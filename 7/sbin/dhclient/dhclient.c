begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: dhclient.c,v 1.63 2005/02/06 17:10:13 krw Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright 2004 Henning Brauer<henning@openbsd.org>  * Copyright (c) 1995, 1996, 1997, 1998, 1999  * The Internet Software Consortium.    All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  *  * This client was substantially modified and enhanced by Elliot Poger  * for use on Linux while he was working on the MosquitoNet project at  * Stanford.  *  * The current version owes much to Elliot's Linux enhancements, but  * was substantially reorganized and partially rewritten by Ted Lemon  * so as to use the same networking framework that the Internet Software  * Consortium DHCP server uses.   Much system-specific configuration code  * was moved into a shell script so that as support for more operating  * systems is added, it will not be necessary to port and maintain  * system-specific configuration code to these operating systems - instead,  * the shell script can invoke the native tools to accomplish the same  * purpose.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"privsep.h"
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_freebsd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_VAREMPTY
end_ifndef

begin_define
define|#
directive|define
name|_PATH_VAREMPTY
value|"/var/empty"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PERIOD
value|0x2e
end_define

begin_define
define|#
directive|define
name|hyphenchar
parameter_list|(
name|c
parameter_list|)
value|((c) == 0x2d)
end_define

begin_define
define|#
directive|define
name|bslashchar
parameter_list|(
name|c
parameter_list|)
value|((c) == 0x5c)
end_define

begin_define
define|#
directive|define
name|periodchar
parameter_list|(
name|c
parameter_list|)
value|((c) == PERIOD)
end_define

begin_define
define|#
directive|define
name|asterchar
parameter_list|(
name|c
parameter_list|)
value|((c) == 0x2a)
end_define

begin_define
define|#
directive|define
name|alphachar
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 0x41&& (c)<= 0x5a) || \ 	    ((c)>= 0x61&& (c)<= 0x7a))
end_define

begin_define
define|#
directive|define
name|digitchar
parameter_list|(
name|c
parameter_list|)
value|((c)>= 0x30&& (c)<= 0x39)
end_define

begin_define
define|#
directive|define
name|whitechar
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|borderchar
parameter_list|(
name|c
parameter_list|)
value|(alphachar(c) || digitchar(c))
end_define

begin_define
define|#
directive|define
name|middlechar
parameter_list|(
name|c
parameter_list|)
value|(borderchar(c) || hyphenchar(c))
end_define

begin_define
define|#
directive|define
name|domainchar
parameter_list|(
name|c
parameter_list|)
value|((c)> 0x20&& (c)< 0x7f)
end_define

begin_define
define|#
directive|define
name|CLIENT_PATH
value|"PATH=/usr/bin:/usr/sbin:/bin:/sbin"
end_define

begin_decl_stmt
name|time_t
name|cur_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|default_lease_time
init|=
literal|43200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12 hours... */
end_comment

begin_decl_stmt
name|char
modifier|*
name|path_dhclient_conf
init|=
name|_PATH_DHCLIENT_CONF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path_dhclient_db
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|log_perror
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|privfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nullfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iaddr
name|iaddr_broadcast
init|=
block|{
literal|4
block|,
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|inaddr_any
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|sockaddr_broadcast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ASSERT_STATE() does nothing now; it used to be  * assert (state_is == state_shouldbe).  */
end_comment

begin_define
define|#
directive|define
name|ASSERT_STATE
parameter_list|(
name|state_is
parameter_list|,
name|state_shouldbe
parameter_list|)
value|{}
end_define

begin_define
define|#
directive|define
name|TIME_MAX
value|2147483647
end_define

begin_decl_stmt
name|int
name|log_priority
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_daemon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unknown_ok
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|routefd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|interface_info
modifier|*
name|ifi
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|findproto
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|sockaddr
modifier|*
name|get_ifa
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|routehandler
parameter_list|(
name|struct
name|protocol
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|check_option
parameter_list|(
name|struct
name|client_lease
modifier|*
name|l
parameter_list|,
name|int
name|option
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|check_classless_option
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ipv4addrs
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|res_hnok
parameter_list|(
specifier|const
name|char
modifier|*
name|dn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|check_search
parameter_list|(
specifier|const
name|char
modifier|*
name|srch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|option_as_string
parameter_list|(
name|unsigned
name|int
name|code
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|fork_privchld
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
end_define

begin_define
define|#
directive|define
name|ADVANCE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(x += ROUNDUP((n)->sa_len))
end_define

begin_decl_stmt
name|time_t
name|scripttime
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|findproto
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|i
operator|&
name|n
condition|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|RTA_IFA
case|:
case|case
name|RTA_DST
case|:
case|case
name|RTA_GATEWAY
case|:
case|case
name|RTA_NETMASK
case|:
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
return|return
name|AF_INET
return|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
return|return
name|AF_INET6
return|;
break|break;
case|case
name|RTA_IFP
case|:
break|break;
block|}
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sockaddr
modifier|*
name|get_ifa
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
condition|;
name|i
operator|<<=
literal|1
control|)
if|if
condition|(
name|i
operator|&
name|n
condition|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|RTA_IFA
condition|)
return|return
operator|(
name|sa
operator|)
return|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|iaddr
name|defaddr
init|=
block|{
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint8_t
name|curbssid
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|disassoc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ifi
init|=
name|arg
decl_stmt|;
comment|/* 	 * Clear existing state. 	 */
if|if
condition|(
name|ifi
operator|->
name|client
operator|->
name|active
operator|!=
name|NULL
condition|)
block|{
name|script_init
argument_list|(
literal|"EXPIRE"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
literal|"old_"
argument_list|,
name|ifi
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifi
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ifi
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|()
expr_stmt|;
block|}
name|ifi
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|routehandler
parameter_list|(
name|struct
name|protocol
modifier|*
name|p
parameter_list|)
block|{
name|char
name|msg
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|;
name|struct
name|ifa_msghdr
modifier|*
name|ifam
decl_stmt|;
name|struct
name|if_announcemsghdr
modifier|*
name|ifan
decl_stmt|;
name|struct
name|ieee80211_join_event
modifier|*
name|jev
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|l
decl_stmt|;
name|time_t
name|t
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|iaddr
name|a
decl_stmt|;
name|ssize_t
name|n
decl_stmt|;
name|n
operator|=
name|read
argument_list|(
name|routefd
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
name|rtm
operator|->
name|rtm_msglen
argument_list|)
operator|||
name|n
operator|<
name|rtm
operator|->
name|rtm_msglen
operator|||
name|rtm
operator|->
name|rtm_version
operator|!=
name|RTM_VERSION
condition|)
return|return;
switch|switch
condition|(
name|rtm
operator|->
name|rtm_type
condition|)
block|{
case|case
name|RTM_NEWADDR
case|:
comment|/* 		 * XXX: If someone other than us adds our address, 		 * we should assume they are taking over from us, 		 * delete the lease record, and exit without modifying 		 * the interface. 		 */
break|break;
case|case
name|RTM_DELADDR
case|:
name|ifam
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
name|rtm
expr_stmt|;
if|if
condition|(
name|ifam
operator|->
name|ifam_index
operator|!=
name|ifi
operator|->
name|index
condition|)
break|break;
if|if
condition|(
name|findproto
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ifam
operator|+
literal|1
operator|)
argument_list|,
name|ifam
operator|->
name|ifam_addrs
argument_list|)
operator|!=
name|AF_INET
condition|)
break|break;
if|if
condition|(
name|scripttime
operator|==
literal|0
operator|||
name|t
operator|<
name|scripttime
operator|+
literal|10
condition|)
break|break;
name|sa
operator|=
name|get_ifa
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ifam
operator|+
literal|1
operator|)
argument_list|,
name|ifam
operator|->
name|ifam_addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
goto|goto
name|die
goto|;
if|if
condition|(
operator|(
name|a
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|a
operator|.
name|iabuf
argument_list|)
condition|)
name|error
argument_list|(
literal|"king bula sez: len mismatch"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
operator|.
name|iabuf
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|,
name|a
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_eq
argument_list|(
name|a
argument_list|,
name|defaddr
argument_list|)
condition|)
break|break;
for|for
control|(
name|l
operator|=
name|ifi
operator|->
name|client
operator|->
name|active
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|addr_eq
argument_list|(
name|a
argument_list|,
name|l
operator|->
name|address
argument_list|)
condition|)
break|break;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
comment|/* deleted addr is not the one we set */
break|break;
goto|goto
name|die
goto|;
case|case
name|RTM_IFINFO
case|:
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|rtm
expr_stmt|;
if|if
condition|(
name|ifm
operator|->
name|ifm_index
operator|!=
name|ifi
operator|->
name|index
condition|)
break|break;
if|if
condition|(
operator|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
goto|goto
name|die
goto|;
break|break;
case|case
name|RTM_IFANNOUNCE
case|:
name|ifan
operator|=
operator|(
expr|struct
name|if_announcemsghdr
operator|*
operator|)
name|rtm
expr_stmt|;
if|if
condition|(
name|ifan
operator|->
name|ifan_what
operator|==
name|IFAN_DEPARTURE
operator|&&
name|ifan
operator|->
name|ifan_index
operator|==
name|ifi
operator|->
name|index
condition|)
goto|goto
name|die
goto|;
break|break;
case|case
name|RTM_IEEE80211
case|:
name|ifan
operator|=
operator|(
expr|struct
name|if_announcemsghdr
operator|*
operator|)
name|rtm
expr_stmt|;
if|if
condition|(
name|ifan
operator|->
name|ifan_index
operator|!=
name|ifi
operator|->
name|index
condition|)
break|break;
switch|switch
condition|(
name|ifan
operator|->
name|ifan_what
condition|)
block|{
case|case
name|RTM_IEEE80211_ASSOC
case|:
case|case
name|RTM_IEEE80211_REASSOC
case|:
comment|/* 			 * Use assoc/reassoc event to kick state machine 			 * in case we roam.  Otherwise fall back to the 			 * normal state machine just like a wired network. 			 */
name|jev
operator|=
operator|(
expr|struct
name|ieee80211_join_event
operator|*
operator|)
operator|&
name|ifan
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|curbssid
argument_list|,
name|jev
operator|->
name|iev_addr
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|disassoc
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
name|state_reboot
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|curbssid
argument_list|,
name|jev
operator|->
name|iev_addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return;
name|die
label|:
name|script_init
argument_list|(
literal|"FAIL"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifi
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ifi
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|fd
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|int
name|pipe_fd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|immediate_daemon
init|=
literal|0
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* Initially, log errors to stderr as well as to syslogd. */
name|openlog
argument_list|(
name|__progname
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|DHCPD_LOG_FACILITY
argument_list|)
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"bc:dl:qu"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|immediate_daemon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|path_dhclient_conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|no_daemon
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|path_dhclient_db
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unknown_ok
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ifi
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|interface_info
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|ifi
operator|->
name|name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|>=
name|IFNAMSIZ
condition|)
name|error
argument_list|(
literal|"Interface name too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_dhclient_db
operator|==
name|NULL
operator|&&
name|asprintf
argument_list|(
operator|&
name|path_dhclient_db
argument_list|,
literal|"%s.%s"
argument_list|,
name|_PATH_DHCLIENT_DB
argument_list|,
name|ifi
operator|->
name|name
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"asprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
name|log_perror
operator|=
literal|0
expr_stmt|;
name|tzset
argument_list|()
expr_stmt|;
name|time
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sockaddr_broadcast
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr_broadcast
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|REMOTE_PORT
argument_list|)
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
name|sockaddr_broadcast
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sockaddr_broadcast
argument_list|)
expr_stmt|;
name|inaddr_any
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|read_client_conf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|interface_link_status
argument_list|(
name|ifi
operator|->
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no link ..."
argument_list|,
name|ifi
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|interface_link_status
argument_list|(
name|ifi
operator|->
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
literal|10
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" giving up\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" got link\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nullfd
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"cannot open %s: %m"
argument_list|,
name|_PATH_DEVNULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
literal|"_dhcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"no such user: _dhcp, falling back to \"nobody\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
literal|"nobody"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no such user: nobody"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|pipe_fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|fork_privchld
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|privfd
operator|=
name|pipe_fd
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path_dhclient_db
argument_list|,
name|O_RDONLY
operator||
name|O_EXLOCK
operator||
name|O_CREAT
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"can't open and lock %s: %m"
argument_list|,
name|path_dhclient_db
argument_list|)
expr_stmt|;
name|read_client_leases
argument_list|()
expr_stmt|;
name|rewrite_client_leases
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|priv_script_init
argument_list|(
literal|"PREINIT"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifi
operator|->
name|client
operator|->
name|alias
condition|)
name|priv_script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ifi
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|priv_script_go
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|routefd
operator|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|add_protocol
argument_list|(
literal|"AF_ROUTE"
argument_list|,
name|routefd
argument_list|,
name|routehandler
argument_list|,
name|ifi
argument_list|)
expr_stmt|;
comment|/* set up the interface */
name|discover_interfaces
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|chroot
argument_list|(
name|_PATH_VAREMPTY
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"chroot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"chdir(\"/\")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
operator|&
name|pw
operator|->
name|pw_gid
argument_list|)
operator|||
name|setegid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
operator|||
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
operator|||
name|seteuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
operator|||
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't drop privileges: %m"
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
name|setproctitle
argument_list|(
literal|"%s"
argument_list|,
name|ifi
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediate_daemon
condition|)
name|go_daemon
argument_list|()
expr_stmt|;
name|ifi
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_reboot
argument_list|(
name|ifi
argument_list|)
expr_stmt|;
name|bootp_packet_handler
operator|=
name|do_packet
expr_stmt|;
name|dispatch
argument_list|()
expr_stmt|;
comment|/* not reached */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-bdqu] "
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[-c conffile] [-l leasefile] interface\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Individual States:  *  * Each routine is called from the dhclient_state_machine() in one of  * these conditions:  * -> entering INIT state  * -> recvpacket_flag == 0: timeout in this state  * -> otherwise: received a packet in this state  *  * Return conditions as handled by dhclient_state_machine():  * Returns 1, sendpacket_flag = 1: send packet, reset timer.  * Returns 1, sendpacket_flag = 0: just reset the timer (wait for a milestone).  * Returns 0: finish the nap which was interrupted for no good reason.  *  * Several per-interface variables are used to keep track of the process:  *   active_lease: the lease that is being used on the interface  *                 (null pointer if not configured yet).  *   offered_leases: leases corresponding to DHCPOFFER messages that have  *                   been sent to us by DHCP servers.  *   acked_leases: leases corresponding to DHCPACK messages that have been  *                 sent to us by DHCP servers.  *   sendpacket: DHCP packet we're trying to send.  *   destination: IP address to send sendpacket to  * In addition, there are several relevant per-lease variables.  *   T1_expiry, T2_expiry, lease_expiry: lease milestones  * In the active lease, these control the process of renewing the lease;  * In leases on the acked_leases list, this simply determines when we  * can no longer legitimately use the lease.  */
end_comment

begin_function
name|void
name|state_reboot
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
comment|/* If we don't remember an active lease, go straight to INIT. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|active
operator|||
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|is_bootp
condition|)
block|{
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We are in the rebooting state. */
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_REBOOTING
expr_stmt|;
comment|/* make_request doesn't initialize xid because it normally comes 	   from the DHCPDISCOVER, but we haven't sent a DHCPDISCOVER, 	   so pick an xid now. */
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|arc4random
argument_list|()
expr_stmt|;
comment|/* Make a DHCPREQUEST packet, and set appropriate per-interface 	   flags. */
name|make_request
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Zap the medium list... */
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
name|NULL
expr_stmt|;
comment|/* Send out the first DHCPREQUEST packet. */
name|send_request
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a lease has completely expired and we've  * been unable to renew it.  */
end_comment

begin_function
name|void
name|state_init
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_INIT
argument_list|)
expr_stmt|;
comment|/* Make a DHCPDISCOVER packet, and set appropriate per-interface 	   flags. */
name|make_discover
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_SELECTING
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Add an immediate timeout to cause the first DHCPDISCOVER packet 	   to go out. */
name|send_discover
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * state_selecting is called when one or more DHCPOFFER packets  * have been received and a configurable period of time has passed.  */
end_comment

begin_function
name|void
name|state_selecting
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|picked
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_SELECTING
argument_list|)
expr_stmt|;
comment|/* Cancel state_selecting and send_discover timeouts, since either 	   one could have got us here. */
name|cancel_timeout
argument_list|(
name|state_selecting
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* We have received one or more DHCPOFFER packets.   Currently, 	   the only criterion by which we judge leases is whether or 	   not we get a response when we arp for them. */
name|picked
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
init|;
name|lp
condition|;
name|lp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
comment|/* Check to see if we got an ARPREPLY for the address 		   in this particular lease. */
if|if
condition|(
operator|!
name|picked
condition|)
block|{
name|script_init
argument_list|(
literal|"ARPCHECK"
argument_list|,
name|lp
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
literal|"check_"
argument_list|,
name|lp
argument_list|)
expr_stmt|;
comment|/* If the ARPCHECK code detects another 			   machine using the offered address, it exits 			   nonzero.  We need to send a DHCPDECLINE and 			   toss the lease. */
if|if
condition|(
name|script_go
argument_list|()
condition|)
block|{
name|make_decline
argument_list|(
name|ip
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|send_decline
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|freeit
goto|;
block|}
name|picked
operator|=
name|lp
expr_stmt|;
name|picked
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|freeit
label|:
name|free_client_lease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|=
name|NULL
expr_stmt|;
comment|/* If we just tossed all the leases we were offered, go back 	   to square one. */
if|if
condition|(
operator|!
name|picked
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it was a BOOTREPLY, we can just take the address right now. */
if|if
condition|(
operator|!
name|picked
operator|->
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|len
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|new
operator|=
name|picked
expr_stmt|;
comment|/* Make up some lease expiry times 		   XXX these should be configurable. */
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|cur_time
operator|+
literal|12000
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|+=
name|cur_time
operator|+
literal|8000
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|+=
name|cur_time
operator|+
literal|10000
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_REQUESTING
expr_stmt|;
comment|/* Bind to the address we received. */
name|bind_lease
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Go to the REQUESTING state. */
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_REQUESTING
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* Make a DHCPREQUEST packet from the lease we picked. */
name|make_request
argument_list|(
name|ip
argument_list|,
name|picked
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
comment|/* Toss the lease we picked - we'll get it back in a DHCPACK. */
name|free_client_lease
argument_list|(
name|picked
argument_list|)
expr_stmt|;
comment|/* Add an immediate timeout to send the first DHCPREQUEST packet. */
name|send_request
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* state_requesting is called when we receive a DHCPACK message after    having sent out one or more DHCPREQUEST packets. */
end_comment

begin_function
name|void
name|dhcpack
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|xid
operator|!=
name|packet
operator|->
name|raw
operator|->
name|xid
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_RENEWING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBINDING
condition|)
return|return;
name|note
argument_list|(
literal|"DHCPACK from %s"
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
name|lease
operator|=
name|packet_to_lease
argument_list|(
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|note
argument_list|(
literal|"packet_to_lease failed."
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|client
operator|->
name|new
operator|=
name|lease
expr_stmt|;
comment|/* Stop resending DHCPREQUEST. */
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* Figure out the lease time. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_LEASE_TIME
index|]
operator|.
name|data
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|getULong
argument_list|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_LEASE_TIME
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|default_lease_time
expr_stmt|;
comment|/* A number that looks negative here is really just very large, 	   because the lease expiry offset is unsigned. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|<
literal|0
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|TIME_MAX
expr_stmt|;
comment|/* XXX should be fixed by resetting the client state */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|<
literal|60
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
literal|60
expr_stmt|;
comment|/* Take the server-provided renewal time if there is one; 	   otherwise figure it out according to the spec. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_RENEWAL_TIME
index|]
operator|.
name|len
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|getULong
argument_list|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_RENEWAL_TIME
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|/
literal|2
expr_stmt|;
comment|/* Same deal with the rebind time. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_REBINDING_TIME
index|]
operator|.
name|len
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|getULong
argument_list|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|options
index|[
name|DHO_DHCP_REBINDING_TIME
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|+
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|/
literal|2
operator|+
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|/
literal|4
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|+=
name|cur_time
expr_stmt|;
comment|/* Lease lengths can never be negative. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|<
name|cur_time
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|expiry
operator|=
name|TIME_MAX
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|+=
name|cur_time
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|<
name|cur_time
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|renewal
operator|=
name|TIME_MAX
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|+=
name|cur_time
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|<
name|cur_time
condition|)
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|rebind
operator|=
name|TIME_MAX
expr_stmt|;
name|bind_lease
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bind_lease
parameter_list|(
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|)
block|{
comment|/* Remember the medium. */
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|medium
expr_stmt|;
comment|/* Write out the new lease. */
name|write_client_lease
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Run the client script with the new parameters. */
name|script_init
argument_list|(
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|?
literal|"BOUND"
else|:
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_RENEWING
condition|?
literal|"RENEW"
else|:
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
condition|?
literal|"REBOOT"
else|:
literal|"REBIND"
operator|)
operator|)
operator|)
argument_list|,
name|ip
operator|->
name|client
operator|->
name|new
operator|->
name|medium
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
condition|)
name|script_write_params
argument_list|(
literal|"old_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
literal|"new_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|()
expr_stmt|;
comment|/* Replace the old active lease with the new one. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|ip
operator|->
name|client
operator|->
name|new
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|new
operator|=
name|NULL
expr_stmt|;
comment|/* Set up a timeout to start the renewal process. */
name|add_timeout
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
argument_list|,
name|state_bound
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|note
argument_list|(
literal|"bound to %s -- renewal in %d seconds."
argument_list|,
name|piaddr
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
operator|-
name|cur_time
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|reinitialize_interfaces
argument_list|()
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * state_bound is called when we've successfully bound to a particular  * lease, but the renewal time on that lease has expired.   We are  * expected to unicast a DHCPREQUEST to the server that gave us our  * original lease.  */
end_comment

begin_function
name|void
name|state_bound
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|ASSERT_STATE
argument_list|(
name|state
argument_list|,
name|S_BOUND
argument_list|)
expr_stmt|;
comment|/* T1 has expired. */
name|make_request
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|options
index|[
name|DHO_DHCP_SERVER_IDENTIFIER
index|]
operator|.
name|len
operator|==
literal|4
condition|)
block|{
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|options
index|[
name|DHO_DHCP_SERVER_IDENTIFIER
index|]
operator|.
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|destination
operator|.
name|len
operator|=
literal|4
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|client
operator|->
name|destination
operator|=
name|iaddr_broadcast
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|=
name|cur_time
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_RENEWING
expr_stmt|;
comment|/* Send the first packet immediately. */
name|send_request
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bootp
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|)
block|{
name|struct
name|iaddrlist
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
name|packet
operator|->
name|raw
operator|->
name|op
operator|!=
name|BOOTREPLY
condition|)
return|return;
comment|/* If there's a reject list, make sure this packet's sender isn't 	   on it. */
for|for
control|(
name|ap
operator|=
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|config
operator|->
name|reject_list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|,
name|ap
operator|->
name|addr
argument_list|)
condition|)
block|{
name|note
argument_list|(
literal|"BOOTREPLY from %s rejected."
argument_list|,
name|piaddr
argument_list|(
name|ap
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|dhcpoffer
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dhcp
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|)
block|{
name|struct
name|iaddrlist
modifier|*
name|ap
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|struct
name|packet
modifier|*
parameter_list|)
function_decl|;
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|packet
operator|->
name|packet_type
condition|)
block|{
case|case
name|DHCPOFFER
case|:
name|handler
operator|=
name|dhcpoffer
expr_stmt|;
name|type
operator|=
literal|"DHCPOFFER"
expr_stmt|;
break|break;
case|case
name|DHCPNAK
case|:
name|handler
operator|=
name|dhcpnak
expr_stmt|;
name|type
operator|=
literal|"DHCPNACK"
expr_stmt|;
break|break;
case|case
name|DHCPACK
case|:
name|handler
operator|=
name|dhcpack
expr_stmt|;
name|type
operator|=
literal|"DHCPACK"
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* If there's a reject list, make sure this packet's sender isn't 	   on it. */
for|for
control|(
name|ap
operator|=
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|config
operator|->
name|reject_list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr_eq
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|,
name|ap
operator|->
name|addr
argument_list|)
condition|)
block|{
name|note
argument_list|(
literal|"%s from %s rejected."
argument_list|,
name|type
argument_list|,
name|piaddr
argument_list|(
name|ap
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
call|(
modifier|*
name|handler
call|)
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dhcpoffer
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|arp_timeout_needed
decl_stmt|,
name|stop_selecting
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|len
condition|?
literal|"DHCPOFFER"
else|:
literal|"BOOTREPLY"
decl_stmt|;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_SELECTING
operator|||
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|xid
operator|!=
name|packet
operator|->
name|raw
operator|->
name|xid
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
return|return;
name|note
argument_list|(
literal|"%s from %s"
argument_list|,
name|name
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this lease doesn't supply the minimum required parameters, 	   blow it off. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|required_options
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|packet
operator|->
name|options
index|[
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|required_options
index|[
name|i
index|]
index|]
operator|.
name|len
condition|)
block|{
name|note
argument_list|(
literal|"%s isn't satisfactory."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we've already seen this lease, don't record it again. */
for|for
control|(
name|lease
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
init|;
name|lease
condition|;
name|lease
operator|=
name|lease
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lease
operator|->
name|address
operator|.
name|len
operator|==
sizeof|sizeof
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"%s already seen."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|lease
operator|=
name|packet_to_lease
argument_list|(
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|note
argument_list|(
literal|"packet_to_lease failed."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this lease was acquired through a BOOTREPLY, record that 	   fact. */
if|if
condition|(
operator|!
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_MESSAGE_TYPE
index|]
operator|.
name|len
condition|)
name|lease
operator|->
name|is_bootp
operator|=
literal|1
expr_stmt|;
comment|/* Record the medium under which this lease was offered. */
name|lease
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|medium
expr_stmt|;
comment|/* Send out an ARP Request for the offered IP address. */
name|script_init
argument_list|(
literal|"ARPSEND"
argument_list|,
name|lease
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
literal|"check_"
argument_list|,
name|lease
argument_list|)
expr_stmt|;
comment|/* If the script can't send an ARP request without waiting, 	   we'll be waiting when we do the ARPCHECK, so don't wait now. */
if|if
condition|(
name|script_go
argument_list|()
condition|)
name|arp_timeout_needed
operator|=
literal|0
expr_stmt|;
else|else
name|arp_timeout_needed
operator|=
literal|2
expr_stmt|;
comment|/* Figure out when we're supposed to stop selecting. */
name|stop_selecting
operator|=
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|select_interval
expr_stmt|;
comment|/* If this is the lease we asked for, put it at the head of the 	   list, and don't mess with the arp request timeout. */
if|if
condition|(
name|lease
operator|->
name|address
operator|.
name|len
operator|==
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|iabuf
argument_list|,
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
argument_list|)
condition|)
block|{
name|lease
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|=
name|lease
expr_stmt|;
block|}
else|else
block|{
comment|/* If we already have an offer, and arping for this 		   offer would take us past the selection timeout, 		   then don't extend the timeout - just hope for the 		   best. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|&&
operator|(
name|cur_time
operator|+
name|arp_timeout_needed
operator|)
operator|>
name|stop_selecting
condition|)
name|arp_timeout_needed
operator|=
literal|0
expr_stmt|;
comment|/* Put the lease at the end of the list. */
name|lease
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|offered_leases
condition|)
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|=
name|lease
expr_stmt|;
else|else
block|{
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|offered_leases
init|;
name|lp
operator|->
name|next
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
empty_stmt|;
comment|/* nothing */
name|lp
operator|->
name|next
operator|=
name|lease
expr_stmt|;
block|}
block|}
comment|/* If we're supposed to stop selecting before we've had time 	   to wait for the ARPREPLY, add some delay to wait for 	   the ARPREPLY. */
if|if
condition|(
name|stop_selecting
operator|-
name|cur_time
operator|<
name|arp_timeout_needed
condition|)
name|stop_selecting
operator|=
name|cur_time
operator|+
name|arp_timeout_needed
expr_stmt|;
comment|/* If the selecting interval has expired, go immediately to 	   state_selecting().  Otherwise, time out into 	   state_selecting at the select interval. */
if|if
condition|(
name|stop_selecting
operator|<=
literal|0
condition|)
name|state_selecting
argument_list|(
name|ip
argument_list|)
expr_stmt|;
else|else
block|{
name|add_timeout
argument_list|(
name|stop_selecting
argument_list|,
name|state_selecting
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_discover
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate a client_lease structure and initialize it from the parameters    in the specified packet. */
end_comment

begin_function
name|struct
name|client_lease
modifier|*
name|packet_to_lease
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|)
block|{
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lease
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_lease
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
block|{
name|warning
argument_list|(
literal|"dhcpoffer: no memory to record lease."
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|lease
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lease
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the lease options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
operator|=
name|malloc
argument_list|(
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
condition|)
block|{
name|warning
argument_list|(
literal|"dhcpoffer: no memory for option %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
operator|=
name|packet
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
index|[
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_option
argument_list|(
name|lease
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* ignore a bogus lease offer */
name|warning
argument_list|(
literal|"Invalid lease option - ignoring offer"
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
name|lease
operator|->
name|address
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
operator|&
name|packet
operator|->
name|raw
operator|->
name|yiaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* If the server name was filled out, copy it. 	   Do not attempt to validate the server name as a host name. 	   RFC 2131 merely states that sname is NUL-terminated (which do 	   do not assume) and that it is the server's host name.  Since 	   the ISC client and server allow arbitrary characters, we do 	   as well. */
if|if
condition|(
operator|(
operator|!
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|len
operator|||
operator|!
operator|(
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|2
operator|)
operator|)
operator|&&
name|packet
operator|->
name|raw
operator|->
name|sname
index|[
literal|0
index|]
condition|)
block|{
name|lease
operator|->
name|server_name
operator|=
name|malloc
argument_list|(
name|DHCP_SNAME_LEN
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|server_name
condition|)
block|{
name|warning
argument_list|(
literal|"dhcpoffer: no memory for server name."
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|lease
operator|->
name|server_name
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|sname
argument_list|,
name|DHCP_SNAME_LEN
argument_list|)
expr_stmt|;
name|lease
operator|->
name|server_name
index|[
name|DHCP_SNAME_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Ditto for the filename. */
if|if
condition|(
operator|(
operator|!
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|len
operator|||
operator|!
operator|(
name|packet
operator|->
name|options
index|[
name|DHO_DHCP_OPTION_OVERLOAD
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|)
operator|&&
name|packet
operator|->
name|raw
operator|->
name|file
index|[
literal|0
index|]
condition|)
block|{
comment|/* Don't count on the NUL terminator. */
name|lease
operator|->
name|filename
operator|=
name|malloc
argument_list|(
name|DHCP_FILE_LEN
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|filename
condition|)
block|{
name|warning
argument_list|(
literal|"dhcpoffer: no memory for filename."
argument_list|)
expr_stmt|;
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|lease
operator|->
name|filename
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|file
argument_list|,
name|DHCP_FILE_LEN
argument_list|)
expr_stmt|;
name|lease
operator|->
name|filename
index|[
name|DHCP_FILE_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|lease
return|;
block|}
end_function

begin_function
name|void
name|dhcpnak
parameter_list|(
name|struct
name|packet
modifier|*
name|packet
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|packet
operator|->
name|interface
decl_stmt|;
comment|/* If we're not receptive to an offer right now, or if the offer 	   has an unrecognizable transaction id, then just drop it. */
if|if
condition|(
name|packet
operator|->
name|interface
operator|->
name|client
operator|->
name|xid
operator|!=
name|packet
operator|->
name|raw
operator|->
name|xid
operator|||
operator|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|hlen
operator|!=
name|packet
operator|->
name|raw
operator|->
name|hlen
operator|)
operator|||
operator|(
name|memcmp
argument_list|(
name|packet
operator|->
name|interface
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|chaddr
argument_list|,
name|packet
operator|->
name|raw
operator|->
name|hlen
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBOOTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_RENEWING
operator|&&
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REBINDING
condition|)
return|return;
name|note
argument_list|(
literal|"DHCPNAK from %s"
argument_list|,
name|piaddr
argument_list|(
name|packet
operator|->
name|client_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|active
condition|)
block|{
name|note
argument_list|(
literal|"DHCPNAK with no active lease.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|NULL
expr_stmt|;
comment|/* Stop sending DHCPREQUEST packets... */
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send out a DHCPDISCOVER packet, and set a timeout to send out another    one after the right interval has expired.  If we don't get an offer by    the time we reach the panic interval, call the panic function. */
end_comment

begin_function
name|void
name|send_discover
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|int
name|interval
decl_stmt|,
name|increase
init|=
literal|1
decl_stmt|;
comment|/* Figure out how long it's been since we started transmitting. */
name|interval
operator|=
name|cur_time
operator|-
name|ip
operator|->
name|client
operator|->
name|first_sending
expr_stmt|;
comment|/* If we're past the panic timeout, call the script and tell it 	   we haven't found anything for this interface yet. */
if|if
condition|(
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|timeout
condition|)
block|{
name|state_panic
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're selecting media, try the whole list before doing 	   the exponential backoff, but if we've already received an 	   offer, stop looping, because we obviously have it right. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|offered_leases
operator|&&
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|media
condition|)
block|{
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|again
label|:
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|medium
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|medium
operator|->
name|next
expr_stmt|;
name|increase
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|medium
condition|)
block|{
if|if
condition|(
name|fail
condition|)
name|error
argument_list|(
literal|"No valid media types for %s!"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|media
expr_stmt|;
name|increase
operator|=
literal|1
expr_stmt|;
block|}
name|note
argument_list|(
literal|"Trying medium \"%s\" %d"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|medium
operator|->
name|string
argument_list|,
name|increase
argument_list|)
expr_stmt|;
name|script_init
argument_list|(
literal|"MEDIUM"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|medium
argument_list|)
expr_stmt|;
if|if
condition|(
name|script_go
argument_list|()
condition|)
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If we're supposed to increase the interval, do so.  If it's 	 * currently zero (i.e., we haven't sent any packets yet), set 	 * it to one; otherwise, add to it a random number between zero 	 * and two times itself.  On average, this means that it will 	 * double with every transmission. 	 */
if|if
condition|(
name|increase
condition|)
block|{
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|interval
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|interval
operator|+=
operator|(
name|arc4random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
operator|(
literal|2
operator|*
name|ip
operator|->
name|client
operator|->
name|interval
operator|)
expr_stmt|;
block|}
comment|/* Don't backoff past cutoff. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
operator|(
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|/
literal|2
operator|)
operator|+
operator|(
operator|(
name|arc4random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|interval
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
comment|/* If the backoff would take us to the panic timeout, just use that 	   as the interval. */
if|if
condition|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|timeout
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
operator|(
name|ip
operator|->
name|client
operator|->
name|first_sending
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|timeout
operator|)
operator|-
name|cur_time
operator|+
literal|1
expr_stmt|;
comment|/* Record the number of seconds since we started sending. */
if|if
condition|(
name|interval
operator|<
literal|65536
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
name|interval
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|secs
operator|=
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
expr_stmt|;
name|note
argument_list|(
literal|"DHCPDISCOVER on %s to %s port %d interval %d"
argument_list|,
name|ip
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_port
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ip
operator|->
name|client
operator|->
name|interval
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
operator|(
name|void
operator|)
name|send_packet
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|inaddr_any
argument_list|,
operator|&
name|sockaddr_broadcast
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
argument_list|,
name|send_discover
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * state_panic gets called if we haven't received any offers in a preset  * amount of time.   When this happens, we try to use existing leases  * that haven't yet expired, and failing that, we call the client script  * and hope it can do something.  */
end_comment

begin_function
name|void
name|state_panic
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|loop
init|=
name|ip
operator|->
name|client
operator|->
name|active
decl_stmt|;
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|;
name|note
argument_list|(
literal|"No DHCPOFFERS received."
argument_list|)
expr_stmt|;
comment|/* We may not have an active lease, but we may have some 	   predefined leases that we can try. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|active
operator|&&
name|ip
operator|->
name|client
operator|->
name|leases
condition|)
goto|goto
name|activate_next
goto|;
comment|/* Run through the list of leases and see if one can be used. */
while|while
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
operator|>
name|cur_time
condition|)
block|{
name|note
argument_list|(
literal|"Trying recorded lease %s"
argument_list|,
name|piaddr
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the client script with the existing 			   parameters. */
name|script_init
argument_list|(
literal|"TIMEOUT"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
literal|"new_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
comment|/* If the old lease is still good and doesn't 			   yet need renewal, go into BOUND state and 			   timeout at the renewal time. */
if|if
condition|(
operator|!
name|script_go
argument_list|()
condition|)
block|{
if|if
condition|(
name|cur_time
operator|<
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|note
argument_list|(
literal|"bound: renewal in %d seconds."
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
operator|-
name|cur_time
argument_list|)
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|renewal
argument_list|,
name|state_bound
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_BOUND
expr_stmt|;
name|note
argument_list|(
literal|"bound: immediate renewal."
argument_list|)
expr_stmt|;
name|state_bound
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|reinitialize_interfaces
argument_list|()
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there are no other leases, give up. */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|leases
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|activate_next
label|:
comment|/* Otherwise, put the active lease at the end of the 		   lease list, and try another lease.. */
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
init|;
name|lp
operator|->
name|next
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
empty_stmt|;
name|lp
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|next
condition|)
name|lp
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
operator|->
name|next
expr_stmt|;
comment|/* If we already tried this lease, we've exhausted the 		   set of leases, so we might as well give up for 		   now. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|==
name|loop
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|loop
condition|)
name|loop
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
block|}
comment|/* No leases were available, or what was available didn't work, so 	   tell the shell script that we failed to allocate an address, 	   and try again later. */
name|note
argument_list|(
literal|"No working leases in persistent database - sleeping.\n"
argument_list|)
expr_stmt|;
name|script_init
argument_list|(
literal|"FAIL"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|()
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|retry_interval
argument_list|,
name|state_init
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|go_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_request
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|struct
name|sockaddr_in
name|destination
decl_stmt|;
name|struct
name|in_addr
name|from
decl_stmt|;
name|int
name|interval
decl_stmt|;
comment|/* Figure out how long it's been since we started transmitting. */
name|interval
operator|=
name|cur_time
operator|-
name|ip
operator|->
name|client
operator|->
name|first_sending
expr_stmt|;
comment|/* If we're in the INIT-REBOOT or REQUESTING state and we're 	   past the reboot timeout, go to INIT and see if we can 	   DISCOVER an address... */
comment|/* XXX In the INIT-REBOOT state, if we don't get an ACK, it 	   means either that we're on a network with no DHCP server, 	   or that our server is down.  In the latter case, assuming 	   that there is a backup DHCP server, DHCPDISCOVER will get 	   us a new address, but we could also have successfully 	   reused our old address.  In the former case, we're hosed 	   anyway.  This is not a win-prone situation. */
if|if
condition|(
operator|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|)
operator|&&
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|reboot_timeout
condition|)
block|{
name|cancel
label|:
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|cancel_timeout
argument_list|(
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're in the reboot state, make sure the media is set up 	   correctly. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|&&
operator|!
name|ip
operator|->
name|client
operator|->
name|medium
operator|&&
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
condition|)
block|{
name|script_init
argument_list|(
literal|"MEDIUM"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
argument_list|)
expr_stmt|;
comment|/* If the medium we chose won't fly, go to INIT state. */
if|if
condition|(
name|script_go
argument_list|()
condition|)
goto|goto
name|cancel
goto|;
comment|/* Record the medium. */
name|ip
operator|->
name|client
operator|->
name|medium
operator|=
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|medium
expr_stmt|;
block|}
comment|/* If the lease has expired, relinquish the address and go back 	   to the INIT state. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|cur_time
operator|>
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
condition|)
block|{
comment|/* Run the client script with the new parameters. */
name|script_init
argument_list|(
literal|"EXPIRE"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|script_write_params
argument_list|(
literal|"old_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|()
expr_stmt|;
comment|/* Now do a preinit on the interface so that we can 		   discover a new address. */
name|script_init
argument_list|(
literal|"PREINIT"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|alias
condition|)
name|script_write_params
argument_list|(
literal|"alias_"
argument_list|,
name|ip
operator|->
name|client
operator|->
name|alias
argument_list|)
expr_stmt|;
name|script_go
argument_list|()
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|state
operator|=
name|S_INIT
expr_stmt|;
name|state_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do the exponential backoff... */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|interval
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|initial_interval
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|interval
operator|+=
operator|(
operator|(
name|arc4random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
operator|(
literal|2
operator|*
name|ip
operator|->
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
comment|/* Don't backoff past cutoff. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
operator|(
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|backoff_cutoff
operator|/
literal|2
operator|)
operator|+
operator|(
operator|(
name|arc4random
argument_list|()
operator|>>
literal|2
operator|)
operator|%
name|ip
operator|->
name|client
operator|->
name|interval
operator|)
operator|)
expr_stmt|;
comment|/* If the backoff would take us to the expiry time, just set the 	   timeout to the expiry time. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
operator|&&
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
operator|>
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
condition|)
name|ip
operator|->
name|client
operator|->
name|interval
operator|=
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
operator|-
name|cur_time
operator|+
literal|1
expr_stmt|;
comment|/* If the lease T2 time has elapsed, or if we're not yet bound, 	   broadcast the DHCPREQUEST rather than unicasting. */
name|memset
argument_list|(
operator|&
name|destination
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|destination
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
operator|||
name|cur_time
operator|>
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|rebind
condition|)
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|client
operator|->
name|destination
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
argument_list|(
name|destination
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|destination
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|REMOTE_PORT
argument_list|)
expr_stmt|;
name|destination
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|destination
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|!=
name|S_REQUESTING
condition|)
name|memcpy
argument_list|(
operator|&
name|from
argument_list|,
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|iabuf
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|from
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* Record the number of seconds since we started sending. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|ip
operator|->
name|client
operator|->
name|secs
expr_stmt|;
else|else
block|{
if|if
condition|(
name|interval
operator|<
literal|65536
condition|)
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
name|interval
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
name|htons
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
block|}
name|note
argument_list|(
literal|"DHCPREQUEST on %s to %s port %d"
argument_list|,
name|ip
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|destination
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|destination
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
operator|(
name|void
operator|)
name|send_packet
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|from
argument_list|,
operator|&
name|destination
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_timeout
argument_list|(
name|cur_time
operator|+
name|ip
operator|->
name|client
operator|->
name|interval
argument_list|,
name|send_request
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_decline
parameter_list|(
name|void
modifier|*
name|ipp
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ipp
decl_stmt|;
name|note
argument_list|(
literal|"DHCPDECLINE on %s to %s port %d"
argument_list|,
name|ip
operator|->
name|name
argument_list|,
name|inet_ntoa
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sockaddr_broadcast
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send out a packet. */
operator|(
name|void
operator|)
name|send_packet
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
name|ip
operator|->
name|client
operator|->
name|packet_length
argument_list|,
name|inaddr_any
argument_list|,
operator|&
name|sockaddr_broadcast
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_discover
parameter_list|(
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|,
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|)
block|{
name|unsigned
name|char
name|discover
init|=
name|DHCPDISCOVER
decl_stmt|;
name|struct
name|tree_cache
modifier|*
name|options
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tree_cache
name|option_elements
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|option_elements
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|option_elements
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set DHCP_MESSAGE_TYPE to DHCPDISCOVER */
name|i
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
operator|&
name|discover
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
name|discover
argument_list|)
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
sizeof|sizeof
argument_list|(
name|discover
argument_list|)
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* Request the options we want */
name|i
operator|=
name|DHO_DHCP_PARAMETER_REQUEST_LIST
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_options
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* If we had an address, try to get it again. */
if|if
condition|(
name|lease
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|=
name|lease
operator|->
name|address
expr_stmt|;
name|i
operator|=
name|DHO_DHCP_REQUESTED_ADDRESS
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|address
operator|.
name|iabuf
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Send any options requested in the config file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|options
index|[
name|i
index|]
operator|&&
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
condition|)
block|{
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
comment|/* send host name if not set via config file. */
name|char
name|hostname
index|[
name|_POSIX_HOST_NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|options
index|[
name|DHO_HOST_NAME
index|]
condition|)
block|{
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|posDot
init|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|posDot
operator|!=
name|NULL
condition|)
name|len
operator|=
name|posDot
operator|-
name|hostname
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|=
operator|&
name|option_elements
index|[
name|DHO_HOST_NAME
index|]
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|value
operator|=
name|hostname
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|buf_size
operator|=
name|len
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
block|}
comment|/* set unique client identifier */
name|char
name|client_ident
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|hardware
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
condition|)
block|{
name|int
name|hwlen
init|=
operator|(
name|ip
operator|->
name|hw_address
operator|.
name|hlen
operator|<
sizeof|sizeof
argument_list|(
name|client_ident
argument_list|)
operator|-
literal|1
operator|)
condition|?
name|ip
operator|->
name|hw_address
operator|.
name|hlen
else|:
sizeof|sizeof
argument_list|(
name|client_ident
argument_list|)
operator|-
literal|1
decl_stmt|;
name|client_ident
index|[
literal|0
index|]
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|client_ident
index|[
literal|1
index|]
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|hwlen
argument_list|)
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|=
operator|&
name|option_elements
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|value
operator|=
name|client_ident
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|len
operator|=
name|hwlen
operator|+
literal|1
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|buf_size
operator|=
name|hwlen
operator|+
literal|1
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
comment|/* Set up the option buffer... */
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
name|NULL
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* filled in by send_discover. */
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_request
parameter_list|(
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|,
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|)
block|{
name|unsigned
name|char
name|request
init|=
name|DHCPREQUEST
decl_stmt|;
name|struct
name|tree_cache
modifier|*
name|options
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tree_cache
name|option_elements
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set DHCP_MESSAGE_TYPE to DHCPREQUEST */
name|i
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
operator|&
name|request
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
sizeof|sizeof
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* Request the options we want */
name|i
operator|=
name|DHO_DHCP_PARAMETER_REQUEST_LIST
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_options
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|requested_option_count
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* If we are requesting an address that hasn't yet been assigned 	   to us, use the DHCP Requested Address option. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
condition|)
block|{
comment|/* Send back the server identifier... */
name|i
operator|=
name|DHO_DHCP_SERVER_IDENTIFIER
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REQUESTING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBOOTING
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|=
name|lease
operator|->
name|address
expr_stmt|;
name|i
operator|=
name|DHO_DHCP_REQUESTED_ADDRESS
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|address
operator|.
name|iabuf
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|client
operator|->
name|requested_address
operator|.
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Send any options requested in the config file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|options
index|[
name|i
index|]
operator|&&
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
condition|)
block|{
name|options
index|[
name|i
index|]
operator|=
operator|&
name|option_elements
index|[
name|i
index|]
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
comment|/* send host name if not set via config file. */
name|char
name|hostname
index|[
name|_POSIX_HOST_NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|options
index|[
name|DHO_HOST_NAME
index|]
condition|)
block|{
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|posDot
init|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|posDot
operator|!=
name|NULL
condition|)
name|len
operator|=
name|posDot
operator|-
name|hostname
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|=
operator|&
name|option_elements
index|[
name|DHO_HOST_NAME
index|]
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|value
operator|=
name|hostname
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|buf_size
operator|=
name|len
expr_stmt|;
name|options
index|[
name|DHO_HOST_NAME
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
block|}
comment|/* set unique client identifier */
name|char
name|client_ident
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|hardware
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
condition|)
block|{
name|int
name|hwlen
init|=
operator|(
name|ip
operator|->
name|hw_address
operator|.
name|hlen
operator|<
sizeof|sizeof
argument_list|(
name|client_ident
argument_list|)
operator|-
literal|1
operator|)
condition|?
name|ip
operator|->
name|hw_address
operator|.
name|hlen
else|:
sizeof|sizeof
argument_list|(
name|client_ident
argument_list|)
operator|-
literal|1
decl_stmt|;
name|client_ident
index|[
literal|0
index|]
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|client_ident
index|[
literal|1
index|]
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|hwlen
argument_list|)
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|=
operator|&
name|option_elements
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|value
operator|=
name|client_ident
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|len
operator|=
name|hwlen
operator|+
literal|1
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|buf_size
operator|=
name|hwlen
operator|+
literal|1
expr_stmt|;
name|options
index|[
name|DHO_DHCP_CLIENT_IDENTIFIER
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
comment|/* Set up the option buffer... */
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
name|NULL
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|xid
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* Filled in by send_request. */
comment|/* If we own the address we're requesting, put it in ciaddr; 	   otherwise set ciaddr to zero. */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_BOUND
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_RENEWING
operator|||
name|ip
operator|->
name|client
operator|->
name|state
operator|==
name|S_REBINDING
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_decline
parameter_list|(
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|,
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|)
block|{
name|struct
name|tree_cache
modifier|*
name|options
index|[
literal|256
index|]
decl_stmt|,
name|message_type_tree
decl_stmt|;
name|struct
name|tree_cache
name|requested_address_tree
decl_stmt|;
name|struct
name|tree_cache
name|server_id_tree
decl_stmt|,
name|client_id_tree
decl_stmt|;
name|unsigned
name|char
name|decline
init|=
name|DHCPDECLINE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set DHCP_MESSAGE_TYPE to DHCPDECLINE */
name|i
operator|=
name|DHO_DHCP_MESSAGE_TYPE
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|message_type_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
operator|&
name|decline
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
name|decline
argument_list|)
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
sizeof|sizeof
argument_list|(
name|decline
argument_list|)
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* Send back the server identifier... */
name|i
operator|=
name|DHO_DHCP_SERVER_IDENTIFIER
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|server_id_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* Send back the address we're declining. */
name|i
operator|=
name|DHO_DHCP_REQUESTED_ADDRESS
expr_stmt|;
name|options
index|[
name|i
index|]
operator|=
operator|&
name|requested_address_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|lease
operator|->
name|address
operator|.
name|iabuf
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|lease
operator|->
name|address
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* Send the uid if the user supplied one. */
name|i
operator|=
name|DHO_DHCP_CLIENT_IDENTIFIER
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|options
index|[
name|i
index|]
operator|=
operator|&
name|client_id_tree
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|value
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|buf_size
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|send_options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|options
index|[
name|i
index|]
operator|->
name|timeout
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
comment|/* Set up the option buffer... */
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|cons_options
argument_list|(
name|NULL
argument_list|,
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
argument_list|,
literal|0
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|<
name|BOOTP_MIN_LEN
condition|)
name|ip
operator|->
name|client
operator|->
name|packet_length
operator|=
name|BOOTP_MIN_LEN
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|htype
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|htype
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hlen
operator|=
name|ip
operator|->
name|hw_address
operator|.
name|hlen
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|xid
operator|=
name|ip
operator|->
name|client
operator|->
name|xid
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* Filled in by send_request. */
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* ciaddr must always be zero. */
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|ciaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|yiaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|siaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|giaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|packet
operator|.
name|chaddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|haddr
argument_list|,
name|ip
operator|->
name|hw_address
operator|.
name|hlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_client_lease
parameter_list|(
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|free
argument_list|(
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|free
argument_list|(
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
name|free
argument_list|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|FILE
modifier|*
name|leaseFile
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rewrite_client_leases
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|client_lease
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
block|{
name|leaseFile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
name|error
argument_list|(
literal|"can't create %s: %m"
argument_list|,
name|path_dhclient_db
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fflush
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|ifi
operator|->
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
name|write_client_lease
argument_list|(
name|ifi
argument_list|,
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifi
operator|->
name|client
operator|->
name|active
condition|)
name|write_client_lease
argument_list|(
name|ifi
argument_list|,
name|ifi
operator|->
name|client
operator|->
name|active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|leaseFile
argument_list|)
argument_list|,
name|ftello
argument_list|(
name|leaseFile
argument_list|)
argument_list|)
expr_stmt|;
name|fsync
argument_list|(
name|fileno
argument_list|(
name|leaseFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_client_lease
parameter_list|(
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|,
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|,
name|int
name|rewrite
parameter_list|)
block|{
specifier|static
name|int
name|leases_written
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rewrite
condition|)
block|{
if|if
condition|(
name|leases_written
operator|++
operator|>
literal|20
condition|)
block|{
name|rewrite_client_leases
argument_list|()
expr_stmt|;
name|leases_written
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the lease came from the config file, we don't need to stash 	   a copy in the lease database. */
if|if
condition|(
name|lease
operator|->
name|is_static
condition|)
return|return;
if|if
condition|(
operator|!
name|leaseFile
condition|)
block|{
comment|/* XXX */
name|leaseFile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaseFile
condition|)
name|error
argument_list|(
literal|"can't create %s: %m"
argument_list|,
name|path_dhclient_db
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"lease {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|is_bootp
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  bootp;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  interface \"%s\";\n"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  fixed-address %s;\n"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  filename \"%s\";\n"
argument_list|,
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  server-name \"%s\";\n"
argument_list|,
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|medium
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  medium \"%s\";\n"
argument_list|,
name|lease
operator|->
name|medium
operator|->
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  option %s %s;\n"
argument_list|,
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pretty_print_option
argument_list|(
name|i
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|renewal
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  renew %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|rebind
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  rebind %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|lease
operator|->
name|expiry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"  expire %d %d/%d/%d %02d:%02d:%02d;\n"
argument_list|,
name|t
operator|->
name|tm_wday
argument_list|,
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|leaseFile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|leaseFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|script_init
parameter_list|(
name|char
modifier|*
name|reason
parameter_list|,
name|struct
name|string_list
modifier|*
name|medium
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|mediumlen
init|=
literal|0
decl_stmt|;
name|struct
name|imsg_hdr
name|hdr
decl_stmt|;
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
name|int
name|errs
decl_stmt|;
if|if
condition|(
name|medium
operator|!=
name|NULL
operator|&&
name|medium
operator|->
name|string
operator|!=
name|NULL
condition|)
name|mediumlen
operator|=
name|strlen
argument_list|(
name|medium
operator|->
name|string
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|code
operator|=
name|IMSG_SCRIPT_INIT
expr_stmt|;
name|hdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|imsg_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|mediumlen
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|strlen
argument_list|(
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|buf_open
argument_list|(
name|hdr
operator|.
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"buf_open: %m"
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|0
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|mediumlen
argument_list|,
sizeof|sizeof
argument_list|(
name|mediumlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mediumlen
operator|>
literal|0
condition|)
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
name|medium
operator|->
name|string
argument_list|,
name|mediumlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
name|reason
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|errs
condition|)
name|error
argument_list|(
literal|"buf_add: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_close
argument_list|(
name|privfd
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"buf_close: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|priv_script_init
parameter_list|(
name|char
modifier|*
name|reason
parameter_list|,
name|char
modifier|*
name|medium
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ifi
decl_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|scriptEnvsize
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|scriptEnv
operator|==
name|NULL
condition|)
name|ip
operator|->
name|client
operator|->
name|scriptEnv
operator|=
name|malloc
argument_list|(
name|ip
operator|->
name|client
operator|->
name|scriptEnvsize
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|scriptEnv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"script_init: no memory for environment"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|scriptEnv
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|CLIENT_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|scriptEnv
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"script_init: no memory for environment"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|scriptEnv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|""
argument_list|,
literal|"interface"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|medium
condition|)
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|""
argument_list|,
literal|"medium"
argument_list|,
name|medium
argument_list|)
expr_stmt|;
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|""
argument_list|,
literal|"reason"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|priv_script_write_params
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ifi
decl_stmt|;
name|u_int8_t
name|dbuf
index|[
literal|1500
index|]
decl_stmt|,
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
name|tbuf
index|[
literal|128
index|]
decl_stmt|;
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"ip_address"
argument_list|,
name|piaddr
argument_list|(
name|lease
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|default_actions
index|[
name|DHO_SUBNET_MASK
index|]
operator|==
name|ACTION_SUPERSEDE
condition|)
block|{
name|dp
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|lease
operator|->
name|options
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|DHO_SUBNET_MASK
index|]
operator|.
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|&&
operator|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|)
operator|)
condition|)
block|{
name|struct
name|iaddr
name|netmask
decl_stmt|,
name|subnet
decl_stmt|,
name|broadcast
decl_stmt|;
name|memcpy
argument_list|(
name|netmask
operator|.
name|iabuf
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|netmask
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|subnet
operator|=
name|subnet_number
argument_list|(
name|lease
operator|->
name|address
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|subnet
operator|.
name|len
condition|)
block|{
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"network_number"
argument_list|,
name|piaddr
argument_list|(
name|subnet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
operator|->
name|options
index|[
name|DHO_BROADCAST_ADDRESS
index|]
operator|.
name|len
condition|)
block|{
name|broadcast
operator|=
name|broadcast_addr
argument_list|(
name|subnet
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|broadcast
operator|.
name|len
condition|)
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"broadcast_address"
argument_list|,
name|piaddr
argument_list|(
name|broadcast
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lease
operator|->
name|filename
condition|)
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"filename"
argument_list|,
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
condition|)
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"server_name"
argument_list|,
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
switch|switch
condition|(
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|default_actions
index|[
name|i
index|]
condition|)
block|{
case|case
name|ACTION_DEFAULT
case|:
name|dp
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|ACTION_SUPERSEDE
case|:
name|supersede
label|:
name|dp
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|ACTION_PREPEND
case|:
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
operator|+
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"no space to %s %s"
argument_list|,
literal|"prepend option"
argument_list|,
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
goto|goto
name|supersede
goto|;
block|}
name|dp
operator|=
name|dbuf
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|dp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ACTION_APPEND
case|:
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
operator|+
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"no space to %s %s"
argument_list|,
literal|"append option"
argument_list|,
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
goto|goto
name|supersede
goto|;
block|}
name|dp
operator|=
name|dbuf
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
operator|+
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|dp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|dp
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|defaults
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|len
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|dp
operator|=
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|dhcp_option_ev_name
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|dhcp_options
index|[
name|i
index|]
argument_list|)
condition|)
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
name|pretty_print_option
argument_list|(
name|i
argument_list|,
name|dp
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|lease
operator|->
name|expiry
argument_list|)
expr_stmt|;
name|script_set_env
argument_list|(
name|ip
operator|->
name|client
argument_list|,
name|prefix
argument_list|,
literal|"expiry"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|script_write_params
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|)
block|{
name|size_t
name|fn_len
init|=
literal|0
decl_stmt|,
name|sn_len
init|=
literal|0
decl_stmt|,
name|pr_len
init|=
literal|0
decl_stmt|;
name|struct
name|imsg_hdr
name|hdr
decl_stmt|;
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
name|int
name|errs
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|lease
operator|->
name|filename
operator|!=
name|NULL
condition|)
name|fn_len
operator|=
name|strlen
argument_list|(
name|lease
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|lease
operator|->
name|server_name
operator|!=
name|NULL
condition|)
name|sn_len
operator|=
name|strlen
argument_list|(
name|lease
operator|->
name|server_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
name|pr_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|code
operator|=
name|IMSG_SCRIPT_WRITE_PARAMS
expr_stmt|;
name|hdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|client_lease
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|fn_len
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|sn_len
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|pr_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|hdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|scripttime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|buf_open
argument_list|(
name|hdr
operator|.
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"buf_open: %m"
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|0
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
name|lease
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|client_lease
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|fn_len
argument_list|,
sizeof|sizeof
argument_list|(
name|fn_len
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
name|lease
operator|->
name|filename
argument_list|,
name|fn_len
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|sn_len
argument_list|,
sizeof|sizeof
argument_list|(
name|sn_len
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
name|lease
operator|->
name|server_name
argument_list|,
name|sn_len
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|pr_len
argument_list|,
sizeof|sizeof
argument_list|(
name|pr_len
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
name|prefix
argument_list|,
name|pr_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|buf_add
argument_list|(
name|buf
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|lease
operator|->
name|options
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
name|error
argument_list|(
literal|"buf_add: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_close
argument_list|(
name|privfd
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"buf_close: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|script_go
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|imsg_hdr
name|hdr
decl_stmt|;
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|scripttime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|code
operator|=
name|IMSG_SCRIPT_GO
expr_stmt|;
name|hdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|imsg_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|buf_open
argument_list|(
name|hdr
operator|.
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"buf_open: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_add
argument_list|(
name|buf
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"buf_add: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_close
argument_list|(
name|privfd
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"buf_close: %m"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|buf_read
argument_list|(
name|privfd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|code
operator|!=
name|IMSG_SCRIPT_GO_RET
condition|)
name|error
argument_list|(
literal|"unexpected msg type %u"
argument_list|,
name|hdr
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|error
argument_list|(
literal|"received corrupted message"
argument_list|)
expr_stmt|;
name|buf_read
argument_list|(
name|privfd
argument_list|,
operator|&
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|priv_script_go
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|scriptName
decl_stmt|,
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
modifier|*
name|envp
decl_stmt|,
modifier|*
name|epp
index|[
literal|3
index|]
decl_stmt|,
name|reason
index|[]
init|=
literal|"REASON=NBI"
decl_stmt|;
specifier|static
name|char
name|client_path
index|[]
init|=
name|CLIENT_PATH
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
init|=
name|ifi
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|wpid
decl_stmt|,
name|wstatus
decl_stmt|;
name|scripttime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|scriptName
operator|=
name|ip
operator|->
name|client
operator|->
name|config
operator|->
name|script_name
expr_stmt|;
name|envp
operator|=
name|ip
operator|->
name|client
operator|->
name|scriptEnv
expr_stmt|;
block|}
else|else
block|{
name|scriptName
operator|=
name|top_level_config
operator|.
name|script_name
expr_stmt|;
name|epp
index|[
literal|0
index|]
operator|=
name|reason
expr_stmt|;
name|epp
index|[
literal|1
index|]
operator|=
name|client_path
expr_stmt|;
name|epp
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|envp
operator|=
name|epp
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
name|scriptName
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fork: %m"
argument_list|)
expr_stmt|;
name|wstatus
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
condition|)
block|{
do|do
block|{
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wpid
operator|!=
name|pid
operator|&&
name|wpid
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|wpid
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"wait: %m"
argument_list|)
expr_stmt|;
name|wstatus
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|execve
argument_list|(
name|scriptName
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"execve (%s, ...): %m"
argument_list|,
name|scriptName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
condition|)
name|script_flush_env
argument_list|(
name|ip
operator|->
name|client
argument_list|)
expr_stmt|;
return|return
operator|(
name|wstatus
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
name|void
name|script_set_env
parameter_list|(
name|struct
name|client_state
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|namelen
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|&&
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
index|[
name|namelen
index|]
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
condition|)
comment|/* Reuse the slot. */
name|free
argument_list|(
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* New variable.  Expand if necessary. */
if|if
condition|(
name|i
operator|>=
name|client
operator|->
name|scriptEnvsize
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
modifier|*
name|newscriptEnv
decl_stmt|;
name|int
name|newscriptEnvsize
init|=
name|client
operator|->
name|scriptEnvsize
operator|+
literal|50
decl_stmt|;
name|newscriptEnv
operator|=
name|realloc
argument_list|(
name|client
operator|->
name|scriptEnv
argument_list|,
name|newscriptEnvsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newscriptEnv
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|client
operator|->
name|scriptEnv
argument_list|)
expr_stmt|;
name|client
operator|->
name|scriptEnv
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|scriptEnvsize
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"script_set_env: no memory for variable"
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|scriptEnv
operator|=
name|newscriptEnv
expr_stmt|;
name|client
operator|->
name|scriptEnvsize
operator|=
name|newscriptEnvsize
expr_stmt|;
block|}
comment|/* need to set the NULL pointer at end of array beyond 		   the new slot. */
name|client
operator|->
name|scriptEnv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Allocate space and format the variable in the appropriate slot. */
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"script_set_env: no memory for variable assignment"
argument_list|)
expr_stmt|;
comment|/* No `` or $() command substitution allowed in environment values! */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen
argument_list|(
name|value
argument_list|)
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|value
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'`'
case|:
case|case
literal|'$'
case|:
name|error
argument_list|(
literal|"illegal character (%c) in value '%s'"
argument_list|,
name|value
index|[
name|j
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* not reached */
block|}
name|snprintf
argument_list|(
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|,
literal|"%s%s=%s"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|script_flush_env
parameter_list|(
name|struct
name|client_state
modifier|*
name|client
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|client
operator|->
name|scriptEnv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|client
operator|->
name|scriptEnvsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dhcp_option_ev_name
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|struct
name|option
modifier|*
name|option
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|option
operator|->
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|buflen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|option
operator|->
name|name
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
else|else
name|buf
index|[
name|i
index|]
operator|=
name|option
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|go_daemon
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|no_daemon
operator|||
name|state
condition|)
return|return;
name|state
operator|=
literal|1
expr_stmt|;
comment|/* Stop logging to stderr... */
name|log_perror
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|daemon
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"daemon"
argument_list|)
expr_stmt|;
comment|/* we are chrooted, daemon(3) fails to open /dev/null */
if|if
condition|(
name|nullfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|nullfd
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|nullfd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|nullfd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|nullfd
argument_list|)
expr_stmt|;
name|nullfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|check_option
parameter_list|(
name|struct
name|client_lease
modifier|*
name|l
parameter_list|,
name|int
name|option
parameter_list|)
block|{
name|char
modifier|*
name|opbuf
decl_stmt|;
name|char
modifier|*
name|sbuf
decl_stmt|;
comment|/* we use this, since this is what gets passed to dhclient-script */
name|opbuf
operator|=
name|pretty_print_option
argument_list|(
name|option
argument_list|,
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|data
argument_list|,
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbuf
operator|=
name|option_as_string
argument_list|(
name|option
argument_list|,
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|data
argument_list|,
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|DHO_SUBNET_MASK
case|:
case|case
name|DHO_TIME_SERVERS
case|:
case|case
name|DHO_NAME_SERVERS
case|:
case|case
name|DHO_ROUTERS
case|:
case|case
name|DHO_DOMAIN_NAME_SERVERS
case|:
case|case
name|DHO_LOG_SERVERS
case|:
case|case
name|DHO_COOKIE_SERVERS
case|:
case|case
name|DHO_LPR_SERVERS
case|:
case|case
name|DHO_IMPRESS_SERVERS
case|:
case|case
name|DHO_RESOURCE_LOCATION_SERVERS
case|:
case|case
name|DHO_SWAP_SERVER
case|:
case|case
name|DHO_BROADCAST_ADDRESS
case|:
case|case
name|DHO_NIS_SERVERS
case|:
case|case
name|DHO_NTP_SERVERS
case|:
case|case
name|DHO_NETBIOS_NAME_SERVERS
case|:
case|case
name|DHO_NETBIOS_DD_SERVER
case|:
case|case
name|DHO_FONT_SERVERS
case|:
case|case
name|DHO_DHCP_SERVER_IDENTIFIER
case|:
case|case
name|DHO_NISPLUS_SERVERS
case|:
case|case
name|DHO_MOBILE_IP_HOME_AGENT
case|:
case|case
name|DHO_SMTP_SERVER
case|:
case|case
name|DHO_POP_SERVER
case|:
case|case
name|DHO_NNTP_SERVER
case|:
case|case
name|DHO_WWW_SERVER
case|:
case|case
name|DHO_FINGER_SERVER
case|:
case|case
name|DHO_IRC_SERVER
case|:
case|case
name|DHO_STREETTALK_SERVER
case|:
case|case
name|DHO_STREETTALK_DA_SERVER
case|:
if|if
condition|(
operator|!
name|ipv4addrs
argument_list|(
name|opbuf
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Invalid IP address in option: %s"
argument_list|,
name|opbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|DHO_HOST_NAME
case|:
case|case
name|DHO_NIS_DOMAIN
case|:
case|case
name|DHO_NISPLUS_DOMAIN
case|:
case|case
name|DHO_TFTP_SERVER_NAME
case|:
if|if
condition|(
operator|!
name|res_hnok
argument_list|(
name|sbuf
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Bogus Host Name option %d: %s (%s)"
argument_list|,
name|option
argument_list|,
name|sbuf
argument_list|,
name|opbuf
argument_list|)
expr_stmt|;
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|DHO_DOMAIN_NAME
case|:
if|if
condition|(
operator|!
name|res_hnok
argument_list|(
name|sbuf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|check_search
argument_list|(
name|sbuf
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Bogus domain search list %d: %s (%s)"
argument_list|,
name|option
argument_list|,
name|sbuf
argument_list|,
name|opbuf
argument_list|)
expr_stmt|;
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|DHO_PAD
case|:
case|case
name|DHO_TIME_OFFSET
case|:
case|case
name|DHO_BOOT_SIZE
case|:
case|case
name|DHO_MERIT_DUMP
case|:
case|case
name|DHO_ROOT_PATH
case|:
case|case
name|DHO_EXTENSIONS_PATH
case|:
case|case
name|DHO_IP_FORWARDING
case|:
case|case
name|DHO_NON_LOCAL_SOURCE_ROUTING
case|:
case|case
name|DHO_POLICY_FILTER
case|:
case|case
name|DHO_MAX_DGRAM_REASSEMBLY
case|:
case|case
name|DHO_DEFAULT_IP_TTL
case|:
case|case
name|DHO_PATH_MTU_AGING_TIMEOUT
case|:
case|case
name|DHO_PATH_MTU_PLATEAU_TABLE
case|:
case|case
name|DHO_INTERFACE_MTU
case|:
case|case
name|DHO_ALL_SUBNETS_LOCAL
case|:
case|case
name|DHO_PERFORM_MASK_DISCOVERY
case|:
case|case
name|DHO_MASK_SUPPLIER
case|:
case|case
name|DHO_ROUTER_DISCOVERY
case|:
case|case
name|DHO_ROUTER_SOLICITATION_ADDRESS
case|:
case|case
name|DHO_STATIC_ROUTES
case|:
case|case
name|DHO_TRAILER_ENCAPSULATION
case|:
case|case
name|DHO_ARP_CACHE_TIMEOUT
case|:
case|case
name|DHO_IEEE802_3_ENCAPSULATION
case|:
case|case
name|DHO_DEFAULT_TCP_TTL
case|:
case|case
name|DHO_TCP_KEEPALIVE_INTERVAL
case|:
case|case
name|DHO_TCP_KEEPALIVE_GARBAGE
case|:
case|case
name|DHO_VENDOR_ENCAPSULATED_OPTIONS
case|:
case|case
name|DHO_NETBIOS_NODE_TYPE
case|:
case|case
name|DHO_NETBIOS_SCOPE
case|:
case|case
name|DHO_X_DISPLAY_MANAGER
case|:
case|case
name|DHO_DHCP_REQUESTED_ADDRESS
case|:
case|case
name|DHO_DHCP_LEASE_TIME
case|:
case|case
name|DHO_DHCP_OPTION_OVERLOAD
case|:
case|case
name|DHO_DHCP_MESSAGE_TYPE
case|:
case|case
name|DHO_DHCP_PARAMETER_REQUEST_LIST
case|:
case|case
name|DHO_DHCP_MESSAGE
case|:
case|case
name|DHO_DHCP_MAX_MESSAGE_SIZE
case|:
case|case
name|DHO_DHCP_RENEWAL_TIME
case|:
case|case
name|DHO_DHCP_REBINDING_TIME
case|:
case|case
name|DHO_DHCP_CLASS_IDENTIFIER
case|:
case|case
name|DHO_DHCP_CLIENT_IDENTIFIER
case|:
case|case
name|DHO_BOOTFILE_NAME
case|:
case|case
name|DHO_DHCP_USER_CLASS_ID
case|:
case|case
name|DHO_END
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|DHO_CLASSLESS_ROUTES
case|:
return|return
operator|(
name|check_classless_option
argument_list|(
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|data
argument_list|,
name|l
operator|->
name|options
index|[
name|option
index|]
operator|.
name|len
argument_list|)
operator|)
return|;
default|default:
name|warning
argument_list|(
literal|"unknown dhcp option value 0x%x"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_ok
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* RFC 3442 The Classless Static Routes option checks */
end_comment

begin_function
name|int
name|check_classless_option
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|width
decl_stmt|;
name|in_addr_t
name|addr
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|5
condition|)
block|{
name|warning
argument_list|(
literal|"Too small length: %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|width
operator|=
name|data
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|width
operator|<
literal|9
condition|)
block|{
name|addr
operator|=
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
index|]
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|<
literal|17
condition|)
block|{
name|addr
operator|=
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
index|]
operator|<<
literal|24
argument_list|)
operator|+
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|<
literal|25
condition|)
block|{
name|addr
operator|=
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
index|]
operator|<<
literal|24
argument_list|)
operator|+
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
argument_list|)
operator|+
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|<
literal|33
condition|)
block|{
name|addr
operator|=
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
index|]
operator|<<
literal|24
argument_list|)
operator|+
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
argument_list|)
operator|+
call|(
name|in_addr_t
call|)
argument_list|(
name|data
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
argument_list|)
operator|+
name|data
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"Incorrect subnet width: %d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mask
operator|=
call|(
name|in_addr_t
call|)
argument_list|(
operator|~
literal|0
argument_list|)
operator|<<
operator|(
literal|32
operator|-
name|width
operator|)
expr_stmt|;
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ntohl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* 		 * From RFC 3442: 		 * ... After deriving a subnet number and subnet mask 		 * from each destination descriptor, the DHCP client 		 * MUST zero any bits in the subnet number where the 		 * corresponding bit in the mask is zero... 		 */
if|if
condition|(
operator|(
name|addr
operator|&
name|mask
operator|)
operator|!=
name|addr
condition|)
block|{
name|addr
operator|&=
name|mask
expr_stmt|;
name|data
index|[
name|i
operator|-
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|addr
operator|>>
operator|(
operator|(
operator|(
literal|32
operator|-
name|width
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|len
condition|)
block|{
name|warning
argument_list|(
literal|"Incorrect data length: %d (must be %d)"
argument_list|,
name|len
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|res_hnok
parameter_list|(
specifier|const
name|char
modifier|*
name|dn
parameter_list|)
block|{
name|int
name|pch
init|=
name|PERIOD
decl_stmt|,
name|ch
init|=
operator|*
name|dn
operator|++
decl_stmt|;
while|while
condition|(
name|ch
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|nch
init|=
operator|*
name|dn
operator|++
decl_stmt|;
if|if
condition|(
name|periodchar
argument_list|(
name|ch
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|periodchar
argument_list|(
name|pch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|borderchar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|periodchar
argument_list|(
name|nch
argument_list|)
operator|||
name|nch
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|borderchar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|middlechar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pch
operator|=
name|ch
operator|,
name|ch
operator|=
name|nch
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|check_search
parameter_list|(
specifier|const
name|char
modifier|*
name|srch
parameter_list|)
block|{
name|int
name|pch
init|=
name|PERIOD
decl_stmt|,
name|ch
init|=
operator|*
name|srch
operator|++
decl_stmt|;
name|int
name|domains
init|=
literal|1
decl_stmt|;
comment|/* 256 char limit re resolv.conf(5) */
if|if
condition|(
name|strlen
argument_list|(
name|srch
argument_list|)
operator|>
literal|256
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|whitechar
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
operator|*
name|srch
operator|++
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|nch
init|=
operator|*
name|srch
operator|++
decl_stmt|;
if|if
condition|(
name|periodchar
argument_list|(
name|ch
argument_list|)
operator|||
name|whitechar
argument_list|(
name|ch
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|periodchar
argument_list|(
name|pch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|borderchar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|periodchar
argument_list|(
name|nch
argument_list|)
operator|||
name|nch
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|borderchar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|middlechar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|whitechar
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|pch
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|whitechar
argument_list|(
name|nch
argument_list|)
condition|)
block|{
name|nch
operator|=
operator|*
name|srch
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nch
operator|!=
literal|'\0'
condition|)
name|domains
operator|++
expr_stmt|;
name|pch
operator|=
name|PERIOD
expr_stmt|;
block|}
name|ch
operator|=
name|nch
expr_stmt|;
block|}
comment|/* 6 domain limit re resolv.conf(5) */
if|if
condition|(
name|domains
operator|>
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Does buf consist only of dotted decimal ipv4 addrs?  * return how many if so,  * otherwise, return 0  */
end_comment

begin_function
name|int
name|ipv4addrs
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|in_addr
name|jnk
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|jnk
argument_list|)
operator|==
literal|1
condition|)
block|{
name|count
operator|++
expr_stmt|;
while|while
condition|(
name|periodchar
argument_list|(
operator|*
name|buf
argument_list|)
operator|||
name|digitchar
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
name|buf
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|count
operator|)
return|;
while|while
condition|(
operator|*
name|buf
operator|==
literal|' '
condition|)
name|buf
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|option_as_string
parameter_list|(
name|unsigned
name|int
name|code
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|static
name|char
name|optbuf
index|[
literal|32768
index|]
decl_stmt|;
comment|/* XXX */
name|char
modifier|*
name|op
init|=
name|optbuf
decl_stmt|;
name|int
name|opleft
init|=
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|code
operator|>
literal|255
condition|)
name|error
argument_list|(
literal|"option_as_string: bad code %d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dp
operator|<
name|data
operator|+
name|len
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|dp
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dp
operator|+
literal|1
operator|!=
name|data
operator|+
name|len
operator|||
operator|*
name|dp
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|op
argument_list|,
name|opleft
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|opleft
operator|-=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|dp
operator|==
literal|'"'
operator|||
operator|*
name|dp
operator|==
literal|'\''
operator|||
operator|*
name|dp
operator|==
literal|'$'
operator|||
operator|*
name|dp
operator|==
literal|'`'
operator|||
operator|*
name|dp
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
name|opleft
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op
operator|++
operator|=
operator|*
name|dp
expr_stmt|;
name|opleft
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opleft
operator|<
literal|1
condition|)
goto|goto
name|toobig
goto|;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
return|return
name|optbuf
return|;
name|toobig
label|:
name|warning
argument_list|(
literal|"dhcp option too large"
argument_list|)
expr_stmt|;
return|return
literal|"<error>"
return|;
block|}
end_function

begin_function
name|int
name|fork_privchld
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|fd2
parameter_list|)
block|{
name|struct
name|pollfd
name|pfd
index|[
literal|1
index|]
decl_stmt|;
name|int
name|nfds
decl_stmt|;
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"cannot fork"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|setproctitle
argument_list|(
literal|"%s [priv]"
argument_list|,
name|ifi
operator|->
name|name
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|nullfd
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|nullfd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|nullfd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|nullfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
if|if
condition|(
operator|(
name|nfds
operator|=
name|poll
argument_list|(
name|pfd
argument_list|,
literal|1
argument_list|,
name|INFTIM
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|error
argument_list|(
literal|"poll error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfds
operator|==
literal|0
operator|||
operator|!
operator|(
name|pfd
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLIN
operator|)
condition|)
continue|continue;
name|dispatch_imsg
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

