begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_comment
comment|/*  * SPA locking  *  * There are four basic locks for managing spa_t structures:  *  * spa_namespace_lock (global mutex)  *  *	This lock must be acquired to do any of the following:  *  *		- Lookup a spa_t by name  *		- Add or remove a spa_t from the namespace  *		- Increase spa_refcount from non-zero  *		- Check if spa_refcount is zero  *		- Rename a spa_t  *		- add/remove/attach/detach devices  *		- Held for the duration of create/destroy/import/export  *  *	It does not need to handle recursion.  A create or destroy may  *	reference objects (files or zvols) in other pools, but by  *	definition they must have an existing reference, and will never need  *	to lookup a spa_t by name.  *  * spa_refcount (per-spa refcount_t protected by mutex)  *  *	This reference count keep track of any active users of the spa_t.  The  *	spa_t cannot be destroyed or freed while this is non-zero.  Internally,  *	the refcount is never really 'zero' - opening a pool implicitly keeps  *	some references in the DMU.  Internally we check against SPA_MINREF, but  *	present the image of a zero/non-zero value to consumers.  *  * spa_config_lock (per-spa crazy rwlock)  *  *	This SPA special is a recursive rwlock, capable of being acquired from  *	asynchronous threads.  It has protects the spa_t from config changes,  *	and must be held in the following circumstances:  *  *		- RW_READER to perform I/O to the spa  *		- RW_WRITER to change the vdev config  *  * spa_config_cache_lock (per-spa mutex)  *  *	This mutex prevents the spa_config nvlist from being updated.  No  *      other locks are required to obtain this lock, although implicitly you  *      must have the namespace lock or non-zero refcount to have any kind  *      of spa_t pointer at all.  *  * The locking order is fairly straightforward:  *  *		spa_namespace_lock	->	spa_refcount  *  *	The namespace lock must be acquired to increase the refcount from 0  *	or to check if it is zero.  *  *		spa_refcount		->	spa_config_lock  *  *	There must be at least one valid reference on the spa_t to acquire  *	the config lock.  *  *		spa_namespace_lock	->	spa_config_lock  *  *	The namespace lock must always be taken before the config lock.  *  *  * The spa_namespace_lock and spa_config_cache_lock can be acquired directly and  * are globally visible.  *  * The namespace is manipulated using the following functions, all which require  * the spa_namespace_lock to be held.  *  *	spa_lookup()		Lookup a spa_t by name.  *  *	spa_add()		Create a new spa_t in the namespace.  *  *	spa_remove()		Remove a spa_t from the namespace.  This also  *				frees up any memory associated with the spa_t.  *  *	spa_next()		Returns the next spa_t in the system, or the  *				first if NULL is passed.  *  *	spa_evict_all()		Shutdown and remove all spa_t structures in  *				the system.  *  *	spa_guid_exists()	Determine whether a pool/device guid exists.  *  * The spa_refcount is manipulated using the following functions:  *  *	spa_open_ref()		Adds a reference to the given spa_t.  Must be  *				called with spa_namespace_lock held if the  *				refcount is currently zero.  *  *	spa_close()		Remove a reference from the spa_t.  This will  *				not free the spa_t or remove it from the  *				namespace.  No locking is required.  *  *	spa_refcount_zero()	Returns true if the refcount is currently  *				zero.  Must be called with spa_namespace_lock  *				held.  *  * The spa_config_lock is manipulated using the following functions:  *  *	spa_config_enter()	Acquire the config lock as RW_READER or  *				RW_WRITER.  At least one reference on the spa_t  *				must exist.  *  *	spa_config_exit()	Release the config lock.  *  *	spa_config_held()	Returns true if the config lock is currently  *				held in the given state.  *  * The vdev configuration is protected by spa_vdev_enter() / spa_vdev_exit().  *  *	spa_vdev_enter()	Acquire the namespace lock and the config lock  *				for writing.  *  *	spa_vdev_exit()		Release the config lock, wait for all I/O  *				to complete, sync the updated configs to the  *				cache, and release the namespace lock.  *  * The spa_name() function also requires either the spa_namespace_lock  * or the spa_config_lock, as both are needed to do a rename.  spa_rename() is  * also implemented within this file since is requires manipulation of the  * namespace.  */
end_comment

begin_decl_stmt
specifier|static
name|avl_tree_t
name|spa_namespace_avl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmutex_t
name|spa_namespace_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kcondvar_t
name|spa_namespace_cv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spa_active_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spa_max_replication_override
init|=
name|SPA_DVAS_PER_BP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|spa_spare_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|avl_tree_t
name|spa_spare_avl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|spa_buffer_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spa_mode
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|zfs_flags
init|=
operator|~
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|zfs_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * zfs_recover can be set to nonzero to attempt to recover from  * otherwise-fatal errors, typically caused by on-disk corruption.  When  * set, calls to zfs_panic_recover() will turn into warning messages.  */
end_comment

begin_decl_stmt
name|int
name|zfs_recover
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.recover"
argument_list|,
operator|&
name|zfs_recover
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|recover
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_recover
argument_list|,
literal|0
argument_list|,
literal|"Try to recover from otherwise-fatal errors."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SPA_MINREF
value|5
end_define

begin_comment
comment|/* spa_refcnt for an open-but-idle pool */
end_comment

begin_comment
comment|/*  * ==========================================================================  * SPA namespace functions  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Lookup the named spa_t in the AVL tree.  The spa_namespace_lock must be held.  * Returns NULL if no matching spa_t is found.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|spa_t
name|search
decl_stmt|,
modifier|*
name|spa
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|search
operator|.
name|spa_name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|spa
operator|=
name|avl_find
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an uninitialized spa_t with the given name.  Requires  * spa_namespace_lock.  The caller must ensure that the spa_t doesn't already  * exist by calling spa_lookup() first.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_name
operator|=
name|spa_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_UNINITIALIZED
expr_stmt|;
name|spa
operator|->
name|spa_freeze_txg
operator|=
name|UINT64_MAX
expr_stmt|;
name|spa
operator|->
name|spa_final_txg
operator|=
name|UINT64_MAX
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_lock
operator|.
name|scl_count
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Set the alternate root, if there is one. 	 */
if|if
condition|(
name|altroot
condition|)
block|{
name|spa
operator|->
name|spa_root
operator|=
name|spa_strdup
argument_list|(
name|altroot
argument_list|)
expr_stmt|;
name|spa_active_count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes a spa_t from the namespace, freeing up any memory used.  Requires  * spa_namespace_lock.  This is called only after the spa_t has been closed and  * deactivated.  */
end_comment

begin_function
name|void
name|spa_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_scrub_thread
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa_namespace_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_root
condition|)
block|{
name|spa_strfree
argument_list|(
name|spa
operator|->
name|spa_root
argument_list|)
expr_stmt|;
name|spa_active_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_name
condition|)
name|spa_strfree
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_lock
operator|.
name|scl_count
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spa
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a pool, return the next pool in the namespace, or NULL if there is  * none.  If 'prev' is NULL, return the first pool.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_next
parameter_list|(
name|spa_t
modifier|*
name|prev
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
return|return
operator|(
name|AVL_NEXT
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|prev
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|avl_first
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA refcount functions  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Add a reference to the given spa_t.  Must have at least one reference, or  * have the namespace lock held.  */
end_comment

begin_function
name|void
name|spa_open_ref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
operator|>
name|SPA_MINREF
operator|||
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a reference to the given spa_t.  Must have at least one reference, or  * have the namespace lock held.  */
end_comment

begin_function
name|void
name|spa_close
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
operator|>
name|SPA_MINREF
operator|||
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the spa refcount is zero.  Must be called with  * spa_namespace_lock held.  We really compare against SPA_MINREF, which is the  * number of references acquired when opening a pool  */
end_comment

begin_function
name|boolean_t
name|spa_refcount_zero
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
operator|==
name|SPA_MINREF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA spare tracking  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Spares are tracked globally due to the following constraints:  *  * 	- A spare may be part of multiple pools.  * 	- A spare may be added to a pool even if it's actively in use within  *	  another pool.  * 	- A spare in use in any pool can only be the source of a replacement if  *	  the target is a spare in the same pool.  *  * We keep track of all spares on the system through the use of a reference  * counted AVL tree.  When a vdev is added as a spare, or used as a replacement  * spare, then we bump the reference count in the AVL tree.  In addition, we set  * the 'vdev_isspare' member to indicate that the device is a spare (active or  * inactive).  When a spare is made active (used to replace a device in the  * pool), we also keep track of which pool its been made a part of.  *  * The 'spa_spare_lock' protects the AVL tree.  These functions are normally  * called under the spa_namespace lock as part of vdev reconfiguration.  The  * separate spare lock exists for the status query path, which does not need to  * be completely consistent with respect to other vdev configuration changes.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|spa_spare
block|{
name|uint64_t
name|spare_guid
decl_stmt|;
name|uint64_t
name|spare_pool
decl_stmt|;
name|avl_node_t
name|spare_avl
decl_stmt|;
name|int
name|spare_count
decl_stmt|;
block|}
name|spa_spare_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|spa_spare_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|spa_spare_t
modifier|*
name|sa
init|=
name|a
decl_stmt|;
specifier|const
name|spa_spare_t
modifier|*
name|sb
init|=
name|b
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|spare_guid
operator|<
name|sb
operator|->
name|spare_guid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|sa
operator|->
name|spare_guid
operator|>
name|sb
operator|->
name|spare_guid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_spare_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|avl_index_t
name|where
decl_stmt|;
name|spa_spare_t
name|search
decl_stmt|;
name|spa_spare_t
modifier|*
name|spare
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|search
operator|.
name|spare_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
if|if
condition|(
operator|(
name|spare
operator|=
name|avl_find
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|spare
operator|->
name|spare_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|spare
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_spare_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|spare
operator|->
name|spare_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|spare
operator|->
name|spare_count
operator|=
literal|1
expr_stmt|;
name|avl_insert
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
name|spare
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_isspare
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_spare_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_spare_t
name|search
decl_stmt|;
name|spa_spare_t
modifier|*
name|spare
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|search
operator|.
name|spare_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|spare
operator|=
name|avl_find
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spare
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|spare
operator|->
name|spare_count
operator|==
literal|0
condition|)
block|{
name|avl_remove
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
name|spare
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_spare_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spare
operator|->
name|spare_pool
operator|==
name|spa_guid
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
condition|)
block|{
name|spare
operator|->
name|spare_pool
operator|=
literal|0ULL
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_isspare
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_spare_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|)
block|{
name|spa_spare_t
name|search
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|search
operator|.
name|spare_guid
operator|=
name|guid
expr_stmt|;
name|found
operator|=
name|avl_find
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
if|if
condition|(
name|found
condition|)
operator|*
name|pool
operator|=
name|found
operator|->
name|spare_pool
expr_stmt|;
else|else
operator|*
name|pool
operator|=
literal|0ULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_spare_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_spare_t
name|search
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|search
operator|.
name|spare_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|found
operator|=
name|avl_find
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|found
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|found
operator|->
name|spare_pool
operator|==
literal|0ULL
argument_list|)
expr_stmt|;
name|found
operator|->
name|spare_pool
operator|=
name|spa_guid
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA config locking  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Acquire the config lock.  The config lock is a special rwlock that allows for  * recursive enters.  Because these enters come from the same thread as well as  * asynchronous threads working on behalf of the owner, we must unilaterally  * allow all reads access as long at least one reader is held (even if a write  * is requested).  This has the side effect of write starvation, but write locks  * are extremely rare, and a solution to this problem would be significantly  * more complex (if even possible).  *  * We would like to assert that the namespace lock isn't held, but this is a  * valid use during create.  */
end_comment

begin_function
name|void
name|spa_config_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|krw_t
name|rw
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|scl
operator|->
name|scl_writer
operator|!=
name|curthread
condition|)
block|{
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
block|{
while|while
condition|(
name|scl
operator|->
name|scl_writer
operator|!=
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|,
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|scl
operator|->
name|scl_writer
operator|!=
name|NULL
operator|||
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|,
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
name|scl
operator|->
name|scl_writer
operator|=
name|curthread
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release the spa config lock, notifying any waiters in the process.  */
end_comment

begin_function
name|void
name|spa_config_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_remove
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|,
name|tag
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|)
expr_stmt|;
name|scl
operator|->
name|scl_writer
operator|=
name|NULL
expr_stmt|;
comment|/* OK in either case */
block|}
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the config lock is held in the given manner.  */
end_comment

begin_function
name|boolean_t
name|spa_config_held
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|krw_t
name|rw
parameter_list|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
decl_stmt|;
name|boolean_t
name|held
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_WRITER
condition|)
name|held
operator|=
operator|(
name|scl
operator|->
name|scl_writer
operator|==
name|curthread
operator|)
expr_stmt|;
else|else
name|held
operator|=
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|held
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA vdev locking  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Lock the given spa_t for the purpose of adding or removing a vdev.  * Grabs the global spa_namespace_lock plus the spa config lock for writing.  * It returns the next transaction group for the spa_t.  */
end_comment

begin_function
name|uint64_t
name|spa_vdev_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
comment|/* 	 * Suspend scrub activity while we mess with the config. 	 */
name|spa_scrub_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|spa
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the spa_t after adding or removing a vdev.  Besides undoing the  * locking of spa_vdev_enter(), we also want make sure the transactions have  * synced to disk, and then update the global configuration cache with the new  * information.  */
end_comment

begin_function
name|int
name|spa_vdev_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|int
name|config_changed
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reassess the DTLs. 	 */
name|vdev_dtl_reassess
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * If the config changed, notify the scrub thread that it must restart. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
condition|)
block|{
name|config_changed
operator|=
name|B_TRUE
expr_stmt|;
name|spa_scrub_restart
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Allow scrubbing to resume. 	 */
name|spa_scrub_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Note: this txg_wait_synced() is important because it ensures 	 * that there won't be more than one config change per txg. 	 * This allows us to use the txg as the generation number. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_detached
operator|||
name|vd
operator|->
name|vdev_dtl
operator|.
name|smo_object
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the config changed, update the config cache. 	 */
if|if
condition|(
name|config_changed
condition|)
name|spa_config_sync
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Miscellaneous functions  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Rename a spa_t.  */
end_comment

begin_function
name|int
name|spa_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Lookup the spa_t and grab the config lock for writing.  We need to 	 * actually open the pool so that we can sync out the necessary labels. 	 * It's OK to call spa_open() with the namespace lock held because we 	 * allow recursive calls for other reasons. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|spa_open
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|spa_strfree
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_name
operator|=
name|spa_strdup
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Sync all labels to disk with the new names by marking the root vdev 	 * dirty and waiting for it to sync.  It will pick up the new pool name 	 * during the sync. 	 */
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Sync the updated config cache. 	 */
name|spa_config_sync
argument_list|()
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a pool with given pool_guid exists.  If device_guid is  * non-zero, determine whether the pool exists *and* contains a device with the  * specified device_guid.  */
end_comment

begin_function
name|boolean_t
name|spa_guid_exists
parameter_list|(
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|device_guid
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|spa_namespace_avl
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|spa
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|spa
operator|!=
name|NULL
condition|;
name|spa
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|spa
argument_list|)
control|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
condition|)
continue|continue;
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|==
name|pool_guid
condition|)
block|{
if|if
condition|(
name|device_guid
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|vdev_lookup_by_guid
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|device_guid
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
comment|/* 			 * Check any devices we may in the process of adding. 			 */
if|if
condition|(
name|spa
operator|->
name|spa_pending_vdev
condition|)
block|{
if|if
condition|(
name|vdev_lookup_by_guid
argument_list|(
name|spa
operator|->
name|spa_pending_vdev
argument_list|,
name|device_guid
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
return|return
operator|(
name|spa
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|spa_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|new
operator|=
name|kmem_alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|new
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_strfree
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|spa_get_random
parameter_list|(
name|uint64_t
name|range
parameter_list|)
block|{
name|uint64_t
name|r
decl_stmt|;
name|ASSERT
argument_list|(
name|range
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|%
name|range
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sprintf_blkptr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"<NULL>"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"<hole>"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"[L%llu %s] %llxL/%llxP "
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
argument_list|,
name|dmu_ot
index|[
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ot_name
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
condition|;
name|d
operator|++
control|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva
init|=
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|len
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"DVA[%d]=<%llu:%llx:%llx> "
argument_list|,
name|d
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|DVA_GET_ASIZE
argument_list|(
name|dva
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|len
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %s %s %s birth=%llu fill=%llu cksum=%llx:%llx:%llx:%llx"
argument_list|,
name|zio_checksum_table
index|[
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ci_name
argument_list|,
name|zio_compress_table
index|[
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ci_name
argument_list|,
name|BP_GET_BYTEORDER
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
condition|?
literal|"BE"
else|:
literal|"LE"
argument_list|,
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|?
literal|"gang"
else|:
literal|"contiguous"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bp
operator|->
name|blk_birth
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bp
operator|->
name|blk_fill
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|1
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|2
index|]
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_freeze
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|uint64_t
name|freeze_txg
init|=
literal|0
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_freeze_txg
operator|==
name|UINT64_MAX
condition|)
block|{
name|freeze_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
name|TXG_SIZE
expr_stmt|;
name|spa
operator|->
name|spa_freeze_txg
operator|=
name|freeze_txg
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeze_txg
operator|!=
literal|0
condition|)
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|freeze_txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_panic_recover
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|adx
decl_stmt|;
name|va_start
argument_list|(
name|adx
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vcmn_err
argument_list|(
name|zfs_recover
condition|?
name|CE_WARN
else|:
name|CE_PANIC
argument_list|,
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|adx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Accessor functions  * ==========================================================================  */
end_comment

begin_function
name|krwlock_t
modifier|*
name|spa_traverse_rwlock
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
operator|&
name|spa
operator|->
name|spa_traverse_lock
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_traverse_wanted
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_traverse_wanted
operator|)
return|;
block|}
end_function

begin_function
name|dsl_pool_t
modifier|*
name|spa_get_dsl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_dsl_pool
operator|)
return|;
block|}
end_function

begin_function
name|blkptr_t
modifier|*
name|spa_get_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
operator|&
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_rootbp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_set_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_altroot
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_root
operator|==
name|NULL
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|spa
operator|->
name|spa_root
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_sync_pass
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_sync_pass
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|spa_name
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
comment|/* 	 * Accessing the name requires holding either the namespace lock or the 	 * config lock, both of which are required to do a rename. 	 */
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
operator|||
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|)
operator|||
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa
operator|->
name|spa_name
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
comment|/* 	 * If we fail to parse the config during spa_load(), we can go through 	 * the error path (which posts an ereport) and end up here with no root 	 * vdev.  We stash the original pool guid in 'spa_load_guid' to handle 	 * this case. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_guid
operator|)
return|;
else|else
return|return
operator|(
name|spa
operator|->
name|spa_load_guid
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_last_synced_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_txg
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_first_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_first_txg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_state
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_freeze_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_freeze_txg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In the future, this may select among different metaslab classes  * depending on the zdp.  For now, there's no such distinction.  */
end_comment

begin_function
name|metaslab_class_t
modifier|*
name|spa_metaslab_class_select
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_normal_class
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return how much space is allocated in the pool (ie. sum of all asize)  */
end_comment

begin_function
name|uint64_t
name|spa_get_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return how much (raid-z inflated) space there is in the pool.  */
end_comment

begin_function
name|uint64_t
name|spa_get_space
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the amount of raid-z-deflated space in the pool.  */
end_comment

begin_function
name|uint64_t
name|spa_get_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_deflate
condition|)
return|return
operator|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|)
return|;
else|else
return|return
operator|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|uint64_t
name|spa_get_asize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|lsize
parameter_list|)
block|{
comment|/* 	 * For now, the worst case is 512-byte RAID-Z blocks, in which 	 * case the space requirement is exactly 2x; so just assume that. 	 * Add to this the fact that we can have up to 3 DVAs per bp, and 	 * we have to multiply by a total of 6x. 	 */
return|return
operator|(
name|lsize
operator|*
literal|6
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_max_replication
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
comment|/* 	 * As of ZFS_VERSION == ZFS_VERSION_DITTO_BLOCKS, we are able to 	 * handle BPs with more than one DVA allocated.  Set our max 	 * replication level accordingly. 	 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|ZFS_VERSION_DITTO_BLOCKS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|MIN
argument_list|(
name|SPA_DVAS_PER_BP
argument_list|,
name|spa_max_replication_override
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|bp_get_dasize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|sz
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|spa
operator|->
name|spa_deflate
condition|)
return|return
operator|(
name|BP_GET_ASIZE
argument_list|(
name|bp
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_DVAS_PER_BP
condition|;
name|i
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|sz
operator|+=
operator|(
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
argument_list|)
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
operator|*
name|vd
operator|->
name|vdev_deflate_ratio
expr_stmt|;
block|}
return|return
operator|(
name|sz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Initialization and Termination  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|spa_name_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a1
parameter_list|,
specifier|const
name|void
modifier|*
name|a2
parameter_list|)
block|{
specifier|const
name|spa_t
modifier|*
name|s1
init|=
name|a1
decl_stmt|;
specifier|const
name|spa_t
modifier|*
name|s2
init|=
name|a2
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|strcmp
argument_list|(
name|s1
operator|->
name|spa_name
argument_list|,
name|s2
operator|->
name|spa_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|spa_active_count
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_init
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa_namespace_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa_name_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_t
argument_list|,
name|spa_avl
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa_spare_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
name|spa_spare_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_spare_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_spare_t
argument_list|,
name|spare_avl
argument_list|)
argument_list|)
expr_stmt|;
name|spa_mode
operator|=
name|mode
expr_stmt|;
name|refcount_sysinit
argument_list|()
expr_stmt|;
name|unique_init
argument_list|()
expr_stmt|;
name|zio_init
argument_list|()
expr_stmt|;
name|dmu_init
argument_list|()
expr_stmt|;
name|zil_init
argument_list|()
expr_stmt|;
name|spa_config_load
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_evict_all
argument_list|()
expr_stmt|;
name|zil_fini
argument_list|()
expr_stmt|;
name|dmu_fini
argument_list|()
expr_stmt|;
name|zio_fini
argument_list|()
expr_stmt|;
name|refcount_fini
argument_list|()
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa_spare_avl
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa_namespace_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

