begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Routines to manage the on-disk persistent error log.  *  * Each pool stores a log of all logical data errors seen during normal  * operation.  This is actually the union of two distinct logs: the last log,  * and the current log.  All errors seen are logged to the current log.  When a  * scrub completes, the current log becomes the last log, the last log is thrown  * out, and the current log is reinitialized.  This way, if an error is somehow  * corrected, a new scrub will show that that it no longer exists, and will be  * deleted from the log when the scrub completes.  *  * The log is stored using a ZAP object whose key is a string form of the  * zbookmark tuple (objset, object, level, blkid), and whose contents is an  * optional 'objset:object' human-readable string describing the data.  When an  * error is first logged, this string will be empty, indicating that no name is  * known.  This prevents us from having to issue a potentially large amount of  * I/O to discover the object name during an error path.  Instead, we do the  * calculation when the data is requested, storing the result so future queries  * will be faster.  *  * This log is then shipped into an nvlist where the key is the dataset name and  * the value is the object name.  Userland is then responsible for uniquifying  * this list and displaying it to the user.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_comment
comment|/*  * This is a stripped-down version of strtoull, suitable only for converting  * lowercase hexidecimal numbers that don't overflow.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|uint64_t
name|_strtonum
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|nptr
parameter_list|)
block|{
name|uint64_t
name|val
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|digit
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|str
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|digit
operator|=
literal|10
operator|+
name|c
operator|-
literal|'a'
expr_stmt|;
else|else
break|break;
name|val
operator|*=
literal|16
expr_stmt|;
name|val
operator|+=
name|digit
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|nptr
operator|=
name|str
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert a bookmark to a string.  */
end_comment

begin_function
specifier|static
name|void
name|bookmark_to_name
parameter_list|(
name|zbookmark_t
modifier|*
name|zb
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%llx:%llx:%llx:%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zb
operator|->
name|zb_objset
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zb
operator|->
name|zb_object
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zb
operator|->
name|zb_level
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zb
operator|->
name|zb_blkid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a string to a bookmark  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|void
name|name_to_bookmark
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|zb
operator|->
name|zb_objset
operator|=
name|_strtonum
argument_list|(
name|buf
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|buf
operator|==
literal|':'
argument_list|)
expr_stmt|;
name|zb
operator|->
name|zb_object
operator|=
name|_strtonum
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|buf
operator|==
literal|':'
argument_list|)
expr_stmt|;
name|zb
operator|->
name|zb_level
operator|=
operator|(
name|int
operator|)
name|_strtonum
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|buf
operator|==
literal|':'
argument_list|)
expr_stmt|;
name|zb
operator|->
name|zb_blkid
operator|=
name|_strtonum
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|buf
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Log an uncorrectable error to the persistent error log.  We add it to the  * spa's list of pending errors.  The changes are actually synced out to disk  * during spa_errlog_sync().  */
end_comment

begin_function
name|void
name|spa_log_error
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zbookmark_t
modifier|*
name|zb
init|=
operator|&
name|zio
operator|->
name|io_logical
operator|->
name|io_bookmark
decl_stmt|;
name|spa_error_entry_t
name|search
decl_stmt|;
name|spa_error_entry_t
modifier|*
name|new
decl_stmt|;
name|avl_tree_t
modifier|*
name|tree
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
comment|/* 	 * If we are trying to import a pool, ignore any errors, as we won't be 	 * writing to the pool any time soon. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_load_state
operator|==
name|SPA_LOAD_TRYIMPORT
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we have had a request to rotate the log, log it to the next list 	 * instead of the current one. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_scrub_active
operator|||
name|spa
operator|->
name|spa_scrub_finished
condition|)
name|tree
operator|=
operator|&
name|spa
operator|->
name|spa_errlist_scrub
expr_stmt|;
else|else
name|tree
operator|=
operator|&
name|spa
operator|->
name|spa_errlist_last
expr_stmt|;
name|search
operator|.
name|se_bookmark
operator|=
operator|*
name|zb
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
name|tree
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|new
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new
operator|->
name|se_bookmark
operator|=
operator|*
name|zb
expr_stmt|;
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|new
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of errors currently in the error log.  This is actually the  * sum of both the last log and the current log, since we don't know the union  * of these logs until we reach userland.  */
end_comment

begin_function
name|uint64_t
name|spa_get_errlog_size
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|uint64_t
name|total
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_errlog_scrub
operator|!=
literal|0
operator|&&
name|zap_count
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_errlog_scrub
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
name|total
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_errlog_last
operator|!=
literal|0
operator|&&
operator|!
name|spa
operator|->
name|spa_scrub_finished
operator|&&
name|zap_count
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_errlog_last
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
name|total
operator|+=
name|count
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|total
operator|+=
name|avl_numnodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|)
expr_stmt|;
name|total
operator|+=
name|avl_numnodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|int
name|process_error_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
if|if
condition|(
name|obj
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|name_to_bookmark
argument_list|(
name|za
operator|.
name|za_name
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|zb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
operator|(
operator|*
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
operator|*
name|count
operator|-=
literal|1
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_error_list
parameter_list|(
name|avl_tree_t
modifier|*
name|list
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|spa_error_entry_t
modifier|*
name|se
decl_stmt|;
for|for
control|(
name|se
operator|=
name|avl_first
argument_list|(
name|list
argument_list|)
init|;
name|se
operator|!=
name|NULL
condition|;
name|se
operator|=
name|AVL_NEXT
argument_list|(
name|list
argument_list|,
name|se
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|se
operator|->
name|se_bookmark
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
operator|(
operator|*
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
operator|*
name|count
operator|-=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Copy all known errors to userland as an array of bookmarks.  This is  * actually a union of the on-disk last log and current log, as well as any  * pending error requests.  *  * Because the act of reading the on-disk log could cause errors to be  * generated, we have two separate locks: one for the error log and one for the  * in-core error lists.  We only need the error list lock to log and error, so  * we grab the error log lock while we read the on-disk logs, and only pick up  * the error list lock when we are finished.  */
end_comment

begin_function
name|int
name|spa_get_errlog
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|uaddr
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|process_error_log
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_errlog_scrub
argument_list|,
name|uaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|!
name|spa
operator|->
name|spa_scrub_finished
condition|)
name|ret
operator|=
name|process_error_log
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_errlog_last
argument_list|,
name|uaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|process_error_list
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|uaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|process_error_list
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|uaddr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a scrub completes.  This simply set a bit which tells which AVL  * tree to add new errors.  spa_errlog_sync() is responsible for actually  * syncing the changes to the underlying objects.  */
end_comment

begin_function
name|void
name|spa_errlog_rotate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|spa
operator|->
name|spa_scrub_finished
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_finished
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard any pending errors from the spa_t.  Called when unloading a faulted  * pool, as the errors encountered during the open cannot be synced to disk.  */
end_comment

begin_function
name|void
name|spa_errlog_drain
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|spa_error_entry_t
modifier|*
name|se
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|se
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|se
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|se
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|se
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a list of errors into the current on-disk log.  */
end_comment

begin_function
specifier|static
name|void
name|sync_error_list
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|avl_tree_t
modifier|*
name|t
parameter_list|,
name|uint64_t
modifier|*
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_error_entry_t
modifier|*
name|se
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* create log if necessary */
if|if
condition|(
operator|*
name|obj
operator|==
literal|0
condition|)
operator|*
name|obj
operator|=
name|zap_create
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_ERROR_LOG
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* add errors to the current log */
for|for
control|(
name|se
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|se
operator|!=
name|NULL
condition|;
name|se
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|se
argument_list|)
control|)
block|{
name|char
modifier|*
name|name
init|=
name|se
operator|->
name|se_name
condition|?
name|se
operator|->
name|se_name
else|:
literal|""
decl_stmt|;
name|bookmark_to_name
argument_list|(
operator|&
name|se
operator|->
name|se_bookmark
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_update
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
operator|*
name|obj
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* purge the error list */
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|se
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|se
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Sync the error log out to disk.  This is a little tricky because the act of  * writing the error log requires the spa_errlist_lock.  So, we need to lock the  * error lists, take a copy of the lists, and then reinitialize them.  Then, we  * drop the error list lock and take the error log lock, at which point we  * do the errlog processing.  Then, if we encounter an I/O error during this  * process, we can successfully add the error to the list.  Note that this will  * result in the perpetual recycling of errors, but it is an unlikely situation  * and not a performance critical operation.  */
end_comment

begin_function
name|void
name|spa_errlog_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|avl_tree_t
name|scrub
decl_stmt|,
name|last
decl_stmt|;
name|int
name|scrub_finished
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Bail out early under normal circumstances. 	 */
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|)
operator|==
literal|0
operator|&&
name|avl_numnodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|spa
operator|->
name|spa_scrub_finished
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|spa_get_errlists
argument_list|(
name|spa
argument_list|,
operator|&
name|last
argument_list|,
operator|&
name|scrub
argument_list|)
expr_stmt|;
name|scrub_finished
operator|=
name|spa
operator|->
name|spa_scrub_finished
expr_stmt|;
name|spa
operator|->
name|spa_scrub_finished
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Sync out the current list of errors. 	 */
name|sync_error_list
argument_list|(
name|spa
argument_list|,
operator|&
name|last
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_last
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Rotate the log if necessary. 	 */
if|if
condition|(
name|scrub_finished
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_errlog_last
operator|!=
literal|0
condition|)
name|VERIFY
argument_list|(
name|dmu_object_free
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_errlog_last
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_errlog_last
operator|=
name|spa
operator|->
name|spa_errlog_scrub
expr_stmt|;
name|spa
operator|->
name|spa_errlog_scrub
operator|=
literal|0
expr_stmt|;
name|sync_error_list
argument_list|(
name|spa
argument_list|,
operator|&
name|scrub
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_last
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sync out any pending scrub errors. 	 */
name|sync_error_list
argument_list|(
name|spa
argument_list|,
operator|&
name|scrub
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_scrub
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Update the MOS to reflect the new values. 	 */
operator|(
name|void
operator|)
name|zap_update
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ERRLOG_LAST
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_last
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_update
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ERRLOG_SCRUB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_scrub
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

