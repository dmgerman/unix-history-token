begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_decl_stmt
specifier|static
name|dsl_checkfunc_t
name|dsl_dataset_destroy_begin_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_destroy_begin_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_checkfunc_t
name|dsl_dataset_rollback_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_rollback_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_checkfunc_t
name|dsl_dataset_destroy_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_destroy_sync
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DS_REF_MAX
value|(1ULL<< 62)
end_define

begin_define
define|#
directive|define
name|DSL_DEADLIST_BLOCKSIZE
value|SPA_MAXBLOCKSIZE
end_define

begin_comment
comment|/*  * We use weighted reference counts to express the various forms of exclusion  * between different open modes.  A STANDARD open is 1 point, an EXCLUSIVE open  * is DS_REF_MAX, and a PRIMARY open is little more than half of an EXCLUSIVE.  * This makes the exclusion logic simple: the total refcnt for all opens cannot  * exceed DS_REF_MAX.  For example, EXCLUSIVE opens are exclusive because their  * weight (DS_REF_MAX) consumes the entire refcnt space.  PRIMARY opens consume  * just over half of the refcnt space, so there can't be more than one, but it  * can peacefully coexist with any number of STANDARD opens.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|ds_refcnt_weight
index|[
name|DS_MODE_LEVELS
index|]
init|=
block|{
literal|0
block|,
comment|/* DS_MODE_NONE - invalid		*/
literal|1
block|,
comment|/* DS_MODE_STANDARD - unlimited number	*/
operator|(
name|DS_REF_MAX
operator|>>
literal|1
operator|)
operator|+
literal|1
block|,
comment|/* DS_MODE_PRIMARY - only one of these	*/
name|DS_REF_MAX
comment|/* DS_MODE_EXCLUSIVE - no other opens	*/
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dsl_dataset_block_born
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|used
init|=
name|bp_get_dasize
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"born, ds=%p\n"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It could have been compressed away to nothing */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|<
argument_list|,
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Account for the meta-objset space in its placeholder 		 * dsl_dir. 		 */
name|ASSERT3U
argument_list|(
name|compressed
argument_list|,
operator|==
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
comment|/* it's all metadata */
name|dsl_dir_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
name|used
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_dirty
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|+=
name|used
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+=
name|compressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+=
name|uncompressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_block_kill
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_t
modifier|*
name|pio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|used
init|=
name|bp_get_dasize
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No block pointer => nothing to free */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|used
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 		 * Account for the meta-objset space in its placeholder 		 * dataset. 		 */
name|err
operator|=
name|arc_free
argument_list|(
name|pio
argument_list|,
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
condition|?
name|ARC_NOWAIT
else|:
name|ARC_WAIT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_dirty
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT3P
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|int
name|err
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"freeing: %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|err
operator|=
name|arc_free
argument_list|(
name|pio
argument_list|,
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
condition|?
name|ARC_NOWAIT
else|:
name|ARC_WAIT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
comment|/* XXX unique_bytes is not accurate for head datasets */
comment|/* ASSERT3U(ds->ds_phys->ds_unique_bytes,>=, used); */
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|-=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"putting on dead list: %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_enqueue
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if (bp->blk_birth> prev prev snap txg) prev unique += bs */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|&&
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|,
operator|>=
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|-=
name|used
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
operator|>=
argument_list|,
name|compressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|-=
name|compressed
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
operator|>=
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|-=
name|uncompressed
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_prev_snap_txg
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|uint64_t
name|trysnap
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The snapshot creation could fail, but that would cause an 	 * incorrect FALSE return, which would only result in an 	 * overestimation of the amount of space that an operation would 	 * consume, which is OK. 	 * 	 * There's also a small window where we could miss a pending 	 * snapshot, because we could set the sync task in the quiescing 	 * phase.  So this should only be used as a guess. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_trysnap_txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
condition|)
name|trysnap
operator|=
name|ds
operator|->
name|ds_trysnap_txg
expr_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|trysnap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_block_freeable
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|blk_birth
parameter_list|)
block|{
return|return
operator|(
name|blk_birth
operator|>
name|dsl_dataset_prev_snap_txg
argument_list|(
name|ds
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_evict
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|dsv
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsv
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
comment|/* open_refcount == DS_REF_MAX when deleting */
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_open_refcount
operator|==
literal|0
operator|||
name|ds
operator|->
name|ds_open_refcount
operator|==
name|DS_REF_MAX
argument_list|)
expr_stmt|;
name|dprintf_ds
argument_list|(
name|ds
argument_list|,
literal|"evicting %s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|unique_remove
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
condition|)
name|ds
operator|->
name|ds_user_evict_func
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
block|}
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
condition|)
name|list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_objsets
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_get_snapname
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_dataset_phys_t
modifier|*
name|headphys
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_buf_t
modifier|*
name|headdbuf
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|headdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|headphys
operator|=
name|headdbuf
operator|->
name|db_data
expr_stmt|;
name|err
operator|=
name|zap_value_search
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|headphys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|headdbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_open_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|uint64_t
name|weight
init|=
name|ds_refcnt_weight
index|[
name|DS_MODE_LEVEL
argument_list|(
name|mode
argument_list|)
index|]
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|||
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
operator|&
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ds
operator|=
name|dmu_buf_get_user
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|winner
decl_stmt|;
name|ds
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dbuf
operator|=
name|dbuf
expr_stmt|;
name|ds
operator|->
name|ds_object
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|bplist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * we don't really need to close the blist if we 			 * just opened it. 			 */
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|==
name|dsobj
condition|)
block|{
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
condition|)
block|{
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|snapname
condition|)
block|{
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|dsl_dataset_phys_t
modifier|*
name|headphys
decl_stmt|;
name|dmu_buf_t
modifier|*
name|headdbuf
decl_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|headdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|headphys
operator|=
name|headdbuf
operator|->
name|db_data
expr_stmt|;
name|uint64_t
name|foundobj
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|headphys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|foundobj
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|foundobj
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|foundobj
argument_list|,
operator|==
argument_list|,
name|dsobj
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|headdbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_SNAPNAMES
condition|)
block|{
name|err
operator|=
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|winner
operator|=
name|dmu_buf_set_user_ie
argument_list|(
name|dbuf
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
argument_list|,
name|dsl_dataset_evict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
name|winner
condition|)
block|{
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ds
operator|=
name|winner
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|new
init|=
name|unique_insert
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
condition|)
block|{
comment|/* XXX it won't necessarily be synced... */
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
operator|==
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_phys
argument_list|,
operator|==
argument_list|,
name|dbuf
operator|->
name|db_data
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DS_MODE_LEVEL
argument_list|(
name|mode
argument_list|)
operator|==
name|DS_MODE_PRIMARY
operator|&&
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_INCONSISTENT
operator|)
operator|&&
operator|!
name|DS_MODE_IS_INCONSISTENT
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|ds
operator|->
name|ds_open_refcount
operator|+
name|weight
operator|>
name|DS_REF_MAX
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|ds
operator|->
name|ds_open_refcount
operator|+=
name|weight
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|ds
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_open_spa
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|dsl_dir_open_spa
argument_list|(
name|spa
argument_list|,
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dp
operator|=
name|dd
operator|->
name|dd_pool
expr_stmt|;
name|obj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
literal|0
condition|)
block|{
comment|/* A dataset with no associated objset */
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tail
operator|!=
name|NULL
condition|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ds
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tail
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tail
operator|++
expr_stmt|;
comment|/* Look for a snapshot */
if|if
condition|(
operator|!
name|DS_MODE_IS_READONLY
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|err
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dprintf
argument_list|(
literal|"looking for snapshot '%s'\n"
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|obj
argument_list|,
name|tail
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tail
argument_list|,
name|mode
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|err
operator|==
literal|0
operator|)
argument_list|,
operator|==
argument_list|,
operator|(
name|ds
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
comment|/* ASSERT(ds == NULL || strcmp(name, ds->ds_name) == 0); */
operator|*
name|dsp
operator|=
name|ds
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
return|return
operator|(
name|dsl_dataset_open_spa
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|mode
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_name
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"mos"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dir_name
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
block|{
comment|/* 				 * We use a "recursive" mutex so that we 				 * can call dprintf_ds() with ds_lock held. 				 */
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_namelen
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
literal|3
expr_stmt|;
comment|/* "mos" */
block|}
else|else
block|{
name|result
operator|=
name|dsl_dir_namelen
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
block|{
operator|++
name|result
expr_stmt|;
comment|/* adding one for the @-sign */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
block|{
comment|/* see dsl_datset_name */
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_close
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uint64_t
name|weight
init|=
name|ds_refcnt_weight
index|[
name|DS_MODE_LEVEL
argument_list|(
name|mode
argument_list|)
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_open_refcount
argument_list|,
operator|>=
argument_list|,
name|weight
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_open_refcount
operator|-=
name|weight
expr_stmt|;
name|dprintf_ds
argument_list|(
name|ds
argument_list|,
literal|"closing mode %u refcount now 0x%llx\n"
argument_list|,
name|mode
argument_list|,
name|ds
operator|->
name|ds_open_refcount
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_create_root
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
modifier|*
name|ddobjp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dir_create_root
argument_list|(
name|mos
argument_list|,
name|ddobjp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
operator|*
name|ddobjp
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
name|unique_remove
argument_list|(
name|dsphys
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
comment|/* it isn't open yet */
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_snapnames_zapobj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DS_SNAP_MAP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|bplist_create
argument_list|(
name|mos
argument_list|,
name|DSL_DEADLIST_BLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
name|dsobj
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_create_impl
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_create_sync
parameter_list|(
name|dsl_dir_t
modifier|*
name|pdd
parameter_list|,
specifier|const
name|char
modifier|*
name|lastname
parameter_list|,
name|dsl_dataset_t
modifier|*
name|clone_parent
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|pdd
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|ddobj
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|ASSERT
argument_list|(
name|clone_parent
operator|==
name|NULL
operator|||
name|clone_parent
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|==
name|dp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|clone_parent
operator|==
name|NULL
operator|||
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lastname
index|[
literal|0
index|]
operator|!=
literal|'@'
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ddobj
operator|=
name|dsl_dir_create_sync
argument_list|(
name|pdd
argument_list|,
name|lastname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|ddobj
argument_list|,
name|lastname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
name|unique_remove
argument_list|(
name|dsphys
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
comment|/* it isn't open yet */
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_snapnames_zapobj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DS_SNAP_MAP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|bplist_create
argument_list|(
name|mos
argument_list|,
name|DSL_DEADLIST_BLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone_parent
condition|)
block|{
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|clone_parent
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_used_bytes
operator|=
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|clone_parent
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|++
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
operator|=
name|clone_parent
operator|->
name|ds_object
expr_stmt|;
block|}
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
name|dsobj
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsobj
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|destroyarg
block|{
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|char
modifier|*
name|snapname
decl_stmt|;
name|char
modifier|*
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dsl_snapshot_destroy_one
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|destroyarg
modifier|*
name|da
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|err
decl_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|da
operator|->
name|snapname
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_open
argument_list|(
name|name
argument_list|,
name|DS_MODE_EXCLUSIVE
operator||
name|DS_MODE_READONLY
operator||
name|DS_MODE_INCONSISTENT
argument_list|,
name|da
operator|->
name|dstg
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|err
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|da
operator|->
name|failed
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dsl_sync_task_create
argument_list|(
name|da
operator|->
name|dstg
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
name|ds
argument_list|,
name|da
operator|->
name|dstg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy 'snapname' in all descendants of 'fsname'.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|weak
name|dmu_snapshots_destroy
name|=
name|dsl_snapshots_destroy
end_pragma

begin_function
name|int
name|dsl_snapshots_destroy
parameter_list|(
name|char
modifier|*
name|fsname
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|destroyarg
name|da
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|da
operator|.
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|da
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
name|da
operator|.
name|failed
operator|=
name|fsname
expr_stmt|;
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|fsname
argument_list|,
name|dsl_snapshot_destroy_one
argument_list|,
operator|&
name|da
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|da
operator|.
name|dstg
argument_list|)
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|da
operator|.
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|da
operator|.
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
block|{
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 		 * If it was successful, destroy_sync would have 		 * closed the ds 		 */
if|if
condition|(
name|err
condition|)
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|da
operator|.
name|dstg
argument_list|)
expr_stmt|;
block|}
name|dsl_sync_task_group_destroy
argument_list|(
name|da
operator|.
name|dstg
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_destroy
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
comment|/* Destroying a snapshot is simpler */
name|err
operator|=
name|dsl_dataset_open
argument_list|(
name|name
argument_list|,
name|DS_MODE_EXCLUSIVE
operator||
name|DS_MODE_READONLY
operator||
name|DS_MODE_INCONSISTENT
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
name|ds
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|DS_MODE_EXCLUSIVE
operator||
name|DS_MODE_INCONSISTENT
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ds
operator|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
expr_stmt|;
name|dd
operator|=
name|ds
operator|->
name|ds_dir
expr_stmt|;
comment|/* 	 * Check for errors and mark this ds as inconsistent, in 	 * case we crash while freeing the objects. 	 */
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_destroy_begin_check
argument_list|,
name|dsl_dataset_destroy_begin_sync
argument_list|,
name|ds
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * remove the objects in open context, so that we won't 	 * have too much to do in syncing context. 	 */
for|for
control|(
name|obj
operator|=
literal|0
init|;
name|err
operator|==
literal|0
condition|;
name|err
operator|=
name|dmu_object_next
argument_list|(
name|os
argument_list|,
operator|&
name|obj
argument_list|,
name|FALSE
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|)
control|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * Perhaps there is not enough disk 			 * space.  Just deal with it from 			 * dsl_dataset_destroy_sync(). 			 */
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure it's not dirty before we finish destroying it. */
name|txg_wait_synced
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ESRCH
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_dataset_open
argument_list|(
name|name
argument_list|,
name|DS_MODE_EXCLUSIVE
operator||
name|DS_MODE_READONLY
operator||
name|DS_MODE_INCONSISTENT
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Blow away the dsl_dir + head dataset. 	 */
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|dstg
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
name|ds
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|dstg
argument_list|,
name|dsl_dir_destroy_check
argument_list|,
name|dsl_dir_destroy_sync
argument_list|,
name|dd
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
comment|/* if it is successful, *destroy_sync will close the ds+dd */
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_rollback
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_open_refcount
argument_list|,
operator|==
argument_list|,
name|DS_REF_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_rollback_check
argument_list|,
name|dsl_dataset_rollback_sync
argument_list|,
name|ds
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dsl_dataset_set_user_ptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|dsl_dataset_evict_func_t
name|func
parameter_list|)
block|{
name|void
modifier|*
name|old
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|old
operator|=
name|ds
operator|->
name|ds_user_ptr
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
block|{
name|ds
operator|->
name|ds_user_ptr
operator|=
name|p
expr_stmt|;
name|ds
operator|->
name|ds_user_evict_func
operator|=
name|func
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dsl_dataset_get_user_ptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_user_ptr
operator|)
return|;
block|}
end_function

begin_function
name|blkptr_t
modifier|*
name|dsl_dataset_get_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_set_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's the meta-objset, set dp_meta_rootbp */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|tx
operator|->
name|tx_pool
operator|->
name|dp_meta_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|spa_t
modifier|*
name|dsl_dataset_get_spa
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_dirty
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
comment|/* this is the meta-objset */
return|return;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"dirtying snapshot!"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
if|if
condition|(
name|txg_list_add
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|ds
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* up the hold count until we can be written out */
name|dmu_buf_add_ref
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|killarg
block|{
name|uint64_t
modifier|*
name|usedp
decl_stmt|;
name|uint64_t
modifier|*
name|compressedp
decl_stmt|;
name|uint64_t
modifier|*
name|uncompressedp
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|kill_blkptr
parameter_list|(
name|traverse_blk_cache_t
modifier|*
name|bc
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|killarg
modifier|*
name|ka
init|=
name|arg
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|bc
operator|->
name|bc_blkptr
decl_stmt|;
name|ASSERT3U
argument_list|(
name|bc
operator|->
name|bc_errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Since this callback is not called concurrently, no lock is 	 * needed on the accounting values. 	 */
operator|*
name|ka
operator|->
name|usedp
operator|+=
name|bp_get_dasize
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|ka
operator|->
name|compressedp
operator|+=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|ka
operator|->
name|uncompressedp
operator|+=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* XXX check for EIO? */
operator|(
name|void
operator|)
name|arc_free
argument_list|(
name|ka
operator|->
name|zio
argument_list|,
name|spa
argument_list|,
name|ka
operator|->
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_rollback_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
comment|/* 	 * There must be a previous snapshot.  I suppose we could roll 	 * it back to being empty (and re-initialize the upper (ZPL) 	 * layer).  But for now there's no way to do this via the user 	 * interface. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * This must not be a snapshot. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If we made changes this txg, traverse_dsl_dataset won't find 	 * them.  Try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_rollback_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Zero out the deadlist. */
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|bplist_create
argument_list|(
name|mos
argument_list|,
name|DSL_DEADLIST_BLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Free blkptrs that we gave birth to */
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|uint64_t
name|used
init|=
literal|0
decl_stmt|,
name|compressed
init|=
literal|0
decl_stmt|,
name|uncompressed
init|=
literal|0
decl_stmt|;
name|struct
name|killarg
name|ka
decl_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
name|ka
operator|.
name|usedp
operator|=
operator|&
name|used
expr_stmt|;
name|ka
operator|.
name|compressedp
operator|=
operator|&
name|compressed
expr_stmt|;
name|ka
operator|.
name|uncompressedp
operator|=
operator|&
name|uncompressed
expr_stmt|;
name|ka
operator|.
name|zio
operator|=
name|zio
expr_stmt|;
name|ka
operator|.
name|tx
operator|=
name|tx
expr_stmt|;
operator|(
name|void
operator|)
name|traverse_dsl_dataset
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|ADVANCE_POST
argument_list|,
name|kill_blkptr
argument_list|,
operator|&
name|ka
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* Change our contents to that of the prev snapshot */
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_destroy_begin_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
comment|/* 	 * Can't delete a head dataset if there are snapshots of it. 	 * (Except if the only snapshots are from the branch we cloned 	 * from.) 	 */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_destroy_begin_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
comment|/* Mark it as inconsistent on-disk, in case we crash */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_INCONSISTENT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_destroy_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
comment|/* Can't delete a branch point. */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* 	 * Can't delete a head dataset if there are snapshots of it. 	 * (Except if the only snapshots are from the branch we cloned 	 * from.) 	 */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If we made changes this txg, traverse_dsl_dataset won't find 	 * them.  Try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* XXX we should do some i/o error checking... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_destroy_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|uint64_t
name|used
init|=
literal|0
decl_stmt|,
name|compressed
init|=
literal|0
decl_stmt|,
name|uncompressed
init|=
literal|0
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|after_branch_point
init|=
name|FALSE
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_prev
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_open_refcount
argument_list|,
operator|==
argument_list|,
name|DS_REF_MAX
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
argument_list|,
operator|<=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
operator|||
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
argument_list|,
operator|<=
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|ds_prev
operator|=
name|ds
operator|->
name|ds_prev
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|after_branch_point
operator|=
operator|(
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|obj
operator|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_branch_point
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
block|{
comment|/* This clone is toast. */
name|ASSERT
argument_list|(
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
argument_list|)
expr_stmt|;
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|after_branch_point
condition|)
block|{
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
block|}
block|}
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
name|blkptr_t
name|bp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_next
decl_stmt|;
name|uint64_t
name|itor
init|=
literal|0
decl_stmt|;
name|spa_scrub_restart
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_next
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_next
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds_prev
condition|?
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Transfer to our deadlist (which will become next's 		 * new deadlist) any entries from next's current 		 * deadlist which were born before prev, and free the 		 * other entries. 		 * 		 * XXX we're doing this long task with the config lock held 		 */
while|while
condition|(
name|bplist_iterate
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|itor
argument_list|,
operator|&
name|bp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|.
name|blk_birth
operator|<=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_enqueue
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|bp
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_prev
operator|&&
operator|!
name|after_branch_point
operator|&&
name|bp
operator|.
name|blk_birth
operator|>
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|bp_get_dasize
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|used
operator|+=
name|bp_get_dasize
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|compressed
operator|+=
name|BP_GET_PSIZE
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
name|uncompressed
operator|+=
name|BP_GET_UCSIZE
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
comment|/* XXX check return value? */
operator|(
name|void
operator|)
name|arc_free
argument_list|(
name|zio
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
operator|&
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* free next's deadlist */
name|bplist_close
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
name|mos
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* set next's deadlist to our deadlist */
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Update next's unique to include blocks which 			 * were previously shared by only this snapshot 			 * and it.  Those blocks will be born after the 			 * prev snap and before this snap, and will have 			 * died after the next snap and before the one 			 * after that (ie. be on the snap after next's 			 * deadlist). 			 * 			 * XXX we're doing this long task with the 			 * config lock held 			 */
name|dsl_dataset_t
modifier|*
name|ds_after_next
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_after_next
argument_list|)
argument_list|)
expr_stmt|;
name|itor
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bplist_iterate
argument_list|(
operator|&
name|ds_after_next
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|itor
argument_list|,
operator|&
name|bp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|.
name|blk_birth
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|&&
name|bp
operator|.
name|blk_birth
operator|<=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
block|{
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|bp_get_dasize
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dataset_close
argument_list|(
name|ds_after_next
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * It would be nice to update the head dataset's 			 * unique.  To do so we would have to traverse 			 * it for blocks born after ds_prev, which is 			 * pretty expensive just to maintain something 			 * for debugging purposes. 			 */
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|ds_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_prev
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|ds_next
argument_list|,
operator|&
name|ds_next
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ds_next
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|dsl_dataset_close
argument_list|(
name|ds_next
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 		 * NB: unique_bytes is not accurate for head objsets 		 * because we don't update it when we delete the most 		 * recent snapshot -- see above comment. 		 */
name|ASSERT3U
argument_list|(
name|used
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There's no next snapshot, so this is a head dataset. 		 * Destroy the deadlist.  Unless it's a clone, the 		 * deadlist should be empty.  (If it's a clone, it's 		 * safe to ignore the deadlist contents.) 		 */
name|struct
name|killarg
name|ka
decl_stmt|;
name|ASSERT
argument_list|(
name|after_branch_point
operator|||
name|bplist_empty
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
argument_list|)
expr_stmt|;
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Free everything that we point to (that's born after 		 * the previous snapshot, if we are a clone) 		 * 		 * XXX we're doing this long task with the config lock held 		 */
name|ka
operator|.
name|usedp
operator|=
operator|&
name|used
expr_stmt|;
name|ka
operator|.
name|compressedp
operator|=
operator|&
name|compressed
expr_stmt|;
name|ka
operator|.
name|uncompressedp
operator|=
operator|&
name|uncompressed
expr_stmt|;
name|ka
operator|.
name|zio
operator|=
name|zio
expr_stmt|;
name|ka
operator|.
name|tx
operator|=
name|tx
expr_stmt|;
name|err
operator|=
name|traverse_dsl_dataset
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|ADVANCE_POST
argument_list|,
name|kill_blkptr
argument_list|,
operator|&
name|ka
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
condition|)
block|{
name|err
operator|=
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
comment|/* Erase the link in the dataset */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
literal|0
expr_stmt|;
comment|/* 		 * dsl_dir_sync_destroy() called us, they'll destroy 		 * the dataset. 		 */
block|}
else|else
block|{
comment|/* remove from snapshot namespace */
name|dsl_dataset_t
modifier|*
name|ds_head
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_head
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
block|{
name|uint64_t
name|val
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|ds_head
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|val
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|ds_head
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds_head
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds_prev
operator|&&
name|ds
operator|->
name|ds_prev
operator|!=
name|ds_prev
condition|)
name|dsl_dataset_close
argument_list|(
name|ds_prev
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_clear_bootfs
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dsl_dataset_snapshot_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
init|=
name|arg2
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
comment|/* 	 * We don't allow multiple snapshots of the same txg.  If there 	 * is already one, try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* 	 * Check for conflicting name snapshot name. 	 */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Check that the dataset's name is not too long.  Name consists 	 * of the dataset's length + 1 for the @-sign + snapshot name's length 	 */
if|if
condition|(
name|dsl_dataset_namelen
argument_list|(
name|ds
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|snapname
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|ds
operator|->
name|ds_trysnap_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_snapshot_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
init|=
name|arg2
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|spa_scrub_restart
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
name|unique_remove
argument_list|(
name|dsphys
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
comment|/* it isn't open yet */
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_next_snap_obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_num_children
operator|=
literal|1
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_used_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|!=
literal|0
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|||
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|dsobj
expr_stmt|;
block|}
block|}
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|<
argument_list|,
name|dsphys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|dsphys
operator|->
name|ds_creation_txg
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|bplist_create
argument_list|(
name|mos
argument_list|,
name|DSL_DEADLIST_BLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"snap '%s' -> obj %llu\n"
argument_list|,
name|snapname
argument_list|,
name|dsobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dsobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
name|dsl_dataset_close
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|snapname
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_sync
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dir_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_objset_sync
argument_list|(
name|ds
operator|->
name|ds_user_ptr
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Unneeded? bplist_close(&ds->ds_deadlist); */
block|}
end_function

begin_function
name|void
name|dsl_dataset_stats
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|dsl_dir_stats
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATION
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_time
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFERENCED
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
condition|)
block|{
comment|/* 		 * This is a snapshot; override the dd's space used with 		 * our unique space and compression ratio. 		 */
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_USED
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_COMPRESSRATIO
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|==
literal|0
condition|?
literal|100
else|:
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|*
literal|100
operator|/
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsl_dataset_fast_stat
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
block|{
name|stat
operator|->
name|dds_creation_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|stat
operator|->
name|dds_inconsistent
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_INCONSISTENT
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
condition|)
block|{
name|stat
operator|->
name|dds_is_snapshot
operator|=
name|B_TRUE
expr_stmt|;
name|stat
operator|->
name|dds_num_clones
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|1
expr_stmt|;
block|}
comment|/* clone origin is really a dsl_dir thing... */
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ods
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ods
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ods
argument_list|,
name|stat
operator|->
name|dds_clone_of
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ods
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_fsid_guid
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_space
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
block|{
operator|*
name|refdbytesp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
operator|*
name|availbytesp
operator|=
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|usedobjsp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_fill
expr_stmt|;
operator|*
name|availobjsp
operator|=
name|DN_MAX_OBJECT
operator|-
operator|*
name|usedobjsp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_rename_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|char
modifier|*
name|newsnapname
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* new name better not be in use */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|newsnapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|hds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|EEXIST
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
comment|/* dataset name + 1 for the "@" + the new snapshot name must fit */
if|if
condition|(
name|dsl_dir_namelen
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|newsnapname
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
name|err
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_snapshot_rename_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|char
modifier|*
name|newsnapname
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|newsnapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|hds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|renamearg
block|{
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|char
name|failed
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|oldsnap
decl_stmt|;
name|char
modifier|*
name|newsnap
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dsl_snapshot_rename_one
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|renamearg
modifier|*
name|ra
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|ra
operator|->
name|oldsnap
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_open
argument_list|(
name|name
argument_list|,
name|DS_MODE_READONLY
operator||
name|DS_MODE_STANDARD
argument_list|,
name|ra
operator|->
name|dstg
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_STANDARD
argument_list|,
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* for all filesystems undergoing rename, we'll need to unmount it */
operator|(
name|void
operator|)
name|zfs_unmount_snap
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|ra
operator|->
name|dstg
argument_list|,
name|dsl_dataset_snapshot_rename_check
argument_list|,
name|dsl_dataset_snapshot_rename_sync
argument_list|,
name|ds
argument_list|,
name|ra
operator|->
name|newsnap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_recursive_rename
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|renamearg
modifier|*
name|ra
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|fsname
init|=
name|spa_strdup
argument_list|(
name|oldname
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|oldname
argument_list|)
decl_stmt|;
comment|/* truncate the snapshot name to get the fsname */
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|fsname
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ra
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|renamearg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ra
operator|->
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ra
operator|->
name|oldsnap
operator|=
name|strchr
argument_list|(
name|oldname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ra
operator|->
name|newsnap
operator|=
name|strchr
argument_list|(
name|newname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|ra
operator|->
name|failed
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|fsname
argument_list|,
name|dsl_snapshot_rename_one
argument_list|,
name|ra
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|fsname
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|ra
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|ra
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
block|{
name|dsl_dir_name
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ra
operator|->
name|failed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
name|ra
operator|->
name|newsnap
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_STANDARD
argument_list|,
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oldname
argument_list|,
name|ra
operator|->
name|failed
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ra
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|renamearg
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_pragma
pragma|#
directive|pragma
name|weak
name|dmu_objset_rename
name|=
name|dsl_dataset_rename
end_pragma

begin_function
name|int
name|dsl_dataset_rename
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|oldname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|dsl_dir_rename
argument_list|(
name|dd
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|tail
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
comment|/* the name ended in a nonexistant component */
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* new name must be snapshot in same filesystem */
name|tail
operator|=
name|strchr
argument_list|(
name|newname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tail
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|,
name|tail
operator|-
name|newname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EXDEV
operator|)
return|;
if|if
condition|(
name|recursive
condition|)
block|{
name|err
operator|=
name|dsl_recursive_rename
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dsl_dataset_open
argument_list|(
name|oldname
argument_list|,
name|DS_MODE_READONLY
operator||
name|DS_MODE_STANDARD
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_snapshot_rename_check
argument_list|,
name|dsl_dataset_snapshot_rename_sync
argument_list|,
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_STANDARD
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|promotearg
block|{
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|,
name|unique
decl_stmt|;
name|uint64_t
name|newnext_obj
decl_stmt|,
name|snapnames_obj
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dsl_dataset_promote_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|hds
init|=
name|arg1
decl_stmt|;
name|struct
name|promotearg
modifier|*
name|pa
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|hds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|hds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dsl_dir_t
modifier|*
name|pdd
init|=
name|NULL
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|pivot_ds
init|=
name|NULL
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|newnext_ds
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|itor
init|=
literal|0
decl_stmt|;
name|blkptr_t
name|bp
decl_stmt|;
name|bzero
argument_list|(
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that it is a clone */
if|if
condition|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Since this is so expensive, don't do the preliminary check */
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pivot_ds
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|pdd
operator|=
name|pivot_ds
operator|->
name|ds_dir
expr_stmt|;
block|{
name|dsl_dataset_t
modifier|*
name|phds
decl_stmt|;
if|if
condition|(
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|pdd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|phds
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|pa
operator|->
name|snapnames_obj
operator|=
name|phds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|phds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
condition|)
block|{
name|err
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* find pivot point's new next ds */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|hds
operator|->
name|ds_object
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|newnext_ds
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|newnext_ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
name|pivot_ds
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|newnext_ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|dsl_dataset_close
argument_list|(
name|newnext_ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|newnext_ds
operator|=
name|prev
expr_stmt|;
block|}
name|pa
operator|->
name|newnext_obj
operator|=
name|newnext_ds
operator|->
name|ds_object
expr_stmt|;
comment|/* compute pivot point's new unique space */
while|while
condition|(
operator|(
name|err
operator|=
name|bplist_iterate
argument_list|(
operator|&
name|newnext_ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|itor
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|.
name|blk_birth
operator|>
name|pivot_ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
name|pa
operator|->
name|unique
operator|+=
name|bp_get_dasize
argument_list|(
name|dd
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
goto|goto
name|out
goto|;
comment|/* Walk the snapshots that we are moving */
name|name
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ds
operator|=
name|pivot_ds
expr_stmt|;
comment|/* CONSTCOND */
while|while
condition|(
name|TRUE
condition|)
block|{
name|uint64_t
name|val
decl_stmt|,
name|dlused
decl_stmt|,
name|dlcomp
decl_stmt|,
name|dluncomp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
comment|/* Check that the snapshot name does not conflict */
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * compute space to transfer.  Each snapshot gave birth to: 		 * (my used) - (prev's used) + (deadlist's used) 		 */
name|pa
operator|->
name|used
operator|+=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|pa
operator|->
name|comp
operator|+=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|+=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
comment|/* If we reach the first snapshot, we're done. */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|err
operator|=
name|bplist_space
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dlused
argument_list|,
operator|&
name|dlcomp
argument_list|,
operator|&
name|dluncomp
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|pa
operator|->
name|used
operator|+=
name|dlused
operator|-
name|prev
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|pa
operator|->
name|comp
operator|+=
name|dlcomp
operator|-
name|prev
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|+=
name|dluncomp
operator|-
name|prev
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
comment|/* 		 * We could be a clone of a clone.  If we reach our 		 * parent's branch point, we're done. 		 */
if|if
condition|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|prev
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ds
operator|!=
name|pivot_ds
condition|)
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ds
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Check that there is enough space here */
name|err
operator|=
name|dsl_dir_transfer_possible
argument_list|(
name|pdd
argument_list|,
name|dd
argument_list|,
name|pa
operator|->
name|used
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ds
operator|&&
name|ds
operator|!=
name|pivot_ds
condition|)
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|pivot_ds
condition|)
name|dsl_dataset_close
argument_list|(
name|pivot_ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnext_ds
condition|)
name|dsl_dataset_close
argument_list|(
name|newnext_ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|kmem_free
argument_list|(
name|name
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_promote_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|hds
init|=
name|arg1
decl_stmt|;
name|struct
name|promotearg
modifier|*
name|pa
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|hds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|hds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dsl_dir_t
modifier|*
name|pdd
init|=
name|NULL
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|,
modifier|*
name|pivot_ds
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ASSERT
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|==
operator|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
operator|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pivot_ds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We need to explicitly open pdd, since pivot_ds's pdd will be 	 * changing. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|pivot_ds
operator|->
name|ds_dir
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pdd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move snapshots to this dir */
name|name
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ds
operator|=
name|pivot_ds
expr_stmt|;
comment|/* CONSTCOND */
while|while
condition|(
name|TRUE
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
comment|/* move snap name entry */
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|pa
operator|->
name|snapnames_obj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* change containing dsl_dir */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
operator|==
argument_list|,
name|pdd
operator|->
name|dd_object
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|==
argument_list|,
name|pdd
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_prop_numcb
argument_list|(
name|ds
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|==
literal|0
condition|)
break|break;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|prev
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ds
operator|!=
name|pivot_ds
condition|)
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ds
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|!=
name|pivot_ds
condition|)
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* change pivot point's next snap */
name|dmu_buf_will_dirty
argument_list|(
name|pivot_ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|pivot_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|pa
operator|->
name|newnext_obj
expr_stmt|;
comment|/* change clone_parent-age */
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
argument_list|,
operator|==
argument_list|,
name|pivot_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
operator|=
name|pdd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|pdd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|pdd
operator|->
name|dd_phys
operator|->
name|dd_clone_parent_obj
operator|=
name|pivot_ds
operator|->
name|ds_object
expr_stmt|;
comment|/* change space accounting */
name|dsl_dir_diduse_space
argument_list|(
name|pdd
argument_list|,
operator|-
name|pa
operator|->
name|used
argument_list|,
operator|-
name|pa
operator|->
name|comp
argument_list|,
operator|-
name|pa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dd
argument_list|,
name|pa
operator|->
name|used
argument_list|,
name|pa
operator|->
name|comp
argument_list|,
name|pa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|pivot_ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
name|pa
operator|->
name|unique
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|pivot_ds
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|name
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_promote
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|struct
name|promotearg
name|pa
decl_stmt|;
name|err
operator|=
name|dsl_dataset_open
argument_list|(
name|name
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_object_info
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Add in 128x the snapnames zapobj size, since we will be moving 	 * a bunch of snapnames to the promoted ds, and dirtying their 	 * bonus buffers. 	 */
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_promote_check
argument_list|,
name|dsl_dataset_promote_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|pa
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|doi
operator|.
name|doi_physical_blks
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a pool name and a dataset object number in that pool,  * return the name of that dataset.  */
end_comment

begin_function
name|int
name|dsl_dsobj_to_dsname
parameter_list|(
name|char
modifier|*
name|pname
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_open
argument_list|(
name|pname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

