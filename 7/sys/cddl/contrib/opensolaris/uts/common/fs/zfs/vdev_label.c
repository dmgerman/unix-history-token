begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Virtual Device Labels  * ---------------------  *  * The vdev label serves several distinct purposes:  *  *	1. Uniquely identify this device as part of a ZFS pool and confirm its  *	   identity within the pool.  *  * 	2. Verify that all the devices given in a configuration are present  *         within the pool.  *  * 	3. Determine the uberblock for the pool.  *  * 	4. In case of an import operation, determine the configuration of the  *         toplevel vdev of which it is a part.  *  * 	5. If an import operation cannot find all the devices in the pool,  *         provide enough information to the administrator to determine which  *         devices are missing.  *  * It is important to note that while the kernel is responsible for writing the  * label, it only consumes the information in the first three cases.  The  * latter information is only consumed in userland when determining the  * configuration to import a pool.  *  *  * Label Organization  * ------------------  *  * Before describing the contents of the label, it's important to understand how  * the labels are written and updated with respect to the uberblock.  *  * When the pool configuration is altered, either because it was newly created  * or a device was added, we want to update all the labels such that we can deal  * with fatal failure at any point.  To this end, each disk has two labels which  * are updated before and after the uberblock is synced.  Assuming we have  * labels and an uberblock with the following transacation groups:  *  *              L1          UB          L2  *           +------+    +------+    +------+  *           |      |    |      |    |      |  *           | t10  |    | t10  |    | t10  |  *           |      |    |      |    |      |  *           +------+    +------+    +------+  *  * In this stable state, the labels and the uberblock were all updated within  * the same transaction group (10).  Each label is mirrored and checksummed, so  * that we can detect when we fail partway through writing the label.  *  * In order to identify which labels are valid, the labels are written in the  * following manner:  *  * 	1. For each vdev, update 'L1' to the new label  * 	2. Update the uberblock  * 	3. For each vdev, update 'L2' to the new label  *  * Given arbitrary failure, we can determine the correct label to use based on  * the transaction group.  If we fail after updating L1 but before updating the  * UB, we will notice that L1's transaction group is greater than the uberblock,  * so L2 must be valid.  If we fail after writing the uberblock but before  * writing L2, we will notice that L2's transaction group is less than L1, and  * therefore L1 is valid.  *  * Another added complexity is that not every label is updated when the config  * is synced.  If we add a single device, we do not want to have to re-write  * every label for every device in the pool.  This means that both L1 and L2 may  * be older than the pool uberblock, because the necessary information is stored  * on another vdev.  *  *  * On-disk Format  * --------------  *  * The vdev label consists of two distinct parts, and is wrapped within the  * vdev_label_t structure.  The label includes 8k of padding to permit legacy  * VTOC disk labels, but is otherwise ignored.  *  * The first half of the label is a packed nvlist which contains pool wide  * properties, per-vdev properties, and configuration information.  It is  * described in more detail below.  *  * The latter half of the label consists of a redundant array of uberblocks.  * These uberblocks are updated whenever a transaction group is committed,  * or when the configuration is updated.  When a pool is loaded, we scan each  * vdev for the 'best' uberblock.  *  *  * Configuration Information  * -------------------------  *  * The nvlist describing the pool and vdev contains the following elements:  *  * 	version		ZFS on-disk version  * 	name		Pool name  * 	state		Pool state  * 	txg		Transaction group in which this label was written  * 	pool_guid	Unique identifier for this pool  * 	vdev_tree	An nvlist describing vdev tree.  *  * Each leaf device label also contains the following:  *  * 	top_guid	Unique ID for top-level vdev in which this is contained  * 	guid		Unique ID for the leaf vdev  *  * The 'vs' configuration follows the format described in 'spa_config.c'.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_comment
comment|/*  * Basic routines to read and write from a vdev label.  * Used throughout the rest of this file.  */
end_comment

begin_function
name|uint64_t
name|vdev_label_offset
parameter_list|(
name|uint64_t
name|psize
parameter_list|,
name|int
name|l
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|offset
operator|<
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|+
name|l
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|+
operator|(
name|l
operator|<
name|VDEV_LABELS
operator|/
literal|2
condition|?
literal|0
else|:
name|psize
operator|-
name|VDEV_LABELS
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_label_read
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|l
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read_phys
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|vdev_label_offset
argument_list|(
name|vd
operator|->
name|vdev_psize
argument_list|,
name|l
argument_list|,
name|offset
argument_list|)
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|ZIO_CHECKSUM_LABEL
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_label_write
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|l
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_write_phys
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|vdev_label_offset
argument_list|(
name|vd
operator|->
name|vdev_psize
argument_list|,
name|l
argument_list|,
name|offset
argument_list|)
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|ZIO_CHECKSUM_LABEL
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the nvlist representing this vdev's config.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|vdev_config_generate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|boolean_t
name|getstats
parameter_list|,
name|boolean_t
name|isspare
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isspare
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
name|vd
operator|->
name|vdev_id
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
name|vd
operator|->
name|vdev_devid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_nparity
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|strcmp
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure someone hasn't managed to sneak a fancy new vdev 		 * into a crufty old storage pool. 		 */
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_nparity
operator|==
literal|1
operator|||
operator|(
name|vd
operator|->
name|vdev_nparity
operator|==
literal|2
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|ZFS_VERSION_RAID6
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Note that we'll add the nparity tag even on storage pools 		 * that only support a single parity device -- older software 		 * will just ignore it. 		 */
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
name|vd
operator|->
name|vdev_nparity
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_wholedisk
operator|!=
operator|-
literal|1ULL
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
name|vd
operator|->
name|vdev_wholedisk
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_not_present
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isspare
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isspare
operator|&&
name|vd
operator|==
name|vd
operator|->
name|vdev_top
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_ARRAY
argument_list|,
name|vd
operator|->
name|vdev_ms_array
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_SHIFT
argument_list|,
name|vd
operator|->
name|vdev_ms_shift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASIZE
argument_list|,
name|vd
operator|->
name|vdev_asize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_dtl
operator|.
name|smo_object
operator|!=
literal|0
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DTL
argument_list|,
name|vd
operator|->
name|vdev_dtl
operator|.
name|smo_object
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getstats
condition|)
block|{
name|vdev_stat_t
name|vs
decl_stmt|;
name|vdev_get_stats
argument_list|(
name|vd
argument_list|,
operator|&
name|vs
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|;
name|child
operator|=
name|kmem_alloc
argument_list|(
name|vd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|child
index|[
name|c
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|getstats
argument_list|,
name|isspare
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|vd
operator|->
name|vdev_children
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|child
argument_list|,
name|vd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_offline
operator|&&
operator|!
name|vd
operator|->
name|vdev_tmpoffline
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
name|DATA_TYPE_UINT64
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nv
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|vdev_label_read_config
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|nvlist_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|vdev_phys_t
modifier|*
name|vp
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|l
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vp
operator|=
name|zio_buf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_CONFIG_HELD
argument_list|)
expr_stmt|;
name|vdev_label_read
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|vp
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_vdev_phys
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
operator|&&
name|nvlist_unpack
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|,
sizeof|sizeof
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|)
argument_list|,
operator|&
name|config
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if a device is in use.  The 'spare_guid' parameter will be filled  * in with the device guid if this spare is active elsewhere on the system.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|vdev_inuse
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|vdev_labeltype_t
name|reason
parameter_list|,
name|uint64_t
modifier|*
name|spare_guid
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|uint64_t
name|state
decl_stmt|,
name|pool_guid
decl_stmt|,
name|device_guid
decl_stmt|,
name|txg
decl_stmt|,
name|spare_pool
decl_stmt|;
name|uint64_t
name|vdtxg
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
if|if
condition|(
name|spare_guid
condition|)
operator|*
name|spare_guid
operator|=
literal|0ULL
expr_stmt|;
comment|/* 	 * Read the label, if any, and perform some basic sanity checks. 	 */
if|if
condition|(
operator|(
name|label
operator|=
name|vdev_label_read_config
argument_list|(
name|vd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_CREATE_TXG
argument_list|,
operator|&
name|vdtxg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|device_guid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
operator|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if this device indeed belongs to the pool it claims to 	 * be a part of.  The only way this is allowed is if the device is a hot 	 * spare (which we check for later on). 	 */
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
operator|!
name|spa_guid_exists
argument_list|(
name|pool_guid
argument_list|,
name|device_guid
argument_list|)
operator|&&
operator|!
name|spa_spare_exists
argument_list|(
name|device_guid
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* 	 * If the transaction group is zero, then this an initialized (but 	 * unused) label.  This is only an error if the create transaction 	 * on-disk is the same as the one we're using now, in which case the 	 * user has attempted to add the same vdev multiple times in the same 	 * transaction. 	 */
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
name|txg
operator|==
literal|0
operator|&&
name|vdtxg
operator|==
name|crtxg
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
comment|/* 	 * Check to see if this is a spare device.  We do an explicit check for 	 * spa_has_spare() here because it may be on our pending list of spares 	 * to add. 	 */
if|if
condition|(
name|spa_spare_exists
argument_list|(
name|device_guid
argument_list|,
operator|&
name|spare_pool
argument_list|)
operator|||
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|device_guid
argument_list|)
condition|)
block|{
if|if
condition|(
name|spare_guid
condition|)
operator|*
name|spare_guid
operator|=
name|device_guid
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|VDEV_LABEL_CREATE
case|:
return|return
operator|(
name|B_TRUE
operator|)
return|;
case|case
name|VDEV_LABEL_REPLACE
case|:
return|return
operator|(
operator|!
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|device_guid
argument_list|)
operator|||
name|spare_pool
operator|!=
literal|0ULL
operator|)
return|;
case|case
name|VDEV_LABEL_SPARE
case|:
return|return
operator|(
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|device_guid
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * If the device is marked ACTIVE, then this device is in use by another 	 * pool on the system. 	 */
return|return
operator|(
name|state
operator|==
name|POOL_STATE_ACTIVE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a vdev label.  We check to make sure each leaf device is not in  * use, and writable.  We put down an initial label which we will later  * overwrite with a complete label.  Note that it's important to do this  * sequentially, not in parallel, so that we catch cases of multiple use of the  * same leaf vdev in the vdev we're creating -- e.g. mirroring a disk with  * itself.  */
end_comment

begin_function
name|int
name|vdev_label_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|vdev_labeltype_t
name|reason
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|vdev_phys_t
modifier|*
name|vp
decl_stmt|;
name|vdev_boot_header_t
modifier|*
name|vb
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|l
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|spare_guid
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|crtxg
argument_list|,
name|reason
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Dead vdevs cannot be initialized. 	 */
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * Determine if the vdev is in use. 	 */
if|if
condition|(
name|reason
operator|!=
name|VDEV_LABEL_REMOVE
operator|&&
name|vdev_inuse
argument_list|(
name|vd
argument_list|,
name|crtxg
argument_list|,
name|reason
argument_list|,
operator|&
name|spare_guid
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ASSERT
argument_list|(
name|reason
operator|!=
name|VDEV_LABEL_REMOVE
operator|||
name|vdev_inuse
argument_list|(
name|vd
argument_list|,
name|crtxg
argument_list|,
name|reason
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a request to add or replace a spare that is in use 	 * elsewhere on the system, then we must update the guid (which was 	 * initialized to a random value) to reflect the actual GUID (which is 	 * shared between multiple pools). 	 */
if|if
condition|(
name|reason
operator|!=
name|VDEV_LABEL_REMOVE
operator|&&
name|spare_guid
operator|!=
literal|0ULL
condition|)
block|{
name|vdev_t
modifier|*
name|pvd
init|=
name|vd
operator|->
name|vdev_parent
decl_stmt|;
for|for
control|(
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
block|{
name|pvd
operator|->
name|vdev_guid_sum
operator|-=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|pvd
operator|->
name|vdev_guid_sum
operator|+=
name|spare_guid
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_guid
operator|=
name|vd
operator|->
name|vdev_guid_sum
operator|=
name|spare_guid
expr_stmt|;
comment|/* 		 * If this is a replacement, then we want to fallthrough to the 		 * rest of the code.  If we're adding a spare, then it's already 		 * labelled appropriately and we can just return. 		 */
if|if
condition|(
name|reason
operator|==
name|VDEV_LABEL_SPARE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|reason
operator|==
name|VDEV_LABEL_REPLACE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize its label. 	 */
name|vp
operator|=
name|zio_buf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Generate a label describing the pool and our top-level vdev. 	 * We mark it as being from txg 0 to indicate that it's not 	 * really part of an active pool just yet.  The labels will 	 * be written again with a meaningful txg by spa_sync(). 	 */
if|if
condition|(
name|reason
operator|==
name|VDEV_LABEL_SPARE
operator|||
operator|(
name|reason
operator|==
name|VDEV_LABEL_REMOVE
operator|&&
name|vd
operator|->
name|vdev_isspare
operator|)
condition|)
block|{
comment|/* 		 * For inactive hot spares, we generate a special label that 		 * identifies as a mutually shared hot spare.  We write the 		 * label if we are adding a hot spare, or if we are removing an 		 * active hot spare (in which case we want to revert the 		 * labels). 		 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|label
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|POOL_STATE_SPARE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|label
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
literal|0ULL
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * Add our creation time.  This allows us to detect multiple 		 * vdev uses as described above, and automatically expires if we 		 * fail. 		 */
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_CREATE_TXG
argument_list|,
name|crtxg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|vp
operator|->
name|vp_nvlist
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|)
expr_stmt|;
name|error
operator|=
name|nvlist_pack
argument_list|(
name|label
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* EFAULT means nvlist_pack ran out of room */
return|return
operator|(
name|error
operator|==
name|EFAULT
condition|?
name|ENAMETOOLONG
else|:
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Initialize boot block header. 	 */
name|vb
operator|=
name|zio_buf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_boot_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vb
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_boot_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|vb
operator|->
name|vb_magic
operator|=
name|VDEV_BOOT_MAGIC
expr_stmt|;
name|vb
operator|->
name|vb_version
operator|=
name|VDEV_BOOT_VERSION
expr_stmt|;
name|vb
operator|->
name|vb_offset
operator|=
name|VDEV_BOOT_OFFSET
expr_stmt|;
name|vb
operator|->
name|vb_size
operator|=
name|VDEV_BOOT_SIZE
expr_stmt|;
comment|/* 	 * Initialize uberblock template. 	 */
name|ub
operator|=
name|zio_buf_alloc
argument_list|(
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ub
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ub
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|ub
operator|->
name|ub_txg
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Write everything in parallel. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|vp
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_vdev_phys
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|vb
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_boot_header
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_boot_header_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|VDEV_UBERBLOCK_COUNT
argument_list|(
name|vd
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|ub
argument_list|,
name|VDEV_UBERBLOCK_OFFSET
argument_list|(
name|vd
argument_list|,
name|n
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|ub
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|vb
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_boot_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this vdev hasn't been previously identified as a spare, then we 	 * mark it as such only if a) we are labelling it as a spare, or b) it 	 * exists as a spare elsewhere in the system. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|vd
operator|->
name|vdev_isspare
operator|&&
operator|(
name|reason
operator|==
name|VDEV_LABEL_SPARE
operator|||
name|spa_spare_exists
argument_list|(
name|vd
operator|->
name|vdev_guid
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|spa_spare_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * uberblock load/sync  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Consider the following situation: txg is safely synced to disk.  We've  * written the first uberblock for txg + 1, and then we lose power.  When we  * come back up, we fail to see the uberblock for txg + 1 because, say,  * it was on a mirrored device and the replica to which we wrote txg + 1  * is now offline.  If we then make some changes and sync txg + 1, and then  * the missing replica comes back, then for a new seconds we'll have two  * conflicting uberblocks on disk with the same txg.  The solution is simple:  * among uberblocks with equal txg, choose the one with the latest timestamp.  */
end_comment

begin_function
specifier|static
name|int
name|vdev_uberblock_compare
parameter_list|(
name|uberblock_t
modifier|*
name|ub1
parameter_list|,
name|uberblock_t
modifier|*
name|ub2
parameter_list|)
block|{
if|if
condition|(
name|ub1
operator|->
name|ub_txg
operator|<
name|ub2
operator|->
name|ub_txg
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ub1
operator|->
name|ub_txg
operator|>
name|ub2
operator|->
name|ub_txg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ub1
operator|->
name|ub_timestamp
operator|<
name|ub2
operator|->
name|ub_timestamp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ub1
operator|->
name|ub_timestamp
operator|>
name|ub2
operator|->
name|ub_timestamp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_uberblock_load_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|uberblock_t
modifier|*
name|ub
init|=
name|zio
operator|->
name|io_data
decl_stmt|;
name|uberblock_t
modifier|*
name|ubbest
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
operator|==
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|zio
operator|->
name|io_vd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|uberblock_verify
argument_list|(
name|ub
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_uberblock_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_uberblock_compare
argument_list|(
name|ub
argument_list|,
name|ubbest
argument_list|)
operator|>
literal|0
condition|)
operator|*
name|ubbest
operator|=
operator|*
name|ub
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_uberblock_lock
argument_list|)
expr_stmt|;
block|}
name|zio_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_uberblock_load
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uberblock_t
modifier|*
name|ubbest
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_uberblock_load
argument_list|(
name|zio
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|ubbest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
return|return;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|VDEV_UBERBLOCK_COUNT
argument_list|(
name|vd
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|vdev_label_read
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|zio_buf_alloc
argument_list|(
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_OFFSET
argument_list|(
name|vd
argument_list|,
name|n
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|,
name|vdev_uberblock_load_done
argument_list|,
name|ubbest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Write the uberblock to both labels of all leaves of the specified vdev.  * We only get credit for writes to known-visible vdevs; see spa_vdev_add().  */
end_comment

begin_function
specifier|static
name|void
name|vdev_uberblock_sync_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|uint64_t
modifier|*
name|good_writes
init|=
name|zio
operator|->
name|io_root
operator|->
name|io_private
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_top
operator|->
name|vdev_ms_array
operator|!=
literal|0
condition|)
name|atomic_add_64
argument_list|(
name|good_writes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_uberblock_sync
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uberblock_t
modifier|*
name|ub
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_uberblock_sync
argument_list|(
name|zio
argument_list|,
name|ub
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
return|return;
name|n
operator|=
name|txg
operator|&
operator|(
name|VDEV_UBERBLOCK_COUNT
argument_list|(
name|vd
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ub
operator|->
name|ub_txg
operator|==
name|txg
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|ub
argument_list|,
name|VDEV_UBERBLOCK_OFFSET
argument_list|(
name|vd
argument_list|,
name|n
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|,
name|vdev_uberblock_sync_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"vdev %s in txg %llu\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_uberblock_sync_tree
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uberblock_t
modifier|*
name|ub
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|uberblock_t
modifier|*
name|ubbuf
decl_stmt|;
name|size_t
name|size
init|=
name|vd
operator|->
name|vdev_top
condition|?
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
else|:
name|SPA_MAXBLOCKSIZE
decl_stmt|;
name|uint64_t
modifier|*
name|good_writes
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ubbuf
operator|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ubbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|ubbuf
operator|=
operator|*
name|ub
expr_stmt|;
name|good_writes
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|good_writes
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
name|vdev_uberblock_sync
argument_list|(
name|zio
argument_list|,
name|ubbuf
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|*
name|good_writes
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"partial success: good_writes = %llu\n"
argument_list|,
operator|*
name|good_writes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * It's possible to have no good writes and no error if every vdev is in 	 * the CANT_OPEN state. 	 */
if|if
condition|(
operator|*
name|good_writes
operator|==
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|kmem_free
argument_list|(
name|good_writes
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|ubbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sync out an individual vdev.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_sync_label_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|uint64_t
modifier|*
name|good_writes
init|=
name|zio
operator|->
name|io_root
operator|->
name|io_private
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|atomic_add_64
argument_list|(
name|good_writes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_sync_label
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|l
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|vdev_phys_t
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_sync_label
argument_list|(
name|zio
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|l
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
return|return;
comment|/* 	 * Generate a label describing the top-level config to which we belong. 	 */
name|label
operator|=
name|spa_config_generate
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|vp
operator|=
name|zio_buf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|vp
operator|->
name|vp_nvlist
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_pack
argument_list|(
name|label
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
condition|)
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|vp
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_vdev_phys
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|,
name|vdev_sync_label_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s label %d txg %llu\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
name|l
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_sync_labels
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|l
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|uint64_t
modifier|*
name|good_writes
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|good_writes
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|NULL
argument_list|,
name|good_writes
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
comment|/* 	 * Recursively kick off writes to all labels. 	 */
name|vdev_sync_label
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|*
name|good_writes
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"partial success: good_writes = %llu\n"
argument_list|,
operator|*
name|good_writes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|good_writes
operator|==
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
name|kmem_free
argument_list|(
name|good_writes
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sync the entire vdev configuration.  *  * The order of operations is carefully crafted to ensure that  * if the system panics or loses power at any time, the state on disk  * is still transactionally consistent.  The in-line comments below  * describe the failure semantics at each stage.  *  * Moreover, it is designed to be idempotent: if spa_sync_labels() fails  * at any time, you can just call it again, and it will resume its work.  */
end_comment

begin_function
name|int
name|vdev_config_sync
parameter_list|(
name|vdev_t
modifier|*
name|uvd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|uvd
operator|->
name|vdev_spa
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
init|=
operator|&
name|spa
operator|->
name|spa_uberblock
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|l
decl_stmt|,
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|ub
operator|->
name|ub_txg
operator|<=
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * If this isn't a resync due to I/O errors, and nothing changed 	 * in this transaction group, and the vdev configuration hasn't changed, 	 * then there's nothing to do. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_txg
operator|<
name|txg
operator|&&
name|uberblock_update
argument_list|(
name|ub
argument_list|,
name|rvd
argument_list|,
name|txg
argument_list|)
operator|==
name|B_FALSE
operator|&&
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"nothing to sync in %s in txg %llu\n"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|txg
operator|<=
name|spa
operator|->
name|spa_final_txg
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"syncing %s txg %llu\n"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the write cache of every disk that's been written to 	 * in this transaction group.  This ensures that all blocks 	 * written in this txg will be committed to stable storage 	 * before any uberblock that references them. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|vd
operator|=
name|txg_list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
init|;
name|vd
condition|;
name|vd
operator|=
name|txg_list_next
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|vd
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
control|)
block|{
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|DKIOCFLUSHWRITECACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * Sync out the even labels (L0, L2) for every dirty vdev.  If the 	 * system dies in the middle of this process, that's OK: all of the 	 * even labels that made it to disk will be newer than any uberblock, 	 * and will therefore be considered invalid.  The odd labels (L1, L3), 	 * which have not yet been touched, will still be valid. 	 */
for|for
control|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
init|;
name|vd
operator|!=
name|NULL
condition|;
name|vd
operator|=
name|list_next
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|,
name|vd
argument_list|)
control|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|&
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_sync_labels
argument_list|(
name|vd
argument_list|,
name|l
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Flush the new labels to disk.  This ensures that all even-label 	 * updates are committed to stable storage before the uberblock update. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
init|;
name|vd
operator|!=
name|NULL
condition|;
name|vd
operator|=
name|list_next
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|,
name|vd
argument_list|)
control|)
block|{
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|DKIOCFLUSHWRITECACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * Sync the uberblocks to all vdevs in the tree specified by uvd. 	 * If the system dies in the middle of this step, there are two cases 	 * to consider, and the on-disk state is consistent either way: 	 * 	 * (1)	If none of the new uberblocks made it to disk, then the 	 *	previous uberblock will be the newest, and the odd labels 	 *	(which had not yet been touched) will be valid with respect 	 *	to that uberblock. 	 * 	 * (2)	If one or more new uberblocks made it to disk, then they 	 *	will be the newest, and the even labels (which had all 	 *	been successfully committed) will be valid with respect 	 *	to the new uberblocks. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_uberblock_sync_tree
argument_list|(
name|spa
argument_list|,
name|ub
argument_list|,
name|uvd
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Flush the uberblocks to disk.  This ensures that the odd labels 	 * are no longer needed (because the new uberblocks and the even 	 * labels are safely on disk), so it is safe to overwrite them. 	 */
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio_ioctl
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|uvd
argument_list|,
name|DKIOCFLUSHWRITECACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Sync out odd labels for every dirty vdev.  If the system dies 	 * in the middle of this process, the even labels and the new 	 * uberblocks will suffice to open the pool.  The next time 	 * the pool is opened, the first thing we'll do -- before any 	 * user data is modified -- is mark every vdev dirty so that 	 * all labels will be brought up to date. 	 */
for|for
control|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
init|;
name|vd
operator|!=
name|NULL
condition|;
name|vd
operator|=
name|list_next
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|,
name|vd
argument_list|)
control|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_sync_labels
argument_list|(
name|vd
argument_list|,
name|l
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Flush the new labels to disk.  This ensures that all odd-label 	 * updates are committed to stable storage before the next 	 * transaction group begins. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
operator||
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
init|;
name|vd
operator|!=
name|NULL
condition|;
name|vd
operator|=
name|list_next
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|,
name|vd
argument_list|)
control|)
block|{
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|DKIOCFLUSHWRITECACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

