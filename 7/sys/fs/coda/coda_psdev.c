begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *             Coda: an Experimental Distributed File System  *                              Release 3.1  *  *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *  * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *  * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *  * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *  * 	@(#) src/sys/coda/coda_psdev.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  */
end_comment

begin_comment
comment|/*-  * Mach Operating System  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda filesystem at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.  */
end_comment

begin_comment
comment|/*  * These routines define the psuedo device for communication between Coda's  * Venus and Minicache in Mach 2.6. They used to be in cfs_subr.c, but I  * moved them to make it easier to port the Minicache without porting coda.  * -- DCS 10/12/94  */
end_comment

begin_comment
comment|/*  * These routines are the device entry points for Venus.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* must come after sys/malloc.h */
end_comment

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<fs/coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<fs/coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<fs/coda/coda_io.h>
end_include

begin_include
include|#
directive|include
file|<fs/coda/coda_psdev.h>
end_include

begin_comment
comment|/*  * Variables to determine how Coda sleeps and whether or not it is  * interruptible when it does sleep waiting for Venus.  */
end_comment

begin_comment
comment|/* #define	CTL_C */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_C
end_ifdef

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|coda_psdev_print_entry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|outstanding_upcalls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coda_call_sleep
init|=
name|PZERO
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_C
end_ifdef

begin_decl_stmt
name|int
name|coda_pcatch
init|=
name|PCATCH
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENTRY
value|do {							\ 	if (coda_psdev_print_entry)					\ 		myprintf(("Entered %s\n", __func__));			\ } while (0)
end_define

begin_struct
struct|struct
name|vmsg
block|{
name|TAILQ_ENTRY
argument_list|(
argument|vmsg
argument_list|)
name|vm_chain
expr_stmt|;
name|caddr_t
name|vm_data
decl_stmt|;
name|u_short
name|vm_flags
decl_stmt|;
name|u_short
name|vm_inSize
decl_stmt|;
comment|/* Size is at most 5000 bytes */
name|u_short
name|vm_outSize
decl_stmt|;
name|u_short
name|vm_opcode
decl_stmt|;
comment|/* Copied from data to save ptr deref */
name|int
name|vm_unique
decl_stmt|;
name|caddr_t
name|vm_sleep
decl_stmt|;
comment|/* Not used by Mach. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VM_READ
value|1
end_define

begin_define
define|#
directive|define
name|VM_WRITE
value|2
end_define

begin_define
define|#
directive|define
name|VM_INTR
value|4
end_define

begin_comment
comment|/* Unused. */
end_comment

begin_function
name|int
name|vc_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|struct
name|coda_mntinfo
modifier|*
name|mnt
decl_stmt|;
name|ENTRY
expr_stmt|;
name|mnt
operator|=
name|dev2coda_mntinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mnt
argument_list|,
operator|(
literal|"Coda: tried to open uninitialized cfs device"
operator|)
argument_list|)
expr_stmt|;
name|vcp
operator|=
operator|&
name|mnt
operator|->
name|mi_vcomm
expr_stmt|;
if|if
condition|(
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bzero
argument_list|(
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|selinfo
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|vcp
operator|->
name|vc_replies
argument_list|)
expr_stmt|;
name|MARK_VC_OPEN
argument_list|(
name|vcp
argument_list|)
expr_stmt|;
name|mnt
operator|->
name|mi_vfsp
operator|=
name|NULL
expr_stmt|;
name|mnt
operator|->
name|mi_rootvp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vc_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|,
modifier|*
name|nvmp
init|=
name|NULL
decl_stmt|;
name|struct
name|coda_mntinfo
modifier|*
name|mi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ENTRY
expr_stmt|;
name|mi
operator|=
name|dev2coda_mntinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mi
argument_list|,
operator|(
literal|"Coda: closing unknown cfs device"
operator|)
argument_list|)
expr_stmt|;
name|vcp
operator|=
operator|&
name|mi
operator|->
name|mi_vcomm
expr_stmt|;
name|KASSERT
argument_list|(
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
argument_list|,
operator|(
literal|"Coda: closing unopened cfs device"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent future operations on this vfs from succeeding by 	 * auto-unmounting any vfs mounted via this device.  This frees user 	 * or sysadm from having to remember where all mount points are 	 * located.  Put this before WAKEUPs to avoid queuing new messages 	 * between the WAKEUP and the unmount (which can happen if we're 	 * unlucky). 	 */
if|if
condition|(
name|mi
operator|->
name|mi_rootvp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Just a simple open/close with no mount. 		 */
name|MARK_VC_CLOSED
argument_list|(
name|vcp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Let unmount know this is for real. 	 */
name|VTOC
argument_list|(
name|mi
operator|->
name|mi_rootvp
argument_list|)
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
name|coda_unmounting
argument_list|(
name|mi
operator|->
name|mi_vfsp
argument_list|)
expr_stmt|;
comment|/* 	 * Wakeup clients so they can return. 	 */
name|outstanding_upcalls
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|vmp
argument_list|,
argument|&vcp->vc_requests
argument_list|,
argument|vm_chain
argument_list|,
argument|nvmp
argument_list|)
block|{
comment|/* 		 * Free signal request messages and don't wakeup cause no one 		 * is waiting. 		 */
if|if
condition|(
name|vmp
operator|->
name|vm_opcode
operator|==
name|CODA_SIGNAL
condition|)
block|{
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
operator|->
name|vm_data
argument_list|,
operator|(
name|u_int
operator|)
name|VC_IN_NO_DATA
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outstanding_upcalls
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|vmp
argument_list|,
argument|&vcp->vc_replies
argument_list|,
argument|vm_chain
argument_list|)
block|{
name|outstanding_upcalls
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
block|}
name|MARK_VC_CLOSED
argument_list|(
name|vcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|outstanding_upcalls
condition|)
block|{
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"presleep: outstanding_upcalls = %d\n"
argument_list|,
name|outstanding_upcalls
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|outstanding_upcalls
argument_list|,
name|coda_call_sleep
argument_list|,
literal|"coda_umount"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"postsleep: outstanding_upcalls = %d\n"
argument_list|,
name|outstanding_upcalls
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|err
operator|=
name|dounmount
argument_list|(
name|mi
operator|->
name|mi_vfsp
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|myprintf
argument_list|(
operator|(
literal|"Error %d unmounting vfs in vcclose(%s)\n"
operator|,
name|err
operator|,
name|devtoname
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vc_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ENTRY
expr_stmt|;
name|vcp
operator|=
operator|&
name|dev2coda_mntinfo
argument_list|(
name|dev
argument_list|)
operator|->
name|mi_vcomm
expr_stmt|;
comment|/* 	 * Get message at head of request queue. 	 */
name|vmp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Nothing to read */
comment|/* 	 * Move the input args into userspace. 	 * 	 * XXXRW: This is not safe in the presence of>1 reader, as vmp is 	 * still on the head of the list. 	 */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|vmp
operator|->
name|vm_data
argument_list|,
name|vmp
operator|->
name|vm_inSize
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcread: error (%d) on uiomove\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|,
name|vmp
argument_list|,
name|vm_chain
argument_list|)
expr_stmt|;
comment|/* 	 * If request was a signal, free up the message and don't enqueue it 	 * in the reply queue. 	 */
if|if
condition|(
name|vmp
operator|->
name|vm_opcode
operator|==
name|CODA_SIGNAL
condition|)
block|{
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcread: signal msg (%d, %d)\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|)
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
operator|->
name|vm_data
argument_list|,
operator|(
name|u_int
operator|)
name|VC_IN_NO_DATA
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vmp
operator|->
name|vm_flags
operator||=
name|VM_READ
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vcp
operator|->
name|vc_replies
argument_list|,
name|vmp
argument_list|,
name|vm_chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vc_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|;
name|struct
name|coda_out_hdr
modifier|*
name|out
decl_stmt|;
name|u_long
name|seq
decl_stmt|;
name|u_long
name|opcode
decl_stmt|;
name|int
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ENTRY
expr_stmt|;
name|vcp
operator|=
operator|&
name|dev2coda_mntinfo
argument_list|(
name|dev
argument_list|)
operator|->
name|mi_vcomm
expr_stmt|;
comment|/* 	 * Peek at the opcode, unique without transfering the data. 	 */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: error (%d) on uiomove\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|opcode
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|seq
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcwrite got a call for %ld.%ld\n"
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOWNCALL
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|union
name|outputArgs
name|pbuf
decl_stmt|;
comment|/* 		 * Get the rest of the data. 		 */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pbuf
operator|.
name|coda_purgeuser
operator|.
name|oh
operator|.
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: error (%d) on uiomove (Op %ld "
literal|"seq %ld)\n"
operator|,
name|error
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|handleDownCall
argument_list|(
name|dev2coda_mntinfo
argument_list|(
name|dev
argument_list|)
argument_list|,
name|opcode
argument_list|,
operator|&
name|pbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Look for the message on the (waiting for) reply queue. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|vmp
argument_list|,
argument|&vcp->vc_replies
argument_list|,
argument|vm_chain
argument_list|)
block|{
if|if
condition|(
name|vmp
operator|->
name|vm_unique
operator|==
name|seq
condition|)
break|break;
block|}
if|if
condition|(
name|vmp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: msg (%ld, %ld) not found\n"
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
comment|/* 	 * Remove the message from the reply queue. 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vcp
operator|->
name|vc_replies
argument_list|,
name|vmp
argument_list|,
name|vm_chain
argument_list|)
expr_stmt|;
comment|/* 	 * Move data into response buffer. 	 */
name|out
operator|=
operator|(
expr|struct
name|coda_out_hdr
operator|*
operator|)
name|vmp
operator|->
name|vm_data
expr_stmt|;
comment|/* 	 * Don't need to copy opcode and uniquifier. 	 * 	 * Get the rest of the data. 	 */
if|if
condition|(
name|vmp
operator|->
name|vm_outSize
operator|<
name|uiop
operator|->
name|uio_resid
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: more data than asked for (%d< %d)\n"
operator|,
name|vmp
operator|->
name|vm_outSize
operator|,
name|uiop
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Notify caller of the error. 		 */
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Save the value. 	 */
name|buf
index|[
literal|0
index|]
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|out
operator|->
name|result
argument_list|,
name|vmp
operator|->
name|vm_outSize
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: error (%d) on uiomove (op %ld seq %ld)\n"
operator|,
name|error
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * I don't think these are used, but just in case. 	 * 	 * XXX - aren't these two already correct? -bnoble 	 */
name|out
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|out
operator|->
name|unique
operator|=
name|seq
expr_stmt|;
name|vmp
operator|->
name|vm_outSize
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* Amount of data transferred? */
name|vmp
operator|->
name|vm_flags
operator||=
name|VM_WRITE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|CODA_OPEN_BY_FD
condition|)
block|{
name|struct
name|coda_open_by_fd_out
modifier|*
name|tmp
init|=
operator|(
expr|struct
name|coda_open_by_fd_out
operator|*
operator|)
name|out
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tmp
operator|->
name|oh
operator|.
name|result
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|getvnode
argument_list|(
name|uiop
operator|->
name|uio_td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|tmp
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 				 * XXX: Since the whole driver runs with 				 * Giant, don't actually need to acquire it 				 * explicitly here yet. 				 */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|uiop
operator|->
name|uio_td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
block|}
name|tmp
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vc_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|t
parameter_list|)
block|{
name|ENTRY
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CODARESIZE
case|:
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
name|CODASTATS
case|:
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
name|CODAPRINT
case|:
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
name|CIOC_KERNEL_VERSION
case|:
switch|switch
condition|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
condition|)
block|{
case|case
literal|0
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|coda_kernel_version
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
case|case
literal|2
case|:
if|if
condition|(
name|coda_kernel_version
operator|!=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|vc_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|int
name|event_msk
init|=
literal|0
decl_stmt|;
name|ENTRY
expr_stmt|;
name|vcp
operator|=
operator|&
name|dev2coda_mntinfo
argument_list|(
name|dev
argument_list|)
operator|->
name|mi_vcomm
expr_stmt|;
name|event_msk
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_msk
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|)
condition|)
return|return
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
return|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Statistics.  */
end_comment

begin_decl_stmt
name|struct
name|coda_clstat
name|coda_clstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Key question: whether to sleep interuptably or uninteruptably when waiting  * for Venus.  The former seems better (cause you can ^C a job), but then  * GNU-EMACS completion breaks.  Use tsleep with no timeout, and no longjmp  * happens.  But, when sleeping "uninterruptibly", we don't get told if it  * returns abnormally (e.g. kill -9).  */
end_comment

begin_function
name|int
name|coda_call
parameter_list|(
name|struct
name|coda_mntinfo
modifier|*
name|mntinfo
parameter_list|,
name|int
name|inSize
parameter_list|,
name|int
modifier|*
name|outSize
parameter_list|,
name|caddr_t
name|buffer
parameter_list|)
block|{
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_C
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|sigset_t
name|psig_omask
decl_stmt|;
name|sigset_t
name|tempset
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Unlikely, but could be a race condition with a dying warden. 	 */
if|if
condition|(
name|mntinfo
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
name|vcp
operator|=
operator|&
operator|(
name|mntinfo
operator|->
name|mi_vcomm
operator|)
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
operator|(
operator|(
expr|struct
name|coda_in_hdr
operator|*
block|)
function|buffer
end_function

begin_expr_stmt
unit|)
operator|->
name|opcode
expr|]
operator|++
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
end_if

begin_expr_stmt
name|CODA_ALLOC
argument_list|(
name|vmp
argument_list|,
expr|struct
name|vmsg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Format the request message. 	 */
end_comment

begin_expr_stmt
name|vmp
operator|->
name|vm_data
operator|=
name|buffer
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_flags
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_inSize
operator|=
name|inSize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_outSize
operator|=
operator|*
name|outSize
condition|?
operator|*
name|outSize
else|:
name|inSize
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* |buffer|>= inSize */
end_comment

begin_expr_stmt
name|vmp
operator|->
name|vm_opcode
operator|=
operator|(
operator|(
expr|struct
name|coda_in_hdr
operator|*
operator|)
name|buffer
operator|)
operator|->
name|opcode
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_unique
operator|=
operator|++
name|vcp
operator|->
name|vc_seq
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"Doing a call for %d.%d\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|)
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	 * Fill in the common input args. 	 */
end_comment

begin_expr_stmt
operator|(
operator|(
expr|struct
name|coda_in_hdr
operator|*
operator|)
name|buffer
operator|)
operator|->
name|unique
operator|=
name|vmp
operator|->
name|vm_unique
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Append msg to request queue and poke Venus. 	 */
end_comment

begin_expr_stmt
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|,
name|vmp
argument_list|,
name|vm_chain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|selwakeuppri
argument_list|(
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|,
name|coda_call_sleep
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * We can be interrupted while we wait for Venus to process our 	 * request.  If the interrupt occurs before Venus has read the 	 * request, we dequeue and return. If it occurs after the read but 	 * before the reply, we dequeue, send a signal message, and return. 	 * If it occurs after the reply we ignore it.  In no case do we want 	 * to restart the syscall.  If it was interrupted by a venus shutdown 	 * (vcclose), return ENODEV. 	 * 	 * Ignore return, we have to check anyway. 	 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_C
end_ifdef

begin_comment
comment|/* 	 * This is work in progress.  Setting coda_pcatch lets tsleep 	 * reawaken on a ^c or ^z.  The problem is that emacs sets certain 	 * interrupts as SA_RESTART.  This means that we should exit sleep 	 * handle the "signal" and then go to sleep again.  Mostly this is 	 * done by letting the syscall complete and be restarted.  We are not 	 * idempotent and can not do this.  A better solution is necessary. 	 */
end_comment

begin_expr_stmt
name|i
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|psig_omask
operator|=
name|td
operator|->
name|td_sigmask
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
operator|(
name|coda_call_sleep
operator||
name|coda_pcatch
operator|)
argument_list|,
literal|"coda_call"
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"coda_call: tsleep TIMEOUT %d sec\n"
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|SIGEMPTYSET
argument_list|(
name|tempset
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|tempset
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGSETEQ
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|,
name|tempset
argument_list|)
condition|)
block|{
name|SIGADDSET
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"coda_call: tsleep returns %d SIGIO, "
literal|"cnt %d\n"
argument_list|,
name|error
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|SIGDELSET
argument_list|(
name|tempset
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|tempset
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGSETEQ
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|,
name|tempset
argument_list|)
condition|)
block|{
name|SIGADDSET
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"coda_call: tsleep returns "
literal|"%d SIGALRM, cnt %d\n"
argument_list|,
name|error
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"coda_call: tsleep returns "
literal|"%d, cnt %d\n"
argument_list|,
name|error
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
name|tempset
operator|=
name|td
operator|->
name|td_siglist
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tempset
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"coda_call: siglist = %p, "
literal|"sigmask = %p, mask %p\n"
argument_list|,
name|td
operator|->
name|td_siglist
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|,
name|tempset
argument_list|)
expr_stmt|;
break|break;
name|SIGSETOR
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|td
operator|->
name|td_siglist
argument_list|)
expr_stmt|;
name|tempset
operator|=
name|td
operator|->
name|td_siglist
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tempset
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"coda_call: new mask, "
literal|"siglist = %p, sigmask = %p, "
literal|"mask %p\n"
argument_list|,
name|td
operator|->
name|td_siglist
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|,
name|tempset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
do|while
condition|(
name|error
operator|&&
name|i
operator|++
operator|<
literal|128
operator|&&
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
do|;
end_do

begin_expr_stmt
name|td
operator|->
name|td_sigmask
operator|=
name|psig_omask
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signotify
argument_list|(
name|td
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|,
name|coda_call_sleep
argument_list|,
literal|"coda_call"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
block|{
comment|/* 		 * Venus is still alive. 		 * 		 * Op went through, interrupt or not... 		 */
if|if
condition|(
name|vmp
operator|->
name|vm_flags
operator|&
name|VM_WRITE
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|outSize
operator|=
name|vmp
operator|->
name|vm_outSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|vmp
operator|->
name|vm_flags
operator|&
name|VM_READ
operator|)
condition|)
block|{
comment|/* Interrupted before venus read it. */
ifdef|#
directive|ifdef
name|CODA_VERBOSE
if|if
condition|(
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|codadebug
condition|)
endif|#
directive|endif
name|myprintf
argument_list|(
operator|(
literal|"interrupted before read: op = "
literal|"%d.%d, flags = %x\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|,
name|vmp
operator|->
name|vm_flags
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|,
name|vmp
argument_list|,
name|vm_chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * (!(vmp->vm_flags& VM_WRITE)) means interrupted 			 * after upcall started. 			 * 			 * Interrupted after start of upcall, send venus a 			 * signal. 			 */
name|struct
name|coda_in_hdr
modifier|*
name|dog
decl_stmt|;
name|struct
name|vmsg
modifier|*
name|svmp
decl_stmt|;
ifdef|#
directive|ifdef
name|CODA_VERBOSE
if|if
condition|(
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|codadebug
condition|)
endif|#
directive|endif
name|myprintf
argument_list|(
operator|(
literal|"Sending Venus a signal: op = "
literal|"%d.%d, flags = %x\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|,
name|vmp
operator|->
name|vm_flags
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|,
name|vmp
argument_list|,
name|vm_chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
name|CODA_ALLOC
argument_list|(
name|svmp
argument_list|,
expr|struct
name|vmsg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
name|CODA_ALLOC
argument_list|(
operator|(
name|svmp
operator|->
name|vm_data
operator|)
argument_list|,
name|char
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coda_in_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|dog
operator|=
operator|(
expr|struct
name|coda_in_hdr
operator|*
operator|)
name|svmp
operator|->
name|vm_data
expr_stmt|;
name|svmp
operator|->
name|vm_flags
operator|=
literal|0
expr_stmt|;
name|dog
operator|->
name|opcode
operator|=
name|svmp
operator|->
name|vm_opcode
operator|=
name|CODA_SIGNAL
expr_stmt|;
name|dog
operator|->
name|unique
operator|=
name|svmp
operator|->
name|vm_unique
operator|=
name|vmp
operator|->
name|vm_unique
expr_stmt|;
name|svmp
operator|->
name|vm_inSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coda_in_hdr
argument_list|)
expr_stmt|;
comment|/*??? rvb */
name|svmp
operator|->
name|vm_outSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coda_in_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"coda_call: enqueing signal msg "
literal|"(%d, %d)\n"
operator|,
name|svmp
operator|->
name|vm_opcode
operator|,
name|svmp
operator|->
name|vm_unique
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Insert at head of queue! 			 * 			 * XXXRW: Actually, the tail. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vcp
operator|->
name|vc_requests
argument_list|,
name|svmp
argument_list|,
name|vm_chain
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|,
name|coda_call_sleep
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If venus died (!VC_OPEN(vcp)) */
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcclose woke op %d.%d flags %d\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|,
name|vmp
operator|->
name|vm_flags
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|CODA_FREE
argument_list|(
name|vmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|outstanding_upcalls
operator|>
literal|0
operator|&&
operator|(
operator|--
name|outstanding_upcalls
operator|==
literal|0
operator|)
condition|)
name|wakeup
argument_list|(
operator|&
name|outstanding_upcalls
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|(
operator|(
expr|struct
name|coda_out_hdr
operator|*
operator|)
name|buffer
operator|)
operator|->
name|result
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|error
operator|)
return|;
end_return

unit|}
end_unit

