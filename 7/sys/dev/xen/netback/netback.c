begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006, Cisco Systems, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:  *  * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.   * 2. Redistributions in binary form must reproduce the above copyright   *    notice, this list of conditions and the following disclaimer in the   *    documentation and/or other materials provided with the distribution.   * 3. Neither the name of Cisco Systems, Inc. nor the names of its contributors   *    may be used to endorse or promote products derived from this software   *    without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_bridgevar.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<machine/hypervisor-ifs.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<machine/xenbus.h>
end_include

begin_include
include|#
directive|include
file|<machine/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen-public/memory.h>
end_include

begin_include
include|#
directive|include
file|<dev/xen/xenbus/xenbus_comms.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XEN_NETBACK_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("netback (%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XEN_NETBACK_DEBUG_LOTS
end_ifdef

begin_define
define|#
directive|define
name|DDPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("netback (%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_define
define|#
directive|define
name|DPRINTF_MBUF
parameter_list|(
name|_m
parameter_list|)
value|print_mbuf(_m, 0)
end_define

begin_define
define|#
directive|define
name|DPRINTF_MBUF_LEN
parameter_list|(
name|_m
parameter_list|,
name|_len
parameter_list|)
value|print_mbuf(_m, _len)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DDPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DPRINTF_MBUF
parameter_list|(
name|_m
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|DPRINTF_MBUF_LEN
parameter_list|(
name|_m
parameter_list|,
name|_len
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|WPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|printf("netback (%s:%d): " fmt, __FUNCTION__, __LINE__, ##args)
end_define

begin_define
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(x[0]))
end_define

begin_define
define|#
directive|define
name|BUG_ON
value|PANIC_IF
end_define

begin_define
define|#
directive|define
name|IFNAME
parameter_list|(
name|_np
parameter_list|)
value|(_np)->ifp->if_xname
end_define

begin_define
define|#
directive|define
name|NET_TX_RING_SIZE
value|__RING_SIZE((netif_tx_sring_t *)0, PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|NET_RX_RING_SIZE
value|__RING_SIZE((netif_rx_sring_t *)0, PAGE_SIZE)
end_define

begin_struct
struct|struct
name|ring_ref
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|grant_handle_t
name|handle
decl_stmt|;
name|uint64_t
name|bus_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|netback_info
block|{
comment|/* Schedule lists */
name|STAILQ_ENTRY
argument_list|(
argument|netback_info
argument_list|)
name|next_tx
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|netback_info
argument_list|)
name|next_rx
expr_stmt|;
name|int
name|on_tx_sched_list
decl_stmt|;
name|int
name|on_rx_sched_list
decl_stmt|;
name|struct
name|xenbus_device
modifier|*
name|xdev
decl_stmt|;
name|XenbusState
name|frontend_state
decl_stmt|;
name|domid_t
name|domid
decl_stmt|;
name|int
name|handle
decl_stmt|;
name|char
modifier|*
name|bridge
decl_stmt|;
name|int
name|rings_connected
decl_stmt|;
name|struct
name|ring_ref
name|tx_ring_ref
decl_stmt|;
name|struct
name|ring_ref
name|rx_ring_ref
decl_stmt|;
name|netif_tx_back_ring_t
name|tx
decl_stmt|;
name|netif_rx_back_ring_t
name|rx
decl_stmt|;
name|evtchn_port_t
name|evtchn
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|void
modifier|*
name|irq_cookie
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|ref_cnt
decl_stmt|;
name|device_t
name|ndev
decl_stmt|;
name|int
name|attached
decl_stmt|;
block|}
name|netif_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_PENDING_REQS
value|256
end_define

begin_define
define|#
directive|define
name|PKT_PROT_LEN
value|64
end_define

begin_struct
specifier|static
struct|struct
block|{
name|netif_tx_request_t
name|req
decl_stmt|;
name|netif_t
modifier|*
name|netif
decl_stmt|;
block|}
name|pending_tx_info
index|[
name|MAX_PENDING_REQS
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|uint16_t
name|pending_ring
index|[
name|MAX_PENDING_REQS
index|]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|int
name|PEND_RING_IDX
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MASK_PEND_IDX
parameter_list|(
name|_i
parameter_list|)
value|((_i)&(MAX_PENDING_REQS-1))
end_define

begin_decl_stmt
specifier|static
name|PEND_RING_IDX
name|pending_prod
decl_stmt|,
name|pending_cons
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NR_PENDING_REQS
value|(MAX_PENDING_REQS - pending_prod + pending_cons)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|mmap_vstart
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MMAP_VADDR
parameter_list|(
name|_req
parameter_list|)
value|(mmap_vstart + ((_req) * PAGE_SIZE))
end_define

begin_comment
comment|/* Freed TX mbufs get batched on this ring before return to pending_ring. */
end_comment

begin_decl_stmt
specifier|static
name|uint16_t
name|dealloc_ring
index|[
name|MAX_PENDING_REQS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PEND_RING_IDX
name|dealloc_prod
decl_stmt|,
name|dealloc_cons
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|multicall_entry_t
name|rx_mcl
index|[
name|NET_RX_RING_SIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mmu_update_t
name|rx_mmu
index|[
name|NET_RX_RING_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gnttab_transfer_t
name|grant_rx_op
index|[
name|NET_RX_RING_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|grant_handle_t
name|grant_tx_handle
index|[
name|MAX_PENDING_REQS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gnttab_unmap_grant_ref_t
name|tx_unmap_ops
index|[
name|MAX_PENDING_REQS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gnttab_map_grant_ref_t
name|tx_map_ops
index|[
name|MAX_PENDING_REQS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|net_tx_task
decl_stmt|,
name|net_rx_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|rx_task_callout
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument|netback_tx_sched_list
argument_list|,
argument|netback_info
argument_list|)
name|tx_sched_list
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|tx_sched_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument|netback_rx_sched_list
argument_list|,
argument|netback_info
argument_list|)
name|rx_sched_list
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|rx_sched_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|tx_sched_list_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|rx_sched_list_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vif_unit_maker
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protos */
end_comment

begin_function_decl
specifier|static
name|void
name|netback_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netback_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vif_add_dev
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disconnect_rings
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|XEN_NETBACK_DEBUG_LOTS
end_ifdef

begin_comment
comment|/* Debug code to display the contents of an mbuf */
end_comment

begin_function
specifier|static
name|void
name|print_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"mbuf %08x len = %d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|unsigned
name|char
modifier|*
name|d
init|=
name|m
operator|->
name|m_data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|m_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|max
operator|&&
name|j
operator|==
name|max
condition|)
break|break;
if|if
condition|(
operator|(
name|j
operator|++
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%04x:"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|d
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_MFN_ALLOC
value|64
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|mfn_list
index|[
name|MAX_MFN_ALLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|alloc_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|long
name|alloc_mfn
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|mfn
init|=
literal|0
decl_stmt|;
name|struct
name|xen_memory_reservation
name|reservation
init|=
block|{
operator|.
name|extent_start
operator|=
name|mfn_list
block|,
operator|.
name|nr_extents
operator|=
name|MAX_MFN_ALLOC
block|,
operator|.
name|extent_order
operator|=
literal|0
block|,
operator|.
name|domid
operator|=
name|DOMID_SELF
block|}
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|alloc_index
operator|==
literal|0
argument_list|)
condition|)
name|alloc_index
operator|=
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_increase_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_index
operator|!=
literal|0
condition|)
name|mfn
operator|=
name|mfn_list
index|[
operator|--
name|alloc_index
index|]
expr_stmt|;
return|return
name|mfn
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|alloc_empty_page_range
parameter_list|(
name|unsigned
name|long
name|nr_pages
parameter_list|)
block|{
name|void
modifier|*
name|pages
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|multicall_entry_t
name|mcl
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|long
name|mfn_list
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|xen_memory_reservation
name|reservation
init|=
block|{
operator|.
name|extent_start
operator|=
name|mfn_list
block|,
operator|.
name|nr_extents
operator|=
literal|0
block|,
operator|.
name|address_bits
operator|=
literal|0
block|,
operator|.
name|extent_order
operator|=
literal|0
block|,
operator|.
name|domid
operator|=
name|DOMID_SELF
block|}
decl_stmt|;
name|pages
operator|=
name|malloc
argument_list|(
name|nr_pages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pages
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
name|mcl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mcl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nr_pages
condition|)
block|{
name|unsigned
name|long
name|va
init|=
operator|(
name|unsigned
name|long
operator|)
name|pages
operator|+
operator|(
name|i
operator|++
operator|*
name|PAGE_SIZE
operator|)
decl_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_update_va_mapping
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|va
expr_stmt|;
name|mfn_list
index|[
name|j
operator|++
index|]
operator|=
name|vtomach
argument_list|(
name|va
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|xen_phys_machine
index|[
operator|(
name|vtophys
argument_list|(
name|va
argument_list|)
operator|>>
name|PAGE_SHIFT
operator|)
index|]
operator|=
name|INVALID_P2M_ENTRY
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|16
operator|||
name|i
operator|==
name|nr_pages
condition|)
block|{
name|mcl
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|args
index|[
name|MULTI_UVMFLAGS_INDEX
index|]
operator|=
name|UVMF_TLB_FLUSH
operator||
name|UVMF_LOCAL
expr_stmt|;
name|reservation
operator|.
name|nr_extents
operator|=
name|j
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_memory_op
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|XENMEM_decrease_reservation
expr_stmt|;
name|mcl
index|[
name|j
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|reservation
expr_stmt|;
operator|(
name|void
operator|)
name|HYPERVISOR_multicall
argument_list|(
name|mcl
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mcl
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|args
index|[
name|MULTI_UVMFLAGS_INDEX
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|unsigned
name|long
operator|)
name|pages
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XEN_NETBACK_FIXUP_CSUM
end_ifdef

begin_function
specifier|static
name|void
name|fixup_checksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|iphlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|int
name|iplen
init|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
condition|)
block|{
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
decl_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
operator|+
operator|(
name|iplen
operator|-
name|iphlen
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_cksum_skip
argument_list|(
name|m
argument_list|,
name|iplen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
name|iphlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_TCP
expr_stmt|;
block|}
else|else
block|{
name|u_short
name|csum
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
init|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
decl_stmt|;
name|uh
operator|->
name|uh_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_UDP
operator|+
operator|(
name|iplen
operator|-
name|iphlen
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csum
operator|=
name|in_cksum_skip
argument_list|(
name|m
argument_list|,
name|iplen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
name|iphlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|csum
operator|=
literal|0xffff
expr_stmt|;
name|uh
operator|->
name|uh_sum
operator|=
name|csum
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_UDP
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add the interface to the specified bridge */
end_comment

begin_function
specifier|static
name|int
name|add_to_bridge
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|char
modifier|*
name|bridge
parameter_list|)
block|{
name|struct
name|ifdrv
name|ifd
decl_stmt|;
name|struct
name|ifbreq
name|ifb
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp_bridge
init|=
name|ifunit
argument_list|(
name|bridge
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ifp_bridge
condition|)
return|return
name|ENOENT
return|;
name|bzero
argument_list|(
operator|&
name|ifd
argument_list|,
sizeof|sizeof
argument_list|(
name|ifd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ifb
argument_list|,
sizeof|sizeof
argument_list|(
name|ifb
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ifb
operator|.
name|ifbr_ifsname
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ifd
operator|.
name|ifd_name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|ifd
operator|.
name|ifd_cmd
operator|=
name|BRDGADD
expr_stmt|;
name|ifd
operator|.
name|ifd_len
operator|=
sizeof|sizeof
argument_list|(
name|ifb
argument_list|)
expr_stmt|;
name|ifd
operator|.
name|ifd_data
operator|=
operator|&
name|ifb
expr_stmt|;
return|return
name|bridge_ioctl_kern
argument_list|(
name|ifp_bridge
argument_list|,
name|SIOCSDRVSPEC
argument_list|,
operator|&
name|ifd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netif_create
parameter_list|(
name|int
name|handle
parameter_list|,
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|,
name|char
modifier|*
name|bridge
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|netif
operator|=
operator|(
name|netif_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|netif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netif
condition|)
return|return
name|ENOMEM
return|;
name|netif
operator|->
name|ref_cnt
operator|=
literal|1
expr_stmt|;
name|netif
operator|->
name|handle
operator|=
name|handle
expr_stmt|;
name|netif
operator|->
name|domid
operator|=
name|xdev
operator|->
name|otherend_id
expr_stmt|;
name|netif
operator|->
name|xdev
operator|=
name|xdev
expr_stmt|;
name|netif
operator|->
name|bridge
operator|=
name|bridge
expr_stmt|;
name|xdev
operator|->
name|data
operator|=
name|netif
expr_stmt|;
comment|/* Set up ifnet structure */
name|ifp
operator|=
name|netif
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
block|{
if|if
condition|(
name|bridge
condition|)
name|free
argument_list|(
name|bridge
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|netif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|netif
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"vif"
argument_list|,
name|atomic_fetchadd_int
argument_list|(
operator|&
name|vif_unit_maker
argument_list|,
literal|1
argument_list|)
comment|/* ifno */
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|netback_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|netback_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|NET_TX_RING_SIZE
operator|-
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Created %s for domid=%d handle=%d\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|,
name|netif
operator|->
name|domid
argument_list|,
name|netif
operator|->
name|handle
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_get
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|netif
operator|->
name|ref_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|netif_put
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|netif
operator|->
name|ref_cnt
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect_rings
argument_list|(
name|netif
argument_list|)
expr_stmt|;
if|if
condition|(
name|netif
operator|->
name|ifp
condition|)
block|{
name|if_free
argument_list|(
name|netif
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|netif
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|netif
operator|->
name|bridge
condition|)
name|free
argument_list|(
name|netif
operator|->
name|bridge
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|netif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|netback_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|DDPRINTF
argument_list|(
literal|"%s cmd=SIOCSIFFLAGS flags=%x\n"
argument_list|,
name|IFNAME
argument_list|(
operator|(
expr|struct
name|netback_info
operator|*
operator|)
name|ifp
operator|->
name|if_softc
argument_list|)
argument_list|,
operator|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
operator|)
operator|->
name|ifr_flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DDPRINTF
argument_list|(
literal|"%s cmd=%lx\n"
argument_list|,
name|IFNAME
argument_list|(
operator|(
expr|struct
name|netback_info
operator|*
operator|)
name|ifp
operator|->
name|if_softc
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|maybe_schedule_tx_action
parameter_list|(
name|void
parameter_list|)
block|{
name|smp_mb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|NR_PENDING_REQS
operator|<
operator|(
name|MAX_PENDING_REQS
operator|/
literal|2
operator|)
operator|)
operator|&&
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|tx_sched_list
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|net_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes netif from front of list and does not call netif_put() (caller must) */
end_comment

begin_function
specifier|static
name|netif_t
modifier|*
name|remove_from_tx_schedule_list
parameter_list|(
name|void
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tx_sched_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|netif
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|tx_sched_list
argument_list|)
operator|)
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|tx_sched_list
argument_list|,
name|netif
argument_list|,
name|netback_info
argument_list|,
name|next_tx
argument_list|)
expr_stmt|;
name|STAILQ_NEXT
argument_list|(
name|netif
argument_list|,
name|next_tx
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|netif
operator|->
name|on_tx_sched_list
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|tx_sched_list_lock
argument_list|)
expr_stmt|;
return|return
name|netif
return|;
block|}
end_function

begin_comment
comment|/* Adds netif to end of list and calls netif_get() */
end_comment

begin_function
specifier|static
name|void
name|add_to_tx_schedule_list_tail
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
if|if
condition|(
name|netif
operator|->
name|on_tx_sched_list
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|tx_sched_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netif
operator|->
name|on_tx_sched_list
operator|&&
operator|(
name|netif
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|netif_get
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|tx_sched_list
argument_list|,
name|netif
argument_list|,
name|next_tx
argument_list|)
expr_stmt|;
name|netif
operator|->
name|on_tx_sched_list
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|tx_sched_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note on CONFIG_XEN_NETDEV_PIPELINED_TRANSMITTER:  * If this driver is pipelining transmit requests then we can be very  * aggressive in avoiding new-packet notifications -- frontend only needs to  * send a notification if there are no outstanding unreceived responses.  * If we may be buffer transmit buffers for any reason then we must be rather  * more conservative and treat this as the final check for pending work.  */
end_comment

begin_function
specifier|static
name|void
name|netif_schedule_tx_work
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
name|int
name|more_to_do
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_XEN_NETDEV_PIPELINED_TRANSMITTER
name|more_to_do
operator|=
name|RING_HAS_UNCONSUMED_REQUESTS
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|)
expr_stmt|;
else|#
directive|else
name|RING_FINAL_CHECK_FOR_REQUESTS
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|,
name|more_to_do
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|more_to_do
condition|)
block|{
name|DDPRINTF
argument_list|(
literal|"Adding %s to tx sched list\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_tx_schedule_list_tail
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|maybe_schedule_tx_action
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|dealloc_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|netback_dealloc
argument_list|,
operator|&
name|dealloc_lock
argument_list|,
literal|"DEALLOC LOCK"
argument_list|,
name|MTX_SPIN
operator||
name|MTX_NOWITNESS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|netif_idx_release
parameter_list|(
name|uint16_t
name|pending_idx
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|dealloc_lock
argument_list|)
expr_stmt|;
name|dealloc_ring
index|[
name|MASK_PEND_IDX
argument_list|(
name|dealloc_prod
operator|++
argument_list|)
index|]
operator|=
name|pending_idx
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|dealloc_lock
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|net_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_tx_response
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|,
name|uint16_t
name|id
parameter_list|,
name|int8_t
name|st
parameter_list|)
block|{
name|RING_IDX
name|i
init|=
name|netif
operator|->
name|tx
operator|.
name|rsp_prod_pvt
decl_stmt|;
name|netif_tx_response_t
modifier|*
name|resp
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|resp
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|resp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|status
operator|=
name|st
expr_stmt|;
name|netif
operator|->
name|tx
operator|.
name|rsp_prod_pvt
operator|=
operator|++
name|i
expr_stmt|;
name|RING_PUSH_RESPONSES_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|,
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|notify_remote_via_irq
argument_list|(
name|netif
operator|->
name|irq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_XEN_NETDEV_PIPELINED_TRANSMITTER
if|if
condition|(
name|i
operator|==
name|netif
operator|->
name|tx
operator|.
name|req_cons
condition|)
block|{
name|int
name|more_to_do
decl_stmt|;
name|RING_FINAL_CHECK_FOR_REQUESTS
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|,
name|more_to_do
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_to_do
condition|)
name|add_to_tx_schedule_list_tail
argument_list|(
name|netif
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|inline
specifier|static
name|void
name|net_tx_action_dealloc
parameter_list|(
name|void
parameter_list|)
block|{
name|gnttab_unmap_grant_ref_t
modifier|*
name|gop
decl_stmt|;
name|uint16_t
name|pending_idx
decl_stmt|;
name|PEND_RING_IDX
name|dc
decl_stmt|,
name|dp
decl_stmt|;
name|netif_t
modifier|*
name|netif
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dc
operator|=
name|dealloc_cons
expr_stmt|;
name|dp
operator|=
name|dealloc_prod
expr_stmt|;
comment|/* 	 * Free up any grants we have finished using 	 */
name|gop
operator|=
name|tx_unmap_ops
expr_stmt|;
while|while
condition|(
name|dc
operator|!=
name|dp
condition|)
block|{
name|pending_idx
operator|=
name|dealloc_ring
index|[
name|MASK_PEND_IDX
argument_list|(
name|dc
operator|++
argument_list|)
index|]
expr_stmt|;
name|gop
operator|->
name|host_addr
operator|=
name|MMAP_VADDR
argument_list|(
name|pending_idx
argument_list|)
expr_stmt|;
name|gop
operator|->
name|dev_bus_addr
operator|=
literal|0
expr_stmt|;
name|gop
operator|->
name|handle
operator|=
name|grant_tx_handle
index|[
name|pending_idx
index|]
expr_stmt|;
name|gop
operator|++
expr_stmt|;
block|}
name|ret
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_unmap_grant_ref
argument_list|,
name|tx_unmap_ops
argument_list|,
name|gop
operator|-
name|tx_unmap_ops
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|ret
argument_list|)
expr_stmt|;
while|while
condition|(
name|dealloc_cons
operator|!=
name|dp
condition|)
block|{
name|pending_idx
operator|=
name|dealloc_ring
index|[
name|MASK_PEND_IDX
argument_list|(
name|dealloc_cons
operator|++
argument_list|)
index|]
expr_stmt|;
name|netif
operator|=
name|pending_tx_info
index|[
name|pending_idx
index|]
operator|.
name|netif
expr_stmt|;
name|make_tx_response
argument_list|(
name|netif
argument_list|,
name|pending_tx_info
index|[
name|pending_idx
index|]
operator|.
name|req
operator|.
name|id
argument_list|,
name|NETIF_RSP_OKAY
argument_list|)
expr_stmt|;
name|pending_ring
index|[
name|MASK_PEND_IDX
argument_list|(
name|pending_prod
operator|++
argument_list|)
index|]
operator|=
name|pending_idx
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|netif_page_release
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
name|uint16_t
name|pending_idx
init|=
operator|(
name|unsigned
name|int
operator|)
name|args
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"pending_idx=%u\n"
argument_list|,
name|pending_idx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pending_idx
operator|<
name|MAX_PENDING_REQS
argument_list|,
operator|(
literal|"%s: bad index %u"
operator|,
name|__func__
operator|,
name|pending_idx
operator|)
argument_list|)
expr_stmt|;
name|netif_idx_release
argument_list|(
name|pending_idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|net_tx_action
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|netif_t
modifier|*
name|netif
decl_stmt|;
name|netif_tx_request_t
name|txreq
decl_stmt|;
name|uint16_t
name|pending_idx
decl_stmt|;
name|RING_IDX
name|i
decl_stmt|;
name|gnttab_map_grant_ref_t
modifier|*
name|mop
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|work_to_do
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|txq
init|=
name|NULL
decl_stmt|,
modifier|*
name|txq_last
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dealloc_cons
operator|!=
name|dealloc_prod
condition|)
name|net_tx_action_dealloc
argument_list|()
expr_stmt|;
name|mop
operator|=
name|tx_map_ops
expr_stmt|;
while|while
condition|(
operator|(
name|NR_PENDING_REQS
operator|<
name|MAX_PENDING_REQS
operator|)
operator|&&
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|tx_sched_list
argument_list|)
condition|)
block|{
comment|/* Get a netif from the list with work to do. */
name|netif
operator|=
name|remove_from_tx_schedule_list
argument_list|()
expr_stmt|;
name|DDPRINTF
argument_list|(
literal|"Processing %s (prod=%u, cons=%u)\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|,
name|netif
operator|->
name|tx
operator|.
name|sring
operator|->
name|req_prod
argument_list|,
name|netif
operator|->
name|tx
operator|.
name|req_cons
argument_list|)
expr_stmt|;
name|RING_FINAL_CHECK_FOR_REQUESTS
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|,
name|work_to_do
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|work_to_do
condition|)
block|{
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|netif
operator|->
name|tx
operator|.
name|req_cons
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Ensure that we see the request before we copy it. */
name|memcpy
argument_list|(
operator|&
name|txreq
argument_list|,
name|RING_GET_REQUEST
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|,
name|i
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|txreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we want credit-based scheduling, coud add it here - WORK */
name|netif
operator|->
name|tx
operator|.
name|req_cons
operator|++
expr_stmt|;
name|netif_schedule_tx_work
argument_list|(
name|netif
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|txreq
operator|.
name|size
operator|<
name|ETHER_HDR_LEN
argument_list|)
operator|||
name|unlikely
argument_list|(
name|txreq
operator|.
name|size
operator|>
operator|(
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|)
argument_list|)
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"Bad packet size: %d\n"
argument_list|,
name|txreq
operator|.
name|size
argument_list|)
expr_stmt|;
name|make_tx_response
argument_list|(
name|netif
argument_list|,
name|txreq
operator|.
name|id
argument_list|,
name|NETIF_RSP_ERROR
argument_list|)
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* No crossing a page as the payload mustn't fragment. */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|txreq
operator|.
name|offset
operator|+
name|txreq
operator|.
name|size
operator|)
operator|>=
name|PAGE_SIZE
argument_list|)
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"txreq.offset: %x, size: %u, end: %u\n"
argument_list|,
name|txreq
operator|.
name|offset
argument_list|,
name|txreq
operator|.
name|size
argument_list|,
operator|(
name|txreq
operator|.
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|+
name|txreq
operator|.
name|size
argument_list|)
expr_stmt|;
name|make_tx_response
argument_list|(
name|netif
argument_list|,
name|txreq
operator|.
name|id
argument_list|,
name|NETIF_RSP_ERROR
argument_list|)
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pending_idx
operator|=
name|pending_ring
index|[
name|MASK_PEND_IDX
argument_list|(
name|pending_cons
argument_list|)
index|]
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"Failed to allocate mbuf\n"
argument_list|)
expr_stmt|;
name|make_tx_response
argument_list|(
name|netif
argument_list|,
name|txreq
operator|.
name|id
argument_list|,
name|NETIF_RSP_ERROR
argument_list|)
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|netif
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|txreq
operator|.
name|size
operator|)
operator|>
name|PKT_PROT_LEN
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_next
operator|=
name|n
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|WPRINTF
argument_list|(
literal|"Failed to allocate second mbuf\n"
argument_list|)
expr_stmt|;
name|make_tx_response
argument_list|(
name|netif
argument_list|,
name|txreq
operator|.
name|id
argument_list|,
name|NETIF_RSP_ERROR
argument_list|)
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|->
name|m_len
operator|=
name|txreq
operator|.
name|size
operator|-
name|PKT_PROT_LEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|PKT_PROT_LEN
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_len
operator|=
name|txreq
operator|.
name|size
expr_stmt|;
name|mop
operator|->
name|host_addr
operator|=
name|MMAP_VADDR
argument_list|(
name|pending_idx
argument_list|)
expr_stmt|;
name|mop
operator|->
name|dom
operator|=
name|netif
operator|->
name|domid
expr_stmt|;
name|mop
operator|->
name|ref
operator|=
name|txreq
operator|.
name|gref
expr_stmt|;
name|mop
operator|->
name|flags
operator|=
name|GNTMAP_host_map
operator||
name|GNTMAP_readonly
expr_stmt|;
name|mop
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pending_tx_info
index|[
name|pending_idx
index|]
operator|.
name|req
argument_list|,
operator|&
name|txreq
argument_list|,
sizeof|sizeof
argument_list|(
name|txreq
argument_list|)
argument_list|)
expr_stmt|;
name|pending_tx_info
index|[
name|pending_idx
index|]
operator|.
name|netif
operator|=
name|netif
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|m
operator|->
name|m_data
operator|)
operator|=
name|pending_idx
expr_stmt|;
if|if
condition|(
name|txq_last
condition|)
name|txq_last
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
else|else
name|txq
operator|=
name|m
expr_stmt|;
name|txq_last
operator|=
name|m
expr_stmt|;
name|pending_cons
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|mop
operator|-
name|tx_map_ops
operator|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|tx_map_ops
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|txq
condition|)
return|return;
name|ret
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_map_grant_ref
argument_list|,
name|tx_map_ops
argument_list|,
name|mop
operator|-
name|tx_map_ops
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|mop
operator|=
name|tx_map_ops
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|txq
operator|)
operator|!=
name|NULL
condition|)
block|{
name|caddr_t
name|data
decl_stmt|;
name|txq
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|pending_idx
operator|=
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|m
operator|->
name|m_data
operator|)
expr_stmt|;
name|netif
operator|=
name|pending_tx_info
index|[
name|pending_idx
index|]
operator|.
name|netif
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|txreq
argument_list|,
operator|&
name|pending_tx_info
index|[
name|pending_idx
index|]
operator|.
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|txreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check the remap error code. */
if|if
condition|(
name|unlikely
argument_list|(
name|mop
operator|->
name|status
argument_list|)
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"#### netback grant fails\n"
argument_list|)
expr_stmt|;
name|make_tx_response
argument_list|(
name|netif
argument_list|,
name|txreq
operator|.
name|id
argument_list|,
name|NETIF_RSP_ERROR
argument_list|)
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mop
operator|++
expr_stmt|;
name|pending_ring
index|[
name|MASK_PEND_IDX
argument_list|(
name|pending_prod
operator|++
argument_list|)
index|]
operator|=
name|pending_idx
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
comment|/* Can't do this in FreeBSD since vtophys() returns the pfn */
comment|/* of the remote domain who loaned us the machine page - DPT */
block|xen_phys_machine[(vtophys(MMAP_VADDR(pending_idx))>> PAGE_SHIFT)] = 			mop->dev_bus_addr>> PAGE_SHIFT;
endif|#
directive|endif
name|grant_tx_handle
index|[
name|pending_idx
index|]
operator|=
name|mop
operator|->
name|handle
expr_stmt|;
comment|/* Setup data in mbuf (lengths are already set) */
name|data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|MMAP_VADDR
argument_list|(
name|pending_idx
argument_list|)
operator||
name|txreq
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m
operator|->
name|m_next
decl_stmt|;
name|MEXTADD
argument_list|(
name|n
argument_list|,
name|MMAP_VADDR
argument_list|(
name|pending_idx
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|netif_page_release
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|int
operator|)
name|pending_idx
argument_list|,
name|M_RDONLY
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_data
operator|=
operator|&
name|data
index|[
name|PKT_PROT_LEN
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Schedule a response immediately. */
name|netif_idx_release
argument_list|(
name|pending_idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|txreq
operator|.
name|flags
operator|&
name|NETTXF_data_validated
operator|)
condition|)
block|{
comment|/* Tell the stack the checksums are okay */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/* If necessary, inform stack to compute the checksums if it forwards the packet */
if|if
condition|(
operator|(
name|txreq
operator|.
name|flags
operator|&
name|NETTXF_csum_blank
operator|)
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_IP
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|&
name|m
operator|->
name|m_data
index|[
literal|14
index|]
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_UDP
expr_stmt|;
block|}
block|}
name|netif
operator|->
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|netif
operator|->
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|DDPRINTF
argument_list|(
literal|"RECV %d bytes from %s (cflags=%x)\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|)
expr_stmt|;
name|DPRINTF_MBUF_LEN
argument_list|(
name|m
argument_list|,
literal|128
argument_list|)
expr_stmt|;
call|(
modifier|*
name|netif
operator|->
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|netif
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mop
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle interrupt from a frontend */
end_comment

begin_function
specifier|static
name|void
name|netback_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
init|=
name|arg
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_tx_schedule_list_tail
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|maybe_schedule_tx_action
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes netif from front of list and does not call netif_put() (caller must) */
end_comment

begin_function
specifier|static
name|netif_t
modifier|*
name|remove_from_rx_schedule_list
parameter_list|(
name|void
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rx_sched_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|netif
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|rx_sched_list
argument_list|)
operator|)
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|rx_sched_list
argument_list|,
name|netif
argument_list|,
name|netback_info
argument_list|,
name|next_rx
argument_list|)
expr_stmt|;
name|STAILQ_NEXT
argument_list|(
name|netif
argument_list|,
name|next_rx
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|netif
operator|->
name|on_rx_sched_list
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rx_sched_list_lock
argument_list|)
expr_stmt|;
return|return
name|netif
return|;
block|}
end_function

begin_comment
comment|/* Adds netif to end of list and calls netif_get() */
end_comment

begin_function
specifier|static
name|void
name|add_to_rx_schedule_list_tail
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
if|if
condition|(
name|netif
operator|->
name|on_rx_sched_list
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|rx_sched_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netif
operator|->
name|on_rx_sched_list
operator|&&
operator|(
name|netif
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|netif_get
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rx_sched_list
argument_list|,
name|netif
argument_list|,
name|next_rx
argument_list|)
expr_stmt|;
name|netif
operator|->
name|on_rx_sched_list
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rx_sched_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|make_rx_response
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|,
name|uint16_t
name|id
parameter_list|,
name|int8_t
name|st
parameter_list|,
name|uint16_t
name|offset
parameter_list|,
name|uint16_t
name|size
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|RING_IDX
name|i
init|=
name|netif
operator|->
name|rx
operator|.
name|rsp_prod_pvt
decl_stmt|;
name|netif_rx_response_t
modifier|*
name|resp
decl_stmt|;
name|int
name|notify
decl_stmt|;
name|resp
operator|=
name|RING_GET_RESPONSE
argument_list|(
operator|&
name|netif
operator|->
name|rx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|resp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|resp
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|resp
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|status
operator|=
operator|(
name|int16_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|st
operator|<
literal|0
condition|)
name|resp
operator|->
name|status
operator|=
operator|(
name|int16_t
operator|)
name|st
expr_stmt|;
name|DDPRINTF
argument_list|(
literal|"rx resp(%d): off=%x fl=%x id=%x stat=%d\n"
argument_list|,
name|i
argument_list|,
name|resp
operator|->
name|offset
argument_list|,
name|resp
operator|->
name|flags
argument_list|,
name|resp
operator|->
name|id
argument_list|,
name|resp
operator|->
name|status
argument_list|)
expr_stmt|;
name|netif
operator|->
name|rx
operator|.
name|rsp_prod_pvt
operator|=
operator|++
name|i
expr_stmt|;
name|RING_PUSH_RESPONSES_AND_CHECK_NOTIFY
argument_list|(
operator|&
name|netif
operator|->
name|rx
argument_list|,
name|notify
argument_list|)
expr_stmt|;
return|return
name|notify
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netif_rx
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|netif
operator|->
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|multicall_entry_t
modifier|*
name|mcl
decl_stmt|;
name|mmu_update_t
modifier|*
name|mmu
decl_stmt|;
name|gnttab_transfer_t
modifier|*
name|gop
decl_stmt|;
name|unsigned
name|long
name|vdata
decl_stmt|,
name|old_mfn
decl_stmt|,
name|new_mfn
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|rxq
init|=
name|NULL
decl_stmt|,
modifier|*
name|rxq_last
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|notify
init|=
literal|0
decl_stmt|,
name|pkts_dequeued
init|=
literal|0
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|mcl
operator|=
name|rx_mcl
expr_stmt|;
name|mmu
operator|=
name|rx_mmu
expr_stmt|;
name|gop
operator|=
name|grant_rx_op
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
comment|/* Quit if the target domain has no receive buffers */
if|if
condition|(
name|netif
operator|->
name|rx
operator|.
name|req_cons
operator|==
name|netif
operator|->
name|rx
operator|.
name|sring
operator|->
name|req_prod
condition|)
break|break;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|pkts_dequeued
operator|++
expr_stmt|;
comment|/* Check if we need to copy the data */
if|if
condition|(
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_RDONLY
operator||
name|M_EXT
operator|)
operator|)
operator|!=
name|M_EXT
operator|)
operator|||
operator|(
operator|*
name|m
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|>
literal|1
operator|)
operator|||
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"copying mbuf (fl=%x ext=%x rc=%d n=%x)\n"
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|?
name|m
operator|->
name|m_ext
operator|.
name|ext_type
else|:
literal|0
argument_list|,
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|?
operator|*
name|m
operator|->
name|m_ext
operator|.
name|ref_cnt
else|:
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
comment|/* Make copy */
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
goto|goto
name|drop
goto|;
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* Leave space at front and keep current alignment */
name|n
operator|->
name|m_data
operator|+=
literal|16
operator|+
operator|(
operator|(
name|unsigned
name|int
operator|)
name|m
operator|->
name|m_data
operator|&
literal|0x3
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"pkt to big %d\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|n
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
operator|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
name|vdata
operator|=
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|m_data
expr_stmt|;
name|old_mfn
operator|=
name|vtomach
argument_list|(
name|vdata
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|new_mfn
operator|=
name|alloc_mfn
argument_list|()
operator|)
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
ifdef|#
directive|ifdef
name|XEN_NETBACK_FIXUP_CSUM
comment|/* Check if we need to compute a checksum.  This happens */
comment|/* when bridging from one domain to another. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
operator|)
condition|)
name|fixup_checksum
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xen_phys_machine
index|[
operator|(
name|vtophys
argument_list|(
name|vdata
argument_list|)
operator|>>
name|PAGE_SHIFT
operator|)
index|]
operator|=
name|new_mfn
expr_stmt|;
name|mcl
operator|->
name|op
operator|=
name|__HYPERVISOR_update_va_mapping
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|0
index|]
operator|=
name|vdata
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|1
index|]
operator|=
operator|(
name|new_mfn
operator|<<
name|PAGE_SHIFT
operator|)
operator||
name|PG_V
operator||
name|PG_RW
operator||
name|PG_M
operator||
name|PG_A
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|mcl
operator|++
expr_stmt|;
name|gop
operator|->
name|mfn
operator|=
name|old_mfn
expr_stmt|;
name|gop
operator|->
name|domid
operator|=
name|netif
operator|->
name|domid
expr_stmt|;
name|gop
operator|->
name|ref
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|netif
operator|->
name|rx
argument_list|,
name|netif
operator|->
name|rx
operator|.
name|req_cons
argument_list|)
operator|->
name|gref
expr_stmt|;
name|netif
operator|->
name|rx
operator|.
name|req_cons
operator|++
expr_stmt|;
name|gop
operator|++
expr_stmt|;
name|mmu
operator|->
name|ptr
operator|=
operator|(
name|new_mfn
operator|<<
name|PAGE_SHIFT
operator|)
operator||
name|MMU_MACHPHYS_UPDATE
expr_stmt|;
name|mmu
operator|->
name|val
operator|=
name|vtophys
argument_list|(
name|vdata
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|mmu
operator|++
expr_stmt|;
if|if
condition|(
name|rxq_last
condition|)
name|rxq_last
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
else|else
name|rxq
operator|=
name|m
expr_stmt|;
name|rxq_last
operator|=
name|m
expr_stmt|;
name|DDPRINTF
argument_list|(
literal|"XMIT %d bytes to %s\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF_MBUF_LEN
argument_list|(
name|m
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* Filled the batch queue? */
if|if
condition|(
operator|(
name|gop
operator|-
name|grant_rx_op
operator|)
operator|==
name|ARRAY_SIZE
argument_list|(
name|grant_rx_op
argument_list|)
condition|)
break|break;
continue|continue;
name|drop
label|:
name|DDPRINTF
argument_list|(
literal|"dropping pkt\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcl
operator|==
name|rx_mcl
condition|)
return|return
name|pkts_dequeued
return|;
name|mcl
operator|->
name|op
operator|=
name|__HYPERVISOR_mmu_update
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rx_mmu
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|1
index|]
operator|=
name|mmu
operator|-
name|rx_mmu
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mcl
operator|->
name|args
index|[
literal|3
index|]
operator|=
name|DOMID_SELF
expr_stmt|;
name|mcl
operator|++
expr_stmt|;
name|mcl
index|[
operator|-
literal|2
index|]
operator|.
name|args
index|[
name|MULTI_UVMFLAGS_INDEX
index|]
operator|=
name|UVMF_TLB_FLUSH
operator||
name|UVMF_ALL
expr_stmt|;
name|ret
operator|=
name|HYPERVISOR_multicall
argument_list|(
name|rx_mcl
argument_list|,
name|mcl
operator|-
name|rx_mcl
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_transfer
argument_list|,
name|grant_rx_op
argument_list|,
name|gop
operator|-
name|grant_rx_op
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|mcl
operator|=
name|rx_mcl
expr_stmt|;
name|gop
operator|=
name|grant_rx_op
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|rxq
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int8_t
name|status
decl_stmt|;
name|uint16_t
name|id
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|rxq
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
comment|/* Rederive the machine addresses. */
name|new_mfn
operator|=
name|mcl
operator|->
name|args
index|[
literal|1
index|]
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|old_mfn
operator|=
name|gop
operator|->
name|mfn
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
comment|/* The update_va_mapping() must not fail. */
name|BUG_ON
argument_list|(
name|mcl
operator|->
name|result
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup flags */
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
operator|)
condition|)
name|flags
operator||=
name|NETRXF_csum_blank
operator||
name|NETRXF_data_validated
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DATA_VALID
operator|)
condition|)
name|flags
operator||=
name|NETRXF_data_validated
expr_stmt|;
comment|/* Check the reassignment error code. */
name|status
operator|=
name|NETIF_RSP_OKAY
expr_stmt|;
if|if
condition|(
name|gop
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Bad status %d from grant transfer to DOM%u\n"
argument_list|,
name|gop
operator|->
name|status
argument_list|,
name|netif
operator|->
name|domid
argument_list|)
expr_stmt|;
comment|/* 			 * Page no longer belongs to us unless GNTST_bad_page, 			 * but that should be a fatal error anyway. 			 */
name|BUG_ON
argument_list|(
name|gop
operator|->
name|status
operator|==
name|GNTST_bad_page
argument_list|)
expr_stmt|;
name|status
operator|=
name|NETIF_RSP_ERROR
expr_stmt|;
block|}
name|id
operator|=
name|RING_GET_REQUEST
argument_list|(
operator|&
name|netif
operator|->
name|rx
argument_list|,
name|netif
operator|->
name|rx
operator|.
name|rsp_prod_pvt
argument_list|)
operator|->
name|id
expr_stmt|;
name|notify
operator||=
name|make_rx_response
argument_list|(
name|netif
argument_list|,
name|id
argument_list|,
name|status
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|m_data
operator|&
name|PAGE_MASK
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mcl
operator|++
expr_stmt|;
name|gop
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|notify
condition|)
name|notify_remote_via_irq
argument_list|(
name|netif
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
name|pkts_dequeued
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rx_task_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|DDPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|net_rx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|net_rx_action
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
decl_stmt|,
modifier|*
name|last_zero_work
init|=
name|NULL
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|netif
operator|=
name|remove_from_rx_schedule_list
argument_list|()
operator|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|netif
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|netif
operator|==
name|last_zero_work
condition|)
block|{
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|add_to_rx_schedule_list_tail
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|rx_sched_list
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|rx_task_callout
argument_list|,
literal|1
argument_list|,
name|rx_task_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
name|netif_rx
argument_list|(
name|netif
argument_list|)
condition|)
name|last_zero_work
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|last_zero_work
condition|)
name|last_zero_work
operator|=
name|netif
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|add_to_rx_schedule_list_tail
argument_list|(
name|netif
argument_list|)
expr_stmt|;
block|}
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|netback_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
init|=
operator|(
name|netif_t
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_rx_schedule_list_tail
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|net_rx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map a grant ref to a ring */
end_comment

begin_function
specifier|static
name|int
name|map_ring
parameter_list|(
name|grant_ref_t
name|ref
parameter_list|,
name|domid_t
name|dom
parameter_list|,
name|struct
name|ring_ref
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|gnttab_map_grant_ref
name|op
decl_stmt|;
name|ring
operator|->
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|va
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|op
operator|.
name|host_addr
operator|=
name|ring
operator|->
name|va
expr_stmt|;
name|op
operator|.
name|flags
operator|=
name|GNTMAP_host_map
expr_stmt|;
name|op
operator|.
name|ref
operator|=
name|ref
expr_stmt|;
name|op
operator|.
name|dom
operator|=
name|dom
expr_stmt|;
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_map_grant_ref
argument_list|,
operator|&
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|status
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"grant table op err=%d\n"
argument_list|,
name|op
operator|.
name|status
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|ring
operator|->
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ring
operator|->
name|va
operator|=
literal|0
expr_stmt|;
return|return
name|EACCES
return|;
block|}
name|ring
operator|->
name|handle
operator|=
name|op
operator|.
name|handle
expr_stmt|;
name|ring
operator|->
name|bus_addr
operator|=
name|op
operator|.
name|dev_bus_addr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unmap grant ref for a ring */
end_comment

begin_function
specifier|static
name|void
name|unmap_ring
parameter_list|(
name|struct
name|ring_ref
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|gnttab_unmap_grant_ref
name|op
decl_stmt|;
name|op
operator|.
name|host_addr
operator|=
name|ring
operator|->
name|va
expr_stmt|;
name|op
operator|.
name|dev_bus_addr
operator|=
name|ring
operator|->
name|bus_addr
expr_stmt|;
name|op
operator|.
name|handle
operator|=
name|ring
operator|->
name|handle
expr_stmt|;
name|HYPERVISOR_grant_table_op
argument_list|(
name|GNTTABOP_unmap_grant_ref
argument_list|,
operator|&
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|status
condition|)
name|WPRINTF
argument_list|(
literal|"grant table op err=%d\n"
argument_list|,
name|op
operator|.
name|status
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|ring
operator|->
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ring
operator|->
name|va
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|connect_rings
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
name|struct
name|xenbus_device
modifier|*
name|xdev
init|=
name|netif
operator|->
name|xdev
decl_stmt|;
name|netif_tx_sring_t
modifier|*
name|txs
decl_stmt|;
name|netif_rx_sring_t
modifier|*
name|rxs
decl_stmt|;
name|unsigned
name|long
name|tx_ring_ref
decl_stmt|,
name|rx_ring_ref
decl_stmt|;
name|evtchn_port_t
name|evtchn
decl_stmt|;
name|evtchn_op_t
name|op
init|=
block|{
operator|.
name|cmd
operator|=
name|EVTCHNOP_bind_interdomain
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|// Grab FE data and map his memory
name|err
operator|=
name|xenbus_gather
argument_list|(
name|NULL
argument_list|,
name|xdev
operator|->
name|otherend
argument_list|,
literal|"tx-ring-ref"
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|tx_ring_ref
argument_list|,
literal|"rx-ring-ref"
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|rx_ring_ref
argument_list|,
literal|"event-channel"
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|evtchn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"reading %s/ring-ref and event-channel"
argument_list|,
name|xdev
operator|->
name|otherend
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|map_ring
argument_list|(
name|tx_ring_ref
argument_list|,
name|netif
operator|->
name|domid
argument_list|,
operator|&
name|netif
operator|->
name|tx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"mapping tx ring"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|txs
operator|=
operator|(
name|netif_tx_sring_t
operator|*
operator|)
name|netif
operator|->
name|tx_ring_ref
operator|.
name|va
expr_stmt|;
name|BACK_RING_INIT
argument_list|(
operator|&
name|netif
operator|->
name|tx
argument_list|,
name|txs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|err
operator|=
name|map_ring
argument_list|(
name|rx_ring_ref
argument_list|,
name|netif
operator|->
name|domid
argument_list|,
operator|&
name|netif
operator|->
name|rx_ring_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|unmap_ring
argument_list|(
operator|&
name|netif
operator|->
name|tx_ring_ref
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"mapping rx ring"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|rxs
operator|=
operator|(
name|netif_rx_sring_t
operator|*
operator|)
name|netif
operator|->
name|rx_ring_ref
operator|.
name|va
expr_stmt|;
name|BACK_RING_INIT
argument_list|(
operator|&
name|netif
operator|->
name|rx
argument_list|,
name|rxs
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|op
operator|.
name|u
operator|.
name|bind_interdomain
operator|.
name|remote_dom
operator|=
name|netif
operator|->
name|domid
expr_stmt|;
name|op
operator|.
name|u
operator|.
name|bind_interdomain
operator|.
name|remote_port
operator|=
name|evtchn
expr_stmt|;
name|err
operator|=
name|HYPERVISOR_event_channel_op
argument_list|(
operator|&
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|unmap_ring
argument_list|(
operator|&
name|netif
operator|->
name|tx_ring_ref
argument_list|)
expr_stmt|;
name|unmap_ring
argument_list|(
operator|&
name|netif
operator|->
name|rx_ring_ref
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"binding event channel"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|netif
operator|->
name|evtchn
operator|=
name|op
operator|.
name|u
operator|.
name|bind_interdomain
operator|.
name|local_port
expr_stmt|;
comment|/* bind evtchn to irq handler */
name|netif
operator|->
name|irq
operator|=
name|bind_evtchn_to_irqhandler
argument_list|(
name|netif
operator|->
name|evtchn
argument_list|,
literal|"netback"
argument_list|,
name|netback_intr
argument_list|,
name|netif
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
operator|&
name|netif
operator|->
name|irq_cookie
argument_list|)
expr_stmt|;
name|netif
operator|->
name|rings_connected
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s connected! evtchn=%d irq=%d\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|,
name|netif
operator|->
name|evtchn
argument_list|,
name|netif
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|disconnect_rings
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|netif
operator|->
name|rings_connected
condition|)
block|{
name|unbind_from_irqhandler
argument_list|(
name|netif
operator|->
name|irq
argument_list|,
name|netif
operator|->
name|irq_cookie
argument_list|)
expr_stmt|;
name|netif
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
name|unmap_ring
argument_list|(
operator|&
name|netif
operator|->
name|tx_ring_ref
argument_list|)
expr_stmt|;
name|unmap_ring
argument_list|(
operator|&
name|netif
operator|->
name|rx_ring_ref
argument_list|)
expr_stmt|;
name|netif
operator|->
name|rings_connected
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|connect
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|)
block|{
if|if
condition|(
operator|!
name|netif
operator|->
name|xdev
operator|||
operator|!
name|netif
operator|->
name|attached
operator|||
name|netif
operator|->
name|frontend_state
operator|!=
name|XenbusStateConnected
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|connect_rings
argument_list|(
name|netif
argument_list|)
condition|)
block|{
name|xenbus_switch_state
argument_list|(
name|netif
operator|->
name|xdev
argument_list|,
name|NULL
argument_list|,
name|XenbusStateConnected
argument_list|)
expr_stmt|;
comment|/* Turn on interface */
name|netif
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|netif
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|netback_remove
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
init|=
name|xdev
operator|->
name|data
decl_stmt|;
name|device_t
name|ndev
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"remove %s\n"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ndev
operator|=
name|netif
operator|->
name|ndev
operator|)
condition|)
block|{
name|netif
operator|->
name|ndev
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_detach
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
name|xdev
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|netif
operator|->
name|xdev
operator|=
name|NULL
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Entry point to this code when a new device is created.  Allocate the basic  * structures and the ring buffers for communication with the frontend.  * Switch to Connected state.  */
end_comment

begin_function
specifier|static
name|int
name|netback_probe
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|,
specifier|const
name|struct
name|xenbus_device_id
modifier|*
name|id
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|long
name|handle
decl_stmt|;
name|char
modifier|*
name|bridge
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"node=%s\n"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
comment|/* Grab the handle */
name|err
operator|=
name|xenbus_scanf
argument_list|(
name|NULL
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"handle"
argument_list|,
literal|"%li"
argument_list|,
operator|&
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|1
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"reading handle"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Check for bridge */
name|bridge
operator|=
name|xenbus_read
argument_list|(
name|NULL
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|,
literal|"bridge"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|bridge
argument_list|)
condition|)
name|bridge
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|xenbus_switch_state
argument_list|(
name|xdev
argument_list|,
name|NULL
argument_list|,
name|XenbusStateInitWait
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"writing switch state"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|netif_create
argument_list|(
name|handle
argument_list|,
name|xdev
argument_list|,
name|bridge
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"creating netif"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|vif_add_dev
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|netif_put
argument_list|(
operator|(
name|netif_t
operator|*
operator|)
name|xdev
operator|->
name|data
argument_list|)
expr_stmt|;
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|err
argument_list|,
literal|"adding vif device"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * We are reconnecting to the backend, due to a suspend/resume, or a backend  * driver restart.  We tear down our netif structure and recreate it, but  * leave the device-layer structures intact so that this is transparent to the  * rest of the kernel.  */
end_comment

begin_function
specifier|static
name|int
name|netback_resume
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"node=%s\n"
argument_list|,
name|xdev
operator|->
name|nodename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Callback received when the frontend's state changes.  */
end_comment

begin_function
specifier|static
name|void
name|frontend_changed
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|,
name|XenbusState
name|frontend_state
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
init|=
name|xdev
operator|->
name|data
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"state=%d\n"
argument_list|,
name|frontend_state
argument_list|)
expr_stmt|;
name|netif
operator|->
name|frontend_state
operator|=
name|frontend_state
expr_stmt|;
switch|switch
condition|(
name|frontend_state
condition|)
block|{
case|case
name|XenbusStateInitialising
case|:
case|case
name|XenbusStateInitialised
case|:
break|break;
case|case
name|XenbusStateConnected
case|:
name|connect
argument_list|(
name|netif
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosing
case|:
name|xenbus_switch_state
argument_list|(
name|xdev
argument_list|,
name|NULL
argument_list|,
name|XenbusStateClosing
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateClosed
case|:
name|xenbus_remove_device
argument_list|(
name|xdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|XenbusStateUnknown
case|:
case|case
name|XenbusStateInitWait
case|:
name|xenbus_dev_fatal
argument_list|(
name|xdev
argument_list|,
name|EINVAL
argument_list|,
literal|"saw state %d at frontend"
argument_list|,
name|frontend_state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ** Driver registration ** */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|xenbus_device_id
name|netback_ids
index|[]
init|=
block|{
block|{
literal|"vif"
block|}
block|,
block|{
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|xenbus_driver
name|netback
init|=
block|{
operator|.
name|name
operator|=
literal|"netback"
block|,
operator|.
name|ids
operator|=
name|netback_ids
block|,
operator|.
name|probe
operator|=
name|netback_probe
block|,
operator|.
name|remove
operator|=
name|netback_remove
block|,
operator|.
name|resume
operator|=
name|netback_resume
block|,
operator|.
name|otherend_changed
operator|=
name|frontend_changed
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|netback_init
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|callout_init
argument_list|(
operator|&
name|rx_task_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|mmap_vstart
operator|=
name|alloc_empty_page_range
argument_list|(
name|MAX_PENDING_REQS
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|mmap_vstart
argument_list|)
expr_stmt|;
name|pending_cons
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pending_prod
operator|=
literal|0
init|;
name|pending_prod
operator|<
name|MAX_PENDING_REQS
condition|;
name|pending_prod
operator|++
control|)
name|pending_ring
index|[
name|pending_prod
index|]
operator|=
name|pending_prod
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|net_tx_task
argument_list|,
literal|0
argument_list|,
name|net_tx_action
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|net_rx_task
argument_list|,
literal|0
argument_list|,
name|net_rx_action
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|tx_sched_list_lock
argument_list|,
literal|"nb_tx_sched_lock"
argument_list|,
literal|"netback tx sched lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rx_sched_list_lock
argument_list|,
literal|"nb_rx_sched_lock"
argument_list|,
literal|"netback rx sched lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"registering %s\n"
argument_list|,
name|netback
operator|.
name|name
argument_list|)
expr_stmt|;
name|xenbus_register_backend
argument_list|(
operator|&
name|netback
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|xnbedev
argument_list|,
argument|SI_SUB_PSEUDO
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|netback_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|vif_add_dev
parameter_list|(
name|struct
name|xenbus_device
modifier|*
name|xdev
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
init|=
name|xdev
operator|->
name|data
decl_stmt|;
name|device_t
name|nexus
decl_stmt|,
name|ndev
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* We will add a vif device as a child of nexus0 (for now) */
if|if
condition|(
operator|!
operator|(
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"nexus"
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|nexus
operator|=
name|devclass_get_device
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"could not find nexus0!\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Create a newbus device representing the vif */
name|ndev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|nexus
argument_list|,
literal|0
argument_list|,
literal|"vif"
argument_list|,
name|netif
operator|->
name|ifp
operator|->
name|if_dunit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndev
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"could not create newbus device %s!\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|netif_get
argument_list|(
name|netif
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|ndev
argument_list|,
name|netif
argument_list|)
expr_stmt|;
name|netif
operator|->
name|ndev
operator|=
name|ndev
expr_stmt|;
name|device_probe_and_attach
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|VIF_SYSCTL_DOMID
block|,
name|VIF_SYSCTL_HANDLE
block|,
name|VIF_SYSCTL_TXRING
block|,
name|VIF_SYSCTL_RXRING
block|, }
enum|;
end_enum

begin_function
specifier|static
name|char
modifier|*
name|vif_sysctl_ring_info
parameter_list|(
name|netif_t
modifier|*
name|netif
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|malloc
argument_list|(
literal|256
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
if|if
condition|(
operator|!
name|netif
operator|->
name|rings_connected
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"rings not connected\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|VIF_SYSCTL_TXRING
condition|)
block|{
name|netif_tx_back_ring_t
modifier|*
name|tx
init|=
operator|&
name|netif
operator|->
name|tx
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"nr_ents=%x req_cons=%x"
literal|" req_prod=%x req_event=%x"
literal|" rsp_prod=%x rsp_event=%x"
argument_list|,
name|tx
operator|->
name|nr_ents
argument_list|,
name|tx
operator|->
name|req_cons
argument_list|,
name|tx
operator|->
name|sring
operator|->
name|req_prod
argument_list|,
name|tx
operator|->
name|sring
operator|->
name|req_event
argument_list|,
name|tx
operator|->
name|sring
operator|->
name|rsp_prod
argument_list|,
name|tx
operator|->
name|sring
operator|->
name|rsp_event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|netif_rx_back_ring_t
modifier|*
name|rx
init|=
operator|&
name|netif
operator|->
name|rx
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"nr_ents=%x req_cons=%x"
literal|" req_prod=%x req_event=%x"
literal|" rsp_prod=%x rsp_event=%x"
argument_list|,
name|rx
operator|->
name|nr_ents
argument_list|,
name|rx
operator|->
name|req_cons
argument_list|,
name|rx
operator|->
name|sring
operator|->
name|req_prod
argument_list|,
name|rx
operator|->
name|sring
operator|->
name|req_event
argument_list|,
name|rx
operator|->
name|sring
operator|->
name|rsp_prod
argument_list|,
name|rx
operator|->
name|sring
operator|->
name|rsp_event
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vif_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg1
decl_stmt|;
name|netif_t
modifier|*
name|netif
init|=
operator|(
name|netif_t
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|arg2
condition|)
block|{
case|case
name|VIF_SYSCTL_DOMID
case|:
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|netif
operator|->
name|domid
argument_list|,
name|req
argument_list|)
return|;
case|case
name|VIF_SYSCTL_HANDLE
case|:
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|netif
operator|->
name|handle
argument_list|,
name|req
argument_list|)
return|;
case|case
name|VIF_SYSCTL_TXRING
case|:
case|case
name|VIF_SYSCTL_RXRING
case|:
name|value
operator|=
name|buf
operator|=
name|vif_sysctl_ring_info
argument_list|(
name|netif
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Newbus vif device driver probe */
end_comment

begin_function
specifier|static
name|int
name|vif_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|DDPRINTF
argument_list|(
literal|"vif%d\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Newbus vif device driver attach */
end_comment

begin_function
specifier|static
name|int
name|vif_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
init|=
operator|(
name|netif_t
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|mac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"domid"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VIF_SYSCTL_DOMID
argument_list|,
name|vif_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"domid of frontend"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"handle"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VIF_SYSCTL_HANDLE
argument_list|,
name|vif_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"handle of frontend"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XEN_NETBACK_DEBUG
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txring"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VIF_SYSCTL_TXRING
argument_list|,
name|vif_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"tx ring info"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxring"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|VIF_SYSCTL_RXRING
argument_list|,
name|vif_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"rx ring info"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|mac
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|mac
argument_list|)
argument_list|)
expr_stmt|;
name|mac
index|[
literal|0
index|]
operator|&=
operator|~
literal|0x01
expr_stmt|;
name|ether_ifattach
argument_list|(
name|netif
operator|->
name|ifp
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|netif
operator|->
name|attached
operator|=
literal|1
expr_stmt|;
name|connect
argument_list|(
name|netif
argument_list|)
expr_stmt|;
if|if
condition|(
name|netif
operator|->
name|bridge
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Adding %s to bridge %s\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|,
name|netif
operator|->
name|bridge
argument_list|)
expr_stmt|;
name|int
name|err
init|=
name|add_to_bridge
argument_list|(
name|netif
operator|->
name|ifp
argument_list|,
name|netif
operator|->
name|bridge
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|WPRINTF
argument_list|(
literal|"Error adding %s to %s; err=%d\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|,
name|netif
operator|->
name|bridge
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Newbus vif device driver detach */
end_comment

begin_function
specifier|static
name|int
name|vif_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|netif_t
modifier|*
name|netif
init|=
operator|(
name|netif_t
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|netif
operator|->
name|ifp
decl_stmt|;
name|DDPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|IFNAME
argument_list|(
name|netif
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|netif
operator|->
name|attached
operator|=
literal|0
expr_stmt|;
name|netif_put
argument_list|(
name|netif
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|vif_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|vif_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|vif_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|vif_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|vif_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|vif_driver
init|=
block|{
literal|"vif"
block|,
name|vif_methods
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vif
argument_list|,
name|nexus
argument_list|,
name|vif_driver
argument_list|,
name|vif_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Local variables:  * mode: C  * c-set-style: "BSD"  * c-basic-offset: 4  * tab-width: 4  * indent-tabs-mode: t  * End:  */
end_comment

end_unit

