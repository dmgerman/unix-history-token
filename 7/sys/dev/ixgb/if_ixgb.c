begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************  Copyright (c) 2001-2004, Intel Corporation All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Intel Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ixgb/if_ixgb.h>
end_include

begin_comment
comment|/*********************************************************************  *  Set this to one to display debug statistics  *********************************************************************/
end_comment

begin_decl_stmt
name|int
name|ixgb_display_debug_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Linked list of board private structures for all NICs found  *********************************************************************/
end_comment

begin_decl_stmt
name|struct
name|adapter
modifier|*
name|ixgb_adapter_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixgb_driver_version
index|[]
init|=
literal|"1.0.6"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ixgb_copyright
index|[]
init|=
literal|"Copyright (c) 2001-2004 Intel Corporation."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixgb_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixgb_vendor_info_t
name|ixgb_vendor_info_array
index|[]
init|=
block|{
comment|/* Intel(R) PRO/10000 Network Connection */
block|{
name|INTEL_VENDOR_ID
block|,
name|IXGB_DEVICE_ID_82597EX
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
name|INTEL_VENDOR_ID
block|,
name|IXGB_DEVICE_ID_82597EX_SR
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings for all supported NICs.  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixgb_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/10GbE Network Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixgb_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|IOCTL_CMD_TYPE
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_hardware_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_initialize_transmit_unit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_initialize_receive_unit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_clean_transmit_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_allocate_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_allocate_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_process_receive_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_receive_checksum
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|ixgb_rx_desc
modifier|*
name|rx_desc
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_transmit_checksum_setup
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_print_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_print_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_get_buf
parameter_list|(
name|int
name|i
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_enable_vlans
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_encap
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_sysctl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgb_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|ixgb_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|ixgb_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|ixgb_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixgb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixgb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixgb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixgb_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixgb_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixgb_driver
init|=
block|{
literal|"ixgb"
block|,
name|ixgb_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ixgb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_ixgb
argument_list|,
name|pci
argument_list|,
name|ixgb_driver
argument_list|,
name|ixgb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_ixgb
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_ixgb
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* some defines for controlling descriptor fetches in h/w */
end_comment

begin_define
define|#
directive|define
name|RXDCTL_PTHRESH_DEFAULT
value|128
end_define

begin_comment
comment|/* chip considers prefech below this */
end_comment

begin_define
define|#
directive|define
name|RXDCTL_HTHRESH_DEFAULT
value|16
end_define

begin_comment
comment|/* chip will only prefetch if tail is 					 * pushed this many descriptors from 					 * head */
end_comment

begin_define
define|#
directive|define
name|RXDCTL_WTHRESH_DEFAULT
value|0
end_define

begin_comment
comment|/* chip writes back at this many or RXT0 */
end_comment

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixgb_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixgb_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u_int16_t
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|char
name|adapter_name
index|[
literal|60
index|]
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|IXGB_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixgb_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixgb_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixgb_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|tsize
decl_stmt|,
name|rsize
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: %s\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|ixgb_copyright
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our adapter structure */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb: adapter structure allocation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|adapter
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|adapter
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|IXGB_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgb_adapter_list
operator|!=
name|NULL
condition|)
name|ixgb_adapter_list
operator|->
name|prev
operator|=
name|adapter
expr_stmt|;
name|adapter
operator|->
name|next
operator|=
name|ixgb_adapter_list
expr_stmt|;
name|ixgb_adapter_list
operator|=
name|adapter
expr_stmt|;
comment|/* SYSCTL APIs */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|adapter
argument_list|,
literal|0
argument_list|,
name|ixgb_sysctl_stats
argument_list|,
literal|"I"
argument_list|,
literal|"Statistics"
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
comment|/* Determine hardware revision */
name|ixgb_identify_hardware
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Parameters (to be read from user) */
name|adapter
operator|->
name|num_tx_desc
operator|=
name|IXGB_MAX_TXD
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|IXGB_MAX_RXD
expr_stmt|;
name|adapter
operator|->
name|tx_int_delay
operator|=
name|TIDV
expr_stmt|;
name|adapter
operator|->
name|rx_int_delay
operator|=
name|RDTR
expr_stmt|;
name|adapter
operator|->
name|rx_buffer_len
operator|=
name|IXGB_RXBUFFER_2048
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|high_water
operator|=
name|FCRTH
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|low_water
operator|=
name|FCRTL
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|pause_time
operator|=
name|FCPAUSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|send_xon
operator|=
name|TRUE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|type
operator|=
name|FLOW_CONTROL
expr_stmt|;
comment|/* Set the max frame size assuming standard ethernet sized frames */
name|adapter
operator|->
name|hw
operator|.
name|max_frame_size
operator|=
name|ETHERMTU
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
if|if
condition|(
name|ixgb_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Allocation of PCI resources failed\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
name|tsize
operator|=
name|IXGB_ROUNDUP
argument_list|(
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_tx_desc
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* Allocate Transmit Descriptor ring */
if|if
condition|(
name|ixgb_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|tsize
argument_list|,
operator|&
name|adapter
operator|->
name|txdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to allocate TxDescriptor memory\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|adapter
operator|->
name|tx_desc_base
operator|=
operator|(
expr|struct
name|ixgb_tx_desc
operator|*
operator|)
name|adapter
operator|->
name|txdma
operator|.
name|dma_vaddr
expr_stmt|;
name|rsize
operator|=
name|IXGB_ROUNDUP
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_rx_desc
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* Allocate Receive Descriptor ring */
if|if
condition|(
name|ixgb_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|adapter
operator|->
name|rxdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to allocate rx_desc memory\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|adapter
operator|->
name|rx_desc_base
operator|=
operator|(
expr|struct
name|ixgb_rx_desc
operator|*
operator|)
name|adapter
operator|->
name|rxdma
operator|.
name|dma_vaddr
expr_stmt|;
comment|/* Initialize the hardware */
if|if
condition|(
name|ixgb_hardware_init
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to initialize the hardware\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_hw_init
goto|;
block|}
comment|/* Setup OS specific network interface */
name|ixgb_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|ixgb_clear_hw_cntrs
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|ixgb_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_hw_init
label|:
name|ixgb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|err_rx_desc
label|:
name|ixgb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|err_tx_desc
label|:
name|err_pci
label|:
name|ixgb_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|adapter
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgb_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_detach: begin"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|in_detach
operator|=
literal|1
expr_stmt|;
name|ixgb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
else|#
directive|else
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ixgb_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Free Transmit Descriptor ring */
if|if
condition|(
name|adapter
operator|->
name|tx_desc_base
condition|)
block|{
name|ixgb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tx_desc_base
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free Receive Descriptor ring */
if|if
condition|(
name|adapter
operator|->
name|rx_desc_base
condition|)
block|{
name|ixgb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rx_desc_base
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Remove from the adapter list */
if|if
condition|(
name|ixgb_adapter_list
operator|==
name|adapter
condition|)
name|ixgb_adapter_list
operator|=
name|adapter
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|next
operator|!=
name|NULL
condition|)
name|adapter
operator|->
name|next
operator|->
name|prev
operator|=
name|adapter
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|adapter
operator|->
name|prev
operator|->
name|next
operator|=
name|adapter
operator|->
name|next
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|IXGB_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgb_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Transmit entry point  *  *  ixgb_start is called by the stack to initiate a transmit.  *  The driver will remain in this routine as long as there are  *  packets to transmit and transmit resources are available.  *  In case resources are not available stack is notified and  *  the packet is requeued.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgb_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IXGB_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
while|while
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|ixgb_encap
argument_list|(
name|adapter
argument_list|,
name|m_head
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Send a copy of the frame to the BPF listener */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
else|#
directive|else
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set timeout in case hardware has problems transmitting */
name|ifp
operator|->
name|if_timer
operator|=
name|IXGB_TX_TIMEOUT
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixgb_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|IOCTL_CMD_TYPE
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|in_detach
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCxIFADDR (Get/Set Interface Addr)"
argument_list|)
expr_stmt|;
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXGB_MAX_JUMBO_FRAME_SIZE
operator|-
name|ETHER_HDR_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|ixgb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|ixgb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|ixgb_disable_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixgb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|ixgb_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupt even in error case */
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_HWCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_HWCSUM
expr_stmt|;
else|else
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgb_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|IOCTL_DEBUGOUT1
argument_list|(
literal|"ioctl received: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Watchdog entry point  *  *  This routine is called whenever hardware quits transmitting.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgb_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|adapter
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
comment|/* 	 * If we are in this routine because of pause frames, then don't 	 * reset the hardware. 	 */
if|if
condition|(
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|IXGB_STATUS_TXOFF
condition|)
block|{
name|ifp
operator|->
name|if_timer
operator|=
name|IXGB_TX_TIMEOUT
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ixgb%d: watchdog timeout -- resetting\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ixgb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgb_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_init: begin"
argument_list|)
expr_stmt|;
name|IXGB_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|curr_mac_addr
argument_list|,
name|IXGB_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
comment|/* Initialize the hardware */
if|if
condition|(
name|ixgb_hardware_init
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to initialize the hardware\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixgb_enable_vlans
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
if|if
condition|(
name|ixgb_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Could not setup transmit structures\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ixgb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixgb_initialize_transmit_unit
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|ixgb_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|ixgb_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Could not setup receive structures\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ixgb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixgb_initialize_receive_unit
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Don't lose promiscuous settings */
name|ixgb_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|IXGB_CHECKSUM_FEATURES
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
comment|/* Enable jumbo frames */
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|uint32_t
name|temp_reg
decl_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|MFS
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|max_frame_size
operator|<<
name|IXGB_MFS_SHIFT
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|CTRL0
argument_list|)
expr_stmt|;
name|temp_reg
operator||=
name|IXGB_CTRL0_JFE
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|temp_reg
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ixgb_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_clear_hw_cntrs
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* 	 * Only disable interrupts if we are polling, make sure they are on 	 * otherwise. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ixgb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ixgb_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgb_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|void
name|ixgb_poll_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|reg_icr
decl_stmt|;
name|IXGB_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|reg_icr
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|IXGB_INT_RXSEQ
operator||
name|IXGB_INT_LSC
operator|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixgb_check_for_link
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|ixgb_print_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ixgb_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
name|ixgb_process_receive_interrupts
argument_list|(
name|adapter
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ixgb_clean_transmit_interrupts
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|ixgb_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixgb_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixgb_poll_locked
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/*********************************************************************  *  *  Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgb_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_int32_t
name|loop_cnt
init|=
name|IXGB_MAX_INTR
decl_stmt|;
name|u_int32_t
name|reg_icr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|boolean_t
name|rxdmt0
init|=
name|FALSE
decl_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|reg_icr
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|==
literal|0
condition|)
block|{
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_icr
operator|&
name|IXGB_INT_RXDMT0
condition|)
name|rxdmt0
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|_SV_
if|if
condition|(
name|reg_icr
operator|&
name|IXGB_INT_RXDMT0
condition|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_rxdmt0
operator|++
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|IXGB_INT_RXO
condition|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_rxo
operator|++
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|IXGB_INT_RXT0
condition|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_rxt0
operator|++
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|IXGB_INT_TXDW
condition|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_TXDW
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* _SV_ */
comment|/* Link status change */
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|IXGB_INT_RXSEQ
operator||
name|IXGB_INT_LSC
operator|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixgb_check_for_link
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|ixgb_print_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ixgb_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|loop_cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixgb_process_receive_interrupts
argument_list|(
name|adapter
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ixgb_clean_transmit_interrupts
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|loop_cnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rxdmt0
operator|&&
name|adapter
operator|->
name|raidc
condition|)
block|{
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IMC
argument_list|,
name|IXGB_INT_RXDMT0
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IMS
argument_list|,
name|IXGB_INT_RXDMT0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|ixgb_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_media_status: begin"
argument_list|)
expr_stmt|;
name|ixgb_check_for_link
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|ixgb_print_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|hw
operator|.
name|link_up
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
operator||
name|IFM_FDX
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine maps the mbufs to tx descriptors.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixgb_encap
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|u_int8_t
name|txd_popts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|struct
name|ifvlan
modifier|*
name|ifv
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|bus_dma_segment_t
name|segs
index|[
name|IXGB_MAX_SCATTER
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|ixgb_buffer
modifier|*
name|tx_buffer
init|=
name|NULL
decl_stmt|;
name|struct
name|ixgb_tx_desc
modifier|*
name|current_tx_desc
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
comment|/* 	 * Force a cleanup if number of TX descriptors available hits the 	 * threshold 	 */
if|if
condition|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|<=
name|IXGB_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|ixgb_clean_transmit_interrupts
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|<=
name|IXGB_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|adapter
operator|->
name|no_tx_desc_avail1
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * Map the packet for DMA. 	 */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|map
argument_list|)
condition|)
block|{
name|adapter
operator|->
name|no_tx_map_avail
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|m_head
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: ixgb_encap: bus_dmamap_load_mbuf failed; "
literal|"error %u\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|!=
literal|0
argument_list|,
operator|(
literal|"ixgb_encap: empty packet"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|>
name|adapter
operator|->
name|num_tx_desc_avail
condition|)
block|{
name|adapter
operator|->
name|no_tx_desc_avail2
operator|++
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_hwassist
operator|>
literal|0
condition|)
block|{
name|ixgb_transmit_checksum_setup
argument_list|(
name|adapter
argument_list|,
name|m_head
argument_list|,
operator|&
name|txd_popts
argument_list|)
expr_stmt|;
block|}
else|else
name|txd_popts
operator|=
literal|0
expr_stmt|;
comment|/* Find out if we are in vlan mode */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
if|if
condition|(
operator|(
name|m_head
operator|->
name|m_flags
operator|&
operator|(
name|M_PROTO1
operator||
name|M_PKTHDR
operator|)
operator|)
operator|==
operator|(
name|M_PROTO1
operator||
name|M_PKTHDR
operator|)
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|!=
name|NULL
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_type
operator|==
name|IFT_L2VLAN
condition|)
name|ifv
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_softc
expr_stmt|;
empty|#elseif __FreeBSD_version< 700000
name|mtag
operator|=
name|VLAN_OUTPUT_TAG
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|adapter
operator|->
name|next_avail_tx_desc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|i
index|]
expr_stmt|;
name|current_tx_desc
operator|=
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|i
index|]
expr_stmt|;
name|current_tx_desc
operator|->
name|buff_addr
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|current_tx_desc
operator|->
name|cmd_type_len
operator|=
operator|(
name|adapter
operator|->
name|txd_cmd
operator||
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
operator|)
expr_stmt|;
name|current_tx_desc
operator|->
name|popts
operator|=
name|txd_popts
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
name|adapter
operator|->
name|num_tx_desc_avail
operator|-=
name|nsegs
expr_stmt|;
name|adapter
operator|->
name|next_avail_tx_desc
operator|=
name|i
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
if|if
condition|(
name|ifv
operator|!=
name|NULL
condition|)
block|{
comment|/* Set the vlan id */
name|current_tx_desc
operator|->
name|vlan
operator|=
name|ifv
operator|->
name|ifv_tag
expr_stmt|;
empty|#elseif __FreeBSD_version< 700000
if|if
condition|(
name|mtag
operator|!=
name|NULL
condition|)
block|{
comment|/* Set the vlan id */
name|current_tx_desc
operator|->
name|vlan
operator|=
name|VLAN_TAG_VALUE
argument_list|(
name|mtag
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|current_tx_desc
operator|->
name|vlan
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
expr_stmt|;
endif|#
directive|endif
comment|/* Tell hardware to add tag */
name|current_tx_desc
operator|->
name|cmd_type_len
operator||=
name|IXGB_TX_DESC_CMD_VLE
expr_stmt|;
block|}
name|tx_buffer
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Last Descriptor of Packet needs End Of Packet (EOP) 	 */
name|current_tx_desc
operator|->
name|cmd_type_len
operator||=
operator|(
name|IXGB_TX_DESC_CMD_EOP
operator|)
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (Tdt), this tells the E1000 	 * that this frame is available to transmit. 	 */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDT
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|ixgb_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|reg_rctl
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg_rctl
operator||=
operator|(
name|IXGB_RCTL_UPE
operator||
name|IXGB_RCTL_MPE
operator|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg_rctl
operator||=
name|IXGB_RCTL_MPE
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|IXGB_RCTL_UPE
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
specifier|static
name|void
name|ixgb_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|reg_rctl
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|IXGB_RCTL_UPE
operator|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|IXGB_RCTL_MPE
operator|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|mta
index|[
name|MAX_NUM_MULTICAST_ADDRESSES
operator|*
name|IXGB_ETH_LENGTH_OF_ADDRESS
index|]
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixgb_set_multi: begin"
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|LIST_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
else|#
directive|else
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
endif|#
directive|endif
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|mta
index|[
name|mcnt
operator|*
name|IXGB_ETH_LENGTH_OF_ADDRESS
index|]
argument_list|,
name|IXGB_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|reg_rctl
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|IXGB_RCTL_MPE
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
else|else
name|ixgb_mc_addr_list_update
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|mta
argument_list|,
name|mcnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status and updates statistics.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_check_for_link
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|ixgb_print_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgb_display_debug_stats
operator|&&
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ixgb_print_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ixgb_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ixgb_print_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|link_up
condition|)
block|{
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Link is up %d Mbps %s \n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
literal|10000
argument_list|,
literal|"Full Duplex"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|adapter
operator|->
name|link_active
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Link is Down \n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|IXGB_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_stop: begin\n"
argument_list|)
expr_stmt|;
name|ixgb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgb_adapter_stop
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixgb_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ixgb_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
comment|/* Make sure our PCI config space has the necessary stuff set */
name|adapter
operator|->
name|hw
operator|.
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|pci_cmd_word
operator|&
name|PCIM_CMD_BUSMASTEREN
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|hw
operator|.
name|pci_cmd_word
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Memory Access and/or Bus Master bits were not set!\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|pci_cmd_word
operator||=
operator|(
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_MEMEN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|pci_cmd_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Save off the information about this board */
name|adapter
operator|->
name|hw
operator|.
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set MacType, etc. based on this PCI info */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|device_id
condition|)
block|{
case|case
name|IXGB_DEVICE_ID_82597EX
case|:
case|case
name|IXGB_DEVICE_ID_82597EX_SR
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac_type
operator|=
name|ixgb_82597
expr_stmt|;
break|break;
default|default:
name|INIT_DEBUGOUT1
argument_list|(
literal|"Unknown device if 0x%x"
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|device_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: unsupported device id 0x%x\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|device_id
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
specifier|static
name|int
name|ixgb_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|IXGB_MMBA
expr_stmt|;
name|adapter
operator|->
name|res_memory
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|res_memory
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to allocate bus resource: memory\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|rid
operator|=
literal|0x0
expr_stmt|;
name|adapter
operator|->
name|res_interrupt
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|res_interrupt
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to allocate bus resource: interrupt\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res_interrupt
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|ixgb_intr
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|int_handler_tag
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Error registering interrupt handler!\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|adapter
operator|->
name|osdep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|ixgb_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res_interrupt
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res_interrupt
argument_list|,
name|adapter
operator|->
name|int_handler_tag
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|res_interrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|res_memory
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|IXGB_MMBA
argument_list|,
name|adapter
operator|->
name|res_memory
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|res_ioport
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|adapter
operator|->
name|io_rid
argument_list|,
name|adapter
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  Initialize the hardware to a configuration as specified by the  *  adapter structure. The controller is reset, the EEPROM is  *  verified, the MAC address is set, then the shared initialization  *  routines are called.  *  **********************************************************************/
specifier|static
name|int
name|ixgb_hardware_init
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* Issue a global reset */
name|adapter
operator|->
name|hw
operator|.
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
name|ixgb_adapter_stop
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
operator|!
name|ixgb_validate_eeprom_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: The EEPROM Checksum Is Not Valid\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ixgb_init_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Hardware Initialization Failed"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgb_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: can not if_alloc()\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502000
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_unit
operator|=
name|adapter
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ixgb"
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|1000000000
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ixgb_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|adapter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixgb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ixgb_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ixgb_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
else|#
directive|else
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|curr_mac_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixgb_media_change
argument_list|,
name|ixgb_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/********************************************************************  * Manage DMA'able memory.  *******************************************************************/
specifier|static
name|void
name|ixgb_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
return|return;
block|}
specifier|static
name|int
name|ixgb_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|ixgb_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502000
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
endif|#
directive|endif
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: ixgb_dma_malloc: bus_dma_tag_create failed; "
literal|"error %u\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|r
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: ixgb_dma_malloc: bus_dmamem_alloc failed; "
literal|"error %u\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
name|r
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|ixgb_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: ixgb_dma_malloc: bus_dmamap_load failed; "
literal|"error %u\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_map
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
specifier|static
name|void
name|ixgb_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ixgb_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire.  *  **********************************************************************/
specifier|static
name|int
name|ixgb_allocate_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|tx_buffer_area
operator|=
operator|(
expr|struct
name|ixgb_buffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_buffer
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to allocate tx_buffer memory\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|adapter
operator|->
name|tx_buffer_area
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_buffer
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*********************************************************************  *  *  Allocate and initialize transmit structures.  *  **********************************************************************/
specifier|static
name|int
name|ixgb_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
operator|*
name|IXGB_MAX_SCATTER
argument_list|,
comment|/* maxsize */
name|IXGB_MAX_SCATTER
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502000
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
endif|#
directive|endif
operator|&
name|adapter
operator|->
name|txtag
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to allocate TX DMA tag\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|ixgb_allocate_transmit_structures
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
name|ENOMEM
return|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|adapter
operator|->
name|tx_desc_base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_tx_desc
argument_list|)
operator|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|next_avail_tx_desc
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|oldest_used_tx_desc
operator|=
literal|0
expr_stmt|;
comment|/* Set number of descriptors available */
name|adapter
operator|->
name|num_tx_desc_avail
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
comment|/* Set checksum context */
name|adapter
operator|->
name|active_checksum_context
operator|=
name|OFFLOAD_NONE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_initialize_transmit_unit
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_tctl
decl_stmt|;
name|u_int64_t
name|tdba
init|=
name|adapter
operator|->
name|txdma
operator|.
name|dma_paddr
decl_stmt|;
comment|/* Setup the Base and Length of the Tx Descriptor Ring */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDBAL
argument_list|,
operator|(
name|tdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDBAH
argument_list|,
operator|(
name|tdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDLEN
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Tx Head and Tail descriptor pointers */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HW_DEBUGOUT2
argument_list|(
literal|"Base = %x, Length = %x\n"
argument_list|,
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDBAL
argument_list|)
argument_list|,
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TDLEN
argument_list|)
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TIDV
argument_list|,
name|adapter
operator|->
name|tx_int_delay
argument_list|)
expr_stmt|;
comment|/* Program the Transmit Control Register */
name|reg_tctl
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TCTL
argument_list|)
expr_stmt|;
name|reg_tctl
operator|=
name|IXGB_TCTL_TCE
operator||
name|IXGB_TCTL_TXEN
operator||
name|IXGB_TCTL_TPDE
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TCTL
argument_list|,
name|reg_tctl
argument_list|)
expr_stmt|;
comment|/* Setup Transmit Descriptor Settings for this adapter */
name|adapter
operator|->
name|txd_cmd
operator|=
name|IXGB_TX_DESC_TYPE
operator||
name|IXGB_TX_DESC_CMD_RS
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tx_int_delay
operator|>
literal|0
condition|)
name|adapter
operator|->
name|txd_cmd
operator||=
name|IXGB_TX_DESC_CMD_IDE
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Free all transmit related data structures.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgb_buffer
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_transmit_structures: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|tx_buffer
operator|=
name|adapter
operator|->
name|tx_buffer_area
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|tx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
block|}
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adapter
operator|->
name|tx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|adapter
operator|->
name|tx_buffer_area
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tx_buffer_area
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|txtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|txtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  The offload context needs to be set when we transfer the first  *  packet of a particular protocol (TCP/UDP). We change the  *  context only if the protocol type changes.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_transmit_checksum_setup
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u_int8_t
modifier|*
name|txd_popts
parameter_list|)
block|{
name|struct
name|ixgb_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|ixgb_buffer
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|curr_txd
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
block|{
operator|*
name|txd_popts
operator|=
name|IXGB_TX_DESC_POPTS_TXSM
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|active_checksum_context
operator|==
name|OFFLOAD_TCP_IP
condition|)
return|return;
else|else
name|adapter
operator|->
name|active_checksum_context
operator|=
name|OFFLOAD_TCP_IP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
operator|*
name|txd_popts
operator|=
name|IXGB_TX_DESC_POPTS_TXSM
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|active_checksum_context
operator|==
name|OFFLOAD_UDP_IP
condition|)
return|return;
else|else
name|adapter
operator|->
name|active_checksum_context
operator|=
name|OFFLOAD_UDP_IP
expr_stmt|;
block|}
else|else
block|{
operator|*
name|txd_popts
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
operator|*
name|txd_popts
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we reach this point, the checksum offload context needs to be 	 * reset. 	 */
name|curr_txd
operator|=
name|adapter
operator|->
name|next_avail_tx_desc
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|curr_txd
index|]
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|ixgb_context_desc
operator|*
operator|)
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|curr_txd
index|]
expr_stmt|;
name|TXD
operator|->
name|tucss
operator|=
name|ENET_HEADER_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|tucse
operator|=
literal|0
expr_stmt|;
name|TXD
operator|->
name|mss
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|active_checksum_context
operator|==
name|OFFLOAD_TCP_IP
condition|)
block|{
name|TXD
operator|->
name|tucso
operator|=
name|ENET_HEADER_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|active_checksum_context
operator|==
name|OFFLOAD_UDP_IP
condition|)
block|{
name|TXD
operator|->
name|tucso
operator|=
name|ENET_HEADER_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
expr_stmt|;
block|}
name|TXD
operator|->
name|cmd_type_len
operator|=
name|IXGB_CONTEXT_DESC_CMD_TCP
operator||
name|IXGB_TX_DESC_CMD_RS
operator||
name|IXGB_CONTEXT_DESC_CMD_IDE
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|++
name|curr_txd
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|curr_txd
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|num_tx_desc_avail
operator|--
expr_stmt|;
name|adapter
operator|->
name|next_avail_tx_desc
operator|=
name|curr_txd
expr_stmt|;
return|return;
block|}
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_clean_transmit_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_avail
decl_stmt|;
name|struct
name|ixgb_buffer
modifier|*
name|tx_buffer
decl_stmt|;
name|struct
name|ixgb_tx_desc
modifier|*
name|tx_desc
decl_stmt|;
name|IXGB_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
return|return;
ifdef|#
directive|ifdef
name|_SV_
name|adapter
operator|->
name|clean_tx_interrupts
operator|++
expr_stmt|;
endif|#
directive|endif
name|num_avail
operator|=
name|adapter
operator|->
name|num_tx_desc_avail
expr_stmt|;
name|i
operator|=
name|adapter
operator|->
name|oldest_used_tx_desc
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|i
index|]
expr_stmt|;
name|tx_desc
operator|=
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|tx_desc
operator|->
name|status
operator|&
name|IXGB_TX_DESC_STATUS_DD
condition|)
block|{
name|tx_desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|num_avail
operator|++
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|i
index|]
expr_stmt|;
name|tx_desc
operator|=
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|i
index|]
expr_stmt|;
block|}
name|adapter
operator|->
name|oldest_used_tx_desc
operator|=
name|i
expr_stmt|;
comment|/* 	 * If we have enough room, clear IFF_DRV_OACTIVE to tell the stack that 	 * it is OK to send packets. If there are no pending descriptors, 	 * clear the timeout. Otherwise, if some descriptors have been freed, 	 * restart the timeout. 	 */
if|if
condition|(
name|num_avail
operator|>
name|IXGB_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|num_avail
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|num_avail
operator|==
name|adapter
operator|->
name|num_tx_desc_avail
condition|)
name|ifp
operator|->
name|if_timer
operator|=
name|IXGB_TX_TIMEOUT
expr_stmt|;
block|}
name|adapter
operator|->
name|num_tx_desc_avail
operator|=
name|num_avail
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Get a buffer from system mbuf buffer pool.  *  **********************************************************************/
specifier|static
name|int
name|ixgb_get_buf
parameter_list|(
name|int
name|i
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
name|nmp
parameter_list|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
init|=
name|nmp
decl_stmt|;
name|struct
name|ixgb_buffer
modifier|*
name|rx_buffer
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_alloc_failed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mp
operator|->
name|m_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|mp
operator|->
name|m_data
operator|=
name|mp
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|<=
name|ETHERMTU
condition|)
block|{
name|m_adj
argument_list|(
name|mp
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
block|}
name|rx_buffer
operator|=
operator|&
name|adapter
operator|->
name|rx_buffer_area
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Using memory from the mbuf cluster pool, invoke the bus_dma 	 * machinery to arrange the memory mapping. 	 */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|,
name|rx_buffer
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mp
operator|->
name|m_len
argument_list|,
name|ixgb_dmamap_cb
argument_list|,
operator|&
name|paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rx_buffer
operator|->
name|m_head
operator|=
name|mp
expr_stmt|;
name|adapter
operator|->
name|rx_desc_base
index|[
name|i
index|]
operator|.
name|buff_addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|,
name|rx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
specifier|static
name|int
name|ixgb_allocate_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|ixgb_buffer
modifier|*
name|rx_buffer
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|rx_buffer_area
operator|=
operator|(
expr|struct
name|ixgb_buffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_buffer
argument_list|)
operator|*
name|adapter
operator|->
name|num_rx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: Unable to allocate rx_buffer memory\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|adapter
operator|->
name|rx_buffer_area
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_buffer
argument_list|)
operator|*
name|adapter
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502000
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
endif|#
directive|endif
operator|&
name|adapter
operator|->
name|rxtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: ixgb_allocate_receive_structures: "
literal|"bus_dma_tag_create failed; error %u\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|rx_buffer
operator|=
name|adapter
operator|->
name|rx_buffer_area
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
operator|,
name|rx_buffer
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ixgb%d: ixgb_allocate_receive_structures: "
literal|"bus_dmamap_create failed; error %u\n"
argument_list|,
name|adapter
operator|->
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ixgb_get_buf
argument_list|(
name|i
argument_list|,
name|adapter
argument_list|,
name|NULL
argument_list|)
operator|==
name|ENOBUFS
condition|)
block|{
name|adapter
operator|->
name|rx_buffer_area
index|[
name|i
index|]
operator|.
name|m_head
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|rx_desc_base
index|[
name|i
index|]
operator|.
name|buff_addr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail_1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|adapter
operator|->
name|rxtag
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|rx_buffer_area
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rx_buffer_area
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Allocate and initialize receive structures.  *  **********************************************************************/
specifier|static
name|int
name|ixgb_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|adapter
operator|->
name|rx_desc_base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_rx_desc
argument_list|)
operator|)
operator|*
name|adapter
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgb_allocate_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
name|ENOMEM
return|;
comment|/* Setup our descriptor pointers */
name|adapter
operator|->
name|next_rx_desc_to_check
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|next_rx_desc_to_use
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Enable receive unit.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_initialize_receive_unit
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u_int32_t
name|reg_rctl
decl_stmt|;
name|u_int32_t
name|reg_rxcsum
decl_stmt|;
name|u_int32_t
name|reg_rxdctl
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int64_t
name|rdba
init|=
name|adapter
operator|->
name|rxdma
operator|.
name|dma_paddr
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
comment|/* 	 * Make sure receives are disabled while setting up the descriptor 	 * ring 	 */
name|reg_rctl
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|,
name|reg_rctl
operator|&
operator|~
name|IXGB_RCTL_RXEN
argument_list|)
expr_stmt|;
comment|/* Set the Receive Delay Timer Register */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RDTR
argument_list|,
name|adapter
operator|->
name|rx_int_delay
argument_list|)
expr_stmt|;
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RDBAL
argument_list|,
operator|(
name|rdba
operator|&
literal|0x00000000ffffffffULL
operator|)
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RDBAH
argument_list|,
operator|(
name|rdba
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RDLEN
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ixgb_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the HW Rx Head and Tail Descriptor Pointers */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RDH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RDT
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
name|reg_rxdctl
operator|=
name|RXDCTL_WTHRESH_DEFAULT
operator|<<
name|IXGB_RXDCTL_WTHRESH_SHIFT
operator||
name|RXDCTL_HTHRESH_DEFAULT
operator|<<
name|IXGB_RXDCTL_HTHRESH_SHIFT
operator||
name|RXDCTL_PTHRESH_DEFAULT
operator|<<
name|IXGB_RXDCTL_PTHRESH_SHIFT
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RXDCTL
argument_list|,
name|reg_rxdctl
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|raidc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|raidc
condition|)
block|{
name|uint32_t
name|raidc
decl_stmt|;
name|uint8_t
name|poll_threshold
decl_stmt|;
define|#
directive|define
name|IXGB_RAIDC_POLL_DEFAULT
value|120
name|poll_threshold
operator|=
operator|(
operator|(
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|poll_threshold
operator|>>=
literal|1
expr_stmt|;
name|poll_threshold
operator|&=
literal|0x3F
expr_stmt|;
name|raidc
operator|=
name|IXGB_RAIDC_EN
operator||
name|IXGB_RAIDC_RXT_GATE
operator||
operator|(
name|IXGB_RAIDC_POLL_DEFAULT
operator|<<
name|IXGB_RAIDC_POLL_SHIFT
operator|)
operator||
operator|(
name|adapter
operator|->
name|rx_int_delay
operator|<<
name|IXGB_RAIDC_DELAY_SHIFT
operator|)
operator||
name|poll_threshold
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RAIDC
argument_list|,
name|raidc
argument_list|)
expr_stmt|;
block|}
comment|/* Enable Receive Checksum Offload for TCP and UDP ? */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|reg_rxcsum
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RXCSUM
argument_list|)
expr_stmt|;
name|reg_rxcsum
operator||=
name|IXGB_RXCSUM_TUOFL
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RXCSUM
argument_list|,
name|reg_rxcsum
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the Receive Control Register */
name|reg_rctl
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
operator|(
literal|3
operator|<<
name|IXGB_RCTL_MO_SHIFT
operator|)
expr_stmt|;
name|reg_rctl
operator||=
name|IXGB_RCTL_BAM
operator||
name|IXGB_RCTL_RDMTS_1_2
operator||
name|IXGB_RCTL_SECRC
operator||
name|IXGB_RCTL_CFF
operator||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mc_filter_type
operator|<<
name|IXGB_RCTL_MO_SHIFT
operator|)
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|rx_buffer_len
condition|)
block|{
default|default:
case|case
name|IXGB_RXBUFFER_2048
case|:
name|reg_rctl
operator||=
name|IXGB_RCTL_BSIZE_2048
expr_stmt|;
break|break;
case|case
name|IXGB_RXBUFFER_4096
case|:
name|reg_rctl
operator||=
name|IXGB_RCTL_BSIZE_4096
expr_stmt|;
break|break;
case|case
name|IXGB_RXBUFFER_8192
case|:
name|reg_rctl
operator||=
name|IXGB_RCTL_BSIZE_8192
expr_stmt|;
break|break;
case|case
name|IXGB_RXBUFFER_16384
case|:
name|reg_rctl
operator||=
name|IXGB_RCTL_BSIZE_16384
expr_stmt|;
break|break;
block|}
name|reg_rctl
operator||=
name|IXGB_RCTL_RXEN
expr_stmt|;
comment|/* Enable Receives */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Free receive related data structures.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ixgb_buffer
modifier|*
name|rx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_receive_structures: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|rx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|rx_buffer
operator|=
name|adapter
operator|->
name|rx_buffer_area
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
operator|,
name|rx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|rx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|,
name|rx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|,
name|rx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rx_buffer
operator|->
name|m_head
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|rx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adapter
operator|->
name|rx_buffer_area
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|adapter
operator|->
name|rx_buffer_area
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rx_buffer_area
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|rxtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rxtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *  *********************************************************************/
specifier|static
name|void
name|ixgb_process_receive_interrupts
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
endif|#
directive|endif
name|int
name|eop
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int8_t
name|accept_frame
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|next_to_use
init|=
literal|0
decl_stmt|;
name|int
name|eop_desc
decl_stmt|;
comment|/* Pointer to the receive descriptor being examined. */
name|struct
name|ixgb_rx_desc
modifier|*
name|current_desc
decl_stmt|;
name|IXGB_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|i
operator|=
name|adapter
operator|->
name|next_rx_desc_to_check
expr_stmt|;
name|next_to_use
operator|=
name|adapter
operator|->
name|next_rx_desc_to_use
expr_stmt|;
name|eop_desc
operator|=
name|adapter
operator|->
name|next_rx_desc_to_check
expr_stmt|;
name|current_desc
operator|=
operator|&
name|adapter
operator|->
name|rx_desc_base
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|current_desc
operator|->
name|status
operator|)
operator|&
name|IXGB_RX_DESC_STATUS_DD
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|_SV_
name|adapter
operator|->
name|no_pkts_avail
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
while|while
condition|(
operator|(
name|current_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_DD
operator|)
operator|&&
operator|(
name|count
operator|!=
literal|0
operator|)
condition|)
block|{
name|mp
operator|=
name|adapter
operator|->
name|rx_buffer_area
index|[
name|i
index|]
operator|.
name|m_head
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|rxtag
argument_list|,
name|adapter
operator|->
name|rx_buffer_area
index|[
name|i
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|accept_frame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_EOP
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|eop
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|eop
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|current_desc
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|current_desc
operator|->
name|errors
operator|&
operator|(
name|IXGB_RX_DESC_ERRORS_CE
operator||
name|IXGB_RX_DESC_ERRORS_SE
operator||
name|IXGB_RX_DESC_ERRORS_P
operator||
name|IXGB_RX_DESC_ERRORS_RXE
operator|)
condition|)
block|{
name|accept_frame
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|accept_frame
condition|)
block|{
comment|/* Assign correct length to the current fragment */
name|mp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|fmp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|adapter
operator|->
name|fmp
operator|=
name|mp
expr_stmt|;
comment|/* Store the first mbuf */
name|adapter
operator|->
name|lmp
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
comment|/* Chain mbuf's together */
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|adapter
operator|->
name|lmp
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|adapter
operator|->
name|lmp
operator|=
name|adapter
operator|->
name|lmp
operator|->
name|m_next
expr_stmt|;
name|adapter
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|eop
condition|)
block|{
name|eop_desc
operator|=
name|i
expr_stmt|;
name|adapter
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|eh
operator|=
name|mtod
argument_list|(
name|adapter
operator|->
name|fmp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Remove ethernet header from mbuf */
name|m_adj
argument_list|(
name|adapter
operator|->
name|fmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ixgb_receive_checksum
argument_list|(
name|adapter
argument_list|,
name|current_desc
argument_list|,
name|adapter
operator|->
name|fmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_VP
condition|)
name|VLAN_INPUT_TAG
argument_list|(
name|eh
argument_list|,
name|adapter
operator|->
name|fmp
argument_list|,
name|current_desc
operator|->
name|special
argument_list|)
expr_stmt|;
else|else
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|adapter
operator|->
name|fmp
argument_list|)
expr_stmt|;
else|#
directive|else
name|ixgb_receive_checksum
argument_list|(
name|adapter
argument_list|,
name|current_desc
argument_list|,
name|adapter
operator|->
name|fmp
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
if|if
condition|(
name|current_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_VP
condition|)
name|VLAN_INPUT_TAG
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|fmp
argument_list|,
name|current_desc
operator|->
name|special
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|current_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_VP
condition|)
block|{
name|adapter
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|current_desc
operator|->
name|special
expr_stmt|;
name|adapter
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|adapter
operator|->
name|fmp
operator|!=
name|NULL
condition|)
block|{
name|IXGB_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|IXGB_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|adapter
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
name|adapter
operator|->
name|rx_buffer_area
index|[
name|i
index|]
operator|.
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|adapter
operator|->
name|dropped_pkts
operator|++
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|fmp
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|adapter
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Zero out the receive descriptors status  */
name|current_desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Advance our pointers to the next descriptor */
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|current_desc
operator|=
name|adapter
operator|->
name|rx_desc_base
expr_stmt|;
block|}
else|else
name|current_desc
operator|++
expr_stmt|;
block|}
name|adapter
operator|->
name|next_rx_desc_to_check
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|i
operator|=
operator|(
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	 * 82597EX: Workaround for redundent write back in receive descriptor ring (causes  	 * memory corruption). Avoid using and re-submitting the most recently received RX 	 * descriptor back to hardware. 	 * 	 * if(Last written back descriptor == EOP bit set descriptor) 	 * 	then avoid re-submitting the most recently received RX descriptor  	 *	back to hardware. 	 * if(Last written back descriptor != EOP bit set descriptor) 	 *	then avoid re-submitting the most recently received RX descriptors 	 * 	till last EOP bit set descriptor.  	 */
if|if
condition|(
name|eop_desc
operator|!=
name|i
condition|)
block|{
if|if
condition|(
operator|++
name|eop_desc
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|eop_desc
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|eop_desc
expr_stmt|;
block|}
comment|/* Replenish the descriptors with new mbufs till last EOP bit set descriptor */
while|while
condition|(
name|next_to_use
operator|!=
name|i
condition|)
block|{
name|current_desc
operator|=
operator|&
name|adapter
operator|->
name|rx_desc_base
index|[
name|next_to_use
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|current_desc
operator|->
name|errors
operator|&
operator|(
name|IXGB_RX_DESC_ERRORS_CE
operator||
name|IXGB_RX_DESC_ERRORS_SE
operator||
name|IXGB_RX_DESC_ERRORS_P
operator||
name|IXGB_RX_DESC_ERRORS_RXE
operator|)
operator|)
condition|)
block|{
name|mp
operator|=
name|adapter
operator|->
name|rx_buffer_area
index|[
name|next_to_use
index|]
operator|.
name|m_head
expr_stmt|;
name|ixgb_get_buf
argument_list|(
name|next_to_use
argument_list|,
name|adapter
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ixgb_get_buf
argument_list|(
name|next_to_use
argument_list|,
name|adapter
argument_list|,
name|NULL
argument_list|)
operator|==
name|ENOBUFS
condition|)
break|break;
block|}
comment|/* Advance our pointers to the next descriptor */
if|if
condition|(
operator|++
name|next_to_use
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
block|{
name|next_to_use
operator|=
literal|0
expr_stmt|;
name|current_desc
operator|=
name|adapter
operator|->
name|rx_desc_base
expr_stmt|;
block|}
else|else
name|current_desc
operator|++
expr_stmt|;
block|}
name|adapter
operator|->
name|next_rx_desc_to_use
operator|=
name|next_to_use
expr_stmt|;
if|if
condition|(
operator|--
name|next_to_use
operator|<
literal|0
condition|)
name|next_to_use
operator|=
operator|(
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Advance the IXGB's Receive Queue #0  "Tail Pointer" */
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RDT
argument_list|,
name|next_to_use
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
specifier|static
name|void
name|ixgb_receive_checksum
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ixgb_rx_desc
modifier|*
name|rx_desc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|rx_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_IXSM
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rx_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_IPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|rx_desc
operator|->
name|errors
operator|&
name|IXGB_RX_DESC_ERRORS_IPE
operator|)
condition|)
block|{
comment|/* IP Checksum Good */
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rx_desc
operator|->
name|status
operator|&
name|IXGB_RX_DESC_STATUS_TCPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|rx_desc
operator|->
name|errors
operator|&
name|IXGB_RX_DESC_ERRORS_TCPE
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
specifier|static
name|void
name|ixgb_enable_vlans
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint32_t
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|CTRL0
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|IXGB_CTRL0_VME
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ixgb_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IMS
argument_list|,
operator|(
name|IXGB_INT_RXT0
operator||
name|IXGB_INT_TXDW
operator||
name|IXGB_INT_RXDMT0
operator||
name|IXGB_INT_LSC
operator||
name|IXGB_INT_RXO
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ixgb_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|IXGB_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|void
name|ixgb_write_pci_cfg
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint16_t
modifier|*
name|value
parameter_list|)
block|{
name|pci_write_config
argument_list|(
operator|(
operator|(
expr|struct
name|ixgb_osdep
operator|*
operator|)
name|hw
operator|->
name|back
operator|)
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
operator|*
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**********************************************************************  *  *  Update the board statistics counters.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|CRCERRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gprcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GPRCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gprch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GPRCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gorcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GORCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gorch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GORCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bprcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BPRCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bprch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BPRCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mprcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|MPRCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mprch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|MPRCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|roc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|ROC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mpc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|MPC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|dc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|DC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rlec
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RLEC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xonrxc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|XONRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xontxc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|XONTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xoffrxc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|XOFFRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xofftxc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|XOFFTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gptcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GPTCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gptch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GPTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GOTCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|GOTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rfc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rjc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RJC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|torl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TORL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|torh
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TORH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|totl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TOTL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|toth
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TOTH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tprl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TPRL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tprh
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TPRH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tptl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TPTL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpth
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TPTH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|plt64c
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PLT64C
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mptcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|MPTCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mptch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|MPTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bptcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BPTCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bptch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BPTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|uprcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|UPRCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|uprch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|UPRCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vprcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|VPRCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vprch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|VPRCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|jprcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|JPRCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|jprch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|JPRCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rnbc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|RNBC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icbc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|ICBC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ecbc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|ECBC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|uptcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|UPTCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|uptch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|UPTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vptcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|VPTCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|vptch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|VPTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|jptcl
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|JPTCL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|jptch
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|JPTCH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tsctc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TSCTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tsctfc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TSCTFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ibic
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|IBIC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|lfc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|LFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|pfrc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PFRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|pftc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PFTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mcfrc
operator|+=
name|IXGB_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|MCFRC
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
comment|/* Fill out the OS statistics structure */
name|ifp
operator|->
name|if_ipackets
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gprcl
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gptcl
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gorcl
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|adapter
operator|->
name|stats
operator|.
name|gotcl
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|adapter
operator|->
name|stats
operator|.
name|mprcl
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|=
literal|0
expr_stmt|;
comment|/* Rx Errors */
name|ifp
operator|->
name|if_ierrors
operator|=
name|adapter
operator|->
name|dropped_pkts
operator|+
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+
name|adapter
operator|->
name|stats
operator|.
name|rnbc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|mpc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|rlec
expr_stmt|;
block|}
comment|/**********************************************************************  *  *  This routine is called only when ixgb_display_debug_stats is enabled.  *  This routine provides a way to take a look at important statistics  *  maintained by the driver and hardware.  *  **********************************************************************/
specifier|static
name|void
name|ixgb_print_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|char
name|buf_speed
index|[
literal|100
index|]
decl_stmt|,
name|buf_type
index|[
literal|100
index|]
decl_stmt|;
name|ixgb_bus_speed
name|bus_speed
decl_stmt|;
name|ixgb_bus_type
name|bus_type
decl_stmt|;
name|int
name|unit
init|=
name|adapter
operator|->
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|_SV_
name|printf
argument_list|(
literal|"ixgb%d: Packets not Avail = %ld\n"
argument_list|,
name|unit
argument_list|,
name|adapter
operator|->
name|no_pkts_avail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: CleanTxInterrupts = %ld\n"
argument_list|,
name|unit
argument_list|,
name|adapter
operator|->
name|clean_tx_interrupts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: ICR RXDMT0 = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_rxdmt0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: ICR RXO = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_rxo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: ICR RXT0 = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_rxt0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: ICR TXDW = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|sv_stats
operator|.
name|icr_TXDW
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _SV_ */
name|bus_speed
operator|=
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|speed
expr_stmt|;
name|bus_type
operator|=
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|type
expr_stmt|;
name|sprintf
argument_list|(
name|buf_speed
argument_list|,
name|bus_speed
operator|==
name|ixgb_bus_speed_33
condition|?
literal|"33MHz"
else|:
name|bus_speed
operator|==
name|ixgb_bus_speed_66
condition|?
literal|"66MHz"
else|:
name|bus_speed
operator|==
name|ixgb_bus_speed_100
condition|?
literal|"100MHz"
else|:
name|bus_speed
operator|==
name|ixgb_bus_speed_133
condition|?
literal|"133MHz"
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: PCI_Bus_Speed = %s\n"
argument_list|,
name|unit
argument_list|,
name|buf_speed
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf_type
argument_list|,
name|bus_type
operator|==
name|ixgb_bus_type_pci
condition|?
literal|"PCI"
else|:
name|bus_type
operator|==
name|ixgb_bus_type_pcix
condition|?
literal|"PCI-X"
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: PCI_Bus_Type = %s\n"
argument_list|,
name|unit
argument_list|,
name|buf_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Tx Descriptors not Avail1 = %ld\n"
argument_list|,
name|unit
argument_list|,
name|adapter
operator|->
name|no_tx_desc_avail1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Tx Descriptors not Avail2 = %ld\n"
argument_list|,
name|unit
argument_list|,
name|adapter
operator|->
name|no_tx_desc_avail2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Std Mbuf Failed = %ld\n"
argument_list|,
name|unit
argument_list|,
name|adapter
operator|->
name|mbuf_alloc_failed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Std Cluster Failed = %ld\n"
argument_list|,
name|unit
argument_list|,
name|adapter
operator|->
name|mbuf_cluster_failed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Defer count = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|dc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Missed Packets = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|mpc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Receive No Buffers = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|rnbc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Receive length errors = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|rlec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Crc errors = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Driver dropped packets = %ld\n"
argument_list|,
name|unit
argument_list|,
name|adapter
operator|->
name|dropped_pkts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: XON Rcvd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|xonrxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: XON Xmtd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|xontxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: XOFF Rcvd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|xoffrxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: XOFF Xmtd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|xofftxc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Good Packets Rcvd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|gprcl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Good Packets Xmtd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|gptcl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Jumbo frames recvd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|jprcl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ixgb%d: Jumbo frames Xmtd = %lld\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter
operator|->
name|stats
operator|.
name|jptcl
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|int
name|ixgb_sysctl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|ixgb_print_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

end_unit

