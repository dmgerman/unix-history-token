begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006-2007 Daniel Roethlisberger<daniel@roe.ch>  * Copyright (c) 2000-2004 OMNIKEY GmbH (www.omnikey.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * OMNIKEY CardMan 4040 a.k.a. CardMan eXtended (cmx) driver.  * This is a PCMCIA based smartcard reader which seems to work  * like an I/O port mapped USB CCID smartcard device.  *  * I/O originally based on Linux driver version 1.1.0 by OMNIKEY.  * Dual GPL/BSD.  Almost all of the code has been rewritten.  * $Omnikey: cm4040_cs.c,v 1.7 2004/10/04 09:08:50 jp Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/cmx/cmxvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/cmx/cmxreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CMX_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEBUG_printf
parameter_list|(
name|dev
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|device_printf(dev, "%s: " fmt, __FUNCTION__, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG_printf
parameter_list|(
name|dev
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SPIN_COUNT
value|1000
end_define

begin_define
define|#
directive|define
name|WAIT_TICKS
value|(hz/100)
end_define

begin_define
define|#
directive|define
name|POLL_TICKS
value|(hz/10)
end_define

begin_comment
comment|/* possibly bogus */
end_comment

begin_define
define|#
directive|define
name|CCID_DRIVER_BULK_DEFAULT_TIMEOUT
value|(150*hz)
end_define

begin_define
define|#
directive|define
name|CCID_DRIVER_ASYNC_POWERUP_TIMEOUT
value|(35*hz)
end_define

begin_define
define|#
directive|define
name|CCID_DRIVER_MINIMUM_TIMEOUT
value|(3*hz)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CMX_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|BSRBITS
index|[]
init|=
literal|"\020"
literal|"\01BULK_OUT_FULL"
comment|/* 0x01 */
literal|"\02BULK_IN_FULL"
comment|/* 0x02 */
literal|"\03(0x04)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x04 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CMX_INTR
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|SCRBITS
index|[]
init|=
literal|"\020"
literal|"\01POWER_DOWN"
comment|/* 0x01 */
literal|"\02PULSE_INTERRUPT"
comment|/* 0x02 */
literal|"\03HOST_TO_READER_DONE"
comment|/* 0x04 */
literal|"\04READER_TO_HOST_DONE"
comment|/* 0x08 */
literal|"\05ACK_NOTIFY"
comment|/* 0x10 */
literal|"\06EN_NOTIFY"
comment|/* 0x20 */
literal|"\07ABORT"
comment|/* 0x40 */
literal|"\10HOST_TO_READER_START"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x80 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CMX_INTR */
end_comment

begin_decl_stmt
specifier|static
name|char
name|POLLBITS
index|[]
init|=
literal|"\020"
literal|"\01POLLIN"
comment|/* 0x0001 */
literal|"\02POLLPRI"
comment|/* 0x0002 */
literal|"\03POLLOUT"
comment|/* 0x0004 */
literal|"\04POLLERR"
comment|/* 0x0008 */
literal|"\05POLLHUP"
comment|/* 0x0010 */
literal|"\06POLLINVAL"
comment|/* 0x0020 */
literal|"\07POLLRDNORM"
comment|/* 0x0040 */
literal|"\10POLLRDBAND"
comment|/* 0x0080 */
literal|"\11POLLWRBAND"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x0100 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|MODEBITS
index|[]
init|=
literal|"\020"
literal|"\01READ"
comment|/* 0x0001 */
literal|"\02WRITE"
comment|/* 0x0002 */
literal|"\03NONBLOCK"
comment|/* 0x0004 */
literal|"\04APPEND"
comment|/* 0x0008 */
literal|"\05SHLOCK"
comment|/* 0x0010 */
literal|"\06EXLOCK"
comment|/* 0x0020 */
literal|"\07ASYNC"
comment|/* 0x0040 */
literal|"\10FSYNC"
comment|/* 0x0080 */
literal|"\11NOFOLLOW"
comment|/* 0x0100 */
literal|"\12CREAT"
comment|/* 0x0200 */
literal|"\13TRUNK"
comment|/* 0x0400 */
literal|"\14EXCL"
comment|/* 0x0800 */
literal|"\15(0x1000)"
comment|/* 0x1000 */
literal|"\16(0x2000)"
comment|/* 0x2000 */
literal|"\17HASLOCK"
comment|/* 0x4000 */
literal|"\20NOCTTY"
comment|/* 0x8000 */
literal|"\21DIRECT"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x00010000 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CMX_DEBUG */
end_comment

begin_decl_stmt
name|devclass_t
name|cmx_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|cmx_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|cmx_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|cmx_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|cmx_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|cmx_poll
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CMX_INTR
end_ifdef

begin_function_decl
specifier|static
name|void
name|cmx_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cmx_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|cmx_open
block|,
operator|.
name|d_close
operator|=
name|cmx_close
block|,
operator|.
name|d_read
operator|=
name|cmx_read
block|,
operator|.
name|d_write
operator|=
name|cmx_write
block|,
operator|.
name|d_poll
operator|=
name|cmx_poll
block|,
operator|.
name|d_name
operator|=
literal|"cmx"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the softc structure.  Must be called from  * the bus specific device allocation routine.  */
end_comment

begin_function
name|void
name|cmx_init_softc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|timeout
operator|=
name|CCID_DRIVER_MINIMUM_TIMEOUT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate driver resources.  Must be called from the  * bus specific device allocation routine.  Caller must  * ensure to call cmx_release_resources to free the  * resources when detaching.  * Return zero if successful, and ENOMEM if the resources  * could not be allocated.  */
end_comment

begin_function
name|int
name|cmx_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|CMX_INTR
name|int
name|rv
decl_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|ioport
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ioport_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ioport
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate io port\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CMX_INTR
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate irq\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
name|cmx_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to set up irq\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"cmx softc lock"
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Release the resources allocated by cmx_allocate_resources.  */
end_comment

begin_function
name|void
name|cmx_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CMX_INTR
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ih
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|ioport
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ioport_rid
argument_list|,
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ioport_rid
argument_list|,
name|sc
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ioport
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Bus independant device attachment routine.  Creates the  * character device node.  */
end_comment

begin_function
name|int
name|cmx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|||
name|sc
operator|->
name|dying
condition|)
return|return
name|ENXIO
return|;
name|sc
operator|->
name|cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|cmx_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"cmx%d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|cdev
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create character device\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Bus independant device detachment routine.  Makes sure all  * allocated resources are freed, callouts disabled and waiting  * processes unblocked.  */
end_comment

begin_function
name|int
name|cmx_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DEBUG_printf
argument_list|(
name|dev
argument_list|,
literal|"called\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dying
operator|=
literal|1
expr_stmt|;
name|CMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
condition|)
block|{
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"disabling polling\n"
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|sel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|dev
argument_list|,
literal|"releasing resources\n"
argument_list|)
expr_stmt|;
name|cmx_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for buffer status register events.  If test is non-zero,  * wait until flags are set, otherwise wait until flags are unset.  * Will spin SPIN_COUNT times, then sleep until timeout is reached.  * Returns zero if event happened, EIO if the timeout was reached,  * and ENXIO if the device was detached in the meantime.  When that  * happens, the caller must quit immediately, since a detach is  * in progress.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmx_wait_BSR
parameter_list|(
name|struct
name|cmx_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|int
name|test
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPIN_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmx_test_BSR
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|,
name|test
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|*
name|WAIT_TICKS
operator|<
name|sc
operator|->
name|timeout
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmx_test_BSR
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|,
name|test
argument_list|)
condition|)
return|return
literal|0
return|;
name|rv
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"cmx"
argument_list|,
name|WAIT_TICKS
argument_list|)
expr_stmt|;
comment|/* 		 * Currently, the only reason for waking up with 		 * rv == 0 is when we are detaching, in which 		 * case sc->dying is always 1. 		 */
if|if
condition|(
name|sc
operator|->
name|dying
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|rv
operator|!=
name|EAGAIN
condition|)
return|return
name|rv
return|;
block|}
comment|/* timeout */
return|return
name|EIO
return|;
block|}
end_function

begin_comment
comment|/*  * Set the sync control register to val.  Before and after writing  * to the SCR, we wait for the BSR to not signal BULK_OUT_FULL.  * Returns zero if successful, or whatever errors cmx_wait_BSR can  * return.  ENXIO signals that the device has been detached in the  * meantime, and that we should leave the kernel immediately.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cmx_sync_write_SCR
parameter_list|(
name|struct
name|cmx_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_wait_BSR
argument_list|(
name|sc
argument_list|,
name|BSR_BULK_OUT_FULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
name|cmx_write_SCR
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_wait_BSR
argument_list|(
name|sc
argument_list|,
name|BSR_BULK_OUT_FULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a suitable timeout value based on the given command byte.  * Some commands appear to need longer timeout values than others.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|cmx_timeout_by_cmd
parameter_list|(
name|uint8_t
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CMD_PC_TO_RDR_XFRBLOCK
case|:
case|case
name|CMD_PC_TO_RDR_SECURE
case|:
case|case
name|CMD_PC_TO_RDR_TEST_SECURE
case|:
case|case
name|CMD_PC_TO_RDR_OK_SECURE
case|:
return|return
name|CCID_DRIVER_BULK_DEFAULT_TIMEOUT
return|;
case|case
name|CMD_PC_TO_RDR_ICCPOWERON
case|:
return|return
name|CCID_DRIVER_ASYNC_POWERUP_TIMEOUT
return|;
case|case
name|CMD_PC_TO_RDR_GETSLOTSTATUS
case|:
case|case
name|CMD_PC_TO_RDR_ICCPOWEROFF
case|:
case|case
name|CMD_PC_TO_RDR_GETPARAMETERS
case|:
case|case
name|CMD_PC_TO_RDR_RESETPARAMETERS
case|:
case|case
name|CMD_PC_TO_RDR_SETPARAMETERS
case|:
case|case
name|CMD_PC_TO_RDR_ESCAPE
case|:
case|case
name|CMD_PC_TO_RDR_ICCCLOCK
case|:
default|default:
return|return
name|CCID_DRIVER_MINIMUM_TIMEOUT
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Periodical callout routine, polling the reader for data  * availability.  If the reader signals data ready for reading,  * wakes up the processes which are waiting in select()/poll().  * Otherwise, reschedules itself with a delay of POLL_TICKS.  */
end_comment

begin_function
specifier|static
name|void
name|cmx_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|uint8_t
name|bsr
decl_stmt|;
name|CMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|&&
operator|!
name|sc
operator|->
name|dying
condition|)
block|{
name|bsr
operator|=
name|cmx_read_BSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"BSR=%b\n"
argument_list|,
name|bsr
argument_list|,
name|BSRBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmx_test
argument_list|(
name|bsr
argument_list|,
name|BSR_BULK_IN_FULL
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|sel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|,
name|POLL_TICKS
argument_list|,
name|cmx_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the character device.  Only a single process may open the  * device at a time.  */
end_comment

begin_function
specifier|static
name|int
name|cmx_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|cdev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|dying
condition|)
return|return
name|ENXIO
return|;
name|CMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|open
condition|)
block|{
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|sc
operator|->
name|open
operator|=
literal|1
expr_stmt|;
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"open (flags=%b thread=%p)\n"
argument_list|,
name|flags
argument_list|,
name|MODEBITS
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Close the character device.  */
end_comment

begin_function
specifier|static
name|int
name|cmx_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|cdev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|dying
condition|)
return|return
name|ENXIO
return|;
name|CMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|open
condition|)
block|{
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|polling
condition|)
block|{
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"disabling polling\n"
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|sel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
name|CMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|open
operator|=
literal|0
expr_stmt|;
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"close (flags=%b thread=%p)\n"
argument_list|,
name|flags
argument_list|,
name|MODEBITS
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read from the character device.  * Returns zero if successful, ENXIO if dying, EINVAL if an attempt  * was made to read less than CMX_MIN_RDLEN bytes or less than the  * device has available, or any of the errors that cmx_sync_write_SCR  * can return.  Partial reads are not supported.  */
end_comment

begin_function
specifier|static
name|int
name|cmx_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|cdev
operator|->
name|si_drv1
decl_stmt|;
name|unsigned
name|long
name|bytes_left
decl_stmt|;
name|uint8_t
name|uc
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|amnt
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|dying
condition|)
return|return
name|ENXIO
return|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"called (len=%d flag=%b)\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|flag
argument_list|,
name|MODEBITS
argument_list|)
expr_stmt|;
name|CMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
condition|)
block|{
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"disabling polling\n"
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|sc
operator|->
name|sel
argument_list|,
name|PZERO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|CMX_MIN_RDLEN
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
if|if
condition|(
name|cmx_test_BSR
argument_list|(
name|sc
argument_list|,
name|BSR_BULK_IN_FULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_wait_BSR
argument_list|(
name|sc
argument_list|,
name|BSR_BULK_IN_FULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
name|sc
operator|->
name|buf
index|[
name|i
index|]
operator|=
name|cmx_read_DTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"buf[%02x]=%02x\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bytes_left
operator|=
name|CMX_MIN_RDLEN
operator|+
operator|(
literal|0x000000FF
operator|&
operator|(
operator|(
name|char
operator|)
name|sc
operator|->
name|buf
index|[
literal|1
index|]
operator|)
operator|)
operator|+
operator|(
literal|0x0000FF00
operator|&
operator|(
operator|(
name|char
operator|)
name|sc
operator|->
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|)
operator|+
operator|(
literal|0x00FF0000
operator|&
operator|(
operator|(
name|char
operator|)
name|sc
operator|->
name|buf
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator|)
operator|+
operator|(
literal|0xFF000000
operator|&
operator|(
operator|(
name|char
operator|)
name|sc
operator|->
name|buf
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"msgsz=%lu\n"
argument_list|,
name|bytes_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|bytes_left
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|offset
operator|=
literal|5
expr_stmt|;
comment|/* prefetched header */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|amnt
operator|=
name|MIN
argument_list|(
name|bytes_left
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|amnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_wait_BSR
argument_list|(
name|sc
argument_list|,
name|BSR_BULK_IN_FULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
name|sc
operator|->
name|buf
index|[
name|i
index|]
operator|=
name|cmx_read_DTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"buf[%02x]=%02x\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|uiomove
argument_list|(
name|sc
operator|->
name|buf
argument_list|,
name|amnt
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"uiomove failed (%d)\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
name|offset
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
name|bytes_left
operator|-=
name|amnt
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_wait_BSR
argument_list|(
name|sc
argument_list|,
name|BSR_BULK_IN_FULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_sync_write_SCR
argument_list|(
name|sc
argument_list|,
name|SCR_READER_TO_HOST_DONE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
name|uc
operator|=
name|cmx_read_DTR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"success (DTR=%02x)\n"
argument_list|,
name|uc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Write to the character device.  * Returns zero if successful, NXIO if dying, EINVAL if less data  * written than CMX_MIN_WRLEN, or any of the errors that cmx_sync_SCR  * can return.  */
end_comment

begin_function
specifier|static
name|int
name|cmx_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|cdev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|amnt
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|dying
condition|)
return|return
name|ENXIO
return|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"called (len=%d flag=%b)\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|flag
argument_list|,
name|MODEBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|CMX_MIN_WRLEN
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_sync_write_SCR
argument_list|(
name|sc
argument_list|,
name|SCR_HOST_TO_READER_START
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
name|sc
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|amnt
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|uiomove
argument_list|(
name|sc
operator|->
name|buf
argument_list|,
name|amnt
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"uiomove failed (%d)\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
comment|/* wildly guessed attempt to notify device */
name|sc
operator|->
name|timeout
operator|=
name|CCID_DRIVER_MINIMUM_TIMEOUT
expr_stmt|;
name|cmx_sync_write_SCR
argument_list|(
name|sc
argument_list|,
name|SCR_HOST_TO_READER_DONE
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|timeout
operator|=
name|cmx_timeout_by_cmd
argument_list|(
name|sc
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cmd=%02x timeout=%lu\n"
argument_list|,
name|sc
operator|->
name|buf
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|amnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_wait_BSR
argument_list|(
name|sc
argument_list|,
name|BSR_BULK_OUT_FULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
name|cmx_write_DTR
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"buf[%02x]=%02x\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|cmx_sync_write_SCR
argument_list|(
name|sc
argument_list|,
name|SCR_HOST_TO_READER_DONE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|rv
return|;
block|}
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"success\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Poll handler.  Writing is always possible, reading is only possible  * if BSR_BULK_IN_FULL is set.  Will start the cmx_tick callout and  * set sc->polling.  */
end_comment

begin_function
specifier|static
name|int
name|cmx_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
name|cdev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|uint8_t
name|bsr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|dying
condition|)
return|return
name|ENXIO
return|;
name|bsr
operator|=
name|cmx_read_BSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"called (events=%b BSR=%b)\n"
argument_list|,
name|events
argument_list|,
name|POLLBITS
argument_list|,
name|bsr
argument_list|,
name|BSRBITS
argument_list|)
expr_stmt|;
name|revents
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|cmx_test
argument_list|(
name|bsr
argument_list|,
name|BSR_BULK_IN_FULL
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sc
operator|->
name|sel
argument_list|)
expr_stmt|;
name|CMX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|polling
condition|)
block|{
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"enabling polling\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|1
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|,
name|POLL_TICKS
argument_list|,
name|cmx_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"already polling\n"
argument_list|)
expr_stmt|;
block|}
name|CMX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"success (revents=%b)\n"
argument_list|,
name|revents
argument_list|,
name|POLLBITS
argument_list|)
expr_stmt|;
return|return
name|revents
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CMX_INTR
end_ifdef

begin_comment
comment|/*  * Interrupt handler.  Currently has no function except to  * print register status (if debugging is also enabled).  */
end_comment

begin_function
specifier|static
name|void
name|cmx_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cmx_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cmx_softc
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|dying
condition|)
return|return;
name|DEBUG_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"received interrupt (SCR=%b BSR=%b)\n"
argument_list|,
name|cmx_read_SCR
argument_list|(
name|sc
argument_list|)
argument_list|,
name|SCRBITS
argument_list|,
name|cmx_read_BSR
argument_list|(
name|sc
argument_list|)
argument_list|,
name|BSRBITS
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

