begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Neterion, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XGE_DEBUG_FP
end_ifdef

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-channel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|xge_hal_status_e
name|__hal_channel_dtr_alloc
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
modifier|*
name|dtrh
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|tmp_arr
decl_stmt|;
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_RX_MULTI_FREE_IRQ
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_FREE_IRQ
argument_list|)
name|unsigned
name|long
name|flags
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|channel
operator|->
name|terminating
condition|)
block|{
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
name|channel
operator|->
name|reserve_length
operator|-
name|channel
operator|->
name|reserve_top
operator|>
name|channel
operator|->
name|reserve_threshold
condition|)
block|{
name|_alloc_after_swap
label|:
operator|*
name|dtrh
operator|=
name|channel
operator|->
name|reserve_arr
index|[
operator|--
name|channel
operator|->
name|reserve_length
index|]
expr_stmt|;
name|xge_debug_channel
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"dtrh 0x"
name|XGE_OS_LLXFMT
literal|" allocated, "
literal|"channel %d:%d:%d, reserve_idx %d"
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|ulong_t
argument_list|)
operator|*
name|dtrh
argument_list|,
name|channel
operator|->
name|type
argument_list|,
name|channel
operator|->
name|post_qid
argument_list|,
name|channel
operator|->
name|compl_qid
argument_list|,
name|channel
operator|->
name|reserve_length
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_RX_MULTI_FREE_IRQ
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_FREE_IRQ
argument_list|)
name|xge_os_spin_lock_irq
argument_list|(
operator|&
name|channel
operator|->
name|free_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XGE_HAL_RX_MULTI_FREE
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_FREE
argument_list|)
name|xge_os_spin_lock
argument_list|(
operator|&
name|channel
operator|->
name|free_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* switch between empty and full arrays */
comment|/* the idea behind such a design is that by having free and reserved 	 * arrays separated we basically separated irq and non-irq parts. 	 * i.e. no additional lock need to be done when we free a resource */
if|if
condition|(
name|channel
operator|->
name|reserve_initial
operator|-
name|channel
operator|->
name|free_length
operator|>
name|channel
operator|->
name|reserve_threshold
condition|)
block|{
name|tmp_arr
operator|=
name|channel
operator|->
name|reserve_arr
expr_stmt|;
name|channel
operator|->
name|reserve_arr
operator|=
name|channel
operator|->
name|free_arr
expr_stmt|;
name|channel
operator|->
name|reserve_length
operator|=
name|channel
operator|->
name|reserve_initial
expr_stmt|;
name|channel
operator|->
name|free_arr
operator|=
name|tmp_arr
expr_stmt|;
name|channel
operator|->
name|reserve_top
operator|=
name|channel
operator|->
name|free_length
expr_stmt|;
name|channel
operator|->
name|free_length
operator|=
name|channel
operator|->
name|reserve_initial
expr_stmt|;
name|channel
operator|->
name|stats
operator|.
name|reserve_free_swaps_cnt
operator|++
expr_stmt|;
name|xge_debug_channel
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"switch on channel %d:%d:%d, reserve_length %d, "
literal|"free_length %d"
argument_list|,
name|channel
operator|->
name|type
argument_list|,
name|channel
operator|->
name|post_qid
argument_list|,
name|channel
operator|->
name|compl_qid
argument_list|,
name|channel
operator|->
name|reserve_length
argument_list|,
name|channel
operator|->
name|free_length
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_RX_MULTI_FREE_IRQ
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_FREE_IRQ
argument_list|)
name|xge_os_spin_unlock_irq
argument_list|(
operator|&
name|channel
operator|->
name|free_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XGE_HAL_RX_MULTI_FREE
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_FREE
argument_list|)
name|xge_os_spin_unlock
argument_list|(
operator|&
name|channel
operator|->
name|free_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|_alloc_after_swap
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_RX_MULTI_FREE_IRQ
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_FREE_IRQ
argument_list|)
name|xge_os_spin_unlock_irq
argument_list|(
operator|&
name|channel
operator|->
name|free_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XGE_HAL_RX_MULTI_FREE
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_FREE
argument_list|)
name|xge_os_spin_unlock
argument_list|(
operator|&
name|channel
operator|->
name|free_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xge_debug_channel
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"channel %d:%d:%d is empty!"
argument_list|,
name|channel
operator|->
name|type
argument_list|,
name|channel
operator|->
name|post_qid
argument_list|,
name|channel
operator|->
name|compl_qid
argument_list|)
expr_stmt|;
name|channel
operator|->
name|stats
operator|.
name|full_cnt
operator|++
expr_stmt|;
operator|*
name|dtrh
operator|=
name|NULL
expr_stmt|;
return|return
name|XGE_HAL_INF_OUT_OF_DESCRIPTORS
return|;
block|}
end_function

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|void
name|__hal_channel_dtr_restore
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
comment|/* restore a previously allocated dtrh at current offset and update 	 * the available reserve length accordingly. If dtrh is null just 	 * update the reserve length, only */
if|if
condition|(
name|dtrh
condition|)
block|{
name|channel
operator|->
name|reserve_arr
index|[
name|channel
operator|->
name|reserve_length
operator|+
name|offset
index|]
operator|=
name|dtrh
expr_stmt|;
name|xge_debug_channel
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"dtrh 0x"
name|XGE_OS_LLXFMT
literal|" restored for "
literal|"channel %d:%d:%d, offset %d at reserve index %d, "
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
operator|(
name|ulong_t
operator|)
name|dtrh
argument_list|,
name|channel
operator|->
name|type
argument_list|,
name|channel
operator|->
name|post_qid
argument_list|,
name|channel
operator|->
name|compl_qid
argument_list|,
name|offset
argument_list|,
name|channel
operator|->
name|reserve_length
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|->
name|reserve_length
operator|+=
name|offset
expr_stmt|;
name|xge_debug_channel
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"channel %d:%d:%d, restored "
literal|"for offset %d, new reserve_length %d, free length %d"
argument_list|,
name|channel
operator|->
name|type
argument_list|,
name|channel
operator|->
name|post_qid
argument_list|,
name|channel
operator|->
name|compl_qid
argument_list|,
name|offset
argument_list|,
name|channel
operator|->
name|reserve_length
argument_list|,
name|channel
operator|->
name|free_length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|void
name|__hal_channel_dtr_post
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
name|xge_assert
argument_list|(
name|channel
operator|->
name|work_arr
index|[
name|channel
operator|->
name|post_index
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|channel
operator|->
name|work_arr
index|[
name|channel
operator|->
name|post_index
operator|++
index|]
operator|=
name|dtrh
expr_stmt|;
comment|/* wrap-around */
if|if
condition|(
name|channel
operator|->
name|post_index
operator|==
name|channel
operator|->
name|length
condition|)
name|channel
operator|->
name|post_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|void
name|__hal_channel_dtr_try_complete
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
modifier|*
name|dtrh
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
name|xge_assert
argument_list|(
name|channel
operator|->
name|work_arr
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|channel
operator|->
name|compl_index
operator|<
name|channel
operator|->
name|length
argument_list|)
expr_stmt|;
operator|*
name|dtrh
operator|=
name|channel
operator|->
name|work_arr
index|[
name|channel
operator|->
name|compl_index
index|]
expr_stmt|;
block|}
end_function

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|void
name|__hal_channel_dtr_complete
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
name|channel
operator|->
name|work_arr
index|[
name|channel
operator|->
name|compl_index
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* wrap-around */
if|if
condition|(
operator|++
name|channel
operator|->
name|compl_index
operator|==
name|channel
operator|->
name|length
condition|)
name|channel
operator|->
name|compl_index
operator|=
literal|0
expr_stmt|;
name|channel
operator|->
name|stats
operator|.
name|total_compl_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|void
name|__hal_channel_dtr_free
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
name|channel
operator|->
name|free_arr
index|[
operator|--
name|channel
operator|->
name|free_length
index|]
operator|=
name|dtrh
expr_stmt|;
name|xge_debug_channel
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"dtrh 0x"
name|XGE_OS_LLXFMT
literal|" freed, "
literal|"channel %d:%d:%d, new free_length %d"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
operator|(
name|ulong_t
operator|)
name|dtrh
argument_list|,
name|channel
operator|->
name|type
argument_list|,
name|channel
operator|->
name|post_qid
argument_list|,
name|channel
operator|->
name|compl_qid
argument_list|,
name|channel
operator|->
name|free_length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_channel_dtr_count  * @channelh: Channel handle. Obtained via xge_hal_channel_open().  *  * Retreive number of DTRs available. This function can not be called  * from data path.  */
end_comment

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|int
name|xge_hal_channel_dtr_count
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
return|return
operator|(
operator|(
name|channel
operator|->
name|reserve_length
operator|-
name|channel
operator|->
name|reserve_top
operator|)
operator|+
operator|(
name|channel
operator|->
name|reserve_initial
operator|-
name|channel
operator|->
name|free_length
operator|)
operator|-
name|channel
operator|->
name|reserve_threshold
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_channel_userdata - Get user-specified channel context.  * @channelh: Channel handle. Obtained via xge_hal_channel_open().  *  * Returns: per-channel "user data", which can be any ULD-defined context.  * The %userdata "gets" into the channel at open time  * (see xge_hal_channel_open()).  *  * See also: xge_hal_channel_open().  */
end_comment

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|void
modifier|*
name|xge_hal_channel_userdata
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
return|return
name|channel
operator|->
name|userdata
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_channel_id - Get channel ID.  * @channelh: Channel handle. Obtained via xge_hal_channel_open().  *  * Returns: channel ID. For link layer channel id is the number  * in the range from 0 to 7 that identifies hardware ring or fifo,  * depending on the channel type.  */
end_comment

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|int
name|xge_hal_channel_id
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
return|return
name|channel
operator|->
name|post_qid
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_check_alignment - Check buffer alignment and calculate the  * "misaligned" portion.  * @dma_pointer: DMA address of the buffer.  * @size: Buffer size, in bytes.  * @alignment: Alignment "granularity" (see below), in bytes.  * @copy_size: Maximum number of bytes to "extract" from the buffer  * (in order to spost it as a separate scatter-gather entry). See below.  *  * Check buffer alignment and calculate "misaligned" portion, if exists.  * The buffer is considered aligned if its address is multiple of  * the specified @alignment. If this is the case,  * xge_hal_check_alignment() returns zero.  * Otherwise, xge_hal_check_alignment() uses the last argument,  * @copy_size,  * to calculate the size to "extract" from the buffer. The @copy_size  * may or may not be equal @alignment. The difference between these two  * arguments is that the @alignment is used to make the decision: aligned  * or not aligned. While the @copy_size is used to calculate the portion  * of the buffer to "extract", i.e. to post as a separate entry in the  * transmit descriptor. For example, the combination  * @alignment=8 and @copy_size=64 will work okay on AMD Opteron boxes.  *  * Note: @copy_size should be a multiple of @alignment. In many practical  * cases @copy_size and @alignment will probably be equal.  *  * See also: xge_hal_fifo_dtr_buffer_set_aligned().  */
end_comment

begin_function
name|__HAL_STATIC_CHANNEL
name|__HAL_INLINE_CHANNEL
name|int
name|xge_hal_check_alignment
parameter_list|(
name|dma_addr_t
name|dma_pointer
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|alignment
parameter_list|,
name|int
name|copy_size
parameter_list|)
block|{
name|int
name|misaligned_size
decl_stmt|;
name|misaligned_size
operator|=
call|(
name|int
call|)
argument_list|(
name|dma_pointer
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|misaligned_size
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|size
operator|>
name|copy_size
condition|)
block|{
name|misaligned_size
operator|=
call|(
name|int
call|)
argument_list|(
name|dma_pointer
operator|&
operator|(
name|copy_size
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|misaligned_size
operator|=
name|copy_size
operator|-
name|misaligned_size
expr_stmt|;
block|}
else|else
block|{
name|misaligned_size
operator|=
name|size
expr_stmt|;
block|}
return|return
name|misaligned_size
return|;
block|}
end_function

end_unit

