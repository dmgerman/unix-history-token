begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999, 2003  Scott Mitchell  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Portions of this software were derived from Werner Koch's xirc2ps driver  * for Linux under the terms of the following license (from v1.30 of the  * xirc2ps driver):  *  * Copyright (c) 1997 by Werner Koch (dd9jn)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, and the entire permission notice in its entirety,  *    including the disclaimer of warranties.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*		  * FreeBSD device driver for Xircom CreditCard PCMCIA Ethernet adapters.  The  * following cards are currently known to work with the driver:  *   Xircom CreditCard 10/100 (CE3)  *   Xircom CreditCard Ethernet + Modem 28 (CEM28)  *   Xircom CreditCard Ethernet 10/100 + Modem 56 (CEM56)  *   Xircom RealPort Ethernet 10  *   Xircom RealPort Ethernet 10/100  *   Xircom RealPort Ethernet 10/100 + Modem 56 (REM56, REM56G)  *   Intel EtherExpress Pro/100 PC Card Mobile Adapter 16 (Pro/100 M16A)  *   Compaq Netelligent 10/100 PC Card (CPQ-10/100)  *  * Some other cards *should* work, but support for them is either broken or in   * an unknown state at the moment.  I'm always interested in hearing from  * people who own any of these cards:  *   Xircom CreditCard 10Base-T (PS-CE2-10)  *   Xircom CreditCard Ethernet + ModemII (CEM2)  *   Xircom CEM28 and CEM33 Ethernet/Modem cards (may be variants of CEM2?)  *  * Thanks to all who assisted with the development and testing of the driver,  * especially: Werner Koch, Duke Kamstra, Duncan Barclay, Jason George, Dru  * Nelson, Mike Kephart, Bill Rainey and Douglas Rand.  Apologies if I've left  * out anyone who deserves a mention here.  *  * Special thanks to Ade Lovett for both hosting the mailing list and doing  * the CEM56/REM56 support code; and the FreeBSD UK Users' Group for hosting  * the web pages.  *  * Author email:<scott@uk.freebsd.org>  * Driver web page: http://ukug.uk.freebsd.org/~scott/xe_drv/  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/xe/if_xereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/xe/if_xevar.h>
end_include

begin_comment
comment|/*  * MII command structure  */
end_comment

begin_struct
struct|struct
name|xe_mii_frame
block|{
name|u_int8_t
name|mii_stdelim
decl_stmt|;
name|u_int8_t
name|mii_opcode
decl_stmt|;
name|u_int8_t
name|mii_phyaddr
decl_stmt|;
name|u_int8_t
name|mii_regaddr
decl_stmt|;
name|u_int8_t
name|mii_turnaround
decl_stmt|;
name|u_int16_t
name|mii_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Media autonegotiation progress constants  */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_NONE
value|0
end_define

begin_comment
comment|/* No autonegotiation in progress */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_WAITING
value|1
end_define

begin_comment
comment|/* Waiting for transmitter to go idle */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_STARTED
value|2
end_define

begin_comment
comment|/* Waiting for autonegotiation to complete */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_100TX
value|3
end_define

begin_comment
comment|/* Trying to force 100baseTX link */
end_comment

begin_define
define|#
directive|define
name|XE_AUTONEG_FAIL
value|4
end_define

begin_comment
comment|/* Autonegotiation failed */
end_comment

begin_comment
comment|/*  * Prototypes start here  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|mrp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|xe_setmedia
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|xe_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_enable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_disable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_set_multicast
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_set_addr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int8_t
modifier|*
name|addr
parameter_list|,
name|unsigned
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mchash
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * MII functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_mii_sync
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_mii_send
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int32_t
name|bits
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xe_mii_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|xe_phy_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xe_phy_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Debugging functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void      xe_reg_dump		(struct xe_softc *scp);
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Debug logging levels - set with hw.xe.debug sysctl  * 0 = None  * 1 = More hardware details, probe/attach progress  * 2 = Most function calls, ioctls and media selection progress  * 3 = Everything - interrupts, packets in/out and multicast address setup  */
end_comment

begin_define
define|#
directive|define
name|XE_DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XE_DEBUG
end_ifdef

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|xe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"if_xe parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|xe_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_xe
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|xe_debug
argument_list|,
literal|0
argument_list|,
literal|"if_xe debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DEVPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
value|if (xe_debug>= (level)) device_printf arg
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
value|if (xe_debug>= (level)) printf arg
end_define

begin_define
define|#
directive|define
name|XE_MII_DUMP
parameter_list|(
name|scp
parameter_list|)
value|if (xe_debug>= 3) xe_mii_dump(scp)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|XE_REG_DUMP
parameter_list|(
name|scp
parameter_list|)
value|if (xe_debug>= 3) xe_reg_dump(scp)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEVPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|level
parameter_list|,
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|XE_MII_DUMP
parameter_list|(
name|scp
parameter_list|)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|XE_REG_DUMP
parameter_list|(
name|scp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Attach a device.  */
end_comment

begin_function
name|int
name|xe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"attach\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialise stuff... */
name|scp
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|scp
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|ifp
operator|==
name|NULL
condition|)
return|return
name|ENOSPC
return|;
name|scp
operator|->
name|ifm
operator|=
operator|&
name|scp
operator|->
name|ifmedia
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
comment|/* Initialise the ifnet structure */
name|scp
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|scp
expr_stmt|;
name|if_initname
argument_list|(
name|scp
operator|->
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_NEEDSGIANT
operator|)
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|scp
operator|->
name|mibdata
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
name|scp
operator|->
name|mibdata
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_start
operator|=
name|xe_start
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_ioctl
operator|=
name|xe_ioctl
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_watchdog
operator|=
name|xe_watchdog
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_init
operator|=
name|xe_init
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
comment|/* Initialise the ifmedia structure */
name|ifmedia_init
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
literal|0
argument_list|,
name|xe_media_change
argument_list|,
name|xe_media_status
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|scp
operator|->
name|chand
argument_list|)
expr_stmt|;
comment|/* Add supported media types */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_HDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|ce2
condition|)
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Default is to autoselect best supported media type */
name|ifmedia_set
argument_list|(
name|scp
operator|->
name|ifm
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* Get the hardware into a known state */
name|xe_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Get hardware version numbers */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|scp
operator|->
name|version
operator|=
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x70
operator|)
operator|>>
literal|4
expr_stmt|;
else|else
name|scp
operator|->
name|srev
operator|=
operator|(
name|XE_INB
argument_list|(
name|XE_BOV
argument_list|)
operator|&
literal|0x30
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* Print some useful information */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"version 0x%02x/0x%02x%s%s\n"
argument_list|,
name|scp
operator|->
name|version
argument_list|,
name|scp
operator|->
name|srev
argument_list|,
name|scp
operator|->
name|mohawk
condition|?
literal|", 100Mbps capable"
else|:
literal|""
argument_list|,
name|scp
operator|->
name|modem
condition|?
literal|", with modem"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x10
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"DingoID=0x%04x, RevisionID=0x%04x, VendorID=0x%04x\n"
operator|,
name|XE_INW
argument_list|(
name|XE_DINGOID
argument_list|)
operator|,
name|XE_INW
argument_list|(
name|XE_RevID
argument_list|)
operator|,
name|XE_INW
argument_list|(
name|XE_VendorID
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|ce2
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"CE2 version = 0x%02x\n"
operator|,
name|XE_INB
argument_list|(
name|XE_REV
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Attach the interface */
name|ether_ifattach
argument_list|(
name|scp
operator|->
name|ifp
argument_list|,
name|scp
operator|->
name|enaddr
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Complete hardware intitialisation and enable output.  Exits without doing  * anything if there's no address assigned to the card, or if media selection  * is in progress (the latter implies we've already run this function).  */
end_comment

begin_function
specifier|static
name|void
name|xe_init
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|xscp
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|autoneg_status
operator|!=
name|XE_AUTONEG_NONE
condition|)
return|return;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"init\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Reset transmitter flags */
name|scp
operator|->
name|tx_queued
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_tpr
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_timeouts
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|tx_thres
operator|=
literal|64
expr_stmt|;
name|scp
operator|->
name|tx_min
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Soft reset the card */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
comment|/*      * set GP1 and GP2 as outputs (bits 2& 3)      * set GP1 low to power on the ML6692 (bit 0)      * set GP2 high to power on the 10Mhz chip (bit 1)      */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
name|XE_GPR0_GP2_SELECT
operator||
name|XE_GPR0_GP1_SELECT
operator||
name|XE_GPR0_GP2_OUT
argument_list|)
expr_stmt|;
block|}
comment|/* Shut off interrupts */
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Wait for everything to wake up */
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/* Check for PHY */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|scp
operator|->
name|phy_ok
operator|=
name|xe_mii_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Disable 'source insertion' (not sure what that means) */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC0
argument_list|,
name|XE_SWC0_NO_SRC_INSERT
argument_list|)
expr_stmt|;
comment|/* Set 8K/24K Tx/Rx buffer split */
if|if
condition|(
name|scp
operator|->
name|srev
operator|!=
literal|1
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_RBS
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
block|}
comment|/* Enable early transmit mode on Mohawk/Dingo */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x03
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_TPT
argument_list|,
name|scp
operator|->
name|tx_thres
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x01
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_ECR
argument_list|,
name|XE_INB
argument_list|(
name|XE_ECR
argument_list|)
operator||
name|XE_ECR_EARLY_TX
argument_list|)
expr_stmt|;
block|}
comment|/* Put MAC address in first 'individual address' register */
name|XE_SELECT_PAGE
argument_list|(
literal|0x50
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|XE_OUTB
argument_list|(
literal|0x08
operator|+
name|i
argument_list|,
name|IF_LLADDR
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
index|[
name|scp
operator|->
name|mohawk
condition|?
literal|5
operator|-
name|i
else|:
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set up multicast addresses */
name|xe_set_multicast
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Fix the receive data offset -- reset can leave it off-by-one */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_DO
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
comment|/* Set interrupt masks */
name|XE_SELECT_PAGE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_IMR0
argument_list|,
name|XE_IMR0_TX_PACKET
operator||
name|XE_IMR0_MAC_INTR
operator||
name|XE_IMR0_RX_PACKET
argument_list|)
expr_stmt|;
comment|/* Set MAC interrupt masks */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_RX0Msk
argument_list|,
operator|~
operator|(
name|XE_RX0M_RX_OVERRUN
operator||
name|XE_RX0M_CRC_ERROR
operator||
name|XE_RX0M_ALIGN_ERROR
operator||
name|XE_RX0M_LONG_PACKET
operator|)
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TX0Msk
argument_list|,
operator|~
operator|(
name|XE_TX0M_SQE_FAIL
operator||
name|XE_TX0M_LATE_COLLISION
operator||
name|XE_TX0M_TX_UNDERRUN
operator||
name|XE_TX0M_16_COLLISIONS
operator||
name|XE_TX0M_NO_CARRIER
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear MAC status registers */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_RST0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXST0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Enable receiver and put MAC online */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CMD0
argument_list|,
name|XE_CMD0_RX_ENABLE
operator||
name|XE_CMD0_ONLINE
argument_list|)
expr_stmt|;
comment|/* Set up IMR, enable interrupts */
name|xe_enable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Start media selection */
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Enable output */
name|scp
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  Should be called at splimp() priority.  Check  * that the output is idle (ie, IFF_DRV_OACTIVE is not set) before calling this  * function.  If media selection is in progress we set IFF_DRV_OACTIVE ourselves  * and return immediately.  */
end_comment

begin_function
specifier|static
name|void
name|xe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|autoneg_status
operator|!=
name|XE_AUTONEG_NONE
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"start\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*    * Loop while there are packets to be sent, and space to send them.    */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Suck a packet off the send queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbp
operator|==
name|NULL
condition|)
block|{
comment|/*        * We are using the !OACTIVE flag to indicate to the outside world that        * we can accept an additional packet rather than that the transmitter        * is _actually_ active. Indeed, the transmitter may be active, but if        * we haven't filled all the buffers with data then we still want to        * accept more.        */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xe_pio_write_packet
argument_list|(
name|scp
argument_list|,
name|mbp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Push the packet back onto the queue */
name|IF_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* Tap off here if there is a bpf listener */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
comment|/* In case we don't hear from the card again... */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|scp
operator|->
name|tx_queued
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  Adapted from the ed driver.  */
end_comment

begin_function
specifier|static
name|int
name|xe_ioctl
parameter_list|(
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|scp
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"ioctl: SIOCSIFFLAGS: 0x%04x\n"
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
comment|/*      * If the interface is marked up and stopped, then start it.  If it is      * marked down and running, then stop it.      */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|xe_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH  (handle changes to PROMISC/ALLMULTI flags) */
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"ioctl: SIOC{ADD,DEL}MULTI\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Multicast list has (maybe) changed; set the hardware filters      * accordingly.      */
name|xe_set_multicast
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"ioctl: bounce to ifmedia_ioctl\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Someone wants to get/set media options.      */
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|scp
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"ioctl: bounce to ether_ioctl\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Card interrupt handler.  *  * This function is probably more complicated than it needs to be, as it  * attempts to deal with the case where multiple packets get sent between  * interrupts.  This is especially annoying when working out the collision  * stats.  Not sure whether this case ever really happens or not (maybe on a  * slow/heavily loaded machine?) so it's probably best to leave this like it  * is.  *  * Note that the crappy PIO used to get packets on and off the card means that   * you will spend a lot of time in this routine -- I can get my P150 to spend  * 90% of its time servicing interrupts if I really hammer the network.  Could   * fix this, but then you'd start dropping/losing packets.  The moral of this  * story?  If you want good network performance _and_ some cycles left over to   * get your work done, don't buy a Xircom card.  Or convince them to tell me  * how to do memory-mapped I/O :)  */
end_comment

begin_function
specifier|static
name|void
name|xe_intr
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|xscp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int8_t
name|psr
decl_stmt|,
name|isr
decl_stmt|,
name|esr
decl_stmt|,
name|rsr
decl_stmt|,
name|rst0
decl_stmt|,
name|txst0
decl_stmt|,
name|txst1
decl_stmt|,
name|coll
decl_stmt|;
name|ifp
operator|=
name|scp
operator|->
name|ifp
expr_stmt|;
comment|/* Disable interrupts */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cache current register page */
name|psr
operator|=
name|XE_INB
argument_list|(
name|XE_PR
argument_list|)
expr_stmt|;
comment|/* Read ISR to see what caused this interrupt */
while|while
condition|(
operator|(
name|isr
operator|=
name|XE_INB
argument_list|(
name|XE_ISR
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 0xff might mean the card is no longer around */
if|if
condition|(
name|isr
operator|==
literal|0xff
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"intr: interrupt received for missing card?\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Read other status registers */
name|XE_SELECT_PAGE
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|rst0
operator|=
name|XE_INB
argument_list|(
name|XE_RST0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_RST0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txst0
operator|=
name|XE_INB
argument_list|(
name|XE_TXST0
argument_list|)
expr_stmt|;
name|txst1
operator|=
name|XE_INB
argument_list|(
name|XE_TXST1
argument_list|)
expr_stmt|;
name|coll
operator|=
name|txst1
operator|&
name|XE_TXST1_RETRY_COUNT
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXST0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_TXST1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"intr: ISR=0x%02x, RST=0x%02x, TXT=0x%02x%02x, COLL=0x%01x\n"
operator|,
name|isr
operator|,
name|rst0
operator|,
name|txst1
operator|,
name|txst0
operator|,
name|coll
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|XE_ISR_TX_PACKET
condition|)
block|{
name|u_int8_t
name|tpr
decl_stmt|,
name|sent
decl_stmt|;
comment|/* Update packet count, accounting for rollover */
name|tpr
operator|=
name|XE_INB
argument_list|(
name|XE_TPR
argument_list|)
expr_stmt|;
name|sent
operator|=
operator|-
name|scp
operator|->
name|tx_tpr
operator|+
name|tpr
expr_stmt|;
comment|/* Update statistics if we actually sent anything */
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
block|{
name|scp
operator|->
name|tx_tpr
operator|=
name|tpr
expr_stmt|;
name|scp
operator|->
name|tx_queued
operator|-=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|sent
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|coll
expr_stmt|;
comment|/* 	 * According to the Xircom manual, Dingo will sometimes manage to 	 * transmit a packet with triggering an interrupt.  If this happens, 	 * we have sent> 1 and the collision count only reflects collisions 	 * on the last packet sent (the one that triggered the interrupt). 	 * Collision stats might therefore be a bit low, but there doesn't 	 * seem to be anything we can do about that. 	 */
switch|switch
condition|(
name|coll
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
default|default:
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|coll
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
comment|/* Handle most MAC interrupts */
if|if
condition|(
name|isr
operator|&
name|XE_ISR_MAC_INTR
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Carrier sense lost -- only in 10Mbit HDX mode */
block|if (txst0& XE_TXST0_NO_CARRIER || !(txst1& XE_TXST1_LINK_STATUS)) {
comment|/* XXX - Need to update media status here */
block|device_printf(scp->dev, "no carrier\n"); 	ifp->if_oerrors++; 	scp->mibdata.dot3StatsCarrierSenseErrors++;       }
endif|#
directive|endif
comment|/* Excessive collisions -- try sending again */
if|if
condition|(
name|txst0
operator|&
name|XE_TXST0_16_COLLISIONS
condition|)
block|{
name|ifp
operator|->
name|if_collisions
operator|+=
literal|16
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_RESTART_TX
argument_list|)
expr_stmt|;
block|}
comment|/* Transmit underrun -- increase early transmit threshold */
if|if
condition|(
name|txst0
operator|&
name|XE_TXST0_TX_UNDERRUN
operator|&&
name|scp
operator|->
name|mohawk
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"transmit underrun"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|tx_thres
operator|<
name|ETHER_MAX_LEN
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|tx_thres
operator|+=
literal|64
operator|)
operator|>
name|ETHER_MAX_LEN
condition|)
name|scp
operator|->
name|tx_thres
operator|=
name|ETHER_MAX_LEN
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|": increasing transmit threshold to %u"
operator|,
name|scp
operator|->
name|tx_thres
operator|)
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x3
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_TPT
argument_list|,
name|scp
operator|->
name|tx_thres
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
block|}
comment|/* Late collision -- just complain about it */
if|if
condition|(
name|txst0
operator|&
name|XE_TXST0_LATE_COLLISION
condition|)
block|{
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"late collision\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsLateCollisions
operator|++
expr_stmt|;
block|}
comment|/* SQE test failure -- just complain about it */
if|if
condition|(
name|txst0
operator|&
name|XE_TXST0_SQE_FAIL
condition|)
block|{
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"SQE test failure\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsSQETestErrors
operator|++
expr_stmt|;
block|}
comment|/* Packet too long -- what happens to these */
if|if
condition|(
name|rst0
operator|&
name|XE_RST0_LONG_PACKET
condition|)
block|{
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"received giant packet\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFrameTooLongs
operator|++
expr_stmt|;
block|}
comment|/* CRC error -- packet dropped */
if|if
condition|(
name|rst0
operator|&
name|XE_RST0_CRC_ERROR
condition|)
block|{
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"CRC error\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
block|}
block|}
comment|/* Handle received packet(s) */
while|while
condition|(
operator|(
name|esr
operator|=
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|)
operator|&
name|XE_ESR_FULL_PACKET_RX
condition|)
block|{
name|rsr
operator|=
name|XE_INB
argument_list|(
name|XE_RSR
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"intr: ESR=0x%02x, RSR=0x%02x\n"
operator|,
name|esr
operator|,
name|rsr
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure packet is a good one */
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_RX_OK
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|ehp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbp
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|len
operator|=
name|XE_INW
argument_list|(
name|XE_RBC
argument_list|)
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"intr: receive length = %d\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Allocate mbuf to hold received packet.  If the mbuf header isn't 	 * big enough, we attach an mbuf cluster to hold the packet.  Note the 	 * +=2 to align the packet data on a 32-bit boundary, and the +3 to 	 * allow for the possibility of reading one more byte than the actual 	 * packet length (we always read 16-bit words). 	 * XXX - Surely there's a better way to do this alignment? 	 */
name|MGETHDR
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbp
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|+
literal|3
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mbp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mbp
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|mbp
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|ehp
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Now get the packet in PIO mode, including the Ethernet header but 	 * omitting the trailing CRC. 	 */
comment|/* 	 * Work around a bug in CE2 cards.  There seems to be a problem with 	 * duplicated and extraneous bytes in the receive buffer, but without 	 * any real documentation for the CE2 it's hard to tell for sure. 	 * XXX - Needs testing on CE2 hardware 	 */
if|if
condition|(
name|scp
operator|->
name|srev
operator|==
literal|0
condition|)
block|{
name|u_short
name|rhs
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XE_INW
argument_list|(
name|XE_RHSA
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|+=
literal|3
expr_stmt|;
comment|/* Skip control info */
if|if
condition|(
name|rhs
operator|>=
literal|0x8000
condition|)
name|rhs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rhs
operator|+
name|len
operator|>
literal|0x8000
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|rhs
operator|++
control|)
block|{
operator|(
operator|(
name|char
operator|*
operator|)
name|ehp
operator|)
index|[
name|i
index|]
operator|=
name|XE_INB
argument_list|(
name|XE_EDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
literal|0x8000
condition|)
block|{
name|rhs
operator|=
literal|0
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
name|bus_space_read_multi_2
argument_list|(
name|scp
operator|->
name|bst
argument_list|,
name|scp
operator|->
name|bsh
argument_list|,
name|XE_EDP
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|ehp
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|bus_space_read_multi_2
argument_list|(
name|scp
operator|->
name|bst
argument_list|,
name|scp
operator|->
name|bsh
argument_list|,
name|XE_EDP
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|ehp
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* Deliver packet to upper layers */
name|mbp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|mbp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
comment|/* Packet alignment error -- drop packet */
elseif|else
if|if
condition|(
name|rsr
operator|&
name|XE_RSR_ALIGN_ERROR
condition|)
block|{
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"alignment error\n"
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/* Skip to next packet, if there is one */
name|XE_OUTW
argument_list|(
name|XE_DO
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
block|}
comment|/* Clear receiver overruns now we have some free buffer space */
if|if
condition|(
name|rst0
operator|&
name|XE_RST0_RX_OVERRUN
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"receive overrun\n"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|scp
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_CLEAR_OVERRUN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore saved page */
name|XE_SELECT_PAGE
argument_list|(
name|psr
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts */
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine.  Called automatically if we queue a packet   * for transmission but don't get an interrupt within a specified timeout  * (usually 5 seconds).  When this happens we assume the worst and reset the  * card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"watchdog timeout: resetting card\n"
argument_list|)
expr_stmt|;
name|scp
operator|->
name|tx_timeouts
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|scp
operator|->
name|tx_queued
expr_stmt|;
name|xe_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_init
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change media selection.  */
end_comment

begin_function
specifier|static
name|int
name|xe_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"media_change\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*    * Some card/media combos aren't always possible -- filter those out here.    */
if|if
condition|(
operator|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_AUTO
operator|||
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|==
name|IFM_100_TX
operator|)
operator|&&
operator|!
name|scp
operator|->
name|phy_ok
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|xe_setmedia
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return current media selection.  */
end_comment

begin_function
specifier|static
name|void
name|xe_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|mrp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"media_status\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - This is clearly wrong.  Will fix once I have CE2 working */
name|mrp
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
name|mrp
operator|->
name|ifm_active
operator|=
operator|(
operator|(
expr|struct
name|xe_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
operator|)
operator|->
name|media
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Select active media.  */
end_comment

begin_function
specifier|static
name|void
name|xe_setmedia
parameter_list|(
name|void
modifier|*
name|xscp
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|scp
init|=
name|xscp
decl_stmt|;
name|u_int16_t
name|bmcr
decl_stmt|,
name|bmsr
decl_stmt|,
name|anar
decl_stmt|,
name|lpar
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"setmedia\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Cancel any pending timeout */
name|untimeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|scp
operator|->
name|chand
argument_list|)
expr_stmt|;
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Select media */
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
comment|/* Autoselect media */
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
comment|/*      * Autoselection is really awful.  It goes something like this:      *      * Wait until the transmitter goes idle (2sec timeout).      * Reset card      *   IF a 100Mbit PHY exists      *     Start NWAY autonegotiation (3.5sec timeout)      *     IF that succeeds      *       Select 100baseTX or 10baseT, whichever was detected      *     ELSE      *       Reset card      *       IF a 100Mbit PHY exists      *         Try to force a 100baseTX link (3sec timeout)      *         IF that succeeds      *           Select 100baseTX      *         ELSE      *           Disable the PHY      *         ENDIF      *       ENDIF      *     ENDIF      *   ENDIF      * IF nothing selected so far      *   IF a 100Mbit PHY exists      *     Select 10baseT      *   ELSE      *     Select 10baseT or 10base2, whichever is connected      *   ENDIF      * ENDIF      */
switch|switch
condition|(
name|scp
operator|->
name|autoneg_status
condition|)
block|{
case|case
name|XE_AUTONEG_NONE
case|:
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Waiting for idle transmitter\n"
operator|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_WAITING
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|XE_AUTONEG_WAITING
case|:
if|if
condition|(
name|scp
operator|->
name|tx_queued
operator|!=
literal|0
condition|)
block|{
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Starting autonegotiation\n"
operator|)
argument_list|)
expr_stmt|;
name|bmcr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|)
expr_stmt|;
name|bmcr
operator|&=
operator|~
operator|(
name|PHY_BMCR_AUTONEGENBL
operator|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|anar
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_ANAR
argument_list|)
expr_stmt|;
name|anar
operator|&=
operator|~
operator|(
name|PHY_ANAR_100BT4
operator||
name|PHY_ANAR_100BTXFULL
operator||
name|PHY_ANAR_10BTFULL
operator|)
expr_stmt|;
name|anar
operator||=
name|PHY_ANAR_100BTXHALF
operator||
name|PHY_ANAR_10BTHALF
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_ANAR
argument_list|,
name|anar
argument_list|)
expr_stmt|;
name|bmcr
operator||=
name|PHY_BMCR_AUTONEGENBL
operator||
name|PHY_BMCR_AUTONEGRSTR
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_STARTED
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|7
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
break|break;
case|case
name|XE_AUTONEG_STARTED
case|:
name|bmsr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
name|lpar
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsr
operator|&
operator|(
name|PHY_BMSR_AUTONEGCOMP
operator||
name|PHY_BMSR_LINKSTAT
operator|)
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Autonegotiation complete!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - Shouldn't have to do this, but (on my hub at least) the 	 * XXX - transmitter won't work after a successful autoneg.  So we see  	 * XXX - what the negotiation result was and force that mode.  I'm 	 * XXX - sure there is an easy fix for this. 	 */
if|if
condition|(
name|lpar
operator|&
name|PHY_LPAR_100BTXHALF
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * XXX - Bit of a hack going on in here. 	   * XXX - This is derived from Ken Hughes patch to the Linux driver 	   * XXX - to make it work with 10Mbit _autonegotiated_ links on CE3B 	   * XXX - cards.  What's a CE3B and how's it differ from a plain CE3? 	   * XXX - these are the things we need to find out. 	   */
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* BEGIN HACK */
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
comment|/* END HACK */
comment|/*XE_OUTB(XE_MSR, XE_INB(XE_MSR)& ~0x08);*/
comment|/* Disable PHY? */
comment|/*scp->autoneg_status = XE_AUTONEG_FAIL;*/
block|}
block|}
else|else
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Autonegotiation failed; trying 100baseTX\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_100TX
expr_stmt|;
name|scp
operator|->
name|chand
operator|=
name|timeout
argument_list|(
name|xe_setmedia
argument_list|,
name|scp
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XE_AUTONEG_100TX
case|:
operator|(
name|void
operator|)
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
name|bmsr
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmsr
operator|&
name|PHY_BMSR_LINKSTAT
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Got 100baseTX link!\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Autonegotiation failed; disabling PHY\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Disable PHY? */
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_FAIL
expr_stmt|;
block|}
break|break;
block|}
comment|/*      * If we got down here _and_ autoneg_status is XE_AUTONEG_FAIL, then      * either autonegotiation failed, or never got started to begin with.  In      * either case, select a suitable 10Mbit media and hope it works.  We      * don't need to reset the card again, since it will have been done      * already by the big switch above.      */
if|if
condition|(
name|scp
operator|->
name|autoneg_status
operator|==
name|XE_AUTONEG_FAIL
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Selecting 10baseX\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
name|IFM_10_T
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
else|else
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
literal|0x80
else|:
literal|0xc0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator|=
name|IFM_ETHER
operator||
operator|(
operator|(
name|XE_INB
argument_list|(
name|XE_ESR
argument_list|)
operator|&
name|XE_ESR_MEDIA_SELECT
operator|)
condition|?
name|IFM_10_T
else|:
name|IFM_10_2
operator|)
expr_stmt|;
name|scp
operator|->
name|autoneg_status
operator|=
name|XE_AUTONEG_NONE
expr_stmt|;
block|}
block|}
break|break;
comment|/*      * If a specific media has been requested, we just reset the card and      * select it (one small exception -- if 100baseTX is requested by there is       * no PHY, we fall back to 10baseT operation).      */
case|case
name|IFM_100_TX
case|:
comment|/* Force 100baseTX */
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Selecting 100baseTX\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_SPEEDSEL
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|IFM_10_T
case|:
comment|/* Force 10baseT */
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Selecting 10baseT\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|phy_ok
condition|)
block|{
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Disable PHY */
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
name|IFM_10_2
case|:
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Selecting 10base2\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|media
operator||=
name|IFM_10_2
expr_stmt|;
break|break;
block|}
comment|/*    * Finally, the LEDs are set to match whatever media was chosen and the    * transmitter is unblocked.     */
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"Setting LEDs\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|scp
operator|->
name|media
argument_list|)
condition|)
block|{
case|case
name|IFM_100_TX
case|:
case|case
name|IFM_10_T
case|:
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3b
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dingo
condition|)
name|XE_OUTB
argument_list|(
literal|0x0b
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* 100Mbit LED */
break|break;
case|case
name|IFM_10_2
case|:
name|XE_OUTB
argument_list|(
name|XE_LED
argument_list|,
literal|0x3a
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restart output? */
name|xe_enable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|xe_start
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hard reset (power cycle) the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_reset
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"reset\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Power down */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
comment|/* Power up again */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
name|XE_GPR1_POWER_DOWN
argument_list|)
expr_stmt|;
else|else
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
name|XE_GPR1_POWER_DOWN
operator||
name|XE_GPR1_AIC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  This is done by powering down the device, which I  * assume means just shutting down the transceiver and Ethernet logic.  This  * requires a _hard_ reset to recover from, as we need to power up again.  */
end_comment

begin_function
specifier|static
name|void
name|xe_stop
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"stop\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Shut off interrupts.    */
name|xe_disable_intr
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*    * Power down.    */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
comment|/*      * set GP1 and GP2 as outputs (bits 2& 3)      * set GP1 high to power on the ML6692 (bit 0)      * set GP2 low to power on the 10Mhz chip (bit 1)      */
name|XE_SELECT_PAGE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR0
argument_list|,
name|XE_GPR0_GP2_SELECT
operator||
name|XE_GPR0_GP1_SELECT
operator||
name|XE_GPR0_GP1_OUT
argument_list|)
expr_stmt|;
block|}
comment|/*    * ~IFF_DRV_RUNNING == interface down.    */
name|scp
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|scp
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable interrupts from the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_enable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"enable_intr\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
operator|!
name|scp
operator|->
name|dingo
condition|)
block|{
comment|/* This bit is just magic */
if|if
condition|(
operator|!
operator|(
name|XE_INB
argument_list|(
literal|0x10
argument_list|)
operator|&
literal|0x01
operator|)
condition|)
block|{
name|XE_OUTB
argument_list|(
literal|0x10
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* Unmask master int enable bit */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Disable interrupts from the card.  */
end_comment

begin_function
specifier|static
name|void
name|xe_disable_intr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"disable_intr\n"
operator|)
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
if|if
condition|(
name|scp
operator|->
name|modem
operator|&&
operator|!
name|scp
operator|->
name|dingo
condition|)
block|{
comment|/* More magic */
name|XE_OUTB
argument_list|(
literal|0x10
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Mask the master int enable bit */
block|}
block|}
end_function

begin_comment
comment|/*  * Set up multicast filter and promiscuous modes.  */
end_comment

begin_function
specifier|static
name|void
name|xe_set_multicast
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|maddr
decl_stmt|;
name|unsigned
name|count
decl_stmt|,
name|i
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"set_multicast\n"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|scp
operator|->
name|ifp
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
comment|/* Handle PROMISC flag */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator||
name|XE_SWC1_PROMISCUOUS
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator|&
operator|~
name|XE_SWC1_PROMISCUOUS
argument_list|)
expr_stmt|;
comment|/* Handle ALLMULTI flag */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator||
name|XE_SWC1_ALLMULTI
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator|&
operator|~
name|XE_SWC1_ALLMULTI
argument_list|)
expr_stmt|;
comment|/* Iterate over multicast address list */
name|count
operator|=
literal|0
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|maddr
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|maddr
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|10
condition|)
comment|/* First 9 use Individual Addresses for exact matching */
name|xe_set_addr
argument_list|(
name|scp
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|maddr
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
comment|/* Use hash filter on Mohawk and Dingo */
name|xe_mchash
argument_list|(
name|scp
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|maddr
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Nowhere else to put them on CE2 */
break|break;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"set_multicast: count = %u\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
comment|/* Now do some cleanup and enable multicast handling as needed */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* Disable all multicast handling */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator|&
operator|~
operator|(
name|XE_SWC1_IA_ENABLE
operator||
name|XE_SWC1_ALLMULTI
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x02
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
name|XE_MSR_HASH_TABLE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|count
operator|<
literal|10
condition|)
block|{
comment|/* Full in any unused Individual Addresses with our MAC address */
for|for
control|(
name|i
operator|=
name|count
operator|+
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|xe_set_addr
argument_list|(
name|scp
argument_list|,
name|IF_LLADDR
argument_list|(
name|scp
operator|->
name|ifp
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Enable Individual Address matching only */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
operator|(
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator|&
operator|~
name|XE_SWC1_ALLMULTI
operator|)
operator||
name|XE_SWC1_IA_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
name|XE_SELECT_PAGE
argument_list|(
literal|0x02
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
name|XE_MSR_HASH_TABLE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
block|{
comment|/* Check whether hash table is full */
name|XE_SELECT_PAGE
argument_list|(
literal|0x58
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x08
init|;
name|i
operator|<
literal|0x10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XE_INB
argument_list|(
name|i
argument_list|)
operator|!=
literal|0xff
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0x10
condition|)
block|{
comment|/* Hash table full - enable promiscuous multicast matching */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
operator|(
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator|&
operator|~
name|XE_SWC1_IA_ENABLE
operator|)
operator||
name|XE_SWC1_ALLMULTI
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x02
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator|&
operator|~
name|XE_MSR_HASH_TABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable hash table and Individual Address matching */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
operator|(
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator|&
operator|~
name|XE_SWC1_ALLMULTI
operator|)
operator||
name|XE_SWC1_IA_ENABLE
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x02
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_MSR
argument_list|,
name|XE_INB
argument_list|(
name|XE_MSR
argument_list|)
operator||
name|XE_MSR_HASH_TABLE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Enable promiscuous multicast matching */
name|XE_SELECT_PAGE
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_SWC1
argument_list|,
operator|(
name|XE_INB
argument_list|(
name|XE_SWC1
argument_list|)
operator|&
operator|~
name|XE_SWC1_IA_ENABLE
operator|)
operator||
name|XE_SWC1_ALLMULTI
argument_list|)
expr_stmt|;
block|}
block|}
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy the Ethernet multicast address in addr to the on-chip registers for  * Individual Address idx.  Assumes that addr is really a multicast address  * and that idx> 0 (slot 0 is always used for the card MAC address).  */
end_comment

begin_function
specifier|static
name|void
name|xe_set_addr
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int8_t
modifier|*
name|addr
parameter_list|,
name|unsigned
name|idx
parameter_list|)
block|{
name|u_int8_t
name|page
decl_stmt|,
name|reg
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/*    * Individual Addresses are stored in registers 8-F of pages 0x50-0x57.  IA1    * therefore starts at register 0xE on page 0x50.  The expressions below    * compute the starting page and register for any IA index> 0.    */
operator|--
name|idx
expr_stmt|;
name|page
operator|=
literal|0x50
operator|+
name|idx
operator|%
literal|4
operator|+
name|idx
operator|/
literal|4
operator|*
literal|3
expr_stmt|;
name|reg
operator|=
literal|0x0e
operator|-
literal|2
operator|*
operator|(
name|idx
operator|%
literal|4
operator|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"set_addr: idx = %u, page = 0x%02x, reg = 0x%02x\n"
operator|,
name|idx
operator|+
literal|1
operator|,
name|page
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
comment|/*    * Copy the IA bytes.  Note that the byte order is reversed for Mohawk and    * Dingo wrt. CE2 hardware.    */
name|XE_SELECT_PAGE
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|":%02x"
operator|,
name|addr
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"set_addr: %02x"
operator|,
name|addr
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|XE_OUTB
argument_list|(
name|reg
argument_list|,
name|addr
index|[
name|scp
operator|->
name|mohawk
condition|?
literal|5
operator|-
name|i
else|:
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|reg
operator|==
literal|0x10
condition|)
block|{
name|reg
operator|=
literal|0x08
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
operator|++
name|page
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the appropriate bit in the multicast hash table for the supplied  * Ethernet multicast address addr.  Assumes that addr is really a multicast  * address.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mchash
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|,
name|hash
decl_stmt|;
name|hash
operator|=
name|ether_crc32_le
argument_list|(
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&
literal|0x3F
expr_stmt|;
comment|/* Top 3 bits of hash give register - 8, bottom 3 give bit within register */
name|byte
operator|=
name|hash
operator|>>
literal|3
operator||
literal|0x08
expr_stmt|;
name|bit
operator|=
literal|0x01
operator|<<
operator|(
name|hash
operator|&
literal|0x07
operator|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"set_hash: hash = 0x%02x, byte = 0x%02x, bit = 0x%02x\n"
operator|,
name|hash
operator|,
name|byte
operator|,
name|bit
operator|)
argument_list|)
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|0x58
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|byte
argument_list|,
name|XE_INB
argument_list|(
name|byte
argument_list|)
operator||
name|bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an outgoing packet to the card using programmed I/O.  */
end_comment

begin_function
specifier|static
name|int
name|xe_pio_write_packet
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbp
parameter_list|)
block|{
name|unsigned
name|len
decl_stmt|,
name|pad
decl_stmt|;
name|unsigned
name|char
name|wantbyte
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
name|u_int8_t
name|savebyte
index|[
literal|2
index|]
decl_stmt|;
comment|/* Get total packet length */
if|if
condition|(
name|mbp
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|len
operator|=
name|mbp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|mbp2
init|=
name|mbp
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|mbp2
operator|!=
name|NULL
condition|;
name|len
operator|+=
name|mbp2
operator|->
name|m_len
operator|,
name|mbp2
operator|=
name|mbp2
operator|->
name|m_next
control|)
empty_stmt|;
block|}
name|DEVPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"pio_write_packet: len = %u\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
comment|/* Packets< minimum length may need to be padded out */
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|scp
operator|->
name|tx_min
condition|)
block|{
name|pad
operator|=
name|scp
operator|->
name|tx_min
operator|-
name|len
expr_stmt|;
name|len
operator|=
name|scp
operator|->
name|tx_min
expr_stmt|;
block|}
comment|/* Check transmit buffer space */
name|XE_SELECT_PAGE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_TRS
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Only effective on rev. 1 CE2 cards */
if|if
condition|(
operator|(
name|XE_INW
argument_list|(
name|XE_TSO
argument_list|)
operator|&
literal|0x7fff
operator|)
operator|<=
name|len
operator|+
literal|2
condition|)
return|return
literal|1
return|;
comment|/* Send packet length to card */
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*    * Write packet to card using PIO (code stolen from the ed driver)    */
name|wantbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mbp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|mbp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|mbp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantbyte
condition|)
block|{
comment|/* Finish the last word */
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
comment|/* Output contiguous words */
name|bus_space_write_multi_2
argument_list|(
name|scp
operator|->
name|bst
argument_list|,
name|scp
operator|->
name|bsh
argument_list|,
name|XE_EDP
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
comment|/* Save last byte, if necessary */
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|wantbyte
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mbp
operator|=
name|mbp
operator|->
name|m_next
expr_stmt|;
block|}
comment|/*    * Send last byte of odd-length packets    */
if|if
condition|(
name|wantbyte
condition|)
name|XE_OUTB
argument_list|(
name|XE_EDP
argument_list|,
name|savebyte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*    * Can just tell CE3 cards to send; short packets will be padded out with    * random cruft automatically.  For CE2, manually pad the packet with    * garbage; it will be sent when the required number or bytes have been    * delivered to the card.    */
if|if
condition|(
name|scp
operator|->
name|mohawk
condition|)
name|XE_OUTB
argument_list|(
name|XE_CR
argument_list|,
name|XE_CR_TX_PACKET
operator||
name|XE_CR_RESTART_TX
operator||
name|XE_CR_ENABLE_INTR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pad
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pad
operator|&
literal|0x01
condition|)
name|XE_OUTB
argument_list|(
name|XE_EDP
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|pad
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|pad
operator|>
literal|0
condition|)
block|{
name|XE_OUTW
argument_list|(
name|XE_EDP
argument_list|,
literal|0xdead
argument_list|)
expr_stmt|;
name|pad
operator|--
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  *                                                            *  *                  M I I  F U N C T I O N S                  *  *                                                            *  **************************************************************/
end_comment

begin_comment
comment|/*  * Alternative MII/PHY handling code adapted from the xl driver.  It doesn't  * seem to work any better than the xirc2_ps stuff, but it's cleaner code.  * XXX - this stuff shouldn't be here.  It should all be abstracted off to  * XXX - some kind of common MII-handling code, shared by all drivers.  But  * XXX - that's a whole other mission.  */
end_comment

begin_define
define|#
directive|define
name|XE_MII_SET
parameter_list|(
name|x
parameter_list|)
value|XE_OUTB(XE_GPR2, (XE_INB(XE_GPR2) | 0x04) | (x))
end_define

begin_define
define|#
directive|define
name|XE_MII_CLR
parameter_list|(
name|x
parameter_list|)
value|XE_OUTB(XE_GPR2, (XE_INB(XE_GPR2) | 0x04)& ~(x))
end_define

begin_comment
comment|/*  * Sync the PHYs by setting data bit and strobing the clock 32 times.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_sync
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
operator||
name|XE_MII_WRD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look for a MII-compliant PHY.  If we find one, reset it.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_init
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|u_int16_t
name|status
decl_stmt|;
name|status
operator|=
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x7800
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"no PHY found, %0x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|scp
operator|->
name|dev
operator|,
literal|"PHY OK!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the PHY */
name|xe_phy_writereg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|,
name|PHY_BMCR_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
while|while
condition|(
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|PHY_BMCR
argument_list|)
operator|&
name|PHY_BMCR_RESET
condition|)
empty_stmt|;
name|XE_MII_DUMP
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clock a series of bits through the MII.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_send
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int32_t
name|bits
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|0x1
operator|<<
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|)
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|bits
operator|&
name|i
condition|)
block|{
name|XE_MII_SET
argument_list|(
name|XE_MII_WRD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_WRD
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read an PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ack
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Set up frame for RX.    */
name|frame
operator|->
name|mii_stdelim
operator|=
name|XE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|XE_MII_READOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|mii_data
operator|=
literal|0
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XE_OUTB
argument_list|(
name|XE_GPR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Turn on data xmit.    */
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|xe_mii_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/*	    * Send command/address info.    */
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Idle bit */
name|XE_MII_CLR
argument_list|(
operator|(
name|XE_MII_CLK
operator||
name|XE_MII_WRD
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn off xmit. */
name|XE_MII_CLR
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
comment|/* Check for ack */
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ack
operator|=
name|XE_INB
argument_list|(
name|XE_GPR2
argument_list|)
operator|&
name|XE_MII_RDD
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*    * Now try reading data bits. If the ack failed, we still    * need to clock through 16 cycles to keep the PHY(s) in sync.    */
if|if
condition|(
name|ack
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0x8000
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ack
condition|)
block|{
if|if
condition|(
name|XE_INB
argument_list|(
name|XE_GPR2
argument_list|)
operator|&
name|XE_MII_RDD
condition|)
name|frame
operator|->
name|mii_data
operator||=
name|i
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fail
label|:
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|xe_mii_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|struct
name|xe_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*    * Set up frame for TX.    */
name|frame
operator|->
name|mii_stdelim
operator|=
name|XE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|XE_MII_WRITEOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
name|XE_MII_TURNAROUND
expr_stmt|;
name|XE_SELECT_PAGE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*		    * Turn on data output.    */
name|XE_MII_SET
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|xe_mii_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_turnaround
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xe_mii_send
argument_list|(
name|scp
argument_list|,
name|frame
operator|->
name|mii_data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Idle bit. */
name|XE_MII_SET
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XE_MII_CLR
argument_list|(
name|XE_MII_CLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*    * Turn off xmit.    */
name|XE_MII_CLR
argument_list|(
name|XE_MII_DIR
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a register from the PHY.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|xe_phy_readreg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
block|{
name|struct
name|xe_mii_frame
name|frame
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|xe_mii_readreg
argument_list|(
name|scp
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|frame
operator|.
name|mii_data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a PHY register.  */
end_comment

begin_function
specifier|static
name|void
name|xe_phy_writereg
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|struct
name|xe_mii_frame
name|frame
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
literal|0
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|frame
operator|.
name|mii_data
operator|=
name|data
expr_stmt|;
name|xe_mii_writereg
argument_list|(
name|scp
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * A bit of debugging code.  */
end_comment

begin_function
specifier|static
name|void
name|xe_mii_dump
parameter_list|(
name|struct
name|xe_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"MII registers: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d:%04x"
argument_list|,
name|i
argument_list|,
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d:%04x"
argument_list|,
name|i
argument_list|,
name|xe_phy_readreg
argument_list|(
name|scp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void xe_reg_dump(struct xe_softc *scp) {   int page, i, s;    s = splimp();    device_printf(scp->dev, "Common registers: ");   for (i = 0; i< 8; i++) {     printf(" %2.2x", XE_INB(i));   }   printf("\n");    for (page = 0; page<= 8; page++) {     device_printf(scp->dev, "Register page %2.2x: ", page);     XE_SELECT_PAGE(page);     for (i = 8; i< 16; i++) {       printf(" %2.2x", XE_INB(i));     }     printf("\n");   }    for (page = 0x10; page< 0x5f; page++) {     if ((page>= 0x11&& page<= 0x3f) || 	(page == 0x41) || 	(page>= 0x43&& page<= 0x4f) || 	(page>= 0x59))       continue;     device_printf(scp->dev, "Register page %2.2x: ", page);     XE_SELECT_PAGE(page);     for (i = 8; i< 16; i++) {       printf(" %2.2x", XE_INB(i));     }     printf("\n");   }    (void)splx(s); }
endif|#
directive|endif
end_endif

begin_function
name|int
name|xe_activate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|start
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"activate\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|modem
condition|)
block|{
name|sc
operator|->
name|port_rid
operator|=
literal|0
expr_stmt|;
comment|/* 0 is managed by pccard */
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|16
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|dingo
condition|)
block|{
comment|/* 		 * Find a 16 byte aligned ioport for the card. 		 */
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"Finding an aligned port for RealPort\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_rid
operator|=
literal|1
expr_stmt|;
comment|/* 0 is managed by pccard */
name|start
operator|=
literal|0x100
expr_stmt|;
do|do
block|{
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
name|start
argument_list|,
literal|0x3ff
argument_list|,
literal|16
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
operator|==
literal|0
condition|)
break|break;
comment|/* we failed */
if|if
condition|(
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* good */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"RealPort port 0x%0lx, size 0x%0lx\n"
operator|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
operator|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|ce2
condition|)
block|{
comment|/* 	     * Find contiguous I/O port for the Ethernet function on CEM2 and 	     * CEM3 cards.  We allocate window 0 wherever pccard has decided 	     * it should be, then find an available window adjacent to it for 	     * the second function.  Not sure that both windows are actually 	     * needed. 	     */
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"Finding I/O port for CEM2/CEM3\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ce2_port_rid
operator|=
literal|0
expr_stmt|;
comment|/* 0 is managed by pccard */
name|sc
operator|->
name|ce2_port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|ce2_port_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|8
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|ce2_port_res
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"Cannot allocate I/O port for modem\n"
operator|)
argument_list|)
expr_stmt|;
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|port_rid
operator|=
literal|1
expr_stmt|;
name|start
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ce2_port_rid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|start
operator|+=
operator|(
name|i
operator|==
literal|0
condition|?
literal|8
else|:
operator|-
literal|24
operator|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
name|start
argument_list|,
name|start
operator|+
literal|15
argument_list|,
literal|16
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
operator|==
literal|0
condition|)
continue|continue;
comment|/* Failed, try again if possible */
if|if
condition|(
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
operator|==
name|start
condition|)
break|break;
comment|/* Success! */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
block|}
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"CEM2/CEM3 port 0x%0lx, size 0x%0lx\n"
operator|,
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
operator|,
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|port_res
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"Cannot allocate ioport\n"
operator|)
argument_list|)
expr_stmt|;
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
name|DEVPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|dev
operator|,
literal|"Cannot allocate irq\n"
operator|)
argument_list|)
expr_stmt|;
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|xe_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xe_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xe_deactivate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DEVPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|dev
operator|,
literal|"deactivate\n"
operator|)
argument_list|)
expr_stmt|;
name|xe_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ce2_port_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|ce2_port_rid
argument_list|,
name|sc
operator|->
name|ce2_port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ce2_port_res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

end_unit

