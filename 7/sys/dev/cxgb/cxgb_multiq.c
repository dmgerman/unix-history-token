begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2008, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.  2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_define
define|#
directive|define
name|DEBUG_BUFRING
end_define

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<sys/mvec.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mvec.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|txq_fills
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysctl_oid_list
name|sysctl__hw_cxgb_children
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cxgb_pcpu_tx_coalesce
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.tx_coalesce"
argument_list|,
operator|&
name|cxgb_pcpu_tx_coalesce
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_coalesce
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cxgb_pcpu_tx_coalesce
argument_list|,
literal|0
argument_list|,
literal|"coalesce small packets into a single work request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|sleep_ticks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.sleep_ticks"
argument_list|,
operator|&
name|sleep_ticks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|sleep_ticks
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sleep_ticks
argument_list|,
literal|0
argument_list|,
literal|"ticks to sleep between checking pcpu queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cxgb_txq_buf_ring_size
init|=
name|TX_ETH_Q_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.txq_mr_size"
argument_list|,
operator|&
name|cxgb_txq_buf_ring_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_mr_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cxgb_txq_buf_ring_size
argument_list|,
literal|0
argument_list|,
literal|"size of per-queue mbuf ring"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
specifier|inline
name|int32_t
name|cxgb_pcpu_calc_cookie
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|immpkt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_pcpu_start_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
end_ifdef

begin_function_decl
specifier|static
name|int
name|cxgb_pcpu_cookie_to_qidx
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|uint32_t
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cxgb_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|uint32_t
name|txmax
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|cxgb_pcpu_enqueue_packet_
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|IFNET_MULTIQUEUE
name|panic
argument_list|(
literal|"not expecting enqueue without multiqueue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_DATA
argument_list|,
operator|(
literal|"bad mbuf type %d"
operator|,
name|m
operator|->
name|m_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|err
operator|=
name|buf_ring_enqueue
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|txq
operator|->
name|txq_drops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|flags
operator|&
name|TXQ_TRANSMITTING
operator|)
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxgb_pcpu_enqueue_packet
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|qidx
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|int32_t
name|calc_cookie
decl_stmt|;
name|calc_cookie
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rss_hash
expr_stmt|;
name|qidx
operator|=
name|cxgb_pcpu_cookie_to_qidx
argument_list|(
name|pi
argument_list|,
name|calc_cookie
argument_list|)
expr_stmt|;
else|#
directive|else
name|qidx
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|qidx
index|]
expr_stmt|;
name|err
operator|=
name|cxgb_pcpu_enqueue_packet_
argument_list|(
name|qs
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_dequeue_packet
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_vec
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|count
decl_stmt|,
name|size
decl_stmt|,
name|coalesced
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
ifndef|#
directive|ifndef
name|IFNET_MULTIQUEUE
name|struct
name|port_info
modifier|*
name|pi
init|=
name|txq
operator|->
name|port
decl_stmt|;
if|if
condition|(
name|txq
operator|->
name|immpkt
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"immediate packet set"
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|pi
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m_vec
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|coalesced
operator|=
name|count
operator|=
name|size
operator|=
literal|0
expr_stmt|;
name|qs
operator|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|txq
operator|->
name|immpkt
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"immediate packet\n"
argument_list|)
expr_stmt|;
name|m_vec
index|[
literal|0
index|]
operator|=
name|txq
operator|->
name|immpkt
expr_stmt|;
name|txq
operator|->
name|immpkt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|=
name|qs
operator|->
name|port
operator|->
name|adapter
expr_stmt|;
name|m
operator|=
name|buf_ring_dequeue
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count
operator|=
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_DATA
argument_list|,
operator|(
literal|"m=%p is bad mbuf type %d from ring cons=%d prod=%d"
operator|,
name|m
operator|,
name|m
operator|->
name|m_type
operator|,
name|txq
operator|->
name|txq_mr
operator|.
name|br_cons
operator|,
name|txq
operator|->
name|txq_mr
operator|.
name|br_prod
operator|)
argument_list|)
expr_stmt|;
name|m_vec
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|>
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|TX_WR_SIZE_MAX
operator|||
name|m
operator|->
name|m_next
operator|!=
name|NULL
operator|||
operator|(
name|cxgb_pcpu_tx_coalesce
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|count
operator|)
return|;
block|}
name|size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
for|for
control|(
name|m
operator|=
name|buf_ring_peek
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|buf_ring_peek
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|>
literal|0
operator|||
name|size
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|TX_WR_SIZE_MAX
operator|||
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
break|break;
name|buf_ring_dequeue
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
expr_stmt|;
name|size
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_vec
index|[
name|count
operator|++
index|]
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|TX_WR_COUNT_MAX
condition|)
break|break;
name|coalesced
operator|++
expr_stmt|;
block|}
name|txq
operator|->
name|txq_coalesced
operator|+=
name|coalesced
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|cxgb_pcpu_get_cookie
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|lip
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|rip
parameter_list|,
name|uint16_t
name|rport
parameter_list|,
name|int
name|ipv6
parameter_list|)
block|{
name|uint32_t
name|base
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|36
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int32_t
name|cookie
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/*  	 * Can definitely bypass bcopy XXX 	 */
if|if
condition|(
name|ipv6
operator|==
literal|0
condition|)
block|{
name|count
operator|=
literal|12
expr_stmt|;
name|bcopy
argument_list|(
name|rip
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lip
argument_list|,
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rport
argument_list|,
operator|&
name|buf
index|[
literal|8
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lport
argument_list|,
operator|&
name|buf
index|[
literal|10
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
literal|36
expr_stmt|;
name|bcopy
argument_list|(
name|rip
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lip
argument_list|,
operator|&
name|buf
index|[
literal|16
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rport
argument_list|,
operator|&
name|buf
index|[
literal|32
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lport
argument_list|,
operator|&
name|buf
index|[
literal|34
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|base
operator|=
literal|0xffffffff
expr_stmt|;
name|base
operator|=
name|update_crc32
argument_list|(
name|base
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|base
operator|=
name|sctp_csum_finalize
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* 	 * Indirection table is 128 bits 	 * -> cookie indexes into indirection table which maps connection to queue 	 * -> RSS map maps queue to CPU 	 */
name|cookie
operator|=
operator|(
name|base
operator|&
operator|(
name|RSS_TABLE_SIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
name|cookie
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|cxgb_pcpu_calc_cookie
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|immpkt
parameter_list|)
block|{
name|struct
name|in6_addr
name|lip
decl_stmt|,
name|rip
decl_stmt|;
name|uint16_t
name|lport
decl_stmt|,
name|rport
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int32_t
name|cookie
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|uint8_t
modifier|*
name|next
decl_stmt|,
name|proto
decl_stmt|;
name|int
name|etype
decl_stmt|;
if|if
condition|(
name|immpkt
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
literal|1
comment|/* 	 * XXX perf test 	 */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|rport
operator|=
name|lport
operator|=
literal|0
expr_stmt|;
name|cookie
operator|=
operator|-
literal|1
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|immpkt
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
name|next
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
operator|&
name|lip
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
operator|&
name|rip
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
name|next
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
operator|&
name|lip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
operator|&
name|rip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_HOPOPTS
condition|)
block|{
name|struct
name|ip6_hbh
modifier|*
name|hbh
decl_stmt|;
name|hbh
operator|=
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
operator|(
name|ip6
operator|+
literal|1
operator|)
expr_stmt|;
name|proto
operator|=
name|hbh
operator|->
name|ip6h_nxt
expr_stmt|;
block|}
else|else
name|proto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
default|default:
comment|/* 		 * Default to queue zero 		 */
name|proto
operator|=
name|cookie
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|proto
condition|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|next
expr_stmt|;
name|lport
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|rport
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|next
expr_stmt|;
name|lport
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|rport
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
name|next
expr_stmt|;
name|lport
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|rport
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
break|break;
default|default:
comment|/* nothing to do */
break|break;
block|}
block|}
if|if
condition|(
name|cookie
condition|)
name|cookie
operator|=
name|cxgb_pcpu_get_cookie
argument_list|(
name|ifp
argument_list|,
operator|&
name|lip
argument_list|,
name|lport
argument_list|,
operator|&
name|rip
argument_list|,
name|rport
argument_list|,
operator|(
name|etype
operator|==
name|ETHERTYPE_IPV6
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cookie
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_pcpu_free
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|txq
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|t3_free_tx_desc_all
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_pcpu_reclaim_tx
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|int
name|reclaimable
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_ETH
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|KASSERT
argument_list|(
name|qs
operator|->
name|qs_cpuid
operator|==
name|curcpu
argument_list|,
operator|(
literal|"cpu qset mismatch cpuid=%d curcpu=%d"
operator|,
name|qs
operator|->
name|qs_cpuid
operator|,
name|curcpu
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|reclaimable
operator|=
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaimable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t3_free_tx_desc
argument_list|(
name|txq
argument_list|,
name|reclaimable
argument_list|)
expr_stmt|;
name|txq
operator|->
name|cleaned
operator|+=
name|reclaimable
expr_stmt|;
name|txq
operator|->
name|in_use
operator|-=
name|reclaimable
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
condition|)
block|{
name|qs
operator|->
name|port
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|reclaimable
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_pcpu_start_
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|immpkt
parameter_list|,
name|int
name|tx_flush
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|initerr
decl_stmt|,
name|flush
decl_stmt|,
name|reclaimed
decl_stmt|,
name|stopped
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|adapter_t
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|max_desc
decl_stmt|;
name|pi
operator|=
name|qs
operator|->
name|port
expr_stmt|;
name|initerr
operator|=
name|err
operator|=
name|i
operator|=
name|reclaimed
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
name|pi
operator|->
name|link_config
operator|.
name|link_ok
condition|)
name|initerr
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
name|initerr
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
name|initerr
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pi
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
name|initerr
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
name|immpkt
condition|)
block|{
if|if
condition|(
operator|!
name|buf_ring_empty
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
condition|)
name|initerr
operator|=
name|cxgb_pcpu_enqueue_packet_
argument_list|(
name|qs
argument_list|,
name|immpkt
argument_list|)
expr_stmt|;
else|else
name|txq
operator|->
name|immpkt
operator|=
name|immpkt
expr_stmt|;
name|immpkt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|initerr
operator|&&
name|initerr
operator|!=
name|ENOBUFS
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cxgb link down\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|immpkt
condition|)
name|m_freem
argument_list|(
name|immpkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|initerr
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|tx_flush
operator|&&
operator|(
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|>
operator|(
name|TX_ETH_Q_SIZE
operator|>>
literal|1
operator|)
operator|)
condition|)
block|{
name|int
name|reclaimed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
block|{
name|device_printf
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
operator|->
name|dev
argument_list|,
literal|"cpuid=%d curcpu=%d reclaimable=%d txq=%p txq->cidx=%d txq->pidx=%d "
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|,
name|curcpu
argument_list|,
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
argument_list|,
name|txq
argument_list|,
name|txq
operator|->
name|cidx
argument_list|,
name|txq
operator|->
name|pidx
argument_list|)
expr_stmt|;
block|}
name|reclaimed
operator|=
name|cxgb_pcpu_reclaim_tx
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"reclaimed=%d\n"
argument_list|,
name|reclaimed
argument_list|)
expr_stmt|;
block|}
name|stopped
operator|=
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
name|flush
operator|=
operator|(
operator|(
operator|(
operator|!
name|buf_ring_empty
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
operator|||
operator|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|pi
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|stopped
operator|)
operator|||
name|txq
operator|->
name|immpkt
operator|)
expr_stmt|;
name|max_desc
operator|=
name|tx_flush
condition|?
name|TX_ETH_Q_SIZE
else|:
name|TX_START_MAX_DESC
expr_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|DPRINTF
argument_list|(
literal|"stopped=%d flush=%d max_desc=%d\n"
argument_list|,
name|stopped
argument_list|,
name|flush
argument_list|,
name|max_desc
argument_list|)
expr_stmt|;
name|err
operator|=
name|flush
condition|?
name|cxgb_tx
argument_list|(
name|qs
argument_list|,
name|max_desc
argument_list|)
else|:
name|ENOSPC
expr_stmt|;
if|if
condition|(
operator|(
name|tx_flush
operator|&&
name|flush
operator|&&
name|err
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|buf_ring_empty
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
operator|||
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|pi
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
operator|)
condition|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MIN_TIMESHARE
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|50
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|device_printf
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
operator|->
name|dev
argument_list|,
literal|"exceeded max enqueue tries\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
goto|goto
name|retry
goto|;
block|}
name|err
operator|=
operator|(
name|initerr
operator|!=
literal|0
operator|)
condition|?
name|initerr
else|:
name|err
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxgb_pcpu_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|immpkt
parameter_list|)
block|{
name|uint32_t
name|cookie
decl_stmt|;
name|int
name|err
decl_stmt|,
name|qidx
decl_stmt|,
name|locked
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|NULL
comment|/* gcc is dumb */
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|pi
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|qs
operator|=
name|NULL
expr_stmt|;
name|qidx
operator|=
name|resid
operator|=
name|err
operator|=
name|cookie
operator|=
name|locked
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
if|if
condition|(
name|immpkt
operator|&&
operator|(
name|immpkt
operator|->
name|m_pkthdr
operator|.
name|rss_hash
operator|!=
literal|0
operator|)
condition|)
block|{
name|cookie
operator|=
name|immpkt
operator|->
name|m_pkthdr
operator|.
name|rss_hash
expr_stmt|;
name|qidx
operator|=
name|cxgb_pcpu_cookie_to_qidx
argument_list|(
name|pi
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"hash=0x%x qidx=%d cpu=%d\n"
argument_list|,
name|immpkt
operator|->
name|m_pkthdr
operator|.
name|rss_hash
argument_list|,
name|qidx
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|qidx
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|tunq_coalesce
operator|==
literal|0
operator|)
operator|||
operator|(
name|buf_ring_count
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
operator|>=
name|TX_WR_COUNT_MAX
operator|)
operator|||
operator|(
name|cxgb_pcpu_tx_coalesce
operator|==
literal|0
operator|)
operator|)
operator|&&
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"doing immediate transmit\n"
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flags
operator||=
name|TXQ_TRANSMITTING
expr_stmt|;
name|err
operator|=
name|cxgb_pcpu_start_
argument_list|(
name|qs
argument_list|,
name|immpkt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flags
operator|&=
operator|~
name|TXQ_TRANSMITTING
expr_stmt|;
name|resid
operator|=
operator|(
name|buf_ring_count
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
operator|>
literal|64
operator|)
operator|||
operator|(
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|>
literal|64
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|immpkt
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"deferred coalesce=%jx ring_count=%d mtx_owned=%d\n"
argument_list|,
name|sc
operator|->
name|tunq_coalesce
argument_list|,
name|buf_ring_count
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
argument_list|,
name|mtx_owned
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|cxgb_pcpu_enqueue_packet_
argument_list|(
name|qs
argument_list|,
name|immpkt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|&&
operator|(
name|txq
operator|->
name|flags
operator|&
name|TXQ_TRANSMITTING
operator|)
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|err
operator|==
name|ENOSPC
operator|)
condition|?
literal|0
else|:
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxgb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|link_config
operator|.
name|link_ok
condition|)
return|return;
if|if
condition|(
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
return|return;
name|cxgb_pcpu_start
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_pcpu_start_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|arg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|int
name|idleticks
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
endif|#
directive|endif
name|td
operator|=
name|curthread
expr_stmt|;
name|sleep_ticks
operator|=
name|max
argument_list|(
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_flags
operator||=
name|QS_RUNNING
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|td
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|qs
operator|->
name|qs_cpuid
operator|*
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"bound to %d running on %d\n"
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
break|break;
if|if
condition|(
operator|(
name|qs
operator|->
name|port
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|idleticks
operator|=
name|hz
expr_stmt|;
if|if
condition|(
operator|!
name|buf_ring_empty
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
operator|||
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|txq
operator|->
name|sendq
argument_list|)
condition|)
name|cxgb_pcpu_free
argument_list|(
name|qs
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|idleticks
operator|=
name|sleep_ticks
expr_stmt|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
condition|)
block|{
name|txq
operator|->
name|flags
operator||=
name|TXQ_TRANSMITTING
expr_stmt|;
name|err
operator|=
name|cxgb_pcpu_start_
argument_list|(
name|qs
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flags
operator|&=
operator|~
name|TXQ_TRANSMITTING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|EINPROGRESS
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
argument_list|)
condition|)
block|{
name|process_responses
argument_list|(
name|sc
argument_list|,
name|qs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|refill_fl_service
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|refill_fl_service
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|next_holdoff
argument_list|)
operator||
name|V_NEWINDEX
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|cidx
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|!
name|buf_ring_empty
argument_list|(
operator|&
name|txq
operator|->
name|txq_mr
argument_list|)
operator|)
operator|&&
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"head=%p cons=%d prod=%d\n"
argument_list|,
name|txq
operator|->
name|sendq
operator|.
name|head
argument_list|,
name|txq
operator|->
name|txq_mr
operator|.
name|br_cons
argument_list|,
name|txq
operator|->
name|txq_mr
operator|.
name|br_prod
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|done
label|:
name|tsleep
argument_list|(
name|qs
argument_list|,
literal|1
argument_list|,
literal|"cxgbidle"
argument_list|,
name|idleticks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
operator|->
name|dev
argument_list|,
literal|"exiting thread for cpu%d\n"
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|)
expr_stmt|;
name|cxgb_pcpu_free
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|t3_free_qset
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
argument_list|,
name|qs
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_flags
operator|&=
operator|~
name|QS_RUNNING
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
end_ifdef

begin_function
specifier|static
name|int
name|cxgb_pcpu_cookie_to_qidx
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|uint32_t
name|cookie
parameter_list|)
block|{
name|int
name|qidx
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
comment|/* 	 * Will probably need to be changed for 4-port XXX 	 */
name|tmp
operator|=
name|pi
operator|->
name|tx_chan
condition|?
name|cookie
else|:
name|cookie
operator|&
operator|(
operator|(
name|RSS_TABLE_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|" tmp=%d "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|qidx
operator|=
operator|(
name|tmp
operator|&
operator|(
name|pi
operator|->
name|nqsets
operator|-
literal|1
operator|)
operator|)
operator|+
name|pi
operator|->
name|first_qset
expr_stmt|;
return|return
operator|(
name|qidx
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|cxgb_pcpu_startup_threads
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nqsets
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|nqsets
operator|=
name|pi
operator|->
name|nqsets
expr_stmt|;
else|#
directive|else
name|nqsets
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nqsets
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
operator|+
name|j
index|]
expr_stmt|;
name|qs
operator|->
name|port
operator|=
name|pi
expr_stmt|;
name|qs
operator|->
name|qs_cpuid
operator|=
operator|(
operator|(
name|pi
operator|->
name|first_qset
operator|+
name|j
operator|)
operator|%
name|mp_ncpus
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"starting thread for %d\n"
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|)
expr_stmt|;
name|kthread_create
argument_list|(
name|cxgb_pcpu_start_proc
argument_list|,
name|qs
argument_list|,
operator|&
name|p
argument_list|,
name|RFNOWAIT
argument_list|,
literal|0
argument_list|,
literal|"cxgbsp"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cxgb_pcpu_shutdown_threads
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nqsets
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|int
name|first
init|=
name|pi
operator|->
name|first_qset
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|nqsets
operator|=
name|pi
operator|->
name|nqsets
expr_stmt|;
else|#
directive|else
name|nqsets
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nqsets
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|first
operator|+
name|j
index|]
decl_stmt|;
name|qs
operator|->
name|qs_flags
operator||=
name|QS_EXITING
expr_stmt|;
name|wakeup
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
argument_list|,
name|PRI_MIN_TIMESHARE
argument_list|,
literal|"cxgb unload 0"
argument_list|,
name|hz
operator|>>
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_RUNNING
condition|)
block|{
name|qs
operator|->
name|qs_flags
operator||=
name|QS_EXITING
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"qset thread %d still running - sleeping\n"
argument_list|,
name|first
operator|+
name|j
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
argument_list|,
name|PRI_MIN_TIMESHARE
argument_list|,
literal|"cxgb unload 1"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|check_pkt_coalesce
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|sc
operator|=
name|qs
operator|->
name|port
operator|->
name|adapter
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|<
operator|(
name|txq
operator|->
name|size
operator|-
operator|(
name|txq
operator|->
name|size
operator|>>
literal|2
operator|)
operator|)
operator|)
condition|)
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|>
operator|(
name|txq
operator|->
name|size
operator|-
operator|(
name|txq
operator|->
name|size
operator|>>
literal|2
operator|)
operator|)
operator|)
condition|)
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|uint32_t
name|txmax
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|qs
operator|->
name|port
operator|->
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|in_use_init
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_vec
index|[
name|TX_WR_COUNT_MAX
index|]
decl_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|ifp
operator|=
name|qs
operator|->
name|port
operator|->
name|ifp
expr_stmt|;
name|in_use_init
operator|=
name|txq
operator|->
name|in_use
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_WR_COUNT_MAX
condition|;
name|i
operator|++
control|)
name|m_vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txq
operator|->
name|in_use
operator|-
name|in_use_init
operator|<
name|txmax
operator|)
operator|&&
operator|(
name|txq
operator|->
name|size
operator|>
name|txq
operator|->
name|in_use
operator|+
name|TX_MAX_DESC
operator|)
condition|)
block|{
name|check_pkt_coalesce
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|count
operator|=
name|cxgb_dequeue_packet
argument_list|(
name|txq
argument_list|,
name|m_vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|t3_encap
argument_list|(
name|qs
argument_list|,
name|m_vec
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|txq
operator|->
name|txq_enqueued
operator|+=
name|count
expr_stmt|;
name|m_vec
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* !MULTIQ */
block|if (__predict_false(err)) { 		if (err == ENOMEM) { 			ifp->if_drv_flags |= IFF_DRV_OACTIVE; 			IFQ_LOCK(&ifp->if_snd); 			IFQ_DRV_PREPEND(&ifp->if_snd, m_vec[0]); 			IFQ_UNLOCK(&ifp->if_snd); 		} 	} 	else if ((err == 0)&&  (txq->size<= txq->in_use + TX_MAX_DESC)&& 	    (ifp->if_drv_flags& IFF_DRV_OACTIVE) == 0) { 		setbit(&qs->txq_stopped, TXQ_ETH); 		ifp->if_drv_flags |= IFF_DRV_OACTIVE; 		txq_fills++; 		err = ENOSPC; 	}
else|#
directive|else
if|if
condition|(
operator|(
name|err
operator|==
literal|0
operator|)
operator|&&
operator|(
name|txq
operator|->
name|size
operator|<=
name|txq
operator|->
name|in_use
operator|+
name|TX_MAX_DESC
operator|)
condition|)
block|{
name|err
operator|=
name|ENOSPC
expr_stmt|;
name|txq_fills
operator|++
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOMEM
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * Sub-optimal :-/ 		 */
name|printf
argument_list|(
literal|"ENOMEM!!!"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|m_freem
argument_list|(
name|m_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

