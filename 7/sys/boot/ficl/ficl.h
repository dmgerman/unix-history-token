begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** f i c l . h ** Forth Inspired Command Language ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 ** Dedicated to RHS, in loving memory ** $Id: ficl.h,v 1.18 2001/12/05 07:21:34 jsadler Exp $ *******************************************************************/
end_comment

begin_comment
comment|/* ** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu) ** All rights reserved. ** ** Get the latest Ficl release at http://ficl.sourceforge.net ** ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release, please ** contact me by email at the address above. ** ** L I C E N S E  and  D I S C L A I M E R **  ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FICL_H__
argument_list|)
end_if

begin_define
define|#
directive|define
name|__FICL_H__
end_define

begin_comment
comment|/* ** Ficl (Forth-inspired command language) is an ANS Forth ** interpreter written in C. Unlike traditional Forths, this ** interpreter is designed to be embedded into other systems ** as a command/macro/development prototype language.  ** ** Where Forths usually view themselves as the center of the system ** and expect the rest of the system to be coded in Forth, Ficl ** acts as a component of the system. It is easy to export  ** code written in C or ASM to Ficl in the style of TCL, or to invoke ** Ficl code from a compiled module. This allows you to do incremental ** development in a way that combines the best features of threaded  ** languages (rapid development, quick code/test/debug cycle, ** reasonably fast) with the best features of C (everyone knows it, ** easier to support large blocks of code, efficient, type checking). ** ** Ficl provides facilities for interoperating ** with programs written in C: C functions can be exported to Ficl, ** and Ficl commands can be executed via a C calling interface. The ** interpreter is re-entrant, so it can be used in multiple instances ** in a multitasking system. Unlike Forth, Ficl's outer interpreter ** expects a text block as input, and returns to the caller after each ** text block, so the "data pump" is somewhere in external code. This ** is more like TCL than Forth, which usually expcets to be at the center ** of the system, requesting input at its convenience. Each Ficl virtual  ** machine can be bound to a different I/O channel, and is independent ** of all others in in the same address space except that all virtual ** machines share a common dictionary (a sort or open symbol table that ** defines all of the elements of the language). ** ** Code is written in ANSI C for portability.  ** ** Summary of Ficl features and constraints: ** - Standard: Implements the ANSI Forth CORE word set and part  **   of the CORE EXT word-set, SEARCH and SEARCH EXT, TOOLS and **   TOOLS EXT, LOCAL and LOCAL ext and various extras. ** - Extensible: you can export code written in Forth, C,  **   or asm in a straightforward way. Ficl provides open **   facilities for extending the language in an application **   specific way. You can even add new control structures! ** - Ficl and C can interact in two ways: Ficl can encapsulate **   C code, or C code can invoke Ficl code. ** - Thread-safe, re-entrant: The shared system dictionary  **   uses a locking mechanism that you can either supply **   or stub out to provide exclusive access. Each Ficl **   virtual machine has an otherwise complete state, and **   each can be bound to a separate I/O channel (or none at all). ** - Simple encapsulation into existing systems: a basic implementation **   requires three function calls (see the example program in testmain.c). ** - ROMable: Ficl is designed to work in RAM-based and ROM code / RAM data **   environments. It does require somewhat more memory than a pure **   ROM implementation because it builds its system dictionary in  **   RAM at startup time. ** - Written an ANSI C to be as simple as I can make it to understand, **   support, debug, and port. Compiles without complaint at /Az /W4  **   (require ANSI C, max warnings) under Microsoft VC++ 5. ** - Does full 32 bit math (but you need to implement **   two mixed precision math primitives (see sysdep.c)) ** - Indirect threaded interpreter is not the fastest kind of **   Forth there is (see pForth 68K for a really fast subroutine **   threaded interpreter), but it's the cleanest match to a **   pure C implementation. ** ** P O R T I N G   F i c l ** ** To install Ficl on your target system, you need an ANSI C compiler ** and its runtime library. Inspect the system dependent macros and ** functions in sysdep.h and sysdep.c and edit them to suit your ** system. For example, INT16 is a short on some compilers and an ** int on others. Check the default CELL alignment controlled by ** FICL_ALIGN. If necessary, add new definitions of ficlMalloc, ficlFree, ** ficlLockDictionary, and ficlTextOut to work with your operating system. ** Finally, use testmain.c as a guide to installing the Ficl system and  ** one or more virtual machines into your code. You do not need to include ** testmain.c in your build. ** ** T o   D o   L i s t ** ** 1. Unimplemented system dependent CORE word: key ** 2. Ficl uses the PAD in some CORE words - this violates the standard, **    but it's cleaner for a multithreaded system. I'll have to make a **    second pad for reference by the word PAD to fix this. ** ** F o r   M o r e   I n f o r m a t i o n ** ** Web home of ficl **   http://ficl.sourceforge.net ** Check this website for Forth literature (including the ANSI standard) **   http://www.taygeta.com/forthlit.html ** and here for software and more links **   http://www.taygeta.com/forth.html ** ** Obvious Performance enhancement opportunities ** Compile speed ** - work on interpret speed ** - turn off locals (FICL_WANT_LOCALS) ** Interpret speed  ** - Change inner interpreter (and everything else) **   so that a definition is a list of pointers to functions **   and inline data rather than pointers to words. This gets **   rid of vm->runningWord and a level of indirection in the **   inner loop. I'll look at it for ficl 3.0 ** - Make the main hash table a bigger prime (HASHSIZE) ** - FORGET about twiddling the hash function - my experience is **   that that is a waste of time. ** - Eliminate the need to pass the pVM parameter on the stack **   by dedicating a register to it. Most words need access to the **   vm, but the parameter passing overhead can be reduced. One way **   requires that the host OS have a task switch callout. Create **   a global variable for the running VM and refer to it in words **   that need VM access. Alternative: use thread local storage.  **   For single threaded implementations, you can just use a global. **   The first two solutions create portability problems, so I **   haven't considered doing them. Another possibility is to **   declare the pVm parameter to be "register", and hope the compiler **   pays attention. ** */
end_comment

begin_comment
comment|/* ** Revision History: **  ** 15 Apr 1999 (sadler) Merged FreeBSD changes for exception wordset and ** counted strings in ficlExec.  ** 12 Jan 1999 (sobral) Corrected EVALUATE behavior. Now TIB has an ** "end" field, and all words respect this. ficlExec is passed a "size" ** of TIB, as well as vmPushTib. This size is used to calculate the "end" ** of the string, ie, base+size. If the size is not known, pass -1. ** ** 10 Jan 1999 (sobral) EXCEPTION word set has been added, and existing ** words has been modified to conform to EXCEPTION EXT word set.  ** ** 27 Aug 1998 (sadler) testing and corrections for LOCALS, LOCALS EXT, **  SEARCH / SEARCH EXT, TOOLS / TOOLS EXT.  **  Added .X to display in hex, PARSE and PARSE-WORD to supplement WORD, **  EMPTY to clear stack. ** ** 29 jun 1998 (sadler) added variable sized hash table support **  and ANS Forth optional SEARCH& SEARCH EXT word set. ** 26 May 1998 (sadler)  **  FICL_PROMPT macro ** 14 April 1998 (sadler) V1.04 **  Ficlwin: Windows version, Skip Carter's Linux port ** 5 March 1998 (sadler) V1.03 **  Bug fixes -- passes John Ryan's ANS test suite "core.fr" ** ** 24 February 1998 (sadler) V1.02 ** -Fixed bugs in<# # #> ** -Changed FICL_WORD so that storage for the name characters **  can be allocated from the dictionary as needed rather than  **  reserving 32 bytes in each word whether needed or not -  **  this saved 50% of the dictionary storage requirement. ** -Added words in testmain for Win32 functions system,chdir,cwd, **  also added a word that loads and evaluates a file. ** ** December 1997 (sadler) ** -Added VM_RESTART exception handling in ficlExec -- this lets words **  that require additional text to succeed (like :, create, variable...) **  recover gracefully from an empty input buffer rather than emitting **  an error message. Definitions can span multiple input blocks with **  no restrictions. ** -Changed #include order so that<assert.h> is included in sysdep.h, **  and sysdep is included in all other files. This lets you define **  NDEBUG in sysdep.h to disable assertions if you want to. ** -Make PC specific system dependent code conditional on _M_IX86 **  defined so that ports can coexist in sysdep.h/sysdep.c */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|"sysdep.h"
include|#
directive|include
file|<limits.h>
comment|/* UCHAR_MAX */
comment|/* ** Forward declarations... read on. */
struct_decl|struct
name|ficl_word
struct_decl|;
typedef|typedef
name|struct
name|ficl_word
name|FICL_WORD
typedef|;
struct_decl|struct
name|vm
struct_decl|;
typedef|typedef
name|struct
name|vm
name|FICL_VM
typedef|;
struct_decl|struct
name|ficl_dict
struct_decl|;
typedef|typedef
name|struct
name|ficl_dict
name|FICL_DICT
typedef|;
struct_decl|struct
name|ficl_system
struct_decl|;
typedef|typedef
name|struct
name|ficl_system
name|FICL_SYSTEM
typedef|;
struct_decl|struct
name|ficl_system_info
struct_decl|;
typedef|typedef
name|struct
name|ficl_system_info
name|FICL_SYSTEM_INFO
typedef|;
comment|/*  ** the Good Stuff starts here... */
define|#
directive|define
name|FICL_VER
value|"3.03"
define|#
directive|define
name|FICL_VER_MAJOR
value|3
define|#
directive|define
name|FICL_VER_MINOR
value|3
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FICL_PROMPT
argument_list|)
define|#
directive|define
name|FICL_PROMPT
value|"ok> "
endif|#
directive|endif
comment|/* ** ANS Forth requires false to be zero, and true to be the ones ** complement of false... that unifies logical and bitwise operations ** nicely. */
define|#
directive|define
name|FICL_TRUE
value|((unsigned long)~(0L))
define|#
directive|define
name|FICL_FALSE
value|(0)
define|#
directive|define
name|FICL_BOOL
parameter_list|(
name|x
parameter_list|)
value|((x) ? FICL_TRUE : FICL_FALSE)
comment|/* ** A CELL is the main storage type. It must be large enough ** to contain a pointer or a scalar. In order to accommodate  ** 32 bit and 64 bit processors, use abstract types for int,  ** unsigned, and float. */
typedef|typedef
union|union
name|_cell
block|{
name|FICL_INT
name|i
decl_stmt|;
name|FICL_UNS
name|u
decl_stmt|;
if|#
directive|if
operator|(
name|FICL_WANT_FLOAT
operator|)
name|FICL_FLOAT
name|f
decl_stmt|;
endif|#
directive|endif
name|void
modifier|*
name|p
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
name|CELL
typedef|;
comment|/* ** LVALUEtoCELL does a little pointer trickery to cast any CELL sized ** lvalue (informal definition: an expression whose result has an ** address) to CELL. Remember that constants and casts are NOT ** themselves lvalues! */
define|#
directive|define
name|LVALUEtoCELL
parameter_list|(
name|v
parameter_list|)
value|(*(CELL *)&v)
comment|/* ** PTRtoCELL is a cast through void * intended to satisfy the ** most outrageously pedantic compiler... (I won't mention  ** its name) */
define|#
directive|define
name|PTRtoCELL
value|(CELL *)(void *)
define|#
directive|define
name|PTRtoSTRING
value|(FICL_STRING *)(void *)
comment|/* ** Strings in FICL are stored in Pascal style - with a count ** preceding the text. We'll also NULL-terminate them so that  ** they work with the usual C lib string functions. (Belt& ** suspenders? You decide.) ** STRINGINFO hides the implementation with a couple of ** macros for use in internal routines. */
typedef|typedef
name|unsigned
name|char
name|FICL_COUNT
typedef|;
define|#
directive|define
name|FICL_STRING_MAX
value|UCHAR_MAX
typedef|typedef
struct|struct
name|_ficl_string
block|{
name|FICL_COUNT
name|count
decl_stmt|;
name|char
name|text
index|[
literal|1
index|]
decl_stmt|;
block|}
name|FICL_STRING
typedef|;
typedef|typedef
struct|struct
block|{
name|FICL_UNS
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|}
name|STRINGINFO
typedef|;
define|#
directive|define
name|SI_COUNT
parameter_list|(
name|si
parameter_list|)
value|(si.count)
define|#
directive|define
name|SI_PTR
parameter_list|(
name|si
parameter_list|)
value|(si.cp)
define|#
directive|define
name|SI_SETLEN
parameter_list|(
name|si
parameter_list|,
name|len
parameter_list|)
value|(si.count = (FICL_UNS)(len))
define|#
directive|define
name|SI_SETPTR
parameter_list|(
name|si
parameter_list|,
name|ptr
parameter_list|)
value|(si.cp = (char *)(ptr))
comment|/*  ** Init a STRINGINFO from a pointer to NULL-terminated string */
define|#
directive|define
name|SI_PSZ
parameter_list|(
name|si
parameter_list|,
name|psz
parameter_list|)
define|\
value|{si.cp = psz; si.count = (FICL_COUNT)strlen(psz);}
comment|/*  ** Init a STRINGINFO from a pointer to FICL_STRING */
define|#
directive|define
name|SI_PFS
parameter_list|(
name|si
parameter_list|,
name|pfs
parameter_list|)
define|\
value|{si.cp = pfs->text; si.count = pfs->count;}
comment|/* ** Ficl uses this little structure to hold the address of  ** the block of text it's working on and an index to the next ** unconsumed character in the string. Traditionally, this is ** done by a Text Input Buffer, so I've called this struct TIB. ** ** Since this structure also holds the size of the input buffer, ** and since evaluate requires that, let's put the size here. ** The size is stored as an end-pointer because that is what the ** null-terminated string aware functions find most easy to deal ** with. ** Notice, though, that nobody really uses this except evaluate, ** so it might just be moved to FICL_VM instead. (sobral) */
typedef|typedef
struct|struct
block|{
name|FICL_INT
name|index
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|}
name|TIB
typedef|;
comment|/* ** Stacks get heavy use in Ficl and Forth... ** Each virtual machine implements two of them: ** one holds parameters (data), and the other holds return ** addresses and control flow information for the virtual ** machine. (Note: C's automatic stack is implicitly used, ** but not modeled because it doesn't need to be...) ** Here's an abstract type for a stack */
typedef|typedef
struct|struct
name|_ficlStack
block|{
name|FICL_UNS
name|nCells
decl_stmt|;
comment|/* size of the stack */
name|CELL
modifier|*
name|pFrame
decl_stmt|;
comment|/* link reg for stack frame */
name|CELL
modifier|*
name|sp
decl_stmt|;
comment|/* stack pointer */
name|CELL
name|base
index|[
literal|1
index|]
decl_stmt|;
comment|/* Top of stack */
block|}
name|FICL_STACK
typedef|;
comment|/* ** Stack methods... many map closely to required Forth words. */
name|FICL_STACK
modifier|*
name|stackCreate
parameter_list|(
name|unsigned
name|nCells
parameter_list|)
function_decl|;
name|void
name|stackDelete
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|int
name|stackDepth
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackDrop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|CELL
name|stackFetch
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|CELL
name|stackGetTop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackLink
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|nCells
parameter_list|)
function_decl|;
name|void
name|stackPick
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|CELL
name|stackPop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
modifier|*
name|stackPopPtr
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|FICL_UNS
name|stackPopUNS
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|FICL_INT
name|stackPopINT
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackPush
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|stackPushPtr
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
name|void
name|stackPushUNS
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|FICL_UNS
name|u
parameter_list|)
function_decl|;
name|void
name|stackPushINT
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|FICL_INT
name|i
parameter_list|)
function_decl|;
name|void
name|stackReset
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackRoll
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|void
name|stackSetTop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|stackStore
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|stackUnlink
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
if|#
directive|if
operator|(
name|FICL_WANT_FLOAT
operator|)
name|float
name|stackPopFloat
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
function_decl|;
name|void
name|stackPushFloat
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|FICL_FLOAT
name|f
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* ** Shortcuts (Guy Carver) */
define|#
directive|define
name|PUSHPTR
parameter_list|(
name|p
parameter_list|)
value|stackPushPtr(pVM->pStack,p)
define|#
directive|define
name|PUSHUNS
parameter_list|(
name|u
parameter_list|)
value|stackPushUNS(pVM->pStack,u)
define|#
directive|define
name|PUSHINT
parameter_list|(
name|i
parameter_list|)
value|stackPushINT(pVM->pStack,i)
define|#
directive|define
name|PUSHFLOAT
parameter_list|(
name|f
parameter_list|)
value|stackPushFloat(pVM->fStack,f)
define|#
directive|define
name|PUSH
parameter_list|(
name|c
parameter_list|)
value|stackPush(pVM->pStack,c)
define|#
directive|define
name|POPPTR
parameter_list|()
value|stackPopPtr(pVM->pStack)
define|#
directive|define
name|POPUNS
parameter_list|()
value|stackPopUNS(pVM->pStack)
define|#
directive|define
name|POPINT
parameter_list|()
value|stackPopINT(pVM->pStack)
define|#
directive|define
name|POPFLOAT
parameter_list|()
value|stackPopFloat(pVM->fStack)
define|#
directive|define
name|POP
parameter_list|()
value|stackPop(pVM->pStack)
define|#
directive|define
name|GETTOP
parameter_list|()
value|stackGetTop(pVM->pStack)
define|#
directive|define
name|SETTOP
parameter_list|(
name|c
parameter_list|)
value|stackSetTop(pVM->pStack,LVALUEtoCELL(c))
define|#
directive|define
name|GETTOPF
parameter_list|()
value|stackGetTop(pVM->fStack)
define|#
directive|define
name|SETTOPF
parameter_list|(
name|c
parameter_list|)
value|stackSetTop(pVM->fStack,LVALUEtoCELL(c))
define|#
directive|define
name|STORE
parameter_list|(
name|n
parameter_list|,
name|c
parameter_list|)
value|stackStore(pVM->pStack,n,LVALUEtoCELL(c))
define|#
directive|define
name|DEPTH
parameter_list|()
value|stackDepth(pVM->pStack)
define|#
directive|define
name|DROP
parameter_list|(
name|n
parameter_list|)
value|stackDrop(pVM->pStack,n)
define|#
directive|define
name|DROPF
parameter_list|(
name|n
parameter_list|)
value|stackDrop(pVM->fStack,n)
define|#
directive|define
name|FETCH
parameter_list|(
name|n
parameter_list|)
value|stackFetch(pVM->pStack,n)
define|#
directive|define
name|PICK
parameter_list|(
name|n
parameter_list|)
value|stackPick(pVM->pStack,n)
define|#
directive|define
name|PICKF
parameter_list|(
name|n
parameter_list|)
value|stackPick(pVM->fStack,n)
define|#
directive|define
name|ROLL
parameter_list|(
name|n
parameter_list|)
value|stackRoll(pVM->pStack,n)
define|#
directive|define
name|ROLLF
parameter_list|(
name|n
parameter_list|)
value|stackRoll(pVM->fStack,n)
comment|/*  ** The virtual machine (VM) contains the state for one interpreter. ** Defined operations include: ** Create& initialize ** Delete ** Execute a block of text ** Parse a word out of the input stream ** Call return, and branch  ** Text output ** Throw an exception */
typedef|typedef
name|FICL_WORD
modifier|*
modifier|*
name|IPTYPE
typedef|;
comment|/* the VM's instruction pointer */
comment|/* ** Each VM has a placeholder for an output function - ** this makes it possible to have each VM do I/O ** through a different device. If you specify no ** OUTFUNC, it defaults to ficlTextOut. */
typedef|typedef
name|void
function_decl|(
modifier|*
name|OUTFUNC
function_decl|)
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|fNewline
parameter_list|)
function_decl|;
comment|/* ** Each VM operates in one of two non-error states: interpreting ** or compiling. When interpreting, words are simply executed. ** When compiling, most words in the input stream have their ** addresses inserted into the word under construction. Some words ** (known as IMMEDIATE) are executed in the compile state, too. */
comment|/* values of STATE */
define|#
directive|define
name|INTERPRET
value|0
define|#
directive|define
name|COMPILE
value|1
comment|/* ** The pad is a small scratch area for text manipulation. ANS Forth ** requires it to hold at least 84 characters. */
if|#
directive|if
operator|!
name|defined
name|nPAD
define|#
directive|define
name|nPAD
value|256
endif|#
directive|endif
comment|/*  ** ANS Forth requires that a word's name contain {1..31} characters. */
if|#
directive|if
operator|!
name|defined
name|nFICLNAME
define|#
directive|define
name|nFICLNAME
value|31
endif|#
directive|endif
comment|/* ** OK - now we can really define the VM... */
struct|struct
name|vm
block|{
name|FICL_SYSTEM
modifier|*
name|pSys
decl_stmt|;
comment|/* Which system this VM belongs to  */
name|FICL_VM
modifier|*
name|link
decl_stmt|;
comment|/* Ficl keeps a VM list for simple teardown */
name|jmp_buf
modifier|*
name|pState
decl_stmt|;
comment|/* crude exception mechanism...     */
name|OUTFUNC
name|textOut
decl_stmt|;
comment|/* Output callback - see sysdep.c   */
name|void
modifier|*
name|pExtend
decl_stmt|;
comment|/* vm extension pointer for app use - initialized from FICL_SYSTEM */
name|short
name|fRestart
decl_stmt|;
comment|/* Set TRUE to restart runningWord  */
name|IPTYPE
name|ip
decl_stmt|;
comment|/* instruction pointer              */
name|FICL_WORD
modifier|*
name|runningWord
decl_stmt|;
comment|/* address of currently running word (often just *(ip-1) ) */
name|FICL_UNS
name|state
decl_stmt|;
comment|/* compiling or interpreting        */
name|FICL_UNS
name|base
decl_stmt|;
comment|/* number conversion base           */
name|FICL_STACK
modifier|*
name|pStack
decl_stmt|;
comment|/* param stack                      */
name|FICL_STACK
modifier|*
name|rStack
decl_stmt|;
comment|/* return stack                     */
if|#
directive|if
name|FICL_WANT_FLOAT
name|FICL_STACK
modifier|*
name|fStack
decl_stmt|;
comment|/* float stack (optional)           */
endif|#
directive|endif
name|CELL
name|sourceID
decl_stmt|;
comment|/* -1 if EVALUATE, 0 if normal input */
name|TIB
name|tib
decl_stmt|;
comment|/* address of incoming text string  */
if|#
directive|if
name|FICL_WANT_USER
name|CELL
name|user
index|[
name|FICL_USER_CELLS
index|]
decl_stmt|;
endif|#
directive|endif
name|char
name|pad
index|[
name|nPAD
index|]
decl_stmt|;
comment|/* the scratch area (see above)     */
block|}
struct|;
comment|/* ** A FICL_CODE points to a function that gets called to help execute ** a word in the dictionary. It always gets passed a pointer to the ** running virtual machine, and from there it can get the address ** of the parameter area of the word it's supposed to operate on. ** For precompiled words, the code is all there is. For user defined ** words, the code assumes that the word's parameter area is a list ** of pointers to the code fields of other words to execute, and ** may also contain inline data. The first parameter is always ** a pointer to a code field. */
typedef|typedef
name|void
function_decl|(
modifier|*
name|FICL_CODE
function_decl|)
parameter_list|(
name|FICL_VM
modifier|*
name|pVm
parameter_list|)
function_decl|;
if|#
directive|if
literal|0
define|#
directive|define
name|VM_ASSERT
parameter_list|(
name|pVM
parameter_list|)
value|assert((*(pVM->ip - 1)) == pVM->runningWord)
else|#
directive|else
define|#
directive|define
name|VM_ASSERT
parameter_list|(
name|pVM
parameter_list|)
endif|#
directive|endif
comment|/*  ** Ficl models memory as a contiguous space divided into ** words in a linked list called the dictionary. ** A FICL_WORD starts each entry in the list. ** Version 1.02: space for the name characters is allotted from ** the dictionary ahead of the word struct, rather than using ** a fixed size array for each name. */
struct|struct
name|ficl_word
block|{
name|struct
name|ficl_word
modifier|*
name|link
decl_stmt|;
comment|/* Previous word in the dictionary      */
name|UNS16
name|hash
decl_stmt|;
name|UNS8
name|flags
decl_stmt|;
comment|/* Immediate, Smudge, Compile-only      */
name|FICL_COUNT
name|nName
decl_stmt|;
comment|/* Number of chars in word name         */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* First nFICLNAME chars of word name   */
name|FICL_CODE
name|code
decl_stmt|;
comment|/* Native code to execute the word      */
name|CELL
name|param
index|[
literal|1
index|]
decl_stmt|;
comment|/* First data cell of the word          */
block|}
struct|;
comment|/* ** Worst-case size of a word header: nFICLNAME chars in name */
define|#
directive|define
name|CELLS_PER_WORD
define|\
value|( (sizeof (FICL_WORD) + nFICLNAME + sizeof (CELL)) \                           / (sizeof (CELL)) )
name|int
name|wordIsImmediate
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
name|int
name|wordIsCompileOnly
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
comment|/* flag values for word header */
define|#
directive|define
name|FW_IMMEDIATE
value|1
comment|/* execute me even if compiling */
define|#
directive|define
name|FW_COMPILE
value|2
comment|/* error if executed when not compiling */
define|#
directive|define
name|FW_SMUDGE
value|4
comment|/* definition in progress - hide me */
define|#
directive|define
name|FW_ISOBJECT
value|8
comment|/* word is an object or object member variable */
define|#
directive|define
name|FW_COMPIMMED
value|(FW_IMMEDIATE | FW_COMPILE)
define|#
directive|define
name|FW_DEFAULT
value|0
comment|/* ** Exit codes for vmThrow */
define|#
directive|define
name|VM_INNEREXIT
value|-256
comment|/* tell ficlExecXT to exit inner loop */
define|#
directive|define
name|VM_OUTOFTEXT
value|-257
comment|/* hungry - normal exit */
define|#
directive|define
name|VM_RESTART
value|-258
comment|/* word needs more text to succeed - re-run it */
define|#
directive|define
name|VM_USEREXIT
value|-259
comment|/* user wants to quit */
define|#
directive|define
name|VM_ERREXIT
value|-260
comment|/* interp found an error */
define|#
directive|define
name|VM_BREAK
value|-261
comment|/* debugger breakpoint */
define|#
directive|define
name|VM_ABORT
value|-1
comment|/* like errexit -- abort */
define|#
directive|define
name|VM_ABORTQ
value|-2
comment|/* like errexit -- abort" */
define|#
directive|define
name|VM_QUIT
value|-56
comment|/* like errexit, but leave pStack& base alone */
name|void
name|vmBranchRelative
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
name|FICL_VM
modifier|*
name|vmCreate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|unsigned
name|nPStack
parameter_list|,
name|unsigned
name|nRStack
parameter_list|)
function_decl|;
name|void
name|vmDelete
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmExecute
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_WORD
modifier|*
name|pWord
parameter_list|)
function_decl|;
name|FICL_DICT
modifier|*
name|vmGetDict
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|char
modifier|*
name|vmGetString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_STRING
modifier|*
name|spDest
parameter_list|,
name|char
name|delimiter
parameter_list|)
function_decl|;
name|STRINGINFO
name|vmGetWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|STRINGINFO
name|vmGetWord0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|int
name|vmGetWordToPad
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|STRINGINFO
name|vmParseString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
name|delimiter
parameter_list|)
function_decl|;
name|STRINGINFO
name|vmParseStringEx
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
name|delimiter
parameter_list|,
name|char
name|fSkipLeading
parameter_list|)
function_decl|;
name|CELL
name|vmPop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmPush
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|vmPopIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmPushIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|IPTYPE
name|newIP
parameter_list|)
function_decl|;
name|void
name|vmQuit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmReset
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|vmSetTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|OUTFUNC
name|textOut
parameter_list|)
function_decl|;
name|void
name|vmTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|fNewline
parameter_list|)
function_decl|;
name|void
name|vmTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|fNewline
parameter_list|)
function_decl|;
name|void
name|vmThrow
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|except
parameter_list|)
function_decl|;
name|void
name|vmThrowErr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
define|#
directive|define
name|vmGetRunningWord
parameter_list|(
name|pVM
parameter_list|)
value|((pVM)->runningWord)
comment|/* ** The inner interpreter - coded as a macro (see note for  ** INLINE_INNER_LOOP in sysdep.h for complaints about VC++ 5 */
define|#
directive|define
name|M_VM_STEP
parameter_list|(
name|pVM
parameter_list|)
define|\
value|FICL_WORD *tempFW = *(pVM)->ip++; \         (pVM)->runningWord = tempFW; \         tempFW->code(pVM);
define|#
directive|define
name|M_INNER_LOOP
parameter_list|(
name|pVM
parameter_list|)
define|\
value|for (;;)  { M_VM_STEP(pVM) }
if|#
directive|if
name|INLINE_INNER_LOOP
operator|!=
literal|0
define|#
directive|define
name|vmInnerLoop
parameter_list|(
name|pVM
parameter_list|)
value|M_INNER_LOOP(pVM)
else|#
directive|else
name|void
name|vmInnerLoop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* ** vmCheckStack needs a vm pointer because it might have to say ** something if it finds a problem. Parms popCells and pushCells ** correspond to the number of parameters on the left and right of  ** a word's stack effect comment. */
name|void
name|vmCheckStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|popCells
parameter_list|,
name|int
name|pushCells
parameter_list|)
function_decl|;
if|#
directive|if
name|FICL_WANT_FLOAT
name|void
name|vmCheckFStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|popCells
parameter_list|,
name|int
name|pushCells
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* ** TIB access routines... ** ANS forth seems to require the input buffer to be represented  ** as a pointer to the start of the buffer, and an index to the ** next character to read. ** PushTib points the VM to a new input string and optionally **  returns a copy of the current state ** PopTib restores the TIB state given a saved TIB from PushTib ** GetInBuf returns a pointer to the next unused char of the TIB */
name|void
name|vmPushTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|FICL_INT
name|nChars
parameter_list|,
name|TIB
modifier|*
name|pSaveTib
parameter_list|)
function_decl|;
name|void
name|vmPopTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|TIB
modifier|*
name|pTib
parameter_list|)
function_decl|;
define|#
directive|define
name|vmGetInBuf
parameter_list|(
name|pVM
parameter_list|)
value|((pVM)->tib.cp + (pVM)->tib.index)
define|#
directive|define
name|vmGetInBufLen
parameter_list|(
name|pVM
parameter_list|)
value|((pVM)->tib.end - (pVM)->tib.cp)
define|#
directive|define
name|vmGetInBufEnd
parameter_list|(
name|pVM
parameter_list|)
value|((pVM)->tib.end)
define|#
directive|define
name|vmGetTibIndex
parameter_list|(
name|pVM
parameter_list|)
value|(pVM)->tib.index
define|#
directive|define
name|vmSetTibIndex
parameter_list|(
name|pVM
parameter_list|,
name|i
parameter_list|)
value|(pVM)->tib.index = i
define|#
directive|define
name|vmUpdateTib
parameter_list|(
name|pVM
parameter_list|,
name|str
parameter_list|)
value|(pVM)->tib.index = (str) - (pVM)->tib.cp
comment|/* ** Generally useful string manipulators omitted by ANSI C... ** ltoa complements strtol */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|FICL_MAIN
comment|/* #SHEESH ** Why do Microsoft Meatballs insist on contaminating ** my namespace with their string functions??? */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4273
name|)
endif|#
directive|endif
name|int
name|isPowerOfTwo
parameter_list|(
name|FICL_UNS
name|u
parameter_list|)
function_decl|;
name|char
modifier|*
name|ltoa
parameter_list|(
name|FICL_INT
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
function_decl|;
name|char
modifier|*
name|ultoa
parameter_list|(
name|FICL_UNS
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
function_decl|;
name|char
name|digit_to_char
parameter_list|(
name|int
name|value
parameter_list|)
function_decl|;
name|char
modifier|*
name|strrev
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
name|char
modifier|*
name|skipSpace
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
name|char
modifier|*
name|caseFold
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
name|int
name|strincmp
parameter_list|(
name|char
modifier|*
name|cp1
parameter_list|,
name|char
modifier|*
name|cp2
parameter_list|,
name|FICL_UNS
name|count
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|FICL_MAIN
pragma|#
directive|pragma
name|warning
name|(
name|default
name|:
name|4273
name|)
endif|#
directive|endif
comment|/* ** Ficl hash table - variable size. ** assert(size> 0) ** If size is 1, the table degenerates into a linked list. ** A WORDLIST (see the search order word set in DPANS) is ** just a pointer to a FICL_HASH in this implementation. */
if|#
directive|if
operator|!
name|defined
name|HASHSIZE
comment|/* Default size of hash table. For most uniform */
define|#
directive|define
name|HASHSIZE
value|241
comment|/*   performance, use a prime number!   */
endif|#
directive|endif
typedef|typedef
struct|struct
name|ficl_hash
block|{
name|struct
name|ficl_hash
modifier|*
name|link
decl_stmt|;
comment|/* link to parent class wordlist for OO */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* optional pointer to \0 terminated wordlist name */
name|unsigned
name|size
decl_stmt|;
comment|/* number of buckets in the hash */
name|FICL_WORD
modifier|*
name|table
index|[
literal|1
index|]
decl_stmt|;
block|}
name|FICL_HASH
typedef|;
name|void
name|hashForget
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
function_decl|;
name|UNS16
name|hashHashCode
parameter_list|(
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
name|void
name|hashInsertWord
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|hashLookup
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|STRINGINFO
name|si
parameter_list|,
name|UNS16
name|hashCode
parameter_list|)
function_decl|;
name|void
name|hashReset
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|)
function_decl|;
comment|/* ** A Dictionary is a linked list of FICL_WORDs. It is also Ficl's ** memory model. Description of fields: ** ** here -- points to the next free byte in the dictionary. This **      pointer is forced to be CELL-aligned before a definition is added. **      Do not assume any specific alignment otherwise - Use dictAlign(). ** ** smudge -- pointer to word currently being defined (or last defined word) **      If the definition completes successfully, the word will be **      linked into the hash table. If unsuccessful, dictUnsmudge **      uses this pointer to restore the previous state of the dictionary. **      Smudge prevents unintentional recursion as a side-effect: the **      dictionary search algo examines only completed definitions, so a  **      word cannot invoke itself by name. See the ficl word "recurse". **      NOTE: smudge always points to the last word defined. IMMEDIATE **      makes use of this fact. Smudge is initially NULL. ** ** pForthWords -- pointer to the default wordlist (FICL_HASH). **      This is the initial compilation list, and contains all **      ficl's precompiled words. ** ** pCompile -- compilation wordlist - initially equal to pForthWords ** pSearch  -- array of pointers to wordlists. Managed as a stack. **      Highest index is the first list in the search order. ** nLists   -- number of lists in pSearch. nLists-1 is the highest  **      filled slot in pSearch, and points to the first wordlist **      in the search order ** size -- number of cells in the dictionary (total) ** dict -- start of data area. Must be at the end of the struct. */
struct|struct
name|ficl_dict
block|{
name|CELL
modifier|*
name|here
decl_stmt|;
name|FICL_WORD
modifier|*
name|smudge
decl_stmt|;
name|FICL_HASH
modifier|*
name|pForthWords
decl_stmt|;
name|FICL_HASH
modifier|*
name|pCompile
decl_stmt|;
name|FICL_HASH
modifier|*
name|pSearch
index|[
name|FICL_DEFAULT_VOCS
index|]
decl_stmt|;
name|int
name|nLists
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
comment|/* Number of cells in dict (total)*/
name|CELL
modifier|*
name|dict
decl_stmt|;
comment|/* Base of dictionary memory      */
block|}
struct|;
name|void
modifier|*
name|alignPtr
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
name|void
name|dictAbortDefinition
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictAlign
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|int
name|dictAllot
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|int
name|dictAllotCells
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|int
name|nCells
parameter_list|)
function_decl|;
name|void
name|dictAppendCell
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|CELL
name|c
parameter_list|)
function_decl|;
name|void
name|dictAppendChar
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|char
name|c
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|dictAppendWord
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|pCode
parameter_list|,
name|UNS8
name|flags
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|dictAppendWord2
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|,
name|FICL_CODE
name|pCode
parameter_list|,
name|UNS8
name|flags
parameter_list|)
function_decl|;
name|void
name|dictAppendUNS
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|FICL_UNS
name|u
parameter_list|)
function_decl|;
name|int
name|dictCellsAvail
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|int
name|dictCellsUsed
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictCheck
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
name|FICL_DICT
modifier|*
name|dictCreate
parameter_list|(
name|unsigned
name|nCELLS
parameter_list|)
function_decl|;
name|FICL_DICT
modifier|*
name|dictCreateHashed
parameter_list|(
name|unsigned
name|nCells
parameter_list|,
name|unsigned
name|nHash
parameter_list|)
function_decl|;
name|FICL_HASH
modifier|*
name|dictCreateWordlist
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|int
name|nBuckets
parameter_list|)
function_decl|;
name|void
name|dictDelete
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictEmpty
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|unsigned
name|nHash
parameter_list|)
function_decl|;
if|#
directive|if
name|FICL_WANT_FLOAT
name|void
name|dictHashSummary
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
endif|#
directive|endif
name|int
name|dictIncludes
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
name|FICL_WORD
modifier|*
name|dictLookup
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|FICL_WORD
modifier|*
name|ficlLookupLoc
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|dictResetSearchOrder
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictSetFlags
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|UNS8
name|set
parameter_list|,
name|UNS8
name|clr
parameter_list|)
function_decl|;
name|void
name|dictSetImmediate
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|void
name|dictUnsmudge
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
name|CELL
modifier|*
name|dictWhere
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
function_decl|;
comment|/*  ** P A R S E   S T E P ** (New for 2.05) ** See words.c: interpWord ** By default, ficl goes through two attempts to parse each token from its input ** stream: it first attempts to match it with a word in the dictionary, and ** if that fails, it attempts to convert it into a number. This mechanism is now ** extensible by additional steps. This allows extensions like floating point and  ** double number support to be factored cleanly. ** ** Each parse step is a function that receives the next input token as a STRINGINFO. ** If the parse step matches the token, it must apply semantics to the token appropriate ** to the present value of VM.state (compiling or interpreting), and return FICL_TRUE. ** Otherwise it returns FICL_FALSE. See words.c: isNumber for an example ** ** Note: for the sake of efficiency, it's a good idea both to limit the number ** of parse steps and to code each parse step so that it rejects tokens that ** do not match as quickly as possible. */
typedef|typedef
name|int
function_decl|(
modifier|*
name|FICL_PARSE_STEP
function_decl|)
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
comment|/* ** Appends a parse step function to the end of the parse list (see  ** FICL_PARSE_STEP notes in ficl.h for details). Returns 0 if successful, ** nonzero if there's no more room in the list. Each parse step is a word in  ** the dictionary. Precompiled parse steps can use (PARSE-STEP) as their  ** CFA - see parenParseStep in words.c. */
name|int
name|ficlAddParseStep
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
comment|/* ficl.c */
name|void
name|ficlAddPrecompiledParseStep
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_PARSE_STEP
name|pStep
parameter_list|)
function_decl|;
name|void
name|ficlListParseSteps
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
comment|/* ** FICL_BREAKPOINT record. ** origXT - if NULL, this breakpoint is unused. Otherwise it stores the xt  ** that the breakpoint overwrote. This is restored to the dictionary when the ** BP executes or gets cleared ** address - the location of the breakpoint (address of the instruction that **           has been replaced with the breakpoint trap ** origXT  - The original contents of the location with the breakpoint ** Note: address is NULL when this breakpoint is empty */
typedef|typedef
struct|struct
name|FICL_BREAKPOINT
block|{
name|void
modifier|*
name|address
decl_stmt|;
name|FICL_WORD
modifier|*
name|origXT
decl_stmt|;
block|}
name|FICL_BREAKPOINT
typedef|;
comment|/* ** F I C L _ S Y S T E M ** The top level data structure of the system - ficl_system ties a list of ** virtual machines with their corresponding dictionaries. Ficl 3.0 will ** support multiple Ficl systems, allowing multiple concurrent sessions  ** to separate dictionaries with some constraints.  ** The present model allows multiple sessions to one dictionary provided ** you implement ficlLockDictionary() as specified in sysdep.h ** Note: the pExtend pointer is there to provide context for applications. It is copied ** to each VM's pExtend field as that VM is created. */
struct|struct
name|ficl_system
block|{
name|FICL_SYSTEM
modifier|*
name|link
decl_stmt|;
name|void
modifier|*
name|pExtend
decl_stmt|;
comment|/* Initializes VM's pExtend pointer (for application use) */
name|FICL_VM
modifier|*
name|vmList
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
decl_stmt|;
name|FICL_DICT
modifier|*
name|envp
decl_stmt|;
ifdef|#
directive|ifdef
name|FICL_WANT_LOCALS
name|FICL_DICT
modifier|*
name|localp
decl_stmt|;
endif|#
directive|endif
name|FICL_WORD
modifier|*
name|pInterp
index|[
literal|3
index|]
decl_stmt|;
name|FICL_WORD
modifier|*
name|parseList
index|[
name|FICL_MAX_PARSE_STEPS
index|]
decl_stmt|;
name|OUTFUNC
name|textOut
decl_stmt|;
name|FICL_WORD
modifier|*
name|pBranchParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pDoParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pDoesParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pExitInner
decl_stmt|;
name|FICL_WORD
modifier|*
name|pExitParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pBranch0
decl_stmt|;
name|FICL_WORD
modifier|*
name|pInterpret
decl_stmt|;
name|FICL_WORD
modifier|*
name|pLitParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pTwoLitParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pLoopParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pPLoopParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pQDoParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pSemiParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pOfParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pStore
decl_stmt|;
name|FICL_WORD
modifier|*
name|pDrop
decl_stmt|;
name|FICL_WORD
modifier|*
name|pCStringLit
decl_stmt|;
name|FICL_WORD
modifier|*
name|pStringLit
decl_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|FICL_WORD
modifier|*
name|pGetLocalParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pGet2LocalParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pGetLocal0
decl_stmt|;
name|FICL_WORD
modifier|*
name|pGetLocal1
decl_stmt|;
name|FICL_WORD
modifier|*
name|pToLocalParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pTo2LocalParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pToLocal0
decl_stmt|;
name|FICL_WORD
modifier|*
name|pToLocal1
decl_stmt|;
name|FICL_WORD
modifier|*
name|pLinkParen
decl_stmt|;
name|FICL_WORD
modifier|*
name|pUnLinkParen
decl_stmt|;
name|FICL_INT
name|nLocals
decl_stmt|;
name|CELL
modifier|*
name|pMarkLocals
decl_stmt|;
endif|#
directive|endif
name|FICL_BREAKPOINT
name|bpStep
decl_stmt|;
block|}
struct|;
struct|struct
name|ficl_system_info
block|{
name|int
name|size
decl_stmt|;
comment|/* structure size tag for versioning */
name|int
name|nDictCells
decl_stmt|;
comment|/* Size of system's Dictionary */
name|OUTFUNC
name|textOut
decl_stmt|;
comment|/* default textOut function */
name|void
modifier|*
name|pExtend
decl_stmt|;
comment|/* Initializes VM's pExtend pointer - for application use */
name|int
name|nEnvCells
decl_stmt|;
comment|/* Size of Environment dictionary */
block|}
struct|;
define|#
directive|define
name|ficlInitInfo
parameter_list|(
name|x
parameter_list|)
value|{ memset((x), 0, sizeof(FICL_SYSTEM_INFO)); \          (x)->size = sizeof(FICL_SYSTEM_INFO); }
comment|/* ** External interface to FICL... */
comment|/*  ** f i c l I n i t S y s t e m ** Binds a global dictionary to the interpreter system and initializes ** the dict to contain the ANSI CORE wordset.  ** You can specify the address and size of the allocated area. ** Using ficlInitSystemEx you can also specify the text output function. ** After that, ficl manages it. ** First step is to set up the static pointers to the area. ** Then write the "precompiled" portion of the dictionary in. ** The dictionary needs to be at least large enough to hold the ** precompiled part. Try 1K cells minimum. Use "words" to find ** out how much of the dictionary is used at any time. */
name|FICL_SYSTEM
modifier|*
name|ficlInitSystemEx
parameter_list|(
name|FICL_SYSTEM_INFO
modifier|*
name|fsi
parameter_list|)
function_decl|;
comment|/* Deprecated call */
name|FICL_SYSTEM
modifier|*
name|ficlInitSystem
parameter_list|(
name|int
name|nDictCells
parameter_list|)
function_decl|;
comment|/* ** f i c l T e r m S y s t e m ** Deletes the system dictionary and all virtual machines that ** were created with ficlNewVM (see below). Call this function to ** reclaim all memory used by the dictionary and VMs. */
name|void
name|ficlTermSystem
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
comment|/* ** f i c l E v a l u a t e ** Evaluates a block of input text in the context of the ** specified interpreter. Also sets SOURCE-ID properly. ** ** PLEASE USE THIS FUNCTION when throwing a hard-coded ** string to the FICL interpreter. */
name|int
name|ficlEvaluate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|)
function_decl|;
comment|/* ** f i c l E x e c ** Evaluates a block of input text in the context of the ** specified interpreter. Emits any requested output to the ** interpreter's output function. If the input string is NULL ** terminated, you can pass -1 as nChars rather than count it. ** Execution returns when the text block has been executed, ** or an error occurs. ** Returns one of the VM_XXXX codes defined in ficl.h: ** VM_OUTOFTEXT is the normal exit condition ** VM_ERREXIT means that the interp encountered a syntax error **      and the vm has been reset to recover (some or all **      of the text block got ignored ** VM_USEREXIT means that the user executed the "bye" command **      to shut down the interpreter. This would be a good **      time to delete the vm, etc -- or you can ignore this **      signal. ** VM_ABORT and VM_ABORTQ are generated by 'abort' and 'abort"' **      commands. ** Preconditions: successful execution of ficlInitSystem, **      Successful creation and init of the VM by ficlNewVM (or equiv) ** ** If you call ficlExec() or one of its brothers, you MUST ** ensure pVM->sourceID was set to a sensible value. ** ficlExec() explicitly DOES NOT manage SOURCE-ID for you. */
name|int
name|ficlExec
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|)
function_decl|;
name|int
name|ficlExecC
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|pText
parameter_list|,
name|FICL_INT
name|nChars
parameter_list|)
function_decl|;
name|int
name|ficlExecXT
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_WORD
modifier|*
name|pWord
parameter_list|)
function_decl|;
comment|/* ** ficlExecFD(FICL_VM *pVM, int fd);  * Evaluates text from file passed in via fd.  * Execution returns when all of file has been executed or an  * error occurs.  */
name|int
name|ficlExecFD
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
comment|/* ** Create a new VM from the heap, and link it into the system VM list. ** Initializes the VM and binds default sized stacks to it. Returns the ** address of the VM, or NULL if an error occurs. ** Precondition: successful execution of ficlInitSystem */
name|FICL_VM
modifier|*
name|ficlNewVM
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
comment|/* ** Force deletion of a VM. You do not need to do this  ** unless you're creating and discarding a lot of VMs. ** For systems that use a constant pool of VMs for the life ** of the system, ficltermSystem takes care of VM cleanup ** automatically. */
name|void
name|ficlFreeVM
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
comment|/* ** Set the stack sizes (return and parameter) to be used for all ** subsequently created VMs. Returns actual stack size to be used. */
name|int
name|ficlSetStackSize
parameter_list|(
name|int
name|nStackCells
parameter_list|)
function_decl|;
comment|/* ** Returns the address of the most recently defined word in the system ** dictionary with the given name, or NULL if no match. ** Precondition: successful execution of ficlInitSystem */
name|FICL_WORD
modifier|*
name|ficlLookup
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* ** f i c l G e t D i c t ** Utility function - returns the address of the system dictionary. ** Precondition: successful execution of ficlInitSystem */
name|FICL_DICT
modifier|*
name|ficlGetDict
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|FICL_DICT
modifier|*
name|ficlGetEnv
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|void
name|ficlSetEnv
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_UNS
name|value
parameter_list|)
function_decl|;
name|void
name|ficlSetEnvD
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_UNS
name|hi
parameter_list|,
name|FICL_UNS
name|lo
parameter_list|)
function_decl|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|FICL_DICT
modifier|*
name|ficlGetLoc
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/*  ** f i c l B u i l d ** Builds a word into the system default dictionary in a thread-safe way. ** Preconditions: system must be initialized, and there must ** be enough space for the new word's header! Operation is ** controlled by ficlLockDictionary, so any initialization ** required by your version of the function (if you "overrode" ** it) must be complete at this point. ** Parameters: ** name  -- the name of the word to be built ** code  -- code to execute when the word is invoked - must take a single param **          pointer to a FICL_VM ** flags -- 0 or more of FW_IMMEDIATE, FW_COMPILE, use bitwise OR!  **          Most words can use FW_DEFAULT. ** nAllot - number of extra cells to allocate in the parameter area (usually zero) */
name|int
name|ficlBuild
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|code
parameter_list|,
name|char
name|flags
parameter_list|)
function_decl|;
comment|/*  ** f i c l C o m p i l e C o r e ** Builds the ANS CORE wordset into the dictionary - called by ** ficlInitSystem - no need to waste dict space by doing it again. */
name|void
name|ficlCompileCore
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|void
name|ficlCompilePrefix
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|void
name|ficlCompileSearch
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|void
name|ficlCompileSoftCore
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|void
name|ficlCompileTools
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|void
name|ficlCompileFile
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
if|#
directive|if
name|FICL_WANT_FLOAT
name|void
name|ficlCompileFloat
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
name|int
name|ficlParseFloatNumber
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
comment|/* float.c */
endif|#
directive|endif
if|#
directive|if
name|FICL_PLATFORM_EXTEND
name|void
name|ficlCompilePlatform
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
function_decl|;
endif|#
directive|endif
name|int
name|ficlParsePrefix
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
comment|/* ** from words.c... */
name|void
name|constantParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|twoConstParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|int
name|ficlParseNumber
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
name|void
name|ficlTick
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
name|void
name|parseStepParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
comment|/* ** From tools.c */
name|int
name|isAFiclWord
parameter_list|(
name|FICL_DICT
modifier|*
name|pd
parameter_list|,
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
comment|/*  ** The following supports SEE and the debugger. */
typedef|typedef
enum|enum
block|{
name|BRANCH
block|,
name|COLON
block|,
name|CONSTANT
block|,
name|CREATE
block|,
name|DO
block|,
name|DOES
block|,
name|IF
block|,
name|LITERAL
block|,
name|LOOP
block|,
name|OF
block|,
name|PLOOP
block|,
name|PRIMITIVE
block|,
name|QDO
block|,
name|STRINGLIT
block|,
name|CSTRINGLIT
block|,
if|#
directive|if
name|FICL_WANT_USER
name|USER
block|,
endif|#
directive|endif
name|VARIABLE
block|,  }
name|WORDKIND
typedef|;
name|WORDKIND
name|ficlWordClassify
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
function_decl|;
comment|/* ** Dictionary on-demand resizing */
specifier|extern
name|CELL
name|dictThreshold
decl_stmt|;
specifier|extern
name|CELL
name|dictIncrease
decl_stmt|;
comment|/* ** Various FreeBSD goodies */
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TESTMAIN
argument_list|)
specifier|extern
name|void
name|ficlOutb
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlInb
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|extern
name|void
name|ficlSetenv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlSetenvq
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlGetenv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlUnsetenv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlCopyin
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlCopyout
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlFindfile
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlCcall
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TESTMAIN
argument_list|)
specifier|extern
name|void
name|ficlPnpdevices
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
specifier|extern
name|void
name|ficlPnphandlers
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* ** Used with File-Access wordset. */
define|#
directive|define
name|FICL_FAM_READ
value|1
define|#
directive|define
name|FICL_FAM_WRITE
value|2
define|#
directive|define
name|FICL_FAM_APPEND
value|4
define|#
directive|define
name|FICL_FAM_BINARY
value|8
define|#
directive|define
name|FICL_FAM_OPEN_MODE
parameter_list|(
name|fam
parameter_list|)
value|((fam)& (FICL_FAM_READ | FICL_FAM_WRITE | FICL_FAM_APPEND))
if|#
directive|if
operator|(
name|FICL_WANT_FILE
operator|)
typedef|typedef
struct|struct
name|ficlFILE
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|filename
index|[
literal|256
index|]
decl_stmt|;
block|}
name|ficlFILE
typedef|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FICL_H__ */
end_comment

end_unit

