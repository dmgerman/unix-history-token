begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** v m . c ** Forth Inspired Command Language - virtual machine methods ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 ** $Id: vm.c,v 1.13 2001/12/05 07:21:34 jsadler Exp $ *******************************************************************/
end_comment

begin_comment
comment|/* ** This file implements the virtual machine of FICL. Each virtual ** machine retains the state of an interpreter. A virtual machine ** owns a pair of stacks for parameters and return addresses, as ** well as a pile of state variables and the two dedicated registers ** of the interp. */
end_comment

begin_comment
comment|/* ** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu) ** All rights reserved. ** ** Get the latest Ficl release at http://ficl.sourceforge.net ** ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release, please ** contact me by email at the address above. ** ** L I C E N S E  and  D I S C L A I M E R **  ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************                         v m B r a n c h R e l a t i v e  **  **************************************************************************/
end_comment

begin_function
name|void
name|vmBranchRelative
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|pVM
operator|->
name|ip
operator|+=
name|offset
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m C r e a t e ** Creates a virtual machine either from scratch (if pVM is NULL on entry) ** or by resizing and reinitializing an existing VM to the specified stack ** sizes. **************************************************************************/
end_comment

begin_function
name|FICL_VM
modifier|*
name|vmCreate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|unsigned
name|nPStack
parameter_list|,
name|unsigned
name|nRStack
parameter_list|)
block|{
if|if
condition|(
name|pVM
operator|==
name|NULL
condition|)
block|{
name|pVM
operator|=
operator|(
name|FICL_VM
operator|*
operator|)
name|ficlMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FICL_VM
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_VM
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pVM
operator|->
name|pStack
condition|)
name|stackDelete
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|pStack
operator|=
name|stackCreate
argument_list|(
name|nPStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|rStack
condition|)
name|stackDelete
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|rStack
operator|=
name|stackCreate
argument_list|(
name|nRStack
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_FLOAT
if|if
condition|(
name|pVM
operator|->
name|fStack
condition|)
name|stackDelete
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|fStack
operator|=
name|stackCreate
argument_list|(
name|nPStack
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pVM
operator|->
name|textOut
operator|=
name|ficlTextOut
expr_stmt|;
name|vmReset
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return
name|pVM
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m D e l e t e ** Free all memory allocated to the specified VM and its subordinate  ** structures. **************************************************************************/
end_comment

begin_function
name|void
name|vmDelete
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|if
condition|(
name|pVM
condition|)
block|{
name|ficlFree
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_FLOAT
name|ficlFree
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ficlFree
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m E x e c u t e ** Sets up the specified word to be run by the inner interpreter. ** Executes the word's code part immediately, but in the case of ** colon definition, the definition itself needs the inner interp ** to complete. This does not happen until control reaches ficlExec **************************************************************************/
end_comment

begin_function
name|void
name|vmExecute
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_WORD
modifier|*
name|pWord
parameter_list|)
block|{
name|pVM
operator|->
name|runningWord
operator|=
name|pWord
expr_stmt|;
name|pWord
operator|->
name|code
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m I n n e r L o o p ** the mysterious inner interpreter... ** This loop is the address interpreter that makes colon definitions ** work. Upon entry, it assumes that the IP points to an entry in  ** a definition (the body of a colon word). It runs one word at a time ** until something does vmThrow. The catcher for this is expected to exist ** in the calling code. ** vmThrow gets you out of this loop with a longjmp() ** Visual C++ 5 chokes on this loop in Release mode. Aargh. **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|INLINE_INNER_LOOP
operator|==
literal|0
end_if

begin_function
name|void
name|vmInnerLoop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|M_INNER_LOOP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ** Recast inner loop that inlines tokens for control structures, arithmetic and stack operations,  ** as well as create does> : ; and various literals */
end_comment

begin_endif
unit|typedef enum {     PATCH = 0,     L0,     L1,     L2,     LMINUS1,     LMINUS2,     DROP,     SWAP,     DUP,     PICK,     ROLL,     FETCH,     STORE,     BRANCH,     CBRANCH,     LEAVE,     TO_R,     R_FROM,     EXIT; } OPCODE;  typedef CELL *IPTYPE;  void vmInnerLoop(FICL_VM *pVM) {     IPTYPE ip = pVM->ip;     FICL_STACK *pStack = pVM->pStack;      for (;;)     {         OPCODE o = (*ip++).i;         CELL c;         switch (o)         {         case L0:             stackPushINT(pStack, 0);             break;         case L1:             stackPushINT(pStack, 1);             break;         case L2:             stackPushINT(pStack, 2);             break;         case LMINUS1:             stackPushINT(pStack, -1);             break;         case LMINUS2:             stackPushINT(pStack, -2);             break;         case DROP:             stackDrop(pStack, 1);             break;         case SWAP:             stackRoll(pStack, 1);             break;         case DUP:             stackPick(pStack, 0);             break;         case PICK:             c = *ip++;             stackPick(pStack, c.i);             break;         case ROLL:             c = *ip++;             stackRoll(pStack, c.i);             break;         case EXIT:             return;         }     }      return; }
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         v m G e t D i c t ** Returns the address dictionary for this VM's system **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|vmGetDict
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return
name|pVM
operator|->
name|pSys
operator|->
name|dp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t S t r i n g ** Parses a string out of the VM input buffer and copies up to the first ** FICL_STRING_MAX characters to the supplied destination buffer, a ** FICL_STRING. The destination string is NULL terminated. **  ** Returns the address of the first unused character in the dest buffer. **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|vmGetString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_STRING
modifier|*
name|spDest
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
name|delimiter
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
name|FICL_STRING_MAX
condition|)
block|{
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|FICL_STRING_MAX
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|spDest
operator|->
name|text
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|spDest
operator|->
name|text
index|[
name|SI_COUNT
argument_list|(
name|si
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spDest
operator|->
name|count
operator|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
expr_stmt|;
return|return
name|spDest
operator|->
name|text
operator|+
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t W o r d ** vmGetWord calls vmGetWord0 repeatedly until it gets a string with  ** non-zero length. **************************************************************************/
end_comment

begin_function
name|STRINGINFO
name|vmGetWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_RESTART
argument_list|)
expr_stmt|;
block|}
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t W o r d 0 ** Skip leading whitespace and parse a space delimited word from the tib. ** Returns the start address and length of the word. Updates the tib ** to reflect characters consumed, including the trailing delimiter. ** If there's nothing of interest in the tib, returns zero. This function ** does not use vmParseString because it uses isspace() rather than a ** single  delimiter character. **************************************************************************/
end_comment

begin_function
name|STRINGINFO
name|vmGetWord0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|pSrc
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pEnd
init|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_UNS
name|count
init|=
literal|0
decl_stmt|;
name|char
name|ch
init|=
literal|0
decl_stmt|;
name|pSrc
operator|=
name|skipSpace
argument_list|(
name|pSrc
argument_list|,
name|pEnd
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
comment|/*     for (ch = *pSrc; (pEnd != pSrc)&& !isspace(ch); ch = *++pSrc)     {         count++;     } */
comment|/* Changed to make Purify happier.  --lch */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pEnd
operator|==
name|pSrc
condition|)
break|break;
name|ch
operator|=
operator|*
name|pSrc
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
name|count
operator|++
expr_stmt|;
name|pSrc
operator|++
expr_stmt|;
block|}
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pEnd
operator|!=
name|pSrc
operator|)
operator|&&
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
comment|/* skip one trailing delimiter */
name|pSrc
operator|++
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t W o r d T o P a d ** Does vmGetWord and copies the result to the pad as a NULL terminated ** string. Returns the length of the string. If the string is too long  ** to fit in the pad, it is truncated. **************************************************************************/
end_comment

begin_function
name|int
name|vmGetWordToPad
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|pVM
operator|->
name|pad
decl_stmt|;
name|si
operator|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
name|nPAD
condition|)
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|nPAD
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cp
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|cp
index|[
name|SI_COUNT
argument_list|(
name|si
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P a r s e S t r i n g ** Parses a string out of the input buffer using the delimiter ** specified. Skips leading delimiters, marks the start of the string, ** and counts characters to the next delimiter it encounters. It then  ** updates the vm input buffer to consume all these chars, including the ** trailing delimiter.  ** Returns the address and length of the parsed string, not including the ** trailing delimiter. **************************************************************************/
end_comment

begin_function
name|STRINGINFO
name|vmParseString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
name|delim
parameter_list|)
block|{
return|return
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
name|delim
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|STRINGINFO
name|vmParseStringEx
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
name|delim
parameter_list|,
name|char
name|fSkipLeading
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|char
modifier|*
name|pSrc
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pEnd
init|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|fSkipLeading
condition|)
block|{
comment|/* skip lead delimiters */
while|while
condition|(
operator|(
name|pSrc
operator|!=
name|pEnd
operator|)
operator|&&
operator|(
operator|*
name|pSrc
operator|==
name|delim
operator|)
condition|)
name|pSrc
operator|++
expr_stmt|;
block|}
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
comment|/* mark start of text */
for|for
control|(
name|ch
operator|=
operator|*
name|pSrc
init|;
operator|(
name|pSrc
operator|!=
name|pEnd
operator|)
operator|&&
operator|(
name|ch
operator|!=
name|delim
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|pSrc
control|)
block|{
empty_stmt|;
comment|/* find next delimiter or end of line */
block|}
comment|/* set length of result */
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|pSrc
operator|-
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pSrc
operator|!=
name|pEnd
operator|)
operator|&&
operator|(
operator|*
name|pSrc
operator|==
name|delim
operator|)
condition|)
comment|/* gobble trailing delimiter */
name|pSrc
operator|++
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P o p **  **************************************************************************/
end_comment

begin_function
name|CELL
name|vmPop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
return|return
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P u s h **  **************************************************************************/
end_comment

begin_function
name|void
name|vmPush
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|CELL
name|c
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P o p I P **  **************************************************************************/
end_comment

begin_function
name|void
name|vmPopIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|ip
operator|=
call|(
name|IPTYPE
call|)
argument_list|(
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P u s h I P **  **************************************************************************/
end_comment

begin_function
name|void
name|vmPushIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|IPTYPE
name|newIP
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|ip
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|ip
operator|=
name|newIP
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P u s h T i b ** Binds the specified input string to the VM and clears>IN (the index) **************************************************************************/
end_comment

begin_function
name|void
name|vmPushTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|FICL_INT
name|nChars
parameter_list|,
name|TIB
modifier|*
name|pSaveTib
parameter_list|)
block|{
if|if
condition|(
name|pSaveTib
condition|)
block|{
operator|*
name|pSaveTib
operator|=
name|pVM
operator|->
name|tib
expr_stmt|;
block|}
name|pVM
operator|->
name|tib
operator|.
name|cp
operator|=
name|text
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|end
operator|=
name|text
operator|+
name|nChars
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmPopTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|TIB
modifier|*
name|pTib
parameter_list|)
block|{
if|if
condition|(
name|pTib
condition|)
block|{
name|pVM
operator|->
name|tib
operator|=
operator|*
name|pTib
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m Q u i t **  **************************************************************************/
end_comment

begin_function
name|void
name|vmQuit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackReset
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|fRestart
operator|=
literal|0
expr_stmt|;
name|pVM
operator|->
name|ip
operator|=
name|NULL
expr_stmt|;
name|pVM
operator|->
name|runningWord
operator|=
name|NULL
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|INTERPRET
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|cp
operator|=
name|NULL
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|pVM
operator|->
name|pad
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m R e s e t  **  **************************************************************************/
end_comment

begin_function
name|void
name|vmReset
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmQuit
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|stackReset
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_FLOAT
name|stackReset
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pVM
operator|->
name|base
operator|=
literal|10
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m S e t T e x t O u t ** Binds the specified output callback to the vm. If you pass NULL, ** binds the default output function (ficlTextOut) **************************************************************************/
end_comment

begin_function
name|void
name|vmSetTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|OUTFUNC
name|textOut
parameter_list|)
block|{
if|if
condition|(
name|textOut
condition|)
name|pVM
operator|->
name|textOut
operator|=
name|textOut
expr_stmt|;
else|else
name|pVM
operator|->
name|textOut
operator|=
name|ficlTextOut
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m T e x t O u t ** Feeds text to the vm's output callback **************************************************************************/
end_comment

begin_function
name|void
name|vmTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|fNewline
parameter_list|)
block|{
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|textOut
argument_list|)
expr_stmt|;
call|(
name|pVM
operator|->
name|textOut
call|)
argument_list|(
name|pVM
argument_list|,
name|text
argument_list|,
name|fNewline
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m T h r o w **  **************************************************************************/
end_comment

begin_function
name|void
name|vmThrow
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|except
parameter_list|)
block|{
if|if
condition|(
name|pVM
operator|->
name|pState
condition|)
name|longjmp
argument_list|(
operator|*
operator|(
name|pVM
operator|->
name|pState
operator|)
argument_list|,
name|except
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmThrowErr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
operator|*
operator|(
name|pVM
operator|->
name|pState
operator|)
argument_list|,
name|VM_ERREXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         w o r d I s I m m e d i a t e **  **************************************************************************/
end_comment

begin_function
name|int
name|wordIsImmediate
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pFW
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pFW
operator|->
name|flags
operator|&
name|FW_IMMEDIATE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         w o r d I s C o m p i l e O n l y **  **************************************************************************/
end_comment

begin_function
name|int
name|wordIsCompileOnly
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pFW
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pFW
operator|->
name|flags
operator|&
name|FW_COMPILE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t r r e v **  **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|strrev
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* reverse a string in-place */
name|int
name|i
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|string
decl_stmt|;
comment|/* first char of string */
name|char
modifier|*
name|p2
init|=
name|string
operator|+
name|i
operator|-
literal|1
decl_stmt|;
comment|/* last non-NULL char of string */
name|char
name|c
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|p1
operator|<
name|p2
condition|)
block|{
name|c
operator|=
operator|*
name|p2
expr_stmt|;
operator|*
name|p2
operator|=
operator|*
name|p1
expr_stmt|;
operator|*
name|p1
operator|=
name|c
expr_stmt|;
name|p1
operator|++
expr_stmt|;
name|p2
operator|--
expr_stmt|;
block|}
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i g i t _ t o _ c h a r **  **************************************************************************/
end_comment

begin_function
name|char
name|digit_to_char
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
name|digits
index|[
name|value
index|]
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i s P o w e r O f T w o ** Tests whether supplied argument is an integer power of 2 (2**n) ** where 32> n> 1, and returns n if so. Otherwise returns zero. **************************************************************************/
end_comment

begin_function
name|int
name|isPowerOfTwo
parameter_list|(
name|FICL_UNS
name|u
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|FICL_UNS
name|t
init|=
literal|2
decl_stmt|;
for|for
control|(
init|;
operator|(
operator|(
name|t
operator|<=
name|u
operator|)
operator|&&
operator|(
name|t
operator|!=
literal|0
operator|)
operator|)
condition|;
name|i
operator|++
operator|,
name|t
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|u
operator|==
name|t
condition|)
return|return
name|i
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l t o a **  **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|ltoa
parameter_list|(
name|FICL_INT
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
block|{
comment|/* convert long to string, any base */
name|char
modifier|*
name|cp
init|=
name|string
decl_stmt|;
name|int
name|sign
init|=
operator|(
operator|(
name|radix
operator|==
literal|10
operator|)
operator|&&
operator|(
name|value
operator|<
literal|0
operator|)
operator|)
decl_stmt|;
name|int
name|pwr
decl_stmt|;
name|assert
argument_list|(
name|radix
operator|>
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|radix
operator|<
literal|37
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|pwr
operator|=
name|isPowerOfTwo
argument_list|(
operator|(
name|FICL_UNS
operator|)
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|pwr
operator|!=
literal|0
condition|)
block|{
name|FICL_UNS
name|v
init|=
operator|(
name|FICL_UNS
operator|)
name|value
decl_stmt|;
name|FICL_UNS
name|mask
init|=
operator|(
name|FICL_UNS
operator|)
operator|~
operator|(
operator|-
literal|1
operator|<<
name|pwr
operator|)
decl_stmt|;
while|while
condition|(
name|v
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
name|v
operator|&
name|mask
index|]
expr_stmt|;
name|v
operator|>>=
name|pwr
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNSQR
name|result
decl_stmt|;
name|DPUNS
name|v
decl_stmt|;
name|v
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|v
operator|.
name|lo
operator|=
operator|(
name|FICL_UNS
operator|)
name|value
expr_stmt|;
while|while
condition|(
name|v
operator|.
name|lo
condition|)
block|{
name|result
operator|=
name|ficlLongDiv
argument_list|(
name|v
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|radix
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
name|result
operator|.
name|rem
index|]
expr_stmt|;
name|v
operator|.
name|lo
operator|=
name|result
operator|.
name|quot
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sign
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|strrev
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         u l t o a **  **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|ultoa
parameter_list|(
name|FICL_UNS
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
block|{
comment|/* convert long to string, any base */
name|char
modifier|*
name|cp
init|=
name|string
decl_stmt|;
name|DPUNS
name|ud
decl_stmt|;
name|UNSQR
name|result
decl_stmt|;
name|assert
argument_list|(
name|radix
operator|>
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|radix
operator|<
literal|37
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
else|else
block|{
name|ud
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
name|value
expr_stmt|;
name|result
operator|.
name|quot
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|ud
operator|.
name|lo
condition|)
block|{
name|result
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|radix
argument_list|)
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
name|result
operator|.
name|quot
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
name|result
operator|.
name|rem
index|]
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|strrev
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c a s e F o l d ** Case folds a NULL terminated string in place. All characters ** get converted to lower case. **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|caseFold
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|char
modifier|*
name|oldCp
init|=
name|cp
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
return|return
name|oldCp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t r i n c m p ** (jws) simplified the code a bit in hopes of appeasing Purify **************************************************************************/
end_comment

begin_function
name|int
name|strincmp
parameter_list|(
name|char
modifier|*
name|cp1
parameter_list|,
name|char
modifier|*
name|cp2
parameter_list|,
name|FICL_UNS
name|count
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
literal|0
operator|<
name|count
condition|;
operator|++
name|cp1
operator|,
operator|++
name|cp2
operator|,
operator|--
name|count
control|)
block|{
name|i
operator|=
name|tolower
argument_list|(
operator|*
name|cp1
argument_list|)
operator|-
name|tolower
argument_list|(
operator|*
name|cp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
elseif|else
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s k i p S p a c e ** Given a string pointer, returns a pointer to the first non-space ** char of the string, or to the NULL terminator if no such char found. ** If the pointer reaches "end" first, stop there. Pass NULL to  ** suppress this behavior. **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|skipSpace
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|!=
name|end
operator|)
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

end_unit

