begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** w o r d s . c ** Forth Inspired Command Language ** ANS Forth CORE word-set written in C ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 ** $Id: words.c,v 1.17 2001/12/05 07:21:34 jsadler Exp $ *******************************************************************/
end_comment

begin_comment
comment|/* ** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu) ** All rights reserved. ** ** Get the latest Ficl release at http://ficl.sourceforge.net ** ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release, please ** contact me by email at the address above. ** ** L I C E N S E  and  D I S C L A I M E R **  ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_include
include|#
directive|include
file|"math64.h"
end_include

begin_function_decl
specifier|static
name|void
name|colonParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|literalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ficlParseWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** Control structure building words use these ** strings' addresses as markers on the stack to  ** check for structure completion. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|doTag
index|[]
init|=
literal|"do"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|colonTag
index|[]
init|=
literal|"colon"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|leaveTag
index|[]
init|=
literal|"leave"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|destTag
index|[]
init|=
literal|"target"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|origTag
index|[]
init|=
literal|"origin"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|caseTag
index|[]
init|=
literal|"case"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ofTag
index|[]
init|=
literal|"of"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fallthroughTag
index|[]
init|=
literal|"fallthrough"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_function_decl
specifier|static
name|void
name|doLocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do2LocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** C O N T R O L   S T R U C T U R E   B U I L D E R S ** ** Push current dict location for later branch resolution. ** The location may be either a branch target or a patch address... */
end_comment

begin_function
specifier|static
name|void
name|markBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|PUSHPTR
argument_list|(
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|markControlTag
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|PUSHPTR
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|matchControlTag
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/*     ** Changed the code below to compare the pointers first (by popular demand)     */
if|if
condition|(
operator|(
name|cp
operator|!=
name|tag
operator|)
operator|&&
name|strcmp
argument_list|(
name|cp
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error -- unmatched control structure \"%s\""
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** Expect a branch target address on the param stack, ** compile a literal offset from the current dict location ** to the target address */
end_comment

begin_function
specifier|static
name|void
name|resolveBackBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|FICL_INT
name|offset
decl_stmt|;
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|offset
operator|=
name|patchAddr
operator|-
name|dp
operator|->
name|here
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Expect a branch patch address on the param stack, ** compile a literal offset from the patch location ** to the current dict location */
end_comment

begin_function
specifier|static
name|void
name|resolveForwardBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|FICL_INT
name|offset
decl_stmt|;
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|offset
operator|=
name|dp
operator|->
name|here
operator|-
name|patchAddr
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Match the tag to the top of the stack. If success, ** sopy "here" address into the cell whose address is next ** on the stack. Used by do..leave..loop. */
end_comment

begin_function
specifier|static
name|void
name|resolveAbsBranch
parameter_list|(
name|FICL_DICT
modifier|*
name|dp
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/*     ** Changed the comparison below to compare the pointers first (by popular demand)     */
if|if
condition|(
operator|(
name|cp
operator|!=
name|tag
operator|)
operator|&&
name|strcmp
argument_list|(
name|cp
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"Warning -- Unmatched control word: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|tag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l P a r s e N u m b e r ** Attempts to convert the NULL terminated string in the VM's pad to  ** a number using the VM's current base. If successful, pushes the number ** onto the param stack and returns TRUE. Otherwise, returns FALSE. ** (jws 8/01) Trailing decimal point causes a zero cell to be pushed. (See ** the standard for DOUBLE wordset. **************************************************************************/
end_comment

begin_function
name|int
name|ficlParseNumber
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|FICL_INT
name|accum
init|=
literal|0
decl_stmt|;
name|char
name|isNeg
init|=
name|FALSE
decl_stmt|;
name|char
name|hasDP
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|base
init|=
name|pVM
operator|->
name|base
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|SI_PTR
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|FICL_COUNT
name|count
init|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|unsigned
name|ch
decl_stmt|;
name|unsigned
name|digit
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'-'
case|:
name|cp
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|isNeg
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|cp
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|isNeg
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cp
index|[
name|count
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
comment|/* detect& remove trailing decimal */
block|{
name|hasDP
operator|=
name|TRUE
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* detect "+", "-", ".", "+." etc */
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|count
operator|--
operator|)
operator|&&
operator|(
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|ch
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|digit
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
name|digit
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
name|base
condition|)
return|return
name|FALSE
return|;
name|accum
operator|=
name|accum
operator|*
name|base
operator|+
name|digit
expr_stmt|;
block|}
if|if
condition|(
name|hasDP
condition|)
comment|/* simple (required) DOUBLE support */
name|PUSHINT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNeg
condition|)
name|accum
operator|=
operator|-
name|accum
expr_stmt|;
name|PUSHINT
argument_list|(
name|accum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
condition|)
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a d d&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|add
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|+=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sub
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
operator|-
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mul
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|*=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|negate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|-
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlDiv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
operator|/
name|i
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** slash-mod        CORE ( n1 n2 -- n3 n4 ) ** Divide n1 by n2, giving the single-cell remainder n3 and the single-cell ** quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 ** differ in sign, the implementation-defined result returned will be the ** same as that returned by either the phrase **>R S>D R> FM/MOD or the phrase>R S>D R> SM/REM .  ** NOTE: Ficl complies with the second phrase (symmetric division) */
end_comment

begin_function
specifier|static
name|void
name|slashMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|n1
decl_stmt|;
name|FICL_INT
name|n2
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n2
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|n1
operator|.
name|lo
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|i64Extend
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|onePlus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|oneMinus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoMul
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoDiv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|i
operator|>>=
literal|1
expr_stmt|;
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mulDiv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|DPINT
name|prod
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|z
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|prod
operator|=
name|m64MulI
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|m64SymmetricDivI
argument_list|(
name|prod
argument_list|,
name|z
argument_list|)
operator|.
name|quot
expr_stmt|;
name|PUSHINT
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mulDivRem
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|DPINT
name|prod
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|z
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|prod
operator|=
name|m64MulI
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|prod
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o l o n   d e f i n i t i o n s ** Code to begin compiling a colon definition ** This function sets the state to COMPILE, then creates a ** new word whose name is the next word in the input stream ** and whose code is colonParen. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|colon
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dictCheckThreshold
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|COMPILE
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|colonTag
argument_list|)
expr_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|colonParen
argument_list|,
name|FW_DEFAULT
operator||
name|FW_SMUDGE
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o l o n P a r e n ** This is the code that executes a colon definition. It assumes that the ** virtual machine is running a "next" loop (See the vm.c ** for its implementation of member function vmExecute()). The colon ** code simply copies the address of the first word in the list of words ** to interpret into IP after saving its old value. When we return to the ** "next" loop, the virtual machine will call the code for each word in  ** turn. ** **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|colonParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|IPTYPE
name|tempIP
init|=
call|(
name|IPTYPE
call|)
argument_list|(
name|pVM
operator|->
name|runningWord
operator|->
name|param
argument_list|)
decl_stmt|;
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
name|tempIP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s e m i c o l o n C o I m **  ** IMMEDIATE code for ";". This function sets the state to INTERPRET and ** terminates a word under compilation by appending code for "(;)" to ** the definition. TO DO: checks for leftover branch target tags on the ** return stack and complains if any are found. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|semiParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|semicolonCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pSemiParen
argument_list|)
expr_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|colonTag
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pUnLinkParen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>
literal|0
condition|)
block|{
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|)
decl_stmt|;
name|dictEmpty
argument_list|(
name|pLoc
argument_list|,
name|pLoc
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pUnLinkParen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pSemiParen
argument_list|)
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|INTERPRET
expr_stmt|;
name|dictUnsmudge
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e x i t ** CORE ** This function simply pops the previous instruction ** pointer and returns to the "next" loop. Used for exiting from within ** a definition. Note that exitParen is identical to semiParen - they ** are in two different functions so that "see" can correctly identify ** the end of a colon definition, even if it uses "exit". **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|exitParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|exitCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pExitParen
argument_list|)
expr_stmt|;
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>
literal|0
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pUnLinkParen
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pExitParen
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o n s t a n t P a r e n ** This is the run-time code for "constant". It simply returns the  ** contents of its word's first data cell. ** **************************************************************************/
end_comment

begin_function
name|void
name|constantParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|twoConstParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* lo */
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pFW
operator|->
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* hi */
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o n s t a n t ** IMMEDIATE ** Compiles a constant into the dictionary. Constants return their ** value when invoked. Expects a value on top of the parm stack. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|constant
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|constantParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoConstant
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|twoConstParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i s p l a y C e l l ** Drop and print the contents of the cell at the top of the param ** stack **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|displayCell
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ltoa
argument_list|(
operator|(
name|c
operator|)
operator|.
name|i
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uDot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ultoa
argument_list|(
name|u
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hexDot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ultoa
argument_list|(
name|u
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t r l e n ** FICL   ( c-string -- length ) ** ** Returns the length of a C-style (zero-terminated) string. ** ** --lch **/
end_comment

begin_function
specifier|static
name|void
name|ficlStrlen
parameter_list|(
name|FICL_VM
modifier|*
name|ficlVM
parameter_list|)
block|{
name|char
modifier|*
name|address
init|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|ficlVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|stackPushINT
argument_list|(
name|ficlVM
operator|->
name|pStack
argument_list|,
name|strlen
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s p r i n t f ** FICL   ( i*x c-addr-fmt u-fmt c-addr-buffer u-buffer -- c-addr-buffer u-written success-flag ) ** Similar to the C sprintf() function.  It formats into a buffer based on ** a "format" string.  Each character in the format string is copied verbatim ** to the output buffer, until SPRINTF encounters a percent sign ("%"). ** SPRINTF then skips the percent sign, and examines the next character ** (the "format character").  Here are the valid format characters: **    s - read a C-ADDR U-LENGTH string from the stack and copy it to **        the buffer **    d - read a cell from the stack, format it as a string (base-10, **        signed), and copy it to the buffer **    x - same as d, except in base-16 **    u - same as d, but unsigned **    % - output a literal percent-sign to the buffer ** SPRINTF returns the c-addr-buffer argument unchanged, the number of bytes ** written, and a flag indicating whether or not it ran out of space while ** writing to the output buffer (TRUE if it ran out of space). ** ** If SPRINTF runs out of space in the buffer to store the formatted string, ** it still continues parsing, in an effort to preserve your stack (otherwise ** it might leave uneaten arguments behind). ** ** --lch **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlSprintf
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
comment|/*  */
block|{
name|int
name|bufferLength
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bufferStart
init|=
name|buffer
decl_stmt|;
name|int
name|formatLength
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|format
init|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|formatStop
init|=
name|format
operator|+
name|formatLength
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|unsignedInteger
init|=
name|FALSE
decl_stmt|;
name|FICL_INT
name|append
init|=
name|FICL_TRUE
decl_stmt|;
while|while
condition|(
name|format
operator|<
name|formatStop
condition|)
block|{
name|char
name|scratch
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|source
decl_stmt|;
name|int
name|actualLength
decl_stmt|;
name|int
name|desiredLength
decl_stmt|;
name|int
name|leadingZeroes
decl_stmt|;
if|if
condition|(
operator|*
name|format
operator|!=
literal|'%'
condition|)
block|{
name|source
operator|=
name|format
expr_stmt|;
name|actualLength
operator|=
name|desiredLength
operator|=
literal|1
expr_stmt|;
name|leadingZeroes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|formatStop
condition|)
break|break;
name|leadingZeroes
operator|=
operator|(
operator|*
name|format
operator|==
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|leadingZeroes
condition|)
block|{
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|formatStop
condition|)
break|break;
block|}
name|desiredLength
operator|=
name|isdigit
argument_list|(
operator|*
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|desiredLength
condition|)
block|{
name|desiredLength
operator|=
name|strtol
argument_list|(
name|format
argument_list|,
operator|&
name|format
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|formatStop
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|format
operator|==
literal|'*'
condition|)
block|{
name|desiredLength
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|format
operator|==
name|formatStop
condition|)
break|break;
block|}
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
block|{
name|actualLength
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|source
operator|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|base
operator|=
literal|16
expr_stmt|;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|unsignedInteger
operator|=
name|TRUE
expr_stmt|;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
block|{
name|int
name|integer
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
if|if
condition|(
name|unsignedInteger
condition|)
name|ultoa
argument_list|(
name|integer
argument_list|,
name|scratch
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|else
name|ltoa
argument_list|(
name|integer
argument_list|,
name|scratch
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
name|unsignedInteger
operator|=
name|FALSE
expr_stmt|;
name|source
operator|=
name|scratch
expr_stmt|;
name|actualLength
operator|=
name|strlen
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'%'
case|:
name|source
operator|=
name|format
expr_stmt|;
name|actualLength
operator|=
literal|1
expr_stmt|;
default|default:
continue|continue;
block|}
block|}
if|if
condition|(
name|append
operator|!=
name|FICL_FALSE
condition|)
block|{
if|if
condition|(
operator|!
name|desiredLength
condition|)
name|desiredLength
operator|=
name|actualLength
expr_stmt|;
if|if
condition|(
name|desiredLength
operator|>
name|bufferLength
condition|)
block|{
name|append
operator|=
name|FICL_FALSE
expr_stmt|;
name|desiredLength
operator|=
name|bufferLength
expr_stmt|;
block|}
while|while
condition|(
name|desiredLength
operator|>
name|actualLength
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|leadingZeroes
operator|)
condition|?
literal|'0'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|bufferLength
operator|--
expr_stmt|;
name|desiredLength
operator|--
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|source
argument_list|,
name|actualLength
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|actualLength
expr_stmt|;
name|bufferLength
operator|-=
name|actualLength
expr_stmt|;
block|}
name|format
operator|++
expr_stmt|;
block|}
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|bufferStart
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|buffer
operator|-
name|bufferStart
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|append
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d u p&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|depth
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackDepth
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|drop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackDrop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoDrop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackDrop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoDup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|over
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoOver
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|pick
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
name|c
operator|.
name|i
operator|+
literal|1
argument_list|,
name|c
operator|.
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|questionDup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|!=
literal|0
condition|)
name|stackPick
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|roll
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|minusRoll
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
init|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|rot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|swap
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoSwap
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e m i t&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|emit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|pVM
operator|->
name|pad
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|commentLine
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pEnd
init|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
name|ch
init|=
operator|*
name|cp
decl_stmt|;
while|while
condition|(
operator|(
name|cp
operator|!=
name|pEnd
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|)
block|{
name|ch
operator|=
operator|*
operator|++
name|cp
expr_stmt|;
block|}
comment|/*     ** Cope with DOS or UNIX-style EOLs -     ** Check for /r, /n, /r/n, or /n/r end-of-line sequences,     ** and point cp to next char. If EOL is \0, we're done.     */
if|if
condition|(
name|cp
operator|!=
name|pEnd
condition|)
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|!=
name|pEnd
operator|)
operator|&&
operator|(
name|ch
operator|!=
operator|*
name|cp
operator|)
operator|&&
operator|(
operator|(
operator|*
name|cp
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** paren CORE  ** Compilation: Perform the execution semantics given below. ** Execution: ( "ccc<paren>" -- ) ** Parse ccc delimited by ) (right parenthesis). ( is an immediate word.  ** The number of characters in ccc may be zero to the number of characters ** in the parse area.  **  */
end_comment

begin_function
specifier|static
name|void
name|commentHang
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
literal|')'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         F E T C H&   S T O R E **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
name|pCell
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** two-fetch    CORE ( a-addr -- x1 x2 ) ** Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and ** x1 at the next consecutive cell. It is equivalent to the sequence ** DUP CELL+ @ SWAP @ .  */
end_comment

begin_function
specifier|static
name|void
name|twoFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
name|pCell
operator|++
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
operator|*
name|pCell
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** store        CORE ( x a-addr -- ) ** Store x at a-addr.  */
end_comment

begin_function
specifier|static
name|void
name|store
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pCell
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** two-store    CORE ( x1 x2 a-addr -- ) ** Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the ** next consecutive cell. It is equivalent to the sequence ** SWAP OVER ! CELL+ ! .  */
end_comment

begin_function
specifier|static
name|void
name|twoStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pCell
operator|++
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pCell
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|plusStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pCell
operator|->
name|i
operator|+=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quadFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS32
modifier|*
name|pw
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
operator|(
name|UNS32
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
operator|(
name|FICL_UNS
operator|)
operator|*
name|pw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|quadStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS32
modifier|*
name|pw
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
operator|(
name|UNS32
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pw
operator|=
call|(
name|UNS32
call|)
argument_list|(
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS16
modifier|*
name|pw
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
operator|(
name|UNS16
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
operator|(
name|FICL_UNS
operator|)
operator|*
name|pw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS16
modifier|*
name|pw
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
operator|(
name|UNS16
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pw
operator|=
call|(
name|UNS16
call|)
argument_list|(
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS8
modifier|*
name|pc
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pc
operator|=
operator|(
name|UNS8
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
operator|(
name|FICL_UNS
operator|)
operator|*
name|pc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|UNS8
modifier|*
name|pc
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pc
operator|=
operator|(
name|UNS8
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
operator|*
name|pc
operator|=
call|(
name|UNS8
call|)
argument_list|(
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b r a n c h P a r e n **  ** Runtime for "(branch)" -- expects a literal offset in the next ** compilation address, and branches to that location. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|branchParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b r a n c h 0 ** Runtime code for "(branch0)"; pop a flag from the stack, ** branch if 0. fall through otherwise.  The heart of "if" and "until". **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|branch0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|flag
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flag
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
comment|/* fall through */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take branch (to else/endif/begin) */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i f C o I m ** IMMEDIATE COMPILE-ONLY ** Compiles code for a conditional branch into the dictionary ** and pushes the branch patch address on the stack for later ** patching by ELSE or THEN/ENDIF.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ifCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranch0
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranch0
argument_list|)
argument_list|)
expr_stmt|;
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e l s e C o I m **  ** IMMEDIATE COMPILE-ONLY ** compiles an "else"... ** 1) Compile a branch and a patch address; the address gets patched **    by "endif" to point past the "else" code. ** 2) Pop the the "if" patch address ** 3) Patch the "if" branch to point to the current compile address. ** 4) Push the "else" patch address. ("endif" patches this to jump past  **    the "else" code. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elseCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|FICL_INT
name|offset
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
expr_stmt|;
comment|/* (1) compile branch runtime */
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* (2) pop "if" patch addr */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
comment|/* (4) push "else" patch addr */
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* (1) compile patch placeholder */
name|offset
operator|=
name|dp
operator|->
name|here
operator|-
name|patchAddr
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* (3) Patch "if" */
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e n d i f C o I m ** IMMEDIATE COMPILE-ONLY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|endifCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|resolveForwardBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c a s e C o I m ** IMMEDIATE COMPILE-ONLY ** ** ** At compile-time, a CASE-SYS (see DPANS94 6.2.0873) looks like this: **			i*addr i caseTag ** and an OF-SYS (see DPANS94 6.2.1950) looks like this: **			i*addr i caseTag addr ofTag ** The integer under caseTag is the count of fixup addresses that branch ** to ENDCASE. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|caseCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHUNS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e n d c a s eC o I m ** IMMEDIATE COMPILE-ONLY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|endcaseCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|fixupCount
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
decl_stmt|;
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|FICL_INT
name|offset
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pDrop
argument_list|)
expr_stmt|;
comment|/* 	** if the last OF ended with FALLTHROUGH, 	** just add the FALLTHROUGH fixup to the 	** ENDOF fixups 	*/
if|if
condition|(
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|p
operator|==
name|fallthroughTag
condition|)
block|{
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|fallthroughTag
argument_list|)
expr_stmt|;
name|patchAddr
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
name|fixupCount
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|PUSHPTR
argument_list|(
name|patchAddr
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|fixupCount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
block|}
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fixupCount
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
name|fixupCount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pDrop
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fixupCount
operator|--
condition|)
block|{
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|offset
operator|=
name|dp
operator|->
name|here
operator|-
name|patchAddr
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ofParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|a
decl_stmt|,
name|b
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|b
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|u
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|b
condition|)
block|{
comment|/* fall through */
name|stackDrop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take branch to next of or endswitch */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         o f C o I m ** IMMEDIATE COMPILE-ONLY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ofCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|CELL
modifier|*
name|fallthroughFixup
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranch0
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|p
operator|==
name|fallthroughTag
condition|)
block|{
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|fallthroughTag
argument_list|)
expr_stmt|;
name|fallthroughFixup
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
block|}
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pOfParen
argument_list|)
argument_list|)
expr_stmt|;
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|ofTag
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallthroughFixup
operator|!=
name|NULL
condition|)
block|{
name|FICL_INT
name|offset
init|=
name|dp
operator|->
name|here
operator|-
name|fallthroughFixup
decl_stmt|;
operator|*
name|fallthroughFixup
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                     e n d o f C o I m ** IMMEDIATE COMPILE-ONLY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|endofCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|FICL_UNS
name|fixupCount
decl_stmt|;
name|FICL_INT
name|offset
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
expr_stmt|;
comment|/* ensure we're in an OF, */
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|ofTag
argument_list|)
expr_stmt|;
comment|/* grab the address of the branch location after the OF */
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* ensure we're also in a "case" */
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
comment|/* grab the current number of ENDOF fixups */
name|fixupCount
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
comment|/* compile branch runtime */
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* push a new ENDOF fixup, the updated count of ENDOF fixups, and the caseTag */
name|PUSHPTR
argument_list|(
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|fixupCount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
comment|/* reserve space for the ENDOF fixup */
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* and patch the original OF */
name|offset
operator|=
name|dp
operator|->
name|here
operator|-
name|patchAddr
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                     f a l l t h r o u g h C o I m ** IMMEDIATE COMPILE-ONLY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fallthroughCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|patchAddr
decl_stmt|;
name|FICL_INT
name|offset
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ensure we're in an OF, */
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|ofTag
argument_list|)
expr_stmt|;
comment|/* grab the address of the branch location after the OF */
name|patchAddr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* ensure we're also in a "case" */
name|matchControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
comment|/* okay, here we go.  put the case tag back. */
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|caseTag
argument_list|)
expr_stmt|;
comment|/* compile branch runtime */
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* push a new FALLTHROUGH fixup and the fallthroughTag */
name|PUSHPTR
argument_list|(
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|fallthroughTag
argument_list|)
expr_stmt|;
comment|/* reserve space for the FALLTHROUGH fixup */
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* and patch the original OF */
name|offset
operator|=
name|dp
operator|->
name|here
operator|-
name|patchAddr
expr_stmt|;
operator|*
name|patchAddr
operator|=
name|LVALUEtoCELL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         h a s h ** hash ( c-addr u -- code) ** calculates hashcode of specified string and leaves it on the stack **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hash
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|hashHashCode
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i n t e r p r e t  ** This is the "user interface" of a Forth. It does the following: **   while there are words in the VM's Text Input Buffer **     Copy next word into the pad (vmGetWord) **     Attempt to find the word in the dictionary (dictLookup) **     If successful, execute the word. **     Otherwise, attempt to convert the word to a number (isNumber) **     If successful, push the number onto the parameter stack. **     Otherwise, print an error message and exit loop... **   End Loop ** ** From the standard, section 3.4 ** Text interpretation (see 6.1.1360 EVALUATE and 6.1.2050 QUIT) shall ** repeat the following steps until either the parse area is empty or an  ** ambiguous condition exists:  ** a) Skip leading spaces and parse a name (see 3.4.1);  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|interpret
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FICL_SYSTEM
modifier|*
name|pSys
decl_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|pSys
operator|=
name|pVM
operator|->
name|pSys
expr_stmt|;
name|si
operator|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
comment|/*     ** Get next word...if out of text, we're done.     */
if|if
condition|(
name|si
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_OUTOFTEXT
argument_list|)
expr_stmt|;
block|}
comment|/*     ** Attempt to find the incoming token in the dictionary. If that fails...     ** run the parse chain against the incoming token until somebody eats it.     ** Otherwise emit an error message and give up.     ** Although ficlParseWord could be part of the parse list, I've hard coded it     ** in for robustness. ficlInitSystem adds the other default steps to the list.     */
if|if
condition|(
name|ficlParseWord
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FICL_MAX_PARSE_STEPS
condition|;
name|i
operator|++
control|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pSys
operator|->
name|parseList
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pFW
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pFW
operator|->
name|code
operator|==
name|parseStepParen
condition|)
block|{
name|FICL_PARSE_STEP
name|pStep
decl_stmt|;
name|pStep
operator|=
call|(
name|FICL_PARSE_STEP
call|)
argument_list|(
name|pFW
operator|->
name|param
operator|->
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|pStep
call|)
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|stackPushUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|ficlExecXT
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
condition|)
return|return;
block|}
block|}
name|i
operator|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not found"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* back to inner interpreter */
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l P a r s e W o r d ** From the standard, section 3.4 ** b) Search the dictionary name space (see 3.4.2). If a definition name ** matching the string is found:  **  1.if interpreting, perform the interpretation semantics of the definition **  (see 3.4.3.2), and continue at a);  **  2.if compiling, perform the compilation semantics of the definition **  (see 3.4.3.3), and continue at a).  ** ** c) If a definition name matching the string is not found, attempt to ** convert the string to a number (see 3.4.1.3). If successful:  **  1.if interpreting, place the number on the data stack, and continue at a);  **  2.if compiling, compile code that when executed will place the number on **  the stack (see 6.1.1780 LITERAL), and continue at a);  ** ** d) If unsuccessful, an ambiguous condition exists (see 3.4.4).  ** ** (jws 4/01) Modified to be a FICL_PARSE_STEP **************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ficlParseWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|tempFW
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
name|dictCheck
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>
literal|0
condition|)
block|{
name|tempFW
operator|=
name|ficlLookupLoc
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|tempFW
operator|=
name|dictLookup
argument_list|(
name|dp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
if|if
condition|(
name|tempFW
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wordIsCompileOnly
argument_list|(
name|tempFW
argument_list|)
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: Compile only!"
argument_list|)
expr_stmt|;
block|}
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|tempFW
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|FICL_TRUE
return|;
block|}
block|}
else|else
comment|/* (pVM->state == COMPILE) */
block|{
if|if
condition|(
name|tempFW
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wordIsImmediate
argument_list|(
name|tempFW
argument_list|)
condition|)
block|{
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|tempFW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|tempFW
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|FICL_TRUE
return|;
block|}
block|}
return|return
name|FICL_FALSE
return|;
block|}
end_function

begin_comment
comment|/* ** Surrogate precompiled parse step for ficlParseWord (this step is hard coded in  ** INTERPRET) */
end_comment

begin_function
specifier|static
name|void
name|lookup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ficlParseWord
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p a r e n P a r s e S t e p ** (parse-step)  ( c-addr u -- flag ) ** runtime for a precompiled parse step - pop a counted string off the ** stack, run the parse step against it, and push the result flag (FICL_TRUE ** if success, FICL_FALSE otherwise). **************************************************************************/
end_comment

begin_function
name|void
name|parseStepParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
name|FICL_PARSE_STEP
name|pStep
init|=
call|(
name|FICL_PARSE_STEP
call|)
argument_list|(
name|pFW
operator|->
name|param
operator|->
name|fn
argument_list|)
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
call|(
modifier|*
name|pStep
call|)
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|addParseStep
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pStep
decl_stmt|;
name|FICL_DICT
modifier|*
name|pd
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pStep
operator|=
operator|(
name|FICL_WORD
operator|*
operator|)
operator|(
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|p
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pStep
operator|!=
name|NULL
operator|)
operator|&&
name|isAFiclWord
argument_list|(
name|pd
argument_list|,
name|pStep
argument_list|)
condition|)
name|ficlAddParseStep
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
name|pStep
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l i t e r a l P a r e n **  ** This is the runtime for (literal). It assumes that it is part of a colon ** definition, and that the next CELL contains a value to be pushed on the ** parameter stack at runtime. This code is compiled by "literal". ** **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|literalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHINT
argument_list|(
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoLitParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHINT
argument_list|(
operator|*
operator|(
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l i t e r a l I m **  ** IMMEDIATE code for "literal". This function gets a value from the stack  ** and compiles it into the dictionary preceded by the code for "(literal)". ** IMMEDIATE **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|literalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pLitParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pLitParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoLiteralIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pTwoLitParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pTwoLitParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l o g i c   a n d   c o m p a r i s o n s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|zeroEquals
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|zeroLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|zeroGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|isEqual
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_BOOL
argument_list|(
name|x
operator|.
name|i
operator|==
name|y
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|isLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_BOOL
argument_list|(
name|x
operator|.
name|i
operator|<
name|y
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uIsLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u1
decl_stmt|,
name|u2
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u2
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|u1
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_BOOL
argument_list|(
name|u1
operator|<
name|u2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|isGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_BOOL
argument_list|(
name|x
operator|.
name|i
operator|>
name|y
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseAnd
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|x
operator|.
name|i
operator|&
name|y
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseOr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|x
operator|.
name|i
operator||
name|y
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseXor
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|y
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|x
operator|.
name|i
operator|^
name|y
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bitwiseNot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|x
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
operator|~
name|x
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                                D o  /  L o o p ** do -- IMMEDIATE COMPILE ONLY **    Compiles code to initialize a loop: compile (do),  **    allot space to hold the "leave" address, push a branch **    target address for the loop. ** (do) -- runtime for "do" **    pops index and limit from the p stack and moves them **    to the r stack, then skips to the loop body. ** loop -- IMMEDIATE COMPILE ONLY ** +loop **    Compiles code for the test part of a loop: **    compile (loop), resolve forward branch from "do", and **    copy "here" address to the "leave" address allotted by "do" ** i,j,k -- COMPILE ONLY **    Runtime: Push loop indices on param stack (i is innermost loop...) **    Note: each loop has three values on the return stack: **    ( R: leave limit index ) **    "leave" is the absolute address of the next cell after the loop **    limit and index are the loop control variables. ** leave -- COMPILE ONLY **    Runtime: pop the loop control variables, then pop the **    "leave" address and jump (absolute) there. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|doCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pDoParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pDoParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     ** Allot space for a pointer to the end     ** of the loop - "leave" uses this...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*     ** Mark location of head of loop...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
decl_stmt|,
name|limit
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|index
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|limit
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* copy "leave" target addr to stack */
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|qDoCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pQDoParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pQDoParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     ** Allot space for a pointer to the end     ** of the loop - "leave" uses this...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*     ** Mark location of head of loop...     */
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|qDoParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
decl_stmt|,
name|limit
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|index
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|limit
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/* copy "leave" target addr to stack */
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|.
name|u
operator|==
name|index
operator|.
name|u
condition|)
block|{
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** Runtime code to break out of a do..loop construct ** Drop the loop control variables; the branch address ** past "loop" is next on the return stack. */
end_comment

begin_function
specifier|static
name|void
name|leaveCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
comment|/* almost unloop */
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* exit */
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|unloopCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pLoopParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pLoopParen
argument_list|)
argument_list|)
expr_stmt|;
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
name|resolveAbsBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|plusLoopCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pPLoopParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pPLoopParen
argument_list|)
argument_list|)
expr_stmt|;
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|doTag
argument_list|)
expr_stmt|;
name|resolveAbsBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|leaveTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|index
init|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
operator|.
name|i
decl_stmt|;
name|FICL_INT
name|limit
init|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|1
argument_list|)
operator|.
name|i
decl_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* nuke the loop indices& "leave" addr */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fall through the loop */
block|}
else|else
block|{
comment|/* update index, branch to loop head */
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|plusLoopParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|index
decl_stmt|,
name|limit
decl_stmt|,
name|increment
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|index
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
operator|.
name|i
expr_stmt|;
name|limit
operator|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|1
argument_list|)
operator|.
name|i
expr_stmt|;
name|increment
operator|=
name|POP
argument_list|()
operator|.
name|i
expr_stmt|;
name|index
operator|+=
name|increment
expr_stmt|;
if|if
condition|(
name|increment
operator|<
literal|0
condition|)
name|flag
operator|=
operator|(
name|index
operator|<
name|limit
operator|)
expr_stmt|;
else|else
name|flag
operator|=
operator|(
name|index
operator|>=
name|limit
operator|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|stackDrop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* nuke the loop indices& "leave" addr */
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fall through the loop */
block|}
else|else
block|{
comment|/* update index, branch to loop head */
name|stackSetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|*
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopICo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
init|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopJCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
init|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|loopKCo
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|index
init|=
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         r e t u r n   s t a c k **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toRStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|POP
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fromRStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSH
argument_list|(
name|stackPop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetchRStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSH
argument_list|(
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|twoToR
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoRFrom
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
name|stackRoll
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoRFetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|stackFetch
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v a r i a b l e **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|variableParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|fw
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fw
operator|=
name|pVM
operator|->
name|runningWord
expr_stmt|;
name|PUSHPTR
argument_list|(
name|fw
operator|->
name|param
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|variable
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|variableParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAllotCells
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoVariable
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|variableParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAllotCells
argument_list|(
name|dp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b a s e&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|base
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pBase
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pBase
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
operator|&
name|pVM
operator|->
name|base
operator|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pBase
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|decimal
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|base
operator|=
literal|10
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hex
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|base
operator|=
literal|16
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a l l o t&   f r i e n d s **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|allot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
decl_stmt|;
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|i
operator|=
name|POPINT
argument_list|()
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
name|dictCheck
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dictAllot
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|here
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|dp
operator|->
name|here
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|comma
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
decl_stmt|;
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|c
operator|=
name|POP
argument_list|()
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cComma
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
decl_stmt|;
name|char
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|dictAppendChar
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cells
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
name|i
operator|*
operator|(
name|FICL_INT
operator|)
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cellPlus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|PUSHPTR
argument_list|(
name|cp
operator|+
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t i c k ** tick         CORE ( "<spaces>name" -- xt ) ** Skip leading space delimiters. Parse name delimited by a space. Find ** name and return xt, the execution token for name. An ambiguous condition ** exists if name is not found.  **************************************************************************/
end_comment

begin_function
name|void
name|ficlTick
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|NULL
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pFW
operator|=
name|dictLookup
argument_list|(
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pFW
condition|)
block|{
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not found"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUSHPTR
argument_list|(
name|pFW
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bracketTickCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|ficlTick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p o s t p o n e ** Lookup the next word in the input stream and compile code to  ** insert it into definitions created by the resulting word ** (defers compilation, even of immediate words) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|postponeCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|FICL_WORD
modifier|*
name|pComma
init|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
literal|","
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pComma
argument_list|)
expr_stmt|;
name|ficlTick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|stackGetTop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|wordIsImmediate
argument_list|(
name|pFW
argument_list|)
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pComma
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e x e c u t e ** Pop an execution token (pointer to a word) off the stack and ** run it **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|execute
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pFW
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         i m m e d i a t e ** Make the most recently compiled word IMMEDIATE -- it executes even ** in compile state (most often used for control compiling words ** such as IF, THEN, etc) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|immediate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictSetImmediate
argument_list|(
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|compileOnly
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictSetFlags
argument_list|(
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
argument_list|,
name|FW_COMPILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|setObjectFlag
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictSetFlags
argument_list|(
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
argument_list|,
name|FW_ISOBJECT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|isObject
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|flag
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
init|=
operator|(
name|FICL_WORD
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|flag
operator|=
operator|(
operator|(
name|pFW
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pFW
operator|->
name|flags
operator|&
name|FW_ISOBJECT
operator|)
operator|)
condition|?
name|FICL_TRUE
else|:
name|FICL_FALSE
expr_stmt|;
name|stackPushINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cstringLit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|sp
operator|->
name|text
decl_stmt|;
name|cp
operator|+=
name|sp
operator|->
name|count
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|alignPtr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|ip
operator|=
operator|(
name|IPTYPE
operator|)
operator|(
name|void
operator|*
operator|)
name|cp
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cstringQuoteIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
decl_stmt|;
name|vmGetString
argument_list|(
name|pVM
argument_list|,
name|sp
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* move HERE past string so it doesn't get overwritten.  --lch */
name|dictAllot
argument_list|(
name|dp
argument_list|,
name|sp
operator|->
name|count
operator|+
sizeof|sizeof
argument_list|(
name|FICL_COUNT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* COMPILE state */
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pCStringLit
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|here
operator|=
name|PTRtoCELL
name|vmGetString
argument_list|(
name|pVM
argument_list|,
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d o t Q u o t e ** IMMEDIATE word that compiles a string literal for later display ** Compile stringLit, then copy the bytes of the string from the TIB ** to the dictionary. Backpatch the count byte and align the dictionary. ** ** stringlit: Fetch the count from the dictionary, then push the address ** and count on the stack. Finally, update ip to point to the first ** aligned address after the string text. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stringLit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
name|FICL_COUNT
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
operator|(
name|FICL_STRING
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
expr_stmt|;
name|count
operator|=
name|sp
operator|->
name|count
expr_stmt|;
name|cp
operator|=
name|sp
operator|->
name|text
expr_stmt|;
name|PUSHPTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|count
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|alignPtr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|ip
operator|=
operator|(
name|IPTYPE
operator|)
operator|(
name|void
operator|*
operator|)
name|cp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dotQuoteCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pType
init|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
literal|"type"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pType
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pStringLit
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|here
operator|=
name|PTRtoCELL
name|vmGetString
argument_list|(
name|pVM
argument_list|,
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pType
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dotParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|pSrc
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pEnd
init|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pDest
init|=
name|pVM
operator|->
name|pad
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|/*     ** Note: the standard does not want leading spaces skipped (apparently)     */
for|for
control|(
name|ch
operator|=
operator|*
name|pSrc
init|;
operator|(
name|pEnd
operator|!=
name|pSrc
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|')'
operator|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|pSrc
control|)
operator|*
name|pDest
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|pDest
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|pEnd
operator|!=
name|pSrc
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|')'
operator|)
condition|)
name|pSrc
operator|++
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s l i t e r a l ** STRING  ** Interpretation: Interpretation semantics for this word are undefined. ** Compilation: ( c-addr1 u -- ) ** Append the run-time semantics given below to the current definition. ** Run-time:       ( -- c-addr2 u ) ** Return c-addr2 u describing a string consisting of the characters ** specified by c-addr1 u during compilation. A program shall not alter ** the returned string.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|sLiteralCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpDest
decl_stmt|;
name|FICL_UNS
name|u
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|u
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|cp
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pStringLit
argument_list|)
argument_list|)
expr_stmt|;
name|cpDest
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|here
expr_stmt|;
operator|*
name|cpDest
operator|++
operator|=
operator|(
name|char
operator|)
name|u
expr_stmt|;
for|for
control|(
init|;
name|u
operator|>
literal|0
condition|;
operator|--
name|u
control|)
block|{
operator|*
name|cpDest
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cpDest
operator|++
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|here
operator|=
name|PTRtoCELL
name|alignPtr
argument_list|(
name|cpDest
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t a t e ** Return the address of the VM's state member (must be sized the ** same as a CELL for this reason) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|state
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHPTR
argument_list|(
operator|&
name|pVM
operator|->
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c r e a t e . . . d o e s> ** Make a new word in the dictionary with the run-time effect of  ** a variable (push my address), but with extra space allotted ** for use by does> . **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|createParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
expr_stmt|;
name|PUSHPTR
argument_list|(
name|pCell
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|create
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dictCheckThreshold
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|createParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAllotCells
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doDoes
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
name|IPTYPE
name|tempIP
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
expr_stmt|;
name|tempIP
operator|=
call|(
name|IPTYPE
call|)
argument_list|(
operator|(
operator|*
name|pCell
operator|)
operator|.
name|p
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|pCell
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
name|tempIP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doesParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|dp
operator|->
name|smudge
operator|->
name|code
operator|=
name|doDoes
expr_stmt|;
name|dp
operator|->
name|smudge
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|ip
argument_list|)
expr_stmt|;
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|doesCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pUnLinkParen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>
literal|0
condition|)
block|{
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|)
decl_stmt|;
name|dictEmpty
argument_list|(
name|pLoc
argument_list|,
name|pLoc
operator|->
name|pForthWords
operator|->
name|size
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pUnLinkParen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pDoesParen
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t o   b o d y ** to-body      CORE ( xt -- a-addr ) ** a-addr is the data-field address corresponding to xt. An ambiguous ** condition exists if xt is not for a word defined via CREATE.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toBody
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
comment|/*#$-GUY CHANGE: Added robustness.-$#*/
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pFW
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|PUSHPTR
argument_list|(
name|pFW
operator|->
name|param
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** from-body       ficl ( a-addr -- xt ) ** Reverse effect of>body */
end_comment

begin_function
specifier|static
name|void
name|fromBody
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|()
operator|-
sizeof|sizeof
argument_list|(
name|FICL_WORD
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **>name        ficl ( xt -- c-addr u ) ** Push the address and length of a word's name given its address ** xt.  */
end_comment

begin_function
specifier|static
name|void
name|toName
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pFW
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|PUSHPTR
argument_list|(
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|pFW
operator|->
name|nName
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|getLastWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|wp
init|=
name|pDict
operator|->
name|smudge
decl_stmt|;
name|assert
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|vmPush
argument_list|(
name|pVM
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|wp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l b r a c k e t   e t c **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lbracketCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|state
operator|=
name|INTERPRET
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|rbracket
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|state
operator|=
name|COMPILE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p i c t u r e d   n u m e r i c   w o r d s ** ** less-number-sign CORE ( -- ) ** Initialize the pictured numeric output conversion process.  ** (clear the pad) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lessNumberSign
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
decl_stmt|;
name|sp
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** number-sign      CORE ( ud1 -- ud2 ) ** Divide ud1 by the number in BASE giving the quotient ud2 and the remainder ** n. (n is the least-significant digit of ud1.) Convert n to external form ** and add the resulting character to the beginning of the pictured numeric ** output  string. An ambiguous condition exists if # executes outside of a **<# #> delimited number conversion.  */
end_comment

begin_function
specifier|static
name|void
name|numberSign
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
name|DPUNS
name|u
decl_stmt|;
name|UNS16
name|rem
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
expr_stmt|;
name|u
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|rem
operator|=
name|m64UMod
argument_list|(
operator|&
name|u
argument_list|,
call|(
name|UNS16
call|)
argument_list|(
name|pVM
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
name|digit_to_char
argument_list|(
name|rem
argument_list|)
expr_stmt|;
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** number-sign-greater CORE ( xd -- c-addr u ) ** Drop xd. Make the pictured numeric output string available as a character ** string. c-addr and u specify the resulting character string. A program ** may replace characters within the string.  */
end_comment

begin_function
specifier|static
name|void
name|numberSignGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
expr_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|strrev
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|DROP
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|sp
operator|->
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** number-sign-s    CORE ( ud1 -- ud2 ) ** Convert one digit of ud1 according to the rule for #. Continue conversion ** until the quotient is zero. ud2 is zero. An ambiguous condition exists if ** #S executes outside of a<# #> delimited number conversion.  ** TO DO: presently does not use ud1 hi cell - use it! */
end_comment

begin_function
specifier|static
name|void
name|numberSignS
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
name|DPUNS
name|u
decl_stmt|;
name|UNS16
name|rem
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
expr_stmt|;
name|u
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
do|do
block|{
name|rem
operator|=
name|m64UMod
argument_list|(
operator|&
name|u
argument_list|,
call|(
name|UNS16
call|)
argument_list|(
name|pVM
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
name|digit_to_char
argument_list|(
name|rem
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|u
operator|.
name|hi
operator|||
name|u
operator|.
name|lo
condition|)
do|;
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** HOLD             CORE ( char -- ) ** Add char to the beginning of the pictured numeric output string. An ambiguous ** condition exists if HOLD executes outside of a<# #> delimited number conversion. */
end_comment

begin_function
specifier|static
name|void
name|hold
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
expr_stmt|;
name|i
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** SIGN             CORE ( n -- ) ** If n is negative, add a minus sign to the beginning of the pictured ** numeric output string. An ambiguous condition exists if SIGN ** executes outside of a<# #> delimited number conversion.  */
end_comment

begin_function
specifier|static
name|void
name|sign
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|PTRtoSTRING
name|pVM
operator|->
name|pad
expr_stmt|;
name|i
operator|=
name|POPINT
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t o   N u m b e r ** to-number CORE ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 ) ** ud2 is the unsigned result of converting the characters within the ** string specified by c-addr1 u1 into digits, using the number in BASE, ** and adding each into ud1 after multiplying ud1 by the number in BASE. ** Conversion continues left-to-right until a character that is not ** convertible, including any + or -, is encountered or the string is ** entirely converted. c-addr2 is the location of the first unconverted ** character or the first character past the end of the string if the string ** was entirely converted. u2 is the number of unconverted characters in the ** string. An ambiguous condition exists if ud2 overflows during the ** conversion.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toNumber
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|DPUNS
name|accum
decl_stmt|;
name|FICL_UNS
name|base
init|=
name|pVM
operator|->
name|base
decl_stmt|;
name|FICL_UNS
name|ch
decl_stmt|;
name|FICL_UNS
name|digit
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|()
expr_stmt|;
name|accum
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
operator|*
name|cp
init|;
name|count
operator|>
literal|0
condition|;
name|ch
operator|=
operator|*
operator|++
name|cp
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
name|ch
operator|<
literal|'0'
condition|)
break|break;
name|digit
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
name|digit
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
comment|/*          ** Note: following test also catches chars between 9 and a         ** because 'digit' is unsigned!          */
if|if
condition|(
name|digit
operator|>=
name|base
condition|)
break|break;
name|accum
operator|=
name|m64Mac
argument_list|(
name|accum
argument_list|,
name|base
argument_list|,
name|digit
argument_list|)
expr_stmt|;
block|}
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|accum
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         q u i t&   a b o r t ** quit CORE   ( -- )  ( R:  i*x -- ) ** Empty the return stack, store zero in SOURCE-ID if it is present, make ** the user input device the input source, and enter interpretation state.  ** Do not display a message. Repeat the following:  ** **   Accept a line from the input source into the input buffer, set>IN to **   zero, and interpret.  **   Display the implementation-defined system prompt if in **   interpretation state, all processing has been completed, and no **   ambiguous condition exists.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_QUIT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlAbort
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_ABORT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a c c e p t ** accept       CORE ( c-addr +n1 -- +n2 ) ** Receive a string of at most +n1 characters. An ambiguous condition ** exists if +n1 is zero or greater than 32,767. Display graphic characters ** as they are received. A program that depends on the presence or absence ** of non-graphic characters in the string has an environmental dependency. ** The editing functions, if any, that the system performs in order to ** construct the string are implementation-defined.  ** ** (Although the standard text doesn't say so, I assume that the intent  ** of 'accept' is to store the string at the address specified on ** the stack.) ** Implementation: if there's more text in the TIB, use it. Otherwise ** throw out for more text. Copy characters up to the max count into the ** address given, and return the number of actual characters copied. **  ** Note (sobral) this may not be the behavior you'd expect if you're ** trying to get user input at load time! **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|accept
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|count
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|pBuf
decl_stmt|,
modifier|*
name|pEnd
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pBuf
operator|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|pEnd
operator|=
name|vmGetInBufEnd
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|len
operator|=
name|pEnd
operator|-
name|pBuf
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_RESTART
argument_list|)
expr_stmt|;
comment|/*     ** Now we have something in the text buffer - use it      */
name|count
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|count
operator|<
name|len
operator|)
condition|?
name|count
else|:
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|cp
argument_list|,
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pBuf
operator|+=
name|len
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pBuf
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a l i g n ** 6.1.0705 ALIGN       CORE ( -- ) ** If the data-space pointer is not aligned, reserve enough space to ** align it.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|align
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a l i g n e d **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|aligned
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|PUSHPTR
argument_list|(
name|alignPtr
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b e g i n&   f r i e n d s ** Indefinite loop control structures ** A.6.1.0760 BEGIN  ** Typical use:  **      : X ... BEGIN ... test UNTIL ; ** or  **      : X ... BEGIN ... test WHILE ... REPEAT ; **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|beginCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|untilCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranch0
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranch0
argument_list|)
argument_list|)
expr_stmt|;
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|whileCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranch0
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranch0
argument_list|)
argument_list|)
expr_stmt|;
name|markBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
name|twoSwap
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendUNS
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|repeatCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* expect "begin" branch marker */
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
comment|/* expect "while" branch marker */
name|resolveForwardBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|origTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|againCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pBranchParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* expect "begin" branch marker */
name|resolveBackBranch
argument_list|(
name|dp
argument_list|,
name|pVM
argument_list|,
name|destTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c h a r&   f r i e n d s ** 6.1.0895 CHAR    CORE ( "<spaces>name" -- char ) ** Skip leading space delimiters. Parse name delimited by a space. ** Put the value of its first character onto the stack.  ** ** bracket-char     CORE  ** Interpretation: Interpretation semantics for this word are undefined. ** Compilation: ( "<spaces>name" -- ) ** Skip leading space delimiters. Parse name delimited by a space. ** Append the run-time semantics given below to the current definition.  ** Run-time: ( -- char ) ** Place char, the value of the first character of name, on the stack.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlChar
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|si
operator|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
call|(
name|FICL_UNS
call|)
argument_list|(
name|si
operator|.
name|cp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|charCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|ficlChar
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c h a r P l u s ** char-plus        CORE ( c-addr1 -- c-addr2 ) ** Add the size in address units of a character to c-addr1, giving c-addr2.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|charPlus
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|PUSHPTR
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c h a r s ** chars        CORE ( n1 -- n2 ) ** n2 is the size in address units of n1 characters.  ** For most processors, this function can be a no-op. To guarantee ** portability, we'll multiply by sizeof (char). **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ficlChars
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|>
literal|1
condition|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* otherwise no-op! */
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|default
name|:
name|4127
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         c o u n t ** COUNT    CORE ( c-addr1 -- c-addr2 u ) ** Return the character string specification for the counted string stored ** at c-addr1. c-addr2 is the address of the first character after c-addr1. ** u is the contents of the character at c-addr1, which is the length in ** characters of the string at c-addr2.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|count
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|PUSHPTR
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|sp
operator|->
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e n v i r o n m e n t ? ** environment-query CORE ( c-addr u -- false | i*x true ) ** c-addr is the address of a character string and u is the string's ** character count. u may have a value in the range from zero to an ** implementation-defined maximum which shall not be less than 31. The ** character string should contain a keyword from 3.2.6 Environmental ** queries or the optional word sets to be checked for correspondence ** with an attribute of the present environment. If the system treats the ** attribute as unknown, the returned flag is false; otherwise, the flag ** is true and the i*x returned is of the type specified in the table for ** the attribute queried.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|environmentQ
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|envp
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|envp
operator|=
name|pVM
operator|->
name|pSys
operator|->
name|envp
expr_stmt|;
name|si
operator|.
name|count
operator|=
operator|(
name|FICL_COUNT
operator|)
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|si
operator|.
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|envp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|!=
name|NULL
condition|)
block|{
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHINT
argument_list|(
name|FICL_FALSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e v a l u a t e ** EVALUATE CORE ( i*x c-addr u -- j*x ) ** Save the current input source specification. Store minus-one (-1) in ** SOURCE-ID if it is present. Make the string described by c-addr and u ** both the input source and input buffer, set>IN to zero, and interpret. ** When the parse area is empty, restore the prior input source ** specification. Other stack effects are due to the words EVALUATEd.  ** **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|evaluate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|CELL
name|id
decl_stmt|;
name|int
name|result
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|cp
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|IGNORE
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|id
operator|=
name|pVM
operator|->
name|sourceID
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|ficlExecC
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|VM_OUTOFTEXT
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t r i n g   q u o t e ** Interpreting: get string delimited by a quote from the input stream, ** copy to a scratch area, and put its count and address on the stack. ** Compiling: compile code to push the address and count of a string ** literal, compile the string from the input stream, and align the dict ** pointer. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stringQuoteIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
decl_stmt|;
name|vmGetString
argument_list|(
name|pVM
argument_list|,
name|sp
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|sp
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* COMPILE state */
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pStringLit
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|here
operator|=
name|PTRtoCELL
name|vmGetString
argument_list|(
name|pVM
argument_list|,
operator|(
name|FICL_STRING
operator|*
operator|)
name|dp
operator|->
name|here
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|dictAlign
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t y p e ** Pop count and char address from stack and print the designated string. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|type
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|count
init|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pDest
init|=
operator|(
name|char
operator|*
operator|)
name|ficlMalloc
argument_list|(
name|count
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/*      ** Since we don't have an output primitive for a counted string     ** (oops), make sure the string is null terminated. If not, copy     ** and terminate it.     */
if|if
condition|(
operator|!
name|pDest
condition|)
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: out of memory"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|pDest
argument_list|,
name|cp
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pDest
index|[
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pDest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|pDest
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         w o r d ** word CORE ( char "<chars>ccc<char>" -- c-addr ) ** Skip leading delimiters. Parse characters ccc delimited by char. An ** ambiguous condition exists if the length of the parsed string is greater ** than the implementation-defined length of a counted string.  **  ** c-addr is the address of a transient region containing the parsed word ** as a counted string. If the parse area was empty or contained no ** characters other than the delimiter, the resulting string has a zero ** length. A space, not included in the length, follows the string. A ** program may replace characters within the string.  ** NOTE! Ficl also NULL-terminates the dest string. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
operator|(
name|FICL_STRING
operator|*
operator|)
name|pVM
operator|->
name|pad
expr_stmt|;
name|delim
operator|=
operator|(
name|char
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|si
operator|=
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
name|delim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
name|nPAD
operator|-
literal|1
condition|)
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|nPAD
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|count
operator|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
comment|/*#$-GUY CHANGE: I added this.-$#*/
name|sp
operator|->
name|text
index|[
name|sp
operator|->
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|sp
operator|->
name|text
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p a r s e - w o r d ** ficl   PARSE-WORD  (<spaces>name -- c-addr u ) ** Skip leading spaces and parse name delimited by a space. c-addr is the ** address within the input buffer and u is the length of the selected  ** string. If the parse area is empty, the resulting string has a zero length. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|parseNoCopy
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|si
operator|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p a r s e ** CORE EXT  ( char "ccc<char>" -- c-addr u ) ** Parse ccc delimited by the delimiter char.  ** c-addr is the address (within the input buffer) and u is the length of  ** the parsed string. If the parse area was empty, the resulting string has ** a zero length.  ** NOTE! PARSE differs from WORD: it does not skip leading delimiters. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|parse
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|char
name|delim
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delim
operator|=
operator|(
name|char
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|si
operator|=
name|vmParseStringEx
argument_list|(
name|pVM
argument_list|,
name|delim
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i l l ** CORE ( c-addr u char -- ) ** If u is greater than zero, store char in each of u consecutive ** characters of memory beginning at c-addr.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fill
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
name|FICL_UNS
name|u
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ch
operator|=
operator|(
name|char
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|u
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|()
expr_stmt|;
while|while
condition|(
name|u
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|ch
expr_stmt|;
name|u
operator|--
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i n d ** FIND CORE ( c-addr -- c-addr 0  |  xt 1  |  xt -1 ) ** Find the definition named in the counted string at c-addr. If the ** definition is not found, return c-addr and zero. If the definition is ** found, return its execution token xt. If the definition is immediate, ** also return one (1), otherwise also return minus-one (-1). For a given ** string, the values returned by FIND while compiling may differ from ** those returned while not compiling.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|do_find
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|,
name|void
modifier|*
name|returnForFailure
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
condition|)
block|{
name|PUSHPTR
argument_list|(
name|pFW
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
operator|(
name|wordIsImmediate
argument_list|(
name|pFW
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHPTR
argument_list|(
name|returnForFailure
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i n d ** FIND CORE ( c-addr -- c-addr 0  |  xt 1  |  xt -1 ) ** Find the definition named in the counted string at c-addr. If the ** definition is not found, return c-addr and zero. If the definition is ** found, return its execution token xt. If the definition is immediate, ** also return one (1), otherwise also return minus-one (-1). For a given ** string, the values returned by FIND while compiling may differ from ** those returned while not compiling.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|cFind
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STRING
modifier|*
name|sp
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|SI_PFS
argument_list|(
name|si
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|do_find
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s f i n d ** FICL   ( c-addr u -- 0 0  |  xt 1  |  xt -1 ) ** Like FIND, but takes "c-addr u" for the string. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|sFind
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|si
operator|.
name|count
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|si
operator|.
name|cp
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|do_find
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f m S l a s h M o d ** f-m-slash-mod CORE ( d1 n1 -- n2 n3 ) ** Divide d1 by n1, giving the floored quotient n3 and the remainder n2. ** Input and output stack arguments are signed. An ambiguous condition ** exists if n1 is zero or if the quotient lies outside the range of a ** single-cell signed integer.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fmSlashMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|d1
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n1
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|d1
operator|=
name|i64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64FlooredDivI
argument_list|(
name|d1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s m S l a s h R e m ** s-m-slash-rem CORE ( d1 n1 -- n2 n3 ) ** Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2. ** Input and output stack arguments are signed. An ambiguous condition ** exists if n1 is zero or if the quotient lies outside the range of a ** single-cell signed integer.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|smSlashRem
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|d1
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n1
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|d1
operator|=
name|i64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|d1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|d1
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
name|INTQR
name|qr
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n1
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|d1
operator|.
name|lo
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|i64Extend
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64SymmetricDivI
argument_list|(
name|d1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         u m S l a s h M o d ** u-m-slash-mod CORE ( ud u1 -- u2 u3 ) ** Divide ud by u1, giving the quotient u3 and the remainder u2. ** All values and arithmetic are unsigned. An ambiguous condition ** exists if u1 is zero or if the quotient lies outside the range of a ** single-cell unsigned integer.  *************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|umSlashMod
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPUNS
name|ud
decl_stmt|;
name|FICL_UNS
name|u1
decl_stmt|;
name|UNSQR
name|qr
decl_stmt|;
name|u1
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ud
operator|=
name|u64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
name|u1
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
expr_stmt|;
name|PUSHUNS
argument_list|(
name|qr
operator|.
name|quot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l s h i f t ** l-shift CORE ( x1 u -- x2 ) ** Perform a logical left shift of u bit-places on x1, giving x2. ** Put zeroes into the least significant bits vacated by the shift. ** An ambiguous condition exists if u is greater than or equal to the ** number of bits in a cell.  ** ** r-shift CORE ( x1 u -- x2 ) ** Perform a logical right shift of u bit-places on x1, giving x2. ** Put zeroes into the most significant bits vacated by the shift. An ** ambiguous condition exists if u is greater than or equal to the ** number of bits in a cell.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lshift
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|nBits
decl_stmt|;
name|FICL_UNS
name|x1
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nBits
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|x1
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|PUSHUNS
argument_list|(
name|x1
operator|<<
name|nBits
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|rshift
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|nBits
decl_stmt|;
name|FICL_UNS
name|x1
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nBits
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|x1
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|PUSHUNS
argument_list|(
name|x1
operator|>>
name|nBits
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m S t a r ** m-star CORE ( n1 n2 -- d ) ** d is the signed product of n1 times n2.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mStar
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|n2
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
name|DPINT
name|d
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n2
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|n1
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|d
operator|=
name|m64MulI
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|i64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|umStar
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u2
decl_stmt|;
name|FICL_UNS
name|u1
decl_stmt|;
name|DPUNS
name|ud
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u2
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|u1
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|ud
operator|=
name|ficlLongMul
argument_list|(
name|u1
argument_list|,
name|u2
argument_list|)
expr_stmt|;
name|u64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|ud
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m a x&   m i n **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlMax
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|n2
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n2
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|n1
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
operator|(
name|n1
operator|>
name|n2
operator|)
condition|?
name|n1
else|:
name|n2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ficlMin
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|n2
decl_stmt|;
name|FICL_INT
name|n1
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n2
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|n1
operator|=
name|POPINT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
operator|(
name|n1
operator|<
name|n2
operator|)
condition|?
name|n1
else|:
name|n2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m o v e ** CORE ( addr1 addr2 u -- ) ** If u is greater than zero, copy the contents of u consecutive address ** units at addr1 to the u consecutive address units at addr2. After MOVE ** completes, the u consecutive address units at addr2 contain exactly ** what the u consecutive address units at addr1 contained before the move.  ** NOTE! This implementation assumes that a char is the same size as **       an address unit. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|move
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_UNS
name|u
decl_stmt|;
name|char
modifier|*
name|addr2
decl_stmt|;
name|char
modifier|*
name|addr1
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|addr2
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
name|addr1
operator|=
name|POPPTR
argument_list|()
expr_stmt|;
if|if
condition|(
name|u
operator|==
literal|0
condition|)
return|return;
comment|/*     ** Do the copy carefully, so as to be     ** correct even if the two ranges overlap     */
if|if
condition|(
name|addr1
operator|>=
name|addr2
condition|)
block|{
for|for
control|(
init|;
name|u
operator|>
literal|0
condition|;
name|u
operator|--
control|)
operator|*
name|addr2
operator|++
operator|=
operator|*
name|addr1
operator|++
expr_stmt|;
block|}
else|else
block|{
name|addr2
operator|+=
name|u
operator|-
literal|1
expr_stmt|;
name|addr1
operator|+=
name|u
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|u
operator|>
literal|0
condition|;
name|u
operator|--
control|)
operator|*
name|addr2
operator|--
operator|=
operator|*
name|addr1
operator|--
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         r e c u r s e **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|recurseCoIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|IGNORE
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pDict
operator|->
name|smudge
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t o d ** s-to-d CORE ( n -- d ) ** Convert the number n to the double-cell number d with the same ** numerical value.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|sToD
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|s
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|POPINT
argument_list|()
expr_stmt|;
comment|/* sign extend to 64 bits.. */
name|PUSHINT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
operator|(
name|s
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s o u r c e ** CORE ( -- c-addr u ) ** c-addr is the address of, and u is the number of characters in, the ** input buffer.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|source
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHPTR
argument_list|(
name|pVM
operator|->
name|tib
operator|.
name|cp
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|vmGetInBufLen
argument_list|(
name|pVM
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v e r s i o n ** non-standard... **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlVersion
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"ficl Version "
name|FICL_VER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         t o I n ** to-in CORE **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toIn
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHPTR
argument_list|(
operator|&
name|pVM
operator|->
name|tib
operator|.
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c o l o n N o N a m e ** CORE EXT ( C:  -- colon-sys )  ( S:  -- xt ) ** Create an unnamed colon definition and push its address. ** Change state to compile. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|colonNoName
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|COMPILE
expr_stmt|;
name|pFW
operator|=
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|colonParen
argument_list|,
name|FW_DEFAULT
operator||
name|FW_SMUDGE
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|pFW
argument_list|)
expr_stmt|;
name|markControlTag
argument_list|(
name|pVM
argument_list|,
name|colonTag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         u s e r   V a r i a b l e ** user  ( u -- )  "<spaces>name"   ** Get a name from the input stream and create a user variable ** with the name and the index supplied. The run-time effect ** of a user variable is to push the address of the indexed cell ** in the running vm's user array.  ** ** User variables are vm local cells. Each vm has an array of ** FICL_USER_CELLS of them when FICL_WANT_USER is nonzero. ** Ficl's user facility is implemented with two primitives, ** "user" and "(user)", a variable ("nUser") (in softcore.c) that  ** holds the index of the next free user cell, and a redefinition ** (also in softcore) of "user" that defines a user word and increments ** nUser. **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|FICL_WANT_USER
end_if

begin_function
specifier|static
name|void
name|userParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
name|PUSHPTR
argument_list|(
operator|&
name|pVM
operator|->
name|user
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|userVariable
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|CELL
name|c
decl_stmt|;
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|>=
name|FICL_USER_CELLS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error - out of user space"
argument_list|)
expr_stmt|;
block|}
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|userParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         t o V a l u e ** CORE EXT  ** Interpretation: ( x "<spaces>name" -- ) ** Skip leading spaces and parse name delimited by a space. Store x in  ** name. An ambiguous condition exists if name was not defined by VALUE.  ** NOTE: In ficl, VALUE is an alias of CONSTANT **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|toValue
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
if|#
directive|if
name|FICL_WANT_LOCALS
if|if
condition|(
operator|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pVM
operator|->
name|state
operator|==
name|COMPILE
operator|)
condition|)
block|{
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|)
decl_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|pLoc
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
operator|&&
operator|(
name|pFW
operator|->
name|code
operator|==
name|doLocalIm
operator|)
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pToLocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|pFW
operator|&&
name|pFW
operator|->
name|code
operator|==
name|do2LocalIm
condition|)
block|{
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pTo2LocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pStore
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|dictLookup
argument_list|(
name|dp
argument_list|,
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pFW
condition|)
block|{
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not found"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
else|else
comment|/* compile code to store to word's param */
block|{
name|PUSHPTR
argument_list|(
operator|&
name|pFW
operator|->
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|literalIm
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pStore
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_comment
comment|/**************************************************************************                         l i n k P a r e n ** ( -- ) ** Link a frame on the return stack, reserving nCells of space for ** locals - the value of nCells is the next cell in the instruction ** stream. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|linkParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLink
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
decl_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stackLink
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
name|nLink
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|unlinkParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackUnlink
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d o L o c a l I m ** Immediate - cfa of a local while compiling - when executed, compiles ** code to fetch the value of a local given the local's index in the ** word's pfa **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|getLocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|toLocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|getLocal0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|toLocal0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|0
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|getLocal1
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|toLocal1
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
literal|1
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Each local is recorded in a private locals dictionary as a  ** word that does doLocalIm at runtime. DoLocalIm compiles code ** into the client definition to fetch the value of the  ** corresponding local variable from the return stack. ** The private dictionary gets initialized at the end of each block ** that uses locals (in ; and does> for example). */
end_comment

begin_function
specifier|static
name|void
name|doLocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_INT
name|nLocal
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nLocal
operator|==
literal|0
condition|)
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pGetLocal0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nLocal
operator|==
literal|1
condition|)
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pGetLocal1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pGetLocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l o c a l P a r e n ** paren-local-paren LOCAL  ** Interpretation: Interpretation semantics for this word are undefined. ** Execution: ( c-addr u -- ) ** When executed during compilation, (LOCAL) passes a message to the  ** system that has one of two meanings. If u is non-zero, ** the message identifies a new local whose definition name is given by ** the string of characters identified by c-addr u. If u is zero, ** the message is last local and c-addr has no significance.  ** ** The result of executing (LOCAL) during compilation of a definition is ** to create a set of named local identifiers, each of which is ** a definition name, that only have execution semantics within the scope ** of that definition's source.  ** ** local Execution: ( -- x ) ** ** Push the local's value, x, onto the stack. The local's value is ** initialized as described in 13.3.3 Processing locals and may be ** changed by preceding the local's name with TO. An ambiguous condition ** exists when local is executed while in interpretation state.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|localParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pDict
operator|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|POPUNS
argument_list|()
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
operator|(
name|char
operator|*
operator|)
name|POPPTR
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* add a local to the **locals** dict and update nLocals */
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|)
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>=
name|FICL_MAX_LOCALS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: out of local space"
argument_list|)
expr_stmt|;
block|}
name|dictAppendWord2
argument_list|(
name|pLoc
argument_list|,
name|si
argument_list|,
name|doLocalIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pLoc
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|==
literal|0
condition|)
block|{
comment|/* compile code to create a local stack frame */
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pLinkParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save location in dictionary for #locals */
name|pVM
operator|->
name|pSys
operator|->
name|pMarkLocals
operator|=
name|pDict
operator|->
name|here
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compile code to initialize first local */
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pToLocal0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|==
literal|1
condition|)
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pToLocal1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pToLocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>
literal|0
condition|)
block|{
comment|/* write nLocals to (link) param area in dictionary */
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|pSys
operator|->
name|pMarkLocals
operator|)
operator|=
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|get2LocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|do2LocalIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_INT
name|nLocal
init|=
name|pVM
operator|->
name|runningWord
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|state
operator|==
name|INTERPRET
condition|)
block|{
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pGet2LocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|nLocal
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|to2LocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|nLocal
init|=
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|++
operator|)
decl_stmt|;
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
operator|+
literal|1
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|rStack
operator|->
name|pFrame
index|[
name|nLocal
index|]
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|twoLocalParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* add a local to the **locals** dict and update nLocals */
name|FICL_DICT
modifier|*
name|pLoc
init|=
name|ficlGetLoc
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|)
decl_stmt|;
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>=
name|FICL_MAX_LOCALS
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: out of local space"
argument_list|)
expr_stmt|;
block|}
name|dictAppendWord2
argument_list|(
name|pLoc
argument_list|,
name|si
argument_list|,
name|do2LocalIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pLoc
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|==
literal|0
condition|)
block|{
comment|/* compile code to create a local stack frame */
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pLinkParen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save location in dictionary for #locals */
name|pVM
operator|->
name|pSys
operator|->
name|pMarkLocals
operator|=
name|pDict
operator|->
name|here
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pTo2LocalParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|pDict
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
argument_list|)
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
operator|>
literal|0
condition|)
block|{
comment|/* write nLocals to (link) param area in dictionary */
operator|*
operator|(
name|FICL_INT
operator|*
operator|)
operator|(
name|pVM
operator|->
name|pSys
operator|->
name|pMarkLocals
operator|)
operator|=
name|pVM
operator|->
name|pSys
operator|->
name|nLocals
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         c o m p a r e  ** STRING ( c-addr1 u1 c-addr2 u2 -- n ) ** Compare the string specified by c-addr1 u1 to the string specified by ** c-addr2 u2. The strings are compared, beginning at the given addresses, ** character by character, up to the length of the shorter string or until a ** difference is found. If the two strings are identical, n is zero. If the two ** strings are identical up to the length of the shorter string, n is minus-one ** (-1) if u1 is less than u2 and one (1) otherwise. If the two strings are not ** identical up to the length of the shorter string, n is minus-one (-1) if the  ** first non-matching character in the string specified by c-addr1 u1 has a ** lesser numeric value than the corresponding character in the string specified ** by c-addr2 u2 and one (1) otherwise.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|compareInternal
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|caseInsensitive
parameter_list|)
block|{
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|FICL_UNS
name|u1
decl_stmt|,
name|u2
decl_stmt|,
name|uMin
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|u2
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp2
operator|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|u1
operator|=
name|stackPopUNS
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|uMin
operator|=
operator|(
name|u1
operator|<
name|u2
operator|)
condition|?
name|u1
else|:
name|u2
expr_stmt|;
for|for
control|(
init|;
operator|(
name|uMin
operator|>
literal|0
operator|)
operator|&&
operator|(
name|n
operator|==
literal|0
operator|)
condition|;
name|uMin
operator|--
control|)
block|{
name|char
name|c1
init|=
operator|*
name|cp1
operator|++
decl_stmt|;
name|char
name|c2
init|=
operator|*
name|cp2
operator|++
decl_stmt|;
if|if
condition|(
name|caseInsensitive
condition|)
block|{
name|c1
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|c2
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|c1
operator|-
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|u1
operator|-
name|u2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|PUSHINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|compareString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|compareInternal
argument_list|(
name|pVM
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compareStringInsensitive
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|compareInternal
argument_list|(
name|pVM
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         p a d ** CORE EXT  ( -- c-addr ) ** c-addr is the address of a transient region that can be used to hold ** data for intermediate processing. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|pad
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|pVM
operator|->
name|pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s o u r c e - i d ** CORE EXT, FILE   ( -- 0 | -1 | fileid ) **    Identifies the input source as follows: ** ** SOURCE-ID       Input source ** ---------       ------------ ** fileid          Text file fileid ** -1              String (via EVALUATE) ** 0               User input device **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|sourceid
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|PUSHINT
argument_list|(
name|pVM
operator|->
name|sourceID
operator|.
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         r e f i l l ** CORE EXT   ( -- flag ) ** Attempt to fill the input buffer from the input source, returning a true ** flag if successful.  ** When the input source is the user input device, attempt to receive input ** into the terminal input buffer. If successful, make the result the input ** buffer, set>IN to zero, and return true. Receipt of a line containing no ** characters is considered successful. If there is no input available from ** the current input source, return false.  ** When the input source is a string from EVALUATE, return false and ** perform no other action.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|refill
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|ret
init|=
operator|(
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|==
operator|-
literal|1
operator|)
condition|?
name|FICL_FALSE
else|:
name|FICL_TRUE
decl_stmt|;
if|if
condition|(
name|ret
operator|&&
operator|(
name|pVM
operator|->
name|fRestart
operator|==
literal|0
operator|)
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_RESTART
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         freebsd exception handling words ** Catch, from ANS Forth standard. Installs a safety net, then EXECUTE ** the word in ToS. If an exception happens, restore the state to what ** it was before, and pushes the exception value on the stack. If not, ** push zero. ** ** Notice that Catch implements an inner interpreter. This is ugly, ** but given how ficl works, it cannot be helped. The problem is that ** colon definitions will be executed *after* the function returns, ** while "code" definitions will be executed immediately. I considered ** other solutions to this problem, but all of them shared the same ** basic problem (with added disadvantages): if ficl ever changes it's ** inner thread modus operandi, one would have to fix this word. ** ** More comments can be found throughout catch's code. ** ** Daniel C. Sobral Jan 09/1999 ** sadler may 2000 -- revised to follow ficl.c:ficlExecXT. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlCatch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|except
decl_stmt|;
name|jmp_buf
name|vmState
decl_stmt|;
name|FICL_VM
name|VM
decl_stmt|;
name|FICL_STACK
name|pStack
decl_stmt|;
name|FICL_STACK
name|rStack
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|pExitInner
argument_list|)
expr_stmt|;
comment|/*     ** Get xt.     ** We need this *before* we save the stack pointer, or     ** we'll have to pop one element out of the stack after     ** an exception. I prefer to get done with it up front. :-)     */
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pFW
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
comment|/*      ** Save vm's state -- a catch will not back out environmental     ** changes.     **     ** We are *not* saving dictionary state, since it is     ** global instead of per vm, and we are not saving     ** stack contents, since we are not required to (and,     ** thus, it would be useless). We save pVM, and pVM     ** "stacks" (a structure containing general information     ** about it, including the current stack pointer).     */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|VM
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_VM
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|pStack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|pStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|rStack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|rStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     ** Give pVM a jmp_buf     */
name|pVM
operator|->
name|pState
operator|=
operator|&
name|vmState
expr_stmt|;
comment|/*     ** Safety net     */
name|except
operator|=
name|setjmp
argument_list|(
name|vmState
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|except
condition|)
block|{
comment|/*         ** Setup condition - push poison pill so that the VM throws         ** VM_INNEREXIT if the XT terminates normally, then execute         ** the XT         */
case|case
literal|0
case|:
name|vmPushIP
argument_list|(
name|pVM
argument_list|,
operator|&
operator|(
name|pVM
operator|->
name|pSys
operator|->
name|pExitInner
operator|)
argument_list|)
expr_stmt|;
comment|/* Open mouth, insert emetic */
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|vmInnerLoop
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
comment|/*         ** Normal exit from XT - lose the poison pill,          ** restore old setjmp vector and push a zero.          */
case|case
name|VM_INNEREXIT
case|:
name|vmPopIP
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
comment|/* Gack - hurl poison pill */
name|pVM
operator|->
name|pState
operator|=
name|VM
operator|.
name|pState
expr_stmt|;
comment|/* Restore just the setjmp vector */
name|PUSHINT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Push 0 -- everything is ok */
break|break;
comment|/*         ** Some other exception got thrown - restore pre-existing VM state         ** and push the exception code         */
default|default:
comment|/* Restore vm's state */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pVM
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|VM
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_VM
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|pStack
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|rStack
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|rStack
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|except
argument_list|)
expr_stmt|;
comment|/* Push error */
break|break;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************** **                     t h r o w ** EXCEPTION ** Throw --  From ANS Forth standard. ** ** Throw takes the ToS and, if that's different from zero, ** returns to the last executed catch context. Further throws will ** unstack previously executed "catches", in LIFO mode. ** ** Daniel C. Sobral Jan 09/1999 **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlThrow
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|except
decl_stmt|;
name|except
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|except
condition|)
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|except
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************** **                     a l l o c a t e ** MEMORY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ansAllocate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|size
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|p
operator|=
name|ficlMalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUSHPTR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|PUSHINT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|PUSHINT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************** **                     f r e e  ** MEMORY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ansFree
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************** **                     r e s i z e ** MEMORY **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ansResize
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|size
operator|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|old
operator|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|new
operator|=
name|ficlRealloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|PUSHPTR
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUSHPTR
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************** **                     e x i t - i n n e r  ** Signals execXT that an inner loop has completed **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlExitInner
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_INNEREXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d n e g a t e ** DOUBLE   ( d1 -- d2 ) ** d2 is the negation of d1.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|dnegate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|DPINT
name|i
init|=
name|i64Pop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|i
operator|=
name|m64Negate
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i64Push
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/**************************************************************************                          **  **************************************************************************/
end_comment

begin_endif
unit|static void funcname(FICL_VM *pVM) {     IGNORE(pVM);     return; }
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         f i c l W o r d C l a s s i f y ** This public function helps to classify word types for SEE ** and the deugger in tools.c. Given a pointer to a word, it returns ** a member of WOR **************************************************************************/
end_comment

begin_function
name|WORDKIND
name|ficlWordClassify
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
typedef|typedef
struct|struct
block|{
name|WORDKIND
name|kind
decl_stmt|;
name|FICL_CODE
name|code
decl_stmt|;
block|}
name|CODEtoKIND
typedef|;
specifier|static
name|CODEtoKIND
name|codeMap
index|[]
init|=
block|{
block|{
name|BRANCH
block|,
name|branchParen
block|}
block|,
block|{
name|COLON
block|,
name|colonParen
block|}
block|,
block|{
name|CONSTANT
block|,
name|constantParen
block|}
block|,
block|{
name|CREATE
block|,
name|createParen
block|}
block|,
block|{
name|DO
block|,
name|doParen
block|}
block|,
block|{
name|DOES
block|,
name|doDoes
block|}
block|,
block|{
name|IF
block|,
name|branch0
block|}
block|,
block|{
name|LITERAL
block|,
name|literalParen
block|}
block|,
block|{
name|LOOP
block|,
name|loopParen
block|}
block|,
block|{
name|OF
block|,
name|ofParen
block|}
block|,
block|{
name|PLOOP
block|,
name|plusLoopParen
block|}
block|,
block|{
name|QDO
block|,
name|qDoParen
block|}
block|,
block|{
name|CSTRINGLIT
block|,
name|cstringLit
block|}
block|,
block|{
name|STRINGLIT
block|,
name|stringLit
block|}
block|,
if|#
directive|if
name|FICL_WANT_USER
block|{
name|USER
block|,
name|userParen
block|}
block|,
endif|#
directive|endif
block|{
name|VARIABLE
block|,
name|variableParen
block|}
block|,     }
decl_stmt|;
define|#
directive|define
name|nMAP
value|(sizeof(codeMap) / sizeof(CODEtoKIND))
name|FICL_CODE
name|code
init|=
name|pFW
operator|->
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nMAP
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|codeMap
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
name|codeMap
index|[
name|i
index|]
operator|.
name|kind
return|;
block|}
return|return
name|PRIMITIVE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_comment
comment|/************************************************************************** **                     r a n d o m ** FICL-specific **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlRandom
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|PUSHINT
argument_list|(
name|rand
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************** **                     s e e d - r a n d o m ** FICL-specific **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ficlSeedRandom
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|srand
argument_list|(
name|POPINT
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         f i c l C o m p i l e C o r e ** Builds the primitive wordset and the environment-query namespace. **************************************************************************/
end_comment

begin_function
name|void
name|ficlCompileCore
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|pSys
operator|->
name|dp
decl_stmt|;
name|assert
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*     ** CORE word set     ** see softcore.c for definitions of: abs bl space spaces abort"     */
name|pSys
operator|->
name|pStore
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"!"
argument_list|,
name|store
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"#"
argument_list|,
name|numberSign
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"#>"
argument_list|,
name|numberSignGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"#s"
argument_list|,
name|numberSignS
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"\'"
argument_list|,
name|ficlTick
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"("
argument_list|,
name|commentHang
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"*"
argument_list|,
name|mul
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"*/"
argument_list|,
name|mulDiv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"*/mod"
argument_list|,
name|mulDivRem
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"+"
argument_list|,
name|add
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"+!"
argument_list|,
name|plusStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"+loop"
argument_list|,
name|plusLoopCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|","
argument_list|,
name|comma
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"-"
argument_list|,
name|sub
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"."
argument_list|,
name|displayCell
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".\""
argument_list|,
name|dotQuoteCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"/"
argument_list|,
name|ficlDiv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"/mod"
argument_list|,
name|slashMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0<"
argument_list|,
name|zeroLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0="
argument_list|,
name|zeroEquals
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"1+"
argument_list|,
name|onePlus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"1-"
argument_list|,
name|oneMinus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2!"
argument_list|,
name|twoStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2*"
argument_list|,
name|twoMul
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2/"
argument_list|,
name|twoDiv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2@"
argument_list|,
name|twoFetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2drop"
argument_list|,
name|twoDrop
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2dup"
argument_list|,
name|twoDup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2over"
argument_list|,
name|twoOver
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2swap"
argument_list|,
name|twoSwap
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|":"
argument_list|,
name|colon
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|";"
argument_list|,
name|semicolonCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"<"
argument_list|,
name|isLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"<#"
argument_list|,
name|lessNumberSign
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"="
argument_list|,
name|isEqual
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">"
argument_list|,
name|isGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">body"
argument_list|,
name|toBody
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">in"
argument_list|,
name|toIn
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">number"
argument_list|,
name|toNumber
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">r"
argument_list|,
name|toRStack
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"?dup"
argument_list|,
name|questionDup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"@"
argument_list|,
name|fetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"abort"
argument_list|,
name|ficlAbort
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"accept"
argument_list|,
name|accept
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"align"
argument_list|,
name|align
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"aligned"
argument_list|,
name|aligned
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"allot"
argument_list|,
name|allot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"and"
argument_list|,
name|bitwiseAnd
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"base"
argument_list|,
name|base
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"begin"
argument_list|,
name|beginCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"c!"
argument_list|,
name|cStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"c,"
argument_list|,
name|cComma
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"c@"
argument_list|,
name|cFetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"case"
argument_list|,
name|caseCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"cell+"
argument_list|,
name|cellPlus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"cells"
argument_list|,
name|cells
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"char"
argument_list|,
name|ficlChar
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"char+"
argument_list|,
name|charPlus
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"chars"
argument_list|,
name|ficlChars
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"constant"
argument_list|,
name|constant
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"count"
argument_list|,
name|count
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"cr"
argument_list|,
name|cr
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"create"
argument_list|,
name|create
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"decimal"
argument_list|,
name|decimal
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"depth"
argument_list|,
name|depth
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"do"
argument_list|,
name|doCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"does>"
argument_list|,
name|doesCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pDrop
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"drop"
argument_list|,
name|drop
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"dup"
argument_list|,
name|dup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"else"
argument_list|,
name|elseCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"emit"
argument_list|,
name|emit
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"endcase"
argument_list|,
name|endcaseCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"endof"
argument_list|,
name|endofCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"environment?"
argument_list|,
name|environmentQ
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"evaluate"
argument_list|,
name|evaluate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"execute"
argument_list|,
name|execute
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"exit"
argument_list|,
name|exitCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fallthrough"
argument_list|,
name|fallthroughCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fill"
argument_list|,
name|fill
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"find"
argument_list|,
name|cFind
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fm/mod"
argument_list|,
name|fmSlashMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"here"
argument_list|,
name|here
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"hold"
argument_list|,
name|hold
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"i"
argument_list|,
name|loopICo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"if"
argument_list|,
name|ifCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"immediate"
argument_list|,
name|immediate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"invert"
argument_list|,
name|bitwiseNot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"j"
argument_list|,
name|loopJCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"k"
argument_list|,
name|loopKCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"leave"
argument_list|,
name|leaveCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"literal"
argument_list|,
name|literalIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"loop"
argument_list|,
name|loopCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"lshift"
argument_list|,
name|lshift
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"m*"
argument_list|,
name|mStar
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"max"
argument_list|,
name|ficlMax
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"min"
argument_list|,
name|ficlMin
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"mod"
argument_list|,
name|ficlMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"move"
argument_list|,
name|move
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"negate"
argument_list|,
name|negate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"of"
argument_list|,
name|ofCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"or"
argument_list|,
name|bitwiseOr
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"over"
argument_list|,
name|over
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"postpone"
argument_list|,
name|postponeCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"quit"
argument_list|,
name|quit
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"r>"
argument_list|,
name|fromRStack
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"r@"
argument_list|,
name|fetchRStack
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"recurse"
argument_list|,
name|recurseCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"repeat"
argument_list|,
name|repeatCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"rot"
argument_list|,
name|rot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"rshift"
argument_list|,
name|rshift
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"s\""
argument_list|,
name|stringQuoteIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"s>d"
argument_list|,
name|sToD
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sign"
argument_list|,
name|sign
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sm/rem"
argument_list|,
name|smSlashRem
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"source"
argument_list|,
name|source
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"state"
argument_list|,
name|state
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"swap"
argument_list|,
name|swap
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"then"
argument_list|,
name|endifCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"type"
argument_list|,
name|type
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"u."
argument_list|,
name|uDot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"u<"
argument_list|,
name|uIsLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"um*"
argument_list|,
name|umStar
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"um/mod"
argument_list|,
name|umSlashMod
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"unloop"
argument_list|,
name|unloopCo
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"until"
argument_list|,
name|untilCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"variable"
argument_list|,
name|variable
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"while"
argument_list|,
name|whileCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"word"
argument_list|,
name|ficlWord
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"xor"
argument_list|,
name|bitwiseXor
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"["
argument_list|,
name|lbracketCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"[\']"
argument_list|,
name|bracketTickCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"[char]"
argument_list|,
name|charCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"]"
argument_list|,
name|rbracket
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*      ** CORE EXT word set...     ** see softcore.fr for other definitions     */
comment|/* "#tib" */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".("
argument_list|,
name|dotParen
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
comment|/* ".r" */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0>"
argument_list|,
name|zeroGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2>r"
argument_list|,
name|twoToR
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2r>"
argument_list|,
name|twoRFrom
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2r@"
argument_list|,
name|twoRFetch
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|":noname"
argument_list|,
name|colonNoName
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"?do"
argument_list|,
name|qDoCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"again"
argument_list|,
name|againCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"c\""
argument_list|,
name|cstringQuoteIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"hex"
argument_list|,
name|hex
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"pad"
argument_list|,
name|pad
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"parse"
argument_list|,
name|parse
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"pick"
argument_list|,
name|pick
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/* query restore-input save-input tib u.r u> unused [compile] */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"roll"
argument_list|,
name|roll
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"refill"
argument_list|,
name|refill
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"source-id"
argument_list|,
name|sourceid
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"to"
argument_list|,
name|toValue
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"value"
argument_list|,
name|constant
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"\\"
argument_list|,
name|commentLine
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
comment|/*     ** Set CORE environment query values     */
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"/counted-string"
argument_list|,
name|FICL_STRING_MAX
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"/hold"
argument_list|,
name|nPAD
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"/pad"
argument_list|,
name|nPAD
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"address-unit-bits"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"core"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"core-ext"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"floored"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"max-char"
argument_list|,
name|UCHAR_MAX
argument_list|)
expr_stmt|;
name|ficlSetEnvD
argument_list|(
name|pSys
argument_list|,
literal|"max-d"
argument_list|,
literal|0x7fffffff
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"max-n"
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"max-u"
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ficlSetEnvD
argument_list|(
name|pSys
argument_list|,
literal|"max-ud"
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"return-stack-cells"
argument_list|,
name|FICL_DEFAULT_STACK
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"stack-cells"
argument_list|,
name|FICL_DEFAULT_STACK
argument_list|)
expr_stmt|;
comment|/*     ** DOUBLE word set (partial)     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2constant"
argument_list|,
name|twoConstant
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2literal"
argument_list|,
name|twoLiteralIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"2variable"
argument_list|,
name|twoVariable
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"dnegate"
argument_list|,
name|dnegate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*     ** EXCEPTION word set     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"catch"
argument_list|,
name|ficlCatch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"throw"
argument_list|,
name|ficlThrow
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"exception"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"exception-ext"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
comment|/*     ** LOCAL and LOCAL EXT     ** see softcore.c for implementation of locals|     */
if|#
directive|if
name|FICL_WANT_LOCALS
name|pSys
operator|->
name|pLinkParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(link)"
argument_list|,
name|linkParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pUnLinkParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(unlink)"
argument_list|,
name|unlinkParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"doLocal"
argument_list|,
name|doLocalIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pGetLocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@local)"
argument_list|,
name|getLocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pToLocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(toLocal)"
argument_list|,
name|toLocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pGetLocal0
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@local0)"
argument_list|,
name|getLocal0
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pToLocal0
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(toLocal0)"
argument_list|,
name|toLocal0
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pGetLocal1
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@local1)"
argument_list|,
name|getLocal1
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pToLocal1
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(toLocal1)"
argument_list|,
name|toLocal1
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(local)"
argument_list|,
name|localParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pGet2LocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(@2local)"
argument_list|,
name|get2LocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pTo2LocalParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(to2Local)"
argument_list|,
name|to2LocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(2local)"
argument_list|,
name|twoLocalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"locals"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"locals-ext"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"#locals"
argument_list|,
name|FICL_MAX_LOCALS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** Optional MEMORY-ALLOC word set     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"allocate"
argument_list|,
name|ansAllocate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"free"
argument_list|,
name|ansFree
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"resize"
argument_list|,
name|ansResize
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"memory-alloc"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
comment|/*     ** optional SEARCH-ORDER word set      */
name|ficlCompileSearch
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
comment|/*     ** TOOLS and TOOLS EXT     */
name|ficlCompileTools
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
comment|/*     ** FILE and FILE EXT     */
if|#
directive|if
name|FICL_WANT_FILE
name|ficlCompileFile
argument_list|(
name|pSys
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** Ficl extras     */
if|#
directive|if
name|FICL_WANT_FLOAT
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".hash"
argument_list|,
name|dictHashSummary
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".ver"
argument_list|,
name|ficlVersion
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"-roll"
argument_list|,
name|minusRoll
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">name"
argument_list|,
name|toName
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"add-parse-step"
argument_list|,
name|addParseStep
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"body>"
argument_list|,
name|fromBody
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"compare"
argument_list|,
name|compareString
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/* STRING */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"compare-insensitive"
argument_list|,
name|compareStringInsensitive
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/* STRING */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"compile-only"
argument_list|,
name|compileOnly
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"endif"
argument_list|,
name|endifCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"last-word"
argument_list|,
name|getLastWord
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"hash"
argument_list|,
name|hash
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"objectify"
argument_list|,
name|setObjectFlag
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"?object"
argument_list|,
name|isObject
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"parse-word"
argument_list|,
name|parseNoCopy
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sfind"
argument_list|,
name|sFind
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sliteral"
argument_list|,
name|sLiteralCoIm
argument_list|,
name|FW_COMPIMMED
argument_list|)
expr_stmt|;
comment|/* STRING */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"sprintf"
argument_list|,
name|ficlSprintf
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"strlen"
argument_list|,
name|ficlStrlen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"q@"
argument_list|,
name|quadFetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"q!"
argument_list|,
name|quadStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"w@"
argument_list|,
name|wFetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"w!"
argument_list|,
name|wStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"x."
argument_list|,
name|hexDot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_USER
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(user)"
argument_list|,
name|userParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"user"
argument_list|,
name|userVariable
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TESTMAIN
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"random"
argument_list|,
name|ficlRandom
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"seed-random"
argument_list|,
name|ficlSeedRandom
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** internal support words     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(create)"
argument_list|,
name|createParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pExitParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(exit)"
argument_list|,
name|exitParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pSemiParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(;)"
argument_list|,
name|semiParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pLitParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(literal)"
argument_list|,
name|literalParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pTwoLitParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(2literal)"
argument_list|,
name|twoLitParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pStringLit
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(.\")"
argument_list|,
name|stringLit
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pCStringLit
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(c\")"
argument_list|,
name|cstringLit
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pBranch0
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(branch0)"
argument_list|,
name|branch0
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pBranchParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(branch)"
argument_list|,
name|branchParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pDoParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(do)"
argument_list|,
name|doParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pDoesParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(does>)"
argument_list|,
name|doesParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pQDoParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(?do)"
argument_list|,
name|qDoParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pLoopParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(loop)"
argument_list|,
name|loopParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pPLoopParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(+loop)"
argument_list|,
name|plusLoopParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pInterpret
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"interpret"
argument_list|,
name|interpret
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"lookup"
argument_list|,
name|lookup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pOfParen
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(of)"
argument_list|,
name|ofParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(variable)"
argument_list|,
name|variableParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(constant)"
argument_list|,
name|constantParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(parse-step)"
argument_list|,
name|parseStepParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|pSys
operator|->
name|pExitInner
operator|=
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"exit-inner"
argument_list|,
name|ficlExitInner
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*     ** Set up system's outer interpreter loop - maybe this should be in initSystem?     */
name|pSys
operator|->
name|pInterp
index|[
literal|0
index|]
operator|=
name|pSys
operator|->
name|pInterpret
expr_stmt|;
name|pSys
operator|->
name|pInterp
index|[
literal|1
index|]
operator|=
name|pSys
operator|->
name|pBranchParen
expr_stmt|;
name|pSys
operator|->
name|pInterp
index|[
literal|2
index|]
operator|=
operator|(
name|FICL_WORD
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|-
literal|2
operator|)
expr_stmt|;
name|assert
argument_list|(
name|dictCellsAvail
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

