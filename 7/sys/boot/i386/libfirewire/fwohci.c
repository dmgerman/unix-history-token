begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003 Hidetoshi Shimokawa  * Copyright (c) 1998-2002 Katsushi Kobayashi and Hidetoshi Shimokawa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the acknowledgement as bellow:  *  *    This product includes software developed by K. Kobayashi and H. Shimokawa  *  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<btxv86.h>
end_include

begin_include
include|#
directive|include
file|<bootstrap.h>
end_include

begin_include
include|#
directive|include
file|"fwohci.h"
end_include

begin_include
include|#
directive|include
file|"fwohcireg.h"
end_include

begin_include
include|#
directive|include
file|<dev/firewire/firewire_phy.h>
end_include

begin_function_decl
specifier|static
name|uint32_t
name|fwphy_wrdata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|fwphy_rddata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|firewire_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|device_printf
parameter_list|(
name|a
parameter_list|,
name|x
parameter_list|,
modifier|...
parameter_list|)
value|printf("FW1394: " x, ## __VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|device_printf
parameter_list|(
name|a
parameter_list|,
name|x
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|device_t
value|int
end_define

begin_define
define|#
directive|define
name|DELAY
parameter_list|(
name|x
parameter_list|)
value|delay(x)
end_define

begin_define
define|#
directive|define
name|MAX_SPEED
value|3
end_define

begin_define
define|#
directive|define
name|MAXREC
parameter_list|(
name|x
parameter_list|)
value|(2<< (x))
end_define

begin_decl_stmt
name|char
modifier|*
name|linkspeed
index|[]
init|=
block|{
literal|"S100"
block|,
literal|"S200"
block|,
literal|"S400"
block|,
literal|"S800"
block|,
literal|"S1600"
block|,
literal|"S3200"
block|,
literal|"undef"
block|,
literal|"undef"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FW_EUI64_BYTE
parameter_list|(
name|eui
parameter_list|,
name|x
parameter_list|)
define|\
value|((((x)<4)?				\ 		((eui)->hi>> (8*(3-(x)))): 	\ 		((eui)->lo>> (8*(7-(x))))	\ 	)& 0xff)
end_define

begin_comment
comment|/*  * Communication with PHY device  */
end_comment

begin_function
specifier|static
name|uint32_t
name|fwphy_wrdata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint32_t
name|fun
decl_stmt|;
name|addr
operator|&=
literal|0xf
expr_stmt|;
name|data
operator|&=
literal|0xff
expr_stmt|;
name|fun
operator|=
operator|(
name|PHYDEV_WRCMD
operator||
operator|(
name|addr
operator|<<
name|PHYDEV_REGADDR
operator|)
operator||
operator|(
name|data
operator|<<
name|PHYDEV_WRDATA
operator|)
operator|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fwphy_rddata
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|addr
parameter_list|)
block|{
name|uint32_t
name|fun
decl_stmt|,
name|stat
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|retry
init|=
literal|0
decl_stmt|;
name|addr
operator|&=
literal|0xf
expr_stmt|;
define|#
directive|define
name|MAX_RETRY
value|100
name|again
label|:
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|OHCI_INT_REG_FAIL
argument_list|)
expr_stmt|;
name|fun
operator|=
name|PHYDEV_RDCMD
operator||
operator|(
name|addr
operator|<<
name|PHYDEV_REGADDR
operator|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|,
name|fun
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_RETRY
condition|;
name|i
operator|++
control|)
block|{
name|fun
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_PHYACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fun
operator|&
name|PHYDEV_RDCMD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|fun
operator|&
name|PHYDEV_RDDONE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|MAX_RETRY
condition|)
block|{
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"phy read failed(1).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retry
operator|<
name|MAX_RETRY
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* Make sure that SCLK is started */
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|OHCI_INT_REG_FAIL
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|fun
operator|>>
name|PHYDEV_REGADDR
operator|)
operator|&
literal|0xf
operator|)
operator|!=
name|addr
condition|)
block|{
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"phy read failed(2).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retry
operator|<
name|MAX_RETRY
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|firewire_debug
operator|||
name|retry
operator|>=
name|MAX_RETRY
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"fwphy_rddata: 0x%x loop=%d, retry=%d\n"
argument_list|,
name|addr
argument_list|,
name|i
argument_list|,
name|retry
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MAX_RETRY
return|return
operator|(
operator|(
name|fun
operator|>>
name|PHYDEV_RDDATA
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fwohci_probe_phy
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|reg2
decl_stmt|;
name|int
name|e1394a
init|=
literal|1
decl_stmt|;
name|int
name|nport
decl_stmt|,
name|speed
decl_stmt|;
comment|/*  * probe PHY parameters  * 0. to prove PHY version, whether compliance of 1394a.  * 1. to probe maximum speed supported by the PHY and   *    number of port supported by core-logic.  *    It is not actually available port on your PC .  */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LPS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_SPD_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>>
literal|5
operator|)
operator|!=
literal|7
condition|)
block|{
name|nport
operator|=
name|reg
operator|&
name|FW_PHY_NP
expr_stmt|;
name|speed
operator|=
name|reg
operator|&
name|FW_PHY_SPD
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|speed
operator|>
name|MAX_SPEED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid speed %d (fixed to %d).\n"
argument_list|,
name|speed
argument_list|,
name|MAX_SPEED
argument_list|)
expr_stmt|;
name|speed
operator|=
name|MAX_SPEED
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Phy 1394 only %s, %d ports.\n"
argument_list|,
name|linkspeed
index|[
name|speed
index|]
argument_list|,
name|nport
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg2
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_ESPD_REG
argument_list|)
expr_stmt|;
name|nport
operator|=
name|reg
operator|&
name|FW_PHY_NP
expr_stmt|;
name|speed
operator|=
operator|(
name|reg2
operator|&
name|FW_PHY_ESPD
operator|)
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|speed
operator|>
name|MAX_SPEED
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid speed %d (fixed to %d).\n"
argument_list|,
name|speed
argument_list|,
name|MAX_SPEED
argument_list|)
expr_stmt|;
name|speed
operator|=
name|MAX_SPEED
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Phy 1394a available %s, %d ports.\n"
argument_list|,
name|linkspeed
index|[
name|speed
index|]
argument_list|,
name|nport
argument_list|)
expr_stmt|;
comment|/* check programPhyEnable */
name|reg2
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (e1394a&& (OREAD(sc, OHCI_HCCCTL)& OHCI_HCC_PRPHY)) {
else|#
directive|else
comment|/* XXX force to enable 1394a */
if|if
condition|(
name|e1394a
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Enable 1394a Enhancements\n"
argument_list|)
expr_stmt|;
comment|/* enable EAA EMC */
name|reg2
operator||=
literal|0x03
expr_stmt|;
comment|/* set aPhyEnhanceEnable */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_PHYEN
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_PRPHY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* for safe */
name|reg2
operator|&=
operator|~
literal|0x83
expr_stmt|;
block|}
name|reg2
operator|=
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_SPD_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|>>
literal|5
operator|)
operator|==
literal|7
condition|)
block|{
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|reg
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fwohci_reset
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max_rec
decl_stmt|,
name|speed
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|reg2
decl_stmt|;
comment|/* Disable interrupts */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* FLUSH FIFO and reset Transmitter/Reciever */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"resetting OHCI..."
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|)
operator|&
name|OHCI_HCC_RESET
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|100
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firewire_debug
condition|)
name|printf
argument_list|(
literal|"done (loop=%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Probe phy */
name|fwohci_probe_phy
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* Probe link */
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|reg
operator||
name|OHCI_BUSFNC
expr_stmt|;
name|max_rec
operator|=
operator|(
name|reg
operator|&
literal|0x0000f000
operator|)
operator|>>
literal|12
expr_stmt|;
name|speed
operator|=
operator|(
name|reg
operator|&
literal|0x00000007
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link %s, max_rec %d bytes.\n"
argument_list|,
name|linkspeed
index|[
name|speed
index|]
argument_list|,
name|MAXREC
argument_list|(
name|max_rec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX fix max_rec */
name|sc
operator|->
name|maxrec
operator|=
name|sc
operator|->
name|speed
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|max_rec
operator|!=
name|sc
operator|->
name|maxrec
condition|)
block|{
name|reg2
operator|=
operator|(
name|reg2
operator|&
literal|0xffff0fff
operator|)
operator||
operator|(
name|sc
operator|->
name|maxrec
operator|<<
literal|12
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"max_rec %d -> %d\n"
argument_list|,
name|MAXREC
argument_list|(
name|max_rec
argument_list|)
argument_list|,
name|MAXREC
argument_list|(
name|sc
operator|->
name|maxrec
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firewire_debug
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BUS_OPT 0x%x -> 0x%x\n"
argument_list|,
name|reg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
comment|/* Initialize registers */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMHDR
argument_list|,
name|sc
operator|->
name|config_rom
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMPTR
argument_list|,
name|VTOP
argument_list|(
name|sc
operator|->
name|config_rom
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|OWRITE(sc, OHCI_SID_BUF, sc->sid_dma.bus_addr);
endif|#
directive|endif
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTLCLR
argument_list|,
name|OHCI_HCC_BIGEND
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_POSTWR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|OWRITE(sc, OHCI_LNKCTL, OHCI_CNTL_SID);
endif|#
directive|endif
comment|/* Enable link */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_HCCCTL
argument_list|,
name|OHCI_HCC_LINKEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fwohci_init
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mver
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint8_t
name|ui
index|[
literal|8
index|]
decl_stmt|;
comment|/* OHCI version */
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_VERSION
argument_list|)
expr_stmt|;
name|mver
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"OHCI version %x.%x (ROM=%d)\n"
argument_list|,
name|mver
argument_list|,
name|reg
operator|&
literal|0xff
argument_list|,
operator|(
name|reg
operator|>>
literal|24
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mver
operator|<
literal|1
operator|||
name|mver
operator|>
literal|9
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid OHCI version\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Available Isochronous DMA channel probe */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|reg
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASK
argument_list|)
operator|&
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASK
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IT_MASKCLR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_IR_MASKCLR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x20
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|reg
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No. of Isochronous channels is %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|#
directive|if
literal|0
comment|/* SID recieve buffer must align 2^11 */
define|#
directive|define
name|OHCI_SIDSIZE
value|(1<< 11)
block|sc->sid_buf = fwdma_malloc(&sc->fc, OHCI_SIDSIZE, OHCI_SIDSIZE,&sc->sid_dma, BUS_DMA_WAITOK); 	if (sc->sid_buf == NULL) { 		device_printf(dev, "sid_buf alloc failed."); 		return ENOMEM; 	}
endif|#
directive|endif
name|sc
operator|->
name|eui
operator|.
name|hi
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCIGUID_H
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eui
operator|.
name|lo
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCIGUID_L
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|ui
index|[
name|i
index|]
operator|=
name|FW_EUI64_BYTE
argument_list|(
operator|&
name|sc
operator|->
name|eui
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EUI64 %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|ui
index|[
literal|0
index|]
argument_list|,
name|ui
index|[
literal|1
index|]
argument_list|,
name|ui
index|[
literal|2
index|]
argument_list|,
name|ui
index|[
literal|3
index|]
argument_list|,
name|ui
index|[
literal|4
index|]
argument_list|,
name|ui
index|[
literal|5
index|]
argument_list|,
name|ui
index|[
literal|6
index|]
argument_list|,
name|ui
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|fwohci_reset
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fwohci_ibr
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|fun
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Initiate bus reset\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure our cached values from the config rom are 	 * initialised. 	 */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMHDR
argument_list|,
name|ntohl
argument_list|(
name|sc
operator|->
name|config_rom
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|,
name|ntohl
argument_list|(
name|sc
operator|->
name|config_rom
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set root hold-off bit so that non cyclemaster capable node 	 * shouldn't became the root node. 	 */
if|#
directive|if
literal|1
name|fun
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_IBR_REG
argument_list|)
expr_stmt|;
name|fun
operator||=
name|FW_PHY_IBR
expr_stmt|;
name|fun
operator|=
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_IBR_REG
argument_list|,
name|fun
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Short bus reset */
name|fun
operator|=
name|fwphy_rddata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_ISBR_REG
argument_list|)
expr_stmt|;
name|fun
operator||=
name|FW_PHY_ISBR
expr_stmt|;
name|fun
operator|=
name|fwphy_wrdata
argument_list|(
name|sc
argument_list|,
name|FW_PHY_ISBR_REG
argument_list|,
name|fun
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|fwohci_sid
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|node_id
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|node_id
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_NODEID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node_id
operator|&
name|OHCI_NODE_VALID
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|printf("Bus reset failure\n");
endif|#
directive|endif
return|return;
block|}
comment|/* Enable bus reset interrupt */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|,
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
comment|/* Allow async. request to us */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_AREQHI
argument_list|,
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* XXX insecure ?? */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQHI
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQLO
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_PREQUPPER
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
comment|/* Set ATRetries register */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_ATRETRY
argument_list|,
literal|1
operator|<<
operator|(
literal|13
operator|+
literal|16
operator|)
operator||
literal|0xfff
argument_list|)
expr_stmt|;
comment|/* ** Checking whether the node is root or not. If root, turn on  ** cycle master. */
name|plen
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|OHCI_SID_CNT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"node_id=0x%08x, gen=%d, "
argument_list|,
name|node_id
argument_list|,
operator|(
name|plen
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_id
operator|&
name|OHCI_NODE_ROOT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CYCLEMASTER mode\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_CYCMTR
operator||
name|OHCI_CNTL_CYCTIMER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"non CYCLEMASTER mode\n"
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTLCLR
argument_list|,
name|OHCI_CNTL_CYCMTR
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTL
argument_list|,
name|OHCI_CNTL_CYCTIMER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|plen
operator|&
name|OHCI_SID_ERR
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"SID Error\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"bus reset phase done\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|FWOHCI_STATE_NORMAL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwohci_intr_body
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|stat
parameter_list|,
name|int
name|count
parameter_list|)
block|{
undef|#
directive|undef
name|OHCI_DEBUG
ifdef|#
directive|ifdef
name|OHCI_DEBUG
if|#
directive|if
literal|0
block|if(stat& OREAD(sc, FWOHCI_INTMASK))
else|#
directive|else
if|if
condition|(
literal|1
condition|)
endif|#
directive|endif
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"INTERRUPT< %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s> 0x%08x, 0x%08x\n"
argument_list|,
name|stat
operator|&
name|OHCI_INT_EN
condition|?
literal|"DMA_EN "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_REG
condition|?
literal|"PHY_REG "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_LONG
condition|?
literal|"CYC_LONG "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_ERR
condition|?
literal|"INT_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_ERR
condition|?
literal|"CYC_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_LOST
condition|?
literal|"CYC_LOST "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_64SECOND
condition|?
literal|"CYC_64SECOND "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_CYC_START
condition|?
literal|"CYC_START "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_INT
condition|?
literal|"PHY_INT "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_BUS_R
condition|?
literal|"BUS_RESET "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PHY_SID
condition|?
literal|"SID "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_LR_ERR
condition|?
literal|"DMA_LR_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_PW_ERR
condition|?
literal|"DMA_PW_ERR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_IR
condition|?
literal|"DMA_IR "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_IT
condition|?
literal|"DMA_IT "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_PRRS
condition|?
literal|"DMA_PRRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_PRRQ
condition|?
literal|"DMA_PRRQ "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ARRS
condition|?
literal|"DMA_ARRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ARRQ
condition|?
literal|"DMA_ARRQ "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ATRS
condition|?
literal|"DMA_ATRS "
else|:
literal|""
argument_list|,
name|stat
operator|&
name|OHCI_INT_DMA_ATRQ
condition|?
literal|"DMA_ATRQ "
else|:
literal|""
argument_list|,
name|stat
argument_list|,
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASK
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Bus reset */
if|if
condition|(
name|stat
operator|&
name|OHCI_INT_PHY_BUS_R
condition|)
block|{
name|device_printf
argument_list|(
name|fc
operator|->
name|dev
argument_list|,
literal|"BUS reset\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|==
name|FWOHCI_STATE_BUSRESET
condition|)
goto|goto
name|busresetout
goto|;
name|sc
operator|->
name|state
operator|=
name|FWOHCI_STATE_BUSRESET
expr_stmt|;
comment|/* Disable bus reset interrupt until sid recv. */
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_PHY_BUS_R
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTMASKCLR
argument_list|,
name|OHCI_INT_CYC_LOST
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_LNKCTLCLR
argument_list|,
name|OHCI_CNTL_CYCSRC
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_CROMHDR
argument_list|,
name|ntohl
argument_list|(
name|sc
operator|->
name|config_rom
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|OHCI_BUS_OPT
argument_list|,
name|ntohl
argument_list|(
name|sc
operator|->
name|config_rom
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|state
operator|==
name|FWOHCI_STATE_BUSRESET
condition|)
block|{
name|fwohci_sid
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|busresetout
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fwochi_check_stat
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|stat
decl_stmt|;
name|stat
operator|=
name|OREAD
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|fc
operator|.
name|dev
argument_list|,
literal|"device physically ejected?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
if|if
condition|(
name|stat
condition|)
name|OWRITE
argument_list|(
name|sc
argument_list|,
name|FWOHCI_INTSTATCLR
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fwohci_poll
parameter_list|(
name|struct
name|fwohci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|stat
decl_stmt|;
name|stat
operator|=
name|fwochi_check_stat
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
literal|0xffffffff
condition|)
name|fwohci_intr_body
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

