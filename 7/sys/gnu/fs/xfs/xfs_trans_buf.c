begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_function_decl
name|STATIC
name|xfs_buf_t
modifier|*
name|xfs_trans_buf_item_match
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_buftarg_t
modifier|*
parameter_list|,
name|xfs_daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|xfs_buf_t
modifier|*
name|xfs_trans_buf_item_match_all
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_buftarg_t
modifier|*
parameter_list|,
name|xfs_daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Get and lock the buffer for the caller if it is not already  * locked within the given transaction.  If it is already locked  * within the transaction, just increment its lock recursion count  * and return a pointer to it.  *  * Use the fast path function xfs_trans_buf_item_match() or the buffer  * cache routine incore_match() to find the buffer  * if it is already owned by this transaction.  *  * If we don't already own the buffer, use get_buf() to get it.  * If it doesn't yet have an associated xfs_buf_log_item structure,  * then allocate one and add the item to this transaction.  *  * If the transaction pointer is NULL, make this just a normal  * get_buf() call.  */
end_comment

begin_function
name|xfs_buf_t
modifier|*
name|xfs_trans_get_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|target_dev
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|,
name|int
name|len
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
name|flags
operator|=
name|XFS_BUF_LOCK
operator||
name|XFS_BUF_MAPPED
expr_stmt|;
comment|/* 	 * Default to a normal get_buf() call if the tp is NULL. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|xfs_buf_get_flags
argument_list|(
name|target_dev
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|flags
operator||
name|BUF_BUSY
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
comment|/* 	 * If we find the buffer in the cache with this transaction 	 * pointer in its b_fsprivate2 field, then we know we already 	 * have it locked.  In this case we just increment the lock 	 * recursion count and return the buffer to the caller. 	 */
if|if
condition|(
name|tp
operator|->
name|t_items
operator|.
name|lic_next
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|xfs_trans_buf_item_match
argument_list|(
name|tp
argument_list|,
name|target_dev
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|xfs_trans_buf_item_match_all
argument_list|(
name|tp
argument_list|,
name|target_dev
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|)
condition|)
block|{
name|xfs_buftrace
argument_list|(
literal|"TRANS GET RECUR SHUT"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SUPER_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the buffer is stale then it was binval'ed 		 * since last read.  This doesn't matter since the 		 * caller isn't allowed to use the data anyway. 		 */
elseif|else
if|if
condition|(
name|XFS_BUF_ISSTALE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_buftrace
argument_list|(
literal|"TRANS GET RECUR STALE"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_ISDELAYWRITE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_recur
operator|++
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"TRANS GET RECUR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"GET RECUR"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
comment|/* 	 * We always specify the BUF_BUSY flag within a transaction so 	 * that get_buf does not try to push out a delayed write buffer 	 * which might cause another transaction to take place (if the 	 * buffer was delayed alloc).  Such recursive transactions can 	 * easily deadlock with our current transaction as well as cause 	 * us to run out of stack space. 	 */
name|bp
operator|=
name|xfs_buf_get_flags
argument_list|(
name|target_dev
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|flags
operator||
name|BUF_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The xfs_buf_log_item pointer is stored in b_fsprivate.  If 	 * it doesn't have one yet, then allocate one and initialize it. 	 * The checks to see if one is there are in xfs_buf_item_init(). 	 */
name|xfs_buf_item_init
argument_list|(
name|bp
argument_list|,
name|tp
operator|->
name|t_mountp
argument_list|)
expr_stmt|;
comment|/* 	 * Set the recursion count for the buffer within this transaction 	 * to 0. 	 */
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_recur
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Take a reference for this transaction on the buf item. 	 */
name|atomic_inc
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
expr_stmt|;
comment|/* 	 * Get a log_item_desc to point at the new item. 	 */
operator|(
name|void
operator|)
name|xfs_trans_add_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize b_fsprivate2 so we can find it with incore_match() 	 * above. 	 */
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"TRANS GET"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"GET"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get and lock the superblock buffer of this file system for the  * given transaction.  *  * We don't need to use incore_match() here, because the superblock  * buffer is a private buffer which we keep a pointer to in the  * mount structure.  */
end_comment

begin_function
name|xfs_buf_t
modifier|*
name|xfs_trans_getsb
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
comment|/* 	 * Default to just trying to lock the superblock buffer 	 * if tp is NULL. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If the superblock buffer already has this transaction 	 * pointer in its b_fsprivate2 field, then we know we already 	 * have it locked.  In this case we just increment the lock 	 * recursion count and return the buffer to the caller. 	 */
name|bp
operator|=
name|mp
operator|->
name|m_sb_bp
expr_stmt|;
if|if
condition|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
condition|)
block|{
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_recur
operator|++
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"GETSB RECUR"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
name|bp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* 	 * The xfs_buf_log_item pointer is stored in b_fsprivate.  If 	 * it doesn't have one yet, then allocate one and initialize it. 	 * The checks to see if one is there are in xfs_buf_item_init(). 	 */
name|xfs_buf_item_init
argument_list|(
name|bp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Set the recursion count for the buffer within this transaction 	 * to 0. 	 */
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_recur
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Take a reference for this transaction on the buf item. 	 */
name|atomic_inc
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
expr_stmt|;
comment|/* 	 * Get a log_item_desc to point at the new item. 	 */
operator|(
name|void
operator|)
name|xfs_trans_add_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize b_fsprivate2 so we can find it with incore_match() 	 * above. 	 */
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"GETSB"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|xfs_buftarg_t
modifier|*
name|xfs_error_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_do_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_req_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_error_mod
init|=
literal|33
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get and lock the buffer for the caller if it is not already  * locked within the given transaction.  If it has not yet been  * read in, read it from disk. If it is already locked  * within the transaction and already read in, just increment its  * lock recursion count and return a pointer to it.  *  * Use the fast path function xfs_trans_buf_item_match() or the buffer  * cache routine incore_match() to find the buffer  * if it is already owned by this transaction.  *  * If we don't already own the buffer, use read_buf() to get it.  * If it doesn't yet have an associated xfs_buf_log_item structure,  * then allocate one and add the item to this transaction.  *  * If the transaction pointer is NULL, make this just a normal  * read_buf() call.  */
end_comment

begin_function
name|int
name|xfs_trans_read_buf
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|target
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|,
name|int
name|len
parameter_list|,
name|uint
name|flags
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
name|flags
operator|=
name|XFS_BUF_LOCK
operator||
name|XFS_BUF_MAPPED
expr_stmt|;
comment|/* 	 * Default to a normal get_buf() call if the tp is NULL. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|target
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|flags
operator||
name|BUF_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOMEM
argument_list|)
return|;
if|if
condition|(
operator|(
name|bp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_trans_read_buf"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|xfs_do_error
operator|&&
operator|(
name|bp
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|xfs_error_target
operator|==
name|target
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|xfs_req_num
operator|++
operator|)
operator|%
name|xfs_error_mod
operator|)
operator|==
literal|0
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"Returning error!\n"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
goto|goto
name|shutdown_abort
goto|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If we find the buffer in the cache with this transaction 	 * pointer in its b_fsprivate2 field, then we know we already 	 * have it locked.  If it is already read in we just increment 	 * the lock recursion count and return the buffer to the caller. 	 * If the buffer is not yet read in, then we read it in, increment 	 * the lock recursion count, and return it to the caller. 	 */
if|if
condition|(
name|tp
operator|->
name|t_items
operator|.
name|lic_next
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|xfs_trans_buf_item_match
argument_list|(
name|tp
argument_list|,
name|target
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|xfs_trans_buf_item_match_all
argument_list|(
name|tp
argument_list|,
name|target
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|XFS_BUF_ISERROR
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XFS_BUF_ISDONE
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_buftrace
argument_list|(
literal|"READ_BUF_INCORE !DONE"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_ISASYNC
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_BUF_READ
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfsbdstrat
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_iowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_trans_read_buf"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 				 * We can gracefully recover from most 				 * read errors. Ones we can't are those 				 * that happen after the transaction's 				 * already dirty. 				 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DIRTY
condition|)
name|xfs_force_shutdown
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* 		 * We never locked this buf ourselves, so we shouldn't 		 * brelse it either. Just get out. 		 */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|xfs_buftrace
argument_list|(
literal|"READ_BUF_INCORE XFSSHUTDN"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|NULL
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_recur
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"READ RECUR"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * We always specify the BUF_BUSY flag within a transaction so 	 * that get_buf does not try to push out a delayed write buffer 	 * which might cause another transaction to take place (if the 	 * buffer was delayed alloc).  Such recursive transactions can 	 * easily deadlock with our current transaction as well as cause 	 * us to run out of stack space. 	 */
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|target
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|flags
operator||
name|BUF_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
operator|*
name|bpp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XFS_BUF_SUPER_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"READ ERROR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_trans_read_buf"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DIRTY
condition|)
name|xfs_force_shutdown
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|xfs_do_error
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DIRTY
operator|)
condition|)
block|{
if|if
condition|(
name|xfs_error_target
operator|==
name|target
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|xfs_req_num
operator|++
operator|)
operator|%
name|xfs_error_mod
operator|)
operator|==
literal|0
condition|)
block|{
name|xfs_force_shutdown
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"Returning error in trans!\n"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
goto|goto
name|shutdown_abort
goto|;
comment|/* 	 * The xfs_buf_log_item pointer is stored in b_fsprivate.  If 	 * it doesn't have one yet, then allocate one and initialize it. 	 * The checks to see if one is there are in xfs_buf_item_init(). 	 */
name|xfs_buf_item_init
argument_list|(
name|bp
argument_list|,
name|tp
operator|->
name|t_mountp
argument_list|)
expr_stmt|;
comment|/* 	 * Set the recursion count for the buffer within this transaction 	 * to 0. 	 */
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_recur
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Take a reference for this transaction on the buf item. 	 */
name|atomic_inc
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
expr_stmt|;
comment|/* 	 * Get a log_item_desc to point at the new item. 	 */
operator|(
name|void
operator|)
name|xfs_trans_add_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize b_fsprivate2 so we can find it with incore_match() 	 * above. 	 */
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"TRANS READ"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"READ"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
name|shutdown_abort
label|:
comment|/* 	 * the theory here is that buffer is good but we're 	 * bailing out because the filesystem is being forcibly 	 * shut down.  So we should leave the b_flags alone since 	 * the buffer's not staled and just get out. 	 */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
if|if
condition|(
name|XFS_BUF_ISSTALE
argument_list|(
name|bp
argument_list|)
operator|&&
name|XFS_BUF_ISDELAYWRITE
argument_list|(
name|bp
argument_list|)
condition|)
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"about to pop assert, bp == 0x%p"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
operator|(
name|XFS_BUF_BFLAGS
argument_list|(
name|bp
argument_list|)
operator|&
operator|(
name|XFS_B_STALE
operator||
name|XFS_B_DELWRI
operator|)
operator|)
operator|!=
operator|(
name|XFS_B_STALE
operator||
name|XFS_B_DELWRI
operator|)
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"READ_BUF XFSSHUTDN"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|NULL
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release the buffer bp which was previously acquired with one of the  * xfs_trans_... buffer allocation routines if the buffer has not  * been modified within this transaction.  If the buffer is modified  * within this transaction, do decrement the recursion count but do  * not release the buffer even if the count goes to 0.  If the buffer is not  * modified within the transaction, decrement the recursion count and  * release the buffer if the recursion count goes to 0.  *  * If the buffer is to be released and it was not modified before  * this transaction began, then free the buf_log_item associated with it.  *  * If the transaction pointer is NULL, make this just a normal  * brelse() call.  */
end_comment

begin_function
name|void
name|xfs_trans_brelse
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
comment|/* 	 * Default to a normal brelse() call if the tp is NULL. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If there's a buf log item attached to the buffer, 		 * then let the AIL know that the buffer is being 		 * unlocked. 		 */
if|if
condition|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
operator|->
name|li_type
operator|==
name|XFS_LI_BUF
condition|)
block|{
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|xfs_trans_unlocked_item
argument_list|(
name|bip
operator|->
name|bli_item
operator|.
name|li_mountp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
block|}
block|}
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_item
operator|.
name|li_type
operator|==
name|XFS_LI_BUF
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Find the item descriptor pointing to this buffer's 	 * log item.  It must be there. 	 */
name|lidp
operator|=
name|xfs_trans_find_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If the release is just for a recursive lock, 	 * then decrement the count and return. 	 */
if|if
condition|(
name|bip
operator|->
name|bli_recur
operator|>
literal|0
condition|)
block|{
name|bip
operator|->
name|bli_recur
operator|--
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"RELSE RECUR"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the buffer is dirty within this transaction, we can't 	 * release it until we commit. 	 */
if|if
condition|(
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_DIRTY
condition|)
block|{
name|xfs_buf_item_trace
argument_list|(
literal|"RELSE DIRTY"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the buffer has been invalidated, then we can't release 	 * it until the transaction commits to disk unless it is re-dirtied 	 * as part of this transaction.  This prevents us from pulling 	 * the item from the AIL before we should. 	 */
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
condition|)
block|{
name|xfs_buf_item_trace
argument_list|(
literal|"RELSE STALE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"RELSE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
comment|/* 	 * Free up the log item descriptor tracking the released item. 	 */
name|xfs_trans_free_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the hold flag in the buf log item if it is set. 	 * We wouldn't want the next user of the buffer to 	 * get confused. 	 */
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_HOLD
condition|)
block|{
name|bip
operator|->
name|bli_flags
operator|&=
operator|~
name|XFS_BLI_HOLD
expr_stmt|;
block|}
comment|/* 	 * Drop our reference to the buf log item. 	 */
name|atomic_dec
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
expr_stmt|;
comment|/* 	 * If the buf item is not tracking data in the log, then 	 * we must free it before releasing the buffer back to the 	 * free pool.  Before releasing the buffer to the free pool, 	 * clear the transaction pointer in b_fsprivate2 to dissolve 	 * its relation to this transaction. 	 */
if|if
condition|(
operator|!
name|xfs_buf_item_dirty
argument_list|(
name|bip
argument_list|)
condition|)
block|{
comment|/*** 		ASSERT(bp->b_pincount == 0); ***/
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_INODE_ALLOC_BUF
operator|)
argument_list|)
expr_stmt|;
name|xfs_buf_item_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bip
operator|=
name|NULL
expr_stmt|;
block|}
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If we've still got a buf log item on the buffer, then 	 * tell the AIL that the buffer is being unlocked. 	 */
if|if
condition|(
name|bip
operator|!=
name|NULL
condition|)
block|{
name|xfs_trans_unlocked_item
argument_list|(
name|bip
operator|->
name|bli_item
operator|.
name|li_mountp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
block|}
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Add the locked buffer to the transaction.  * The buffer must be locked, and it cannot be associated with any  * transaction.  *  * If the buffer does not yet have a buf log item associated with it,  * then allocate one for it.  Then add the buf item to the transaction.  */
end_comment

begin_function
name|void
name|xfs_trans_bjoin
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * The xfs_buf_log_item pointer is stored in b_fsprivate.  If 	 * it doesn't have one yet, then allocate one and initialize it. 	 * The checks to see if one is there are in xfs_buf_item_init(). 	 */
name|xfs_buf_item_init
argument_list|(
name|bp
argument_list|,
name|tp
operator|->
name|t_mountp
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Take a reference for this transaction on the buf item. 	 */
name|atomic_inc
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
expr_stmt|;
comment|/* 	 * Get a log_item_desc to point at the new item. 	 */
operator|(
name|void
operator|)
name|xfs_trans_add_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize b_fsprivate2 so we can find it with incore_match() 	 * in xfs_trans_get_buf() and friends above. 	 */
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"BJOIN"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the buffer as not needing to be unlocked when the buf item's  * IOP_UNLOCK() routine is called.  The buffer must already be locked  * and associated with the given transaction.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_trans_bhold
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator||=
name|XFS_BLI_HOLD
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"BHOLD"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel the previous buffer hold request made on this buffer  * for this transaction.  */
end_comment

begin_function
name|void
name|xfs_trans_bhold_release
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_HOLD
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator|&=
operator|~
name|XFS_BLI_HOLD
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"BHOLD RELEASE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to mark bytes first through last inclusive of the given  * buffer as needing to be logged when the transaction is committed.  * The buffer must already be associated with the given transaction.  *  * First and last are numbers relative to the beginning of this buffer,  * so the first byte in the buffer is numbered 0 regardless of the  * value of b_blkno.  */
end_comment

begin_function
name|void
name|xfs_trans_log_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|uint
name|first
parameter_list|,
name|uint
name|last
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|first
operator|<=
name|last
operator|)
operator|&&
operator|(
name|last
operator|<
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|==
name|xfs_buf_iodone_callbacks
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the buffer as needing to be written out eventually, 	 * and set its iodone function to remove the buffer's buf log 	 * item from the AIL and free it when the buffer is flushed 	 * to disk.  See xfs_buf_attach_iodone() for more details 	 * on li_cb and xfs_buf_iodone_callbacks(). 	 * If we end up aborting this transaction, we trap this buffer 	 * inside the b_bdstrat callback so that this won't get written to 	 * disk. 	 */
name|XFS_BUF_DELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_DONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xfs_buf_iodone_callbacks
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_item
operator|.
name|li_cb
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_buf_t
operator|*
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_iodone
expr_stmt|;
comment|/* 	 * If we invalidated the buffer within this transaction, then 	 * cancel the invalidation now that we're dirtying the buffer 	 * again.  There are no races with the code in xfs_buf_item_unpin(), 	 * because we have a reference to the buffer this entire time. 	 */
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
condition|)
block|{
name|xfs_buf_item_trace
argument_list|(
literal|"BLOG UNSTALE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator|&=
operator|~
name|XFS_BLI_STALE
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISSTALE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_BUF_UNSTALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&=
operator|~
name|XFS_BLI_CANCEL
expr_stmt|;
block|}
name|lidp
operator|=
name|xfs_trans_find_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|XFS_TRANS_DIRTY
expr_stmt|;
name|lidp
operator|->
name|lid_flags
operator||=
name|XFS_LID_DIRTY
expr_stmt|;
name|lidp
operator|->
name|lid_flags
operator|&=
operator|~
name|XFS_LID_BUF_STALE
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator||=
name|XFS_BLI_LOGGED
expr_stmt|;
name|xfs_buf_item_log
argument_list|(
name|bip
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"BLOG"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This called to invalidate a buffer that is being used within  * a transaction.  Typically this is because the blocks in the  * buffer are being freed, so we need to prevent it from being  * written out when we're done.  Allowing it to be written again  * might overwrite data in the free blocks if they are reallocated  * to a file.  *  * We prevent the buffer from being written out by clearing the  * B_DELWRI flag.  We can't always  * get rid of the buf log item at this point, though, because  * the buffer may still be pinned by another transaction.  If that  * is the case, then we'll wait until the buffer is committed to  * disk for the last time (we can tell by the ref count) and  * free it in xfs_buf_item_unpin().  Until it is cleaned up we  * will keep the buffer locked so that the buffer and buf log item  * are not reused.  */
end_comment

begin_function
name|void
name|xfs_trans_binval
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|lidp
operator|=
name|xfs_trans_find_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
condition|)
block|{
comment|/* 		 * If the buffer is already invalidated, then 		 * just return. 		 */
name|ASSERT
argument_list|(
operator|!
operator|(
name|XFS_BUF_ISDELAYWRITE
argument_list|(
name|bp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISSTALE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
operator|(
name|XFS_BLI_LOGGED
operator||
name|XFS_BLI_DIRTY
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_INODE_BUF
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_DIRTY
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DIRTY
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_BINVAL RECUR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"BINVAL RECUR"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Clear the dirty bit in the buffer and set the STALE flag 	 * in the buf log item.  The STALE flag will be used in 	 * xfs_buf_item_unpin() to determine if it should clean up 	 * when the last reference to the buf item is given up. 	 * We set the XFS_BLI_CANCEL flag in the buf log format structure 	 * and log the buf item.  This will be used at recovery time 	 * to determine that copies of the buffer in the log before 	 * this should not be replayed. 	 * We mark the item descriptor and the transaction dirty so 	 * that we'll hold the buffer until after the commit. 	 * 	 * Since we're invalidating the buffer, we also clear the state 	 * about which parts of the buffer have been logged.  We also 	 * clear the flag indicating that this is an inode buffer since 	 * the data in the buffer will no longer be valid. 	 * 	 * We set the stale bit in the buffer as well since we're getting 	 * rid of it. 	 */
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator||=
name|XFS_BLI_STALE
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator|&=
operator|~
operator|(
name|XFS_BLI_LOGGED
operator||
name|XFS_BLI_DIRTY
operator|)
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&=
operator|~
name|XFS_BLI_INODE_BUF
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator||=
name|XFS_BLI_CANCEL
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|lidp
operator|->
name|lid_flags
operator||=
name|XFS_LID_DIRTY
operator||
name|XFS_LID_BUF_STALE
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|XFS_TRANS_DIRTY
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_BINVAL"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"BINVAL"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This call is used to indicate that the buffer contains on-disk  * inodes which must be handled specially during recovery.  They  * require special handling because only the di_next_unlinked from  * the inodes in the buffer should be recovered.  The rest of the  * data in the buffer is logged via the inodes themselves.  *  * All we do is set the XFS_BLI_INODE_BUF flag in the buffer's log  * format structure so that we'll know what to do at recovery time.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_trans_inode_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator||=
name|XFS_BLI_INODE_BUF
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This call is used to indicate that the buffer is going to  * be staled and was an inode buffer. This means it gets  * special processing during unpin - where any inodes   * associated with the buffer should be removed from ail.  * There is also special processing during recovery,  * any replay of the inodes in the buffer needs to be  * prevented as the buffer may have been reused.  */
end_comment

begin_function
name|void
name|xfs_trans_stale_inode_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator||=
name|XFS_BLI_STALE_INODE
expr_stmt|;
name|bip
operator|->
name|bli_item
operator|.
name|li_cb
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_buf_t
operator|*
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_iodone
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the buffer as being one which contains newly allocated  * inodes.  We need to make sure that even if this buffer is  * relogged as an 'inode buf' we still recover all of the inode  * images in the face of a crash.  This works in coordination with  * xfs_buf_item_committed() to ensure that the buffer remains in the  * AIL at its original location even after it has been relogged.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_trans_inode_alloc_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_flags
operator||=
name|XFS_BLI_INODE_ALLOC_BUF
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Similar to xfs_trans_inode_buf(), this marks the buffer as a cluster of  * dquots. However, unlike in inode buffer recovery, dquot buffers get  * recovered in their entirety. (Hence, no XFS_BLI_DQUOT_ALLOC_BUF flag).  * The only thing that makes dquot buffers different from regular  * buffers is that we must not replay dquot bufs when recovering  * if a _corresponding_ quotaoff has happened. We also have to distinguish  * between usr dquot bufs and grp dquot bufs, because usr and grp quotas  * can be turned off independently.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_trans_dquot_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|uint
name|type
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|type
operator|==
name|XFS_BLI_UDQUOT_BUF
operator|||
name|type
operator|==
name|XFS_BLI_PDQUOT_BUF
operator|||
name|type
operator|==
name|XFS_BLI_GDQUOT_BUF
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator||=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a buffer matching the given parameters is already  * a part of the given transaction.  Only check the first, embedded  * chunk, since we don't want to spend all day scanning large transactions.  */
end_comment

begin_function
name|STATIC
name|xfs_buf_t
modifier|*
name|xfs_trans_buf_item_match
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|target
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|blip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|BBTOB
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|licp
operator|=
operator|&
name|tp
operator|->
name|t_items
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Skip unoccupied slots. 			 */
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|lidp
operator|=
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|blip
operator|=
operator|(
name|xfs_buf_log_item_t
operator|*
operator|)
name|lidp
operator|->
name|lid_item
expr_stmt|;
if|if
condition|(
name|blip
operator|->
name|bli_item
operator|.
name|li_type
operator|!=
name|XFS_LI_BUF
condition|)
block|{
continue|continue;
block|}
name|bp
operator|=
name|blip
operator|->
name|bli_buf
expr_stmt|;
if|if
condition|(
operator|(
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
operator|==
name|target
operator|)
operator|&&
operator|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|==
name|blkno
operator|)
operator|&&
operator|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|==
name|len
operator|)
condition|)
block|{
comment|/* 				 * We found it.  Break out and 				 * return the pointer to the buffer. 				 */
break|break;
block|}
else|else
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a buffer matching the given parameters is already  * a part of the given transaction.  Check all the chunks, we  * want to be thorough.  */
end_comment

begin_function
name|STATIC
name|xfs_buf_t
modifier|*
name|xfs_trans_buf_item_match_all
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|target
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|blip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|BBTOB
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|licp
operator|=
operator|&
name|tp
operator|->
name|t_items
init|;
name|licp
operator|!=
name|NULL
condition|;
name|licp
operator|=
name|licp
operator|->
name|lic_next
control|)
block|{
if|if
condition|(
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|licp
operator|==
operator|&
name|tp
operator|->
name|t_items
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|licp
operator|->
name|lic_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Skip unoccupied slots. 			 */
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|lidp
operator|=
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|blip
operator|=
operator|(
name|xfs_buf_log_item_t
operator|*
operator|)
name|lidp
operator|->
name|lid_item
expr_stmt|;
if|if
condition|(
name|blip
operator|->
name|bli_item
operator|.
name|li_type
operator|!=
name|XFS_LI_BUF
condition|)
block|{
continue|continue;
block|}
name|bp
operator|=
name|blip
operator|->
name|bli_buf
expr_stmt|;
if|if
condition|(
operator|(
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
operator|==
name|target
operator|)
operator|&&
operator|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|==
name|blkno
operator|)
operator|&&
operator|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|==
name|len
operator|)
condition|)
block|{
comment|/* 				 * We found it.  Break out and 				 * return the pointer to the buffer. 				 */
return|return
name|bp
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

