begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_data.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_block.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_node.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_trace.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_comment
comment|/*  * Declarations for interface routines.  */
end_comment

begin_function_decl
specifier|static
name|void
name|xfs_dir2_mount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_isempty
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_init
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_inode_t
modifier|*
name|pdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_createname
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
name|inum
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_lookup
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
modifier|*
name|inum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_removename
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_replace
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
name|inum
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_canenter
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_shortform_validate_ondisk
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routine declarations.  */
end_comment

begin_function_decl
specifier|static
name|int
name|xfs_dir2_put_dirent64_direct
parameter_list|(
name|xfs_dir2_put_args_t
modifier|*
name|pa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_put_dirent64_uio
parameter_list|(
name|xfs_dir2_put_args_t
modifier|*
name|pa
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Directory operations vector.  */
end_comment

begin_decl_stmt
name|xfs_dirops_t
name|xfsv2_dirops
init|=
block|{
operator|.
name|xd_mount
operator|=
name|xfs_dir2_mount
block|,
operator|.
name|xd_isempty
operator|=
name|xfs_dir2_isempty
block|,
operator|.
name|xd_init
operator|=
name|xfs_dir2_init
block|,
operator|.
name|xd_createname
operator|=
name|xfs_dir2_createname
block|,
operator|.
name|xd_lookup
operator|=
name|xfs_dir2_lookup
block|,
operator|.
name|xd_removename
operator|=
name|xfs_dir2_removename
block|,
operator|.
name|xd_getdents
operator|=
name|xfs_dir2_getdents
block|,
operator|.
name|xd_replace
operator|=
name|xfs_dir2_replace
block|,
operator|.
name|xd_canenter
operator|=
name|xfs_dir2_canenter
block|,
operator|.
name|xd_shortform_validate_ondisk
operator|=
name|xfs_dir2_shortform_validate_ondisk
block|,
operator|.
name|xd_shortform_to_single
operator|=
name|xfs_dir2_sf_to_block
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Interface routines.  */
end_comment

begin_comment
comment|/*  * Initialize directory-related fields in the mount structure.  */
end_comment

begin_function
specifier|static
name|void
name|xfs_dir2_mount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
comment|/* filesystem mount point */
block|{
name|mp
operator|->
name|m_dirversion
operator|=
literal|2
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
literal|1
operator|<<
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
operator|+
name|mp
operator|->
name|m_sb
operator|.
name|sb_dirblklog
operator|)
operator|)
operator|<=
name|XFS_MAX_BLOCKSIZE
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dirblksize
operator|=
literal|1
operator|<<
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
operator|+
name|mp
operator|->
name|m_sb
operator|.
name|sb_dirblklog
operator|)
expr_stmt|;
name|mp
operator|->
name|m_dirblkfsbs
operator|=
literal|1
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_dirblklog
expr_stmt|;
name|mp
operator|->
name|m_dirdatablk
operator|=
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_DATA_FIRSTDB
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dirleafblk
operator|=
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_LEAF_FIRSTDB
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dirfreeblk
operator|=
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_FREE_FIRSTDB
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_attr_node_ents
operator|=
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_hdr_t
argument_list|)
operator|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dir_node_ents
operator|=
operator|(
name|mp
operator|->
name|m_dirblksize
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_hdr_t
argument_list|)
operator|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dir_magicpct
operator|=
operator|(
name|mp
operator|->
name|m_dirblksize
operator|*
literal|37
operator|)
operator|/
literal|100
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if directory contains only "." and "..".  */
end_comment

begin_function
specifier|static
name|int
comment|/* return code */
name|xfs_dir2_isempty
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|)
comment|/* incore inode structure */
block|{
name|xfs_dir2_sf_t
modifier|*
name|sfp
decl_stmt|;
comment|/* shortform directory structure */
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
comment|/* 	 * Might happen during shutdown. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|>
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
condition|)
return|return
literal|0
return|;
name|sfp
operator|=
operator|(
name|xfs_dir2_sf_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
return|return
operator|!
name|sfp
operator|->
name|hdr
operator|.
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a directory with its "." and ".." entries.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_init
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|xfs_inode_t
modifier|*
name|pdp
parameter_list|)
comment|/* incore parent directory inode */
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
comment|/* operation arguments */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|tp
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir_ino_validate
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|pdp
operator|->
name|i_ino
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
return|return
name|xfs_dir2_sf_create
argument_list|(
operator|&
name|args
argument_list|,
name|pdp
operator|->
name|i_ino
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*   Enter a name in a directory.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_createname
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|char
modifier|*
name|name
parameter_list|,
comment|/* new entry name */
name|int
name|namelen
parameter_list|,
comment|/* new entry name length */
name|xfs_ino_t
name|inum
parameter_list|,
comment|/* new entry inode number */
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
comment|/* bmap's firstblock */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* bmap's freeblock list */
name|xfs_extlen_t
name|total
parameter_list|)
comment|/* bmap's total block count */
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
comment|/* operation arguments */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|int
name|v
decl_stmt|;
comment|/* type-checking value */
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir_ino_validate
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|inum
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_dir_create
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|inum
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|first
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
name|rval
operator|=
name|xfs_dir2_sf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isblock
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_block_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isleaf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|xfs_dir2_node_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a name in a directory, give back the inode number.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_lookup
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|char
modifier|*
name|name
parameter_list|,
comment|/* lookup name */
name|int
name|namelen
parameter_list|,
comment|/* lookup name length */
name|xfs_ino_t
modifier|*
name|inum
parameter_list|)
comment|/* out: inode number */
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
comment|/* operation arguments */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|int
name|v
decl_stmt|;
comment|/* type-checking value */
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_dir_lookup
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|total
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
name|rval
operator|=
name|xfs_dir2_sf_lookup
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isblock
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_block_lookup
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isleaf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_leaf_lookup
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|xfs_dir2_node_lookup
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|EEXIST
condition|)
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
operator|*
name|inum
operator|=
name|args
operator|.
name|inumber
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from a directory.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_removename
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|char
modifier|*
name|name
parameter_list|,
comment|/* name of entry to remove */
name|int
name|namelen
parameter_list|,
comment|/* name length of entry to remove */
name|xfs_ino_t
name|ino
parameter_list|,
comment|/* inode number of entry to remove */
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
comment|/* bmap's firstblock */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* bmap's freeblock list */
name|xfs_extlen_t
name|total
parameter_list|)
comment|/* bmap's total block count */
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
comment|/* operation arguments */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|int
name|v
decl_stmt|;
comment|/* type-checking value */
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_dir_remove
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|ino
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|first
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
name|rval
operator|=
name|xfs_dir2_sf_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isblock
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_block_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isleaf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_leaf_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|xfs_dir2_node_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Read a directory.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|uio_t
modifier|*
name|uio
parameter_list|,
comment|/* caller's buffer control */
name|int
modifier|*
name|eofp
parameter_list|)
comment|/* out: eof reached */
block|{
name|int
name|alignment
decl_stmt|;
comment|/* alignment required for ABI */
name|xfs_dirent_t
modifier|*
name|dbp
decl_stmt|;
comment|/* malloc'ed buffer */
name|xfs_dir2_put_t
name|put
decl_stmt|;
comment|/* entry formatting routine */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|int
name|v
decl_stmt|;
comment|/* type-checking value */
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_dir_getdents
argument_list|)
expr_stmt|;
comment|/* 	 * If our caller has given us a single contiguous aligned memory buffer, 	 * just work directly within that buffer.  If it's in user memory, 	 * lock it down first. 	 */
name|alignment
operator|=
sizeof|sizeof
argument_list|(
name|xfs_off_t
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
operator|(
name|__psint_t
operator|)
name|uio
operator|->
name|uio_iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|&
name|alignment
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|uio
operator|->
name|uio_iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|&
name|alignment
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|dbp
operator|=
name|NULL
expr_stmt|;
name|put
operator|=
name|xfs_dir2_put_dirent64_direct
expr_stmt|;
block|}
else|else
block|{
name|dbp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dbp
argument_list|)
operator|+
name|MAXNAMELEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|put
operator|=
name|xfs_dir2_put_dirent64_uio
expr_stmt|;
block|}
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
name|rval
operator|=
name|xfs_dir2_sf_getdents
argument_list|(
name|dp
argument_list|,
name|uio
argument_list|,
name|eofp
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isblock
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_block_getdents
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|eofp
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|xfs_dir2_leaf_getdents
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|eofp
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|dbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbp
argument_list|)
operator|+
name|MAXNAMELEN
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Replace the inode number of a directory entry.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_replace
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|char
modifier|*
name|name
parameter_list|,
comment|/* name of entry to replace */
name|int
name|namelen
parameter_list|,
comment|/* name length of entry to replace */
name|xfs_ino_t
name|inum
parameter_list|,
comment|/* new inode number */
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
comment|/* bmap's firstblock */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* bmap's freeblock list */
name|xfs_extlen_t
name|total
parameter_list|)
comment|/* bmap's total block count */
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
comment|/* operation arguments */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|int
name|v
decl_stmt|;
comment|/* type-checking value */
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir_ino_validate
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|inum
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|inum
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|first
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
name|rval
operator|=
name|xfs_dir2_sf_replace
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isblock
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_block_replace
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isleaf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_leaf_replace
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|xfs_dir2_node_replace
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * See if this entry can be added to the directory without allocating space.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_canenter
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|char
modifier|*
name|name
parameter_list|,
comment|/* name of entry to add */
name|int
name|namelen
parameter_list|)
comment|/* name length of entry to add */
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
comment|/* operation arguments */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|int
name|v
decl_stmt|;
comment|/* type-checking value */
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|total
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
name|rval
operator|=
name|xfs_dir2_sf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isblock
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_block_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_dir2_isleaf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
name|rval
operator|=
name|xfs_dir2_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|xfs_dir2_node_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Dummy routine for shortform inode validation.  * Can't really do this.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_shortform_validate_ondisk
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* filesystem mount point */
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|)
comment|/* ondisk inode */
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_comment
comment|/*  * Add a block to the directory.  * This routine is for data and free blocks, not leaf/node blocks  * which are handled by xfs_da_grow_inode.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_grow_inode
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|int
name|space
parameter_list|,
comment|/* v2 dir's space XFS_DIR2_xxx_SPACE */
name|xfs_dir2_db_t
modifier|*
name|dbp
parameter_list|)
comment|/* out: block number added */
block|{
name|xfs_fileoff_t
name|bno
decl_stmt|;
comment|/* directory offset of new block */
name|int
name|count
decl_stmt|;
comment|/* count of filesystem blocks */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|got
decl_stmt|;
comment|/* blocks actually mapped */
name|int
name|i
decl_stmt|;
comment|/* temp mapping index */
name|xfs_bmbt_irec_t
name|map
decl_stmt|;
comment|/* single structure for bmap */
name|int
name|mapi
decl_stmt|;
comment|/* mapping index */
name|xfs_bmbt_irec_t
modifier|*
name|mapp
decl_stmt|;
comment|/* bmap mapping structure(s) */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|nmap
decl_stmt|;
comment|/* number of bmap entries */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args_s
argument_list|(
literal|"grow_inode"
argument_list|,
name|args
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * Set lowest possible block in the space requested. 	 */
name|bno
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|space
operator|*
name|XFS_DIR2_SPACE_SIZE
argument_list|)
expr_stmt|;
name|count
operator|=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
comment|/* 	 * Find the first hole for our block. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_first_unused
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|count
argument_list|,
operator|&
name|bno
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|nmap
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|firstblock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Try mapping the new block contiguously (one extent). 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
name|count
argument_list|,
name|XFS_BMAPI_WRITE
operator||
name|XFS_BMAPI_METADATA
operator||
name|XFS_BMAPI_CONTIG
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|total
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|args
operator|->
name|flist
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|nmap
operator|<=
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Got it in 1. 	 */
if|if
condition|(
name|nmap
operator|==
literal|1
condition|)
block|{
name|mapp
operator|=
operator|&
name|map
expr_stmt|;
name|mapi
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Didn't work and this is a multiple-fsb directory block. 	 * Try again with contiguous flag turned on. 	 */
elseif|else
if|if
condition|(
name|nmap
operator|==
literal|0
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
name|xfs_fileoff_t
name|b
decl_stmt|;
comment|/* current file offset */
comment|/* 		 * Space for maximum number of mappings. 		 */
name|mapp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 		 * Iterate until we get to the end of our block. 		 */
for|for
control|(
name|b
operator|=
name|bno
operator|,
name|mapi
operator|=
literal|0
init|;
name|b
operator|<
name|bno
operator|+
name|count
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
comment|/* current fsb count */
comment|/* 			 * Can't map more than MAX_NMAP at once. 			 */
name|nmap
operator|=
name|MIN
argument_list|(
name|XFS_BMAP_MAX_NMAP
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|int
call|)
argument_list|(
name|bno
operator|+
name|count
operator|-
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|XFS_BMAPI_WRITE
operator||
name|XFS_BMAPI_METADATA
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|total
argument_list|,
operator|&
name|mapp
index|[
name|mapi
index|]
argument_list|,
operator|&
name|nmap
argument_list|,
name|args
operator|->
name|flist
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|nmap
operator|<
literal|1
condition|)
break|break;
comment|/* 			 * Add this bunch into our table, go to the next offset. 			 */
name|mapi
operator|+=
name|nmap
expr_stmt|;
name|b
operator|=
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_blockcount
expr_stmt|;
block|}
block|}
comment|/* 	 * Didn't work. 	 */
else|else
block|{
name|mapi
operator|=
literal|0
expr_stmt|;
name|mapp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * See how many fsb's we got. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|got
operator|=
literal|0
init|;
name|i
operator|<
name|mapi
condition|;
name|i
operator|++
control|)
name|got
operator|+=
name|mapp
index|[
name|i
index|]
operator|.
name|br_blockcount
expr_stmt|;
comment|/* 	 * Didn't get enough fsb's, or the first/last block's are wrong. 	 */
if|if
condition|(
name|got
operator|!=
name|count
operator|||
name|mapp
index|[
literal|0
index|]
operator|.
name|br_startoff
operator|!=
name|bno
operator|||
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_blockcount
operator|!=
name|bno
operator|+
name|count
condition|)
block|{
if|if
condition|(
name|mapp
operator|!=
operator|&
name|map
condition|)
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* 	 * Done with the temporary mapping table. 	 */
if|if
condition|(
name|mapp
operator|!=
operator|&
name|map
condition|)
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
name|XFS_DIR2_DA_TO_DB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_dablk_t
operator|)
name|bno
argument_list|)
expr_stmt|;
comment|/* 	 * Update file's size if this is the data space and it grew. 	 */
if|if
condition|(
name|space
operator|==
name|XFS_DIR2_DATA_SPACE
condition|)
block|{
name|xfs_fsize_t
name|size
decl_stmt|;
comment|/* directory file (data) size */
name|size
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|bno
operator|+
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|dp
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|size
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * See if the directory is a single-block form directory.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_isblock
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|int
modifier|*
name|vp
parameter_list|)
comment|/* out: 1 is block, 0 is not block */
block|{
name|xfs_fileoff_t
name|last
decl_stmt|;
comment|/* last file offset */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|last
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
name|rval
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|last
argument_list|)
operator|==
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
name|ASSERT
argument_list|(
name|rval
operator|==
literal|0
operator|||
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|==
name|mp
operator|->
name|m_dirblksize
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|rval
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * See if the directory is a single-leaf form directory.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_isleaf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|int
modifier|*
name|vp
parameter_list|)
comment|/* out: 1 is leaf, 0 is not leaf */
block|{
name|xfs_fileoff_t
name|last
decl_stmt|;
comment|/* last file offset */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|last
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|rval
return|;
block|}
operator|*
name|vp
operator|=
name|last
operator|==
name|mp
operator|->
name|m_dirleafblk
operator|+
operator|(
literal|1
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_dirblklog
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Getdents put routine for 64-bit ABI, direct form.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_put_dirent64_direct
parameter_list|(
name|xfs_dir2_put_args_t
modifier|*
name|pa
parameter_list|)
comment|/* argument bundle */
block|{
name|struct
name|dirent
modifier|*
name|idbp
decl_stmt|,
name|dtmp
decl_stmt|;
comment|/* dirent pointer */
name|iovec_t
modifier|*
name|iovp
decl_stmt|;
comment|/* io vector */
name|int
name|namelen
decl_stmt|;
comment|/* entry name length */
name|int
name|reclen
decl_stmt|;
comment|/* entry total length */
name|uio_t
modifier|*
name|uio
decl_stmt|;
comment|/* I/O control */
name|namelen
operator|=
name|pa
operator|->
name|namelen
expr_stmt|;
name|dtmp
operator|.
name|d_namlen
operator|=
name|namelen
expr_stmt|;
name|dtmp
operator|.
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
operator|&
name|dtmp
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|dtmp
operator|.
name|d_reclen
expr_stmt|;
name|uio
operator|=
name|pa
operator|->
name|uio
expr_stmt|;
comment|/* 	 * Won't fit in the remaining space. 	 */
if|if
condition|(
name|reclen
operator|>
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|pa
operator|->
name|done
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iovp
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|idbp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
name|iovp
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|idbp
operator|+
name|reclen
expr_stmt|;
name|iovp
operator|->
name|iov_len
operator|-=
name|reclen
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|reclen
expr_stmt|;
name|idbp
operator|->
name|d_reclen
operator|=
name|reclen
expr_stmt|;
name|idbp
operator|->
name|d_fileno
operator|=
name|pa
operator|->
name|ino
expr_stmt|;
name|idbp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|idbp
operator|->
name|d_namlen
operator|=
name|namelen
expr_stmt|;
name|memcpy
argument_list|(
name|idbp
operator|->
name|d_name
argument_list|,
name|pa
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|idbp
operator|->
name|d_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pa
operator|->
name|done
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Getdents put routine for 64-bit ABI, uio form.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_put_dirent64_uio
parameter_list|(
name|xfs_dir2_put_args_t
modifier|*
name|pa
parameter_list|)
comment|/* argument bundle */
block|{
name|struct
name|dirent
modifier|*
name|idbp
decl_stmt|,
name|dtmp
decl_stmt|;
comment|/* dirent pointer */
name|int
name|namelen
decl_stmt|;
comment|/* entry name length */
name|int
name|reclen
decl_stmt|;
comment|/* entry total length */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|uio_t
modifier|*
name|uio
decl_stmt|;
comment|/* I/O control */
name|namelen
operator|=
name|pa
operator|->
name|namelen
expr_stmt|;
name|dtmp
operator|.
name|d_namlen
operator|=
name|namelen
expr_stmt|;
name|dtmp
operator|.
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
operator|&
name|dtmp
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|dtmp
operator|.
name|d_reclen
expr_stmt|;
name|uio
operator|=
name|pa
operator|->
name|uio
expr_stmt|;
comment|/* 	 * Won't fit in the remaining space. 	 */
if|if
condition|(
name|reclen
operator|>
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|pa
operator|->
name|done
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|idbp
operator|=
operator|&
name|dtmp
expr_stmt|;
name|idbp
operator|->
name|d_reclen
operator|=
name|reclen
expr_stmt|;
name|idbp
operator|->
name|d_fileno
operator|=
name|pa
operator|->
name|ino
expr_stmt|;
name|idbp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|idbp
operator|->
name|d_namlen
operator|=
name|namelen
expr_stmt|;
name|memcpy
argument_list|(
name|idbp
operator|->
name|d_name
argument_list|,
name|pa
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|idbp
operator|->
name|d_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rval
operator|=
name|uio_read
argument_list|(
operator|(
name|caddr_t
operator|)
name|idbp
argument_list|,
name|reclen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|pa
operator|->
name|done
operator|=
operator|(
name|rval
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the given block from the directory.  * This routine is used for data and free blocks, leaf/node are done  * by xfs_da_shrink_inode.  */
end_comment

begin_function
name|int
name|xfs_dir2_shrink_inode
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dir2_db_t
name|db
parameter_list|,
comment|/* directory block number */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* block's buffer */
block|{
name|xfs_fileoff_t
name|bno
decl_stmt|;
comment|/* directory file offset */
name|xfs_dablk_t
name|da
decl_stmt|;
comment|/* directory file offset */
name|int
name|done
decl_stmt|;
comment|/* bunmap is finished */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args_db
argument_list|(
literal|"shrink_inode"
argument_list|,
name|args
argument_list|,
name|db
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|da
operator|=
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * Unmap the fsblock(s). 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bunmapi
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|da
argument_list|,
name|mp
operator|->
name|m_dirblkfsbs
argument_list|,
name|XFS_BMAPI_METADATA
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|flist
argument_list|,
name|NULL
argument_list|,
operator|&
name|done
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * ENOSPC actually can happen if we're in a removename with 		 * no space reservation, and the resulting block removal 		 * would cause a bmap btree split or conversion from extents 		 * to btree.  This can only happen for un-fragmented 		 * directory blocks, since you need to be punching out 		 * the middle of an extent. 		 * In this case we need to leave the block in the file, 		 * and not binval it. 		 * So the block has to be in a consistent empty state 		 * and appropriately logged. 		 * We don't free up the buffer, the caller can tell it 		 * hasn't happened since it got an error back. 		 */
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|done
argument_list|)
expr_stmt|;
comment|/* 	 * Invalidate the buffer from the transaction. 	 */
name|xfs_da_binval
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * If it's not a data block, we're done. 	 */
if|if
condition|(
name|db
operator|>=
name|XFS_DIR2_LEAF_FIRSTDB
argument_list|(
name|mp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * If the block isn't the last one in the directory, we're done. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|>
name|XFS_DIR2_DB_OFF_TO_BYTE
argument_list|(
name|mp
argument_list|,
name|db
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|bno
operator|=
name|da
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_last_before
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|bno
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * This can't really happen unless there's kernel corruption. 		 */
return|return
name|error
return|;
block|}
if|if
condition|(
name|db
operator|==
name|mp
operator|->
name|m_dirdatablk
condition|)
name|ASSERT
argument_list|(
name|bno
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|ASSERT
argument_list|(
name|bno
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set the size to the new last block. 	 */
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

