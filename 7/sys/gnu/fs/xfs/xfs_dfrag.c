begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2006 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dfrag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/*  * Syssgi interface for swapext  */
end_comment

begin_function
name|int
name|xfs_swapext
parameter_list|(
name|xfs_swapext_t
name|__user
modifier|*
name|sxu
parameter_list|)
block|{
name|xfs_swapext_t
modifier|*
name|sxp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
init|=
name|NULL
decl_stmt|,
modifier|*
name|tip
init|=
name|NULL
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|,
modifier|*
name|tvp
init|=
name|NULL
decl_stmt|;
name|struct
name|vnode
modifier|*
name|bvp
decl_stmt|,
modifier|*
name|btvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sxp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_swapext_t
argument_list|)
argument_list|,
name|KM_MAYFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sxp
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|cred
modifier|*
name|cred
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
name|sxp
argument_list|,
name|sxu
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_swapext_t
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* Pull information for the target fd */
if|if
condition|(
name|fgetvp
argument_list|(
name|td
argument_list|,
operator|(
name|int
operator|)
name|sxp
operator|->
name|sx_fdtarget
argument_list|,
operator|&
name|bvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|vp
operator|=
name|VPTOXFSVP
argument_list|(
name|bvp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|xfs_vtoi
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
name|fgetvp
argument_list|(
name|td
argument_list|,
operator|(
name|int
operator|)
name|sxp
operator|->
name|sx_fdtmp
argument_list|,
operator|&
name|btvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|tvp
operator|=
name|VPTOXFSVP
argument_list|(
name|btvp
argument_list|)
expr_stmt|;
name|tip
operator|=
name|xfs_vtoi
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_mount
operator|!=
name|tip
operator|->
name|i_mount
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|tip
operator|->
name|i_ino
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|error
operator|=
name|XFS_SWAP_EXTENTS
argument_list|(
name|mp
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
operator|&
name|tip
operator|->
name|i_iocore
argument_list|,
name|sxp
argument_list|)
expr_stmt|;
name|error0
label|:
ifdef|#
directive|ifdef
name|RMC
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fput
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|!=
name|NULL
condition|)
name|fput
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sxp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|sxp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_swapext_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|xfs_swap_extents
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_inode_t
modifier|*
name|tip
parameter_list|,
name|xfs_swapext_t
modifier|*
name|sxp
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ips
index|[
literal|2
index|]
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_bstat_t
modifier|*
name|sbp
init|=
operator|&
name|sxp
operator|->
name|sx_stat
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|tempifp
decl_stmt|,
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|tifp
decl_stmt|;
name|int
name|ilf_fields
decl_stmt|,
name|tilf_fields
decl_stmt|;
specifier|static
name|uint
name|lock_flags
init|=
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|aforkblks
init|=
literal|0
decl_stmt|;
name|int
name|taforkblks
init|=
literal|0
decl_stmt|;
name|__uint64_t
name|tmp
decl_stmt|;
name|char
name|locked
init|=
literal|0
decl_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|tempifp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_ifork_t
argument_list|)
argument_list|,
name|KM_MAYFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tempifp
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|sbp
operator|=
operator|&
name|sxp
operator|->
name|sx_stat
expr_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|XFS_ITOV
argument_list|(
name|tip
argument_list|)
expr_stmt|;
comment|/* Lock in i_ino order */
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|<
name|tip
operator|->
name|i_ino
condition|)
block|{
name|ips
index|[
literal|0
index|]
operator|=
name|ip
expr_stmt|;
name|ips
index|[
literal|1
index|]
operator|=
name|tip
expr_stmt|;
block|}
else|else
block|{
name|ips
index|[
literal|0
index|]
operator|=
name|tip
expr_stmt|;
name|ips
index|[
literal|1
index|]
operator|=
name|ip
expr_stmt|;
block|}
name|xfs_lock_inodes
argument_list|(
name|ips
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
comment|/* Check permissions */
name|error
operator|=
name|xfs_iaccess
argument_list|(
name|ip
argument_list|,
name|S_IWUSR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
name|error
operator|=
name|xfs_iaccess
argument_list|(
name|tip
argument_list|,
name|S_IWUSR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
comment|/* Verify that both files have the same format */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|!=
operator|(
name|tip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* Verify both files are either real-time or non-realtime */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|!=
operator|(
name|tip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* Should never get a local format */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
operator|||
name|tip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
name|VN_CACHED
argument_list|(
name|tvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfs_inval_cached_trace
argument_list|(
operator|&
name|tip
operator|->
name|i_iocore
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|XVOP_FLUSHINVAL_PAGES
argument_list|(
name|tvp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF_LOCKED
argument_list|)
expr_stmt|;
block|}
comment|/* Verify O_DIRECT for ftmp */
if|if
condition|(
name|VN_CACHED
argument_list|(
name|tvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* Verify all data are being swapped */
if|if
condition|(
name|sxp
operator|->
name|sx_offset
operator|!=
literal|0
operator|||
name|sxp
operator|->
name|sx_length
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|||
name|sxp
operator|->
name|sx_length
operator|!=
name|tip
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * If the target has extended attributes, the tmp file 	 * must also in order to ensure the correct data fork 	 * format. 	 */
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
operator|!=
name|XFS_IFORK_Q
argument_list|(
name|tip
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * Compare the current change& modify times with that 	 * passed in.  If they differ, we abort this swap. 	 * This is the mechanism used to ensure the calling 	 * process that the file was not changed out from 	 * under it. 	 */
if|if
condition|(
operator|(
name|sbp
operator|->
name|bs_ctime
operator|.
name|tv_sec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_sec
operator|)
operator|||
operator|(
name|sbp
operator|->
name|bs_ctime
operator|.
name|tv_nsec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_nsec
operator|)
operator|||
operator|(
name|sbp
operator|->
name|bs_mtime
operator|.
name|tv_sec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_sec
operator|)
operator|||
operator|(
name|sbp
operator|->
name|bs_mtime
operator|.
name|tv_nsec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_nsec
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* We need to fail if the file is memory mapped.  Once we have tossed 	 * all existing pages, the page fault will have no option 	 * but to go to the filesystem for pages. By making the page fault call 	 * VOP_READ (or write in the case of autogrow) they block on the iolock 	 * until we have switched the extents. 	 */
if|if
condition|(
name|VN_MAPPED
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * There is a race condition here since we gave up the 	 * ilock.  However, the data fork will not change since 	 * we have the iolock (locked for truncation too) so we 	 * are safe.  We don't really care if non-io related 	 * fields change. 	 */
name|XVOP_TOSS_PAGES
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SWAPEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ICHANGE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|xfs_lock_inodes
argument_list|(
name|ips
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Count the number of extended attribute blocks 	 */
if|if
condition|(
operator|(
operator|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_LOCAL
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_bmap_count_blocks
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ATTR_FORK
argument_list|,
operator|&
name|aforkblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|XFS_IFORK_Q
argument_list|(
name|tip
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
name|tip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_LOCAL
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_bmap_count_blocks
argument_list|(
name|tp
argument_list|,
name|tip
argument_list|,
name|XFS_ATTR_FORK
argument_list|,
operator|&
name|taforkblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
block|}
comment|/* 	 * Swap the data forks of the inodes 	 */
name|ifp
operator|=
operator|&
name|ip
operator|->
name|i_df
expr_stmt|;
name|tifp
operator|=
operator|&
name|tip
operator|->
name|i_df
expr_stmt|;
operator|*
name|tempifp
operator|=
operator|*
name|ifp
expr_stmt|;
comment|/* struct copy */
operator|*
name|ifp
operator|=
operator|*
name|tifp
expr_stmt|;
comment|/* struct copy */
operator|*
name|tifp
operator|=
operator|*
name|tempifp
expr_stmt|;
comment|/* struct copy */
comment|/* 	 * Fix the on-disk inode values 	 */
name|tmp
operator|=
operator|(
name|__uint64_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|=
name|tip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|-
name|taforkblks
operator|+
name|aforkblks
expr_stmt|;
name|tip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|=
name|tmp
operator|+
name|taforkblks
operator|-
name|aforkblks
expr_stmt|;
name|tmp
operator|=
operator|(
name|__uint64_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|=
name|tip
operator|->
name|i_d
operator|.
name|di_nextents
expr_stmt|;
name|tip
operator|->
name|i_d
operator|.
name|di_nextents
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
operator|(
name|__uint64_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_format
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|tip
operator|->
name|i_d
operator|.
name|di_format
expr_stmt|;
name|tip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|tmp
expr_stmt|;
name|ilf_fields
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
comment|/* If the extents fit in the inode, fix the 		 * pointer.  Otherwise it's already NULL or 		 * pointing to the extent. 		 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|<=
name|XFS_INLINE_EXTS
condition|)
block|{
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
expr_stmt|;
block|}
name|ilf_fields
operator||=
name|XFS_ILOG_DEXT
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|ilf_fields
operator||=
name|XFS_ILOG_DBROOT
expr_stmt|;
break|break;
block|}
name|tilf_fields
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
switch|switch
condition|(
name|tip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
comment|/* If the extents fit in the inode, fix the 		 * pointer.  Otherwise it's already NULL or 		 * pointing to the extent. 		 */
if|if
condition|(
name|tip
operator|->
name|i_d
operator|.
name|di_nextents
operator|<=
name|XFS_INLINE_EXTS
condition|)
block|{
name|tifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|tifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
expr_stmt|;
block|}
name|tilf_fields
operator||=
name|XFS_ILOG_DEXT
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|tilf_fields
operator||=
name|XFS_ILOG_DBROOT
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|XXXKAN
comment|/* Not necessary, vnodes are vrefed already by fgetvp */
comment|/* 	 * Increment vnode ref counts since xfs_trans_commit& 	 * xfs_trans_cancel will both unlock the inodes and 	 * decrement the associated ref counts. 	 */
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|tip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|ilf_fields
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|tip
argument_list|,
name|tilf_fields
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * transaction goes to disk before returning to the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SWAPEXT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
name|error0
label|:
if|if
condition|(
name|locked
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tempifp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|tempifp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_ifork_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

