begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_define
define|#
directive|define
name|XFS_ABSDIFF
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<= (b)) ? ((b) - (a)) : ((a) - (b)))
end_define

begin_define
define|#
directive|define
name|XFSA_FIXUP_BNO_OK
value|1
end_define

begin_define
define|#
directive|define
name|XFSA_FIXUP_CNT_OK
value|2
end_define

begin_function_decl
name|STATIC
name|int
name|xfs_alloc_search_busy
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_agnumber_t
name|agno
parameter_list|,
name|xfs_agblock_t
name|bno
parameter_list|,
name|xfs_extlen_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_ALLOC_TRACE
argument_list|)
end_if

begin_decl_stmt
name|ktrace_t
modifier|*
name|xfs_alloc_trace_buf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRACE_ALLOC
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
define|\
value|xfs_alloc_trace_alloc(fname, s, a, __LINE__)
end_define

begin_define
define|#
directive|define
name|TRACE_FREE
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|x
parameter_list|,
name|f
parameter_list|)
define|\
value|xfs_alloc_trace_free(fname, s, mp, a, b, x, f, __LINE__)
end_define

begin_define
define|#
directive|define
name|TRACE_MODAGF
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|)
define|\
value|xfs_alloc_trace_modagf(fname, s, mp, a, f, __LINE__)
end_define

begin_define
define|#
directive|define
name|TRACE_BUSY
parameter_list|(
name|fname
parameter_list|,
name|s
parameter_list|,
name|ag
parameter_list|,
name|agb
parameter_list|,
name|l
parameter_list|,
name|sl
parameter_list|,
name|tp
parameter_list|)
define|\
value|xfs_alloc_trace_busy(fname, s, mp, ag, agb, l, sl, tp, XFS_ALLOC_KTRACE_BUSY, __LINE__)
end_define

begin_define
define|#
directive|define
name|TRACE_UNBUSY
parameter_list|(
name|fname
parameter_list|,
name|s
parameter_list|,
name|ag
parameter_list|,
name|sl
parameter_list|,
name|tp
parameter_list|)
define|\
value|xfs_alloc_trace_busy(fname, s, mp, ag, -1, -1, sl, tp, XFS_ALLOC_KTRACE_UNBUSY, __LINE__)
end_define

begin_define
define|#
directive|define
name|TRACE_BUSYSEARCH
parameter_list|(
name|fname
parameter_list|,
name|s
parameter_list|,
name|ag
parameter_list|,
name|agb
parameter_list|,
name|l
parameter_list|,
name|sl
parameter_list|,
name|tp
parameter_list|)
define|\
value|xfs_alloc_trace_busy(fname, s, mp, ag, agb, l, sl, tp, XFS_ALLOC_KTRACE_BUSYSEARCH, __LINE__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRACE_ALLOC
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE_FREE
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|x
parameter_list|,
name|f
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE_MODAGF
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE_BUSY
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|ag
parameter_list|,
name|agb
parameter_list|,
name|l
parameter_list|,
name|sl
parameter_list|,
name|tp
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE_UNBUSY
parameter_list|(
name|fname
parameter_list|,
name|s
parameter_list|,
name|ag
parameter_list|,
name|sl
parameter_list|,
name|tp
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE_BUSYSEARCH
parameter_list|(
name|fname
parameter_list|,
name|s
parameter_list|,
name|ag
parameter_list|,
name|agb
parameter_list|,
name|l
parameter_list|,
name|sl
parameter_list|,
name|tp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_ALLOC_TRACE */
end_comment

begin_comment
comment|/*  * Prototypes for per-ag allocation routines  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_alloc_ag_vextent_exact
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_alloc_ag_vextent_near
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_alloc_ag_vextent_size
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_alloc_ag_vextent_small
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
parameter_list|,
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|xfs_agblock_t
modifier|*
parameter_list|,
name|xfs_extlen_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Internal functions.  */
end_comment

begin_comment
comment|/*  * Compute aligned version of the found extent.  * Takes alignment and min length into account.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* success (>= minlen) */
name|xfs_alloc_compute_aligned
parameter_list|(
name|xfs_agblock_t
name|foundbno
parameter_list|,
comment|/* starting block in found extent */
name|xfs_extlen_t
name|foundlen
parameter_list|,
comment|/* length in found extent */
name|xfs_extlen_t
name|alignment
parameter_list|,
comment|/* alignment for allocation */
name|xfs_extlen_t
name|minlen
parameter_list|,
comment|/* minimum length for allocation */
name|xfs_agblock_t
modifier|*
name|resbno
parameter_list|,
comment|/* result block number */
name|xfs_extlen_t
modifier|*
name|reslen
parameter_list|)
comment|/* result length */
block|{
name|xfs_agblock_t
name|bno
decl_stmt|;
name|xfs_extlen_t
name|diff
decl_stmt|;
name|xfs_extlen_t
name|len
decl_stmt|;
if|if
condition|(
name|alignment
operator|>
literal|1
operator|&&
name|foundlen
operator|>=
name|minlen
condition|)
block|{
name|bno
operator|=
name|roundup
argument_list|(
name|foundbno
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|diff
operator|=
name|bno
operator|-
name|foundbno
expr_stmt|;
name|len
operator|=
name|diff
operator|>=
name|foundlen
condition|?
literal|0
else|:
name|foundlen
operator|-
name|diff
expr_stmt|;
block|}
else|else
block|{
name|bno
operator|=
name|foundbno
expr_stmt|;
name|len
operator|=
name|foundlen
expr_stmt|;
block|}
operator|*
name|resbno
operator|=
name|bno
expr_stmt|;
operator|*
name|reslen
operator|=
name|len
expr_stmt|;
return|return
name|len
operator|>=
name|minlen
return|;
block|}
end_function

begin_comment
comment|/*  * Compute best start block and diff for "near" allocations.  * freelen>= wantlen already checked by caller.  */
end_comment

begin_function
name|STATIC
name|xfs_extlen_t
comment|/* difference value (absolute) */
name|xfs_alloc_compute_diff
parameter_list|(
name|xfs_agblock_t
name|wantbno
parameter_list|,
comment|/* target starting block */
name|xfs_extlen_t
name|wantlen
parameter_list|,
comment|/* target length */
name|xfs_extlen_t
name|alignment
parameter_list|,
comment|/* target alignment */
name|xfs_agblock_t
name|freebno
parameter_list|,
comment|/* freespace's starting block */
name|xfs_extlen_t
name|freelen
parameter_list|,
comment|/* freespace's length */
name|xfs_agblock_t
modifier|*
name|newbnop
parameter_list|)
comment|/* result: best start block from free */
block|{
name|xfs_agblock_t
name|freeend
decl_stmt|;
comment|/* end of freespace extent */
name|xfs_agblock_t
name|newbno1
decl_stmt|;
comment|/* return block number */
name|xfs_agblock_t
name|newbno2
decl_stmt|;
comment|/* other new block number */
name|xfs_extlen_t
name|newlen1
init|=
literal|0
decl_stmt|;
comment|/* length with newbno1 */
name|xfs_extlen_t
name|newlen2
init|=
literal|0
decl_stmt|;
comment|/* length with newbno2 */
name|xfs_agblock_t
name|wantend
decl_stmt|;
comment|/* end of target extent */
name|ASSERT
argument_list|(
name|freelen
operator|>=
name|wantlen
argument_list|)
expr_stmt|;
name|freeend
operator|=
name|freebno
operator|+
name|freelen
expr_stmt|;
name|wantend
operator|=
name|wantbno
operator|+
name|wantlen
expr_stmt|;
if|if
condition|(
name|freebno
operator|>=
name|wantbno
condition|)
block|{
if|if
condition|(
operator|(
name|newbno1
operator|=
name|roundup
argument_list|(
name|freebno
argument_list|,
name|alignment
argument_list|)
operator|)
operator|>=
name|freeend
condition|)
name|newbno1
operator|=
name|NULLAGBLOCK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freeend
operator|>=
name|wantend
operator|&&
name|alignment
operator|>
literal|1
condition|)
block|{
name|newbno1
operator|=
name|roundup
argument_list|(
name|wantbno
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|newbno2
operator|=
name|newbno1
operator|-
name|alignment
expr_stmt|;
if|if
condition|(
name|newbno1
operator|>=
name|freeend
condition|)
name|newbno1
operator|=
name|NULLAGBLOCK
expr_stmt|;
else|else
name|newlen1
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|wantlen
argument_list|,
name|freeend
operator|-
name|newbno1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbno2
operator|<
name|freebno
condition|)
name|newbno2
operator|=
name|NULLAGBLOCK
expr_stmt|;
else|else
name|newlen2
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|wantlen
argument_list|,
name|freeend
operator|-
name|newbno2
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbno1
operator|!=
name|NULLAGBLOCK
operator|&&
name|newbno2
operator|!=
name|NULLAGBLOCK
condition|)
block|{
if|if
condition|(
name|newlen1
operator|<
name|newlen2
operator|||
operator|(
name|newlen1
operator|==
name|newlen2
operator|&&
name|XFS_ABSDIFF
argument_list|(
name|newbno1
argument_list|,
name|wantbno
argument_list|)
operator|>
name|XFS_ABSDIFF
argument_list|(
name|newbno2
argument_list|,
name|wantbno
argument_list|)
operator|)
condition|)
name|newbno1
operator|=
name|newbno2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newbno2
operator|!=
name|NULLAGBLOCK
condition|)
name|newbno1
operator|=
name|newbno2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freeend
operator|>=
name|wantend
condition|)
block|{
name|newbno1
operator|=
name|wantbno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alignment
operator|>
literal|1
condition|)
block|{
name|newbno1
operator|=
name|roundup
argument_list|(
name|freeend
operator|-
name|wantlen
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbno1
operator|>
name|freeend
operator|-
name|wantlen
operator|&&
name|newbno1
operator|-
name|alignment
operator|>=
name|freebno
condition|)
name|newbno1
operator|-=
name|alignment
expr_stmt|;
elseif|else
if|if
condition|(
name|newbno1
operator|>=
name|freeend
condition|)
name|newbno1
operator|=
name|NULLAGBLOCK
expr_stmt|;
block|}
else|else
name|newbno1
operator|=
name|freeend
operator|-
name|wantlen
expr_stmt|;
operator|*
name|newbnop
operator|=
name|newbno1
expr_stmt|;
return|return
name|newbno1
operator|==
name|NULLAGBLOCK
condition|?
literal|0
else|:
name|XFS_ABSDIFF
argument_list|(
name|newbno1
argument_list|,
name|wantbno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fix up the length, based on mod and prod.  * len should be k * prod + mod for some k.  * If len is too small it is returned unchanged.  * If len hits maxlen it is left alone.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_alloc_fix_len
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|)
comment|/* allocation argument structure */
block|{
name|xfs_extlen_t
name|k
decl_stmt|;
name|xfs_extlen_t
name|rlen
decl_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|mod
operator|<
name|args
operator|->
name|prod
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|ASSERT
argument_list|(
name|rlen
operator|>=
name|args
operator|->
name|minlen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rlen
operator|<=
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|prod
operator|<=
literal|1
operator|||
name|rlen
operator|<
name|args
operator|->
name|mod
operator|||
name|rlen
operator|==
name|args
operator|->
name|maxlen
operator|||
operator|(
name|args
operator|->
name|mod
operator|==
literal|0
operator|&&
name|rlen
operator|<
name|args
operator|->
name|prod
operator|)
condition|)
return|return;
name|k
operator|=
name|rlen
operator|%
name|args
operator|->
name|prod
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|args
operator|->
name|mod
condition|)
return|return;
if|if
condition|(
name|k
operator|>
name|args
operator|->
name|mod
condition|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|rlen
operator|=
name|rlen
operator|-
name|k
operator|-
name|args
operator|->
name|mod
argument_list|)
operator|<
operator|(
name|int
operator|)
name|args
operator|->
name|minlen
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|rlen
operator|=
name|rlen
operator|-
name|args
operator|->
name|prod
operator|-
operator|(
name|args
operator|->
name|mod
operator|-
name|k
operator|)
argument_list|)
operator|<
operator|(
name|int
operator|)
name|args
operator|->
name|minlen
condition|)
return|return;
block|}
name|ASSERT
argument_list|(
name|rlen
operator|>=
name|args
operator|->
name|minlen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rlen
operator|<=
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|rlen
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fix up length if there is too little space left in the a.g.  * Return 1 if ok, 0 if too little, should give up.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_alloc_fix_minleft
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|)
comment|/* allocation argument structure */
block|{
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* a.g. freelist header */
name|int
name|diff
decl_stmt|;
comment|/* free space difference */
if|if
condition|(
name|args
operator|->
name|minleft
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
expr_stmt|;
name|diff
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
operator|+
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|-
name|args
operator|->
name|len
operator|-
name|args
operator|->
name|minleft
expr_stmt|;
if|if
condition|(
name|diff
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
name|args
operator|->
name|len
operator|+=
name|diff
expr_stmt|;
comment|/* shrink the allocated space */
if|if
condition|(
name|args
operator|->
name|len
operator|>=
name|args
operator|->
name|minlen
condition|)
return|return
literal|1
return|;
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Update the two btrees, logically removing from freespace the extent  * starting at rbno, rlen blocks.  The extent is contained within the  * actual (current) free extent fbno for flen blocks.  * Flags are passed in indicating whether the cursors are set to the  * relevant records.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error code */
name|xfs_alloc_fixup_trees
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cnt_cur
parameter_list|,
comment|/* cursor for by-size btree */
name|xfs_btree_cur_t
modifier|*
name|bno_cur
parameter_list|,
comment|/* cursor for by-block btree */
name|xfs_agblock_t
name|fbno
parameter_list|,
comment|/* starting block of free extent */
name|xfs_extlen_t
name|flen
parameter_list|,
comment|/* length of free extent */
name|xfs_agblock_t
name|rbno
parameter_list|,
comment|/* starting block of returned extent */
name|xfs_extlen_t
name|rlen
parameter_list|,
comment|/* length of returned extent */
name|int
name|flags
parameter_list|)
comment|/* flags, XFSA_FIXUP_... */
block|{
name|int
name|error
decl_stmt|;
comment|/* error code */
name|int
name|i
decl_stmt|;
comment|/* operation results */
name|xfs_agblock_t
name|nfbno1
decl_stmt|;
comment|/* first new free startblock */
name|xfs_agblock_t
name|nfbno2
decl_stmt|;
comment|/* second new free startblock */
name|xfs_extlen_t
name|nflen1
init|=
literal|0
decl_stmt|;
comment|/* first new free length */
name|xfs_extlen_t
name|nflen2
init|=
literal|0
decl_stmt|;
comment|/* second new free length */
comment|/* 	 * Look up the record in the by-size tree if necessary. 	 */
if|if
condition|(
name|flags
operator|&
name|XFSA_FIXUP_CNT_OK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|nfbno1
argument_list|,
operator|&
name|nflen1
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
operator|&&
name|nfbno1
operator|==
name|fbno
operator|&&
name|nflen1
operator|==
name|flen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|fbno
argument_list|,
name|flen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look up the record in the by-block tree if necessary. 	 */
if|if
condition|(
name|flags
operator|&
name|XFSA_FIXUP_BNO_OK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|nfbno1
argument_list|,
operator|&
name|nflen1
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
operator|&&
name|nfbno1
operator|==
name|fbno
operator|&&
name|nflen1
operator|==
name|flen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|bno_cur
argument_list|,
name|fbno
argument_list|,
name|flen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|xfs_alloc_block_t
modifier|*
name|bnoblock
decl_stmt|;
name|xfs_alloc_block_t
modifier|*
name|cntblock
decl_stmt|;
if|if
condition|(
name|bno_cur
operator|->
name|bc_nlevels
operator|==
literal|1
operator|&&
name|cnt_cur
operator|->
name|bc_nlevels
operator|==
literal|1
condition|)
block|{
name|bnoblock
operator|=
name|XFS_BUF_TO_ALLOC_BLOCK
argument_list|(
name|bno_cur
operator|->
name|bc_bufs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cntblock
operator|=
name|XFS_BUF_TO_ALLOC_BLOCK
argument_list|(
name|cnt_cur
operator|->
name|bc_bufs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|be16_to_cpu
argument_list|(
name|bnoblock
operator|->
name|bb_numrecs
argument_list|)
operator|==
name|be16_to_cpu
argument_list|(
name|cntblock
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Deal with all four cases: the allocated record is contained 	 * within the freespace record, so we can have new freespace 	 * at either (or both) end, or no freespace remaining. 	 */
if|if
condition|(
name|rbno
operator|==
name|fbno
operator|&&
name|rlen
operator|==
name|flen
condition|)
name|nfbno1
operator|=
name|nfbno2
operator|=
name|NULLAGBLOCK
expr_stmt|;
elseif|else
if|if
condition|(
name|rbno
operator|==
name|fbno
condition|)
block|{
name|nfbno1
operator|=
name|rbno
operator|+
name|rlen
expr_stmt|;
name|nflen1
operator|=
name|flen
operator|-
name|rlen
expr_stmt|;
name|nfbno2
operator|=
name|NULLAGBLOCK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbno
operator|+
name|rlen
operator|==
name|fbno
operator|+
name|flen
condition|)
block|{
name|nfbno1
operator|=
name|fbno
expr_stmt|;
name|nflen1
operator|=
name|flen
operator|-
name|rlen
expr_stmt|;
name|nfbno2
operator|=
name|NULLAGBLOCK
expr_stmt|;
block|}
else|else
block|{
name|nfbno1
operator|=
name|fbno
expr_stmt|;
name|nflen1
operator|=
name|rbno
operator|-
name|fbno
expr_stmt|;
name|nfbno2
operator|=
name|rbno
operator|+
name|rlen
expr_stmt|;
name|nflen2
operator|=
operator|(
name|fbno
operator|+
name|flen
operator|)
operator|-
name|nfbno2
expr_stmt|;
block|}
comment|/* 	 * Delete the entry from the by-size btree. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_delete
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Add new by-size btree entry(s). 	 */
if|if
condition|(
name|nfbno1
operator|!=
name|NULLAGBLOCK
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|nfbno1
argument_list|,
name|nflen1
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_insert
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfbno2
operator|!=
name|NULLAGBLOCK
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|nfbno2
argument_list|,
name|nflen2
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_insert
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fix up the by-block btree entry(s). 	 */
if|if
condition|(
name|nfbno1
operator|==
name|NULLAGBLOCK
condition|)
block|{
comment|/* 		 * No remaining freespace, just delete the by-block tree entry. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_delete
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Update the by-block entry to start later|be shorter. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_update
argument_list|(
name|bno_cur
argument_list|,
name|nfbno1
argument_list|,
name|nflen1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|nfbno2
operator|!=
name|NULLAGBLOCK
condition|)
block|{
comment|/* 		 * 2 resulting free entries, need to add one. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|bno_cur
argument_list|,
name|nfbno2
argument_list|,
name|nflen2
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_insert
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read in the allocation group free block array.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_alloc_read_agfl
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
comment|/* buffer for the ag free block array */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* return value */
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|agno
operator|!=
name|NULLAGNUMBER
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGFL_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_VTYPE_REF
argument_list|(
name|bp
argument_list|,
name|B_FS_AGFL
argument_list|,
name|XFS_AGFL_REF
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_ALLOC_TRACE
argument_list|)
end_if

begin_comment
comment|/*  * Add an allocation trace entry for an alloc call.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_alloc_trace_alloc
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* function tag string */
name|char
modifier|*
name|str
parameter_list|,
comment|/* additional string */
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|,
comment|/* allocation argument structure */
name|int
name|line
parameter_list|)
comment|/* source line number */
block|{
name|ktrace_enter
argument_list|(
name|xfs_alloc_trace_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|XFS_ALLOC_KTRACE_ALLOC
operator||
operator|(
name|line
operator|<<
literal|16
operator|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|mp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|agno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|agbno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|minlen
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|maxlen
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|mod
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|prod
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|minleft
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|total
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|alignment
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|args
operator|->
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
operator|(
name|__psint_t
operator|)
name|args
operator|->
name|type
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|__psint_t
operator|)
name|args
operator|->
name|otype
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
operator|(
name|args
operator|->
name|wasdel
operator|<<
literal|3
operator|)
operator||
operator|(
name|args
operator|->
name|wasfromfl
operator|<<
literal|2
operator|)
operator||
operator|(
name|args
operator|->
name|isfl
operator|<<
literal|1
operator|)
operator||
operator|(
name|args
operator|->
name|userdata
operator|<<
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an allocation trace entry for a free call.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_alloc_trace_free
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* function tag string */
name|char
modifier|*
name|str
parameter_list|,
comment|/* additional string */
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|xfs_agblock_t
name|agbno
parameter_list|,
comment|/* a.g. relative block number */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length of extent */
name|int
name|isfl
parameter_list|,
comment|/* set if is freelist allocation/free */
name|int
name|line
parameter_list|)
comment|/* source line number */
block|{
name|ktrace_enter
argument_list|(
name|xfs_alloc_trace_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|XFS_ALLOC_KTRACE_FREE
operator||
operator|(
name|line
operator|<<
literal|16
operator|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|agno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|agbno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|isfl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an allocation trace entry for modifying an agf.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_alloc_trace_modagf
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* function tag string */
name|char
modifier|*
name|str
parameter_list|,
comment|/* additional string */
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_agf_t
modifier|*
name|agf
parameter_list|,
comment|/* new agf value */
name|int
name|flags
parameter_list|,
comment|/* logging flags for agf */
name|int
name|line
parameter_list|)
comment|/* source line number */
block|{
name|ktrace_enter
argument_list|(
name|xfs_alloc_trace_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|XFS_ALLOC_KTRACE_MODAGF
operator||
operator|(
name|line
operator|<<
literal|16
operator|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|flags
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_seqno
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_length
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_roots
index|[
name|XFS_BTNUM_BNO
index|]
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_roots
index|[
name|XFS_BTNUM_CNT
index|]
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_levels
index|[
name|XFS_BTNUM_BNO
index|]
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_levels
index|[
name|XFS_BTNUM_CNT
index|]
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flfirst
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_fllast
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_longest
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xfs_alloc_trace_busy
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* function tag string */
name|char
modifier|*
name|str
parameter_list|,
comment|/* additional string */
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|xfs_agblock_t
name|agbno
parameter_list|,
comment|/* a.g. relative block number */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length of extent */
name|int
name|slot
parameter_list|,
comment|/* perag Busy slot */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|int
name|trtype
parameter_list|,
comment|/* type: add, delete, search */
name|int
name|line
parameter_list|)
comment|/* source line number */
block|{
name|ktrace_enter
argument_list|(
name|xfs_alloc_trace_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|trtype
operator||
operator|(
name|line
operator|<<
literal|16
operator|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|agno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|agbno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|slot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_ALLOC_TRACE */
end_comment

begin_comment
comment|/*  * Allocation group level functions.  */
end_comment

begin_comment
comment|/*  * Allocate a variable extent in the allocation group agno.  * Type and bno are used to determine where in the allocation group the  * extent will start.  * Extent's length (returned in *len) will be between minlen and maxlen,  * and of the form k * prod + mod unless there's nothing that large.  * Return the starting a.g. block, or NULLAGBLOCK if we can't do it.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_alloc_ag_vextent
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|)
comment|/* argument structure for allocation */
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_ag_vextent"
decl_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|args
operator|->
name|minlen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|maxlen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|minlen
operator|<=
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|mod
operator|<
name|args
operator|->
name|prod
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|alignment
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Branch to correct routine based on the type. 	 */
name|args
operator|->
name|wasfromfl
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|type
condition|)
block|{
case|case
name|XFS_ALLOCTYPE_THIS_AG
case|:
name|error
operator|=
name|xfs_alloc_ag_vextent_size
argument_list|(
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ALLOCTYPE_NEAR_BNO
case|:
name|error
operator|=
name|xfs_alloc_ag_vextent_near
argument_list|(
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ALLOCTYPE_THIS_BNO
case|:
name|error
operator|=
name|xfs_alloc_ag_vextent_exact
argument_list|(
name|args
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * If the allocation worked, need to change the agf structure 	 * (and log it), and the superblock. 	 */
if|if
condition|(
name|args
operator|->
name|agbno
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* allocation group freelist header */
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
name|xfs_mount_t
modifier|*
name|mp
init|=
name|args
operator|->
name|mp
decl_stmt|;
endif|#
directive|endif
name|long
name|slen
init|=
operator|(
name|long
operator|)
name|args
operator|->
name|len
decl_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|len
operator|>=
name|args
operator|->
name|minlen
operator|&&
name|args
operator|->
name|len
operator|<=
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|args
operator|->
name|wasfromfl
operator|)
operator|||
operator|!
name|args
operator|->
name|isfl
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|agbno
operator|%
name|args
operator|->
name|alignment
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|args
operator|->
name|wasfromfl
operator|)
condition|)
block|{
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agf
operator|->
name|agf_freeblks
argument_list|,
operator|-
operator|(
name|args
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
name|xfs_trans_agblocks_delta
argument_list|(
name|args
operator|->
name|tp
argument_list|,
operator|-
operator|(
call|(
name|long
call|)
argument_list|(
name|args
operator|->
name|len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|pag
operator|->
name|pagf_freeblks
operator|-=
name|args
operator|->
name|len
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
operator|<=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_length
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_MODAGF
argument_list|(
name|NULL
argument_list|,
name|agf
argument_list|,
name|XFS_AGF_FREEBLKS
argument_list|)
expr_stmt|;
name|xfs_alloc_log_agf
argument_list|(
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|XFS_AGF_FREEBLKS
argument_list|)
expr_stmt|;
comment|/* search the busylist for these blocks */
name|xfs_alloc_search_busy
argument_list|(
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|args
operator|->
name|agbno
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|args
operator|->
name|isfl
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|wasdel
condition|?
name|XFS_TRANS_SB_RES_FDBLOCKS
else|:
name|XFS_TRANS_SB_FDBLOCKS
argument_list|,
operator|-
name|slen
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_allocx
argument_list|)
expr_stmt|;
name|XFS_STATS_ADD
argument_list|(
name|xs_allocb
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a variable extent at exactly agno/bno.  * Extent's length (returned in *len) will be between minlen and maxlen,  * and of the form k * prod + mod unless there's nothing that large.  * Return the starting a.g. block (bno), or NULLAGBLOCK if we can't do it.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_alloc_ag_vextent_exact
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|)
comment|/* allocation argument structure */
block|{
name|xfs_btree_cur_t
modifier|*
name|bno_cur
decl_stmt|;
comment|/* by block-number btree cursor */
name|xfs_btree_cur_t
modifier|*
name|cnt_cur
decl_stmt|;
comment|/* by count btree cursor */
name|xfs_agblock_t
name|end
decl_stmt|;
comment|/* end of allocated extent */
name|int
name|error
decl_stmt|;
name|xfs_agblock_t
name|fbno
decl_stmt|;
comment|/* start block of found extent */
name|xfs_agblock_t
name|fend
decl_stmt|;
comment|/* end block of found extent */
name|xfs_extlen_t
name|flen
decl_stmt|;
comment|/* length of found extent */
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_ag_vextent_exact"
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
comment|/* success/failure of operation */
name|xfs_agblock_t
name|maxend
decl_stmt|;
comment|/* end of maximal extent */
name|xfs_agblock_t
name|minend
decl_stmt|;
comment|/* end of minimal extent */
name|xfs_extlen_t
name|rlen
decl_stmt|;
comment|/* length of returned extent */
name|ASSERT
argument_list|(
name|args
operator|->
name|alignment
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate/initialize a cursor for the by-number freespace btree. 	 */
name|bno_cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|XFS_BTNUM_BNO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup bno and minlen in the btree (minlen is irrelevant, really). 	 * Look for the closest free block<= bno, it must contain bno 	 * if any free block does. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_le
argument_list|(
name|bno_cur
argument_list|,
name|args
operator|->
name|agbno
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* 		 * Didn't find it, return null. 		 */
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Grab the freespace record. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|fbno
argument_list|,
operator|&
name|flen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fbno
operator|<=
name|args
operator|->
name|agbno
argument_list|)
expr_stmt|;
name|minend
operator|=
name|args
operator|->
name|agbno
operator|+
name|args
operator|->
name|minlen
expr_stmt|;
name|maxend
operator|=
name|args
operator|->
name|agbno
operator|+
name|args
operator|->
name|maxlen
expr_stmt|;
name|fend
operator|=
name|fbno
operator|+
name|flen
expr_stmt|;
comment|/* 	 * Give up if the freespace isn't long enough for the minimum request. 	 */
if|if
condition|(
name|fend
operator|<
name|minend
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * End of extent will be smaller of the freespace end and the 	 * maximal requested end. 	 */
name|end
operator|=
name|XFS_AGBLOCK_MIN
argument_list|(
name|fend
argument_list|,
name|maxend
argument_list|)
expr_stmt|;
comment|/* 	 * Fix the length according to mod and prod if given. 	 */
name|args
operator|->
name|len
operator|=
name|end
operator|-
name|args
operator|->
name|agbno
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xfs_alloc_fix_minleft
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|agbno
operator|+
name|rlen
operator|<=
name|fend
argument_list|)
expr_stmt|;
name|end
operator|=
name|args
operator|->
name|agbno
operator|+
name|rlen
expr_stmt|;
comment|/* 	 * We are allocating agbno for rlen [agbno .. end] 	 * Allocate/initialize a cursor for the by-size btree. 	 */
name|cnt_cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|XFS_BTNUM_CNT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|agbno
operator|+
name|args
operator|->
name|len
operator|<=
name|be32_to_cpu
argument_list|(
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
operator|->
name|agf_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_fixup_trees
argument_list|(
name|cnt_cur
argument_list|,
name|bno_cur
argument_list|,
name|fbno
argument_list|,
name|flen
argument_list|,
name|args
operator|->
name|agbno
argument_list|,
name|args
operator|->
name|len
argument_list|,
name|XFSA_FIXUP_BNO_OK
argument_list|)
operator|)
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"normal"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|->
name|wasfromfl
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"error"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a variable extent near bno in the allocation group agno.  * Extent's length (returned in len) will be between minlen and maxlen,  * and of the form k * prod + mod unless there's nothing that large.  * Return the starting a.g. block, or NULLAGBLOCK if we can't do it.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_alloc_ag_vextent_near
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|)
comment|/* allocation argument structure */
block|{
name|xfs_btree_cur_t
modifier|*
name|bno_cur_gt
decl_stmt|;
comment|/* cursor for bno btree, right side */
name|xfs_btree_cur_t
modifier|*
name|bno_cur_lt
decl_stmt|;
comment|/* cursor for bno btree, left side */
name|xfs_btree_cur_t
modifier|*
name|cnt_cur
decl_stmt|;
comment|/* cursor for count btree */
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_ag_vextent_near"
decl_stmt|;
endif|#
directive|endif
name|xfs_agblock_t
name|gtbno
decl_stmt|;
comment|/* start bno of right side entry */
name|xfs_agblock_t
name|gtbnoa
decl_stmt|;
comment|/* aligned ... */
name|xfs_extlen_t
name|gtdiff
decl_stmt|;
comment|/* difference to right side entry */
name|xfs_extlen_t
name|gtlen
decl_stmt|;
comment|/* length of right side entry */
name|xfs_extlen_t
name|gtlena
decl_stmt|;
comment|/* aligned ... */
name|xfs_agblock_t
name|gtnew
decl_stmt|;
comment|/* useful start bno of right side */
name|int
name|error
decl_stmt|;
comment|/* error code */
name|int
name|i
decl_stmt|;
comment|/* result code, temporary */
name|int
name|j
decl_stmt|;
comment|/* result code, temporary */
name|xfs_agblock_t
name|ltbno
decl_stmt|;
comment|/* start bno of left side entry */
name|xfs_agblock_t
name|ltbnoa
decl_stmt|;
comment|/* aligned ... */
name|xfs_extlen_t
name|ltdiff
decl_stmt|;
comment|/* difference to left side entry */
comment|/*REFERENCED*/
name|xfs_agblock_t
name|ltend
decl_stmt|;
comment|/* end bno of left side entry */
name|xfs_extlen_t
name|ltlen
decl_stmt|;
comment|/* length of left side entry */
name|xfs_extlen_t
name|ltlena
decl_stmt|;
comment|/* aligned ... */
name|xfs_agblock_t
name|ltnew
decl_stmt|;
comment|/* useful start bno of left side */
name|xfs_extlen_t
name|rlen
decl_stmt|;
comment|/* length of returned extent */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
comment|/* 	 * Randomly don't execute the first algorithm. 	 */
name|int
name|dofirst
decl_stmt|;
comment|/* set to do first algorithm */
name|dofirst
operator|=
name|random
argument_list|()
operator|&
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Get a cursor for the by-size btree. 	 */
name|cnt_cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|XFS_BTNUM_CNT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ltlen
operator|=
literal|0
expr_stmt|;
name|bno_cur_lt
operator|=
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * See if there are any free extents as big as maxlen. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_ge
argument_list|(
name|cnt_cur
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|maxlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
comment|/* 	 * If none, then pick up the last entry in the tree unless the 	 * tree is empty. 	 */
if|if
condition|(
operator|!
name|i
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_ag_vextent_small
argument_list|(
name|args
argument_list|,
name|cnt_cur
argument_list|,
operator|&
name|ltbno
argument_list|,
operator|&
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|ltlen
operator|==
literal|0
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|args
operator|->
name|wasfromfl
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First algorithm. 	 * If the requested extent is large wrt the freespaces available 	 * in this a.g., then the cursor will be pointing to a btree entry 	 * near the right edge of the tree.  If it's in the last btree leaf 	 * block, then we just examine all the entries in that block 	 * that are big enough, and pick the best one. 	 * This is written as a while loop so we can break out of it, 	 * but we never loop back to the top. 	 */
while|while
condition|(
name|xfs_btree_islastblock
argument_list|(
name|cnt_cur
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|xfs_extlen_t
name|bdiff
decl_stmt|;
name|int
name|besti
init|=
literal|0
decl_stmt|;
name|xfs_extlen_t
name|blen
init|=
literal|0
decl_stmt|;
name|xfs_agblock_t
name|bnew
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
if|if
condition|(
operator|!
name|dofirst
condition|)
break|break;
endif|#
directive|endif
comment|/* 		 * Start from the entry that lookup found, sequence through 		 * all larger free blocks.  If we're actually pointing at a 		 * record smaller than maxlen, go to the start of this block, 		 * and skip all those smaller than minlen. 		 */
if|if
condition|(
name|ltlen
operator|||
name|args
operator|->
name|alignment
operator|>
literal|1
condition|)
block|{
name|cnt_cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|ltbno
argument_list|,
operator|&
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltlen
operator|>=
name|args
operator|->
name|minlen
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_increment
argument_list|(
name|cnt_cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
block|}
do|while
condition|(
name|i
condition|)
do|;
name|ASSERT
argument_list|(
name|ltlen
operator|>=
name|args
operator|->
name|minlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
break|break;
block|}
name|i
operator|=
name|cnt_cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|blen
operator|=
literal|0
operator|,
name|bdiff
operator|=
literal|0
init|;
operator|!
name|error
operator|&&
name|j
operator|&&
operator|(
name|blen
operator|<
name|args
operator|->
name|maxlen
operator|||
name|bdiff
operator|>
literal|0
operator|)
condition|;
name|error
operator|=
name|xfs_alloc_increment
argument_list|(
name|cnt_cur
argument_list|,
literal|0
argument_list|,
operator|&
name|j
argument_list|)
control|)
block|{
comment|/* 			 * For each entry, decide if it's better than 			 * the previous best entry. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|ltbno
argument_list|,
operator|&
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xfs_alloc_compute_aligned
argument_list|(
name|ltbno
argument_list|,
name|ltlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|ltbnoa
argument_list|,
operator|&
name|ltlena
argument_list|)
condition|)
continue|continue;
name|args
operator|->
name|len
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|ltlena
argument_list|,
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|len
operator|>=
name|args
operator|->
name|minlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|len
operator|<
name|blen
condition|)
continue|continue;
name|ltdiff
operator|=
name|xfs_alloc_compute_diff
argument_list|(
name|args
operator|->
name|agbno
argument_list|,
name|args
operator|->
name|len
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
operator|&
name|ltnew
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltnew
operator|!=
name|NULLAGBLOCK
operator|&&
operator|(
name|args
operator|->
name|len
operator|>
name|blen
operator|||
name|ltdiff
operator|<
name|bdiff
operator|)
condition|)
block|{
name|bdiff
operator|=
name|ltdiff
expr_stmt|;
name|bnew
operator|=
name|ltnew
expr_stmt|;
name|blen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|besti
operator|=
name|cnt_cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|/* 		 * It didn't work.  We COULD be in a case where 		 * there's a good record somewhere, so try again. 		 */
if|if
condition|(
name|blen
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Point at the best entry, and retrieve it again. 		 */
name|cnt_cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
operator|=
name|besti
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|ltbno
argument_list|,
operator|&
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|ltend
operator|=
name|ltbno
operator|+
name|ltlen
expr_stmt|;
name|ASSERT
argument_list|(
name|ltend
operator|<=
name|be32_to_cpu
argument_list|(
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
operator|->
name|agf_length
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|blen
expr_stmt|;
if|if
condition|(
operator|!
name|xfs_alloc_fix_minleft
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"nominleft"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|blen
operator|=
name|args
operator|->
name|len
expr_stmt|;
comment|/* 		 * We are allocating starting at bnew for blen blocks. 		 */
name|args
operator|->
name|agbno
operator|=
name|bnew
expr_stmt|;
name|ASSERT
argument_list|(
name|bnew
operator|>=
name|ltbno
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bnew
operator|+
name|blen
operator|<=
name|ltend
argument_list|)
expr_stmt|;
comment|/* 		 * Set up a cursor for the by-bno tree. 		 */
name|bno_cur_lt
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|XFS_BTNUM_BNO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Fix up the btree entries. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_fixup_trees
argument_list|(
name|cnt_cur
argument_list|,
name|bno_cur_lt
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
name|bnew
argument_list|,
name|blen
argument_list|,
name|XFSA_FIXUP_CNT_OK
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"first"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Second algorithm. 	 * Search in the by-bno tree to the left and to the right 	 * simultaneously, until in each case we find a space big enough, 	 * or run into the edge of the tree.  When we run into the edge, 	 * we deallocate that cursor. 	 * If both searches succeed, we compare the two spaces and pick 	 * the better one. 	 * With alignment, it's possible for both to fail; the upper 	 * level algorithm that picks allocation groups for allocations 	 * is not supposed to do this. 	 */
comment|/* 	 * Allocate and initialize the cursor for the leftward search. 	 */
name|bno_cur_lt
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|XFS_BTNUM_BNO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup<= bno to find the leftward search's starting point. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_le
argument_list|(
name|bno_cur_lt
argument_list|,
name|args
operator|->
name|agbno
argument_list|,
name|args
operator|->
name|maxlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* 		 * Didn't find anything; use this cursor for the rightward 		 * search. 		 */
name|bno_cur_gt
operator|=
name|bno_cur_lt
expr_stmt|;
name|bno_cur_lt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Found something.  Duplicate the cursor for the rightward search. 	 */
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_dup_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
operator|&
name|bno_cur_gt
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
comment|/* 	 * Increment the cursor, so we will point at the entry just right 	 * of the leftward entry if any, or to the leftmost entry. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_increment
argument_list|(
name|bno_cur_gt
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* 		 * It failed, there are no rightward entries. 		 */
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Loop going left with the leftward cursor, right with the 	 * rightward cursor, until either both directions give up or 	 * we find an entry at least as big as minlen. 	 */
do|do
block|{
if|if
condition|(
name|bno_cur_lt
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur_lt
argument_list|,
operator|&
name|ltbno
argument_list|,
operator|&
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_alloc_compute_aligned
argument_list|(
name|ltbno
argument_list|,
name|ltlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|ltbnoa
argument_list|,
operator|&
name|ltlena
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_decrement
argument_list|(
name|bno_cur_lt
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_lt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bno_cur_gt
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur_gt
argument_list|,
operator|&
name|gtbno
argument_list|,
operator|&
name|gtlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_alloc_compute_aligned
argument_list|(
name|gtbno
argument_list|,
name|gtlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|gtbnoa
argument_list|,
operator|&
name|gtlena
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_increment
argument_list|(
name|bno_cur_gt
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|bno_cur_lt
operator|||
name|bno_cur_gt
condition|)
do|;
comment|/* 	 * Got both cursors still active, need to find better entry. 	 */
if|if
condition|(
name|bno_cur_lt
operator|&&
name|bno_cur_gt
condition|)
block|{
comment|/* 		 * Left side is long enough, look for a right side entry. 		 */
if|if
condition|(
name|ltlena
operator|>=
name|args
operator|->
name|minlen
condition|)
block|{
comment|/* 			 * Fix up the length. 			 */
name|args
operator|->
name|len
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|ltlena
argument_list|,
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|ltdiff
operator|=
name|xfs_alloc_compute_diff
argument_list|(
name|args
operator|->
name|agbno
argument_list|,
name|rlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
operator|&
name|ltnew
argument_list|)
expr_stmt|;
comment|/* 			 * Not perfect. 			 */
if|if
condition|(
name|ltdiff
condition|)
block|{
comment|/* 				 * Look until we find a better one, run out of 				 * space, or run off the end. 				 */
while|while
condition|(
name|bno_cur_lt
operator|&&
name|bno_cur_gt
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur_gt
argument_list|,
operator|&
name|gtbno
argument_list|,
operator|&
name|gtlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|xfs_alloc_compute_aligned
argument_list|(
name|gtbno
argument_list|,
name|gtlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|gtbnoa
argument_list|,
operator|&
name|gtlena
argument_list|)
expr_stmt|;
comment|/* 					 * The left one is clearly better. 					 */
if|if
condition|(
name|gtbnoa
operator|>=
name|args
operator|->
name|agbno
operator|+
name|ltdiff
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 					 * If we reach a big enough entry, 					 * compare the two and pick the best. 					 */
if|if
condition|(
name|gtlena
operator|>=
name|args
operator|->
name|minlen
condition|)
block|{
name|args
operator|->
name|len
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|gtlena
argument_list|,
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|gtdiff
operator|=
name|xfs_alloc_compute_diff
argument_list|(
name|args
operator|->
name|agbno
argument_list|,
name|rlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|gtbno
argument_list|,
name|gtlen
argument_list|,
operator|&
name|gtnew
argument_list|)
expr_stmt|;
comment|/* 						 * Right side is better. 						 */
if|if
condition|(
name|gtdiff
operator|<
name|ltdiff
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_lt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 						 * Left side is better. 						 */
else|else
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
comment|/* 					 * Fell off the right end. 					 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_increment
argument_list|(
name|bno_cur_gt
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 			 * The left side is perfect, trash the right side. 			 */
else|else
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 		 * It's the right side that was found first, look left. 		 */
else|else
block|{
comment|/* 			 * Fix up the length. 			 */
name|args
operator|->
name|len
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|gtlena
argument_list|,
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|gtdiff
operator|=
name|xfs_alloc_compute_diff
argument_list|(
name|args
operator|->
name|agbno
argument_list|,
name|rlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|gtbno
argument_list|,
name|gtlen
argument_list|,
operator|&
name|gtnew
argument_list|)
expr_stmt|;
comment|/* 			 * Right side entry isn't perfect. 			 */
if|if
condition|(
name|gtdiff
condition|)
block|{
comment|/* 				 * Look until we find a better one, run out of 				 * space, or run off the end. 				 */
while|while
condition|(
name|bno_cur_lt
operator|&&
name|bno_cur_gt
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur_lt
argument_list|,
operator|&
name|ltbno
argument_list|,
operator|&
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|xfs_alloc_compute_aligned
argument_list|(
name|ltbno
argument_list|,
name|ltlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|ltbnoa
argument_list|,
operator|&
name|ltlena
argument_list|)
expr_stmt|;
comment|/* 					 * The right one is clearly better. 					 */
if|if
condition|(
name|ltbnoa
operator|<=
name|args
operator|->
name|agbno
operator|-
name|gtdiff
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_lt
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 					 * If we reach a big enough entry, 					 * compare the two and pick the best. 					 */
if|if
condition|(
name|ltlena
operator|>=
name|args
operator|->
name|minlen
condition|)
block|{
name|args
operator|->
name|len
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|ltlena
argument_list|,
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|ltdiff
operator|=
name|xfs_alloc_compute_diff
argument_list|(
name|args
operator|->
name|agbno
argument_list|,
name|rlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
operator|&
name|ltnew
argument_list|)
expr_stmt|;
comment|/* 						 * Left side is better. 						 */
if|if
condition|(
name|ltdiff
operator|<
name|gtdiff
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 						 * Right side is better. 						 */
else|else
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_lt
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
comment|/* 					 * Fell off the left end. 					 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_decrement
argument_list|(
name|bno_cur_lt
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_lt
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 			 * The right side is perfect, trash the left side. 			 */
else|else
block|{
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur_lt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we couldn't get anything, give up. 	 */
if|if
condition|(
name|bno_cur_lt
operator|==
name|NULL
operator|&&
name|bno_cur_gt
operator|==
name|NULL
condition|)
block|{
name|TRACE_ALLOC
argument_list|(
literal|"neither"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * At this point we have selected a freespace entry, either to the 	 * left or to the right.  If it's on the right, copy all the 	 * useful variables to the "left" set so we only have one 	 * copy of this code. 	 */
if|if
condition|(
name|bno_cur_gt
condition|)
block|{
name|bno_cur_lt
operator|=
name|bno_cur_gt
expr_stmt|;
name|bno_cur_gt
operator|=
name|NULL
expr_stmt|;
name|ltbno
operator|=
name|gtbno
expr_stmt|;
name|ltbnoa
operator|=
name|gtbnoa
expr_stmt|;
name|ltlen
operator|=
name|gtlen
expr_stmt|;
name|ltlena
operator|=
name|gtlena
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|j
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fix up the length and compute the useful address. 	 */
name|ltend
operator|=
name|ltbno
operator|+
name|ltlen
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|ltlena
argument_list|,
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xfs_alloc_fix_minleft
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|TRACE_ALLOC
argument_list|(
literal|"nominleft"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_alloc_compute_diff
argument_list|(
name|args
operator|->
name|agbno
argument_list|,
name|rlen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
operator|&
name|ltnew
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ltnew
operator|>=
name|ltbno
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ltnew
operator|+
name|rlen
operator|<=
name|ltend
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ltnew
operator|+
name|rlen
operator|<=
name|be32_to_cpu
argument_list|(
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
operator|->
name|agf_length
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|ltnew
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_fixup_trees
argument_list|(
name|cnt_cur
argument_list|,
name|bno_cur_lt
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
name|ltnew
argument_list|,
name|rlen
argument_list|,
name|XFSA_FIXUP_BNO_OK
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|TRACE_ALLOC
argument_list|(
name|j
condition|?
literal|"gt"
else|:
literal|"lt"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
name|TRACE_ALLOC
argument_list|(
literal|"error"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt_cur
operator|!=
name|NULL
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno_cur_lt
operator|!=
name|NULL
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_lt
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno_cur_gt
operator|!=
name|NULL
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur_gt
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a variable extent anywhere in the allocation group agno.  * Extent's length (returned in len) will be between minlen and maxlen,  * and of the form k * prod + mod unless there's nothing that large.  * Return the starting a.g. block, or NULLAGBLOCK if we can't do it.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_alloc_ag_vextent_size
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|)
comment|/* allocation argument structure */
block|{
name|xfs_btree_cur_t
modifier|*
name|bno_cur
decl_stmt|;
comment|/* cursor for bno btree */
name|xfs_btree_cur_t
modifier|*
name|cnt_cur
decl_stmt|;
comment|/* cursor for cnt btree */
name|int
name|error
decl_stmt|;
comment|/* error result */
name|xfs_agblock_t
name|fbno
decl_stmt|;
comment|/* start of found freespace */
name|xfs_extlen_t
name|flen
decl_stmt|;
comment|/* length of found freespace */
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_ag_vextent_size"
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
comment|/* temp status variable */
name|xfs_agblock_t
name|rbno
decl_stmt|;
comment|/* returned block number */
name|xfs_extlen_t
name|rlen
decl_stmt|;
comment|/* length of returned extent */
comment|/* 	 * Allocate and initialize a cursor for the by-size btree. 	 */
name|cnt_cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|XFS_BTNUM_CNT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bno_cur
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Look for an entry>= maxlen+alignment-1 blocks. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_ge
argument_list|(
name|cnt_cur
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|maxlen
operator|+
name|args
operator|->
name|alignment
operator|-
literal|1
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
comment|/* 	 * If none, then pick up the last entry in the tree unless the 	 * tree is empty. 	 */
if|if
condition|(
operator|!
name|i
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_ag_vextent_small
argument_list|(
name|args
argument_list|,
name|cnt_cur
argument_list|,
operator|&
name|fbno
argument_list|,
operator|&
name|flen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|flen
operator|==
literal|0
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"noentry"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There's a freespace as big as maxlen+alignment-1, get it. 	 */
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|fbno
argument_list|,
operator|&
name|flen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In the first case above, we got the last entry in the 	 * by-size btree.  Now we check to see if the space hits maxlen 	 * once aligned; if not, we search left for something better. 	 * This can't happen in the second case above. 	 */
name|xfs_alloc_compute_aligned
argument_list|(
name|fbno
argument_list|,
name|flen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|rbno
argument_list|,
operator|&
name|rlen
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|args
operator|->
name|maxlen
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|rlen
operator|==
literal|0
operator|||
operator|(
name|rlen
operator|<=
name|flen
operator|&&
name|rbno
operator|+
name|rlen
operator|<=
name|fbno
operator|+
name|flen
operator|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
name|args
operator|->
name|maxlen
condition|)
block|{
name|xfs_agblock_t
name|bestfbno
decl_stmt|;
name|xfs_extlen_t
name|bestflen
decl_stmt|;
name|xfs_agblock_t
name|bestrbno
decl_stmt|;
name|xfs_extlen_t
name|bestrlen
decl_stmt|;
name|bestrlen
operator|=
name|rlen
expr_stmt|;
name|bestrbno
operator|=
name|rbno
expr_stmt|;
name|bestflen
operator|=
name|flen
expr_stmt|;
name|bestfbno
operator|=
name|fbno
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_decrement
argument_list|(
name|cnt_cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|fbno
argument_list|,
operator|&
name|flen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|<
name|bestrlen
condition|)
break|break;
name|xfs_alloc_compute_aligned
argument_list|(
name|fbno
argument_list|,
name|flen
argument_list|,
name|args
operator|->
name|alignment
argument_list|,
name|args
operator|->
name|minlen
argument_list|,
operator|&
name|rbno
argument_list|,
operator|&
name|rlen
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|XFS_EXTLEN_MIN
argument_list|(
name|args
operator|->
name|maxlen
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|rlen
operator|==
literal|0
operator|||
operator|(
name|rlen
operator|<=
name|flen
operator|&&
name|rbno
operator|+
name|rlen
operator|<=
name|fbno
operator|+
name|flen
operator|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|>
name|bestrlen
condition|)
block|{
name|bestrlen
operator|=
name|rlen
expr_stmt|;
name|bestrbno
operator|=
name|rbno
expr_stmt|;
name|bestflen
operator|=
name|flen
expr_stmt|;
name|bestfbno
operator|=
name|fbno
expr_stmt|;
if|if
condition|(
name|rlen
operator|==
name|args
operator|->
name|maxlen
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|bestfbno
argument_list|,
name|bestflen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|bestrlen
expr_stmt|;
name|rbno
operator|=
name|bestrbno
expr_stmt|;
name|flen
operator|=
name|bestflen
expr_stmt|;
name|fbno
operator|=
name|bestfbno
expr_stmt|;
block|}
name|args
operator|->
name|wasfromfl
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fix up the length. 	 */
name|args
operator|->
name|len
operator|=
name|rlen
expr_stmt|;
name|xfs_alloc_fix_len
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
name|args
operator|->
name|minlen
operator|||
operator|!
name|xfs_alloc_fix_minleft
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"nominleft"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rlen
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|rlen
operator|<=
name|flen
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize a cursor for the by-block tree. 	 */
name|bno_cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|XFS_BTNUM_BNO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_fixup_trees
argument_list|(
name|cnt_cur
argument_list|,
name|bno_cur
argument_list|,
name|fbno
argument_list|,
name|flen
argument_list|,
name|rbno
argument_list|,
name|rlen
argument_list|,
name|XFSA_FIXUP_CNT_OK
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|cnt_cur
operator|=
name|bno_cur
operator|=
name|NULL
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|rlen
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|rbno
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|args
operator|->
name|agbno
operator|+
name|args
operator|->
name|len
operator|<=
name|be32_to_cpu
argument_list|(
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
operator|->
name|agf_length
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"normal"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
name|TRACE_ALLOC
argument_list|(
literal|"error"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt_cur
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno_cur
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Deal with the case where only small freespaces remain.  * Either return the contents of the last freespace record,  * or allocate space from the freelist if there is nothing in the tree.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_alloc_ag_vextent_small
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|,
comment|/* allocation argument structure */
name|xfs_btree_cur_t
modifier|*
name|ccur
parameter_list|,
comment|/* by-size cursor */
name|xfs_agblock_t
modifier|*
name|fbnop
parameter_list|,
comment|/* result block number */
name|xfs_extlen_t
modifier|*
name|flenp
parameter_list|,
comment|/* result length */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* status: 0-freelist, 1-normal/none */
block|{
name|int
name|error
decl_stmt|;
name|xfs_agblock_t
name|fbno
decl_stmt|;
name|xfs_extlen_t
name|flen
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_ag_vextent_small"
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_decrement
argument_list|(
name|ccur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|ccur
argument_list|,
operator|&
name|fbno
argument_list|,
operator|&
name|flen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Nothing in the btree, try the freelist.  Make sure 	 * to respect minleft even when pulling from the 	 * freelist. 	 */
elseif|else
if|if
condition|(
name|args
operator|->
name|minlen
operator|==
literal|1
operator|&&
name|args
operator|->
name|alignment
operator|==
literal|1
operator|&&
operator|!
name|args
operator|->
name|isfl
operator|&&
operator|(
name|be32_to_cpu
argument_list|(
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
operator|->
name|agf_flcount
argument_list|)
operator|>
name|args
operator|->
name|minleft
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_freelist
argument_list|(
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agbp
argument_list|,
operator|&
name|fbno
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|fbno
operator|!=
name|NULLAGBLOCK
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|userdata
condition|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|xfs_btree_get_bufs
argument_list|(
name|args
operator|->
name|mp
argument_list|,
name|args
operator|->
name|tp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|fbno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_trans_binval
argument_list|(
name|args
operator|->
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|args
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|fbno
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|args
operator|->
name|agbno
operator|+
name|args
operator|->
name|len
operator|<=
name|be32_to_cpu
argument_list|(
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|->
name|agbp
argument_list|)
operator|->
name|agf_length
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|args
operator|->
name|wasfromfl
operator|=
literal|1
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"freelist"
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * Nothing in the freelist. 		 */
else|else
name|flen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Can't allocate from the freelist for some reason. 	 */
else|else
name|flen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Can't do the allocation, give up. 	 */
if|if
condition|(
name|flen
operator|<
name|args
operator|->
name|minlen
condition|)
block|{
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"notenough"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|flen
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|fbnop
operator|=
name|fbno
expr_stmt|;
operator|*
name|flenp
operator|=
name|flen
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"normal"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
name|TRACE_ALLOC
argument_list|(
literal|"error"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Free the extent starting at agno/bno for length.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_free_ag_extent
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_buf_t
modifier|*
name|agbp
parameter_list|,
comment|/* buffer for a.g. freelist header */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|xfs_agblock_t
name|bno
parameter_list|,
comment|/* starting block number */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length of extent */
name|int
name|isfl
parameter_list|)
comment|/* set if is freelist blocks - no sb acctg */
block|{
name|xfs_btree_cur_t
modifier|*
name|bno_cur
decl_stmt|;
comment|/* cursor for by-block btree */
name|xfs_btree_cur_t
modifier|*
name|cnt_cur
decl_stmt|;
comment|/* cursor for by-size btree */
name|int
name|error
decl_stmt|;
comment|/* error return value */
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_free_ag_extent"
decl_stmt|;
endif|#
directive|endif
name|xfs_agblock_t
name|gtbno
decl_stmt|;
comment|/* start of right neighbor block */
name|xfs_extlen_t
name|gtlen
decl_stmt|;
comment|/* length of right neighbor block */
name|int
name|haveleft
decl_stmt|;
comment|/* have a left neighbor block */
name|int
name|haveright
decl_stmt|;
comment|/* have a right neighbor block */
name|int
name|i
decl_stmt|;
comment|/* temp, result code */
name|xfs_agblock_t
name|ltbno
decl_stmt|;
comment|/* start of left neighbor block */
name|xfs_extlen_t
name|ltlen
decl_stmt|;
comment|/* length of left neighbor block */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount point struct for filesystem */
name|xfs_agblock_t
name|nbno
decl_stmt|;
comment|/* new starting block of freespace */
name|xfs_extlen_t
name|nlen
decl_stmt|;
comment|/* new length of freespace */
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
comment|/* 	 * Allocate and initialize a cursor for the by-block btree. 	 */
name|bno_cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|agbp
argument_list|,
name|agno
argument_list|,
name|XFS_BTNUM_BNO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt_cur
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Look for a neighboring block on the left (lower block numbers) 	 * that is contiguous with this space. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_le
argument_list|(
name|bno_cur
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
operator|&
name|haveleft
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|haveleft
condition|)
block|{
comment|/* 		 * There is a block to our left. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|ltbno
argument_list|,
operator|&
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * It's not contiguous, though. 		 */
if|if
condition|(
name|ltbno
operator|+
name|ltlen
operator|<
name|bno
condition|)
name|haveleft
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 			 * If this failure happens the request to free this 			 * space was invalid, it's (partly) already free. 			 * Very bad. 			 */
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|ltbno
operator|+
name|ltlen
operator|<=
name|bno
argument_list|,
name|error0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Look for a neighboring block on the right (higher block numbers) 	 * that is contiguous with this space. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_increment
argument_list|(
name|bno_cur
argument_list|,
literal|0
argument_list|,
operator|&
name|haveright
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|haveright
condition|)
block|{
comment|/* 		 * There is a block to our right. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|gtbno
argument_list|,
operator|&
name|gtlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * It's not contiguous, though. 		 */
if|if
condition|(
name|bno
operator|+
name|len
operator|<
name|gtbno
condition|)
name|haveright
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 			 * If this failure happens the request to free this 			 * space was invalid, it's (partly) already free. 			 * Very bad. 			 */
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|gtbno
operator|>=
name|bno
operator|+
name|len
argument_list|,
name|error0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Now allocate and initialize a cursor for the by-size tree. 	 */
name|cnt_cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|agbp
argument_list|,
name|agno
argument_list|,
name|XFS_BTNUM_CNT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Have both left and right contiguous neighbors. 	 * Merge all three into a single free block. 	 */
if|if
condition|(
name|haveleft
operator|&&
name|haveright
condition|)
block|{
comment|/* 		 * Delete the old by-size entry on the left. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_delete
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * Delete the old by-size entry on the right. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|gtbno
argument_list|,
name|gtlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_delete
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * Delete the old by-block entry for the right block. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_delete
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * Move the by-block cursor back to the left neighbor. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_decrement
argument_list|(
name|bno_cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 		 * Check that this is the right record: delete didn't 		 * mangle the cursor. 		 */
block|{
name|xfs_agblock_t
name|xxbno
decl_stmt|;
name|xfs_extlen_t
name|xxlen
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_rec
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|xxbno
argument_list|,
operator|&
name|xxlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
operator|&&
name|xxbno
operator|==
name|ltbno
operator|&&
name|xxlen
operator|==
name|ltlen
argument_list|,
name|error0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Update remaining by-block entry to the new, joined block. 		 */
name|nbno
operator|=
name|ltbno
expr_stmt|;
name|nlen
operator|=
name|len
operator|+
name|ltlen
operator|+
name|gtlen
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_update
argument_list|(
name|bno_cur
argument_list|,
name|nbno
argument_list|,
name|nlen
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * Have only a left contiguous neighbor. 	 * Merge it together with the new freespace. 	 */
elseif|else
if|if
condition|(
name|haveleft
condition|)
block|{
comment|/* 		 * Delete the old by-size entry on the left. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|ltbno
argument_list|,
name|ltlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_delete
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * Back up the by-block cursor to the left neighbor, and 		 * update its length. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_decrement
argument_list|(
name|bno_cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|nbno
operator|=
name|ltbno
expr_stmt|;
name|nlen
operator|=
name|len
operator|+
name|ltlen
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_update
argument_list|(
name|bno_cur
argument_list|,
name|nbno
argument_list|,
name|nlen
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * Have only a right contiguous neighbor. 	 * Merge it together with the new freespace. 	 */
elseif|else
if|if
condition|(
name|haveright
condition|)
block|{
comment|/* 		 * Delete the old by-size entry on the right. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|gtbno
argument_list|,
name|gtlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_delete
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * Update the starting block and length of the right 		 * neighbor in the by-block tree. 		 */
name|nbno
operator|=
name|bno
expr_stmt|;
name|nlen
operator|=
name|len
operator|+
name|gtlen
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_update
argument_list|(
name|bno_cur
argument_list|,
name|nbno
argument_list|,
name|nlen
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * No contiguous neighbors. 	 * Insert the new freespace into the by-block tree. 	 */
else|else
block|{
name|nbno
operator|=
name|bno
expr_stmt|;
name|nlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_insert
argument_list|(
name|bno_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
block|}
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|bno_cur
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * In all cases we need to insert the new freespace in the by-size tree. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_lookup_eq
argument_list|(
name|cnt_cur
argument_list|,
name|nbno
argument_list|,
name|nlen
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|0
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_insert
argument_list|(
name|cnt_cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|cnt_cur
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Update the freespace totals in the ag and superblock. 	 */
block|{
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
comment|/* per allocation group data */
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agf
operator|->
name|agf_freeblks
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xfs_trans_agblocks_delta
argument_list|(
name|tp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_freeblks
operator|+=
name|len
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
operator|<=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_length
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|TRACE_MODAGF
argument_list|(
name|NULL
argument_list|,
name|agf
argument_list|,
name|XFS_AGF_FREEBLKS
argument_list|)
expr_stmt|;
name|xfs_alloc_log_agf
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|,
name|XFS_AGF_FREEBLKS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfl
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_FDBLOCKS
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_freex
argument_list|)
expr_stmt|;
name|XFS_STATS_ADD
argument_list|(
name|xs_freeb
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|TRACE_FREE
argument_list|(
name|haveleft
condition|?
operator|(
name|haveright
condition|?
literal|"both"
else|:
literal|"left"
operator|)
else|:
operator|(
name|haveright
condition|?
literal|"right"
else|:
literal|"none"
operator|)
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
name|isfl
argument_list|)
expr_stmt|;
comment|/* 	 * Since blocks move to the free list without the coordination 	 * used in xfs_bmap_finish, we can't allow block to be available 	 * for reallocation and non-transaction writing (user data) 	 * until we know that the transaction that moved it to the free 	 * list is permanently on disk.  We track the blocks by declaring 	 * these blocks as "busy"; the busy list is maintained on a per-ag 	 * basis and each transaction records which entries should be removed 	 * when the iclog commits to disk.  If a busy block is allocated, 	 * the iclog is pushed up to the LSN that freed the block. 	 */
name|xfs_alloc_mark_busy
argument_list|(
name|tp
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
name|TRACE_FREE
argument_list|(
literal|"error"
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
name|isfl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno_cur
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|bno_cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt_cur
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|cnt_cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Visible (exported) allocation/free functions.  * Some of these are used just by xfs_alloc_btree.c and this file.  */
end_comment

begin_comment
comment|/*  * Compute and fill in value of m_ag_maxlevels.  */
end_comment

begin_function
name|void
name|xfs_alloc_compute_maxlevels
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
comment|/* file system mount structure */
block|{
name|int
name|level
decl_stmt|;
name|uint
name|maxblocks
decl_stmt|;
name|uint
name|maxleafents
decl_stmt|;
name|int
name|minleafrecs
decl_stmt|;
name|int
name|minnoderecs
decl_stmt|;
name|maxleafents
operator|=
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|minleafrecs
operator|=
name|mp
operator|->
name|m_alloc_mnr
index|[
literal|0
index|]
expr_stmt|;
name|minnoderecs
operator|=
name|mp
operator|->
name|m_alloc_mnr
index|[
literal|1
index|]
expr_stmt|;
name|maxblocks
operator|=
operator|(
name|maxleafents
operator|+
name|minleafrecs
operator|-
literal|1
operator|)
operator|/
name|minleafrecs
expr_stmt|;
for|for
control|(
name|level
operator|=
literal|1
init|;
name|maxblocks
operator|>
literal|1
condition|;
name|level
operator|++
control|)
name|maxblocks
operator|=
operator|(
name|maxblocks
operator|+
name|minnoderecs
operator|-
literal|1
operator|)
operator|/
name|minnoderecs
expr_stmt|;
name|mp
operator|->
name|m_ag_maxlevels
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decide whether to use this allocation group for this allocation.  * If so, fix up the btree freelist's size.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_alloc_fix_freelist
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|,
comment|/* allocation argument structure */
name|int
name|flags
parameter_list|)
comment|/* XFS_ALLOC_FLAG_... */
block|{
name|xfs_buf_t
modifier|*
name|agbp
decl_stmt|;
comment|/* agf buffer pointer */
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* a.g. freespace structure pointer */
name|xfs_buf_t
modifier|*
name|agflbp
decl_stmt|;
comment|/* agfl buffer pointer */
name|xfs_agblock_t
name|bno
decl_stmt|;
comment|/* freelist block */
name|xfs_extlen_t
name|delta
decl_stmt|;
comment|/* new blocks needed in freelist */
name|int
name|error
decl_stmt|;
comment|/* error result code */
name|xfs_extlen_t
name|longest
decl_stmt|;
comment|/* longest extent in allocation group */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount point structure */
name|xfs_extlen_t
name|need
decl_stmt|;
comment|/* total blocks needed in freelist */
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
comment|/* per-ag information structure */
name|xfs_alloc_arg_t
name|targs
decl_stmt|;
comment|/* local allocation arguments */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|mp
operator|=
name|args
operator|->
name|mp
expr_stmt|;
name|pag
operator|=
name|args
operator|->
name|pag
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|tp
expr_stmt|;
if|if
condition|(
operator|!
name|pag
operator|->
name|pagf_init
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_read_agf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|flags
argument_list|,
operator|&
name|agbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|pag
operator|->
name|pagf_init
condition|)
block|{
name|args
operator|->
name|agbp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
name|agbp
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a metadata preferred pag and we are user data 	 * then try somewhere else if we are not being asked to 	 * try harder at this point 	 */
if|if
condition|(
name|pag
operator|->
name|pagf_metadata
operator|&&
name|args
operator|->
name|userdata
operator|&&
name|flags
condition|)
block|{
name|args
operator|->
name|agbp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|need
operator|=
name|XFS_MIN_FREELIST_PAG
argument_list|(
name|pag
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|delta
operator|=
name|need
operator|>
name|pag
operator|->
name|pagf_flcount
condition|?
name|need
operator|-
name|pag
operator|->
name|pagf_flcount
else|:
literal|0
expr_stmt|;
comment|/* 	 * If it looks like there isn't a long enough extent, or enough 	 * total blocks, reject it. 	 */
name|longest
operator|=
operator|(
name|pag
operator|->
name|pagf_longest
operator|>
name|delta
operator|)
condition|?
operator|(
name|pag
operator|->
name|pagf_longest
operator|-
name|delta
operator|)
else|:
operator|(
name|pag
operator|->
name|pagf_flcount
operator|>
literal|0
operator|||
name|pag
operator|->
name|pagf_longest
operator|>
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|minlen
operator|+
name|args
operator|->
name|alignment
operator|+
name|args
operator|->
name|minalignslop
operator|-
literal|1
operator|>
name|longest
operator|||
operator|(
name|args
operator|->
name|minleft
operator|&&
call|(
name|int
call|)
argument_list|(
name|pag
operator|->
name|pagf_freeblks
operator|+
name|pag
operator|->
name|pagf_flcount
operator|-
name|need
operator|-
name|args
operator|->
name|total
argument_list|)
operator|<
operator|(
name|int
operator|)
name|args
operator|->
name|minleft
operator|)
condition|)
block|{
if|if
condition|(
name|agbp
condition|)
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|)
expr_stmt|;
name|args
operator|->
name|agbp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Get the a.g. freespace buffer. 	 * Can fail if we're not blocking on locks, and it's held. 	 */
if|if
condition|(
name|agbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_read_agf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|flags
argument_list|,
operator|&
name|agbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|agbp
operator|==
name|NULL
condition|)
block|{
name|args
operator|->
name|agbp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Figure out how many blocks we should have in the freelist. 	 */
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|need
operator|=
name|XFS_MIN_FREELIST
argument_list|(
name|agf
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|delta
operator|=
name|need
operator|>
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
condition|?
operator|(
name|need
operator|-
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|)
else|:
literal|0
expr_stmt|;
comment|/* 	 * If there isn't enough total or single-extent, reject it. 	 */
name|longest
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_longest
argument_list|)
expr_stmt|;
name|longest
operator|=
operator|(
name|longest
operator|>
name|delta
operator|)
condition|?
operator|(
name|longest
operator|-
name|delta
operator|)
else|:
operator|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|>
literal|0
operator|||
name|longest
operator|>
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|minlen
operator|+
name|args
operator|->
name|alignment
operator|+
name|args
operator|->
name|minalignslop
operator|-
literal|1
operator|>
name|longest
operator|||
operator|(
name|args
operator|->
name|minleft
operator|&&
call|(
name|int
call|)
argument_list|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
operator|+
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|-
name|need
operator|-
name|args
operator|->
name|total
argument_list|)
operator|<
operator|(
name|int
operator|)
name|args
operator|->
name|minleft
operator|)
condition|)
block|{
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|)
expr_stmt|;
name|args
operator|->
name|agbp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Make the freelist shorter if it's too long. 	 */
while|while
condition|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|>
name|need
condition|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_get_freelist
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|,
operator|&
name|bno
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_free_ag_extent
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|bno
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|bp
operator|=
name|xfs_btree_get_bufs
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|bno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_trans_binval
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the args structure. 	 */
name|targs
operator|.
name|tp
operator|=
name|tp
expr_stmt|;
name|targs
operator|.
name|mp
operator|=
name|mp
expr_stmt|;
name|targs
operator|.
name|agbp
operator|=
name|agbp
expr_stmt|;
name|targs
operator|.
name|agno
operator|=
name|args
operator|->
name|agno
expr_stmt|;
name|targs
operator|.
name|mod
operator|=
name|targs
operator|.
name|minleft
operator|=
name|targs
operator|.
name|wasdel
operator|=
name|targs
operator|.
name|userdata
operator|=
name|targs
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
name|targs
operator|.
name|alignment
operator|=
name|targs
operator|.
name|minlen
operator|=
name|targs
operator|.
name|prod
operator|=
name|targs
operator|.
name|isfl
operator|=
literal|1
expr_stmt|;
name|targs
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_THIS_AG
expr_stmt|;
name|targs
operator|.
name|pag
operator|=
name|pag
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_read_agfl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|targs
operator|.
name|agno
argument_list|,
operator|&
name|agflbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Make the freelist longer if it's too short. 	 */
while|while
condition|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|<
name|need
condition|)
block|{
name|targs
operator|.
name|agbno
operator|=
literal|0
expr_stmt|;
name|targs
operator|.
name|maxlen
operator|=
name|need
operator|-
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate as many blocks as possible at once. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_ag_vextent
argument_list|(
operator|&
name|targs
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 		 * Stop if we run out.  Won't happen if callers are obeying 		 * the restrictions correctly.  Can happen for free calls 		 * on a completely full ag. 		 */
if|if
condition|(
name|targs
operator|.
name|agbno
operator|==
name|NULLAGBLOCK
condition|)
break|break;
comment|/* 		 * Put each allocated block on the list. 		 */
for|for
control|(
name|bno
operator|=
name|targs
operator|.
name|agbno
init|;
name|bno
operator|<
name|targs
operator|.
name|agbno
operator|+
name|targs
operator|.
name|len
condition|;
name|bno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_put_freelist
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|,
name|agflbp
argument_list|,
name|bno
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
block|}
name|args
operator|->
name|agbp
operator|=
name|agbp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get a block from the freelist.  * Returns with the buffer for the block gotten.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_alloc_get_freelist
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_buf_t
modifier|*
name|agbp
parameter_list|,
comment|/* buffer containing the agf structure */
name|xfs_agblock_t
modifier|*
name|bnop
parameter_list|)
comment|/* block address retrieved from freelist */
block|{
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* a.g. freespace structure */
name|xfs_agfl_t
modifier|*
name|agfl
decl_stmt|;
comment|/* a.g. freelist structure */
name|xfs_buf_t
modifier|*
name|agflbp
decl_stmt|;
comment|/* buffer for a.g. freelist structure */
name|xfs_agblock_t
name|bno
decl_stmt|;
comment|/* block number returned */
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_get_freelist"
decl_stmt|;
endif|#
directive|endif
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
comment|/* per allocation group data */
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
comment|/* 	 * Freelist is empty, give up. 	 */
if|if
condition|(
operator|!
name|agf
operator|->
name|agf_flcount
condition|)
block|{
operator|*
name|bnop
operator|=
name|NULLAGBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Read the array of free blocks. 	 */
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_read_agfl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_seqno
argument_list|)
argument_list|,
operator|&
name|agflbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|agfl
operator|=
name|XFS_BUF_TO_AGFL
argument_list|(
name|agflbp
argument_list|)
expr_stmt|;
comment|/* 	 * Get the block number and update the data structures. 	 */
name|bno
operator|=
name|INT_GET
argument_list|(
name|agfl
operator|->
name|agfl_bno
index|[
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flfirst
argument_list|)
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agf
operator|->
name|agf_flfirst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|agflbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flfirst
argument_list|)
operator|==
name|XFS_AGFL_SIZE
argument_list|(
name|mp
argument_list|)
condition|)
name|agf
operator|->
name|agf_flfirst
operator|=
literal|0
expr_stmt|;
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_seqno
argument_list|)
index|]
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agf
operator|->
name|agf_flcount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_trans_agflist_delta
argument_list|(
name|tp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_flcount
operator|--
expr_stmt|;
name|TRACE_MODAGF
argument_list|(
name|NULL
argument_list|,
name|agf
argument_list|,
name|XFS_AGF_FLFIRST
operator||
name|XFS_AGF_FLCOUNT
argument_list|)
expr_stmt|;
name|xfs_alloc_log_agf
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|,
name|XFS_AGF_FLFIRST
operator||
name|XFS_AGF_FLCOUNT
argument_list|)
expr_stmt|;
operator|*
name|bnop
operator|=
name|bno
expr_stmt|;
comment|/* 	 * As blocks are freed, they are added to the per-ag busy list 	 * and remain there until the freeing transaction is committed to 	 * disk.  Now that we have allocated blocks, this list must be 	 * searched to see if a block is being reused.  If one is, then 	 * the freeing transaction must be pushed to disk NOW by forcing 	 * to disk all iclogs up that transaction's LSN. 	 */
name|xfs_alloc_search_busy
argument_list|(
name|tp
argument_list|,
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_seqno
argument_list|)
argument_list|,
name|bno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Log the given fields from the agf structure.  */
end_comment

begin_function
name|void
name|xfs_alloc_log_agf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
comment|/* buffer for a.g. freelist header */
name|int
name|fields
parameter_list|)
comment|/* mask of fields to be logged (XFS_AGF_...) */
block|{
name|int
name|first
decl_stmt|;
comment|/* first byte offset */
name|int
name|last
decl_stmt|;
comment|/* last byte offset */
specifier|static
specifier|const
name|short
name|offsets
index|[]
init|=
block|{
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_magicnum
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_versionnum
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_seqno
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_length
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_roots
index|[
literal|0
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_levels
index|[
literal|0
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_flfirst
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_fllast
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_flcount
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_freeblks
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_agf_t
argument_list|,
name|agf_longest
argument_list|)
block|,
expr|sizeof
operator|(
name|xfs_agf_t
operator|)
block|}
decl_stmt|;
name|xfs_btree_offsets
argument_list|(
name|fields
argument_list|,
name|offsets
argument_list|,
name|XFS_AGF_NUM_BITS
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
operator|(
name|uint
operator|)
name|first
argument_list|,
operator|(
name|uint
operator|)
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interface for inode allocation to force the pag data to be initialized.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_alloc_pagf_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|int
name|flags
parameter_list|)
comment|/* XFS_ALLOC_FLAGS_... */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_read_agf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|agno
argument_list|,
name|flags
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|bp
condition|)
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Put the block on the freelist for the allocation group.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_alloc_put_freelist
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_buf_t
modifier|*
name|agbp
parameter_list|,
comment|/* buffer for a.g. freelist header */
name|xfs_buf_t
modifier|*
name|agflbp
parameter_list|,
comment|/* buffer for a.g. free block array */
name|xfs_agblock_t
name|bno
parameter_list|)
comment|/* block being freed */
block|{
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* a.g. freespace structure */
name|xfs_agfl_t
modifier|*
name|agfl
decl_stmt|;
comment|/* a.g. free block array */
name|xfs_agblock_t
modifier|*
name|blockp
decl_stmt|;
comment|/* pointer to array entry */
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_put_freelist"
decl_stmt|;
endif|#
directive|endif
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
comment|/* per allocation group data */
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
if|if
condition|(
operator|!
name|agflbp
operator|&&
operator|(
name|error
operator|=
name|xfs_alloc_read_agfl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_seqno
argument_list|)
argument_list|,
operator|&
name|agflbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|agfl
operator|=
name|XFS_BUF_TO_AGFL
argument_list|(
name|agflbp
argument_list|)
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agf
operator|->
name|agf_fllast
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_fllast
argument_list|)
operator|==
name|XFS_AGFL_SIZE
argument_list|(
name|mp
argument_list|)
condition|)
name|agf
operator|->
name|agf_fllast
operator|=
literal|0
expr_stmt|;
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_seqno
argument_list|)
index|]
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agf
operator|->
name|agf_flcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_trans_agflist_delta
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_flcount
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|<=
name|XFS_AGFL_SIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|blockp
operator|=
operator|&
name|agfl
operator|->
name|agfl_bno
index|[
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_fllast
argument_list|)
index|]
expr_stmt|;
name|INT_SET
argument_list|(
operator|*
name|blockp
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|TRACE_MODAGF
argument_list|(
name|NULL
argument_list|,
name|agf
argument_list|,
name|XFS_AGF_FLLAST
operator||
name|XFS_AGF_FLCOUNT
argument_list|)
expr_stmt|;
name|xfs_alloc_log_agf
argument_list|(
name|tp
argument_list|,
name|agbp
argument_list|,
name|XFS_AGF_FLLAST
operator||
name|XFS_AGF_FLCOUNT
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|agflbp
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
name|blockp
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|agfl
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
name|blockp
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|agfl
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agblock_t
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read in the allocation group header (free/alloc section).  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_alloc_read_agf
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|int
name|flags
parameter_list|,
comment|/* XFS_ALLOC_FLAG_... */
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
comment|/* buffer for the ag freelist header */
block|{
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* ag freelist header */
name|int
name|agf_ok
decl_stmt|;
comment|/* set if agf is consistent */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* return value */
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
comment|/* per allocation group data */
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|agno
operator|!=
name|NULLAGNUMBER
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGF_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
name|flags
operator|&
name|XFS_ALLOC_FLAG_TRYLOCK
operator|)
condition|?
name|XFS_BUF_TRYLOCK
else|:
literal|0U
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
operator|!
name|bp
operator|||
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
operator|*
name|bpp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Validate the magic number of the agf block. 	 */
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|agf_ok
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_magicnum
argument_list|)
operator|==
name|XFS_AGF_MAGIC
operator|&&
name|XFS_AGF_GOOD_VERSION
argument_list|(
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_versionnum
argument_list|)
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
operator|<=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_length
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flfirst
argument_list|)
operator|<
name|XFS_AGFL_SIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_fllast
argument_list|)
operator|<
name|XFS_AGFL_SIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
operator|<=
name|XFS_AGFL_SIZE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|agf_ok
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_ALLOC_READ_AGF
argument_list|,
name|XFS_RANDOM_ALLOC_READ_AGF
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_alloc_read_agf"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|agf
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pag
operator|->
name|pagf_init
condition|)
block|{
name|pag
operator|->
name|pagf_freeblks
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_flcount
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_longest
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_longest
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_levels
index|[
name|XFS_BTNUM_BNOi
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_levels
index|[
name|XFS_BTNUM_BNOi
index|]
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_levels
index|[
name|XFS_BTNUM_CNTi
index|]
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_levels
index|[
name|XFS_BTNUM_CNTi
index|]
argument_list|)
expr_stmt|;
name|spinlock_init
argument_list|(
operator|&
name|pag
operator|->
name|pagb_lock
argument_list|,
literal|"xfspagb"
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagb_list
operator|=
name|kmem_zalloc
argument_list|(
name|XFS_PAGB_NUM_SLOTS
operator|*
sizeof|sizeof
argument_list|(
name|xfs_perag_busy_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pag
operator|->
name|pagf_init
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|pag
operator|->
name|pagf_freeblks
operator|==
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_freeblks
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pag
operator|->
name|pagf_flcount
operator|==
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_flcount
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pag
operator|->
name|pagf_longest
operator|==
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_longest
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pag
operator|->
name|pagf_levels
index|[
name|XFS_BTNUM_BNOi
index|]
operator|==
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_levels
index|[
name|XFS_BTNUM_BNOi
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pag
operator|->
name|pagf_levels
index|[
name|XFS_BTNUM_CNTi
index|]
operator|==
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_levels
index|[
name|XFS_BTNUM_CNTi
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|XFS_BUF_SET_VTYPE_REF
argument_list|(
name|bp
argument_list|,
name|B_FS_AGF
argument_list|,
name|XFS_AGF_REF
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an extent (variable-size).  * Depending on the allocation type, we either look in a single allocation  * group or loop over the allocation groups to find the result.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_alloc_vextent
parameter_list|(
name|xfs_alloc_arg_t
modifier|*
name|args
parameter_list|)
comment|/* allocation argument structure */
block|{
name|xfs_agblock_t
name|agsize
decl_stmt|;
comment|/* allocation group size */
name|int
name|error
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* XFS_ALLOC_FLAG_... locking flags */
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_alloc_vextent"
decl_stmt|;
endif|#
directive|endif
name|xfs_extlen_t
name|minleft
decl_stmt|;
comment|/* minimum left value, temp copy */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure pointer */
name|xfs_agnumber_t
name|sagno
decl_stmt|;
comment|/* starting allocation group number */
name|xfs_alloctype_t
name|type
decl_stmt|;
comment|/* input allocation type */
name|int
name|bump_rotor
init|=
literal|0
decl_stmt|;
name|int
name|no_min
init|=
literal|0
decl_stmt|;
name|xfs_agnumber_t
name|rotorstep
init|=
name|xfs_rotorstep
decl_stmt|;
comment|/* inode32 agf stepper */
name|mp
operator|=
name|args
operator|->
name|mp
expr_stmt|;
name|type
operator|=
name|args
operator|->
name|otype
operator|=
name|args
operator|->
name|type
expr_stmt|;
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
comment|/* 	 * Just fix this up, for the case where the last a.g. is shorter 	 * (or there's only one a.g.) and the caller couldn't easily figure 	 * that out (xfs_bmap_alloc). 	 */
name|agsize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|maxlen
operator|>
name|agsize
condition|)
name|args
operator|->
name|maxlen
operator|=
name|agsize
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|alignment
operator|==
literal|0
condition|)
name|args
operator|->
name|alignment
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
operator|<
name|agsize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|minlen
operator|<=
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|minlen
operator|<=
name|agsize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|mod
operator|<
name|args
operator|->
name|prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
operator|>=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|||
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
operator|>=
name|agsize
operator|||
name|args
operator|->
name|minlen
operator|>
name|args
operator|->
name|maxlen
operator|||
name|args
operator|->
name|minlen
operator|>
name|agsize
operator|||
name|args
operator|->
name|mod
operator|>=
name|args
operator|->
name|prod
condition|)
block|{
name|args
operator|->
name|fsbno
operator|=
name|NULLFSBLOCK
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"badargs"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|minleft
operator|=
name|args
operator|->
name|minleft
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|XFS_ALLOCTYPE_THIS_AG
case|:
case|case
name|XFS_ALLOCTYPE_NEAR_BNO
case|:
case|case
name|XFS_ALLOCTYPE_THIS_BNO
case|:
comment|/* 		 * These three force us into a single a.g. 		 */
name|args
operator|->
name|agno
operator|=
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
expr_stmt|;
name|down_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
name|args
operator|->
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|args
operator|->
name|agno
index|]
expr_stmt|;
name|args
operator|->
name|minleft
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_alloc_fix_freelist
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
operator|->
name|minleft
operator|=
name|minleft
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|TRACE_ALLOC
argument_list|(
literal|"nofix"
argument_list|,
name|args
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
operator|!
name|args
operator|->
name|agbp
condition|)
block|{
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"noagbp"
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
block|}
name|args
operator|->
name|agbno
operator|=
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_ag_vextent
argument_list|(
name|args
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ALLOCTYPE_START_BNO
case|:
comment|/* 		 * Try near allocation first, then anywhere-in-ag after 		 * the first a.g. fails. 		 */
if|if
condition|(
operator|(
name|args
operator|->
name|userdata
operator|==
name|XFS_ALLOC_INITIAL_USER_DATA
operator|)
operator|&&
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_32BITINODES
operator|)
condition|)
block|{
name|args
operator|->
name|fsbno
operator|=
name|XFS_AGB_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
operator|(
name|mp
operator|->
name|m_agfrotor
operator|/
name|rotorstep
operator|)
operator|%
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bump_rotor
operator|=
literal|1
expr_stmt|;
block|}
name|args
operator|->
name|agbno
operator|=
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|XFS_ALLOCTYPE_ANY_AG
case|:
case|case
name|XFS_ALLOCTYPE_START_AG
case|:
case|case
name|XFS_ALLOCTYPE_FIRST_AG
case|:
comment|/* 		 * Rotate through the allocation groups looking for a winner. 		 */
if|if
condition|(
name|type
operator|==
name|XFS_ALLOCTYPE_ANY_AG
condition|)
block|{
comment|/* 			 * Start with the last place we left off. 			 */
name|args
operator|->
name|agno
operator|=
name|sagno
operator|=
operator|(
name|mp
operator|->
name|m_agfrotor
operator|/
name|rotorstep
operator|)
operator|%
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|XFS_ALLOCTYPE_THIS_AG
expr_stmt|;
name|flags
operator|=
name|XFS_ALLOC_FLAG_TRYLOCK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XFS_ALLOCTYPE_FIRST_AG
condition|)
block|{
comment|/* 			 * Start with allocation group given by bno. 			 */
name|args
operator|->
name|agno
operator|=
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|XFS_ALLOCTYPE_THIS_AG
expr_stmt|;
name|sagno
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|XFS_ALLOCTYPE_START_AG
condition|)
name|args
operator|->
name|type
operator|=
name|XFS_ALLOCTYPE_THIS_AG
expr_stmt|;
comment|/* 			 * Start with the given allocation group. 			 */
name|args
operator|->
name|agno
operator|=
name|sagno
operator|=
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
expr_stmt|;
name|flags
operator|=
name|XFS_ALLOC_FLAG_TRYLOCK
expr_stmt|;
block|}
comment|/* 		 * Loop over allocation groups twice; first time with 		 * trylock set, second time without. 		 */
name|down_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|args
operator|->
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|args
operator|->
name|agno
index|]
expr_stmt|;
if|if
condition|(
name|no_min
condition|)
name|args
operator|->
name|minleft
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_alloc_fix_freelist
argument_list|(
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|args
operator|->
name|minleft
operator|=
name|minleft
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|TRACE_ALLOC
argument_list|(
literal|"nofix"
argument_list|,
name|args
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* 			 * If we get a buffer back then the allocation will fly. 			 */
if|if
condition|(
name|args
operator|->
name|agbp
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_ag_vextent
argument_list|(
name|args
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
break|break;
block|}
name|TRACE_ALLOC
argument_list|(
literal|"loopfailed"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 			 * Didn't work, figure out the next iteration. 			 */
if|if
condition|(
name|args
operator|->
name|agno
operator|==
name|sagno
operator|&&
name|type
operator|==
name|XFS_ALLOCTYPE_START_BNO
condition|)
name|args
operator|->
name|type
operator|=
name|XFS_ALLOCTYPE_THIS_AG
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|args
operator|->
name|agno
operator|)
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
condition|)
name|args
operator|->
name|agno
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Reached the starting a.g., must either be done 			 * or switch to non-trylock mode. 			 */
if|if
condition|(
name|args
operator|->
name|agno
operator|==
name|sagno
condition|)
block|{
if|if
condition|(
name|no_min
operator|==
literal|1
condition|)
block|{
name|args
operator|->
name|agbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
name|TRACE_ALLOC
argument_list|(
literal|"allfailed"
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
name|no_min
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|XFS_ALLOCTYPE_START_BNO
condition|)
block|{
name|args
operator|->
name|agbno
operator|=
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
block|}
block|}
block|}
block|}
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bump_rotor
operator|||
operator|(
name|type
operator|==
name|XFS_ALLOCTYPE_ANY_AG
operator|)
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|agno
operator|==
name|sagno
condition|)
name|mp
operator|->
name|m_agfrotor
operator|=
operator|(
name|mp
operator|->
name|m_agfrotor
operator|+
literal|1
operator|)
operator|%
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|*
name|rotorstep
operator|)
expr_stmt|;
else|else
name|mp
operator|->
name|m_agfrotor
operator|=
operator|(
name|args
operator|->
name|agno
operator|*
name|rotorstep
operator|+
literal|1
operator|)
operator|%
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|*
name|rotorstep
operator|)
expr_stmt|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|args
operator|->
name|agbno
operator|==
name|NULLAGBLOCK
condition|)
name|args
operator|->
name|fsbno
operator|=
name|NULLFSBLOCK
expr_stmt|;
else|else
block|{
name|args
operator|->
name|fsbno
operator|=
name|XFS_AGB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|agno
argument_list|,
name|args
operator|->
name|agbno
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ASSERT
argument_list|(
name|args
operator|->
name|len
operator|>=
name|args
operator|->
name|minlen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|len
operator|<=
name|args
operator|->
name|maxlen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|agbno
operator|%
name|args
operator|->
name|alignment
operator|==
literal|0
argument_list|)
expr_stmt|;
name|XFS_AG_CHECK_DADDR
argument_list|(
name|mp
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsbno
argument_list|)
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
name|error0
label|:
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Free an extent.  * Just break up the extent address and hand off to xfs_free_ag_extent  * after fixing up the freelist.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_free_extent
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_fsblock_t
name|bno
parameter_list|,
comment|/* starting block number of extent */
name|xfs_extlen_t
name|len
parameter_list|)
comment|/* length of extent */
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* a.g. freespace header */
endif|#
directive|endif
name|xfs_alloc_arg_t
name|args
decl_stmt|;
comment|/* allocation argument structure */
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|len
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|args
operator|.
name|tp
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|args
operator|.
name|agno
operator|=
name|XFS_FSB_TO_AGNO
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|.
name|agno
operator|<
name|args
operator|.
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
name|args
operator|.
name|agbno
operator|=
name|XFS_FSB_TO_AGBNO
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|args
operator|.
name|alignment
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|minlen
operator|=
name|args
operator|.
name|minleft
operator|=
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
name|down_read
argument_list|(
operator|&
name|args
operator|.
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
name|args
operator|.
name|pag
operator|=
operator|&
name|args
operator|.
name|mp
operator|->
name|m_perag
index|[
name|args
operator|.
name|agno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_fix_freelist
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
ifdef|#
directive|ifdef
name|DEBUG
name|ASSERT
argument_list|(
name|args
operator|.
name|agbp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|args
operator|.
name|agbp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|.
name|agbno
operator|+
name|len
operator|<=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_length
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|xfs_free_ag_extent
argument_list|(
name|tp
argument_list|,
name|args
operator|.
name|agbp
argument_list|,
name|args
operator|.
name|agno
argument_list|,
name|args
operator|.
name|agbno
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error0
label|:
name|up_read
argument_list|(
operator|&
name|args
operator|.
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * AG Busy list management  * The busy list contains block ranges that have been freed but whose  * transactions have not yet hit disk.  If any block listed in a busy  * list is reused, the transaction that freed it must be forced to disk  * before continuing to use the block.  *  * xfs_alloc_mark_busy - add to the per-ag busy list  * xfs_alloc_clear_busy - remove an item from the per-ag busy list  */
end_comment

begin_function
name|void
name|xfs_alloc_mark_busy
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_agnumber_t
name|agno
parameter_list|,
name|xfs_agblock_t
name|bno
parameter_list|,
name|xfs_extlen_t
name|len
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_perag_busy_t
modifier|*
name|bsy
decl_stmt|;
name|int
name|n
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|)
expr_stmt|;
comment|/* search pagb_list for an open slot */
for|for
control|(
name|bsy
operator|=
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|XFS_PAGB_NUM_SLOTS
condition|;
name|bsy
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
name|bsy
operator|->
name|busy_tp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|<
name|XFS_PAGB_NUM_SLOTS
condition|)
block|{
name|bsy
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
index|[
name|n
index|]
expr_stmt|;
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_count
operator|++
expr_stmt|;
name|TRACE_BUSY
argument_list|(
literal|"xfs_alloc_mark_busy"
argument_list|,
literal|"got"
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
name|n
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|bsy
operator|->
name|busy_start
operator|=
name|bno
expr_stmt|;
name|bsy
operator|->
name|busy_length
operator|=
name|len
expr_stmt|;
name|bsy
operator|->
name|busy_tp
operator|=
name|tp
expr_stmt|;
name|xfs_trans_add_busy
argument_list|(
name|tp
argument_list|,
name|agno
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE_BUSY
argument_list|(
literal|"xfs_alloc_mark_busy"
argument_list|,
literal|"FULL"
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * The busy list is full!  Since it is now not possible to 		 * track the free block, make this a synchronous transaction 		 * to insure that the block is not reused before this 		 * transaction commits. 		 */
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xfs_alloc_clear_busy
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_agnumber_t
name|agno
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_perag_busy_t
modifier|*
name|list
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|)
expr_stmt|;
name|list
operator|=
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
expr_stmt|;
name|ASSERT
argument_list|(
name|idx
operator|<
name|XFS_PAGB_NUM_SLOTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
index|[
name|idx
index|]
operator|.
name|busy_tp
operator|==
name|tp
condition|)
block|{
name|TRACE_UNBUSY
argument_list|(
literal|"xfs_alloc_clear_busy"
argument_list|,
literal|"found"
argument_list|,
name|agno
argument_list|,
name|idx
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|list
index|[
name|idx
index|]
operator|.
name|busy_tp
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|TRACE_UNBUSY
argument_list|(
literal|"xfs_alloc_clear_busy"
argument_list|,
literal|"missing"
argument_list|,
name|agno
argument_list|,
name|idx
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * returns non-zero if any of (agno,bno):len is in a busy list  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_alloc_search_busy
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_agnumber_t
name|agno
parameter_list|,
name|xfs_agblock_t
name|bno
parameter_list|,
name|xfs_extlen_t
name|len
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_perag_busy_t
modifier|*
name|bsy
decl_stmt|;
name|int
name|n
decl_stmt|;
name|xfs_agblock_t
name|uend
decl_stmt|,
name|bend
decl_stmt|;
name|xfs_lsn_t
name|lsn
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_count
expr_stmt|;
name|uend
operator|=
name|bno
operator|+
name|len
operator|-
literal|1
expr_stmt|;
comment|/* search pagb_list for this slot, skipping open slots */
for|for
control|(
name|bsy
operator|=
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
operator|,
name|n
operator|=
literal|0
init|;
name|cnt
condition|;
name|bsy
operator|++
operator|,
name|n
operator|++
control|)
block|{
comment|/* 		 * (start1,length1) within (start2, length2) 		 */
if|if
condition|(
name|bsy
operator|->
name|busy_tp
operator|!=
name|NULL
condition|)
block|{
name|bend
operator|=
name|bsy
operator|->
name|busy_start
operator|+
name|bsy
operator|->
name|busy_length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|bno
operator|>
name|bend
operator|)
operator|||
operator|(
name|uend
operator|<
name|bsy
operator|->
name|busy_start
operator|)
condition|)
block|{
name|cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|TRACE_BUSYSEARCH
argument_list|(
literal|"xfs_alloc_search_busy"
argument_list|,
literal|"found1"
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
name|n
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * If a block was found, force the log through the LSN of the 	 * transaction that freed the block 	 */
if|if
condition|(
name|cnt
condition|)
block|{
name|TRACE_BUSYSEARCH
argument_list|(
literal|"xfs_alloc_search_busy"
argument_list|,
literal|"found"
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
name|n
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|lsn
operator|=
name|bsy
operator|->
name|busy_tp
operator|->
name|t_commit_lsn
expr_stmt|;
name|mutex_spinunlock
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
name|lsn
argument_list|,
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE_BUSYSEARCH
argument_list|(
literal|"xfs_alloc_search_busy"
argument_list|,
literal|"not-found"
argument_list|,
name|agno
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
name|n
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
name|mutex_spinunlock
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

end_unit

