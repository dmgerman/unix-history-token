begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * getether.c : get the ethernet address of an interface  *  * All of this code is quite system-specific.  As you may well  * guess, it took a good bit of detective work to figure out!  *  * If you figure out how to do this on another system,  * please let me know.<gwr@mc.com>  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UNISTD
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"getether.h"
end_include

begin_include
include|#
directive|include
file|"report.h"
end_include

begin_define
define|#
directive|define
name|EALEN
value|6
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ultrix
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__alpha
argument_list|)
operator|)
end_if

begin_comment
comment|/*  * This is really easy on Ultrix!  Thanks to  * Harald Lundberg<hl@tekla.fi> for this code.  *  * The code here is not specific to the Alpha, but that was the  * only symbol we could find to identify DEC's version of OSF.  * (Perhaps we should just define DEC in the Makefile... -gwr)  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* struct ifdevea */
end_comment

begin_macro
name|getether
argument_list|(
argument|ifname
argument_list|,
argument|eap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ifname
decl_stmt|,
modifier|*
name|eap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|ifdevea
name|phys
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|phys
argument_list|,
sizeof|sizeof
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|phys
operator|.
name|ifr_name
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: socket(INET,DGRAM) failed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCRPHYSADDR
argument_list|,
operator|&
name|phys
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: ioctl SIOCRPHYSADDR failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|phys
operator|.
name|current_pa
index|[
literal|0
index|]
argument_list|,
name|eap
argument_list|,
name|EALEN
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_define
define|#
directive|define
name|GETETHER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ultrix|osf1 */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* needed by net_if.h */
end_comment

begin_include
include|#
directive|include
file|<net/nit_if.h>
end_include

begin_comment
comment|/* for NIOCBIND */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* for struct ifreq */
end_comment

begin_macro
name|getether
argument_list|(
argument|ifname
argument_list|,
argument|eap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ifname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface name from ifconfig structure */
end_comment

begin_decl_stmt
name|char
modifier|*
name|eap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ether address (output) */
end_comment

begin_block
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|ifreq
name|ifrnit
decl_stmt|;
name|int
name|nit
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifrnit
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrnit
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
operator|&
name|ifrnit
operator|.
name|ifr_name
index|[
literal|0
index|]
argument_list|,
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|nit
operator|=
name|open
argument_list|(
literal|"/dev/nit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nit
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: open /dev/nit: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
do|do
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|nit
argument_list|,
name|NIOCBIND
argument_list|,
operator|&
name|ifrnit
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: NIOCBIND on nit"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|nit
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|&
name|ifrnit
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: SIOCGIFADDR on nit"
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|ifrnit
operator|.
name|ifr_addr
operator|.
name|sa_data
index|[
literal|0
index|]
argument_list|,
name|eap
argument_list|,
name|EALEN
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|close
argument_list|(
name|nit
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_define
define|#
directive|define
name|GETETHER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNOS */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_comment
comment|/* Thanks to John Brezak<brezak@ch.hp.com> for this code. */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_function
name|int
name|getether
parameter_list|(
name|ifname
parameter_list|,
name|eap
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|;
comment|/* interface name from ifconfig structure */
name|char
modifier|*
name|eap
decl_stmt|;
comment|/* Ether address (output) */
block|{
name|int
name|fd
decl_stmt|,
name|rc
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|ifreq
name|ibuf
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifrp
decl_stmt|,
modifier|*
name|ifend
decl_stmt|;
comment|/* Fetch the interface configuration */
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: socket %s: %s"
argument_list|,
name|ifname
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
operator|(
name|caddr_t
operator|)
name|ibuf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
operator|||
name|ifc
operator|.
name|ifc_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: SIOCGIFCONF: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Search interface configuration list for link layer address. */
name|ifrp
operator|=
name|ibuf
expr_stmt|;
name|ifend
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ibuf
operator|+
name|ifc
operator|.
name|ifc_len
operator|)
expr_stmt|;
while|while
condition|(
name|ifrp
operator|<
name|ifend
condition|)
block|{
comment|/* Look for interface */
if|if
condition|(
name|strcmp
argument_list|(
name|ifname
argument_list|,
name|ifrp
operator|->
name|ifr_name
argument_list|)
operator|==
literal|0
operator|&&
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|==
name|AF_LINK
operator|&&
operator|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|&
name|ifrp
operator|->
name|ifr_addr
operator|)
operator|->
name|sdl_type
operator|==
name|IFT_ETHER
condition|)
block|{
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|&
name|ifrp
operator|->
name|ifr_addr
argument_list|)
argument_list|,
name|eap
argument_list|,
name|EALEN
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Bump interface config pointer */
name|n
operator|=
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|+
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ifrp
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifrp
argument_list|)
expr_stmt|;
name|ifrp
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifrp
operator|+
name|n
operator|)
expr_stmt|;
block|}
name|out
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GETETHER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_comment
comment|/*  * This is for "Streams TCP/IP" by Lachman Associates.  * They sure made this cumbersome!  -gwr  */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dlpi.h>
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getether
parameter_list|(
name|ifname
parameter_list|,
name|eap
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|;
comment|/* interface name from ifconfig structure */
name|char
modifier|*
name|eap
decl_stmt|;
comment|/* Ether address (output) */
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|devname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|tmpbuf
index|[
sizeof|sizeof
argument_list|(
expr|union
name|DL_primitives
argument_list|)
operator|+
literal|16
index|]
expr_stmt|;
name|struct
name|strbuf
name|cbuf
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|flags
decl_stmt|;
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|char
modifier|*
name|enaddr
decl_stmt|;
name|int
name|unit
init|=
operator|-
literal|1
decl_stmt|;
comment|/* which unit to attach */
name|snprintf
argument_list|(
name|devname
argument_list|,
sizeof|sizeof
argument_list|(
name|devname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|devname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* Try without the trailing digit. */
name|char
modifier|*
name|p
init|=
name|devname
operator|+
literal|5
decl_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|unit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|devname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: open %s: %s"
argument_list|,
name|devname
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DL_ATTACH_REQ
comment|/* 	 * If this is a "Style 2" DLPI, then we must "attach" first 	 * to tell the driver which unit (board, port) we want. 	 * For now, decide this based on the device name. 	 * (Should do "info_req" and check dl_provider_style ...) 	 */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|memset
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|tmpbuf
expr_stmt|;
name|dlp
operator|->
name|dl_primitive
operator|=
name|DL_ATTACH_REQ
expr_stmt|;
name|dlp
operator|->
name|attach_req
operator|.
name|dl_ppa
operator|=
name|unit
expr_stmt|;
name|cbuf
operator|.
name|buf
operator|=
name|tmpbuf
expr_stmt|;
name|cbuf
operator|.
name|len
operator|=
name|DL_ATTACH_REQ_SIZE
expr_stmt|;
if|if
condition|(
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|cbuf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: attach: putmsg: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Recv the ack. */
name|cbuf
operator|.
name|buf
operator|=
name|tmpbuf
expr_stmt|;
name|cbuf
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|cbuf
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: attach: getmsg: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Check the type, etc. 		 */
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|==
name|DL_ERROR_ACK
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: attach: dlpi_errno=%d, unix_errno=%d"
argument_list|,
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
argument_list|,
name|dlp
operator|->
name|error_ack
operator|.
name|dl_unix_errno
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|!=
name|DL_OK_ACK
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: attach: not OK or ERROR"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* unit>= 0 */
endif|#
directive|endif
comment|/* DL_ATTACH_REQ */
comment|/* 	 * Get the Ethernet address the same way the ARP module 	 * does when it is pushed onto a new stream (bind). 	 * One should instead be able just do a dl_info_req 	 * but many drivers do not supply the hardware address 	 * in the response to dl_info_req (they MUST supply it 	 * for dl_bind_ack because the ARP module requires it). 	 */
name|memset
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|tmpbuf
expr_stmt|;
name|dlp
operator|->
name|dl_primitive
operator|=
name|DL_BIND_REQ
expr_stmt|;
name|dlp
operator|->
name|bind_req
operator|.
name|dl_sap
operator|=
literal|0x8FF
expr_stmt|;
comment|/* XXX - Unused SAP */
name|cbuf
operator|.
name|buf
operator|=
name|tmpbuf
expr_stmt|;
name|cbuf
operator|.
name|len
operator|=
name|DL_BIND_REQ_SIZE
expr_stmt|;
if|if
condition|(
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|cbuf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: bind: putmsg: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Recv the ack. */
name|cbuf
operator|.
name|buf
operator|=
name|tmpbuf
expr_stmt|;
name|cbuf
operator|.
name|maxlen
operator|=
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|cbuf
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: bind: getmsg: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Check the type, etc. 	 */
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|==
name|DL_ERROR_ACK
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: bind: dlpi_errno=%d, unix_errno=%d"
argument_list|,
name|dlp
operator|->
name|error_ack
operator|.
name|dl_errno
argument_list|,
name|dlp
operator|->
name|error_ack
operator|.
name|dl_unix_errno
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|!=
name|DL_BIND_ACK
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: bind: not OK or ERROR"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dlp
operator|->
name|bind_ack
operator|.
name|dl_addr_offset
operator|==
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: bind: ack has no address"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dlp
operator|->
name|bind_ack
operator|.
name|dl_addr_length
operator|<
name|EALEN
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: bind: ack address truncated"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Copy the Ethernet address out of the message. 	 */
name|enaddr
operator|=
name|tmpbuf
operator|+
name|dlp
operator|->
name|bind_ack
operator|.
name|dl_addr_offset
expr_stmt|;
name|memcpy
argument_list|(
name|eap
argument_list|,
name|enaddr
argument_list|,
name|EALEN
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GETETHER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4 */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_comment
comment|/*  * This is really easy on Linux!  This version (for linux)  * written by Nigel Metheringham<nigelm@ohm.york.ac.uk> and  * updated by Pauline Middelink<middelin@polyware.iaf.nl>  *  * The code is almost identical to the Ultrix code - however  * the names are different to confuse the innocent :-)  * Most of this code was stolen from the Ultrix bit above.  */
end_comment

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* struct ifreq */
end_comment

begin_include
include|#
directive|include
file|<sys/socketio.h>
end_include

begin_comment
comment|/* Needed for IOCTL defs */
end_comment

begin_function
name|int
name|getether
parameter_list|(
name|ifname
parameter_list|,
name|eap
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|,
decl|*
name|eap
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|phys
decl_stmt|;
name|memset
argument_list|(
operator|&
name|phys
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|phys
operator|.
name|ifr_name
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: socket(INET,DGRAM) failed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFHWADDR
argument_list|,
operator|&
name|phys
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getether: ioctl SIOCGIFHWADDR failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|eap
argument_list|,
operator|&
name|phys
operator|.
name|ifr_hwaddr
operator|.
name|sa_data
argument_list|,
name|EALEN
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_define
define|#
directive|define
name|GETETHER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_comment
comment|/* If we don't know how on this system, just return an error. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GETETHER
end_ifndef

begin_function
name|int
name|getether
parameter_list|(
name|ifname
parameter_list|,
name|eap
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|,
decl|*
name|eap
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !GETETHER */
end_comment

begin_comment
comment|/*  * Local Variables:  * tab-width: 4  * c-indent-level: 4  * c-argdecl-indent: 4  * c-continued-statement-offset: 4  * c-continued-brace-offset: -4  * c-label-offset: -4  * c-brace-offset: 0  * End:  */
end_comment

end_unit

