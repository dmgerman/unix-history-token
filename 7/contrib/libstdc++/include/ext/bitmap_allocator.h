begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Bitmap Allocator. -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/** @file ext/bitmap_allocator.h  *  This file is a GNU extension to the Standard C++ Library.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_BITMAP_ALLOCATOR_H
end_ifndef

begin_define
define|#
directive|define
name|_BITMAP_ALLOCATOR_H
value|1
end_define

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_comment
comment|// For std::size_t, and ptrdiff_t.
end_comment

begin_include
include|#
directive|include
file|<bits/functexcept.h>
end_include

begin_comment
comment|// For __throw_bad_alloc().
end_comment

begin_include
include|#
directive|include
file|<utility>
end_include

begin_comment
comment|// For std::pair.
end_comment

begin_include
include|#
directive|include
file|<functional>
end_include

begin_comment
comment|// For greater_equal, and less_equal.
end_comment

begin_include
include|#
directive|include
file|<new>
end_include

begin_comment
comment|// For operator new.
end_comment

begin_include
include|#
directive|include
file|<debug/debug.h>
end_include

begin_comment
comment|// _GLIBCXX_DEBUG_ASSERT
end_comment

begin_include
include|#
directive|include
file|<ext/concurrence.h>
end_include

begin_comment
comment|/** @brief The constant in the expression below is the alignment  * required in bytes.  */
end_comment

begin_define
define|#
directive|define
name|_BALLOC_ALIGN_BYTES
value|8
end_define

begin_macro
name|_GLIBCXX_BEGIN_NAMESPACE
argument_list|(
argument|__gnu_cxx
argument_list|)
end_macro

begin_expr_stmt
name|using
name|std
operator|::
name|size_t
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|using
name|std
operator|::
name|ptrdiff_t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|namespace
name|__detail
block|{
comment|/** @class  __mini_vector bitmap_allocator.h bitmap_allocator.h      *      *  @brief  __mini_vector<> is a stripped down version of the      *  full-fledged std::vector<>.      *      *  It is to be used only for built-in types or PODs. Notable      *  differences are:      *       *  @detail      *  1. Not all accessor functions are present.      *  2. Used ONLY for PODs.      *  3. No Allocator template argument. Uses ::operator new() to get      *  memory, and ::operator delete() to free it.      *  Caveat: The dtor does NOT free the memory allocated, so this a      *  memory-leaking vector!      */
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|__mini_vector
block|{
name|__mini_vector
argument_list|(
specifier|const
name|__mini_vector
operator|&
argument_list|)
block|;
name|__mini_vector
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__mini_vector
operator|&
operator|)
block|;
name|public
operator|:
typedef|typedef
name|_Tp
name|value_type
typedef|;
typedef|typedef
name|_Tp
modifier|*
name|pointer
typedef|;
typedef|typedef
name|_Tp
modifier|&
name|reference
typedef|;
typedef|typedef
specifier|const
name|_Tp
modifier|&
name|const_reference
typedef|;
typedef|typedef
name|size_t
name|size_type
typedef|;
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
typedef|typedef
name|pointer
name|iterator
typedef|;
name|private
label|:
name|pointer
name|_M_start
decl_stmt|;
name|pointer
name|_M_finish
decl_stmt|;
name|pointer
name|_M_end_of_storage
decl_stmt|;
name|size_type
name|_M_space_left
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|_M_end_of_storage
operator|-
name|_M_finish
return|;
block|}
name|pointer
name|allocate
parameter_list|(
name|size_type
name|__n
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|pointer
operator|>
operator|(
operator|::
name|operator
name|new
argument_list|(
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|_Tp
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|void
name|deallocate
parameter_list|(
name|pointer
name|__p
parameter_list|,
name|size_type
parameter_list|)
block|{
operator|::
name|operator
name|delete
argument_list|(
name|__p
argument_list|)
expr_stmt|;
block|}
name|public
label|:
comment|// Members used: size(), push_back(), pop_back(),
comment|// insert(iterator, const_reference), erase(iterator),
comment|// begin(), end(), back(), operator[].
name|__mini_vector
argument_list|()
operator|:
name|_M_start
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_finish
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_end_of_storage
argument_list|(
literal|0
argument_list|)
block|{ }
if|#
directive|if
literal|0
expr|~__mini_vector() 	{ 	  if (this->_M_start) 	    { 	      this->deallocate(this->_M_start, this->_M_end_of_storage  			       - this->_M_start); 	    } 	}
endif|#
directive|endif
name|size_type
name|size
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|_M_finish
operator|-
name|_M_start
return|;
block|}
name|iterator
name|begin
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|this
operator|->
name|_M_start
return|;
block|}
name|iterator
name|end
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|this
operator|->
name|_M_finish
return|;
block|}
name|reference
name|back
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
operator|*
operator|(
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
operator|)
return|;
block|}
name|reference
name|operator
index|[]
argument_list|(
specifier|const
name|size_type
name|__pos
argument_list|)
decl|const
name|throw
argument_list|()
block|{
return|return
name|this
operator|->
name|_M_start
index|[
name|__pos
index|]
return|;
block|}
name|void
name|insert
parameter_list|(
name|iterator
name|__pos
parameter_list|,
name|const_reference
name|__x
parameter_list|)
function_decl|;
name|void
name|push_back
parameter_list|(
name|const_reference
name|__x
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|_M_space_left
argument_list|()
condition|)
block|{
operator|*
name|this
operator|->
name|end
argument_list|()
operator|=
name|__x
expr_stmt|;
operator|++
name|this
operator|->
name|_M_finish
expr_stmt|;
block|}
else|else
name|this
operator|->
name|insert
argument_list|(
name|this
operator|->
name|end
argument_list|()
argument_list|,
name|__x
argument_list|)
expr_stmt|;
block|}
name|void
name|pop_back
parameter_list|()
function|throw
parameter_list|()
block|{
operator|--
name|this
operator|->
name|_M_finish
expr_stmt|;
block|}
name|void
name|erase
parameter_list|(
name|iterator
name|__pos
parameter_list|)
function_decl|throw
parameter_list|()
function_decl|;
name|void
name|clear
parameter_list|()
function|throw
parameter_list|()
block|{
name|this
operator|->
name|_M_finish
operator|=
name|this
operator|->
name|_M_start
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Out of line function definitions.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|void
name|__mini_vector
operator|<
name|_Tp
operator|>
operator|::
name|insert
argument_list|(
argument|iterator __pos
argument_list|,
argument|const_reference __x
argument_list|)
block|{
if|if
condition|(
name|this
operator|->
name|_M_space_left
argument_list|()
condition|)
block|{
name|size_type
name|__to_move
init|=
name|this
operator|->
name|_M_finish
operator|-
name|__pos
decl_stmt|;
name|iterator
name|__dest
init|=
name|this
operator|->
name|end
argument_list|()
decl_stmt|;
name|iterator
name|__src
init|=
name|this
operator|->
name|end
argument_list|()
operator|-
literal|1
decl_stmt|;
operator|++
name|this
operator|->
name|_M_finish
expr_stmt|;
while|while
condition|(
name|__to_move
condition|)
block|{
operator|*
name|__dest
operator|=
operator|*
name|__src
expr_stmt|;
operator|--
name|__dest
expr_stmt|;
operator|--
name|__src
expr_stmt|;
operator|--
name|__to_move
expr_stmt|;
block|}
operator|*
name|__pos
operator|=
name|__x
expr_stmt|;
end_expr_stmt

begin_block
unit|} 	else
block|{
name|size_type
name|__new_size
init|=
name|this
operator|->
name|size
argument_list|()
condition|?
name|this
operator|->
name|size
argument_list|()
operator|*
literal|2
else|:
literal|1
decl_stmt|;
name|iterator
name|__new_start
init|=
name|this
operator|->
name|allocate
argument_list|(
name|__new_size
argument_list|)
decl_stmt|;
name|iterator
name|__first
init|=
name|this
operator|->
name|begin
argument_list|()
decl_stmt|;
name|iterator
name|__start
init|=
name|__new_start
decl_stmt|;
while|while
condition|(
name|__first
operator|!=
name|__pos
condition|)
block|{
operator|*
name|__start
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__start
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
operator|*
name|__start
operator|=
name|__x
expr_stmt|;
operator|++
name|__start
expr_stmt|;
while|while
condition|(
name|__first
operator|!=
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
operator|*
name|__start
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__start
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|->
name|_M_start
condition|)
name|this
operator|->
name|deallocate
argument_list|(
name|this
operator|->
name|_M_start
argument_list|,
name|this
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|_M_start
operator|=
name|__new_start
expr_stmt|;
name|this
operator|->
name|_M_finish
operator|=
name|__start
expr_stmt|;
name|this
operator|->
name|_M_end_of_storage
operator|=
name|this
operator|->
name|_M_start
operator|+
name|__new_size
expr_stmt|;
block|}
end_block

begin_expr_stmt
unit|}      template
operator|<
name|typename
name|_Tp
operator|>
name|void
name|__mini_vector
operator|<
name|_Tp
operator|>
operator|::
name|erase
argument_list|(
argument|iterator __pos
argument_list|)
name|throw
argument_list|()
block|{
while|while
condition|(
name|__pos
operator|+
literal|1
operator|!=
name|this
operator|->
name|end
argument_list|()
condition|)
block|{
operator|*
name|__pos
operator|=
name|__pos
index|[
literal|1
index|]
expr_stmt|;
operator|++
name|__pos
expr_stmt|;
block|}
operator|--
name|this
operator|->
name|_M_finish
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}       template
operator|<
name|typename
name|_Tp
operator|>
expr|struct
name|__mv_iter_traits
block|{
typedef|typedef
name|typename
name|_Tp
operator|::
name|value_type
name|value_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Tp
operator|::
name|difference_type
name|difference_type
expr_stmt|;
end_typedef

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|>
expr|struct
name|__mv_iter_traits
operator|<
name|_Tp
operator|*
operator|>
block|{
typedef|typedef
name|_Tp
name|value_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_enum
unit|};
enum|enum
block|{
name|bits_per_byte
init|=
literal|8
block|,
name|bits_per_block
init|=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
name|size_t
argument_list|(
argument|bits_per_byte
argument_list|)
block|}
enum|;
end_enum

begin_expr_stmt
name|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
name|_ForwardIterator
name|__lower_bound
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|__mv_iter_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|__mv_iter_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_decl_stmt
name|_DistanceType
name|__len
init|=
name|__last
operator|-
name|__first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__half
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__middle
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__len
operator|>
literal|0
condition|)
block|{
name|__half
operator|=
name|__len
operator|>>
literal|1
expr_stmt|;
name|__middle
operator|=
name|__first
expr_stmt|;
name|__middle
operator|+=
name|__half
expr_stmt|;
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__middle
argument_list|,
name|__val
argument_list|)
condition|)
block|{
name|__first
operator|=
name|__middle
expr_stmt|;
operator|++
name|__first
expr_stmt|;
name|__len
operator|=
name|__len
operator|-
name|__half
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|__len
operator|=
name|__half
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__first
return|;
end_return

begin_expr_stmt
unit|}      template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Predicate
operator|>
specifier|inline
name|_InputIterator
name|__find_if
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_Predicate __p
argument_list|)
block|{
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
operator|!
name|__p
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
operator|++
name|__first
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/** @brief The number of Blocks pointed to by the address pair      *  passed to the function.      */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_AddrPair
operator|>
specifier|inline
name|size_t
name|__num_blocks
argument_list|(
argument|_AddrPair __ap
argument_list|)
block|{
return|return
operator|(
name|__ap
operator|.
name|second
operator|-
name|__ap
operator|.
name|first
operator|)
operator|+
literal|1
return|;
block|}
end_expr_stmt

begin_comment
comment|/** @brief The number of Bit-maps pointed to by the address pair      *  passed to the function.      */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_AddrPair
operator|>
specifier|inline
name|size_t
name|__num_bitmaps
argument_list|(
argument|_AddrPair __ap
argument_list|)
block|{
return|return
name|__num_blocks
argument_list|(
name|__ap
argument_list|)
operator|/
name|size_t
argument_list|(
name|bits_per_block
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// _Tp should be a pointer type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|_Inclusive_between
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
operator|,
name|bool
operator|>
block|{
typedef|typedef
name|_Tp
name|pointer
typedef|;
name|pointer
name|_M_ptr_value
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
name|_Block_pair
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_macro
name|_Inclusive_between
argument_list|(
argument|pointer __ptr
argument_list|)
end_macro

begin_macro
unit|:
name|_M_ptr_value
argument_list|(
argument|__ptr
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_expr_stmt
name|bool
name|operator
argument_list|()
operator|(
name|_Block_pair
name|__bp
operator|)
specifier|const
name|throw
argument_list|()
block|{
if|if
condition|(
name|std
operator|::
name|less_equal
operator|<
name|pointer
operator|>
operator|(
operator|)
operator|(
name|_M_ptr_value
operator|,
name|__bp
operator|.
name|second
operator|)
operator|&&
name|std
operator|::
name|greater_equal
operator|<
name|pointer
operator|>
operator|(
operator|)
operator|(
name|_M_ptr_value
operator|,
name|__bp
operator|.
name|first
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// Used to pass a Functor to functions by reference.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
operator|>
name|class
name|_Functor_Ref
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|typename
name|_Functor
operator|::
name|argument_type
operator|,
name|typename
name|_Functor
operator|::
name|result_type
operator|>
block|{
name|_Functor
operator|&
name|_M_fref
block|;
name|public
operator|:
typedef|typedef
name|typename
name|_Functor
operator|::
name|argument_type
name|argument_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_Functor
operator|::
name|result_type
name|result_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|_Functor_Ref
argument_list|(
name|_Functor
operator|&
name|__fref
argument_list|)
operator|:
name|_M_fref
argument_list|(
argument|__fref
argument_list|)
block|{ }
name|result_type
name|operator
argument_list|()
operator|(
name|argument_type
name|__arg
operator|)
block|{
return|return
name|_M_fref
argument_list|(
name|__arg
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/** @class  _Ffit_finder bitmap_allocator.h bitmap_allocator.h      *      *  @brief  The class which acts as a predicate for applying the      *  first-fit memory allocation policy for the bitmap allocator.      */
end_comment

begin_comment
comment|// _Tp should be a pointer type, and _Alloc is the Allocator for
end_comment

begin_comment
comment|// the vector.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|_Ffit_finder
operator|:
name|public
name|std
operator|::
name|unary_function
operator|<
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
operator|,
name|bool
operator|>
block|{
typedef|typedef
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
name|_Block_pair
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|__detail
operator|::
name|__mini_vector
operator|<
name|_Block_pair
operator|>
name|_BPVector
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|_BPVector
operator|::
name|difference_type
name|_Counter_type
expr_stmt|;
end_typedef

begin_decl_stmt
name|size_t
modifier|*
name|_M_pbitmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Counter_type
name|_M_data_offset
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|_Ffit_finder
argument_list|()
operator|:
name|_M_pbitmap
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_data_offset
argument_list|(
literal|0
argument_list|)
block|{ }
name|bool
name|operator
argument_list|()
operator|(
name|_Block_pair
name|__bp
operator|)
name|throw
argument_list|()
block|{
comment|// Set the _rover to the last physical location bitmap,
comment|// which is the bitmap which belongs to the first free
comment|// block. Thus, the bitmaps are in exact reverse order of
comment|// the actual memory layout. So, we count down the bimaps,
comment|// which is the same as moving up the memory.
comment|// If the used count stored at the start of the Bit Map headers
comment|// is equal to the number of Objects that the current Block can
comment|// store, then there is definitely no space for another single
comment|// object, so just return false.
name|_Counter_type
name|__diff
operator|=
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__num_bitmaps
argument_list|(
name|__bp
argument_list|)
block|;
if|if
condition|(
operator|*
operator|(
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|__bp
operator|.
name|first
operator|)
operator|-
operator|(
name|__diff
operator|+
literal|1
operator|)
operator|)
operator|==
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__num_blocks
argument_list|(
name|__bp
argument_list|)
condition|)
return|return
name|false
return|;
name|size_t
operator|*
name|__rover
operator|=
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|__bp
operator|.
name|first
operator|)
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|_Counter_type
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|__diff
condition|;
operator|++
name|__i
control|)
block|{
name|_M_data_offset
operator|=
name|__i
expr_stmt|;
if|if
condition|(
operator|*
name|__rover
condition|)
block|{
name|_M_pbitmap
operator|=
name|__rover
expr_stmt|;
return|return
name|true
return|;
block|}
operator|--
name|__rover
expr_stmt|;
block|}
end_for

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}       	size_t
operator|*
name|_M_get
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|_M_pbitmap
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Counter_type
name|_M_offset
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|_M_data_offset
operator|*
name|size_t
argument_list|(
name|bits_per_block
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/** @class  _Bitmap_counter bitmap_allocator.h bitmap_allocator.h      *      *  @brief  The bitmap counter which acts as the bitmap      *  manipulator, and manages the bit-manipulation functions and      *  the searching and identification functions on the bit-map.      */
end_comment

begin_comment
comment|// _Tp should be a pointer type.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|_Bitmap_counter
block|{
typedef|typedef
name|typename
name|__detail
operator|::
name|__mini_vector
operator|<
name|typename
name|std
operator|::
name|pair
operator|<
name|_Tp
operator|,
name|_Tp
operator|>
expr|>
name|_BPVector
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|_BPVector
operator|::
name|size_type
name|_Index_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
name|pointer
typedef|;
end_typedef

begin_decl_stmt
name|_BPVector
modifier|&
name|_M_vbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
modifier|*
name|_M_curr_bmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
modifier|*
name|_M_last_bmap_in_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Index_type
name|_M_curr_index
decl_stmt|;
end_decl_stmt

begin_label
name|public
label|:
end_label

begin_comment
comment|// Use the 2nd parameter with care. Make sure that such an
end_comment

begin_comment
comment|// entry exists in the vector before passing that particular
end_comment

begin_comment
comment|// index to this ctor.
end_comment

begin_macro
name|_Bitmap_counter
argument_list|(
argument|_BPVector& Rvbp
argument_list|,
argument|long __index = -
literal|1
argument_list|)
end_macro

begin_macro
unit|:
name|_M_vbp
argument_list|(
argument|Rvbp
argument_list|)
end_macro

begin_block
block|{
name|this
operator|->
name|_M_reset
argument_list|(
name|__index
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|_M_reset
parameter_list|(
name|long
name|__index
init|=
operator|-
literal|1
parameter_list|)
function|throw
parameter_list|()
block|{
if|if
condition|(
name|__index
operator|==
operator|-
literal|1
condition|)
block|{
name|_M_curr_bmap
operator|=
literal|0
expr_stmt|;
name|_M_curr_index
operator|=
name|static_cast
operator|<
name|_Index_type
operator|>
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
return|return;
block|}
name|_M_curr_index
operator|=
name|__index
expr_stmt|;
name|_M_curr_bmap
operator|=
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|first
operator|)
operator|-
literal|1
expr_stmt|;
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|__index
operator|<=
operator|(
name|long
operator|)
name|_M_vbp
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_M_last_bmap_in_block
operator|=
name|_M_curr_bmap
operator|-
operator|(
operator|(
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|second
operator|-
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|first
operator|+
literal|1
operator|)
operator|/
name|size_t
argument_list|(
name|bits_per_block
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Dangerous Function! Use with extreme care. Pass to this
end_comment

begin_comment
comment|// function ONLY those values that are known to be correct,
end_comment

begin_comment
comment|// otherwise this will mess up big time.
end_comment

begin_function
name|void
name|_M_set_internal_bitmap
parameter_list|(
name|size_t
modifier|*
name|__new_internal_marker
parameter_list|)
function|throw
parameter_list|()
block|{
name|_M_curr_bmap
operator|=
name|__new_internal_marker
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|_M_finished
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
operator|(
name|_M_curr_bmap
operator|==
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Bitmap_counter
operator|&
name|operator
operator|++
operator|(
operator|)
name|throw
argument_list|()
block|{
if|if
condition|(
name|_M_curr_bmap
operator|==
name|_M_last_bmap_in_block
condition|)
block|{
if|if
condition|(
operator|++
name|_M_curr_index
operator|==
name|_M_vbp
operator|.
name|size
argument_list|()
condition|)
name|_M_curr_bmap
operator|=
literal|0
expr_stmt|;
else|else
name|this
operator|->
name|_M_reset
argument_list|(
name|_M_curr_index
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
operator|--
name|_M_curr_bmap
expr_stmt|;
end_else

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}      	size_t
operator|*
name|_M_get
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|_M_curr_bmap
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|pointer
name|_M_base
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|_M_vbp
index|[
name|_M_curr_index
index|]
operator|.
name|first
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Index_type
name|_M_offset
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|size_t
argument_list|(
name|bits_per_block
argument_list|)
operator|*
operator|(
operator|(
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|this
operator|->
name|_M_base
argument_list|()
operator|)
operator|-
name|_M_curr_bmap
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Index_type
name|_M_where
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|_M_curr_index
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|/** @brief  Mark a memory address as allocated by re-setting the      *  corresponding bit in the bit-map.      */
end_comment

begin_function
specifier|inline
name|void
name|__bit_allocate
parameter_list|(
name|size_t
modifier|*
name|__pbmap
parameter_list|,
name|size_t
name|__pos
parameter_list|)
function|throw
parameter_list|()
block|{
name|size_t
name|__mask
init|=
literal|1
operator|<<
name|__pos
decl_stmt|;
name|__mask
operator|=
operator|~
name|__mask
expr_stmt|;
operator|*
name|__pbmap
operator|&=
name|__mask
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @brief  Mark a memory address as free by setting the      *  corresponding bit in the bit-map.      */
end_comment

begin_function
specifier|inline
name|void
name|__bit_free
parameter_list|(
name|size_t
modifier|*
name|__pbmap
parameter_list|,
name|size_t
name|__pos
parameter_list|)
function|throw
parameter_list|()
block|{
name|size_t
name|__mask
init|=
literal|1
operator|<<
name|__pos
decl_stmt|;
operator|*
name|__pbmap
operator||=
name|__mask
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|// namespace __detail
end_comment

begin_comment
comment|/** @brief  Generic Version of the bsf instruction.    */
end_comment

begin_function
unit|inline
name|size_t
name|_Bit_scan_forward
parameter_list|(
name|size_t
name|__num
parameter_list|)
block|{
return|return
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|__builtin_ctzl
argument_list|(
name|__num
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/** @class  free_list bitmap_allocator.h bitmap_allocator.h    *    *  @brief  The free list class for managing chunks of memory to be    *  given to and returned by the bitmap_allocator.    */
end_comment

begin_decl_stmt
name|class
name|free_list
block|{
typedef|typedef
name|size_t
modifier|*
name|value_type
typedef|;
typedef|typedef
name|__detail
operator|::
name|__mini_vector
operator|<
name|value_type
operator|>
name|vector_type
expr_stmt|;
typedef|typedef
name|vector_type
operator|::
name|iterator
name|iterator
expr_stmt|;
typedef|typedef
name|__mutex
name|__mutex_type
typedef|;
struct|struct
name|_LT_pointer_compare
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|size_t
operator|*
name|__pui
operator|,
specifier|const
name|size_t
name|__cui
operator|)
specifier|const
name|throw
argument_list|()
block|{
return|return
operator|*
name|__pui
operator|<
name|__cui
return|;
block|}
block|}
struct|;
if|#
directive|if
name|defined
name|__GTHREADS
name|__mutex_type
modifier|&
name|_M_get_mutex
parameter_list|()
block|{
specifier|static
name|__mutex_type
name|_S_mutex
decl_stmt|;
return|return
name|_S_mutex
return|;
block|}
endif|#
directive|endif
name|vector_type
modifier|&
name|_M_get_free_list
parameter_list|()
block|{
specifier|static
name|vector_type
name|_S_free_list
decl_stmt|;
return|return
name|_S_free_list
return|;
block|}
comment|/** @brief  Performs validation of memory based on their size.      *      *  @param  __addr The pointer to the memory block to be      *  validated.      *      *  @detail  Validates the memory block passed to this function and      *  appropriately performs the action of managing the free list of      *  blocks by adding this block to the free list or deleting this      *  or larger blocks from the free list.      */
name|void
name|_M_validate
parameter_list|(
name|size_t
modifier|*
name|__addr
parameter_list|)
function|throw
parameter_list|()
block|{
name|vector_type
modifier|&
name|__free_list
init|=
name|_M_get_free_list
argument_list|()
decl_stmt|;
specifier|const
name|vector_type
operator|::
name|size_type
name|__max_size
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|__free_list
operator|.
name|size
argument_list|()
operator|>=
name|__max_size
condition|)
block|{
comment|// Ok, the threshold value has been reached.  We determine
comment|// which block to remove from the list of free blocks.
if|if
condition|(
operator|*
name|__addr
operator|>=
operator|*
name|__free_list
operator|.
name|back
argument_list|()
condition|)
block|{
comment|// Ok, the new block is greater than or equal to the
comment|// last block in the list of free blocks. We just free
comment|// the new block.
operator|::
name|operator
name|delete
argument_list|(
name|static_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|__addr
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// Deallocate the last block in the list of free lists,
comment|// and insert the new one in it's correct position.
operator|::
name|operator
name|delete
argument_list|(
name|static_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|__free_list
operator|.
name|back
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|__free_list
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Just add the block to the list of free lists unconditionally.
name|iterator
name|__temp
init|=
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__lower_bound
argument_list|(
name|__free_list
operator|.
name|begin
argument_list|()
argument_list|,
name|__free_list
operator|.
name|end
argument_list|()
argument_list|,
operator|*
name|__addr
argument_list|,
name|_LT_pointer_compare
argument_list|()
argument_list|)
decl_stmt|;
comment|// We may insert the new free list before _temp;
name|__free_list
operator|.
name|insert
argument_list|(
name|__temp
argument_list|,
name|__addr
argument_list|)
expr_stmt|;
block|}
comment|/** @brief  Decides whether the wastage of memory is acceptable for      *  the current memory request and returns accordingly.      *      *  @param __block_size The size of the block available in the free      *  list.      *      *  @param __required_size The required size of the memory block.      *      *  @return true if the wastage incurred is acceptable, else returns      *  false.      */
name|bool
name|_M_should_i_give
parameter_list|(
name|size_t
name|__block_size
parameter_list|,
name|size_t
name|__required_size
parameter_list|)
function|throw
parameter_list|()
block|{
specifier|const
name|size_t
name|__max_wastage_percentage
init|=
literal|36
decl_stmt|;
if|if
condition|(
name|__block_size
operator|>=
name|__required_size
operator|&&
operator|(
operator|(
operator|(
name|__block_size
operator|-
name|__required_size
operator|)
operator|*
literal|100
operator|/
name|__block_size
operator|)
operator|<
name|__max_wastage_percentage
operator|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
name|public
label|:
comment|/** @brief This function returns the block of memory to the      *  internal free list.      *      *  @param  __addr The pointer to the memory block that was given      *  by a call to the _M_get function.      */
specifier|inline
name|void
name|_M_insert
parameter_list|(
name|size_t
modifier|*
name|__addr
parameter_list|)
function|throw
parameter_list|()
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|__gnu_cxx
operator|::
name|__scoped_lock
name|__bfl_lock
argument_list|(
name|_M_get_mutex
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Call _M_validate to decide what should be done with
comment|// this particular free list.
name|this
operator|->
name|_M_validate
argument_list|(
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|__addr
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// See discussion as to why this is 1!
block|}
comment|/** @brief  This function gets a block of memory of the specified      *  size from the free list.      *      *  @param  __sz The size in bytes of the memory required.      *      *  @return  A pointer to the new memory block of size at least      *  equal to that requested.      */
name|size_t
modifier|*
name|_M_get
parameter_list|(
name|size_t
name|__sz
parameter_list|)
function_decl|throw
parameter_list|(
function_decl|std::bad_alloc
block|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** @brief  This function just clears the internal Free List, and      *  gives back all the memory to the OS.      */
end_comment

begin_function_decl
name|void
name|_M_clear
parameter_list|()
function_decl|;
end_function_decl

begin_comment
unit|};
comment|// Forward declare the class.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|bitmap_allocator
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Specialize for void:
end_comment

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|bitmap_allocator
operator|<
name|void
operator|>
block|{
name|public
operator|:
typedef|typedef
name|void
modifier|*
name|pointer
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_comment
comment|// Reference-to-void members are impossible.
end_comment

begin_typedef
typedef|typedef
name|void
name|value_type
typedef|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|bitmap_allocator
operator|:
name|private
name|free_list
block|{
name|public
operator|:
typedef|typedef
name|size_t
name|size_type
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|ptrdiff_t
name|difference_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|*
name|pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|*
name|const_pointer
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
modifier|&
name|reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|_Tp
modifier|&
name|const_reference
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|_Tp
name|value_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|free_list
operator|::
name|__mutex_type
name|__mutex_type
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
expr|struct
name|rebind
block|{
typedef|typedef
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
name|other
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|size_t
name|_BSize
operator|,
name|size_t
name|_AlignSize
operator|>
expr|struct
name|aligned_size
block|{ 	  enum
block|{
name|modulus
operator|=
name|_BSize
operator|%
name|_AlignSize
block|,
name|value
operator|=
name|_BSize
operator|+
operator|(
name|modulus
operator|?
name|_AlignSize
operator|-
operator|(
name|modulus
operator|)
operator|:
literal|0
operator|)
block|}
block|; 	}
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|_Alloc_block
block|{
name|char
name|__M_unused
index|[
name|aligned_size
operator|<
sizeof|sizeof
argument_list|(
name|value_type
argument_list|)
operator|,
name|_BALLOC_ALIGN_BYTES
operator|>
operator|::
name|value
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|typename
name|std
operator|::
name|pair
operator|<
name|_Alloc_block
operator|*
operator|,
name|_Alloc_block
operator|*
operator|>
name|_Block_pair
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|__detail
operator|::
name|__mini_vector
operator|<
name|_Block_pair
operator|>
name|_BPVector
expr_stmt|;
end_typedef

begin_if
if|#
directive|if
name|defined
name|_GLIBCXX_DEBUG
end_if

begin_comment
comment|// Complexity: O(lg(N)). Where, N is the number of block of size
end_comment

begin_comment
comment|// sizeof(value_type).
end_comment

begin_function
name|void
name|_S_check_for_free_blocks
parameter_list|()
function|throw
parameter_list|()
block|{
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Ffit_finder
operator|<
name|_Alloc_block
operator|*
operator|>
name|_FFF
expr_stmt|;
name|_FFF
name|__fff
decl_stmt|;
typedef|typedef
name|typename
name|_BPVector
operator|::
name|iterator
name|_BPiter
expr_stmt|;
name|_BPiter
name|__bpi
init|=
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__find_if
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|,
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Functor_Ref
operator|<
name|_FFF
operator|>
operator|(
name|__fff
operator|)
argument_list|)
decl_stmt|;
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|__bpi
operator|==
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** @brief  Responsible for exponentially growing the internal        *  memory pool.        *        *  @throw  std::bad_alloc. If memory can not be allocated.        *        *  @detail  Complexity: O(1), but internally depends upon the        *  complexity of the function free_list::_M_get. The part where        *  the bitmap headers are written has complexity: O(X),where X        *  is the number of blocks of size sizeof(value_type) within        *  the newly acquired block. Having a tight bound.        */
end_comment

begin_function
name|void
name|_S_refill_pool
parameter_list|()
function|throw
parameter_list|(
function|std::bad_alloc
end_function

begin_block
unit|)
block|{
if|#
directive|if
name|defined
name|_GLIBCXX_DEBUG
name|_S_check_for_free_blocks
argument_list|()
expr_stmt|;
endif|#
directive|endif
specifier|const
name|size_t
name|__num_bitmaps
init|=
operator|(
name|_S_block_size
operator|/
name|size_t
argument_list|(
name|__detail
operator|::
name|bits_per_block
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|size_t
name|__size_to_allocate
init|=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|_S_block_size
operator|*
sizeof|sizeof
argument_list|(
name|_Alloc_block
argument_list|)
operator|+
name|__num_bitmaps
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
decl_stmt|;
name|size_t
modifier|*
name|__temp
init|=
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|this
operator|->
name|_M_get
argument_list|(
name|__size_to_allocate
argument_list|)
operator|)
decl_stmt|;
operator|*
name|__temp
operator|=
literal|0
expr_stmt|;
operator|++
name|__temp
expr_stmt|;
comment|// The Header information goes at the Beginning of the Block.
name|_Block_pair
name|__bp
init|=
name|std
operator|::
name|make_pair
argument_list|(
name|reinterpret_cast
operator|<
name|_Alloc_block
operator|*
operator|>
operator|(
name|__temp
operator|+
name|__num_bitmaps
operator|)
argument_list|,
name|reinterpret_cast
operator|<
name|_Alloc_block
operator|*
operator|>
operator|(
name|__temp
operator|+
name|__num_bitmaps
operator|)
operator|+
name|_S_block_size
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// Fill the Vector with this information.
name|_S_mem_blocks
operator|.
name|push_back
argument_list|(
name|__bp
argument_list|)
expr_stmt|;
name|size_t
name|__bit_mask
init|=
literal|0
decl_stmt|;
comment|// 0 Indicates all Allocated.
name|__bit_mask
operator|=
operator|~
name|__bit_mask
expr_stmt|;
comment|// 1 Indicates all Free.
for|for
control|(
name|size_t
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|__num_bitmaps
condition|;
operator|++
name|__i
control|)
name|__temp
index|[
name|__i
index|]
operator|=
name|__bit_mask
expr_stmt|;
name|_S_block_size
operator|*=
literal|2
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|_BPVector
name|_S_mem_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|_S_block_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Bitmap_counter
operator|<
name|_Alloc_block
operator|*
operator|>
name|_S_last_request
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|typename
name|_BPVector
operator|::
name|size_type
name|_S_last_dealloc_index
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
name|__GTHREADS
end_if

begin_decl_stmt
specifier|static
name|__mutex_type
name|_S_mut
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|public
label|:
end_label

begin_comment
comment|/** @brief  Allocates memory for a single object of size        *  sizeof(_Tp).        *        *  @throw  std::bad_alloc. If memory can not be allocated.        *        *  @detail  Complexity: Worst case complexity is O(N), but that        *  is hardly ever hit. If and when this particular case is        *  encountered, the next few cases are guaranteed to have a        *  worst case complexity of O(1)!  That's why this function        *  performs very well on average. You can consider this        *  function to have a complexity referred to commonly as:        *  Amortized Constant time.        */
end_comment

begin_function
name|pointer
name|_M_allocate_single_object
parameter_list|()
function|throw
parameter_list|(
function|std::bad_alloc
end_function

begin_block
unit|)
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|__gnu_cxx
operator|::
name|__scoped_lock
name|__bit_lock
argument_list|(
name|_S_mut
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// The algorithm is something like this: The last_request
comment|// variable points to the last accessed Bit Map. When such a
comment|// condition occurs, we try to find a free block in the
comment|// current bitmap, or succeeding bitmaps until the last bitmap
comment|// is reached. If no free block turns up, we resort to First
comment|// Fit method.
comment|// WARNING: Do not re-order the condition in the while
comment|// statement below, because it relies on C++'s short-circuit
comment|// evaluation. The return from _S_last_request->_M_get() will
comment|// NOT be dereference able if _S_last_request->_M_finished()
comment|// returns true. This would inevitably lead to a NULL pointer
comment|// dereference if tinkered with.
while|while
condition|(
name|_S_last_request
operator|.
name|_M_finished
argument_list|()
operator|==
name|false
operator|&&
operator|(
operator|*
operator|(
name|_S_last_request
operator|.
name|_M_get
argument_list|()
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|_S_last_request
operator|.
name|operator
operator|++
operator|(
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|__builtin_expect
argument_list|(
name|_S_last_request
operator|.
name|_M_finished
argument_list|()
operator|==
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
comment|// Fall Back to First Fit algorithm.
typedef|typedef
name|typename
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Ffit_finder
operator|<
name|_Alloc_block
operator|*
operator|>
name|_FFF
expr_stmt|;
name|_FFF
name|__fff
decl_stmt|;
typedef|typedef
name|typename
name|_BPVector
operator|::
name|iterator
name|_BPiter
expr_stmt|;
name|_BPiter
name|__bpi
init|=
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__find_if
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|,
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Functor_Ref
operator|<
name|_FFF
operator|>
operator|(
name|__fff
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|__bpi
operator|!=
name|_S_mem_blocks
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// Search was successful. Ok, now mark the first bit from
comment|// the right as 0, meaning Allocated. This bit is obtained
comment|// by calling _M_get() on __fff.
name|size_t
name|__nz_bit
init|=
name|_Bit_scan_forward
argument_list|(
operator|*
name|__fff
operator|.
name|_M_get
argument_list|()
argument_list|)
decl_stmt|;
name|__detail
operator|::
name|__bit_allocate
argument_list|(
name|__fff
operator|.
name|_M_get
argument_list|()
argument_list|,
name|__nz_bit
argument_list|)
expr_stmt|;
name|_S_last_request
operator|.
name|_M_reset
argument_list|(
name|__bpi
operator|-
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now, get the address of the bit we marked as allocated.
name|pointer
name|__ret
init|=
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
name|__bpi
operator|->
name|first
operator|+
name|__fff
operator|.
name|_M_offset
argument_list|()
operator|+
name|__nz_bit
operator|)
decl_stmt|;
name|size_t
modifier|*
name|__puse_count
init|=
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|__bpi
operator|->
name|first
operator|)
operator|-
operator|(
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__num_bitmaps
argument_list|(
operator|*
name|__bpi
argument_list|)
operator|+
literal|1
operator|)
decl_stmt|;
operator|++
operator|(
operator|*
name|__puse_count
operator|)
expr_stmt|;
return|return
name|__ret
return|;
block|}
else|else
block|{
comment|// Search was unsuccessful. We Add more memory to the
comment|// pool by calling _S_refill_pool().
name|_S_refill_pool
argument_list|()
expr_stmt|;
comment|// _M_Reset the _S_last_request structure to the first
comment|// free block's bit map.
name|_S_last_request
operator|.
name|_M_reset
argument_list|(
name|_S_mem_blocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Now, mark that bit as allocated.
block|}
block|}
comment|// _S_last_request holds a pointer to a valid bit map, that
comment|// points to a free block in memory.
name|size_t
name|__nz_bit
init|=
name|_Bit_scan_forward
argument_list|(
operator|*
name|_S_last_request
operator|.
name|_M_get
argument_list|()
argument_list|)
decl_stmt|;
name|__detail
operator|::
name|__bit_allocate
argument_list|(
name|_S_last_request
operator|.
name|_M_get
argument_list|()
argument_list|,
name|__nz_bit
argument_list|)
expr_stmt|;
name|pointer
name|__ret
init|=
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
name|_S_last_request
operator|.
name|_M_base
argument_list|()
operator|+
name|_S_last_request
operator|.
name|_M_offset
argument_list|()
operator|+
name|__nz_bit
operator|)
decl_stmt|;
name|size_t
modifier|*
name|__puse_count
init|=
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|_S_mem_blocks
index|[
name|_S_last_request
operator|.
name|_M_where
argument_list|()
index|]
operator|.
name|first
operator|)
operator|-
operator|(
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__num_bitmaps
argument_list|(
name|_S_mem_blocks
index|[
name|_S_last_request
operator|.
name|_M_where
argument_list|()
index|]
argument_list|)
operator|+
literal|1
operator|)
decl_stmt|;
operator|++
operator|(
operator|*
name|__puse_count
operator|)
expr_stmt|;
return|return
name|__ret
return|;
block|}
end_block

begin_comment
comment|/** @brief  Deallocates memory that belongs to a single object of        *  size sizeof(_Tp).        *        *  @detail  Complexity: O(lg(N)), but the worst case is not hit        *  often!  This is because containers usually deallocate memory        *  close to each other and this case is handled in O(1) time by        *  the deallocate function.        */
end_comment

begin_function
name|void
name|_M_deallocate_single_object
parameter_list|(
name|pointer
name|__p
parameter_list|)
function|throw
parameter_list|()
block|{
if|#
directive|if
name|defined
name|__GTHREADS
name|__gnu_cxx
operator|::
name|__scoped_lock
name|__bit_lock
argument_list|(
name|_S_mut
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_Alloc_block
modifier|*
name|__real_p
init|=
name|reinterpret_cast
operator|<
name|_Alloc_block
operator|*
operator|>
operator|(
name|__p
operator|)
decl_stmt|;
typedef|typedef
name|typename
name|_BPVector
operator|::
name|iterator
name|_Iterator
expr_stmt|;
typedef|typedef
name|typename
name|_BPVector
operator|::
name|difference_type
name|_Difference_type
expr_stmt|;
name|_Difference_type
name|__diff
decl_stmt|;
name|long
name|__displacement
decl_stmt|;
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|_S_last_dealloc_index
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Inclusive_between
operator|<
name|_Alloc_block
operator|*
operator|>
call|(
name|__real_p
call|)
argument_list|(
name|_S_mem_blocks
index|[
name|_S_last_dealloc_index
index|]
argument_list|)
condition|)
block|{
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|_S_last_dealloc_index
operator|<=
name|_S_mem_blocks
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Initial Assumption was correct!
name|__diff
operator|=
name|_S_last_dealloc_index
expr_stmt|;
name|__displacement
operator|=
name|__real_p
operator|-
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
expr_stmt|;
block|}
else|else
block|{
name|_Iterator
name|_iter
init|=
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__find_if
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
argument_list|,
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|,
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Inclusive_between
operator|<
name|_Alloc_block
operator|*
operator|>
operator|(
name|__real_p
operator|)
argument_list|)
decl_stmt|;
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|_iter
operator|!=
name|_S_mem_blocks
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|__diff
operator|=
name|_iter
operator|-
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
expr_stmt|;
name|__displacement
operator|=
name|__real_p
operator|-
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
expr_stmt|;
name|_S_last_dealloc_index
operator|=
name|__diff
expr_stmt|;
block|}
comment|// Get the position of the iterator that has been found.
specifier|const
name|size_t
name|__rotate
init|=
operator|(
name|__displacement
operator|%
name|size_t
argument_list|(
name|__detail
operator|::
name|bits_per_block
argument_list|)
operator|)
decl_stmt|;
name|size_t
modifier|*
name|__bitmapC
init|=
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
operator|)
operator|-
literal|1
decl_stmt|;
name|__bitmapC
operator|-=
operator|(
name|__displacement
operator|/
name|size_t
argument_list|(
name|__detail
operator|::
name|bits_per_block
argument_list|)
operator|)
expr_stmt|;
name|__detail
operator|::
name|__bit_free
argument_list|(
name|__bitmapC
argument_list|,
name|__rotate
argument_list|)
expr_stmt|;
name|size_t
modifier|*
name|__puse_count
init|=
name|reinterpret_cast
operator|<
name|size_t
operator|*
operator|>
operator|(
name|_S_mem_blocks
index|[
name|__diff
index|]
operator|.
name|first
operator|)
operator|-
operator|(
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|__num_bitmaps
argument_list|(
name|_S_mem_blocks
index|[
name|__diff
index|]
argument_list|)
operator|+
literal|1
operator|)
decl_stmt|;
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
operator|*
name|__puse_count
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|__puse_count
operator|)
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
operator|*
name|__puse_count
operator|==
literal|0
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|_S_block_size
operator|/=
literal|2
expr_stmt|;
comment|// We can safely remove this block.
comment|// _Block_pair __bp = _S_mem_blocks[__diff];
name|this
operator|->
name|_M_insert
argument_list|(
name|__puse_count
argument_list|)
expr_stmt|;
name|_S_mem_blocks
operator|.
name|erase
argument_list|(
name|_S_mem_blocks
operator|.
name|begin
argument_list|()
operator|+
name|__diff
argument_list|)
expr_stmt|;
comment|// Reset the _S_last_request variable to reflect the
comment|// erased block. We do this to protect future requests
comment|// after the last block has been removed from a particular
comment|// memory Chunk, which in turn has been returned to the
comment|// free list, and hence had been erased from the vector,
comment|// so the size of the vector gets reduced by 1.
if|if
condition|(
operator|(
name|_Difference_type
operator|)
name|_S_last_request
operator|.
name|_M_where
argument_list|()
operator|>=
name|__diff
operator|--
condition|)
name|_S_last_request
operator|.
name|_M_reset
argument_list|(
name|__diff
argument_list|)
expr_stmt|;
comment|// If the Index into the vector of the region of memory
comment|// that might hold the next address that will be passed to
comment|// deallocated may have been invalidated due to the above
comment|// erase procedure being called on the vector, hence we
comment|// try to restore this invariant too.
if|if
condition|(
name|_S_last_dealloc_index
operator|>=
name|_S_mem_blocks
operator|.
name|size
argument_list|()
condition|)
block|{
name|_S_last_dealloc_index
operator|=
operator|(
name|__diff
operator|!=
operator|-
literal|1
condition|?
name|__diff
else|:
literal|0
operator|)
expr_stmt|;
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|_S_last_dealloc_index
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_label
name|public
label|:
end_label

begin_macro
name|bitmap_allocator
argument_list|()
end_macro

begin_macro
name|throw
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|bitmap_allocator
argument_list|(
argument|const bitmap_allocator&
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|bitmap_allocator
argument_list|(
argument|const bitmap_allocator<_Tp1>&
argument_list|)
name|throw
argument_list|()
block|{ }
operator|~
name|bitmap_allocator
argument_list|()
name|throw
argument_list|()
block|{ }
name|pointer
name|allocate
argument_list|(
argument|size_type __n
argument_list|)
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__n
operator|>
name|this
operator|->
name|max_size
argument_list|()
argument_list|,
name|false
argument_list|)
condition|)
name|std
operator|::
name|__throw_bad_alloc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__n
operator|==
literal|1
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|this
operator|->
name|_M_allocate_single_object
argument_list|()
return|;
else|else
block|{
specifier|const
name|size_type
name|__b
init|=
name|__n
operator|*
sizeof|sizeof
argument_list|(
name|value_type
argument_list|)
decl_stmt|;
return|return
name|reinterpret_cast
operator|<
name|pointer
operator|>
operator|(
operator|::
name|operator
name|new
argument_list|(
name|__b
argument_list|)
operator|)
return|;
block|}
end_if

begin_macro
unit|}        pointer
name|allocate
argument_list|(
argument|size_type __n
argument_list|,
argument|typename bitmap_allocator<void>::const_pointer
argument_list|)
end_macro

begin_block
block|{
return|return
name|allocate
argument_list|(
name|__n
argument_list|)
return|;
block|}
end_block

begin_function
name|void
name|deallocate
parameter_list|(
name|pointer
name|__p
parameter_list|,
name|size_type
name|__n
parameter_list|)
function|throw
parameter_list|()
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__p
operator|!=
literal|0
argument_list|,
name|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|__builtin_expect
argument_list|(
name|__n
operator|==
literal|1
argument_list|,
name|true
argument_list|)
condition|)
name|this
operator|->
name|_M_deallocate_single_object
argument_list|(
name|__p
argument_list|)
expr_stmt|;
else|else
operator|::
name|operator
name|delete
argument_list|(
name|__p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|pointer
name|address
argument_list|(
name|reference
name|__r
argument_list|)
decl|const
block|{
return|return
operator|&
name|__r
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|const_pointer
name|address
argument_list|(
name|const_reference
name|__r
argument_list|)
decl|const
block|{
return|return
operator|&
name|__r
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|size_type
name|max_size
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|size_type
argument_list|(
operator|-
literal|1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|value_type
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|construct
parameter_list|(
name|pointer
name|__p
parameter_list|,
name|const_reference
name|__data
parameter_list|)
block|{
operator|::
name|new
argument_list|(
argument|__p
argument_list|)
name|value_type
argument_list|(
name|__data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|destroy
parameter_list|(
name|pointer
name|__p
parameter_list|)
block|{
name|__p
operator|->
expr|~
name|value_type
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|typename
name|_Tp2
operator|>
name|bool
name|operator
operator|==
operator|(
specifier|const
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
operator|&
operator|,
specifier|const
name|bitmap_allocator
operator|<
name|_Tp2
operator|>
operator|&
operator|)
name|throw
argument_list|()
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|typename
name|_Tp2
operator|>
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|bitmap_allocator
operator|<
name|_Tp1
operator|>
operator|&
operator|,
specifier|const
name|bitmap_allocator
operator|<
name|_Tp2
operator|>
operator|&
operator|)
name|throw
argument_list|()
block|{
return|return
name|false
return|;
block|}
end_expr_stmt

begin_comment
comment|// Static member definitions.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_BPVector
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_mem_blocks
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|size_t
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_block_size
operator|=
literal|2
operator|*
name|size_t
argument_list|(
name|__detail
operator|::
name|bits_per_block
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|__gnu_cxx
operator|::
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_BPVector
operator|::
name|size_type
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_last_dealloc_index
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|__gnu_cxx
operator|::
name|__detail
operator|::
name|_Bitmap_counter
operator|<
name|typename
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_Alloc_block
operator|*
operator|>
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_last_request
argument_list|(
name|_S_mem_blocks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
name|__GTHREADS
end_if

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|typename
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|__mutex_type
name|bitmap_allocator
operator|<
name|_Tp
operator|>
operator|::
name|_S_mut
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|_GLIBCXX_END_NAMESPACE
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

