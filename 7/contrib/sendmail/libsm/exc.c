begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: exc.c,v 1.49 2006/12/19 19:28:09 ca Exp $"
argument_list|)
end_macro

begin_comment
comment|/* **  exception handling **  For documentation, see exc.html */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sm/errstring.h>
end_include

begin_include
include|#
directive|include
file|<sm/exc.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_include
include|#
directive|include
file|<sm/varargs.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_decl_stmt
specifier|const
name|char
name|SmExcMagic
index|[]
init|=
literal|"sm_exc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|SmExcTypeMagic
index|[]
init|=
literal|"sm_exc_type"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SM_ETYPE_PRINTF -- printf for exception types. ** **	Parameters: **		exc -- exception. **		stream -- file for output. ** **	Returns: **		none. */
end_comment

begin_comment
comment|/* **  A simple formatted print function that can be used as the print function **  by most exception types.  It prints the printcontext string, interpreting **  occurrences of %0 through %9 as references to the argument vector. **  If exception argument 3 is an int or long, then %3 will print the **  argument in decimal, and %o3 or %x3 will print it in octal or hex. */
end_comment

begin_function
name|void
name|sm_etype_printf
parameter_list|(
name|exc
parameter_list|,
name|stream
parameter_list|)
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
name|SM_FILE_T
modifier|*
name|stream
decl_stmt|;
block|{
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|exc
operator|->
name|exc_type
operator|->
name|etype_argformat
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|char
name|format
decl_stmt|;
for|for
control|(
name|p
operator|=
name|exc
operator|->
name|exc_type
operator|->
name|etype_printcontext
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'%'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|format
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|format
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|size_t
name|i
init|=
operator|*
name|p
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|n
condition|)
block|{
switch|switch
condition|(
name|exc
operator|->
name|exc_type
operator|->
name|etype_argformat
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'r'
case|:
name|s
operator|=
name|exc
operator|->
name|exc_argv
index|[
name|i
index|]
operator|.
name|v_str
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|"(null)"
expr_stmt|;
name|sm_io_fputs
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|format
operator|==
literal|'o'
condition|?
literal|"%o"
else|:
name|format
operator|==
literal|'x'
condition|?
literal|"%x"
else|:
literal|"%d"
argument_list|,
name|exc
operator|->
name|exc_argv
index|[
name|i
index|]
operator|.
name|v_int
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|format
operator|==
literal|'o'
condition|?
literal|"%lo"
else|:
name|format
operator|==
literal|'x'
condition|?
literal|"%lx"
else|:
literal|"%ld"
argument_list|,
name|exc
operator|->
name|exc_argv
index|[
name|i
index|]
operator|.
name|v_long
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
name|sm_exc_write
argument_list|(
name|exc
operator|->
name|exc_argv
index|[
name|i
index|]
operator|.
name|v_exc
argument_list|,
name|stream
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Standard exception types. */
end_comment

begin_comment
comment|/* **  SM_ETYPE_OS_PRINT -- Print OS related exception. ** **	Parameters: **		exc -- exception. **		stream -- file for output. ** **	Returns: **		none. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|sm_etype_os_print
name|__P
argument_list|(
operator|(
name|SM_EXC_T
operator|*
name|exc
operator|,
name|SM_FILE_T
operator|*
name|stream
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sm_etype_os_print
parameter_list|(
name|exc
parameter_list|,
name|stream
parameter_list|)
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
name|SM_FILE_T
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|err
init|=
name|exc
operator|->
name|exc_argv
index|[
literal|0
index|]
operator|.
name|v_int
decl_stmt|;
name|char
modifier|*
name|syscall
init|=
name|exc
operator|->
name|exc_argv
index|[
literal|1
index|]
operator|.
name|v_str
decl_stmt|;
name|char
modifier|*
name|sysargs
init|=
name|exc
operator|->
name|exc_argv
index|[
literal|2
index|]
operator|.
name|v_str
decl_stmt|;
if|if
condition|(
name|sysargs
condition|)
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: %s failed: %s"
argument_list|,
name|sysargs
argument_list|,
name|syscall
argument_list|,
name|sm_errstring
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s failed: %s"
argument_list|,
name|syscall
argument_list|,
name|sm_errstring
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SmEtypeOs represents the failure of a Unix system call. **  The three arguments are: **   int errno (eg, ENOENT) **   char *syscall (eg, "open") **   char *sysargs (eg, NULL or "/etc/mail/sendmail.cf") */
end_comment

begin_decl_stmt
specifier|const
name|SM_EXC_TYPE_T
name|SmEtypeOs
init|=
block|{
name|SmExcTypeMagic
block|,
literal|"E:sm.os"
block|,
literal|"isr"
block|,
name|sm_etype_os_print
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SmEtypeErr is a completely generic error which should only be **  used in applications and test programs.  Libraries should use **  more specific exception codes. */
end_comment

begin_decl_stmt
specifier|const
name|SM_EXC_TYPE_T
name|SmEtypeErr
init|=
block|{
name|SmExcTypeMagic
block|,
literal|"E:sm.err"
block|,
literal|"r"
block|,
name|sm_etype_printf
block|,
literal|"%0"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SM_EXC_VNEW_X -- Construct a new exception object. ** **	Parameters: **		etype -- type of exception. **		ap -- varargs. ** **	Returns: **		pointer to exception object. */
end_comment

begin_comment
comment|/* **  This is an auxiliary function called by sm_exc_new_x and sm_exc_raisenew_x. ** **  If an exception is raised, then to avoid a storage leak, we must: **  (a) Free all storage we have allocated. **  (b) Free all exception arguments in the varargs list. **  Getting this right is tricky. ** **  To see why (b) is required, consider the code fragment **     SM_EXCEPT(exc, "*") **         sm_exc_raisenew_x(&MyEtype, exc); **     SM_END_TRY **  In the normal case, sm_exc_raisenew_x will allocate and raise a new **  exception E that owns exc.  When E is eventually freed, exc is also freed. **  In the exceptional case, sm_exc_raisenew_x must free exc before raising **  an out-of-memory exception so that exc is not leaked. */
end_comment

begin_decl_stmt
specifier|static
name|SM_EXC_T
modifier|*
name|sm_exc_vnew_x
name|__P
argument_list|(
operator|(
specifier|const
name|SM_EXC_TYPE_T
operator|*
operator|,
name|va_list
name|SM_NONVOLATILE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|SM_EXC_T
modifier|*
name|sm_exc_vnew_x
parameter_list|(
name|etype
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|SM_EXC_TYPE_T
modifier|*
name|etype
decl_stmt|;
name|va_list
name|SM_NONVOLATILE
name|ap
decl_stmt|;
block|{
comment|/* 	**  All variables that are modified in the SM_TRY clause and 	**  referenced in the SM_EXCEPT clause must be declared volatile. 	*/
comment|/* NOTE: Type of si, i, and argc *must* match */
name|SM_EXC_T
modifier|*
specifier|volatile
name|exc
init|=
name|NULL
decl_stmt|;
name|int
specifier|volatile
name|si
init|=
literal|0
decl_stmt|;
name|SM_VAL_T
modifier|*
specifier|volatile
name|argv
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|argc
decl_stmt|;
name|SM_REQUIRE_ISA
argument_list|(
name|etype
argument_list|,
name|SmExcTypeMagic
argument_list|)
expr_stmt|;
name|argc
operator|=
name|strlen
argument_list|(
name|etype
operator|->
name|etype_argformat
argument_list|)
expr_stmt|;
name|SM_TRY
block|{
comment|/* 		**  Step 1.  Allocate the exception structure. 		**  On failure, scan the varargs list and free all 		**  exception arguments. 		*/
name|exc
operator|=
name|sm_malloc_x
argument_list|(
sizeof|sizeof
argument_list|(
name|SM_EXC_T
argument_list|)
argument_list|)
expr_stmt|;
name|exc
operator|->
name|sm_magic
operator|=
name|SmExcMagic
expr_stmt|;
name|exc
operator|->
name|exc_refcount
operator|=
literal|1
expr_stmt|;
name|exc
operator|->
name|exc_type
operator|=
name|etype
expr_stmt|;
name|exc
operator|->
name|exc_argv
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  Step 2.  Allocate the argument vector. 		**  On failure, free exc, scan the varargs list and free all 		**  exception arguments.  On success, scan the varargs list, 		**  and copy the arguments into argv. 		*/
name|argv
operator|=
name|sm_malloc_x
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|SM_VAL_T
argument_list|)
argument_list|)
expr_stmt|;
name|exc
operator|->
name|exc_argv
operator|=
name|argv
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|etype
operator|->
name|etype_argformat
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
name|argv
index|[
name|i
index|]
operator|.
name|v_int
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|argv
index|[
name|i
index|]
operator|.
name|v_long
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|argv
index|[
name|i
index|]
operator|.
name|v_exc
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|SM_EXC_T
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|argv
index|[
name|i
index|]
operator|.
name|v_str
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|SM_REQUIRE
argument_list|(
name|etype
operator|->
name|etype_argformat
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|.
name|v_str
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sm_abort
argument_list|(
literal|"sm_exc_vnew_x: bad argformat '%c'"
argument_list|,
name|etype
operator|->
name|etype_argformat
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		**  Step 3.  Scan argv, and allocate space for all 		**  string arguments.  si is the number of elements 		**  of argv that have been processed so far. 		**  On failure, free exc, argv, all the exception arguments 		**  and all of the strings that have been copied. 		*/
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|argc
condition|;
operator|++
name|si
control|)
block|{
switch|switch
condition|(
name|etype
operator|->
name|etype_argformat
index|[
name|si
index|]
condition|)
block|{
case|case
literal|'s'
case|:
block|{
name|char
modifier|*
name|str
init|=
name|argv
index|[
name|si
index|]
operator|.
name|v_str
decl_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|argv
index|[
name|si
index|]
operator|.
name|v_str
operator|=
name|sm_strdup_x
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
block|{
name|char
modifier|*
name|fmt
init|=
name|argv
index|[
name|si
index|]
operator|.
name|v_str
decl_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
name|argv
index|[
name|si
index|]
operator|.
name|v_str
operator|=
name|sm_vstringf_x
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|SM_EXCEPT
argument_list|(
argument|e
argument_list|,
literal|"*"
argument_list|)
block|{
if|if
condition|(
name|exc
operator|==
name|NULL
operator|||
name|argv
operator|==
name|NULL
condition|)
block|{
comment|/* 			**  Failure in step 1 or step 2. 			**  Scan ap and free all exception arguments. 			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|etype
operator|->
name|etype_argformat
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
operator|(
name|void
operator|)
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|(
name|void
operator|)
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|sm_exc_free
argument_list|(
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|SM_EXC_T
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'r'
case|:
operator|(
name|void
operator|)
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* 			**  Failure in step 3.  Scan argv and free 			**  all exception arguments and all string 			**  arguments that have been duplicated. 			**  Then free argv. 			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|etype
operator|->
name|etype_argformat
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|sm_exc_free
argument_list|(
name|argv
index|[
name|i
index|]
operator|.
name|v_exc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'r'
case|:
if|if
condition|(
name|i
operator|<
name|si
condition|)
name|sm_free
argument_list|(
name|argv
index|[
name|i
index|]
operator|.
name|v_str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sm_free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
name|sm_free
argument_list|(
name|exc
argument_list|)
expr_stmt|;
name|sm_exc_raise_x
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|SM_END_TRY
return|return
name|exc
return|;
block|}
end_function

begin_comment
comment|/* **  SM_EXC_NEW_X -- Construct a new exception object. ** **	Parameters: **		etype -- type of exception. **		... -- varargs. ** **	Returns: **		pointer to exception object. */
end_comment

begin_function
name|SM_EXC_T
modifier|*
if|#
directive|if
name|SM_VA_STD
name|sm_exc_new_x
parameter_list|(
specifier|const
name|SM_EXC_TYPE_T
modifier|*
name|etype
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* SM_VA_STD */
function|sm_exc_new_x
parameter_list|(
name|etype
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|SM_EXC_TYPE_T
modifier|*
name|etype
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* SM_VA_STD */
block|{
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
name|SM_VA_LOCAL_DECL
name|SM_VA_START
argument_list|(
name|ap
argument_list|,
name|etype
argument_list|)
decl_stmt|;
name|exc
operator|=
name|sm_exc_vnew_x
argument_list|(
name|etype
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|exc
return|;
block|}
end_function

begin_comment
comment|/* **  SM_EXC_FREE -- Destroy a reference to an exception object. ** **	Parameters: **		exc -- exception object. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_exc_free
parameter_list|(
name|exc
parameter_list|)
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
block|{
if|if
condition|(
name|exc
operator|==
name|NULL
condition|)
return|return;
name|SM_REQUIRE
argument_list|(
name|exc
operator|->
name|sm_magic
operator|==
name|SmExcMagic
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|->
name|exc_refcount
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|--
name|exc
operator|->
name|exc_refcount
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|exc
operator|->
name|exc_type
operator|->
name|etype_argformat
index|[
name|i
index|]
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'r'
case|:
name|sm_free
argument_list|(
name|exc
operator|->
name|exc_argv
index|[
name|i
index|]
operator|.
name|v_str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|sm_exc_free
argument_list|(
name|exc
operator|->
name|exc_argv
index|[
name|i
index|]
operator|.
name|v_exc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|exc
operator|->
name|sm_magic
operator|=
name|NULL
expr_stmt|;
name|sm_free
argument_list|(
name|exc
operator|->
name|exc_argv
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|exc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  SM_EXC_MATCH -- Match exception category against a glob pattern. ** **	Parameters: **		exc -- exception. **		pattern -- glob pattern. ** **	Returns: **		true iff match. */
end_comment

begin_function
name|bool
name|sm_exc_match
parameter_list|(
name|exc
parameter_list|,
name|pattern
parameter_list|)
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|exc
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|SM_REQUIRE
argument_list|(
name|exc
operator|->
name|sm_magic
operator|==
name|SmExcMagic
argument_list|)
expr_stmt|;
return|return
name|sm_match
argument_list|(
name|exc
operator|->
name|exc_type
operator|->
name|etype_category
argument_list|,
name|pattern
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SM_EXC_WRITE -- Write exception message to a stream (wo trailing newline). ** **	Parameters: **		exc -- exception. **		stream -- file for output. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_exc_write
parameter_list|(
name|exc
parameter_list|,
name|stream
parameter_list|)
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
name|SM_FILE_T
modifier|*
name|stream
decl_stmt|;
block|{
name|SM_REQUIRE_ISA
argument_list|(
name|exc
argument_list|,
name|SmExcMagic
argument_list|)
expr_stmt|;
name|exc
operator|->
name|exc_type
operator|->
name|etype_print
argument_list|(
name|exc
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_EXC_PRINT -- Print exception message to a stream (with trailing newline). ** **	Parameters: **		exc -- exception. **		stream -- file for output. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_exc_print
parameter_list|(
name|exc
parameter_list|,
name|stream
parameter_list|)
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
name|SM_FILE_T
modifier|*
name|stream
decl_stmt|;
block|{
name|SM_REQUIRE_ISA
argument_list|(
name|exc
argument_list|,
name|SmExcMagic
argument_list|)
expr_stmt|;
name|exc
operator|->
name|exc_type
operator|->
name|etype_print
argument_list|(
name|exc
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|SM_EXC_HANDLER_T
modifier|*
name|SmExcHandler
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SM_EXC_DEFAULT_HANDLER_T
name|SmExcDefaultHandler
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SM_EXC_NEWTHREAD -- Initialize exception handling for new process/thread. ** **	Parameters: **		h -- default exception handler. ** **	Returns: **		none. */
end_comment

begin_comment
comment|/* **  Initialize a new process or a new thread by clearing the **  exception handler stack and optionally setting a default **  exception handler function.  Call this at the beginning of main, **  or in a new process after calling fork, or in a new thread. ** **  This function is a luxury, not a necessity. **  If h != NULL then you can get the same effect by **  wrapping the body of main, or the body of a forked child **  or a new thread in SM_TRY ... SM_EXCEPT(e,"*") h(e); SM_END_TRY. */
end_comment

begin_function
name|void
name|sm_exc_newthread
parameter_list|(
name|h
parameter_list|)
name|SM_EXC_DEFAULT_HANDLER_T
name|h
decl_stmt|;
block|{
name|SmExcHandler
operator|=
name|NULL
expr_stmt|;
name|SmExcDefaultHandler
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_EXC_RAISE_X -- Raise an exception. ** **	Parameters: **		exc -- exception. ** **	Returns: **		doesn't. */
end_comment

begin_function
name|void
name|SM_DEAD_D
name|sm_exc_raise_x
parameter_list|(
name|exc
parameter_list|)
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
block|{
name|SM_REQUIRE_ISA
argument_list|(
name|exc
argument_list|,
name|SmExcMagic
argument_list|)
expr_stmt|;
if|if
condition|(
name|SmExcHandler
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SmExcDefaultHandler
operator|!=
name|NULL
condition|)
block|{
name|SM_EXC_DEFAULT_HANDLER_T
name|h
decl_stmt|;
comment|/* 			**  If defined, the default handler is expected 			**  to terminate the current thread of execution 			**  using exit() or pthread_exit(). 			**  If it instead returns normally, then we fall 			**  through to the default case below.  If it 			**  raises an exception, then sm_exc_raise_x is 			**  re-entered and, because we set SmExcDefaultHandler 			**  to NULL before invoking h, we will again 			**  end up in the default case below. 			*/
name|h
operator|=
name|SmExcDefaultHandler
expr_stmt|;
name|SmExcDefaultHandler
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|h
call|)
argument_list|(
name|exc
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  No exception handler, so print the error and exit. 		**  To override this behaviour on a program wide basis, 		**  call sm_exc_newthread or put an exception handler in main(). 		** 		**  XXX TODO: map the exception category to an exit code 		**  XXX from<sysexits.h>. 		*/
name|sm_exc_print
argument_list|(
name|exc
argument_list|,
name|smioerr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SmExcHandler
operator|->
name|eh_value
operator|==
name|NULL
condition|)
name|SmExcHandler
operator|->
name|eh_value
operator|=
name|exc
expr_stmt|;
else|else
name|sm_exc_free
argument_list|(
name|exc
argument_list|)
expr_stmt|;
name|sm_longjmp_nosig
argument_list|(
name|SmExcHandler
operator|->
name|eh_context
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_EXC_RAISENEW_X -- shorthand for sm_exc_raise_x(sm_exc_new_x(...)) ** **	Parameters: **		etype -- type of exception. **		ap -- varargs. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|SM_DEAD_D
if|#
directive|if
name|SM_VA_STD
name|sm_exc_raisenew_x
parameter_list|(
specifier|const
name|SM_EXC_TYPE_T
modifier|*
name|etype
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|sm_exc_raisenew_x
parameter_list|(
name|etype
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|SM_EXC_TYPE_T
modifier|*
name|etype
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|SM_EXC_T
modifier|*
name|exc
decl_stmt|;
name|SM_VA_LOCAL_DECL
name|SM_VA_START
argument_list|(
name|ap
argument_list|,
name|etype
argument_list|)
decl_stmt|;
name|exc
operator|=
name|sm_exc_vnew_x
argument_list|(
name|etype
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|sm_exc_raise_x
argument_list|(
name|exc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

