begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Sendmail, Inc. and its suppliers.  *      All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_comment
comment|/* **  Compile this program using a command line similar to: **	cc -O -L../OBJ/libsm -o b-strl b-strl.c -lsm **  where "OBJ" is the name of the object directory for the platform **  you are compiling on. **  Then run the program: **	./b-strl **  and read the output for results and how to interpret the results. */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: b-strl.c,v 1.25 2005/06/14 23:07:20 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sm/time.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_define
define|#
directive|define
name|SRC_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|toseconds
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x.tv_sec - y.tv_sec)
end_define

begin_define
define|#
directive|define
name|LOOPS
value|4000000L
end_define

begin_comment
comment|/* initial number of loops */
end_comment

begin_define
define|#
directive|define
name|MAXTIME
value|30L
end_define

begin_comment
comment|/* "maximum" time to run single test */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|perror
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|purpose
parameter_list|()
block|{
name|printf
argument_list|(
literal|"This program benchmarks the performance differences between\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"strlcpy() and sm_strlcpy(), and strlcat() and sm_strlcat().\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"These tests may take several minutes to complete.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|SM_CONF_STRL
name|printf
argument_list|(
literal|"The configuration indicates the system needs the libsm\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"versions of strlcpy(3) and strlcat(3). Thus, performing\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"these tests will not be of much use.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"If your OS has strlcpy(3) and strlcat(3) then set the macro\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SM_CONF_STRL to 1 in your site.config.m4 file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(located in ../devtools/Site) and recompile this program.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SM_CONF_STRL */
name|int
name|ch
decl_stmt|;
name|long
name|a
decl_stmt|;
name|bool
name|doit
init|=
name|false
decl_stmt|;
name|long
name|loops
init|=
name|LOOPS
decl_stmt|;
name|long
name|one
decl_stmt|,
name|two
decl_stmt|;
name|struct
name|timeval
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|char
name|dest
index|[
name|SRC_SIZE
index|]
decl_stmt|,
name|source
index|[
name|SRC_SIZE
index|]
decl_stmt|;
define|#
directive|define
name|OPTIONS
value|"d"
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|doit
operator|=
name|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|doit
condition|)
block|{
name|purpose
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"If you want to run it, specify -d as option.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	**  Let's place a small string at the head of dest for 	**  catenation to happen (it'll be ignored for the copy). 	*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|dest
argument_list|,
literal|"a small string at the start! "
argument_list|,
name|SRC_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	**  Let's place a larger string into source for the catenation and 	**  the copy. 	*/
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|source
argument_list|,
literal|" This is the longer string that will be used for catenation and copying for the the performace testing. The longer the string being catenated or copied the greater the difference in measureable performance\n"
argument_list|,
name|SRC_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Run-time comments to the user */
name|purpose
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Test 1: strlcat() versus sm_strlcat()\n"
argument_list|)
expr_stmt|;
name|redo_cat
label|:
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|loops
condition|;
name|a
operator|++
control|)
name|strlcat
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|SRC_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tstrlcat() result: %ld seconds\n"
argument_list|,
name|one
operator|=
name|toseconds
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|loops
condition|;
name|a
operator|++
control|)
name|sm_strlcat
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|SRC_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsm_strlcat() result: %ld seconds\n"
argument_list|,
name|two
operator|=
name|toseconds
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|-
name|two
operator|>=
operator|-
literal|2
operator|&&
name|one
operator|-
name|two
operator|<=
literal|2
condition|)
block|{
name|loops
operator|+=
name|loops
expr_stmt|;
if|if
condition|(
name|loops
operator|<
literal|0L
operator|||
name|one
operator|>
name|MAXTIME
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t** results too close: no decision\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\t\t** results too close redoing test %ld times **\n"
argument_list|,
name|loops
argument_list|)
expr_stmt|;
goto|goto
name|redo_cat
goto|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Test 2: strlcpy() versus sm_strlpy()\n"
argument_list|)
expr_stmt|;
name|loops
operator|=
name|LOOPS
expr_stmt|;
name|redo_cpy
label|:
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|loops
condition|;
name|a
operator|++
control|)
name|strlcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|SRC_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tstrlcpy() result: %ld seconds\n"
argument_list|,
name|one
operator|=
name|toseconds
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|loops
condition|;
name|a
operator|++
control|)
name|sm_strlcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
name|SRC_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsm_strlcpy() result: %ld seconds\n"
argument_list|,
name|two
operator|=
name|toseconds
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|-
name|two
operator|>=
operator|-
literal|2
operator|&&
name|one
operator|-
name|two
operator|<=
literal|2
condition|)
block|{
name|loops
operator|+=
name|loops
expr_stmt|;
if|if
condition|(
name|loops
operator|<
literal|0L
operator|||
name|one
operator|>
name|MAXTIME
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t** results too close: no decision\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\t\t** results too close redoing test %ld times **\n"
argument_list|,
name|loops
argument_list|)
expr_stmt|;
goto|goto
name|redo_cpy
goto|;
block|}
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Interpreting the results:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tFor differences larger than 2 seconds, the lower value is\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbetter and that function should be used for performance\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\treasons.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"This program will re-run the tests when the difference is\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"less than 2 seconds.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The result will vary depending on the compiler optimization\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"level used. Compiling the sendmail libsm library with a\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"better optimization level can change the results.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SM_CONF_STRL  */
return|return
literal|0
return|;
block|}
end_function

end_unit

