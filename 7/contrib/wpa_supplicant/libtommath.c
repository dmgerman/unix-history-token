begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Minimal code for RSA support from LibTomMath 0.3.9  * http://math.libtomcrypt.com/  * http://math.libtomcrypt.com/files/ltm-0.39.tar.bz2  * This library was released in public domain by Tom St Denis.  *  * The combination in this file is not using many of the optimized algorithms  * (e.g., Montgomery reduction) and is considerable slower than the LibTomMath  * with its default of SC_RSA_1 settins. The main purpose of having this  * version here is to make it easier to build bignum.c wrapper without having  * to install and build an external library. However, it is likely worth the  * effort to use the full library with SC_RSA_1 instead of this minimized copy.  * Including the optimized algorithms may increase the size requirements by  * 15 kB or so (measured with x86 build).  *  * If CONFIG_INTERNAL_LIBTOMMATH is defined, bignum.c includes this  * libtommath.c file instead of using the external LibTomMath library.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BN_MP_INVMOD_C
end_define

begin_define
define|#
directive|define
name|BN_S_MP_EXPTMOD_C
end_define

begin_comment
comment|/* Note: #undef in tommath_superclass.h; this would 			   * require BN_MP_EXPTMOD_FAST_C instead */
end_comment

begin_define
define|#
directive|define
name|BN_S_MP_MUL_DIGS_C
end_define

begin_define
define|#
directive|define
name|BN_MP_INVMOD_SLOW_C
end_define

begin_define
define|#
directive|define
name|BN_S_MP_SQR_C
end_define

begin_define
define|#
directive|define
name|BN_S_MP_MUL_HIGH_DIGS_C
end_define

begin_comment
comment|/* Note: #undef in tommath_superclass.h; this 				 * would require other than mp_reduce */
end_comment

begin_comment
comment|/* from tommath.h */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)<(y)?(x):(y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)>(y)?(x):(y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OPT_CAST
parameter_list|(
name|x
parameter_list|)
end_define

begin_typedef
typedef|typedef
name|unsigned
name|long
name|mp_digit
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u64
name|mp_word
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIGIT_BIT
value|28
end_define

begin_define
define|#
directive|define
name|MP_28BIT
end_define

begin_define
define|#
directive|define
name|XMALLOC
value|os_malloc
end_define

begin_define
define|#
directive|define
name|XFREE
value|os_free
end_define

begin_define
define|#
directive|define
name|XREALLOC
value|os_realloc
end_define

begin_define
define|#
directive|define
name|MP_MASK
value|((((mp_digit)1)<<((mp_digit)DIGIT_BIT))-((mp_digit)1))
end_define

begin_define
define|#
directive|define
name|MP_LT
value|-1
end_define

begin_comment
comment|/* less than */
end_comment

begin_define
define|#
directive|define
name|MP_EQ
value|0
end_define

begin_comment
comment|/* equal to */
end_comment

begin_define
define|#
directive|define
name|MP_GT
value|1
end_define

begin_comment
comment|/* greater than */
end_comment

begin_define
define|#
directive|define
name|MP_ZPOS
value|0
end_define

begin_comment
comment|/* positive integer */
end_comment

begin_define
define|#
directive|define
name|MP_NEG
value|1
end_define

begin_comment
comment|/* negative */
end_comment

begin_define
define|#
directive|define
name|MP_OKAY
value|0
end_define

begin_comment
comment|/* ok result */
end_comment

begin_define
define|#
directive|define
name|MP_MEM
value|-2
end_define

begin_comment
comment|/* out of mem */
end_comment

begin_define
define|#
directive|define
name|MP_VAL
value|-3
end_define

begin_comment
comment|/* invalid input */
end_comment

begin_define
define|#
directive|define
name|MP_YES
value|1
end_define

begin_comment
comment|/* yes response */
end_comment

begin_define
define|#
directive|define
name|MP_NO
value|0
end_define

begin_comment
comment|/* no response */
end_comment

begin_typedef
typedef|typedef
name|int
name|mp_err
typedef|;
end_typedef

begin_comment
comment|/* define this to use lower memory usage routines (exptmods mostly) */
end_comment

begin_define
define|#
directive|define
name|MP_LOW_MEM
end_define

begin_comment
comment|/* default precision */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MP_PREC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|MP_LOW_MEM
end_ifndef

begin_define
define|#
directive|define
name|MP_PREC
value|32
end_define

begin_comment
comment|/* default digits of precision */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MP_PREC
value|8
end_define

begin_comment
comment|/* default digits of precision */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* size of comba arrays, should be at least 2 * 2**(BITS_PER_WORD - BITS_PER_DIGIT*2) */
end_comment

begin_define
define|#
directive|define
name|MP_WARRAY
value|(1<< (sizeof(mp_word) * CHAR_BIT - 2 * DIGIT_BIT + 1))
end_define

begin_comment
comment|/* the infamous mp_int structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|used
decl_stmt|,
name|alloc
decl_stmt|,
name|sign
decl_stmt|;
name|mp_digit
modifier|*
name|dp
decl_stmt|;
block|}
name|mp_int
typedef|;
end_typedef

begin_comment
comment|/* ---> Basic Manipulations<--- */
end_comment

begin_define
define|#
directive|define
name|mp_iszero
parameter_list|(
name|a
parameter_list|)
value|(((a)->used == 0) ? MP_YES : MP_NO)
end_define

begin_define
define|#
directive|define
name|mp_iseven
parameter_list|(
name|a
parameter_list|)
value|(((a)->used> 0&& (((a)->dp[0]& 1) == 0)) ? MP_YES : MP_NO)
end_define

begin_define
define|#
directive|define
name|mp_isodd
parameter_list|(
name|a
parameter_list|)
value|(((a)->used> 0&& (((a)->dp[0]& 1) == 1)) ? MP_YES : MP_NO)
end_define

begin_comment
comment|/* prototypes for copied functions */
end_comment

begin_define
define|#
directive|define
name|s_mp_mul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|s_mp_mul_digs(a, b, c, (a)->used + (b)->used + 1)
end_define

begin_function_decl
specifier|static
name|int
name|s_mp_exptmod
parameter_list|(
name|mp_int
modifier|*
name|G
parameter_list|,
name|mp_int
modifier|*
name|X
parameter_list|,
name|mp_int
modifier|*
name|P
parameter_list|,
name|mp_int
modifier|*
name|Y
parameter_list|,
name|int
name|redmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s_mp_mul_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s_mp_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s_mp_mul_high_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fast_s_mp_mul_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_init_multi
parameter_list|(
name|mp_int
modifier|*
name|mp
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_clear_multi
parameter_list|(
name|mp_int
modifier|*
name|mp
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_lshd
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_set
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_clamp
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_exch
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_rshd
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_zero
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_mod_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_div_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_init_copy
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_mul_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_div_2
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_copy
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_count_bits
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_div
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_mod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_grow
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_cmp_mag
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_invmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_abs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_invmod_slow
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_reduce_2k_l
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|n
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_reduce_2k_setup_l
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_2expt
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_reduce_setup
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_reduce
parameter_list|(
name|mp_int
modifier|*
name|x
parameter_list|,
name|mp_int
modifier|*
name|m
parameter_list|,
name|mp_int
modifier|*
name|mu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mp_init_size
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* functions from bn_<func name>.c */
end_comment

begin_comment
comment|/* reverse an array, used for radix code */
end_comment

begin_function
specifier|static
name|void
name|bn_reverse
parameter_list|(
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|unsigned
name|char
name|t
decl_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
name|iy
operator|=
name|len
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ix
operator|<
name|iy
condition|)
block|{
name|t
operator|=
name|s
index|[
name|ix
index|]
expr_stmt|;
name|s
index|[
name|ix
index|]
operator|=
name|s
index|[
name|iy
index|]
expr_stmt|;
name|s
index|[
name|iy
index|]
operator|=
name|t
expr_stmt|;
operator|++
name|ix
expr_stmt|;
operator|--
name|iy
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* low level addition, based on HAC pp.594, Algorithm 14.7 */
end_comment

begin_function
specifier|static
name|int
name|s_mp_add
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|mp_int
modifier|*
name|x
decl_stmt|;
name|int
name|olduse
decl_stmt|,
name|res
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* find sizes, we let |a|<= |b| which means we have to sort    * them.  "x" will point to the input with the most digits    */
if|if
condition|(
name|a
operator|->
name|used
operator|>
name|b
operator|->
name|used
condition|)
block|{
name|min
operator|=
name|b
operator|->
name|used
expr_stmt|;
name|max
operator|=
name|a
operator|->
name|used
expr_stmt|;
name|x
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|a
operator|->
name|used
expr_stmt|;
name|max
operator|=
name|b
operator|->
name|used
expr_stmt|;
name|x
operator|=
name|b
expr_stmt|;
block|}
comment|/* init result */
if|if
condition|(
name|c
operator|->
name|alloc
operator|<
name|max
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|c
argument_list|,
name|max
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
comment|/* get old used digit count and set new one */
name|olduse
operator|=
name|c
operator|->
name|used
expr_stmt|;
name|c
operator|->
name|used
operator|=
name|max
operator|+
literal|1
expr_stmt|;
block|{
specifier|register
name|mp_digit
name|u
decl_stmt|,
modifier|*
name|tmpa
decl_stmt|,
modifier|*
name|tmpb
decl_stmt|,
modifier|*
name|tmpc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* alias for digit pointers */
comment|/* first input */
name|tmpa
operator|=
name|a
operator|->
name|dp
expr_stmt|;
comment|/* second input */
name|tmpb
operator|=
name|b
operator|->
name|dp
expr_stmt|;
comment|/* destination */
name|tmpc
operator|=
name|c
operator|->
name|dp
expr_stmt|;
comment|/* zero the carry */
name|u
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
condition|;
name|i
operator|++
control|)
block|{
comment|/* Compute the sum at one digit, T[i] = A[i] + B[i] + U */
operator|*
name|tmpc
operator|=
operator|*
name|tmpa
operator|++
operator|+
operator|*
name|tmpb
operator|++
operator|+
name|u
expr_stmt|;
comment|/* U = carry bit of T[i] */
name|u
operator|=
operator|*
name|tmpc
operator|>>
operator|(
operator|(
name|mp_digit
operator|)
name|DIGIT_BIT
operator|)
expr_stmt|;
comment|/* take away carry bit from T[i] */
operator|*
name|tmpc
operator|++
operator|&=
name|MP_MASK
expr_stmt|;
block|}
comment|/* now copy higher words if any, that is in A+B       * if A or B has more digits add those in       */
if|if
condition|(
name|min
operator|!=
name|max
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
comment|/* T[i] = X[i] + U */
operator|*
name|tmpc
operator|=
name|x
operator|->
name|dp
index|[
name|i
index|]
operator|+
name|u
expr_stmt|;
comment|/* U = carry bit of T[i] */
name|u
operator|=
operator|*
name|tmpc
operator|>>
operator|(
operator|(
name|mp_digit
operator|)
name|DIGIT_BIT
operator|)
expr_stmt|;
comment|/* take away carry bit from T[i] */
operator|*
name|tmpc
operator|++
operator|&=
name|MP_MASK
expr_stmt|;
block|}
block|}
comment|/* add carry */
operator|*
name|tmpc
operator|++
operator|=
name|u
expr_stmt|;
comment|/* clear digits above oldused */
for|for
control|(
name|i
operator|=
name|c
operator|->
name|used
init|;
name|i
operator|<
name|olduse
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|tmpc
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mp_clamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* low level subtraction (assumes |a|> |b|), HAC pp.595 Algorithm 14.9 */
end_comment

begin_function
specifier|static
name|int
name|s_mp_sub
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|olduse
decl_stmt|,
name|res
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* find sizes */
name|min
operator|=
name|b
operator|->
name|used
expr_stmt|;
name|max
operator|=
name|a
operator|->
name|used
expr_stmt|;
comment|/* init result */
if|if
condition|(
name|c
operator|->
name|alloc
operator|<
name|max
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|c
argument_list|,
name|max
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
name|olduse
operator|=
name|c
operator|->
name|used
expr_stmt|;
name|c
operator|->
name|used
operator|=
name|max
expr_stmt|;
block|{
specifier|register
name|mp_digit
name|u
decl_stmt|,
modifier|*
name|tmpa
decl_stmt|,
modifier|*
name|tmpb
decl_stmt|,
modifier|*
name|tmpc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* alias for digit pointers */
name|tmpa
operator|=
name|a
operator|->
name|dp
expr_stmt|;
name|tmpb
operator|=
name|b
operator|->
name|dp
expr_stmt|;
name|tmpc
operator|=
name|c
operator|->
name|dp
expr_stmt|;
comment|/* set carry to zero */
name|u
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|min
condition|;
name|i
operator|++
control|)
block|{
comment|/* T[i] = A[i] - B[i] - U */
operator|*
name|tmpc
operator|=
operator|*
name|tmpa
operator|++
operator|-
operator|*
name|tmpb
operator|++
operator|-
name|u
expr_stmt|;
comment|/* U = carry bit of T[i]        * Note this saves performing an AND operation since        * if a carry does occur it will propagate all the way to the        * MSB.  As a result a single shift is enough to get the carry        */
name|u
operator|=
operator|*
name|tmpc
operator|>>
operator|(
call|(
name|mp_digit
call|)
argument_list|(
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|mp_digit
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
comment|/* Clear carry from T[i] */
operator|*
name|tmpc
operator|++
operator|&=
name|MP_MASK
expr_stmt|;
block|}
comment|/* now copy higher words if any, e.g. if A has more digits than B  */
for|for
control|(
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
comment|/* T[i] = A[i] - U */
operator|*
name|tmpc
operator|=
operator|*
name|tmpa
operator|++
operator|-
name|u
expr_stmt|;
comment|/* U = carry bit of T[i] */
name|u
operator|=
operator|*
name|tmpc
operator|>>
operator|(
call|(
name|mp_digit
call|)
argument_list|(
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|mp_digit
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
comment|/* Clear carry from T[i] */
operator|*
name|tmpc
operator|++
operator|&=
name|MP_MASK
expr_stmt|;
block|}
comment|/* clear digits above used (since we may not have grown result above) */
for|for
control|(
name|i
operator|=
name|c
operator|->
name|used
init|;
name|i
operator|<
name|olduse
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|tmpc
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mp_clamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* init a new mp_int */
end_comment

begin_function
specifier|static
name|int
name|mp_init
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* allocate memory required and clear it */
name|a
operator|->
name|dp
operator|=
name|OPT_CAST
argument_list|(
argument|mp_digit
argument_list|)
name|XMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|mp_digit
argument_list|)
operator|*
name|MP_PREC
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|dp
operator|==
name|NULL
condition|)
block|{
return|return
name|MP_MEM
return|;
block|}
comment|/* set the digits to zero */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_PREC
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|->
name|dp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* set the used to zero, allocated digits to the default precision    * and sign to positive */
name|a
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|alloc
operator|=
name|MP_PREC
expr_stmt|;
name|a
operator|->
name|sign
operator|=
name|MP_ZPOS
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* clear one (frees)  */
end_comment

begin_function
specifier|static
name|void
name|mp_clear
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* only do anything if a hasn't been freed previously */
if|if
condition|(
name|a
operator|->
name|dp
operator|!=
name|NULL
condition|)
block|{
comment|/* first zero the digits */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|used
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|->
name|dp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* free ram */
name|XFREE
argument_list|(
name|a
operator|->
name|dp
argument_list|)
expr_stmt|;
comment|/* reset members to make debugging easier */
name|a
operator|->
name|dp
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|alloc
operator|=
name|a
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|sign
operator|=
name|MP_ZPOS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* high level addition (handles signs) */
end_comment

begin_function
specifier|static
name|int
name|mp_add
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|sa
decl_stmt|,
name|sb
decl_stmt|,
name|res
decl_stmt|;
comment|/* get sign of both inputs */
name|sa
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|sb
operator|=
name|b
operator|->
name|sign
expr_stmt|;
comment|/* handle two cases, not four */
if|if
condition|(
name|sa
operator|==
name|sb
condition|)
block|{
comment|/* both positive or both negative */
comment|/* add their magnitudes, copy the sign */
name|c
operator|->
name|sign
operator|=
name|sa
expr_stmt|;
name|res
operator|=
name|s_mp_add
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* one positive, the other negative */
comment|/* subtract the one with the greater magnitude from */
comment|/* the one of the lesser magnitude.  The result gets */
comment|/* the sign of the one with the greater magnitude. */
if|if
condition|(
name|mp_cmp_mag
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
name|MP_LT
condition|)
block|{
name|c
operator|->
name|sign
operator|=
name|sb
expr_stmt|;
name|res
operator|=
name|s_mp_sub
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|sign
operator|=
name|sa
expr_stmt|;
name|res
operator|=
name|s_mp_sub
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* high level subtraction (handles signs) */
end_comment

begin_function
specifier|static
name|int
name|mp_sub
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|sa
decl_stmt|,
name|sb
decl_stmt|,
name|res
decl_stmt|;
name|sa
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|sb
operator|=
name|b
operator|->
name|sign
expr_stmt|;
if|if
condition|(
name|sa
operator|!=
name|sb
condition|)
block|{
comment|/* subtract a negative from a positive, OR */
comment|/* subtract a positive from a negative. */
comment|/* In either case, ADD their magnitudes, */
comment|/* and use the sign of the first number. */
name|c
operator|->
name|sign
operator|=
name|sa
expr_stmt|;
name|res
operator|=
name|s_mp_add
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* subtract a positive from a positive, OR */
comment|/* subtract a negative from a negative. */
comment|/* First, take the difference between their */
comment|/* magnitudes, then... */
if|if
condition|(
name|mp_cmp_mag
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|!=
name|MP_LT
condition|)
block|{
comment|/* Copy the sign from the first */
name|c
operator|->
name|sign
operator|=
name|sa
expr_stmt|;
comment|/* The first has a larger or equal magnitude */
name|res
operator|=
name|s_mp_sub
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The result has the *opposite* sign from */
comment|/* the first number. */
name|c
operator|->
name|sign
operator|=
operator|(
name|sa
operator|==
name|MP_ZPOS
operator|)
condition|?
name|MP_NEG
else|:
name|MP_ZPOS
expr_stmt|;
comment|/* The second has a larger magnitude */
name|res
operator|=
name|s_mp_sub
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* high level multiplication (handles sign) */
end_comment

begin_function
specifier|static
name|int
name|mp_mul
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|res
decl_stmt|,
name|neg
decl_stmt|;
name|neg
operator|=
operator|(
name|a
operator|->
name|sign
operator|==
name|b
operator|->
name|sign
operator|)
condition|?
name|MP_ZPOS
else|:
name|MP_NEG
expr_stmt|;
comment|/* use Toom-Cook? */
ifdef|#
directive|ifdef
name|BN_MP_TOOM_MUL_C
if|if
condition|(
name|MIN
argument_list|(
name|a
operator|->
name|used
argument_list|,
name|b
operator|->
name|used
argument_list|)
operator|>=
name|TOOM_MUL_CUTOFF
condition|)
block|{
name|res
operator|=
name|mp_toom_mul
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_MP_KARATSUBA_MUL_C
comment|/* use Karatsuba? */
if|if
condition|(
name|MIN
argument_list|(
name|a
operator|->
name|used
argument_list|,
name|b
operator|->
name|used
argument_list|)
operator|>=
name|KARATSUBA_MUL_CUTOFF
condition|)
block|{
name|res
operator|=
name|mp_karatsuba_mul
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* can we use the fast multiplier?      *      * The fast multiplier can be used if the output will       * have less than MP_WARRAY digits and the number of       * digits won't affect carry propagation      */
ifdef|#
directive|ifdef
name|BN_FAST_S_MP_MUL_DIGS_C
name|int
name|digs
init|=
name|a
operator|->
name|used
operator|+
name|b
operator|->
name|used
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|digs
operator|<
name|MP_WARRAY
operator|)
operator|&&
name|MIN
argument_list|(
name|a
operator|->
name|used
argument_list|,
name|b
operator|->
name|used
argument_list|)
operator|<=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|mp_word
argument_list|)
operator|)
operator|-
operator|(
literal|2
operator|*
name|DIGIT_BIT
operator|)
operator|)
operator|)
condition|)
block|{
name|res
operator|=
name|fast_s_mp_mul_digs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|digs
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_S_MP_MUL_DIGS_C
name|res
operator|=
name|s_mp_mul
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* uses s_mp_mul_digs */
else|#
directive|else
error|#
directive|error
error|mp_mul could fail
name|res
operator|=
name|MP_VAL
expr_stmt|;
endif|#
directive|endif
block|}
name|c
operator|->
name|sign
operator|=
operator|(
name|c
operator|->
name|used
operator|>
literal|0
operator|)
condition|?
name|neg
else|:
name|MP_ZPOS
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* d = a * b (mod c) */
end_comment

begin_function
specifier|static
name|int
name|mp_mulmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|mp_int
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init
argument_list|(
operator|&
name|t
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_mul
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
name|res
operator|=
name|mp_mod
argument_list|(
operator|&
name|t
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* c = a mod b, 0<= c< b */
end_comment

begin_function
specifier|static
name|int
name|mp_mod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|mp_int
name|t
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init
argument_list|(
operator|&
name|t
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|NULL
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
if|if
condition|(
name|t
operator|.
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
name|res
operator|=
name|mp_add
argument_list|(
name|b
argument_list|,
operator|&
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|MP_OKAY
expr_stmt|;
name|mp_exch
argument_list|(
operator|&
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* this is a shell function that calls either the normal or Montgomery  * exptmod functions.  Originally the call to the montgomery code was  * embedded in the normal function but that wasted alot of stack space  * for nothing (since 99% of the time the Montgomery code would be called)  */
end_comment

begin_function
specifier|static
name|int
name|mp_exptmod
parameter_list|(
name|mp_int
modifier|*
name|G
parameter_list|,
name|mp_int
modifier|*
name|X
parameter_list|,
name|mp_int
modifier|*
name|P
parameter_list|,
name|mp_int
modifier|*
name|Y
parameter_list|)
block|{
name|int
name|dr
decl_stmt|;
comment|/* modulus P must be positive */
if|if
condition|(
name|P
operator|->
name|sign
operator|==
name|MP_NEG
condition|)
block|{
return|return
name|MP_VAL
return|;
block|}
comment|/* if exponent X is negative we have to recurse */
if|if
condition|(
name|X
operator|->
name|sign
operator|==
name|MP_NEG
condition|)
block|{
ifdef|#
directive|ifdef
name|BN_MP_INVMOD_C
name|mp_int
name|tmpG
decl_stmt|,
name|tmpX
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* first compute 1/G mod P */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|tmpG
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|mp_invmod
argument_list|(
name|G
argument_list|,
name|P
argument_list|,
operator|&
name|tmpG
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear
argument_list|(
operator|&
name|tmpG
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* now get |X| */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|tmpX
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear
argument_list|(
operator|&
name|tmpG
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|mp_abs
argument_list|(
name|X
argument_list|,
operator|&
name|tmpX
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear_multi
argument_list|(
operator|&
name|tmpG
argument_list|,
operator|&
name|tmpX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* and now compute (1/G)**|X| instead of G**X [X< 0] */
name|err
operator|=
name|mp_exptmod
argument_list|(
operator|&
name|tmpG
argument_list|,
operator|&
name|tmpX
argument_list|,
name|P
argument_list|,
name|Y
argument_list|)
expr_stmt|;
name|mp_clear_multi
argument_list|(
operator|&
name|tmpG
argument_list|,
operator|&
name|tmpX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
else|#
directive|else
error|#
directive|error
error|mp_exptmod would always fail
comment|/* no invmod */
return|return
name|MP_VAL
return|;
endif|#
directive|endif
block|}
comment|/* modified diminished radix reduction */
if|#
directive|if
name|defined
argument_list|(
name|BN_MP_REDUCE_IS_2K_L_C
argument_list|)
operator|&&
name|defined
argument_list|(
name|BN_MP_REDUCE_2K_L_C
argument_list|)
operator|&&
name|defined
argument_list|(
name|BN_S_MP_EXPTMOD_C
argument_list|)
if|if
condition|(
name|mp_reduce_is_2k_l
argument_list|(
name|P
argument_list|)
operator|==
name|MP_YES
condition|)
block|{
return|return
name|s_mp_exptmod
argument_list|(
name|G
argument_list|,
name|X
argument_list|,
name|P
argument_list|,
name|Y
argument_list|,
literal|1
argument_list|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_MP_DR_IS_MODULUS_C
comment|/* is it a DR modulus? */
name|dr
operator|=
name|mp_dr_is_modulus
argument_list|(
name|P
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* default to no */
name|dr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_MP_REDUCE_IS_2K_C
comment|/* if not, is it a unrestricted DR modulus? */
if|if
condition|(
name|dr
operator|==
literal|0
condition|)
block|{
name|dr
operator|=
name|mp_reduce_is_2k
argument_list|(
name|P
argument_list|)
operator|<<
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if the modulus is odd or dr != 0 use the montgomery method */
ifdef|#
directive|ifdef
name|BN_MP_EXPTMOD_FAST_C
if|if
condition|(
name|mp_isodd
argument_list|(
name|P
argument_list|)
operator|==
literal|1
operator|||
name|dr
operator|!=
literal|0
condition|)
block|{
return|return
name|mp_exptmod_fast
argument_list|(
name|G
argument_list|,
name|X
argument_list|,
name|P
argument_list|,
name|Y
argument_list|,
name|dr
argument_list|)
return|;
block|}
else|else
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_S_MP_EXPTMOD_C
comment|/* otherwise use the generic Barrett reduction technique */
return|return
name|s_mp_exptmod
argument_list|(
name|G
argument_list|,
name|X
argument_list|,
name|P
argument_list|,
name|Y
argument_list|,
literal|0
argument_list|)
return|;
else|#
directive|else
error|#
directive|error
error|mp_exptmod could fail
comment|/* no exptmod for evens */
return|return
name|MP_VAL
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_MP_EXPTMOD_FAST_C
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* compare two ints (signed)*/
end_comment

begin_function
specifier|static
name|int
name|mp_cmp
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
comment|/* compare based on sign */
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|sign
operator|==
name|MP_NEG
condition|)
block|{
return|return
name|MP_LT
return|;
block|}
else|else
block|{
return|return
name|MP_GT
return|;
block|}
block|}
comment|/* compare digits */
if|if
condition|(
name|a
operator|->
name|sign
operator|==
name|MP_NEG
condition|)
block|{
comment|/* if negative compare opposite direction */
return|return
name|mp_cmp_mag
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|mp_cmp_mag
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* compare a digit */
end_comment

begin_function
specifier|static
name|int
name|mp_cmp_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|)
block|{
comment|/* compare based on sign */
if|if
condition|(
name|a
operator|->
name|sign
operator|==
name|MP_NEG
condition|)
block|{
return|return
name|MP_LT
return|;
block|}
comment|/* compare based on magnitude */
if|if
condition|(
name|a
operator|->
name|used
operator|>
literal|1
condition|)
block|{
return|return
name|MP_GT
return|;
block|}
comment|/* compare the only digit of a to b */
if|if
condition|(
name|a
operator|->
name|dp
index|[
literal|0
index|]
operator|>
name|b
condition|)
block|{
return|return
name|MP_GT
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|dp
index|[
literal|0
index|]
operator|<
name|b
condition|)
block|{
return|return
name|MP_LT
return|;
block|}
else|else
block|{
return|return
name|MP_EQ
return|;
block|}
block|}
end_function

begin_comment
comment|/* hac 14.61, pp608 */
end_comment

begin_function
specifier|static
name|int
name|mp_invmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
comment|/* b cannot be negative */
if|if
condition|(
name|b
operator|->
name|sign
operator|==
name|MP_NEG
operator|||
name|mp_iszero
argument_list|(
name|b
argument_list|)
operator|==
literal|1
condition|)
block|{
return|return
name|MP_VAL
return|;
block|}
ifdef|#
directive|ifdef
name|BN_FAST_MP_INVMOD_C
comment|/* if the modulus is odd we can use a faster routine instead */
if|if
condition|(
name|mp_isodd
argument_list|(
name|b
argument_list|)
operator|==
literal|1
condition|)
block|{
return|return
name|fast_mp_invmod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_MP_INVMOD_SLOW_C
return|return
name|mp_invmod_slow
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BN_FAST_MP_INVMOD_C
ifndef|#
directive|ifndef
name|BN_MP_INVMOD_SLOW_C
error|#
directive|error
error|mp_invmod would always fail
endif|#
directive|endif
endif|#
directive|endif
return|return
name|MP_VAL
return|;
block|}
end_function

begin_comment
comment|/* get the size for an unsigned equivalent */
end_comment

begin_function
specifier|static
name|int
name|mp_unsigned_bin_size
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
block|{
name|int
name|size
init|=
name|mp_count_bits
argument_list|(
name|a
argument_list|)
decl_stmt|;
return|return
operator|(
name|size
operator|/
literal|8
operator|+
operator|(
operator|(
name|size
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* hac 14.61, pp608 */
end_comment

begin_function
specifier|static
name|int
name|mp_invmod_slow
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|mp_int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* b cannot be negative */
if|if
condition|(
name|b
operator|->
name|sign
operator|==
name|MP_NEG
operator|||
name|mp_iszero
argument_list|(
name|b
argument_list|)
operator|==
literal|1
condition|)
block|{
return|return
name|MP_VAL
return|;
block|}
comment|/* init temps */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init_multi
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|A
argument_list|,
operator|&
name|B
argument_list|,
operator|&
name|C
argument_list|,
operator|&
name|D
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
comment|/* x = a, y = b */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_mod
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|x
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_copy
argument_list|(
name|b
argument_list|,
operator|&
name|y
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
comment|/* 2. [modified] if x,y are both even then return an error! */
if|if
condition|(
name|mp_iseven
argument_list|(
operator|&
name|x
argument_list|)
operator|==
literal|1
operator|&&
name|mp_iseven
argument_list|(
operator|&
name|y
argument_list|)
operator|==
literal|1
condition|)
block|{
name|res
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|LBL_ERR
goto|;
block|}
comment|/* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_copy
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|u
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_copy
argument_list|(
operator|&
name|y
argument_list|,
operator|&
name|v
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
name|mp_set
argument_list|(
operator|&
name|A
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mp_set
argument_list|(
operator|&
name|D
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top
label|:
comment|/* 4.  while u is even do */
while|while
condition|(
name|mp_iseven
argument_list|(
operator|&
name|u
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 4.1 u = u/2 */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|u
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
comment|/* 4.2 if A or B is odd then */
if|if
condition|(
name|mp_isodd
argument_list|(
operator|&
name|A
argument_list|)
operator|==
literal|1
operator|||
name|mp_isodd
argument_list|(
operator|&
name|B
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* A = (A+y)/2, B = (B-x)/2 */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_add
argument_list|(
operator|&
name|A
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|A
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|B
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|B
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* A = A/2, B = B/2 */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2
argument_list|(
operator|&
name|A
argument_list|,
operator|&
name|A
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2
argument_list|(
operator|&
name|B
argument_list|,
operator|&
name|B
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* 5.  while v is even do */
while|while
condition|(
name|mp_iseven
argument_list|(
operator|&
name|v
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 5.1 v = v/2 */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|v
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
comment|/* 5.2 if C or D is odd then */
if|if
condition|(
name|mp_isodd
argument_list|(
operator|&
name|C
argument_list|)
operator|==
literal|1
operator|||
name|mp_isodd
argument_list|(
operator|&
name|D
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* C = (C+y)/2, D = (D-x)/2 */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_add
argument_list|(
operator|&
name|C
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|C
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|D
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|D
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* C = C/2, D = D/2 */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2
argument_list|(
operator|&
name|C
argument_list|,
operator|&
name|C
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2
argument_list|(
operator|&
name|D
argument_list|,
operator|&
name|D
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* 6.  if u>= v then */
if|if
condition|(
name|mp_cmp
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
name|MP_LT
condition|)
block|{
comment|/* u = u - v, A = A - C, B = B - D */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|u
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|A
argument_list|,
operator|&
name|C
argument_list|,
operator|&
name|A
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|B
argument_list|,
operator|&
name|D
argument_list|,
operator|&
name|B
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
else|else
block|{
comment|/* v - v - u, C = C - A, D = D - B */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|v
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|C
argument_list|,
operator|&
name|A
argument_list|,
operator|&
name|C
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|D
argument_list|,
operator|&
name|B
argument_list|,
operator|&
name|D
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* if not zero goto step 4 */
if|if
condition|(
name|mp_iszero
argument_list|(
operator|&
name|u
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
comment|/* now a = C, b = D, gcd == g*v */
comment|/* if v != 1 then there is no inverse */
if|if
condition|(
name|mp_cmp_d
argument_list|(
operator|&
name|v
argument_list|,
literal|1
argument_list|)
operator|!=
name|MP_EQ
condition|)
block|{
name|res
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|LBL_ERR
goto|;
block|}
comment|/* if its too low */
while|while
condition|(
name|mp_cmp_d
argument_list|(
operator|&
name|C
argument_list|,
literal|0
argument_list|)
operator|==
name|MP_LT
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_add
argument_list|(
operator|&
name|C
argument_list|,
name|b
argument_list|,
operator|&
name|C
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* too big */
while|while
condition|(
name|mp_cmp_mag
argument_list|(
operator|&
name|C
argument_list|,
name|b
argument_list|)
operator|!=
name|MP_LT
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|C
argument_list|,
name|b
argument_list|,
operator|&
name|C
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* C is now the inverse */
name|mp_exch
argument_list|(
operator|&
name|C
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|res
operator|=
name|MP_OKAY
expr_stmt|;
name|LBL_ERR
label|:
name|mp_clear_multi
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|A
argument_list|,
operator|&
name|B
argument_list|,
operator|&
name|C
argument_list|,
operator|&
name|D
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* compare maginitude of two ints (unsigned) */
end_comment

begin_function
specifier|static
name|int
name|mp_cmp_mag
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|mp_digit
modifier|*
name|tmpa
decl_stmt|,
modifier|*
name|tmpb
decl_stmt|;
comment|/* compare based on # of non-zero digits */
if|if
condition|(
name|a
operator|->
name|used
operator|>
name|b
operator|->
name|used
condition|)
block|{
return|return
name|MP_GT
return|;
block|}
if|if
condition|(
name|a
operator|->
name|used
operator|<
name|b
operator|->
name|used
condition|)
block|{
return|return
name|MP_LT
return|;
block|}
comment|/* alias for a */
name|tmpa
operator|=
name|a
operator|->
name|dp
operator|+
operator|(
name|a
operator|->
name|used
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* alias for b */
name|tmpb
operator|=
name|b
operator|->
name|dp
operator|+
operator|(
name|a
operator|->
name|used
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* compare based on digits  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|a
operator|->
name|used
condition|;
operator|++
name|n
operator|,
operator|--
name|tmpa
operator|,
operator|--
name|tmpb
control|)
block|{
if|if
condition|(
operator|*
name|tmpa
operator|>
operator|*
name|tmpb
condition|)
block|{
return|return
name|MP_GT
return|;
block|}
if|if
condition|(
operator|*
name|tmpa
operator|<
operator|*
name|tmpb
condition|)
block|{
return|return
name|MP_LT
return|;
block|}
block|}
return|return
name|MP_EQ
return|;
block|}
end_function

begin_comment
comment|/* reads a unsigned char array, assumes the msb is stored first [big endian] */
end_comment

begin_function
specifier|static
name|int
name|mp_read_unsigned_bin
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
comment|/* make sure there are at least two digits */
if|if
condition|(
name|a
operator|->
name|alloc
operator|<
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
comment|/* zero the int */
name|mp_zero
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* read the bytes in */
while|while
condition|(
name|c
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_mul_2d
argument_list|(
name|a
argument_list|,
literal|8
argument_list|,
name|a
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
ifndef|#
directive|ifndef
name|MP_8BIT
name|a
operator|->
name|dp
index|[
literal|0
index|]
operator||=
operator|*
name|b
operator|++
expr_stmt|;
name|a
operator|->
name|used
operator|+=
literal|1
expr_stmt|;
else|#
directive|else
name|a
operator|->
name|dp
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|b
operator|&
name|MP_MASK
operator|)
expr_stmt|;
name|a
operator|->
name|dp
index|[
literal|1
index|]
operator||=
operator|(
operator|(
operator|*
name|b
operator|++
operator|>>
literal|7U
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|a
operator|->
name|used
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
name|mp_clamp
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* store in unsigned [big endian] format */
end_comment

begin_function
specifier|static
name|int
name|mp_to_unsigned_bin
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|res
decl_stmt|;
name|mp_int
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init_copy
argument_list|(
operator|&
name|t
argument_list|,
name|a
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mp_iszero
argument_list|(
operator|&
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|MP_8BIT
name|b
index|[
name|x
operator|++
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|t
operator|.
name|dp
index|[
literal|0
index|]
operator|&
literal|255
argument_list|)
expr_stmt|;
else|#
directive|else
name|b
index|[
name|x
operator|++
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|t
operator|.
name|dp
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|t
operator|.
name|dp
index|[
literal|1
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|7
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2d
argument_list|(
operator|&
name|t
argument_list|,
literal|8
argument_list|,
operator|&
name|t
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
name|bn_reverse
argument_list|(
name|b
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* shift right by a certain bit count (store quotient in c, optional remainder in d) */
end_comment

begin_function
specifier|static
name|int
name|mp_div_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
block|{
name|mp_digit
name|D
decl_stmt|,
name|r
decl_stmt|,
name|rr
decl_stmt|;
name|int
name|x
decl_stmt|,
name|res
decl_stmt|;
name|mp_int
name|t
decl_stmt|;
comment|/* if the shift count is<= 0 then we do no work */
if|if
condition|(
name|b
operator|<=
literal|0
condition|)
block|{
name|res
operator|=
name|mp_copy
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|mp_zero
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init
argument_list|(
operator|&
name|t
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
comment|/* get the remainder */
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_mod_2d
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
comment|/* copy */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_copy
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* shift by as many digits in the bit count */
if|if
condition|(
name|b
operator|>=
operator|(
name|int
operator|)
name|DIGIT_BIT
condition|)
block|{
name|mp_rshd
argument_list|(
name|c
argument_list|,
name|b
operator|/
name|DIGIT_BIT
argument_list|)
expr_stmt|;
block|}
comment|/* shift any bit count< DIGIT_BIT */
name|D
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|b
operator|%
name|DIGIT_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|D
operator|!=
literal|0
condition|)
block|{
specifier|register
name|mp_digit
modifier|*
name|tmpc
decl_stmt|,
name|mask
decl_stmt|,
name|shift
decl_stmt|;
comment|/* mask */
name|mask
operator|=
operator|(
operator|(
operator|(
name|mp_digit
operator|)
literal|1
operator|)
operator|<<
name|D
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* shift for lsb */
name|shift
operator|=
name|DIGIT_BIT
operator|-
name|D
expr_stmt|;
comment|/* alias */
name|tmpc
operator|=
name|c
operator|->
name|dp
operator|+
operator|(
name|c
operator|->
name|used
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* carry */
name|r
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|c
operator|->
name|used
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
comment|/* get the lower  bits of this word in a temp */
name|rr
operator|=
operator|*
name|tmpc
operator|&
name|mask
expr_stmt|;
comment|/* shift the current word and mix in the carry bits from the previous word */
operator|*
name|tmpc
operator|=
operator|(
operator|*
name|tmpc
operator|>>
name|D
operator|)
operator||
operator|(
name|r
operator|<<
name|shift
operator|)
expr_stmt|;
operator|--
name|tmpc
expr_stmt|;
comment|/* set the carry to the carry bits of the current word found above */
name|r
operator|=
name|rr
expr_stmt|;
block|}
block|}
name|mp_clamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|mp_exch
argument_list|(
operator|&
name|t
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_init_copy
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init
argument_list|(
name|a
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
return|return
name|mp_copy
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* set to zero */
end_comment

begin_function
specifier|static
name|void
name|mp_zero
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|mp_digit
modifier|*
name|tmp
decl_stmt|;
name|a
operator|->
name|sign
operator|=
name|MP_ZPOS
expr_stmt|;
name|a
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|a
operator|->
name|dp
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|a
operator|->
name|alloc
condition|;
name|n
operator|++
control|)
block|{
operator|*
name|tmp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copy, b = a */
end_comment

begin_function
specifier|static
name|int
name|mp_copy
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|res
decl_stmt|,
name|n
decl_stmt|;
comment|/* if dst == src do nothing */
if|if
condition|(
name|a
operator|==
name|b
condition|)
block|{
return|return
name|MP_OKAY
return|;
block|}
comment|/* grow dest */
if|if
condition|(
name|b
operator|->
name|alloc
operator|<
name|a
operator|->
name|used
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|b
argument_list|,
name|a
operator|->
name|used
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
comment|/* zero b and copy the parameters over */
block|{
specifier|register
name|mp_digit
modifier|*
name|tmpa
decl_stmt|,
modifier|*
name|tmpb
decl_stmt|;
comment|/* pointer aliases */
comment|/* source */
name|tmpa
operator|=
name|a
operator|->
name|dp
expr_stmt|;
comment|/* destination */
name|tmpb
operator|=
name|b
operator|->
name|dp
expr_stmt|;
comment|/* copy all the digits */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|a
operator|->
name|used
condition|;
name|n
operator|++
control|)
block|{
operator|*
name|tmpb
operator|++
operator|=
operator|*
name|tmpa
operator|++
expr_stmt|;
block|}
comment|/* clear high digits */
for|for
control|(
init|;
name|n
operator|<
name|b
operator|->
name|used
condition|;
name|n
operator|++
control|)
block|{
operator|*
name|tmpb
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* copy used count and sign */
name|b
operator|->
name|used
operator|=
name|a
operator|->
name|used
expr_stmt|;
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* shift right a certain amount of digits */
end_comment

begin_function
specifier|static
name|void
name|mp_rshd
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* if b<= 0 then ignore it */
if|if
condition|(
name|b
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* if b> used then simply zero it and return */
if|if
condition|(
name|a
operator|->
name|used
operator|<=
name|b
condition|)
block|{
name|mp_zero
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
specifier|register
name|mp_digit
modifier|*
name|bottom
decl_stmt|,
modifier|*
name|top
decl_stmt|;
comment|/* shift the digits down */
comment|/* bottom */
name|bottom
operator|=
name|a
operator|->
name|dp
expr_stmt|;
comment|/* top [offset into digits] */
name|top
operator|=
name|a
operator|->
name|dp
operator|+
name|b
expr_stmt|;
comment|/* this is implemented as a sliding window where       * the window is b-digits long and digits from       * the top of the window are copied to the bottom      *      * e.g.       b-2 | b-1 | b0 | b1 | b2 | ... | bb |   ---->                  /\                   |      ---->                   \-------------------/      ---->      */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|a
operator|->
name|used
operator|-
name|b
operator|)
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|bottom
operator|++
operator|=
operator|*
name|top
operator|++
expr_stmt|;
block|}
comment|/* zero the top digits */
for|for
control|(
init|;
name|x
operator|<
name|a
operator|->
name|used
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|bottom
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* remove excess digits */
name|a
operator|->
name|used
operator|-=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* swap the elements of two integers, for cases where you can't simply swap the   * mp_int pointers around  */
end_comment

begin_function
specifier|static
name|void
name|mp_exch
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|mp_int
name|t
decl_stmt|;
name|t
operator|=
operator|*
name|a
expr_stmt|;
operator|*
name|a
operator|=
operator|*
name|b
expr_stmt|;
operator|*
name|b
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* trim unused digits   *  * This is used to ensure that leading zero digits are  * trimed and the leading "used" digit will be non-zero  * Typically very fast.  Also fixes the sign if there  * are no more leading digits  */
end_comment

begin_function
specifier|static
name|void
name|mp_clamp
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
block|{
comment|/* decrease used while the most significant digit is    * zero.    */
while|while
condition|(
name|a
operator|->
name|used
operator|>
literal|0
operator|&&
name|a
operator|->
name|dp
index|[
name|a
operator|->
name|used
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
operator|--
operator|(
name|a
operator|->
name|used
operator|)
expr_stmt|;
block|}
comment|/* reset the sign flag if used == 0 */
if|if
condition|(
name|a
operator|->
name|used
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|sign
operator|=
name|MP_ZPOS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* grow as required */
end_comment

begin_function
specifier|static
name|int
name|mp_grow
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mp_digit
modifier|*
name|tmp
decl_stmt|;
comment|/* if the alloc size is smaller alloc more ram */
if|if
condition|(
name|a
operator|->
name|alloc
operator|<
name|size
condition|)
block|{
comment|/* ensure there are always at least MP_PREC digits extra on top */
name|size
operator|+=
operator|(
name|MP_PREC
operator|*
literal|2
operator|)
operator|-
operator|(
name|size
operator|%
name|MP_PREC
operator|)
expr_stmt|;
comment|/* reallocate the array a->dp      *      * We store the return in a temporary variable      * in case the operation failed we don't want      * to overwrite the dp member of a.      */
name|tmp
operator|=
name|OPT_CAST
argument_list|(
argument|mp_digit
argument_list|)
name|XREALLOC
argument_list|(
name|a
operator|->
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|mp_digit
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
comment|/* reallocation failed but "a" is still valid [can be freed] */
return|return
name|MP_MEM
return|;
block|}
comment|/* reallocation succeeded so set a->dp */
name|a
operator|->
name|dp
operator|=
name|tmp
expr_stmt|;
comment|/* zero excess digits */
name|i
operator|=
name|a
operator|->
name|alloc
expr_stmt|;
name|a
operator|->
name|alloc
operator|=
name|size
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|a
operator|->
name|alloc
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|->
name|dp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* b = |a|   *  * Simple function copies the input and fixes the sign to positive  */
end_comment

begin_function
specifier|static
name|int
name|mp_abs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
comment|/* copy a to b */
if|if
condition|(
name|a
operator|!=
name|b
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_copy
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
comment|/* force the sign of b to positive */
name|b
operator|->
name|sign
operator|=
name|MP_ZPOS
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* set to a digit */
end_comment

begin_function
specifier|static
name|void
name|mp_set
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|)
block|{
name|mp_zero
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|dp
index|[
literal|0
index|]
operator|=
name|b
operator|&
name|MP_MASK
expr_stmt|;
name|a
operator|->
name|used
operator|=
operator|(
name|a
operator|->
name|dp
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* b = a/2 */
end_comment

begin_function
specifier|static
name|int
name|mp_div_2
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|res
decl_stmt|,
name|oldused
decl_stmt|;
comment|/* copy */
if|if
condition|(
name|b
operator|->
name|alloc
operator|<
name|a
operator|->
name|used
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|b
argument_list|,
name|a
operator|->
name|used
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
name|oldused
operator|=
name|b
operator|->
name|used
expr_stmt|;
name|b
operator|->
name|used
operator|=
name|a
operator|->
name|used
expr_stmt|;
block|{
specifier|register
name|mp_digit
name|r
decl_stmt|,
name|rr
decl_stmt|,
modifier|*
name|tmpa
decl_stmt|,
modifier|*
name|tmpb
decl_stmt|;
comment|/* source alias */
name|tmpa
operator|=
name|a
operator|->
name|dp
operator|+
name|b
operator|->
name|used
operator|-
literal|1
expr_stmt|;
comment|/* dest alias */
name|tmpb
operator|=
name|b
operator|->
name|dp
operator|+
name|b
operator|->
name|used
operator|-
literal|1
expr_stmt|;
comment|/* carry */
name|r
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|b
operator|->
name|used
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
comment|/* get the carry for the next iteration */
name|rr
operator|=
operator|*
name|tmpa
operator|&
literal|1
expr_stmt|;
comment|/* shift the current digit, add in carry and store */
operator|*
name|tmpb
operator|--
operator|=
operator|(
operator|*
name|tmpa
operator|--
operator|>>
literal|1
operator|)
operator||
operator|(
name|r
operator|<<
operator|(
name|DIGIT_BIT
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* forward carry to next iteration */
name|r
operator|=
name|rr
expr_stmt|;
block|}
comment|/* zero excess digits */
name|tmpb
operator|=
name|b
operator|->
name|dp
operator|+
name|b
operator|->
name|used
expr_stmt|;
for|for
control|(
name|x
operator|=
name|b
operator|->
name|used
init|;
name|x
operator|<
name|oldused
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|tmpb
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|mp_clamp
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* shift left by a certain bit count */
end_comment

begin_function
specifier|static
name|int
name|mp_mul_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|mp_digit
name|d
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* copy */
if|if
condition|(
name|a
operator|!=
name|c
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_copy
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
if|if
condition|(
name|c
operator|->
name|alloc
operator|<
call|(
name|int
call|)
argument_list|(
name|c
operator|->
name|used
operator|+
name|b
operator|/
name|DIGIT_BIT
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|used
operator|+
name|b
operator|/
name|DIGIT_BIT
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
comment|/* shift by as many digits in the bit count */
if|if
condition|(
name|b
operator|>=
operator|(
name|int
operator|)
name|DIGIT_BIT
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_lshd
argument_list|(
name|c
argument_list|,
name|b
operator|/
name|DIGIT_BIT
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
comment|/* shift any bit count< DIGIT_BIT */
name|d
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|b
operator|%
name|DIGIT_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
specifier|register
name|mp_digit
modifier|*
name|tmpc
decl_stmt|,
name|shift
decl_stmt|,
name|mask
decl_stmt|,
name|r
decl_stmt|,
name|rr
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
comment|/* bitmask for carries */
name|mask
operator|=
operator|(
operator|(
operator|(
name|mp_digit
operator|)
literal|1
operator|)
operator|<<
name|d
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* shift for msbs */
name|shift
operator|=
name|DIGIT_BIT
operator|-
name|d
expr_stmt|;
comment|/* alias */
name|tmpc
operator|=
name|c
operator|->
name|dp
expr_stmt|;
comment|/* carry */
name|r
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|c
operator|->
name|used
condition|;
name|x
operator|++
control|)
block|{
comment|/* get the higher bits of the current word */
name|rr
operator|=
operator|(
operator|*
name|tmpc
operator|>>
name|shift
operator|)
operator|&
name|mask
expr_stmt|;
comment|/* shift the current word and OR in the carry */
operator|*
name|tmpc
operator|=
operator|(
operator|(
operator|*
name|tmpc
operator|<<
name|d
operator|)
operator||
name|r
operator|)
operator|&
name|MP_MASK
expr_stmt|;
operator|++
name|tmpc
expr_stmt|;
comment|/* set the carry to the carry bits of the current word */
name|r
operator|=
name|rr
expr_stmt|;
block|}
comment|/* set final carry */
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|c
operator|->
name|dp
index|[
operator|(
name|c
operator|->
name|used
operator|)
operator|++
index|]
operator|=
name|r
expr_stmt|;
block|}
block|}
name|mp_clamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_init_multi
parameter_list|(
name|mp_int
modifier|*
name|mp
parameter_list|,
modifier|...
parameter_list|)
block|{
name|mp_err
name|res
init|=
name|MP_OKAY
decl_stmt|;
comment|/* Assume ok until proven otherwise */
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Number of ok inits */
name|mp_int
modifier|*
name|cur_arg
init|=
name|mp
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* init args to next argument from caller */
while|while
condition|(
name|cur_arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mp_init
argument_list|(
name|cur_arg
argument_list|)
operator|!=
name|MP_OKAY
condition|)
block|{
comment|/* Oops - error! Back-track and mp_clear what we already                succeeded in init-ing, then return error.             */
name|va_list
name|clean_args
decl_stmt|;
comment|/* end the current list */
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* now start cleaning up */
name|cur_arg
operator|=
name|mp
expr_stmt|;
name|va_start
argument_list|(
name|clean_args
argument_list|,
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|mp_clear
argument_list|(
name|cur_arg
argument_list|)
expr_stmt|;
name|cur_arg
operator|=
name|va_arg
argument_list|(
name|clean_args
argument_list|,
name|mp_int
operator|*
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|clean_args
argument_list|)
expr_stmt|;
name|res
operator|=
name|MP_MEM
expr_stmt|;
break|break;
block|}
name|n
operator|++
expr_stmt|;
name|cur_arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|mp_int
operator|*
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|res
return|;
comment|/* Assumed ok, if error flagged above. */
block|}
end_function

begin_function
specifier|static
name|void
name|mp_clear_multi
parameter_list|(
name|mp_int
modifier|*
name|mp
parameter_list|,
modifier|...
parameter_list|)
block|{
name|mp_int
modifier|*
name|next_mp
init|=
name|mp
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_mp
operator|!=
name|NULL
condition|)
block|{
name|mp_clear
argument_list|(
name|next_mp
argument_list|)
expr_stmt|;
name|next_mp
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|mp_int
operator|*
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* shift left a certain amount of digits */
end_comment

begin_function
specifier|static
name|int
name|mp_lshd
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|res
decl_stmt|;
comment|/* if its less than zero return */
if|if
condition|(
name|b
operator|<=
literal|0
condition|)
block|{
return|return
name|MP_OKAY
return|;
block|}
comment|/* grow to fit the new digits */
if|if
condition|(
name|a
operator|->
name|alloc
operator|<
name|a
operator|->
name|used
operator|+
name|b
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|used
operator|+
name|b
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
block|{
specifier|register
name|mp_digit
modifier|*
name|top
decl_stmt|,
modifier|*
name|bottom
decl_stmt|;
comment|/* increment the used by the shift amount then copy upwards */
name|a
operator|->
name|used
operator|+=
name|b
expr_stmt|;
comment|/* top */
name|top
operator|=
name|a
operator|->
name|dp
operator|+
name|a
operator|->
name|used
operator|-
literal|1
expr_stmt|;
comment|/* base */
name|bottom
operator|=
name|a
operator|->
name|dp
operator|+
name|a
operator|->
name|used
operator|-
literal|1
operator|-
name|b
expr_stmt|;
comment|/* much like mp_rshd this is implemented using a sliding window      * except the window goes the otherway around.  Copying from      * the bottom to the top.  see bn_mp_rshd.c for more info.      */
for|for
control|(
name|x
operator|=
name|a
operator|->
name|used
operator|-
literal|1
init|;
name|x
operator|>=
name|b
condition|;
name|x
operator|--
control|)
block|{
operator|*
name|top
operator|--
operator|=
operator|*
name|bottom
operator|--
expr_stmt|;
block|}
comment|/* zero the lower digits */
name|top
operator|=
name|a
operator|->
name|dp
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|b
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|top
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* returns the number of bits in an int */
end_comment

begin_function
specifier|static
name|int
name|mp_count_bits
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|mp_digit
name|q
decl_stmt|;
comment|/* shortcut */
if|if
condition|(
name|a
operator|->
name|used
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* get number of digits and add that */
name|r
operator|=
operator|(
name|a
operator|->
name|used
operator|-
literal|1
operator|)
operator|*
name|DIGIT_BIT
expr_stmt|;
comment|/* take the last digit and count the bits in it */
name|q
operator|=
name|a
operator|->
name|dp
index|[
name|a
operator|->
name|used
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|q
operator|>
operator|(
operator|(
name|mp_digit
operator|)
literal|0
operator|)
condition|)
block|{
operator|++
name|r
expr_stmt|;
name|q
operator|>>=
operator|(
operator|(
name|mp_digit
operator|)
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* calc a value mod 2**b */
end_comment

begin_function
specifier|static
name|int
name|mp_mod_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|res
decl_stmt|;
comment|/* if b is<= 0 then zero the int */
if|if
condition|(
name|b
operator|<=
literal|0
condition|)
block|{
name|mp_zero
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
comment|/* if the modulus is larger than the value than return */
if|if
condition|(
name|b
operator|>=
call|(
name|int
call|)
argument_list|(
name|a
operator|->
name|used
operator|*
name|DIGIT_BIT
argument_list|)
condition|)
block|{
name|res
operator|=
name|mp_copy
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* copy */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_copy
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
comment|/* zero digits above the last digit of the modulus */
for|for
control|(
name|x
operator|=
operator|(
name|b
operator|/
name|DIGIT_BIT
operator|)
operator|+
operator|(
operator|(
name|b
operator|%
name|DIGIT_BIT
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
init|;
name|x
operator|<
name|c
operator|->
name|used
condition|;
name|x
operator|++
control|)
block|{
name|c
operator|->
name|dp
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clear the digit that is not completely outside/inside the modulus */
name|c
operator|->
name|dp
index|[
name|b
operator|/
name|DIGIT_BIT
index|]
operator|&=
call|(
name|mp_digit
call|)
argument_list|(
operator|(
operator|(
operator|(
name|mp_digit
operator|)
literal|1
operator|)
operator|<<
operator|(
operator|(
operator|(
name|mp_digit
operator|)
name|b
operator|)
operator|%
name|DIGIT_BIT
operator|)
operator|)
operator|-
operator|(
operator|(
name|mp_digit
operator|)
literal|1
operator|)
argument_list|)
expr_stmt|;
name|mp_clamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* slower bit-bang division... also smaller */
end_comment

begin_function
specifier|static
name|int
name|mp_div
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
block|{
name|mp_int
name|ta
decl_stmt|,
name|tb
decl_stmt|,
name|tq
decl_stmt|,
name|q
decl_stmt|;
name|int
name|res
decl_stmt|,
name|n
decl_stmt|,
name|n2
decl_stmt|;
comment|/* is divisor zero ? */
if|if
condition|(
name|mp_iszero
argument_list|(
name|b
argument_list|)
operator|==
literal|1
condition|)
block|{
return|return
name|MP_VAL
return|;
block|}
comment|/* if a< b then q=0, r = a */
if|if
condition|(
name|mp_cmp_mag
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
name|MP_LT
condition|)
block|{
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|mp_copy
argument_list|(
name|a
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|MP_OKAY
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|mp_zero
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/* init our temps */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init_multi
argument_list|(
operator|&
name|ta
argument_list|,
operator|&
name|tb
argument_list|,
operator|&
name|tq
argument_list|,
operator|&
name|q
argument_list|,
name|NULL
argument_list|)
operator|!=
name|MP_OKAY
operator|)
condition|)
block|{
return|return
name|res
return|;
block|}
name|mp_set
argument_list|(
operator|&
name|tq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|mp_count_bits
argument_list|(
name|a
argument_list|)
operator|-
name|mp_count_bits
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|res
operator|=
name|mp_abs
argument_list|(
name|a
argument_list|,
operator|&
name|ta
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
operator|||
operator|(
operator|(
name|res
operator|=
name|mp_abs
argument_list|(
name|b
argument_list|,
operator|&
name|tb
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
operator|||
operator|(
operator|(
name|res
operator|=
name|mp_mul_2d
argument_list|(
operator|&
name|tb
argument_list|,
name|n
argument_list|,
operator|&
name|tb
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
operator|||
operator|(
operator|(
name|res
operator|=
name|mp_mul_2d
argument_list|(
operator|&
name|tq
argument_list|,
name|n
argument_list|,
operator|&
name|tq
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
while|while
condition|(
name|n
operator|--
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|mp_cmp
argument_list|(
operator|&
name|tb
argument_list|,
operator|&
name|ta
argument_list|)
operator|!=
name|MP_GT
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
operator|&
name|ta
argument_list|,
operator|&
name|tb
argument_list|,
operator|&
name|ta
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
operator|||
operator|(
operator|(
name|res
operator|=
name|mp_add
argument_list|(
operator|&
name|q
argument_list|,
operator|&
name|tq
argument_list|,
operator|&
name|q
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|res
operator|=
name|mp_div_2d
argument_list|(
operator|&
name|tb
argument_list|,
literal|1
argument_list|,
operator|&
name|tb
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
operator|||
operator|(
operator|(
name|res
operator|=
name|mp_div_2d
argument_list|(
operator|&
name|tq
argument_list|,
literal|1
argument_list|,
operator|&
name|tq
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|MP_OKAY
operator|)
condition|)
block|{
goto|goto
name|LBL_ERR
goto|;
block|}
block|}
comment|/* now q == quotient and ta == remainder */
name|n
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|n2
operator|=
operator|(
name|a
operator|->
name|sign
operator|==
name|b
operator|->
name|sign
condition|?
name|MP_ZPOS
else|:
name|MP_NEG
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|mp_exch
argument_list|(
name|c
argument_list|,
operator|&
name|q
argument_list|)
expr_stmt|;
name|c
operator|->
name|sign
operator|=
operator|(
name|mp_iszero
argument_list|(
name|c
argument_list|)
operator|==
name|MP_YES
operator|)
condition|?
name|MP_ZPOS
else|:
name|n2
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|mp_exch
argument_list|(
name|d
argument_list|,
operator|&
name|ta
argument_list|)
expr_stmt|;
name|d
operator|->
name|sign
operator|=
operator|(
name|mp_iszero
argument_list|(
name|d
argument_list|)
operator|==
name|MP_YES
operator|)
condition|?
name|MP_ZPOS
else|:
name|n
expr_stmt|;
block|}
name|LBL_ERR
label|:
name|mp_clear_multi
argument_list|(
operator|&
name|ta
argument_list|,
operator|&
name|tb
argument_list|,
operator|&
name|tq
argument_list|,
operator|&
name|q
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MP_LOW_MEM
end_ifdef

begin_define
define|#
directive|define
name|TAB_SIZE
value|32
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TAB_SIZE
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|s_mp_exptmod
parameter_list|(
name|mp_int
modifier|*
name|G
parameter_list|,
name|mp_int
modifier|*
name|X
parameter_list|,
name|mp_int
modifier|*
name|P
parameter_list|,
name|mp_int
modifier|*
name|Y
parameter_list|,
name|int
name|redmode
parameter_list|)
block|{
name|mp_int
name|M
index|[
name|TAB_SIZE
index|]
decl_stmt|,
name|res
decl_stmt|,
name|mu
decl_stmt|;
name|mp_digit
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|,
name|bitbuf
decl_stmt|,
name|bitcpy
decl_stmt|,
name|bitcnt
decl_stmt|,
name|mode
decl_stmt|,
name|digidx
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|winsize
decl_stmt|;
name|int
function_decl|(
modifier|*
name|redux
function_decl|)
parameter_list|(
name|mp_int
modifier|*
parameter_list|,
name|mp_int
modifier|*
parameter_list|,
name|mp_int
modifier|*
parameter_list|)
function_decl|;
comment|/* find window size */
name|x
operator|=
name|mp_count_bits
argument_list|(
name|X
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|7
condition|)
block|{
name|winsize
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|36
condition|)
block|{
name|winsize
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|140
condition|)
block|{
name|winsize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|450
condition|)
block|{
name|winsize
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|1303
condition|)
block|{
name|winsize
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|3529
condition|)
block|{
name|winsize
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|winsize
operator|=
literal|8
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MP_LOW_MEM
if|if
condition|(
name|winsize
operator|>
literal|5
condition|)
block|{
name|winsize
operator|=
literal|5
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* init M array */
comment|/* init first cell */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|err
return|;
block|}
comment|/* now init the second half of the array */
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
for|for
control|(
name|y
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|y
operator|<
name|x
condition|;
name|y
operator|++
control|)
block|{
name|mp_clear
argument_list|(
operator|&
name|M
index|[
name|y
index|]
argument_list|)
expr_stmt|;
block|}
name|mp_clear
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
comment|/* create mu, used for Barrett reduction */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_M
goto|;
block|}
if|if
condition|(
name|redmode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_reduce_setup
argument_list|(
operator|&
name|mu
argument_list|,
name|P
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
name|redux
operator|=
name|mp_reduce
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_reduce_2k_setup_l
argument_list|(
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
name|redux
operator|=
name|mp_reduce_2k_l
expr_stmt|;
block|}
comment|/* create M table    *    * The M table contains powers of the base,     * e.g. M[x] = G**x mod P    *    * The first half of the table is not     * computed though accept for M[0] and M[1]    */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mod
argument_list|(
name|G
argument_list|,
name|P
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
comment|/* compute the value at M[1<<(winsize-1)] by squaring     * M[1] (winsize-1) times     */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_copy
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|winsize
operator|-
literal|1
operator|)
condition|;
name|x
operator|++
control|)
block|{
comment|/* square it */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
comment|/* reduce modulo P */
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
block|}
comment|/* create upper table, that is M[x] = M[x-1] * M[1] (mod P)    * for x = (2**(winsize - 1) + 1) to (2**winsize - 1)    */
for|for
control|(
name|x
operator|=
operator|(
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|M
index|[
name|x
operator|-
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
name|x
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
block|}
comment|/* setup result */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
name|mp_set
argument_list|(
operator|&
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set initial mode and bit cnt */
name|mode
operator|=
literal|0
expr_stmt|;
name|bitcnt
operator|=
literal|1
expr_stmt|;
name|buf
operator|=
literal|0
expr_stmt|;
name|digidx
operator|=
name|X
operator|->
name|used
operator|-
literal|1
expr_stmt|;
name|bitcpy
operator|=
literal|0
expr_stmt|;
name|bitbuf
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* grab next digit as required */
if|if
condition|(
operator|--
name|bitcnt
operator|==
literal|0
condition|)
block|{
comment|/* if digidx == -1 we are out of digits */
if|if
condition|(
name|digidx
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
comment|/* read next digit and reset the bitcnt */
name|buf
operator|=
name|X
operator|->
name|dp
index|[
name|digidx
operator|--
index|]
expr_stmt|;
name|bitcnt
operator|=
operator|(
name|int
operator|)
name|DIGIT_BIT
expr_stmt|;
block|}
comment|/* grab the next msb from the exponent */
name|y
operator|=
operator|(
name|buf
operator|>>
call|(
name|mp_digit
call|)
argument_list|(
name|DIGIT_BIT
operator|-
literal|1
argument_list|)
operator|)
operator|&
literal|1
expr_stmt|;
name|buf
operator|<<=
operator|(
name|mp_digit
operator|)
literal|1
expr_stmt|;
comment|/* if the bit is zero and mode == 0 then we ignore it      * These represent the leading zero bits before the first 1 bit      * in the exponent.  Technically this opt is not required but it      * does lower the # of trivial squaring/reductions used      */
if|if
condition|(
name|mode
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* if the bit is zero and mode == 1 then we square */
if|if
condition|(
name|mode
operator|==
literal|1
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
continue|continue;
block|}
comment|/* else we add it to the window */
name|bitbuf
operator||=
operator|(
name|y
operator|<<
operator|(
name|winsize
operator|-
operator|++
name|bitcpy
operator|)
operator|)
expr_stmt|;
name|mode
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|bitcpy
operator|==
name|winsize
condition|)
block|{
comment|/* ok window is filled so square as required and multiply  */
comment|/* square first */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|winsize
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
comment|/* then multiply */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|M
index|[
name|bitbuf
index|]
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
comment|/* empty window and reset */
name|bitcpy
operator|=
literal|0
expr_stmt|;
name|bitbuf
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* if bits remain then square/multiply */
if|if
condition|(
name|mode
operator|==
literal|2
operator|&&
name|bitcpy
operator|>
literal|0
condition|)
block|{
comment|/* square then multiply if the bit is set */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|bitcpy
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
name|bitbuf
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|bitbuf
operator|&
operator|(
literal|1
operator|<<
name|winsize
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* then multiply */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
block|}
block|}
name|mp_exch
argument_list|(
operator|&
name|res
argument_list|,
name|Y
argument_list|)
expr_stmt|;
name|err
operator|=
name|MP_OKAY
expr_stmt|;
name|LBL_RES
label|:
name|mp_clear
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|LBL_MU
label|:
name|mp_clear
argument_list|(
operator|&
name|mu
argument_list|)
expr_stmt|;
name|LBL_M
label|:
name|mp_clear
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
name|mp_clear
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* computes b = a*a */
end_comment

begin_function
specifier|static
name|int
name|mp_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
ifdef|#
directive|ifdef
name|BN_MP_TOOM_SQR_C
comment|/* use Toom-Cook? */
if|if
condition|(
name|a
operator|->
name|used
operator|>=
name|TOOM_SQR_CUTOFF
condition|)
block|{
name|res
operator|=
name|mp_toom_sqr
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Karatsuba? */
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_MP_KARATSUBA_SQR_C
if|if
condition|(
name|a
operator|->
name|used
operator|>=
name|KARATSUBA_SQR_CUTOFF
condition|)
block|{
name|res
operator|=
name|mp_karatsuba_sqr
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|BN_FAST_S_MP_SQR_C
comment|/* can we use the fast comba multiplier? */
if|if
condition|(
operator|(
name|a
operator|->
name|used
operator|*
literal|2
operator|+
literal|1
operator|)
operator|<
name|MP_WARRAY
operator|&&
name|a
operator|->
name|used
operator|<
operator|(
literal|1
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|mp_word
argument_list|)
operator|*
name|CHAR_BIT
operator|-
literal|2
operator|*
name|DIGIT_BIT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|res
operator|=
name|fast_s_mp_sqr
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BN_S_MP_SQR_C
name|res
operator|=
name|s_mp_sqr
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|mp_sqr could fail
name|res
operator|=
name|MP_VAL
expr_stmt|;
endif|#
directive|endif
block|}
name|b
operator|->
name|sign
operator|=
name|MP_ZPOS
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* reduces a modulo n where n is of the form 2**p - d     This differs from reduce_2k since "d" can be larger    than a single digit. */
end_comment

begin_function
specifier|static
name|int
name|mp_reduce_2k_l
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|n
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
block|{
name|mp_int
name|q
decl_stmt|;
name|int
name|p
decl_stmt|,
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init
argument_list|(
operator|&
name|q
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
name|p
operator|=
name|mp_count_bits
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|top
label|:
comment|/* q = a/2**p, a = a mod 2**p */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_div_2d
argument_list|(
name|a
argument_list|,
name|p
argument_list|,
operator|&
name|q
argument_list|,
name|a
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|ERR
goto|;
block|}
comment|/* q = q * d */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_mul
argument_list|(
operator|&
name|q
argument_list|,
name|d
argument_list|,
operator|&
name|q
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|ERR
goto|;
block|}
comment|/* a = a + q */
if|if
condition|(
operator|(
name|res
operator|=
name|s_mp_add
argument_list|(
name|a
argument_list|,
operator|&
name|q
argument_list|,
name|a
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|ERR
goto|;
block|}
if|if
condition|(
name|mp_cmp_mag
argument_list|(
name|a
argument_list|,
name|n
argument_list|)
operator|!=
name|MP_LT
condition|)
block|{
name|s_mp_sub
argument_list|(
name|a
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|ERR
label|:
name|mp_clear
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* determines the setup value */
end_comment

begin_function
specifier|static
name|int
name|mp_reduce_2k_setup_l
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|mp_int
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init
argument_list|(
operator|&
name|tmp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_2expt
argument_list|(
operator|&
name|tmp
argument_list|,
name|mp_count_bits
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|ERR
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|s_mp_sub
argument_list|(
operator|&
name|tmp
argument_list|,
name|a
argument_list|,
name|d
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|ERR
goto|;
block|}
name|ERR
label|:
name|mp_clear
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* computes a = 2**b   *  * Simple algorithm which zeroes the int, grows it then just sets one bit  * as required.  */
end_comment

begin_function
specifier|static
name|int
name|mp_2expt
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
comment|/* zero a as per default */
name|mp_zero
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* grow a to accomodate the single bit */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|a
argument_list|,
name|b
operator|/
name|DIGIT_BIT
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
comment|/* set the used count of where the bit will go */
name|a
operator|->
name|used
operator|=
name|b
operator|/
name|DIGIT_BIT
operator|+
literal|1
expr_stmt|;
comment|/* put the single bit in its place */
name|a
operator|->
name|dp
index|[
name|b
operator|/
name|DIGIT_BIT
index|]
operator|=
operator|(
operator|(
name|mp_digit
operator|)
literal|1
operator|)
operator|<<
operator|(
name|b
operator|%
name|DIGIT_BIT
operator|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* pre-calculate the value required for Barrett reduction  * For a given modulus "b" it calulates the value required in "a"  */
end_comment

begin_function
specifier|static
name|int
name|mp_reduce_setup
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_2expt
argument_list|(
name|a
argument_list|,
name|b
operator|->
name|used
operator|*
literal|2
operator|*
name|DIGIT_BIT
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
return|return
name|mp_div
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* reduces x mod m, assumes 0< x< m**2, mu is   * precomputed via mp_reduce_setup.  * From HAC pp.604 Algorithm 14.42  */
end_comment

begin_function
specifier|static
name|int
name|mp_reduce
parameter_list|(
name|mp_int
modifier|*
name|x
parameter_list|,
name|mp_int
modifier|*
name|m
parameter_list|,
name|mp_int
modifier|*
name|mu
parameter_list|)
block|{
name|mp_int
name|q
decl_stmt|;
name|int
name|res
decl_stmt|,
name|um
init|=
name|m
operator|->
name|used
decl_stmt|;
comment|/* q = x */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init_copy
argument_list|(
operator|&
name|q
argument_list|,
name|x
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
comment|/* q1 = x / b**(k-1)  */
name|mp_rshd
argument_list|(
operator|&
name|q
argument_list|,
name|um
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* according to HAC this optimization is ok */
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|um
operator|)
operator|>
operator|(
operator|(
operator|(
name|mp_digit
operator|)
literal|1
operator|)
operator|<<
operator|(
name|DIGIT_BIT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_mul
argument_list|(
operator|&
name|q
argument_list|,
name|mu
argument_list|,
operator|&
name|q
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BN_S_MP_MUL_HIGH_DIGS_C
if|if
condition|(
operator|(
name|res
operator|=
name|s_mp_mul_high_digs
argument_list|(
operator|&
name|q
argument_list|,
name|mu
argument_list|,
operator|&
name|q
argument_list|,
name|um
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|BN_FAST_S_MP_MUL_HIGH_DIGS_C
argument_list|)
if|if
condition|(
operator|(
name|res
operator|=
name|fast_s_mp_mul_high_digs
argument_list|(
operator|&
name|q
argument_list|,
name|mu
argument_list|,
operator|&
name|q
argument_list|,
name|um
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
else|#
directive|else
block|{
error|#
directive|error
error|mp_reduce would always fail
name|res
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|CLEANUP
goto|;
block|}
endif|#
directive|endif
block|}
comment|/* q3 = q2 / b**(k+1) */
name|mp_rshd
argument_list|(
operator|&
name|q
argument_list|,
name|um
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* x = x mod b**(k+1), quick (no division) */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_mod_2d
argument_list|(
name|x
argument_list|,
name|DIGIT_BIT
operator|*
operator|(
name|um
operator|+
literal|1
operator|)
argument_list|,
name|x
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
comment|/* q = q * m mod b**(k+1), quick (no division) */
if|if
condition|(
operator|(
name|res
operator|=
name|s_mp_mul_digs
argument_list|(
operator|&
name|q
argument_list|,
name|m
argument_list|,
operator|&
name|q
argument_list|,
name|um
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
comment|/* x = x - q */
if|if
condition|(
operator|(
name|res
operator|=
name|mp_sub
argument_list|(
name|x
argument_list|,
operator|&
name|q
argument_list|,
name|x
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
comment|/* If x< 0, add b**(k+1) to it */
if|if
condition|(
name|mp_cmp_d
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|MP_LT
condition|)
block|{
name|mp_set
argument_list|(
operator|&
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_lshd
argument_list|(
operator|&
name|q
argument_list|,
name|um
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_add
argument_list|(
name|x
argument_list|,
operator|&
name|q
argument_list|,
name|x
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
block|}
comment|/* Back off if it's too big */
while|while
condition|(
name|mp_cmp
argument_list|(
name|x
argument_list|,
name|m
argument_list|)
operator|!=
name|MP_LT
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|s_mp_sub
argument_list|(
name|x
argument_list|,
name|m
argument_list|,
name|x
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|CLEANUP
goto|;
block|}
block|}
name|CLEANUP
label|:
name|mp_clear
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* multiplies |a| * |b| and only computes upto digs digits of result  * HAC pp. 595, Algorithm 14.12  Modified so you can control how   * many digits of output are created.  */
end_comment

begin_function
specifier|static
name|int
name|s_mp_mul_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
block|{
name|mp_int
name|t
decl_stmt|;
name|int
name|res
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|mp_digit
name|u
decl_stmt|;
name|mp_word
name|r
decl_stmt|;
name|mp_digit
name|tmpx
decl_stmt|,
modifier|*
name|tmpt
decl_stmt|,
modifier|*
name|tmpy
decl_stmt|;
comment|/* can we use the fast multiplier? */
if|if
condition|(
operator|(
operator|(
name|digs
operator|)
operator|<
name|MP_WARRAY
operator|)
operator|&&
name|MIN
argument_list|(
name|a
operator|->
name|used
argument_list|,
name|b
operator|->
name|used
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
operator|(
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|mp_word
argument_list|)
operator|)
operator|-
operator|(
literal|2
operator|*
name|DIGIT_BIT
operator|)
operator|)
operator|)
condition|)
block|{
return|return
name|fast_s_mp_mul_digs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|digs
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init_size
argument_list|(
operator|&
name|t
argument_list|,
name|digs
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
name|t
operator|.
name|used
operator|=
name|digs
expr_stmt|;
comment|/* compute the digits of the product directly */
name|pa
operator|=
name|a
operator|->
name|used
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|pa
condition|;
name|ix
operator|++
control|)
block|{
comment|/* set the carry to zero */
name|u
operator|=
literal|0
expr_stmt|;
comment|/* limit ourselves to making digs digits of output */
name|pb
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|used
argument_list|,
name|digs
operator|-
name|ix
argument_list|)
expr_stmt|;
comment|/* setup some aliases */
comment|/* copy of the digit from a used within the nested loop */
name|tmpx
operator|=
name|a
operator|->
name|dp
index|[
name|ix
index|]
expr_stmt|;
comment|/* an alias for the destination shifted ix places */
name|tmpt
operator|=
name|t
operator|.
name|dp
operator|+
name|ix
expr_stmt|;
comment|/* an alias for the digits of b */
name|tmpy
operator|=
name|b
operator|->
name|dp
expr_stmt|;
comment|/* compute the columns of the output and propagate the carry */
for|for
control|(
name|iy
operator|=
literal|0
init|;
name|iy
operator|<
name|pb
condition|;
name|iy
operator|++
control|)
block|{
comment|/* compute the column as a mp_word */
name|r
operator|=
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpt
operator|)
operator|+
operator|(
operator|(
name|mp_word
operator|)
name|tmpx
operator|)
operator|*
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpy
operator|++
operator|)
operator|+
operator|(
operator|(
name|mp_word
operator|)
name|u
operator|)
expr_stmt|;
comment|/* the new column is the lower part of the result */
operator|*
name|tmpt
operator|++
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|&
operator|(
operator|(
name|mp_word
operator|)
name|MP_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* get the carry word from the result */
name|u
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|>>
operator|(
operator|(
name|mp_word
operator|)
name|DIGIT_BIT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* set carry if it is placed below digs */
if|if
condition|(
name|ix
operator|+
name|iy
operator|<
name|digs
condition|)
block|{
operator|*
name|tmpt
operator|=
name|u
expr_stmt|;
block|}
block|}
name|mp_clamp
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|mp_exch
argument_list|(
operator|&
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* Fast (comba) multiplier  *  * This is the fast column-array [comba] multiplier.  It is   * designed to compute the columns of the product first   * then handle the carries afterwards.  This has the effect   * of making the nested loops that compute the columns very  * simple and schedulable on super-scalar processors.  *  * This has been modified to produce a variable number of   * digits of output so if say only a half-product is required   * you don't have to compute the upper half (a feature   * required for fast Barrett reduction).  *  * Based on Algorithm 14.12 on pp.595 of HAC.  *  */
end_comment

begin_function
specifier|static
name|int
name|fast_s_mp_mul_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
block|{
name|int
name|olduse
decl_stmt|,
name|res
decl_stmt|,
name|pa
decl_stmt|,
name|ix
decl_stmt|,
name|iz
decl_stmt|;
name|mp_digit
name|W
index|[
name|MP_WARRAY
index|]
decl_stmt|;
specifier|register
name|mp_word
name|_W
decl_stmt|;
comment|/* grow the destination as required */
if|if
condition|(
name|c
operator|->
name|alloc
operator|<
name|digs
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|mp_grow
argument_list|(
name|c
argument_list|,
name|digs
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
block|}
comment|/* number of output digits to produce */
name|pa
operator|=
name|MIN
argument_list|(
name|digs
argument_list|,
name|a
operator|->
name|used
operator|+
name|b
operator|->
name|used
argument_list|)
expr_stmt|;
comment|/* clear the carry */
name|_W
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|pa
condition|;
name|ix
operator|++
control|)
block|{
name|int
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|int
name|iy
decl_stmt|;
name|mp_digit
modifier|*
name|tmpx
decl_stmt|,
modifier|*
name|tmpy
decl_stmt|;
comment|/* get offsets into the two bignums */
name|ty
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|used
operator|-
literal|1
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ix
operator|-
name|ty
expr_stmt|;
comment|/* setup temp aliases */
name|tmpx
operator|=
name|a
operator|->
name|dp
operator|+
name|tx
expr_stmt|;
name|tmpy
operator|=
name|b
operator|->
name|dp
operator|+
name|ty
expr_stmt|;
comment|/* this is the number of times the loop will iterrate, essentially           while (tx++< a->used&& ty-->= 0) { ... }        */
name|iy
operator|=
name|MIN
argument_list|(
name|a
operator|->
name|used
operator|-
name|tx
argument_list|,
name|ty
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* execute loop */
for|for
control|(
name|iz
operator|=
literal|0
init|;
name|iz
operator|<
name|iy
condition|;
operator|++
name|iz
control|)
block|{
name|_W
operator|+=
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpx
operator|++
operator|)
operator|*
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpy
operator|--
operator|)
expr_stmt|;
block|}
comment|/* store term */
name|W
index|[
name|ix
index|]
operator|=
operator|(
operator|(
name|mp_digit
operator|)
name|_W
operator|)
operator|&
name|MP_MASK
expr_stmt|;
comment|/* make next carry */
name|_W
operator|=
name|_W
operator|>>
operator|(
operator|(
name|mp_word
operator|)
name|DIGIT_BIT
operator|)
expr_stmt|;
block|}
comment|/* setup dest */
name|olduse
operator|=
name|c
operator|->
name|used
expr_stmt|;
name|c
operator|->
name|used
operator|=
name|pa
expr_stmt|;
block|{
specifier|register
name|mp_digit
modifier|*
name|tmpc
decl_stmt|;
name|tmpc
operator|=
name|c
operator|->
name|dp
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|pa
operator|+
literal|1
condition|;
name|ix
operator|++
control|)
block|{
comment|/* now extract the previous digit [below the carry] */
operator|*
name|tmpc
operator|++
operator|=
name|W
index|[
name|ix
index|]
expr_stmt|;
block|}
comment|/* clear unused digits [that existed in the old copy of c] */
for|for
control|(
init|;
name|ix
operator|<
name|olduse
condition|;
name|ix
operator|++
control|)
block|{
operator|*
name|tmpc
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mp_clamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* init an mp_init for a given size */
end_comment

begin_function
specifier|static
name|int
name|mp_init_size
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* pad size so there are always extra digits */
name|size
operator|+=
operator|(
name|MP_PREC
operator|*
literal|2
operator|)
operator|-
operator|(
name|size
operator|%
name|MP_PREC
operator|)
expr_stmt|;
comment|/* alloc mem */
name|a
operator|->
name|dp
operator|=
name|OPT_CAST
argument_list|(
argument|mp_digit
argument_list|)
name|XMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|mp_digit
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|dp
operator|==
name|NULL
condition|)
block|{
return|return
name|MP_MEM
return|;
block|}
comment|/* set the members */
name|a
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|alloc
operator|=
name|size
expr_stmt|;
name|a
operator|->
name|sign
operator|=
name|MP_ZPOS
expr_stmt|;
comment|/* zero the digits */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|size
condition|;
name|x
operator|++
control|)
block|{
name|a
operator|->
name|dp
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* low level squaring, b = a*a, HAC pp.596-597, Algorithm 14.16 */
end_comment

begin_function
specifier|static
name|int
name|s_mp_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
block|{
name|mp_int
name|t
decl_stmt|;
name|int
name|res
decl_stmt|,
name|ix
decl_stmt|,
name|iy
decl_stmt|,
name|pa
decl_stmt|;
name|mp_word
name|r
decl_stmt|;
name|mp_digit
name|u
decl_stmt|,
name|tmpx
decl_stmt|,
modifier|*
name|tmpt
decl_stmt|;
name|pa
operator|=
name|a
operator|->
name|used
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init_size
argument_list|(
operator|&
name|t
argument_list|,
literal|2
operator|*
name|pa
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
comment|/* default used is maximum possible size */
name|t
operator|.
name|used
operator|=
literal|2
operator|*
name|pa
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|pa
condition|;
name|ix
operator|++
control|)
block|{
comment|/* first calculate the digit at 2*ix */
comment|/* calculate double precision result */
name|r
operator|=
operator|(
operator|(
name|mp_word
operator|)
name|t
operator|.
name|dp
index|[
literal|2
operator|*
name|ix
index|]
operator|)
operator|+
operator|(
operator|(
name|mp_word
operator|)
name|a
operator|->
name|dp
index|[
name|ix
index|]
operator|)
operator|*
operator|(
operator|(
name|mp_word
operator|)
name|a
operator|->
name|dp
index|[
name|ix
index|]
operator|)
expr_stmt|;
comment|/* store lower part in result */
name|t
operator|.
name|dp
index|[
name|ix
operator|+
name|ix
index|]
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|&
operator|(
operator|(
name|mp_word
operator|)
name|MP_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* get the carry */
name|u
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|>>
operator|(
operator|(
name|mp_word
operator|)
name|DIGIT_BIT
operator|)
argument_list|)
expr_stmt|;
comment|/* left hand side of A[ix] * A[iy] */
name|tmpx
operator|=
name|a
operator|->
name|dp
index|[
name|ix
index|]
expr_stmt|;
comment|/* alias for where to store the results */
name|tmpt
operator|=
name|t
operator|.
name|dp
operator|+
operator|(
literal|2
operator|*
name|ix
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|iy
operator|=
name|ix
operator|+
literal|1
init|;
name|iy
operator|<
name|pa
condition|;
name|iy
operator|++
control|)
block|{
comment|/* first calculate the product */
name|r
operator|=
operator|(
operator|(
name|mp_word
operator|)
name|tmpx
operator|)
operator|*
operator|(
operator|(
name|mp_word
operator|)
name|a
operator|->
name|dp
index|[
name|iy
index|]
operator|)
expr_stmt|;
comment|/* now calculate the double precision result, note we use        * addition instead of *2 since it's easier to optimize        */
name|r
operator|=
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpt
operator|)
operator|+
name|r
operator|+
name|r
operator|+
operator|(
operator|(
name|mp_word
operator|)
name|u
operator|)
expr_stmt|;
comment|/* store lower part */
operator|*
name|tmpt
operator|++
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|&
operator|(
operator|(
name|mp_word
operator|)
name|MP_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* get carry */
name|u
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|>>
operator|(
operator|(
name|mp_word
operator|)
name|DIGIT_BIT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* propagate upwards */
while|while
condition|(
name|u
operator|!=
operator|(
operator|(
name|mp_digit
operator|)
literal|0
operator|)
condition|)
block|{
name|r
operator|=
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpt
operator|)
operator|+
operator|(
operator|(
name|mp_word
operator|)
name|u
operator|)
expr_stmt|;
operator|*
name|tmpt
operator|++
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|&
operator|(
operator|(
name|mp_word
operator|)
name|MP_MASK
operator|)
argument_list|)
expr_stmt|;
name|u
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|>>
operator|(
operator|(
name|mp_word
operator|)
name|DIGIT_BIT
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mp_clamp
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|mp_exch
argument_list|(
operator|&
name|t
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

begin_comment
comment|/* multiplies |a| * |b| and does not compute the lower digs digits  * [meant to get the higher part of the product]  */
end_comment

begin_function
specifier|static
name|int
name|s_mp_mul_high_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
block|{
name|mp_int
name|t
decl_stmt|;
name|int
name|res
decl_stmt|,
name|pa
decl_stmt|,
name|pb
decl_stmt|,
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|mp_digit
name|u
decl_stmt|;
name|mp_word
name|r
decl_stmt|;
name|mp_digit
name|tmpx
decl_stmt|,
modifier|*
name|tmpt
decl_stmt|,
modifier|*
name|tmpy
decl_stmt|;
comment|/* can we use the fast multiplier? */
ifdef|#
directive|ifdef
name|BN_FAST_S_MP_MUL_HIGH_DIGS_C
if|if
condition|(
operator|(
operator|(
name|a
operator|->
name|used
operator|+
name|b
operator|->
name|used
operator|+
literal|1
operator|)
operator|<
name|MP_WARRAY
operator|)
operator|&&
name|MIN
argument_list|(
name|a
operator|->
name|used
argument_list|,
name|b
operator|->
name|used
argument_list|)
operator|<
operator|(
literal|1
operator|<<
operator|(
operator|(
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|mp_word
argument_list|)
operator|)
operator|-
operator|(
literal|2
operator|*
name|DIGIT_BIT
operator|)
operator|)
operator|)
condition|)
block|{
return|return
name|fast_s_mp_mul_high_digs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|digs
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|res
operator|=
name|mp_init_size
argument_list|(
operator|&
name|t
argument_list|,
name|a
operator|->
name|used
operator|+
name|b
operator|->
name|used
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|res
return|;
block|}
name|t
operator|.
name|used
operator|=
name|a
operator|->
name|used
operator|+
name|b
operator|->
name|used
operator|+
literal|1
expr_stmt|;
name|pa
operator|=
name|a
operator|->
name|used
expr_stmt|;
name|pb
operator|=
name|b
operator|->
name|used
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|pa
condition|;
name|ix
operator|++
control|)
block|{
comment|/* clear the carry */
name|u
operator|=
literal|0
expr_stmt|;
comment|/* left hand side of A[ix] * B[iy] */
name|tmpx
operator|=
name|a
operator|->
name|dp
index|[
name|ix
index|]
expr_stmt|;
comment|/* alias to the address of where the digits will be stored */
name|tmpt
operator|=
operator|&
operator|(
name|t
operator|.
name|dp
index|[
name|digs
index|]
operator|)
expr_stmt|;
comment|/* alias for where to read the right hand side from */
name|tmpy
operator|=
name|b
operator|->
name|dp
operator|+
operator|(
name|digs
operator|-
name|ix
operator|)
expr_stmt|;
for|for
control|(
name|iy
operator|=
name|digs
operator|-
name|ix
init|;
name|iy
operator|<
name|pb
condition|;
name|iy
operator|++
control|)
block|{
comment|/* calculate the double precision result */
name|r
operator|=
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpt
operator|)
operator|+
operator|(
operator|(
name|mp_word
operator|)
name|tmpx
operator|)
operator|*
operator|(
operator|(
name|mp_word
operator|)
operator|*
name|tmpy
operator|++
operator|)
operator|+
operator|(
operator|(
name|mp_word
operator|)
name|u
operator|)
expr_stmt|;
comment|/* get the lower part */
operator|*
name|tmpt
operator|++
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|&
operator|(
operator|(
name|mp_word
operator|)
name|MP_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* carry the carry */
name|u
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|r
operator|>>
operator|(
operator|(
name|mp_word
operator|)
name|DIGIT_BIT
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|tmpt
operator|=
name|u
expr_stmt|;
block|}
name|mp_clamp
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|mp_exch
argument_list|(
operator|&
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|mp_clear
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|MP_OKAY
return|;
block|}
end_function

end_unit

