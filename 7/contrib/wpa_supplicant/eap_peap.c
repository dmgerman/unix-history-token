begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * EAP peer method: EAP-PEAP (draft-josefsson-pppext-eap-tls-eap-07.txt)  * Copyright (c) 2004-2006, Jouni Malinen<j@w1.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_include
include|#
directive|include
file|"eap_tls_common.h"
end_include

begin_include
include|#
directive|include
file|"config_ssid.h"
end_include

begin_include
include|#
directive|include
file|"tls.h"
end_include

begin_include
include|#
directive|include
file|"eap_tlv.h"
end_include

begin_comment
comment|/* Maximum supported PEAP version  * 0 = Microsoft's PEAP version 0; draft-kamath-pppext-peapv0-00.txt  * 1 = draft-josefsson-ppext-eap-tls-eap-05.txt  * 2 = draft-josefsson-ppext-eap-tls-eap-07.txt  */
end_comment

begin_define
define|#
directive|define
name|EAP_PEAP_VERSION
value|1
end_define

begin_function_decl
specifier|static
name|void
name|eap_peap_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|eap_peap_data
block|{
name|struct
name|eap_ssl_data
name|ssl
decl_stmt|;
name|int
name|peap_version
decl_stmt|,
name|force_peap_version
decl_stmt|,
name|force_new_label
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|phase2_method
decl_stmt|;
name|void
modifier|*
name|phase2_priv
decl_stmt|;
name|int
name|phase2_success
decl_stmt|;
name|int
name|phase2_eap_success
decl_stmt|;
name|int
name|phase2_eap_started
decl_stmt|;
name|struct
name|eap_method_type
name|phase2_type
decl_stmt|;
name|struct
name|eap_method_type
modifier|*
name|phase2_types
decl_stmt|;
name|size_t
name|num_phase2_types
decl_stmt|;
name|int
name|peap_outer_success
decl_stmt|;
comment|/* 0 = PEAP terminated on Phase 2 inner 				 * EAP-Success 				 * 1 = reply with tunneled EAP-Success to inner 				 * EAP-Success and expect AS to send outer 				 * (unencrypted) EAP-Success after this 				 * 2 = reply with PEAP/TLS ACK to inner 				 * EAP-Success and expect AS to send outer 				 * (unencrypted) EAP-Success after this */
name|int
name|resuming
decl_stmt|;
comment|/* starting a resumed session */
name|u8
modifier|*
name|key_data
decl_stmt|;
name|u8
modifier|*
name|pending_phase2_req
decl_stmt|;
name|size_t
name|pending_phase2_req_len
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
modifier|*
name|eap_peap_init
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|data
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sm
operator|->
name|peap_done
operator|=
name|FALSE
expr_stmt|;
name|data
operator|->
name|peap_version
operator|=
name|EAP_PEAP_VERSION
expr_stmt|;
name|data
operator|->
name|force_peap_version
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|->
name|peap_outer_success
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|config
operator|&&
name|config
operator|->
name|phase1
condition|)
block|{
name|char
modifier|*
name|pos
init|=
name|os_strstr
argument_list|(
name|config
operator|->
name|phase1
argument_list|,
literal|"peapver="
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
condition|)
block|{
name|data
operator|->
name|force_peap_version
operator|=
name|atoi
argument_list|(
name|pos
operator|+
literal|8
argument_list|)
expr_stmt|;
name|data
operator|->
name|peap_version
operator|=
name|data
operator|->
name|force_peap_version
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Forced PEAP version "
literal|"%d"
argument_list|,
name|data
operator|->
name|force_peap_version
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|os_strstr
argument_list|(
name|config
operator|->
name|phase1
argument_list|,
literal|"peaplabel=1"
argument_list|)
condition|)
block|{
name|data
operator|->
name|force_new_label
operator|=
literal|1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Force new label for "
literal|"key derivation"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|os_strstr
argument_list|(
name|config
operator|->
name|phase1
argument_list|,
literal|"peap_outer_success=0"
argument_list|)
condition|)
block|{
name|data
operator|->
name|peap_outer_success
operator|=
literal|0
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: terminate "
literal|"authentication on tunneled EAP-Success"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|config
operator|->
name|phase1
argument_list|,
literal|"peap_outer_success=1"
argument_list|)
condition|)
block|{
name|data
operator|->
name|peap_outer_success
operator|=
literal|1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: send tunneled "
literal|"EAP-Success after receiving tunneled "
literal|"EAP-Success"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os_strstr
argument_list|(
name|config
operator|->
name|phase1
argument_list|,
literal|"peap_outer_success=2"
argument_list|)
condition|)
block|{
name|data
operator|->
name|peap_outer_success
operator|=
literal|2
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: send PEAP/TLS ACK "
literal|"after receiving tunneled EAP-Success"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|config
operator|&&
name|config
operator|->
name|phase2
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|pos
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|struct
name|eap_method_type
modifier|*
name|methods
init|=
name|NULL
decl_stmt|,
modifier|*
name|_methods
decl_stmt|;
name|u8
name|method
decl_stmt|;
name|size_t
name|num_methods
init|=
literal|0
decl_stmt|;
name|start
operator|=
name|buf
operator|=
name|os_strdup
argument_list|(
name|config
operator|->
name|phase2
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|eap_peap_deinit
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|start
operator|&&
operator|*
name|start
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|vendor
decl_stmt|;
name|pos
operator|=
name|os_strstr
argument_list|(
name|start
argument_list|,
literal|"auth="
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|start
operator|!=
name|pos
operator|&&
operator|*
operator|(
name|pos
operator|-
literal|1
operator|)
operator|!=
literal|' '
condition|)
block|{
name|start
operator|=
name|pos
operator|+
literal|5
expr_stmt|;
continue|continue;
block|}
name|start
operator|=
name|pos
operator|+
literal|5
expr_stmt|;
name|pos
operator|=
name|os_strchr
argument_list|(
name|start
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
condition|)
operator|*
name|pos
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|method
operator|=
name|eap_get_phase2_type
argument_list|(
name|start
argument_list|,
operator|&
name|vendor
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|method
operator|==
name|EAP_TYPE_NONE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"EAP-PEAP: Unsupported "
literal|"Phase2 method '%s'"
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num_methods
operator|++
expr_stmt|;
name|_methods
operator|=
name|os_realloc
argument_list|(
name|methods
argument_list|,
name|num_methods
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_methods
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|eap_peap_deinit
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|methods
operator|=
name|_methods
expr_stmt|;
name|methods
index|[
name|num_methods
operator|-
literal|1
index|]
operator|.
name|vendor
operator|=
name|vendor
expr_stmt|;
name|methods
index|[
name|num_methods
operator|-
literal|1
index|]
operator|.
name|method
operator|=
name|method
expr_stmt|;
block|}
name|start
operator|=
name|pos
expr_stmt|;
block|}
name|os_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|data
operator|->
name|phase2_types
operator|=
name|methods
expr_stmt|;
name|data
operator|->
name|num_phase2_types
operator|=
name|num_methods
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|phase2_types
operator|==
name|NULL
condition|)
block|{
name|data
operator|->
name|phase2_types
operator|=
name|eap_get_phase2_types
argument_list|(
name|config
argument_list|,
operator|&
name|data
operator|->
name|num_phase2_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|phase2_types
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"EAP-PEAP: No Phase2 method available"
argument_list|)
expr_stmt|;
name|eap_peap_deinit
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase2 EAP types"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|data
operator|->
name|phase2_types
argument_list|,
name|data
operator|->
name|num_phase2_types
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eap_method_type
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|phase2_type
operator|.
name|vendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|eap_tls_ssl_init
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|config
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Failed to initialize SSL."
argument_list|)
expr_stmt|;
name|eap_peap_deinit
argument_list|(
name|sm
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peap_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|&&
name|data
operator|->
name|phase2_method
condition|)
name|data
operator|->
name|phase2_method
operator|->
name|deinit
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|phase2_types
argument_list|)
expr_stmt|;
name|eap_tls_ssl_deinit
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|key_data
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_encrypt
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|int
name|id
parameter_list|,
specifier|const
name|u8
modifier|*
name|plain
parameter_list|,
name|size_t
name|plain_len
parameter_list|,
name|u8
modifier|*
modifier|*
name|out_data
parameter_list|,
name|size_t
modifier|*
name|out_len
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
comment|/* TODO: add support for fragmentation, if needed. This will need to 	 * add TLS Message Length field, if the frame is fragmented. 	 * Note: Microsoft IAS did not seem to like TLS Message Length with 	 * PEAP/MSCHAPv2. */
name|resp
operator|=
name|os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|2
operator|+
name|data
operator|->
name|ssl
operator|.
name|tls_out_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_PEAP
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|data
operator|->
name|peap_version
expr_stmt|;
name|res
operator|=
name|tls_connection_encrypt
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|,
name|plain
argument_list|,
name|plain_len
argument_list|,
name|pos
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|tls_out_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Failed to encrypt Phase 2 "
literal|"data"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|out_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|2
operator|+
name|res
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|out_len
argument_list|)
expr_stmt|;
operator|*
name|out_data
operator|=
operator|(
name|u8
operator|*
operator|)
name|resp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_phase2_nak
parameter_list|(
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|struct
name|eap_hdr
modifier|*
name|hdr
parameter_list|,
name|u8
modifier|*
modifier|*
name|resp
parameter_list|,
name|size_t
modifier|*
name|resp_len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|resp_hdr
decl_stmt|;
name|u8
modifier|*
name|pos
init|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* TODO: add support for expanded Nak */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 Request: Nak type=%d"
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Allowed Phase2 EAP types"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|data
operator|->
name|phase2_types
argument_list|,
name|data
operator|->
name|num_phase2_types
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eap_method_type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|resp_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|resp
operator|=
name|os_malloc
argument_list|(
operator|*
name|resp_len
operator|+
name|data
operator|->
name|num_phase2_types
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|resp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|resp_hdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
operator|(
operator|*
name|resp
operator|)
expr_stmt|;
name|resp_hdr
operator|->
name|code
operator|=
name|EAP_CODE_RESPONSE
expr_stmt|;
name|resp_hdr
operator|->
name|identifier
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|resp_hdr
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|EAP_TYPE_NAK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|num_phase2_types
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|method
operator|<
literal|256
condition|)
block|{
operator|(
operator|*
name|resp_len
operator|)
operator|++
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|method
expr_stmt|;
block|}
block|}
name|resp_hdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
operator|*
name|resp_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_phase2_request
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|struct
name|eap_method_ret
modifier|*
name|ret
parameter_list|,
name|struct
name|eap_hdr
modifier|*
name|hdr
parameter_list|,
name|u8
modifier|*
modifier|*
name|resp
parameter_list|,
name|size_t
modifier|*
name|resp_len
parameter_list|)
block|{
name|size_t
name|len
init|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|struct
name|eap_method_ret
name|iret
decl_stmt|;
name|struct
name|wpa_ssid
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: too short "
literal|"Phase 2 request (len=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 Request: type=%d"
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|pos
condition|)
block|{
case|case
name|EAP_TYPE_IDENTITY
case|:
operator|*
name|resp
operator|=
name|eap_sm_buildIdentity
argument_list|(
name|sm
argument_list|,
name|hdr
operator|->
name|identifier
argument_list|,
name|resp_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_TYPE_TLV
case|:
name|os_memset
argument_list|(
operator|&
name|iret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_tlv_process
argument_list|(
name|sm
argument_list|,
operator|&
name|iret
argument_list|,
name|hdr
argument_list|,
name|resp
argument_list|,
name|resp_len
argument_list|,
name|data
operator|->
name|phase2_eap_started
operator|&&
operator|!
name|data
operator|->
name|phase2_eap_success
argument_list|)
condition|)
block|{
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iret
operator|.
name|methodState
operator|==
name|METHOD_DONE
operator|||
name|iret
operator|.
name|methodState
operator|==
name|METHOD_MAY_CONT
condition|)
block|{
name|ret
operator|->
name|methodState
operator|=
name|iret
operator|.
name|methodState
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|iret
operator|.
name|decision
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|data
operator|->
name|phase2_type
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|==
name|EAP_TYPE_NONE
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|num_phase2_types
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|method
operator|!=
operator|*
name|pos
condition|)
continue|continue;
name|data
operator|->
name|phase2_type
operator|.
name|vendor
operator|=
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|vendor
expr_stmt|;
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|=
name|data
operator|->
name|phase2_types
index|[
name|i
index|]
operator|.
name|method
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Selected "
literal|"Phase 2 EAP vendor %d method %d"
argument_list|,
name|data
operator|->
name|phase2_type
operator|.
name|vendor
argument_list|,
name|data
operator|->
name|phase2_type
operator|.
name|method
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|pos
operator|!=
name|data
operator|->
name|phase2_type
operator|.
name|method
operator|||
operator|*
name|pos
operator|==
name|EAP_TYPE_NONE
condition|)
block|{
if|if
condition|(
name|eap_peap_phase2_nak
argument_list|(
name|data
argument_list|,
name|hdr
argument_list|,
name|resp
argument_list|,
name|resp_len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|==
name|NULL
condition|)
block|{
name|data
operator|->
name|phase2_method
operator|=
name|eap_sm_get_eap_methods
argument_list|(
name|data
operator|->
name|phase2_type
operator|.
name|vendor
argument_list|,
name|data
operator|->
name|phase2_type
operator|.
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|phase2_method
condition|)
block|{
name|sm
operator|->
name|init_phase2
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|phase2_priv
operator|=
name|data
operator|->
name|phase2_method
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|init_phase2
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|==
name|NULL
operator|||
name|data
operator|->
name|phase2_method
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: failed to initialize "
literal|"Phase 2 EAP method %d"
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|data
operator|->
name|phase2_eap_started
operator|=
literal|1
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|iret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iret
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|resp
operator|=
name|data
operator|->
name|phase2_method
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|,
operator|&
name|iret
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|hdr
argument_list|,
name|len
argument_list|,
name|resp_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iret
operator|.
name|methodState
operator|==
name|METHOD_DONE
operator|||
name|iret
operator|.
name|methodState
operator|==
name|METHOD_MAY_CONT
operator|)
operator|&&
operator|(
name|iret
operator|.
name|decision
operator|==
name|DECISION_UNCOND_SUCC
operator|||
name|iret
operator|.
name|decision
operator|==
name|DECISION_COND_SUCC
operator|)
condition|)
block|{
name|data
operator|->
name|phase2_eap_success
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|resp
operator|==
name|NULL
operator|&&
operator|(
name|config
operator|->
name|pending_req_identity
operator|||
name|config
operator|->
name|pending_req_password
operator|||
name|config
operator|->
name|pending_req_otp
operator|||
name|config
operator|->
name|pending_req_new_password
operator|)
condition|)
block|{
name|os_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|os_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|pending_phase2_req
condition|)
block|{
name|os_memcpy
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|,
name|hdr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_phase2_req_len
operator|=
name|len
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_decrypt
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peap_data
modifier|*
name|data
parameter_list|,
name|struct
name|eap_method_ret
modifier|*
name|ret
parameter_list|,
specifier|const
name|struct
name|eap_hdr
modifier|*
name|req
parameter_list|,
specifier|const
name|u8
modifier|*
name|in_data
parameter_list|,
name|size_t
name|in_len
parameter_list|,
name|u8
modifier|*
modifier|*
name|out_data
parameter_list|,
name|size_t
modifier|*
name|out_len
parameter_list|)
block|{
name|u8
modifier|*
name|in_decrypted
decl_stmt|;
name|int
name|res
decl_stmt|,
name|skip_change
init|=
literal|0
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|rhdr
decl_stmt|;
name|u8
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|size_t
name|resp_len
decl_stmt|,
name|len_decrypted
decl_stmt|,
name|len
decl_stmt|,
name|buf_len
decl_stmt|;
specifier|const
name|u8
modifier|*
name|msg
decl_stmt|;
name|size_t
name|msg_len
decl_stmt|;
name|int
name|need_more_input
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: received %lu bytes encrypted data for"
literal|" Phase 2"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|in_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|pending_phase2_req
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Pending Phase 2 request - "
literal|"skip decryption and use old data"
argument_list|)
expr_stmt|;
comment|/* Clear TLS reassembly state. */
name|os_free
argument_list|(
name|data
operator|->
name|ssl
operator|.
name|tls_in
argument_list|)
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in_len
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in_left
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in_total
operator|=
literal|0
expr_stmt|;
name|in_decrypted
operator|=
name|data
operator|->
name|pending_phase2_req
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|NULL
expr_stmt|;
name|len_decrypted
operator|=
name|data
operator|->
name|pending_phase2_req_len
expr_stmt|;
name|skip_change
operator|=
literal|1
expr_stmt|;
goto|goto
name|continue_req
goto|;
block|}
name|msg
operator|=
name|eap_tls_data_reassemble
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|in_data
argument_list|,
name|in_len
argument_list|,
operator|&
name|msg_len
argument_list|,
operator|&
name|need_more_input
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|need_more_input
condition|?
literal|1
else|:
operator|-
literal|1
return|;
if|if
condition|(
name|in_len
operator|==
literal|0
operator|&&
name|sm
operator|->
name|workaround
operator|&&
name|data
operator|->
name|phase2_success
condition|)
block|{
comment|/* 		 * Cisco ACS seems to be using TLS ACK to terminate 		 * EAP-PEAPv0/GTC. Try to reply with TLS ACK. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Received TLS ACK, but "
literal|"expected data - acknowledge with TLS ACK since "
literal|"Phase 2 has been completed"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
return|return
literal|1
return|;
block|}
name|buf_len
operator|=
name|in_len
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ssl
operator|.
name|tls_in_total
operator|>
name|buf_len
condition|)
name|buf_len
operator|=
name|data
operator|->
name|ssl
operator|.
name|tls_in_total
expr_stmt|;
name|in_decrypted
operator|=
name|os_malloc
argument_list|(
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decrypted
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|data
operator|->
name|ssl
operator|.
name|tls_in
argument_list|)
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in_len
operator|=
literal|0
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP-PEAP: failed to allocate memory "
literal|"for decryption"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|res
operator|=
name|tls_connection_decrypt
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|,
name|msg
argument_list|,
name|msg_len
argument_list|,
name|in_decrypted
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|ssl
operator|.
name|tls_in
argument_list|)
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|ssl
operator|.
name|tls_in_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Failed to decrypt Phase 2 "
literal|"data"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len_decrypted
operator|=
name|res
expr_stmt|;
name|continue_req
label|:
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Decrypted Phase 2 EAP"
argument_list|,
name|in_decrypted
argument_list|,
name|len_decrypted
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|in_decrypted
expr_stmt|;
if|if
condition|(
name|len_decrypted
operator|==
literal|5
operator|&&
name|hdr
operator|->
name|code
operator|==
name|EAP_CODE_REQUEST
operator|&&
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|==
literal|5
operator|&&
name|in_decrypted
index|[
literal|4
index|]
operator|==
name|EAP_TYPE_IDENTITY
condition|)
block|{
comment|/* At least FreeRADIUS seems to send full EAP header with 		 * EAP Request Identity */
name|skip_change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len_decrypted
operator|>=
literal|5
operator|&&
name|hdr
operator|->
name|code
operator|==
name|EAP_CODE_REQUEST
operator|&&
name|in_decrypted
index|[
literal|4
index|]
operator|==
name|EAP_TYPE_TLV
condition|)
block|{
name|skip_change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|peap_version
operator|==
literal|0
operator|&&
operator|!
name|skip_change
condition|)
block|{
name|struct
name|eap_hdr
modifier|*
name|nhdr
init|=
name|os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
name|len_decrypted
argument_list|)
decl_stmt|;
if|if
condition|(
name|nhdr
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|os_memcpy
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|nhdr
operator|+
literal|1
operator|)
argument_list|,
name|in_decrypted
argument_list|,
name|len_decrypted
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|nhdr
operator|->
name|code
operator|=
name|req
operator|->
name|code
expr_stmt|;
name|nhdr
operator|->
name|identifier
operator|=
name|req
operator|->
name|identifier
expr_stmt|;
name|nhdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
name|len_decrypted
argument_list|)
expr_stmt|;
name|len_decrypted
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
expr_stmt|;
name|in_decrypted
operator|=
operator|(
name|u8
operator|*
operator|)
name|nhdr
expr_stmt|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|in_decrypted
expr_stmt|;
if|if
condition|(
name|len_decrypted
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Too short Phase 2 "
literal|"EAP frame (len=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|len_decrypted
condition|)
block|{
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Length mismatch in "
literal|"Phase 2 EAP frame (len=%lu hdr->length=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len_decrypted
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|<
name|len_decrypted
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Odd.. Phase 2 EAP header has "
literal|"shorter length than full decrypted data "
literal|"(%lu< %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len_decrypted
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|len
operator|==
literal|4
operator|&&
name|len_decrypted
operator|==
literal|5
operator|&&
name|in_decrypted
index|[
literal|4
index|]
operator|==
name|EAP_TYPE_IDENTITY
condition|)
block|{
comment|/* Radiator 3.9 seems to set Phase 2 EAP header to use 			 * incorrect length for the EAP-Request Identity 			 * packet, so fix the inner header to interoperate.. 			 * This was fixed in 2004-06-23 patch for Radiator and 			 * this workaround can be removed at some point. */
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: workaround -> replace "
literal|"Phase 2 EAP header len (%lu) with real "
literal|"decrypted len (%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len_decrypted
argument_list|)
expr_stmt|;
name|len
operator|=
name|len_decrypted
expr_stmt|;
name|hdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: received Phase 2: code=%d "
literal|"identifier=%d length=%lu"
argument_list|,
name|hdr
operator|->
name|code
argument_list|,
name|hdr
operator|->
name|identifier
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|code
condition|)
block|{
case|case
name|EAP_CODE_REQUEST
case|:
if|if
condition|(
name|eap_peap_phase2_request
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|ret
argument_list|,
name|hdr
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|resp_len
argument_list|)
condition|)
block|{
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Phase2 Request "
literal|"processing failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|EAP_CODE_SUCCESS
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 Success"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|peap_version
operator|==
literal|1
condition|)
block|{
comment|/* EAP-Success within TLS tunnel is used to indicate 			 * shutdown of the TLS channel. The authentication has 			 * been completed. */
if|if
condition|(
name|data
operator|->
name|phase2_eap_started
operator|&&
operator|!
name|data
operator|->
name|phase2_eap_success
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 "
literal|"Success used to indicate success, "
literal|"but Phase 2 EAP was not yet "
literal|"completed successfully"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Version 1 - "
literal|"EAP-Success within TLS tunnel - "
literal|"authentication completed"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_UNCOND_SUCC
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|peap_outer_success
operator|==
literal|2
condition|)
block|{
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Use TLS ACK "
literal|"to finish authentication"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|peap_outer_success
operator|==
literal|1
condition|)
block|{
comment|/* Reply with EAP-Success within the TLS 				 * channel to complete the authentication. */
name|resp_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
expr_stmt|;
name|resp
operator|=
name|os_zalloc
argument_list|(
name|resp_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|rhdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|resp
expr_stmt|;
name|rhdr
operator|->
name|code
operator|=
name|EAP_CODE_SUCCESS
expr_stmt|;
name|rhdr
operator|->
name|identifier
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
name|rhdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
name|resp_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No EAP-Success expected for Phase 1 (outer, 				 * unencrypted auth), so force EAP state 				 * machine to SUCCESS state. */
name|sm
operator|->
name|peap_done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* FIX: ? */
block|}
break|break;
case|case
name|EAP_CODE_FAILURE
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Phase 2 Failure"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_MAY_CONT
expr_stmt|;
name|ret
operator|->
name|allowNotifications
operator|=
name|FALSE
expr_stmt|;
comment|/* Reply with EAP-Failure within the TLS channel to complete 		 * failure reporting. */
name|resp_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
expr_stmt|;
name|resp
operator|=
name|os_zalloc
argument_list|(
name|resp_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|rhdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|resp
expr_stmt|;
name|rhdr
operator|->
name|code
operator|=
name|EAP_CODE_FAILURE
expr_stmt|;
name|rhdr
operator|->
name|identifier
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
name|rhdr
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
name|resp_len
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Unexpected code=%d in "
literal|"Phase 2 EAP header"
argument_list|,
name|hdr
operator|->
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
name|os_free
argument_list|(
name|in_decrypted
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|u8
modifier|*
name|resp_pos
decl_stmt|;
name|size_t
name|resp_send_len
decl_stmt|;
name|int
name|skip_change2
init|=
literal|0
decl_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Encrypting Phase 2 data"
argument_list|,
name|resp
argument_list|,
name|resp_len
argument_list|)
expr_stmt|;
comment|/* PEAP version changes */
if|if
condition|(
name|resp_len
operator|>=
literal|5
operator|&&
name|resp
index|[
literal|0
index|]
operator|==
name|EAP_CODE_RESPONSE
operator|&&
name|resp
index|[
literal|4
index|]
operator|==
name|EAP_TYPE_TLV
condition|)
name|skip_change2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|peap_version
operator|==
literal|0
operator|&&
operator|!
name|skip_change2
condition|)
block|{
name|resp_pos
operator|=
name|resp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
expr_stmt|;
name|resp_send_len
operator|=
name|resp_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resp_pos
operator|=
name|resp
expr_stmt|;
name|resp_send_len
operator|=
name|resp_len
expr_stmt|;
block|}
if|if
condition|(
name|eap_peap_encrypt
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|req
operator|->
name|identifier
argument_list|,
name|resp_pos
argument_list|,
name|resp_send_len
argument_list|,
name|out_data
argument_list|,
name|out_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP-PEAP: Failed to encrypt "
literal|"a Phase 2 frame"
argument_list|)
expr_stmt|;
block|}
name|os_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_peap_process
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|struct
name|eap_method_ret
modifier|*
name|ret
parameter_list|,
specifier|const
name|u8
modifier|*
name|reqData
parameter_list|,
name|size_t
name|reqDataLen
parameter_list|,
name|size_t
modifier|*
name|respDataLen
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|req
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|int
name|res
decl_stmt|;
name|u8
name|flags
decl_stmt|,
modifier|*
name|resp
decl_stmt|,
name|id
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|pos
operator|=
name|eap_tls_process_init
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|ret
argument_list|,
name|reqData
argument_list|,
name|reqDataLen
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|req
operator|=
operator|(
specifier|const
expr|struct
name|eap_hdr
operator|*
operator|)
name|reqData
expr_stmt|;
name|id
operator|=
name|req
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EAP_TLS_FLAGS_START
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Start (server ver=%d, own "
literal|"ver=%d)"
argument_list|,
name|flags
operator|&
name|EAP_PEAP_VERSION_MASK
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|EAP_PEAP_VERSION_MASK
operator|)
operator|<
name|data
operator|->
name|peap_version
condition|)
name|data
operator|->
name|peap_version
operator|=
name|flags
operator|&
name|EAP_PEAP_VERSION_MASK
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|force_peap_version
operator|>=
literal|0
operator|&&
name|data
operator|->
name|force_peap_version
operator|!=
name|data
operator|->
name|peap_version
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP-PEAP: Failed to select "
literal|"forced PEAP version %d"
argument_list|,
name|data
operator|->
name|force_peap_version
argument_list|)
expr_stmt|;
name|ret
operator|->
name|methodState
operator|=
name|METHOD_DONE
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|ret
operator|->
name|allowNotifications
operator|=
name|FALSE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Using PEAP version %d"
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
comment|/* make sure that this frame is empty, even though it 			   * should always be, anyway */
block|}
name|resp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tls_connection_established
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|)
operator|&&
operator|!
name|data
operator|->
name|resuming
condition|)
block|{
name|res
operator|=
name|eap_peap_decrypt
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|ret
argument_list|,
name|req
argument_list|,
name|pos
argument_list|,
name|left
argument_list|,
operator|&
name|resp
argument_list|,
name|respDataLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|eap_tls_process_helper
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|data
operator|->
name|peap_version
argument_list|,
name|id
argument_list|,
name|pos
argument_list|,
name|left
argument_list|,
operator|&
name|resp
argument_list|,
name|respDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_connection_established
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|)
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: TLS done, proceed to Phase 2"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|key_data
argument_list|)
expr_stmt|;
comment|/* draft-josefsson-ppext-eap-tls-eap-05.txt 			 * specifies that PEAPv1 would use "client PEAP 			 * encryption" as the label. However, most existing 			 * PEAPv1 implementations seem to be using the old 			 * label, "client EAP encryption", instead. Use the old 			 * label by default, but allow it to be configured with 			 * phase1 parameter peaplabel=1. */
if|if
condition|(
name|data
operator|->
name|peap_version
operator|>
literal|1
operator|||
name|data
operator|->
name|force_new_label
condition|)
name|label
operator|=
literal|"client PEAP encryption"
expr_stmt|;
else|else
name|label
operator|=
literal|"client EAP encryption"
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: using label '%s' in "
literal|"key derivation"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|data
operator|->
name|key_data
operator|=
name|eap_tls_derive_key
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|label
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|key_data
condition|)
block|{
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Derived key"
argument_list|,
name|data
operator|->
name|key_data
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Failed to "
literal|"derive key"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|data
operator|->
name|resuming
condition|)
block|{
comment|/* 				 * At least few RADIUS servers (Aegis v1.1.6; 				 * but not v1.1.4; and Cisco ACS) seem to be 				 * terminating PEAPv1 (Aegis) or PEAPv0 (Cisco 				 * ACS) session resumption with outer 				 * EAP-Success. This does not seem to follow 				 * draft-josefsson-pppext-eap-tls-eap-05.txt 				 * section 4.2, so only allow this if EAP 				 * workarounds are enabled. 				 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP-PEAP: Workaround - "
literal|"allow outer EAP-Success to "
literal|"terminate PEAP resumption"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|1
expr_stmt|;
block|}
name|data
operator|->
name|resuming
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|2
condition|)
block|{
comment|/* 			 * Application data included in the handshake message. 			 */
name|os_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|resp
expr_stmt|;
name|data
operator|->
name|pending_phase2_req_len
operator|=
operator|*
name|respDataLen
expr_stmt|;
name|resp
operator|=
name|NULL
expr_stmt|;
operator|*
name|respDataLen
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|eap_peap_decrypt
argument_list|(
name|sm
argument_list|,
name|data
argument_list|,
name|ret
argument_list|,
name|req
argument_list|,
name|pos
argument_list|,
name|left
argument_list|,
operator|&
name|resp
argument_list|,
name|respDataLen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
block|{
name|ret
operator|->
name|allowNotifications
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|1
condition|)
block|{
return|return
name|eap_tls_build_ack
argument_list|(
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|respDataLen
argument_list|,
name|id
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
name|data
operator|->
name|peap_version
argument_list|)
return|;
block|}
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|eap_peap_has_reauth_data
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
return|return
name|tls_connection_established
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|,
name|data
operator|->
name|ssl
operator|.
name|conn
argument_list|)
operator|&&
name|data
operator|->
name|phase2_success
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peap_deinit_for_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|pending_phase2_req
argument_list|)
expr_stmt|;
name|data
operator|->
name|pending_phase2_req
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|eap_peap_init_for_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|os_free
argument_list|(
name|data
operator|->
name|key_data
argument_list|)
expr_stmt|;
name|data
operator|->
name|key_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|eap_tls_reauth_init
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|)
condition|)
block|{
name|os_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|data
operator|->
name|phase2_priv
operator|&&
name|data
operator|->
name|phase2_method
operator|&&
name|data
operator|->
name|phase2_method
operator|->
name|init_for_reauth
condition|)
name|data
operator|->
name|phase2_method
operator|->
name|init_for_reauth
argument_list|(
name|sm
argument_list|,
name|data
operator|->
name|phase2_priv
argument_list|)
expr_stmt|;
name|data
operator|->
name|phase2_success
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|phase2_eap_success
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|phase2_eap_started
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|resuming
operator|=
literal|1
expr_stmt|;
name|sm
operator|->
name|peap_done
operator|=
name|FALSE
expr_stmt|;
return|return
name|priv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peap_get_status
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|len
operator|=
name|eap_tls_status
argument_list|(
name|sm
argument_list|,
operator|&
name|data
operator|->
name|ssl
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|phase2_method
condition|)
block|{
name|ret
operator|=
name|os_snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"EAP-PEAPv%d Phase2 method=%s\n"
argument_list|,
name|data
operator|->
name|peap_version
argument_list|,
name|data
operator|->
name|phase2_method
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|ret
operator|>=
name|buflen
operator|-
name|len
condition|)
return|return
name|len
return|;
name|len
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|eap_peap_isKeyAvailable
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
return|return
name|data
operator|->
name|key_data
operator|!=
name|NULL
operator|&&
name|data
operator|->
name|phase2_success
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_peap_getKey
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_peap_data
modifier|*
name|data
init|=
name|priv
decl_stmt|;
name|u8
modifier|*
name|key
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|key_data
operator|==
name|NULL
operator|||
operator|!
name|data
operator|->
name|phase2_success
condition|)
return|return
name|NULL
return|;
name|key
operator|=
name|os_malloc
argument_list|(
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|EAP_TLS_KEY_LEN
expr_stmt|;
name|os_memcpy
argument_list|(
name|key
argument_list|,
name|data
operator|->
name|key_data
argument_list|,
name|EAP_TLS_KEY_LEN
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_function
name|int
name|eap_peer_peap_register
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|eap_method
modifier|*
name|eap
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|eap
operator|=
name|eap_peer_method_alloc
argument_list|(
name|EAP_PEER_METHOD_INTERFACE_VERSION
argument_list|,
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_PEAP
argument_list|,
literal|"PEAP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|eap
operator|->
name|init
operator|=
name|eap_peap_init
expr_stmt|;
name|eap
operator|->
name|deinit
operator|=
name|eap_peap_deinit
expr_stmt|;
name|eap
operator|->
name|process
operator|=
name|eap_peap_process
expr_stmt|;
name|eap
operator|->
name|isKeyAvailable
operator|=
name|eap_peap_isKeyAvailable
expr_stmt|;
name|eap
operator|->
name|getKey
operator|=
name|eap_peap_getKey
expr_stmt|;
name|eap
operator|->
name|get_status
operator|=
name|eap_peap_get_status
expr_stmt|;
name|eap
operator|->
name|has_reauth_data
operator|=
name|eap_peap_has_reauth_data
expr_stmt|;
name|eap
operator|->
name|deinit_for_reauth
operator|=
name|eap_peap_deinit_for_reauth
expr_stmt|;
name|eap
operator|->
name|init_for_reauth
operator|=
name|eap_peap_init_for_reauth
expr_stmt|;
name|ret
operator|=
name|eap_peer_method_register
argument_list|(
name|eap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|eap_peer_method_free
argument_list|(
name|eap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

