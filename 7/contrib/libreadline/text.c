begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* text.c -- text handling commands for readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1987-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LOCALE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"rlmbutil.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
end_if

begin_define
define|#
directive|define
name|INCL_DOSPROCESS
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __EMX__ */
end_comment

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* Forward declarations. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rl_change_case
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_char_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|_rl_insert_next_callback
name|PARAMS
argument_list|(
operator|(
name|_rl_callback_generic_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_char_search_callback
name|PARAMS
argument_list|(
operator|(
name|_rl_callback_generic_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Insert and Delete			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Insert a string of text into the line at point.  This is the only    way that you should do insertion.  _rl_insert_char () calls this    function.  Returns the number of characters inserted. */
end_comment

begin_function
name|int
name|rl_insert_text
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|l
operator|=
operator|(
name|string
operator|&&
operator|*
name|string
operator|)
condition|?
name|strlen
argument_list|(
name|string
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rl_end
operator|+
name|l
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|rl_end
operator|+
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rl_end
init|;
name|i
operator|>=
name|rl_point
condition|;
name|i
operator|--
control|)
name|rl_line_buffer
index|[
name|i
operator|+
name|l
index|]
operator|=
name|rl_line_buffer
index|[
name|i
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|rl_line_buffer
operator|+
name|rl_point
argument_list|,
name|string
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Remember how to undo this if we aren't undoing something. */
if|if
condition|(
name|_rl_doing_an_undo
operator|==
literal|0
condition|)
block|{
comment|/* If possible and desirable, concatenate the undos. */
if|if
condition|(
operator|(
name|l
operator|==
literal|1
operator|)
operator|&&
name|rl_undo_list
operator|&&
operator|(
name|rl_undo_list
operator|->
name|what
operator|==
name|UNDO_INSERT
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|==
name|rl_point
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|-
name|rl_undo_list
operator|->
name|start
operator|<
literal|20
operator|)
condition|)
name|rl_undo_list
operator|->
name|end
operator|++
expr_stmt|;
else|else
name|rl_add_undo
argument_list|(
name|UNDO_INSERT
argument_list|,
name|rl_point
argument_list|,
name|rl_point
operator|+
name|l
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|rl_point
operator|+=
name|l
expr_stmt|;
name|rl_end
operator|+=
name|l
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Delete the string between FROM and TO.  FROM is inclusive, TO is not.    Returns the number of characters deleted. */
end_comment

begin_function
name|int
name|rl_delete_text
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
specifier|register
name|int
name|diff
decl_stmt|,
name|i
decl_stmt|;
comment|/* Fix it if the caller is confused. */
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|SWAP
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* fix boundaries */
if|if
condition|(
name|to
operator|>
name|rl_end
condition|)
block|{
name|to
operator|=
name|rl_end
expr_stmt|;
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|from
operator|=
name|to
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
literal|0
expr_stmt|;
name|text
operator|=
name|rl_copy_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* Some versions of strncpy() can't handle overlapping arguments. */
name|diff
operator|=
name|to
operator|-
name|from
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<
name|rl_end
operator|-
name|diff
condition|;
name|i
operator|++
control|)
name|rl_line_buffer
index|[
name|i
index|]
operator|=
name|rl_line_buffer
index|[
name|i
operator|+
name|diff
index|]
expr_stmt|;
comment|/* Remember how to undo this delete. */
if|if
condition|(
name|_rl_doing_an_undo
operator|==
literal|0
condition|)
name|rl_add_undo
argument_list|(
name|UNDO_DELETE
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_end
operator|-=
name|diff
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fix up point so that it is within the line boundaries after killing    text.  If FIX_MARK_TOO is non-zero, the mark is forced within line    boundaries also. */
end_comment

begin_define
define|#
directive|define
name|_RL_FIX_POINT
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 	if (x> rl_end) \ 	  x = rl_end; \ 	else if (x< 0) \ 	  x = 0; \ 	} while (0)
end_define

begin_function
name|void
name|_rl_fix_point
parameter_list|(
name|fix_mark_too
parameter_list|)
name|int
name|fix_mark_too
decl_stmt|;
block|{
name|_RL_FIX_POINT
argument_list|(
name|rl_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix_mark_too
condition|)
name|_RL_FIX_POINT
argument_list|(
name|rl_mark
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|_RL_FIX_POINT
end_undef

begin_comment
comment|/* Replace the contents of the line buffer between START and END with    TEXT.  The operation is undoable.  To replace the entire line in an    undoable mode, use _rl_replace_text(text, 0, rl_end); */
end_comment

begin_function
name|int
name|_rl_replace_text
parameter_list|(
name|text
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
name|n
operator|=
name|rl_insert_text
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is    non-zero, we free the current undo list. */
end_comment

begin_function
name|void
name|rl_replace_line
parameter_list|(
name|text
parameter_list|,
name|clear_undo
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|clear_undo
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rl_line_buffer
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|rl_end
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|clear_undo
condition|)
name|rl_free_undo_list
argument_list|()
expr_stmt|;
name|_rl_fix_point
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Readline character functions		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is not a gap editor, just a stupid line input routine.  No hair    is involved in writing any of the functions, and none should be. */
end_comment

begin_comment
comment|/* Note that:     rl_end is the place in the string that we would place '\0';    i.e., it is always safe to place '\0' there.     rl_point is the place in the string where the cursor is.  Sometimes    this is the same as rl_end.     Any command that is called interactively receives two arguments.    The first is a count: the numeric arg pased to this command.    The second is the key which invoked this command. */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Movement Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Note that if you `optimize' the display for these functions, you cannot    use said functions in other functions which do not do optimizing display.    I.e., you will have to update the data base for rl_redisplay, and you    might as well let rl_redisplay do that job. */
end_comment

begin_comment
comment|/* Move forward COUNT bytes. */
end_comment

begin_function
name|int
name|rl_forward_byte
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_backward_byte
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|end
init|=
name|rl_point
operator|+
name|count
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|int
name|lend
init|=
name|rl_end
operator|>
literal|0
condition|?
name|rl_end
operator|-
operator|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|)
else|:
name|rl_end
decl_stmt|;
else|#
directive|else
name|int
name|lend
init|=
name|rl_end
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|end
operator|>
name|lend
condition|)
block|{
name|rl_point
operator|=
name|lend
expr_stmt|;
name|rl_ding
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_point
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|rl_end
operator|<
literal|0
condition|)
name|rl_end
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_comment
comment|/* Move forward COUNT characters. */
end_comment

begin_function
name|int
name|rl_forward_char
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|point
decl_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
return|return
operator|(
name|rl_forward_byte
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_backward_char
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|point
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|count
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_end
operator|<=
name|point
operator|&&
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|point
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_end
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rl_point
operator|==
name|point
condition|)
name|rl_ding
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|rl_end
operator|<
literal|0
condition|)
name|rl_end
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HANDLE_MULTIBYTE */
end_comment

begin_function
name|int
name|rl_forward_char
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_forward_byte
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HANDLE_MULTIBYTE */
end_comment

begin_comment
comment|/* Backwards compatibility. */
end_comment

begin_function
name|int
name|rl_forward
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_forward_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move backward COUNT bytes. */
end_comment

begin_function
name|int
name|rl_backward_byte
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_forward_byte
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rl_point
operator|<
name|count
condition|)
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_ding
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_point
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|rl_point
operator|<
literal|0
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_comment
comment|/* Move backward COUNT characters. */
end_comment

begin_function
name|int
name|rl_backward_char
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|point
decl_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
return|return
operator|(
name|rl_backward_byte
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_forward_char
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|point
operator|=
name|rl_point
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
operator|&&
name|point
operator|>
literal|0
condition|)
block|{
name|point
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_ding
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_point
operator|=
name|point
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|rl_backward_char
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_backward_byte
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Backwards compatibility. */
end_comment

begin_function
name|int
name|rl_backward
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_backward_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move to the beginning of the line. */
end_comment

begin_function
name|int
name|rl_beg_of_line
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move to the end of the line. */
end_comment

begin_function
name|int
name|rl_end_of_line
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_point
operator|=
name|rl_end
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move forward a word.  We do what Emacs does.  Handles multibyte chars. */
end_comment

begin_function
name|int
name|rl_forward_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_backward_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return
literal|0
return|;
comment|/* If we are not in a word, move forward until we are in one. 	 Then, move forward until we hit a non-alphabetic character. */
name|c
operator|=
name|_rl_char_value
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_walphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rl_point
operator|=
name|MB_NEXTCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|_rl_char_value
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_walphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|rl_point
operator|=
name|MB_NEXTCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return
literal|0
return|;
name|rl_point
operator|=
name|MB_NEXTCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|_rl_char_value
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_walphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|rl_point
operator|=
name|MB_NEXTCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
block|}
operator|--
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move backward a word.  We do what Emacs does.  Handles multibyte chars. */
end_comment

begin_function
name|int
name|rl_backward_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|p
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_forward_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Like rl_forward_word (), except that we look at the characters 	 just before point. */
name|p
operator|=
name|MB_PREVCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|c
operator|=
name|_rl_char_value
argument_list|(
name|rl_line_buffer
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_walphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rl_point
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|MB_PREVCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|c
operator|=
name|_rl_char_value
argument_list|(
name|rl_line_buffer
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_walphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|rl_point
operator|=
name|p
expr_stmt|;
block|}
block|}
while|while
condition|(
name|rl_point
condition|)
block|{
name|p
operator|=
name|MB_PREVCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|c
operator|=
name|_rl_char_value
argument_list|(
name|rl_line_buffer
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_walphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
name|rl_point
operator|=
name|p
expr_stmt|;
block|}
operator|--
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear the current line.  Numeric argument to C-l does this. */
end_comment

begin_function
name|int
name|rl_refresh_line
parameter_list|(
name|ignore1
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|int
name|curr_line
decl_stmt|;
name|curr_line
operator|=
name|_rl_current_display_line
argument_list|()
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|curr_line
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|rl_line_buffer
argument_list|)
expr_stmt|;
comment|/* XXX is this right */
name|_rl_clear_to_eol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* arg of 0 means to not use spaces */
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* C-l typed to a line without quoting clears the screen, and then reprints    the prompt and the current input line.  Given a numeric arg, redraw only    the current line. */
end_comment

begin_function
name|int
name|rl_clear_screen
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|rl_refresh_line
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|_rl_clear_screen
argument_list|()
expr_stmt|;
comment|/* calls termcap function to clear screen */
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_arrow_keys
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|ch
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|_rl_to_upper
argument_list|(
name|ch
argument_list|)
condition|)
block|{
case|case
literal|'A'
case|:
name|rl_get_previous_history
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|rl_get_next_history
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_forward_char
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
name|rl_forward_byte
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_backward_char
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
name|rl_backward_byte
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rl_ding
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Text commands				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_MULTIBYTE
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|pending_bytes
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pending_bytes_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mbstate_t
name|ps
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Insert the character C at the current location, moving point forward.    If C introduces a multibyte sequence, we read the whole sequence and    then insert the multibyte char into the line buffer. */
end_comment

begin_function
name|int
name|_rl_insert_char
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_MULTIBYTE
name|int
name|string_size
decl_stmt|;
name|char
name|incoming
index|[
name|MB_LEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|incoming_length
init|=
literal|0
decl_stmt|;
name|mbstate_t
name|ps_back
decl_stmt|;
specifier|static
name|int
name|stored_count
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
block|{
name|incoming
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|incoming
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|incoming_length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wchar_t
name|wc
decl_stmt|;
name|size_t
name|ret
decl_stmt|;
if|if
condition|(
name|stored_count
operator|<=
literal|0
condition|)
name|stored_count
operator|=
name|count
expr_stmt|;
else|else
name|count
operator|=
name|stored_count
expr_stmt|;
name|ps_back
operator|=
name|ps
expr_stmt|;
name|pending_bytes
index|[
name|pending_bytes_length
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|ret
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|pending_bytes
argument_list|,
name|pending_bytes_length
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
comment|/* Bytes too short to compose character, try to wait for next byte. 	     Restore the state of the byte sequence, because in this case the 	     effect of mbstate is undefined. */
name|ps
operator|=
name|ps_back
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Invalid byte sequence for the current locale.  Treat first byte 	     as a single character. */
name|incoming
index|[
literal|0
index|]
operator|=
name|pending_bytes
index|[
literal|0
index|]
expr_stmt|;
name|incoming
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|incoming_length
operator|=
literal|1
expr_stmt|;
name|pending_bytes_length
operator|--
expr_stmt|;
name|memmove
argument_list|(
name|pending_bytes
argument_list|,
name|pending_bytes
operator|+
literal|1
argument_list|,
name|pending_bytes_length
argument_list|)
expr_stmt|;
comment|/* Clear the state of the byte sequence, because in this case the 	     effect of mbstate is undefined. */
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|(
name|size_t
operator|)
literal|0
condition|)
block|{
name|incoming
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|incoming_length
operator|=
literal|0
expr_stmt|;
name|pending_bytes_length
operator|--
expr_stmt|;
comment|/* Clear the state of the byte sequence, because in this case the 	     effect of mbstate is undefined. */
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We successfully read a single multibyte character. */
name|memcpy
argument_list|(
name|incoming
argument_list|,
name|pending_bytes
argument_list|,
name|pending_bytes_length
argument_list|)
expr_stmt|;
name|incoming
index|[
name|pending_bytes_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|incoming_length
operator|=
name|pending_bytes_length
expr_stmt|;
name|pending_bytes_length
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
comment|/* If we can optimize, then do it.  But don't let people crash      readline because of extra large arguments. */
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
name|count
operator|<=
literal|1024
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|string_size
operator|=
name|count
operator|*
name|incoming_length
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|string_size
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|string_size
condition|)
block|{
name|strncpy
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|incoming
argument_list|,
name|incoming_length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|incoming_length
expr_stmt|;
block|}
name|incoming_length
operator|=
literal|0
expr_stmt|;
name|stored_count
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* !HANDLE_MULTIBYTE */
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
comment|/* !HANDLE_MULTIBYTE */
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1024
condition|)
block|{
name|int
name|decreaser
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|string_size
operator|=
name|incoming_length
operator|*
literal|1024
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|string_size
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|string_size
condition|)
block|{
name|strncpy
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|incoming
argument_list|,
name|incoming_length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|incoming_length
expr_stmt|;
block|}
while|while
condition|(
name|count
condition|)
block|{
name|decreaser
operator|=
operator|(
name|count
operator|>
literal|1024
operator|)
condition|?
literal|1024
else|:
name|count
expr_stmt|;
name|string
index|[
name|decreaser
operator|*
name|incoming_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|count
operator|-=
name|decreaser
expr_stmt|;
block|}
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|incoming_length
operator|=
literal|0
expr_stmt|;
name|stored_count
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* !HANDLE_MULTIBYTE */
name|char
name|str
index|[
literal|1024
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
name|str
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|decreaser
operator|=
operator|(
name|count
operator|>
literal|1024
condition|?
literal|1024
else|:
name|count
operator|)
expr_stmt|;
name|str
index|[
name|decreaser
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|count
operator|-=
name|decreaser
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !HANDLE_MULTIBYTE */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
block|{
comment|/* We are inserting a single character. 	 If there is pending input, then make a string of all of the 	 pending characters that are bound to rl_insert, and insert 	 them all. */
if|if
condition|(
name|_rl_any_typein
argument_list|()
condition|)
name|_rl_insert_typein
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Inserting a single character. */
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|rl_insert_text
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
else|else
block|{
name|rl_insert_text
argument_list|(
name|incoming
argument_list|)
expr_stmt|;
name|stored_count
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the character at point (or next COUNT characters) with C.    If C introduces a multibyte character sequence, read the entire sequence    before starting the overwrite loop. */
end_comment

begin_function
name|int
name|_rl_overwrite_char
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|char
name|mbkey
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* Read an entire multibyte character sequence to insert COUNT times. */
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|k
operator|=
name|_rl_read_mbstring
argument_list|(
name|c
argument_list|,
name|mbkey
argument_list|,
name|MB_LEN_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_insert_text
argument_list|(
name|mbkey
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|_rl_insert_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_insert
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
return|return
operator|(
name|rl_insert_mode
operator|==
name|RL_IM_INSERT
condition|?
name|_rl_insert_char
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
else|:
name|_rl_overwrite_char
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Insert the next typed character verbatim. */
end_comment

begin_function
specifier|static
name|int
name|_rl_insert_next
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
operator|==
literal|0
condition|)
name|_rl_restore_tty_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|_rl_insert_char
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_insert_next_callback
parameter_list|(
name|data
parameter_list|)
name|_rl_callback_generic_arg
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
name|data
operator|->
name|count
expr_stmt|;
comment|/* Deregister function, let rl_callback_read_char deallocate data */
name|_rl_callback_func
operator|=
literal|0
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|1
expr_stmt|;
return|return
name|_rl_insert_next
argument_list|(
name|count
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rl_quoted_insert
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
comment|/* Let's see...should the callback interface futz with signal handling? */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
operator|==
literal|0
condition|)
name|_rl_disable_tty_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
block|{
name|_rl_callback_data
operator|=
name|_rl_callback_data_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|_rl_callback_func
operator|=
name|_rl_insert_next_callback
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
name|_rl_insert_next
argument_list|(
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Insert a tab character. */
end_comment

begin_function
name|int
name|rl_tab_insert
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|_rl_insert_char
argument_list|(
name|count
argument_list|,
literal|'\t'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* What to do when a NEWLINE is pressed.  We accept the whole line.    KEY is the key that invoked this command.  I guess it could have    meaning in the future. */
end_comment

begin_function
name|int
name|rl_newline
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|_rl_history_preserve_point
condition|)
name|_rl_history_saved_point
operator|=
operator|(
name|rl_point
operator|==
name|rl_end
operator|)
condition|?
operator|-
literal|1
else|:
name|rl_point
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_DONE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
block|{
name|_rl_vi_done_inserting
argument_list|()
expr_stmt|;
if|if
condition|(
name|_rl_vi_textmod_command
argument_list|(
name|_rl_vi_last_command
argument_list|)
operator|==
literal|0
condition|)
comment|/* XXX */
name|_rl_vi_reset_last
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VI_MODE */
comment|/* If we've been asked to erase empty lines, suppress the final update,      since _rl_update_final calls rl_crlf(). */
if|if
condition|(
name|rl_erase_empty_line
operator|&&
name|rl_point
operator|==
literal|0
operator|&&
name|rl_end
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|readline_echoing_p
condition|)
name|_rl_update_final
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* What to do for some uppercase characters, like meta characters,    and some characters appearing in emacs_ctlx_keymap.  This function    is just a stub, you bind keys to it and the code in _rl_dispatch ()    is special cased. */
end_comment

begin_function
name|int
name|rl_do_lowercase_version
parameter_list|(
name|ignore1
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is different from what vi does, so the code's not shared.  Emacs    rubout in overwrite mode has one oddity:  it replaces a control    character that's displayed as two characters (^X) with two spaces. */
end_comment

begin_function
name|int
name|_rl_overwrite_rubout
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|opoint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|opoint
operator|=
name|rl_point
expr_stmt|;
comment|/* L == number of spaces to insert */
for|for
control|(
name|i
operator|=
name|l
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rl_backward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|l
operator|+=
name|rl_character_len
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
comment|/* not exactly right */
block|}
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
operator|||
name|rl_explicit_arg
condition|)
name|rl_kill_text
argument_list|(
name|opoint
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
else|else
name|rl_delete_text
argument_list|(
name|opoint
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
comment|/* Emacs puts point at the beginning of the sequence of spaces. */
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|opoint
operator|=
name|rl_point
expr_stmt|;
name|_rl_insert_char
argument_list|(
name|l
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|opoint
expr_stmt|;
block|}
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Rubout the character behind point. */
end_comment

begin_function
name|int
name|rl_rubout
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_delete
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|rl_point
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|rl_insert_mode
operator|==
name|RL_IM_OVERWRITE
condition|)
return|return
operator|(
name|_rl_overwrite_rubout
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
return|return
operator|(
name|_rl_rubout_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_rl_rubout_char
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|orig_point
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Duplicated code because this is called from other parts of the library. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_delete
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|orig_point
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
operator|||
name|rl_explicit_arg
condition|)
block|{
name|rl_backward_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
block|{
name|c
operator|=
name|rl_line_buffer
index|[
operator|--
name|rl_point
index|]
expr_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|orig_point
argument_list|)
expr_stmt|;
comment|/* The erase-at-end-of-line hack is of questionable merit now. */
if|if
condition|(
name|rl_point
operator|==
name|rl_end
operator|&&
name|ISPRINT
argument_list|(
name|c
argument_list|)
operator|&&
name|_rl_last_c_pos
condition|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|rl_character_len
argument_list|(
name|c
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|_rl_erase_at_end_of_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rl_point
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|orig_point
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Delete the character under the cursor.  Given a numeric argument,    kill that many characters instead. */
end_comment

begin_function
name|int
name|rl_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|xpoint
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|_rl_rubout_char
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
operator|||
name|rl_explicit_arg
condition|)
block|{
name|xpoint
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_forward_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_forward_byte
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|xpoint
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|xpoint
expr_stmt|;
block|}
else|else
block|{
name|xpoint
operator|=
name|MB_NEXTCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|xpoint
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Delete the character under the cursor, unless the insertion    point is at the end of the line, in which case the character    behind the cursor is deleted.  COUNT is obeyed and may be used    to delete forward or backward that many characters. */
end_comment

begin_function
name|int
name|rl_rubout_or_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_end
operator|!=
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
return|return
operator|(
name|_rl_rubout_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_delete
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete all spaces and tabs around point. */
end_comment

begin_function
name|int
name|rl_delete_horizontal_space
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|start
init|=
name|rl_point
decl_stmt|;
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
name|start
operator|=
name|rl_point
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|rl_point
condition|)
block|{
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
block|}
if|if
condition|(
name|rl_point
operator|<
literal|0
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like the tcsh editing function delete-char-or-list.  The eof character    is caught before this is invoked, so this really does the same thing as    delete-char-or-list-or-eof, as long as it's bound to the eof character. */
end_comment

begin_function
name|int
name|rl_delete_or_show_completions
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_end
operator|!=
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
return|return
operator|(
name|rl_possible_completions
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_delete
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RL_COMMENT_BEGIN_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|RL_COMMENT_BEGIN_DEFAULT
value|"#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Turn the current line into a comment in shell history.    A K*rn shell style function. */
end_comment

begin_function
name|int
name|rl_insert_comment
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|char
modifier|*
name|rl_comment_text
decl_stmt|;
name|int
name|rl_comment_len
decl_stmt|;
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_comment_text
operator|=
name|_rl_comment_begin
condition|?
name|_rl_comment_begin
else|:
name|RL_COMMENT_BEGIN_DEFAULT
expr_stmt|;
if|if
condition|(
name|rl_explicit_arg
operator|==
literal|0
condition|)
name|rl_insert_text
argument_list|(
name|rl_comment_text
argument_list|)
expr_stmt|;
else|else
block|{
name|rl_comment_len
operator|=
name|strlen
argument_list|(
name|rl_comment_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQN
argument_list|(
name|rl_comment_text
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_comment_len
argument_list|)
condition|)
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
name|rl_comment_len
argument_list|)
expr_stmt|;
else|else
name|rl_insert_text
argument_list|(
name|rl_comment_text
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Changing Case				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The three kinds of things that we know how to do. */
end_comment

begin_define
define|#
directive|define
name|UpCase
value|1
end_define

begin_define
define|#
directive|define
name|DownCase
value|2
end_define

begin_define
define|#
directive|define
name|CapCase
value|3
end_define

begin_comment
comment|/* Uppercase the word at point. */
end_comment

begin_function
name|int
name|rl_upcase_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|UpCase
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lowercase the word at point. */
end_comment

begin_function
name|int
name|rl_downcase_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|DownCase
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Upcase the first letter, downcase the rest. */
end_comment

begin_function
name|int
name|rl_capitalize_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|CapCase
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The meaty function.    Change the case of COUNT words, performing OP on them.    OP is one of UpCase, DownCase, or CapCase.    If a negative argument is given, leave point where it started,    otherwise, leave it where it moves to. */
end_comment

begin_function
specifier|static
name|int
name|rl_change_case
parameter_list|(
name|count
parameter_list|,
name|op
parameter_list|)
name|int
name|count
decl_stmt|,
name|op
decl_stmt|;
block|{
name|int
name|start
decl_stmt|,
name|next
decl_stmt|,
name|end
decl_stmt|;
name|int
name|inword
decl_stmt|,
name|c
decl_stmt|,
name|nc
decl_stmt|,
name|nop
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|wchar_t
name|wc
decl_stmt|,
name|nwc
decl_stmt|;
name|char
name|mb
index|[
name|MB_LEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|mlen
decl_stmt|;
name|mbstate_t
name|mps
decl_stmt|;
endif|#
directive|endif
name|start
operator|=
name|rl_point
expr_stmt|;
name|rl_forward_word
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|UpCase
operator|&&
name|op
operator|!=
name|DownCase
operator|&&
name|op
operator|!=
name|CapCase
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|SWAP
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|memset
argument_list|(
operator|&
name|mps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We are going to modify some text, so let's prepare to undo it. */
name|rl_modifying
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|inword
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|c
operator|=
name|_rl_char_value
argument_list|(
name|rl_line_buffer
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/*  This assumes that the upper and lower case versions are the same width. */
name|next
operator|=
name|MB_NEXTCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|start
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_walphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inword
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|==
name|CapCase
condition|)
block|{
name|nop
operator|=
name|inword
condition|?
name|DownCase
else|:
name|UpCase
expr_stmt|;
name|inword
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|nop
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
operator|||
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|nc
operator|=
operator|(
name|nop
operator|==
name|UpCase
operator|)
condition|?
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
else|:
name|_rl_to_lower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_line_buffer
index|[
name|start
index|]
operator|=
name|nc
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
else|else
block|{
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|rl_line_buffer
operator|+
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|,
operator|&
name|mps
argument_list|)
expr_stmt|;
name|nwc
operator|=
operator|(
name|nop
operator|==
name|UpCase
operator|)
condition|?
name|_rl_to_wupper
argument_list|(
name|wc
argument_list|)
else|:
name|_rl_to_wlower
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwc
operator|!=
name|wc
condition|)
comment|/*  just skip unchanged characters */
block|{
name|mlen
operator|=
name|wcrtomb
argument_list|(
name|mb
argument_list|,
name|nwc
argument_list|,
operator|&
name|mps
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|>
literal|0
condition|)
name|mb
index|[
name|mlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Assume the same width */
name|strncpy
argument_list|(
name|rl_line_buffer
operator|+
name|start
argument_list|,
name|mb
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|start
operator|=
name|next
expr_stmt|;
block|}
name|rl_point
operator|=
name|end
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Transposition				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Transpose the words at point.  If point is at the end of the line,    transpose the two words before point. */
end_comment

begin_function
name|int
name|rl_transpose_words
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|char
modifier|*
name|word1
decl_stmt|,
modifier|*
name|word2
decl_stmt|;
name|int
name|w1_beg
decl_stmt|,
name|w1_end
decl_stmt|,
name|w2_beg
decl_stmt|,
name|w2_end
decl_stmt|;
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
comment|/* Find the two words. */
name|rl_forward_word
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w2_end
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w2_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w1_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_forward_word
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w1_end
operator|=
name|rl_point
expr_stmt|;
comment|/* Do some check to make sure that there really are two words. */
if|if
condition|(
operator|(
name|w1_beg
operator|==
name|w2_beg
operator|)
operator|||
operator|(
name|w2_beg
operator|<
name|w1_end
operator|)
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the text of the words. */
name|word1
operator|=
name|rl_copy_text
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|word2
operator|=
name|rl_copy_text
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
comment|/* We are about to do many insertions and deletions.  Remember them      as one operation. */
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* Do the stuff at word2 first, so that we don't have to worry      about word1 moving. */
name|rl_point
operator|=
name|w2_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|w1_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word2
argument_list|)
expr_stmt|;
comment|/* This is exactly correct since the text before this point has not      changed in length. */
name|rl_point
operator|=
name|w2_end
expr_stmt|;
comment|/* I think that does it. */
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|word2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Transpose the characters at point.  If point is at the end of the line,    then transpose the characters before point. */
end_comment

begin_function
name|int
name|rl_transpose_chars
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
name|int
name|i
decl_stmt|;
else|#
directive|else
name|char
name|dummy
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|char_length
decl_stmt|,
name|prev_point
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|rl_point
operator|||
name|rl_end
operator|<
literal|2
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
name|rl_point
operator|=
name|MB_PREVCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|prev_point
operator|=
name|rl_point
expr_stmt|;
name|rl_point
operator|=
name|MB_PREVCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|char_length
operator|=
name|prev_point
operator|-
name|rl_point
expr_stmt|;
name|dummy
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|char_length
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|char_length
condition|;
name|i
operator|++
control|)
name|dummy
index|[
name|i
index|]
operator|=
name|rl_line_buffer
index|[
name|rl_point
operator|+
name|i
index|]
expr_stmt|;
name|dummy
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|dummy
index|[
literal|0
index|]
operator|=
name|rl_line_buffer
index|[
name|rl_point
index|]
expr_stmt|;
name|dummy
index|[
name|char_length
operator|=
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
name|char_length
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|count
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|_rl_fix_point
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|free
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Character Searching			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|int
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|_rl_char_search_internal
parameter_list|(
name|count
parameter_list|,
name|dir
parameter_list|,
name|smbchar
parameter_list|,
name|len
parameter_list|)
name|int
name|count
decl_stmt|,
name|dir
decl_stmt|;
name|char
modifier|*
name|smbchar
decl_stmt|;
name|int
name|len
decl_stmt|;
else|#
directive|else
function|_rl_char_search_internal
parameter_list|(
name|count
parameter_list|,
name|dir
parameter_list|,
name|schar
parameter_list|)
name|int
name|count
decl_stmt|,
name|dir
decl_stmt|,
name|schar
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|pos
decl_stmt|,
name|inc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|int
name|prepos
decl_stmt|;
endif|#
directive|endif
name|pos
operator|=
name|rl_point
expr_stmt|;
name|inc
operator|=
operator|(
name|dir
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|(
name|dir
operator|<
literal|0
operator|&&
name|pos
operator|<=
literal|0
operator|)
operator|||
operator|(
name|dir
operator|>
literal|0
operator|&&
name|pos
operator|>=
name|rl_end
operator|)
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|pos
operator|=
operator|(
name|inc
operator|>
literal|0
operator|)
condition|?
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
else|:
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
else|#
directive|else
name|pos
operator|+=
name|inc
expr_stmt|;
endif|#
directive|endif
do|do
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|_rl_is_mbchar_matched
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
name|rl_end
argument_list|,
name|smbchar
argument_list|,
name|len
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|rl_line_buffer
index|[
name|pos
index|]
operator|==
name|schar
condition|)
endif|#
directive|endif
block|{
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|rl_point
operator|=
operator|(
name|dir
operator|==
name|BTO
operator|)
condition|?
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
else|:
name|pos
expr_stmt|;
else|else
name|rl_point
operator|=
operator|(
name|dir
operator|==
name|FTO
operator|)
condition|?
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
name|MB_FIND_ANY
argument_list|)
else|:
name|pos
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|prepos
operator|=
name|pos
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
do|while
condition|(
operator|(
name|dir
operator|<
literal|0
operator|)
condition|?
operator|(
name|pos
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
name|MB_FIND_ANY
argument_list|)
operator|)
operator|!=
name|prepos
else|:
operator|(
name|pos
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
operator|)
operator|!=
name|prepos
condition|)
do|;
else|#
directive|else
while|while
condition|(
operator|(
name|dir
operator|<
literal|0
operator|)
condition|?
name|pos
operator|--
else|:
operator|++
name|pos
operator|<
name|rl_end
condition|)
empty_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search COUNT times for a character read from the current input stream.    FDIR is the direction to search if COUNT is non-negative; otherwise    the search goes in BDIR.  So much is dependent on HANDLE_MULTIBYTE    that there are two separate versions of this function. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_char_search
parameter_list|(
name|count
parameter_list|,
name|fdir
parameter_list|,
name|bdir
parameter_list|)
name|int
name|count
decl_stmt|,
name|fdir
decl_stmt|,
name|bdir
decl_stmt|;
block|{
name|char
name|mbchar
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
name|int
name|mb_len
decl_stmt|;
name|mb_len
operator|=
name|_rl_read_mbchar
argument_list|(
name|mbchar
argument_list|,
name|MB_LEN_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
operator|-
name|count
argument_list|,
name|bdir
argument_list|,
name|mbchar
argument_list|,
name|mb_len
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|count
argument_list|,
name|fdir
argument_list|,
name|mbchar
argument_list|,
name|mb_len
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HANDLE_MULTIBYTE */
end_comment

begin_function
specifier|static
name|int
name|_rl_char_search
parameter_list|(
name|count
parameter_list|,
name|fdir
parameter_list|,
name|bdir
parameter_list|)
name|int
name|count
decl_stmt|,
name|fdir
decl_stmt|,
name|bdir
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
operator|-
name|count
argument_list|,
name|bdir
argument_list|,
name|c
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|count
argument_list|,
name|fdir
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HANDLE_MULTIBYTE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_char_search_callback
parameter_list|(
name|data
parameter_list|)
name|_rl_callback_generic_arg
modifier|*
name|data
decl_stmt|;
block|{
name|_rl_callback_func
operator|=
literal|0
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|_rl_char_search
argument_list|(
name|data
operator|->
name|count
argument_list|,
name|data
operator|->
name|i1
argument_list|,
name|data
operator|->
name|i2
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rl_char_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
block|{
name|_rl_callback_data
operator|=
name|_rl_callback_data_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|_rl_callback_data
operator|->
name|i1
operator|=
name|FFIND
expr_stmt|;
name|_rl_callback_data
operator|->
name|i2
operator|=
name|BFIND
expr_stmt|;
name|_rl_callback_func
operator|=
name|_rl_char_search_callback
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|_rl_char_search
argument_list|(
name|count
argument_list|,
name|FFIND
argument_list|,
name|BFIND
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_backward_char_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
block|{
name|_rl_callback_data
operator|=
name|_rl_callback_data_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|_rl_callback_data
operator|->
name|i1
operator|=
name|BFIND
expr_stmt|;
name|_rl_callback_data
operator|->
name|i2
operator|=
name|FFIND
expr_stmt|;
name|_rl_callback_func
operator|=
name|_rl_char_search_callback
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|_rl_char_search
argument_list|(
name|count
argument_list|,
name|BFIND
argument_list|,
name|FFIND
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   The Mark and the Region.			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Set the mark at POSITION. */
end_comment

begin_function
name|int
name|_rl_set_mark_at_pos
parameter_list|(
name|position
parameter_list|)
name|int
name|position
decl_stmt|;
block|{
if|if
condition|(
name|position
operator|>
name|rl_end
condition|)
return|return
operator|-
literal|1
return|;
name|rl_mark
operator|=
name|position
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A bindable command to set the mark. */
end_comment

begin_function
name|int
name|rl_set_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|_rl_set_mark_at_pos
argument_list|(
name|rl_explicit_arg
condition|?
name|count
else|:
name|rl_point
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Exchange the position of mark and point. */
end_comment

begin_function
name|int
name|rl_exchange_point_and_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_mark
operator|>
name|rl_end
condition|)
name|rl_mark
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rl_mark
operator|==
operator|-
literal|1
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
name|SWAP
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

