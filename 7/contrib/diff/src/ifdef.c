begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* #ifdef-format output routines for GNU DIFF.     Copyright (C) 1989, 1991, 1992, 1993, 1994, 2001, 2002, 2004 Free    Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY.  No author or distributor    accepts responsibility to anyone for the consequences of using it    or for whether it serves any particular purpose or works at all,    unless he says so in writing.  Refer to the GNU DIFF General Public    License for full details.     Everyone is granted permission to copy, modify and redistribute    GNU DIFF, but only under the conditions described in the    GNU DIFF General Public License.   A copy of this license is    supposed to have been given to you along with GNU DIFF so you    can know your rights and responsibilities.  It should be in a    file named COPYING.  Among other things, the copyright notice    and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_struct
struct|struct
name|group
block|{
name|struct
name|file_data
specifier|const
modifier|*
name|file
decl_stmt|;
name|lin
name|from
decl_stmt|,
name|upto
decl_stmt|;
comment|/* start and limit lines for this group of lines */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|format_group
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
parameter_list|,
name|struct
name|group
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|do_printf_spec
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|struct
name|file_data
specifier|const
modifier|*
parameter_list|,
name|lin
parameter_list|,
name|struct
name|group
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|scan_char_literal
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|lin
name|groups_letter_value
parameter_list|(
name|struct
name|group
specifier|const
modifier|*
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|format_ifdef
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|lin
parameter_list|,
name|lin
parameter_list|,
name|lin
parameter_list|,
name|lin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ifdef_hunk
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ifdef_lines
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|struct
name|group
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|lin
name|next_line0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lin
name|next_line1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the edit-script SCRIPT as a merged #ifdef file.  */
end_comment

begin_function
name|void
name|print_ifdef_script
parameter_list|(
name|struct
name|change
modifier|*
name|script
parameter_list|)
block|{
name|next_line0
operator|=
name|next_line1
operator|=
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|prefix_lines
expr_stmt|;
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|print_ifdef_hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_line0
operator|<
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
operator|||
name|next_line1
operator|<
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
condition|)
block|{
name|begin_output
argument_list|()
expr_stmt|;
name|format_ifdef
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
name|next_line0
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
argument_list|,
name|next_line1
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a hunk of an ifdef diff.    This is a contiguous portion of a complete edit script,    describing changes in consecutive lines.  */
end_comment

begin_function
specifier|static
name|void
name|print_ifdef_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|hunk
parameter_list|)
block|{
name|lin
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|enum
name|changes
name|changes
init|=
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changes
condition|)
return|return;
name|begin_output
argument_list|()
expr_stmt|;
comment|/* Print lines up to this change.  */
if|if
condition|(
name|next_line0
operator|<
name|first0
operator|||
name|next_line1
operator|<
name|first1
condition|)
name|format_ifdef
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
name|next_line0
argument_list|,
name|first0
argument_list|,
name|next_line1
argument_list|,
name|first1
argument_list|)
expr_stmt|;
comment|/* Print this change.  */
name|next_line0
operator|=
name|last0
operator|+
literal|1
expr_stmt|;
name|next_line1
operator|=
name|last1
operator|+
literal|1
expr_stmt|;
name|format_ifdef
argument_list|(
name|group_format
index|[
name|changes
index|]
argument_list|,
name|first0
argument_list|,
name|next_line0
argument_list|,
name|first1
argument_list|,
name|next_line1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a set of lines according to FORMAT.    Lines BEG0 up to END0 are from the first file;    lines BEG1 up to END1 are from the second file.  */
end_comment

begin_function
specifier|static
name|void
name|format_ifdef
parameter_list|(
name|char
specifier|const
modifier|*
name|format
parameter_list|,
name|lin
name|beg0
parameter_list|,
name|lin
name|end0
parameter_list|,
name|lin
name|beg1
parameter_list|,
name|lin
name|end1
parameter_list|)
block|{
name|struct
name|group
name|groups
index|[
literal|2
index|]
decl_stmt|;
name|groups
index|[
literal|0
index|]
operator|.
name|file
operator|=
operator|&
name|files
index|[
literal|0
index|]
expr_stmt|;
name|groups
index|[
literal|0
index|]
operator|.
name|from
operator|=
name|beg0
expr_stmt|;
name|groups
index|[
literal|0
index|]
operator|.
name|upto
operator|=
name|end0
expr_stmt|;
name|groups
index|[
literal|1
index|]
operator|.
name|file
operator|=
operator|&
name|files
index|[
literal|1
index|]
expr_stmt|;
name|groups
index|[
literal|1
index|]
operator|.
name|from
operator|=
name|beg1
expr_stmt|;
name|groups
index|[
literal|1
index|]
operator|.
name|upto
operator|=
name|end1
expr_stmt|;
name|format_group
argument_list|(
name|outfile
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|groups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print to file OUT a set of lines according to FORMAT.    The format ends at the first free instance of ENDCHAR.    Yield the address of the terminating character.    GROUPS specifies which lines to print.    If OUT is zero, do not actually print anything; just scan the format.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|format_group
parameter_list|(
specifier|register
name|FILE
modifier|*
name|out
parameter_list|,
name|char
specifier|const
modifier|*
name|format
parameter_list|,
name|char
name|endchar
parameter_list|,
name|struct
name|group
specifier|const
modifier|*
name|groups
parameter_list|)
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|f
init|=
name|format
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|)
operator|!=
name|endchar
operator|&&
name|c
operator|!=
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|f1
init|=
operator|++
name|f
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
condition|)
block|{
case|case
literal|'%'
case|:
break|break;
case|case
literal|'('
case|:
comment|/* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
block|{
name|int
name|i
decl_stmt|;
name|uintmax_t
name|value
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|thenout
decl_stmt|,
modifier|*
name|elseout
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|f
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fend
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
index|[
name|i
index|]
operator|=
name|strtoumax
argument_list|(
name|f
argument_list|,
operator|&
name|fend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
goto|goto
name|bad_format
goto|;
name|f
operator|=
name|fend
expr_stmt|;
block|}
else|else
block|{
name|value
index|[
name|i
index|]
operator|=
name|groups_letter_value
argument_list|(
name|groups
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad_format
goto|;
name|f
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f
operator|++
operator|!=
literal|"=?"
index|[
name|i
index|]
condition|)
goto|goto
name|bad_format
goto|;
block|}
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
name|value
index|[
literal|1
index|]
condition|)
name|thenout
operator|=
name|out
operator|,
name|elseout
operator|=
literal|0
expr_stmt|;
else|else
name|thenout
operator|=
literal|0
operator|,
name|elseout
operator|=
name|out
expr_stmt|;
name|f
operator|=
name|format_group
argument_list|(
name|thenout
argument_list|,
name|f
argument_list|,
literal|':'
argument_list|,
name|groups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|f
condition|)
block|{
name|f
operator|=
name|format_group
argument_list|(
name|elseout
argument_list|,
name|f
operator|+
literal|1
argument_list|,
literal|')'
argument_list|,
name|groups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|f
condition|)
name|f
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'<'
case|:
comment|/* Print lines deleted from first file.  */
name|print_ifdef_lines
argument_list|(
name|out
argument_list|,
name|line_format
index|[
name|OLD
index|]
argument_list|,
operator|&
name|groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* Print common lines.  */
name|print_ifdef_lines
argument_list|(
name|out
argument_list|,
name|line_format
index|[
name|UNCHANGED
index|]
argument_list|,
operator|&
name|groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* Print lines inserted from second file.  */
name|print_ifdef_lines
argument_list|(
name|out
argument_list|,
name|line_format
index|[
name|NEW
index|]
argument_list|,
operator|&
name|groups
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|f
operator|=
name|do_printf_spec
argument_list|(
name|out
argument_list|,
name|f
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|groups
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
continue|continue;
comment|/* Fall through. */
name|bad_format
label|:
name|c
operator|=
literal|'%'
expr_stmt|;
name|f
operator|=
name|f1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|out
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* For the line group pair G, return the number corresponding to LETTER.    Return -1 if LETTER is not a group format letter.  */
end_comment

begin_function
specifier|static
name|lin
name|groups_letter_value
parameter_list|(
name|struct
name|group
specifier|const
modifier|*
name|g
parameter_list|,
name|char
name|letter
parameter_list|)
block|{
switch|switch
condition|(
name|letter
condition|)
block|{
case|case
literal|'E'
case|:
name|letter
operator|=
literal|'e'
expr_stmt|;
name|g
operator|++
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|letter
operator|=
literal|'f'
expr_stmt|;
name|g
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|letter
operator|=
literal|'l'
expr_stmt|;
name|g
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|letter
operator|=
literal|'m'
expr_stmt|;
name|g
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|letter
operator|=
literal|'n'
expr_stmt|;
name|g
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|letter
condition|)
block|{
case|case
literal|'e'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|from
argument_list|)
operator|-
literal|1
return|;
case|case
literal|'f'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|from
argument_list|)
return|;
case|case
literal|'l'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|upto
argument_list|)
operator|-
literal|1
return|;
case|case
literal|'m'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|upto
argument_list|)
return|;
case|case
literal|'n'
case|:
return|return
name|g
operator|->
name|upto
operator|-
name|g
operator|->
name|from
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Print to file OUT, using FORMAT to print the line group GROUP.    But do nothing if OUT is zero.  */
end_comment

begin_function
specifier|static
name|void
name|print_ifdef_lines
parameter_list|(
specifier|register
name|FILE
modifier|*
name|out
parameter_list|,
name|char
specifier|const
modifier|*
name|format
parameter_list|,
name|struct
name|group
specifier|const
modifier|*
name|group
parameter_list|)
block|{
name|struct
name|file_data
specifier|const
modifier|*
name|file
init|=
name|group
operator|->
name|file
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|linbuf
init|=
name|file
operator|->
name|linbuf
decl_stmt|;
name|lin
name|from
init|=
name|group
operator|->
name|from
decl_stmt|,
name|upto
init|=
name|group
operator|->
name|upto
decl_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
return|return;
comment|/* If possible, use a single fwrite; it's faster.  */
if|if
condition|(
operator|!
name|expand_tabs
operator|&&
name|format
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|format
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|format
index|[
literal|2
index|]
operator|==
literal|'\n'
operator|&&
operator|!
name|format
index|[
literal|3
index|]
operator|&&
name|from
operator|<
name|upto
condition|)
block|{
name|fwrite
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|linbuf
index|[
name|upto
index|]
operator|+
operator|(
name|linbuf
index|[
name|upto
index|]
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
operator|-
name|linbuf
index|[
name|from
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
operator|!
name|format
index|[
literal|2
index|]
condition|)
block|{
name|fwrite
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|linbuf
index|[
name|upto
index|]
operator|-
name|linbuf
index|[
name|from
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
init|;
name|from
operator|<
name|upto
condition|;
name|from
operator|++
control|)
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|f
init|=
name|format
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|f1
init|=
name|f
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
condition|)
block|{
case|case
literal|'%'
case|:
break|break;
case|case
literal|'l'
case|:
name|output_1_line
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
operator|(
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
operator|-
operator|(
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
name|output_1_line
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|f
operator|=
name|do_printf_spec
argument_list|(
name|out
argument_list|,
name|f
operator|-
literal|2
argument_list|,
name|file
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
continue|continue;
name|c
operator|=
literal|'%'
expr_stmt|;
name|f
operator|=
name|f1
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|do_printf_spec
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|char
specifier|const
modifier|*
name|spec
parameter_list|,
name|struct
name|file_data
specifier|const
modifier|*
name|file
parameter_list|,
name|lin
name|n
parameter_list|,
name|struct
name|group
specifier|const
modifier|*
name|groups
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|f
init|=
name|spec
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|c1
decl_stmt|;
comment|/* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
comment|/* assert (*f == '%'); */
name|f
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'0'
condition|)
continue|continue;
while|while
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
while|while
condition|(
name|ISDIGIT
argument_list|(
name|c
operator|=
operator|*
name|f
operator|++
argument_list|)
condition|)
continue|continue;
name|c1
operator|=
operator|*
name|f
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|c1
operator|!=
literal|'\''
condition|)
return|return
literal|0
return|;
else|else
block|{
name|char
name|value
decl_stmt|;
name|f
operator|=
name|scan_char_literal
argument_list|(
name|f
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|out
condition|)
name|putc
argument_list|(
name|value
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
name|lin
name|value
decl_stmt|;
if|if
condition|(
name|file
condition|)
block|{
if|if
condition|(
name|c1
operator|!=
literal|'n'
condition|)
return|return
literal|0
return|;
name|value
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|groups_letter_value
argument_list|(
name|groups
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|out
condition|)
block|{
comment|/* For example, if the spec is "%3xn", use the printf 	       format spec "%3lx".  Here the spec prefix is "%3".  */
name|long
name|int
name|long_value
init|=
name|value
decl_stmt|;
name|size_t
name|spec_prefix_len
init|=
name|f
operator|-
name|spec
operator|-
literal|2
decl_stmt|;
if|#
directive|if
name|HAVE_C_VARARRAYS
name|char
name|format
index|[
name|spec_prefix_len
operator|+
literal|3
index|]
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|format
init|=
name|xmalloc
argument_list|(
name|spec_prefix_len
operator|+
literal|3
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|p
init|=
name|format
operator|+
name|spec_prefix_len
decl_stmt|;
name|memcpy
argument_list|(
name|format
argument_list|,
name|spec
argument_list|,
name|spec_prefix_len
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'l'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
name|format
argument_list|,
name|long_value
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_C_VARARRAYS
name|free
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Scan the character literal represented in the string LIT; LIT points just    after the initial apostrophe.  Put the literal's value into *VALPTR.    Yield the address of the first character after the closing apostrophe,    or zero if the literal is ill-formed.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|scan_char_literal
parameter_list|(
name|char
specifier|const
modifier|*
name|lit
parameter_list|,
name|char
modifier|*
name|valptr
parameter_list|)
block|{
specifier|register
name|char
specifier|const
modifier|*
name|p
init|=
name|lit
decl_stmt|;
name|char
name|value
decl_stmt|;
name|ptrdiff_t
name|digits
decl_stmt|;
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|'\''
case|:
return|return
literal|0
return|;
case|case
literal|'\\'
case|:
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\''
condition|)
block|{
name|unsigned
name|int
name|digit
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
literal|8
operator|<=
name|digit
condition|)
return|return
literal|0
return|;
name|value
operator|=
literal|8
operator|*
name|value
operator|+
name|digit
expr_stmt|;
block|}
name|digits
operator|=
name|p
operator|-
name|lit
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|1
operator|<=
name|digits
operator|&&
name|digits
operator|<=
literal|3
operator|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|value
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\''
condition|)
return|return
literal|0
return|;
break|break;
block|}
operator|*
name|valptr
operator|=
name|value
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

end_unit

