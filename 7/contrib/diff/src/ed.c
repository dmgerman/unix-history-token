begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output routines for ed-script format.     Copyright (C) 1988, 1989, 1991, 1992, 1993, 1995, 1998, 2001, 2004    Free Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_function_decl
specifier|static
name|void
name|print_ed_hunk
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_rcs_hunk
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_forward_ed_hunk
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Print our script as ed commands.  */
end_comment

begin_function
name|void
name|print_ed_script
parameter_list|(
name|struct
name|change
modifier|*
name|script
parameter_list|)
block|{
name|print_script
argument_list|(
name|script
argument_list|,
name|find_reverse_change
argument_list|,
name|print_ed_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a hunk of an ed diff */
end_comment

begin_function
specifier|static
name|void
name|print_ed_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|hunk
parameter_list|)
block|{
name|lin
name|f0
decl_stmt|,
name|l0
decl_stmt|,
name|f1
decl_stmt|,
name|l1
decl_stmt|;
name|enum
name|changes
name|changes
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug_script
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Determine range of line numbers involved in each file.  */
name|changes
operator|=
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|f0
argument_list|,
operator|&
name|l0
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changes
condition|)
return|return;
name|begin_output
argument_list|()
expr_stmt|;
comment|/* Print out the line number header for this hunk */
name|print_number_range
argument_list|(
literal|','
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|f0
argument_list|,
name|l0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%c\n"
argument_list|,
name|change_letter
index|[
name|changes
index|]
argument_list|)
expr_stmt|;
comment|/* Print new/changed lines from second file, if needed */
if|if
condition|(
name|changes
operator|!=
name|OLD
condition|)
block|{
name|lin
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|f1
init|;
name|i
operator|<=
name|l1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* The file's line is just a dot, and it would exit 		 insert mode.  Precede the dot with another dot, exit 		 insert mode, remove the extra dot, and then resume 		 insert mode.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"..\n.\ns/.//\na\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|print_1_line
argument_list|(
literal|""
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print change script in the style of ed commands,    but print the changes in the order they appear in the input files,    which means that the commands are not truly useful with ed.  */
end_comment

begin_function
name|void
name|pr_forward_ed_script
parameter_list|(
name|struct
name|change
modifier|*
name|script
parameter_list|)
block|{
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|pr_forward_ed_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pr_forward_ed_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|hunk
parameter_list|)
block|{
name|lin
name|i
decl_stmt|,
name|f0
decl_stmt|,
name|l0
decl_stmt|,
name|f1
decl_stmt|,
name|l1
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|enum
name|changes
name|changes
init|=
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|f0
argument_list|,
operator|&
name|l0
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|l1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changes
condition|)
return|return;
name|begin_output
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%c"
argument_list|,
name|change_letter
index|[
name|changes
index|]
argument_list|)
expr_stmt|;
name|print_number_range
argument_list|(
literal|' '
argument_list|,
name|files
argument_list|,
name|f0
argument_list|,
name|l0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If deletion only, print just the number range.  */
if|if
condition|(
name|changes
operator|==
name|OLD
condition|)
return|return;
comment|/* For insertion (with or without deletion), print the number range      and the lines from file 2.  */
for|for
control|(
name|i
operator|=
name|f1
init|;
name|i
operator|<=
name|l1
condition|;
name|i
operator|++
control|)
name|print_1_line
argument_list|(
literal|""
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print in a format somewhat like ed commands    except that each insert command states the number of lines it inserts.    This format is used for RCS.  */
end_comment

begin_function
name|void
name|print_rcs_script
parameter_list|(
name|struct
name|change
modifier|*
name|script
parameter_list|)
block|{
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|print_rcs_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a hunk of an RCS diff */
end_comment

begin_function
specifier|static
name|void
name|print_rcs_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|hunk
parameter_list|)
block|{
name|lin
name|i
decl_stmt|,
name|f0
decl_stmt|,
name|l0
decl_stmt|,
name|f1
decl_stmt|,
name|l1
decl_stmt|;
name|long
name|int
name|tf0
decl_stmt|,
name|tl0
decl_stmt|,
name|tf1
decl_stmt|,
name|tl1
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|enum
name|changes
name|changes
init|=
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|f0
argument_list|,
operator|&
name|l0
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|l1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changes
condition|)
return|return;
name|begin_output
argument_list|()
expr_stmt|;
name|translate_range
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|f0
argument_list|,
name|l0
argument_list|,
operator|&
name|tf0
argument_list|,
operator|&
name|tl0
argument_list|)
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|OLD
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
comment|/* For deletion, print just the starting line number from file 0 	 and the number of lines deleted.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld %ld\n"
argument_list|,
name|tf0
argument_list|,
name|tf0
operator|<=
name|tl0
condition|?
name|tl0
operator|-
name|tf0
operator|+
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changes
operator|&
name|NEW
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
comment|/* Take last-line-number from file 0 and # lines from file 1.  */
name|translate_range
argument_list|(
operator|&
name|files
index|[
literal|1
index|]
argument_list|,
name|f1
argument_list|,
name|l1
argument_list|,
operator|&
name|tf1
argument_list|,
operator|&
name|tl1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld %ld\n"
argument_list|,
name|tl0
argument_list|,
name|tf1
operator|<=
name|tl1
condition|?
name|tl1
operator|-
name|tf1
operator|+
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Print the inserted lines.  */
for|for
control|(
name|i
operator|=
name|f1
init|;
name|i
operator|<=
name|l1
condition|;
name|i
operator|++
control|)
name|print_1_line
argument_list|(
literal|""
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

