begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* If-conversion support.    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_execution
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_execution
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_move
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_move
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_incscc
end_ifndef

begin_define
define|#
directive|define
name|HAVE_incscc
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_decscc
end_ifndef

begin_define
define|#
directive|define
name|HAVE_decscc
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_trap
end_ifndef

begin_define
define|#
directive|define
name|HAVE_trap
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_trap
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_trap
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CONDITIONAL_EXECUTE
end_ifndef

begin_define
define|#
directive|define
name|MAX_CONDITIONAL_EXECUTE
value|(BRANCH_COST + 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NULL_BLOCK
value|((basic_block) NULL)
end_define

begin_comment
comment|/* # of IF-THEN or IF-THEN-ELSE blocks we looked at  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_possible_if_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of IF-THEN or IF-THEN-ELSE blocks were converted to conditional    execution.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_updated_if_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of changes made which require life information to be updated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_true_changes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether conditional execution changes were made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cond_exec_changed_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if life data ok at present.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|life_data_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references.  */
end_comment

begin_function_decl
specifier|static
name|int
name|count_bb_insns
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|cheap_bb_rtx_cost_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|first_active_insn
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|last_active_insn
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|block_fallthru
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cond_exec_process_insns
parameter_list|(
name|ce_if_block_t
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|cond_exec_get_condition
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cond_exec_process_if_block
parameter_list|(
name|ce_if_block_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|noce_get_condition
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_operand_ok
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_process_if_block
parameter_list|(
name|ce_if_block_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_if_block
parameter_list|(
name|ce_if_block_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_if_block
parameter_list|(
name|ce_if_block_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_cond_trap
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|find_if_header
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|block_jumps_and_fallthru_p
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_if_block
parameter_list|(
name|ce_if_block_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_if_case_1
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_if_case_2
parameter_list|(
name|basic_block
parameter_list|,
name|edge
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_memory
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dead_or_predicable
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|noce_emit_move_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|block_has_only_trap
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Count the number of non-jump active insns in BB.  */
end_comment

begin_function
specifier|static
name|int
name|count_bb_insns
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the total insn_rtx_cost on non-jump insns in    basic block BB is less than MAX_COST.  This function returns    false if the cost of any instruction could not be estimated.  */
end_comment

begin_function
specifier|static
name|bool
name|cheap_bb_rtx_cost_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|max_cost
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|cost
init|=
name|insn_rtx_cost
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* If this instruction is the load or set of a "stack" register, 	     such as a floating point register on x87, then the cost of 	     speculatively executing this insn may need to include 	     the additional cost of popping its result off of the 	     register stack.  Unfortunately, correctly recognizing and 	     accounting for this additional overhead is tricky, so for 	     now we simply prohibit such speculative execution.  */
ifdef|#
directive|ifdef
name|STACK_REGS
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|STACK_REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
name|count
operator|+=
name|cost
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|max_cost
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the first non-jump active insn in the basic block.  */
end_comment

begin_function
specifier|static
name|rtx
name|first_active_insn
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last non-jump active (non-jump) insn in the basic block.  */
end_comment

begin_function
specifier|static
name|rtx
name|last_active_insn
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|skip_use_p
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|skip_use_p
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|head
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the basic block reached by falling though the basic block BB.  */
end_comment

begin_function
specifier|static
name|basic_block
name|block_fallthru
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
return|return
operator|(
name|e
operator|)
condition|?
name|e
operator|->
name|dest
else|:
name|NULL_BLOCK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Go through a bunch of insns, converting them to conditional    execution format if possible.  Return TRUE if all of the non-note    insns were processed.  */
end_comment

begin_function
specifier|static
name|int
name|cond_exec_process_insns
parameter_list|(
name|ce_if_block_t
modifier|*
name|ce_info
name|ATTRIBUTE_UNUSED
parameter_list|,
comment|/* if block information */
name|rtx
name|start
parameter_list|,
comment|/* first insn to look at */
name|rtx
name|end
parameter_list|,
comment|/* last insn to look at */
name|rtx
name|test
parameter_list|,
comment|/* conditional execution test */
name|rtx
name|prob_val
parameter_list|,
comment|/* probability of branch taken. */
name|int
name|mod_ok
parameter_list|)
block|{
name|int
name|must_be_last
init|=
name|FALSE
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|xtest
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
if|if
condition|(
operator|!
name|start
operator|||
operator|!
name|end
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|insn
operator|=
name|start
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|insn_done
goto|;
name|gcc_assert
argument_list|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|CALL_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove USE insns that get in the way.  */
if|if
condition|(
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
comment|/* ??? Ug.  Actually unlinking the thing is problematic, 	     given what we'd have to coordinate with our callers.  */
name|SET_INSN_DELETED
argument_list|(
name|insn
argument_list|)
expr_stmt|;
goto|goto
name|insn_done
goto|;
block|}
comment|/* Last insn wasn't last?  */
if|if
condition|(
name|must_be_last
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|modified_in_p
argument_list|(
name|test
argument_list|,
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mod_ok
condition|)
return|return
name|FALSE
return|;
name|must_be_last
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Now build the conditional form of the instruction.  */
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|xtest
operator|=
name|copy_rtx
argument_list|(
name|test
argument_list|)
expr_stmt|;
comment|/* If this is already a COND_EXEC, rewrite the test to be an AND of the          two conditions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|COND_EXEC
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|xtest
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|xtest
operator|=
name|gen_rtx_AND
argument_list|(
name|GET_MODE
argument_list|(
name|xtest
argument_list|)
argument_list|,
name|xtest
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|COND_EXEC_CODE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
name|pattern
operator|=
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|xtest
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
comment|/* If the machine needs to modify the insn being conditionally executed,          say for example to force a constant integer operand into a temp          register, do so here.  */
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_INSN
name|IFCVT_MODIFY_INSN
argument_list|(
name|ce_info
argument_list|,
name|pattern
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pattern
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|prob_val
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|alloc_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|prob_val
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn_done
label|:
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the condition for a jump.  Do not do any special processing.  */
end_comment

begin_function
specifier|static
name|rtx
name|cond_exec_get_condition
parameter_list|(
name|rtx
name|jump
parameter_list|)
block|{
name|rtx
name|test_if
decl_stmt|,
name|cond
decl_stmt|;
if|if
condition|(
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
name|test_if
operator|=
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
name|cond
operator|=
name|XEXP
argument_list|(
name|test_if
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false,      reverse the condition.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|test_if
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|test_if
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
condition|)
block|{
name|enum
name|rtx_code
name|rev
init|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|==
name|UNKNOWN
condition|)
return|return
name|NULL_RTX
return|;
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|rev
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it    to conditional execution.  Return TRUE if we were successful at    converting the block.  */
end_comment

begin_function
specifier|static
name|int
name|cond_exec_process_if_block
parameter_list|(
name|ce_if_block_t
modifier|*
name|ce_info
parameter_list|,
comment|/* if block information */
name|int
name|do_multiple_p
parameter_list|)
block|{
name|basic_block
name|test_bb
init|=
name|ce_info
operator|->
name|test_bb
decl_stmt|;
comment|/* last test block */
name|basic_block
name|then_bb
init|=
name|ce_info
operator|->
name|then_bb
decl_stmt|;
comment|/* THEN */
name|basic_block
name|else_bb
init|=
name|ce_info
operator|->
name|else_bb
decl_stmt|;
comment|/* ELSE or NULL */
name|rtx
name|test_expr
decl_stmt|;
comment|/* expression in IF_THEN_ELSE that is tested */
name|rtx
name|then_start
decl_stmt|;
comment|/* first insn in THEN block */
name|rtx
name|then_end
decl_stmt|;
comment|/* last insn + 1 in THEN block */
name|rtx
name|else_start
init|=
name|NULL_RTX
decl_stmt|;
comment|/* first insn in ELSE block or NULL */
name|rtx
name|else_end
init|=
name|NULL_RTX
decl_stmt|;
comment|/* last insn + 1 in ELSE block */
name|int
name|max
decl_stmt|;
comment|/* max # of insns to convert.  */
name|int
name|then_mod_ok
decl_stmt|;
comment|/* whether conditional mods are ok in THEN */
name|rtx
name|true_expr
decl_stmt|;
comment|/* test for else block insns */
name|rtx
name|false_expr
decl_stmt|;
comment|/* test for then block insns */
name|rtx
name|true_prob_val
decl_stmt|;
comment|/* probability of else block */
name|rtx
name|false_prob_val
decl_stmt|;
comment|/* probability of then block */
name|int
name|n_insns
decl_stmt|;
name|enum
name|rtx_code
name|false_code
decl_stmt|;
comment|/* If test is comprised of&& or || elements, and we've failed at handling      all of them together, just use the last test if it is the special case of&& elements without an ELSE block.  */
if|if
condition|(
operator|!
name|do_multiple_p
operator|&&
name|ce_info
operator|->
name|num_multiple_test_blocks
condition|)
block|{
if|if
condition|(
name|else_bb
operator|||
operator|!
name|ce_info
operator|->
name|and_and_p
condition|)
return|return
name|FALSE
return|;
name|ce_info
operator|->
name|test_bb
operator|=
name|test_bb
operator|=
name|ce_info
operator|->
name|last_test_bb
expr_stmt|;
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|=
literal|0
expr_stmt|;
name|ce_info
operator|->
name|num_and_and_blocks
operator|=
literal|0
expr_stmt|;
name|ce_info
operator|->
name|num_or_or_blocks
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Find the conditional jump to the ELSE or JOIN part, and isolate      the test.  */
name|test_expr
operator|=
name|cond_exec_get_condition
argument_list|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test_expr
condition|)
return|return
name|FALSE
return|;
comment|/* If the conditional jump is more than just a conditional jump,      then we can not do conditional execution conversion on this block.  */
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Collect the bounds of where we're to search, skipping any labels, jumps      and notes at the beginning and end of the block.  Then count the total      number of insns and see if it is small enough to convert.  */
name|then_start
operator|=
name|first_active_insn
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
name|then_end
operator|=
name|last_active_insn
argument_list|(
name|then_bb
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|n_insns
operator|=
name|ce_info
operator|->
name|num_then_insns
operator|=
name|count_bb_insns
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAX_CONDITIONAL_EXECUTE
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
block|{
name|max
operator|*=
literal|2
expr_stmt|;
name|else_start
operator|=
name|first_active_insn
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
name|else_end
operator|=
name|last_active_insn
argument_list|(
name|else_bb
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|n_insns
operator|+=
name|ce_info
operator|->
name|num_else_insns
operator|=
name|count_bb_insns
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_insns
operator|>
name|max
condition|)
return|return
name|FALSE
return|;
comment|/* Map test_expr/test_jump into the appropriate MD tests to use on      the conditionally executed code.  */
name|true_expr
operator|=
name|test_expr
expr_stmt|;
name|false_code
operator|=
name|reversed_comparison_code
argument_list|(
name|true_expr
argument_list|,
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|false_code
operator|!=
name|UNKNOWN
condition|)
name|false_expr
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|false_code
argument_list|,
name|GET_MODE
argument_list|(
name|true_expr
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|true_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|true_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|false_expr
operator|=
name|NULL_RTX
expr_stmt|;
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_TESTS
comment|/* If the machine description needs to modify the tests, such as setting a      conditional execution register from a comparison, it can do so here.  */
name|IFCVT_MODIFY_TESTS
argument_list|(
name|ce_info
argument_list|,
name|true_expr
argument_list|,
name|false_expr
argument_list|)
expr_stmt|;
comment|/* See if the conversion failed.  */
if|if
condition|(
operator|!
name|true_expr
operator|||
operator|!
name|false_expr
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
name|true_prob_val
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_prob_val
condition|)
block|{
name|true_prob_val
operator|=
name|XEXP
argument_list|(
name|true_prob_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|false_prob_val
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|true_prob_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|false_prob_val
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* If we have&& or || tests, do them here.  These tests are in the adjacent      blocks after the first block containing the test.  */
if|if
condition|(
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|>
literal|0
condition|)
block|{
name|basic_block
name|bb
init|=
name|test_bb
decl_stmt|;
name|basic_block
name|last_test_bb
init|=
name|ce_info
operator|->
name|last_test_bb
decl_stmt|;
if|if
condition|(
operator|!
name|false_expr
condition|)
goto|goto
name|fail
goto|;
do|do
block|{
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
name|rtx
name|t
decl_stmt|,
name|f
decl_stmt|;
name|enum
name|rtx_code
name|f_code
decl_stmt|;
name|bb
operator|=
name|block_fallthru
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|start
operator|=
name|first_active_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|end
operator|=
name|last_active_insn
argument_list|(
name|bb
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|&&
operator|!
name|cond_exec_process_insns
argument_list|(
name|ce_info
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|false_expr
argument_list|,
name|false_prob_val
argument_list|,
name|FALSE
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* If the conditional jump is more than just a conditional jump, then 	     we can not do conditional execution conversion on this block.  */
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Find the conditional jump and isolate the test.  */
name|t
operator|=
name|cond_exec_get_condition
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
goto|goto
name|fail
goto|;
name|f_code
operator|=
name|reversed_comparison_code
argument_list|(
name|t
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_code
operator|==
name|UNKNOWN
condition|)
goto|goto
name|fail
goto|;
name|f
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|f_code
argument_list|,
name|GET_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce_info
operator|->
name|and_and_p
condition|)
block|{
name|t
operator|=
name|gen_rtx_AND
argument_list|(
name|GET_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|true_expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|f
operator|=
name|gen_rtx_IOR
argument_list|(
name|GET_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|false_expr
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|gen_rtx_IOR
argument_list|(
name|GET_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|true_expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|f
operator|=
name|gen_rtx_AND
argument_list|(
name|GET_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|false_expr
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* If the machine description needs to modify the tests, such as 	     setting a conditional execution register from a comparison, it can 	     do so here.  */
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_MULTIPLE_TESTS
name|IFCVT_MODIFY_MULTIPLE_TESTS
argument_list|(
name|ce_info
argument_list|,
name|bb
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* See if the conversion failed.  */
if|if
condition|(
operator|!
name|t
operator|||
operator|!
name|f
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
name|true_expr
operator|=
name|t
expr_stmt|;
name|false_expr
operator|=
name|f
expr_stmt|;
block|}
do|while
condition|(
name|bb
operator|!=
name|last_test_bb
condition|)
do|;
block|}
comment|/* For IF-THEN-ELSE blocks, we don't allow modifications of the test      on then THEN block.  */
name|then_mod_ok
operator|=
operator|(
name|else_bb
operator|==
name|NULL_BLOCK
operator|)
expr_stmt|;
comment|/* Go through the THEN and ELSE blocks converting the insns if possible      to conditional execution.  */
if|if
condition|(
name|then_end
operator|&&
operator|(
operator|!
name|false_expr
operator|||
operator|!
name|cond_exec_process_insns
argument_list|(
name|ce_info
argument_list|,
name|then_start
argument_list|,
name|then_end
argument_list|,
name|false_expr
argument_list|,
name|false_prob_val
argument_list|,
name|then_mod_ok
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|else_bb
operator|&&
name|else_end
operator|&&
operator|!
name|cond_exec_process_insns
argument_list|(
name|ce_info
argument_list|,
name|else_start
argument_list|,
name|else_end
argument_list|,
name|true_expr
argument_list|,
name|true_prob_val
argument_list|,
name|TRUE
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* If we cannot apply the changes, fail.  Do not go through the normal fail      processing, since apply_change_group will call cancel_changes.  */
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_CANCEL
comment|/* Cancel any machine dependent changes.  */
name|IFCVT_MODIFY_CANCEL
argument_list|(
name|ce_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_FINAL
comment|/* Do any machine dependent final modifications.  */
name|IFCVT_MODIFY_FINAL
argument_list|(
name|ce_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Conversion succeeded.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d insn%s converted to conditional execution.\n"
argument_list|,
name|n_insns
argument_list|,
operator|(
name|n_insns
operator|==
literal|1
operator|)
condition|?
literal|" was"
else|:
literal|"s were"
argument_list|)
expr_stmt|;
comment|/* Merge the blocks!  */
name|merge_if_block
argument_list|(
name|ce_info
argument_list|)
expr_stmt|;
name|cond_exec_changed_p
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
name|fail
label|:
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_CANCEL
comment|/* Cancel any machine dependent changes.  */
name|IFCVT_MODIFY_CANCEL
argument_list|(
name|ce_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used by noce_process_if_block to communicate with its subroutines.     The subroutines know that A and B may be evaluated freely.  They    know that X is a register.  They should insert new instructions    before cond_earliest.  */
end_comment

begin_struct
struct|struct
name|noce_if_info
block|{
name|basic_block
name|test_bb
decl_stmt|;
name|rtx
name|insn_a
decl_stmt|,
name|insn_b
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|rtx
name|jump
decl_stmt|,
name|cond
decl_stmt|,
name|cond_earliest
decl_stmt|;
comment|/* True if "b" was originally evaluated unconditionally.  */
name|bool
name|b_unconditional
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|rtx
name|noce_emit_store_flag
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_move
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_store_flag
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_addcc
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_store_flag_constants
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_store_flag_mask
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|noce_emit_cmove
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_cmove
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_cmove_arith
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|noce_get_alt_condition
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_minmax
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_abs
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|noce_try_sign_mask
parameter_list|(
name|struct
name|noce_if_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Helper function for noce_try_store_flag*.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_emit_store_flag
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|reversep
parameter_list|,
name|int
name|normalize
parameter_list|)
block|{
name|rtx
name|cond
init|=
name|if_info
operator|->
name|cond
decl_stmt|;
name|int
name|cond_complex
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|cond_complex
operator|=
operator|(
operator|!
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|!
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
expr_stmt|;
comment|/* If earliest == jump, or when the condition is complex, try to      build the store_flag insn directly.  */
if|if
condition|(
name|cond_complex
condition|)
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|if_info
operator|->
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_info
operator|->
name|cond_earliest
operator|==
name|if_info
operator|->
name|jump
operator|||
name|cond_complex
operator|)
operator|&&
operator|(
name|normalize
operator|==
literal|0
operator|||
name|STORE_FLAG_VALUE
operator|==
name|normalize
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|if_info
operator|->
name|cond_earliest
operator|=
name|if_info
operator|->
name|jump
expr_stmt|;
return|return
name|x
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Don't even try if the comparison operands or the mode of X are weird.  */
if|if
condition|(
name|cond_complex
operator|||
operator|!
name|SCALAR_INT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|emit_store_flag
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|GTU
operator|)
argument_list|,
name|normalize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit instruction to move an rtx, possibly into STRICT_LOW_PART.    X is the destination/target and Y is the value to copy.  */
end_comment

begin_function
specifier|static
name|void
name|noce_emit_move_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|machine_mode
name|outmode
decl_stmt|;
name|rtx
name|outer
decl_stmt|,
name|inner
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|STRICT_LOW_PART
condition|)
block|{
name|rtx
name|seq
decl_stmt|,
name|insn
decl_stmt|,
name|target
decl_stmt|;
name|optab
name|ot
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Check that the SET_SRC is reasonable before calling emit_move_insn, 	 otherwise construct a suitable SET pattern ourselves.  */
name|insn
operator|=
operator|(
name|OBJECT_P
argument_list|(
name|y
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|)
condition|?
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
else|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|rtx
name|op
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|size
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|start
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* store_bit_field expects START to be relative to  		 BYTES_BIG_ENDIAN and adjusts this value for machines with  		 BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN.  In order to be able to  		 invoke store_bit_field again it is necessary to have the START 		 value from the first call.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
block|{
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
name|start
operator|=
name|BITS_PER_UNIT
operator|-
name|start
operator|-
name|size
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|BITS_PER_WORD
operator|-
name|start
operator|-
name|size
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|start
operator|<
operator|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
name|store_bit_field
argument_list|(
name|op
argument_list|,
name|size
argument_list|,
name|start
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RTX_UNARY
case|:
name|ot
operator|=
name|code_to_optab
index|[
name|GET_CODE
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|ot
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|ot
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|RTX_BIN_ARITH
case|:
case|case
name|RTX_COMM_ARITH
case|:
name|ot
operator|=
name|code_to_optab
index|[
name|GET_CODE
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|ot
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|ot
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return;
block|}
name|outer
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner
operator|=
name|XEXP
argument_list|(
name|outer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outmode
operator|=
name|GET_MODE
argument_list|(
name|outer
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|SUBREG_BYTE
argument_list|(
name|outer
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|store_bit_field
argument_list|(
name|inner
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|outmode
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|outmode
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return sequence of instructions generated by if conversion.  This    function calls end_sequence() to end the current stream, ensures    that are instructions are unshared, recognizable non-jump insns.    On failure, this function returns a NULL_RTX.  */
end_comment

begin_function
specifier|static
name|rtx
name|end_ifcvt_sequence
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|seq
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|set_used_flags
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
expr_stmt|;
name|set_used_flags
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
expr_stmt|;
name|unshare_all_rtl_in_chain
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Make sure that all of the instructions emitted are recognizable,      and that we haven't introduced a new jump instruction.      As an exercise for the reader, build a general mechanism that      allows proper placement of required clobbers.  */
for|for
control|(
name|insn
operator|=
name|seq
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|seq
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (a != b) x = a; else x = b" into "x = a" and    "if (a == b) x = a; else x = b" into "x = b".  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_move
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|cond
init|=
name|if_info
operator|->
name|cond
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
decl_stmt|;
name|rtx
name|y
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|NE
operator|&&
name|code
operator|!=
name|EQ
condition|)
return|return
name|FALSE
return|;
comment|/* This optimization isn't valid if either A or B could be a NaN      or a signed zero.  */
if|if
condition|(
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
operator|||
name|HONOR_SIGNED_ZEROS
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Check whether the operands of the comparison are A and in      either order.  */
if|if
condition|(
operator|(
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|y
operator|=
operator|(
name|code
operator|==
name|EQ
operator|)
condition|?
name|if_info
operator|->
name|a
else|:
name|if_info
operator|->
name|b
expr_stmt|;
comment|/* Avoid generating the move if the source is the destination.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (test) x = 1; else x = 0".     Only try 0 and STORE_FLAG_VALUE here.  Other combinations will be    tried in noce_try_store_flag_constants after noce_try_cmove has had    a go at the conversion.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_store_flag
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|int
name|reversep
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|==
name|STORE_FLAG_VALUE
operator|&&
name|if_info
operator|->
name|a
operator|==
name|const0_rtx
condition|)
name|reversep
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|if_info
operator|->
name|b
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|STORE_FLAG_VALUE
operator|&&
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
condition|)
name|reversep
operator|=
literal|1
expr_stmt|;
else|else
return|return
name|FALSE
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|reversep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert "if (test) x = a; else x = b", for A and B constant.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_store_flag_constants
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|reversep
decl_stmt|;
name|HOST_WIDE_INT
name|itrue
decl_stmt|,
name|ifalse
decl_stmt|,
name|diff
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|normalize
decl_stmt|,
name|can_reverse
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
expr_stmt|;
name|ifalse
operator|=
name|INTVAL
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
expr_stmt|;
name|itrue
operator|=
name|INTVAL
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
expr_stmt|;
comment|/* Make sure we can represent the difference between the two values.  */
if|if
condition|(
operator|(
name|itrue
operator|-
name|ifalse
operator|>
literal|0
operator|)
operator|!=
operator|(
operator|(
name|ifalse
operator|<
literal|0
operator|)
operator|!=
operator|(
name|itrue
operator|<
literal|0
operator|)
condition|?
name|ifalse
operator|<
literal|0
else|:
name|ifalse
operator|<
name|itrue
operator|)
condition|)
return|return
name|FALSE
return|;
name|diff
operator|=
name|trunc_int_for_mode
argument_list|(
name|itrue
operator|-
name|ifalse
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|can_reverse
operator|=
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
expr_stmt|;
name|reversep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|diff
operator|==
name|STORE_FLAG_VALUE
operator|||
name|diff
operator|==
operator|-
name|STORE_FLAG_VALUE
condition|)
name|normalize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ifalse
operator|==
literal|0
operator|&&
name|exact_log2
argument_list|(
name|itrue
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|itrue
operator|==
literal|0
operator|&&
name|exact_log2
argument_list|(
name|ifalse
argument_list|)
operator|>=
literal|0
operator|&&
name|can_reverse
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
literal|1
operator|,
name|reversep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|itrue
operator|==
operator|-
literal|1
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ifalse
operator|==
operator|-
literal|1
operator|&&
name|can_reverse
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
operator|-
literal|1
operator|,
name|reversep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|||
name|BRANCH_COST
operator|>=
literal|3
condition|)
name|normalize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|reversep
condition|)
block|{
name|tmp
operator|=
name|itrue
expr_stmt|;
name|itrue
operator|=
name|ifalse
expr_stmt|;
name|ifalse
operator|=
name|tmp
expr_stmt|;
name|diff
operator|=
name|trunc_int_for_mode
argument_list|(
operator|-
name|diff
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|reversep
argument_list|,
name|normalize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* if (test) x = 3; else x = 4; 	 =>   x = 3 + (test == 0);  */
if|if
condition|(
name|diff
operator|==
name|STORE_FLAG_VALUE
operator|||
name|diff
operator|==
operator|-
name|STORE_FLAG_VALUE
condition|)
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
operator|(
name|diff
operator|==
name|STORE_FLAG_VALUE
condition|?
name|PLUS
else|:
name|MINUS
operator|)
argument_list|,
name|GEN_INT
argument_list|(
name|ifalse
argument_list|)
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* if (test) x = 8; else x = 0; 	 =>   x = (test != 0)<< 3;  */
elseif|else
if|if
condition|(
name|ifalse
operator|==
literal|0
operator|&&
operator|(
name|tmp
operator|=
name|exact_log2
argument_list|(
name|itrue
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|ASHIFT
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* if (test) x = -1; else x = b; 	 =>   x = -(test != 0) | b;  */
elseif|else
if|if
condition|(
name|itrue
operator|==
operator|-
literal|1
condition|)
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|IOR
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|ifalse
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* if (test) x = a; else x = b; 	 =>   x = (-(test != 0)& (b - a)) + a;  */
else|else
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|diff
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|ifalse
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (test) foo++" into "foo += (test != 0)", and    similarly for "foo--".  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_addcc
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|subtract
decl_stmt|,
name|normalize
decl_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
operator|&&
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
condition|)
block|{
name|rtx
name|cond
init|=
name|if_info
operator|->
name|cond
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
decl_stmt|;
comment|/* First try to use addcc pattern.  */
if|if
condition|(
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|emit_conditional_add
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|if_info
operator|->
name|b
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* If that fails, construct conditional increment or decrement using 	 setcc.  */
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
operator|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtract
operator|=
literal|0
operator|,
name|normalize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|-
name|STORE_FLAG_VALUE
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtract
operator|=
literal|1
operator|,
name|normalize
operator|=
literal|0
expr_stmt|;
else|else
name|subtract
operator|=
literal|0
operator|,
name|normalize
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|normalize
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|subtract
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|if_info
operator|->
name|b
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (test) x = 0;" to "x&= -(test == 0);"  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_store_flag_mask
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|reversep
decl_stmt|;
name|reversep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|if_info
operator|->
name|a
operator|==
name|const0_rtx
operator|&&
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|if_info
operator|->
name|x
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|reversep
operator|=
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
operator|)
operator|&&
name|if_info
operator|->
name|b
operator|==
name|const0_rtx
operator|&&
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|if_info
operator|->
name|x
argument_list|)
operator|)
operator|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
argument_list|,
name|reversep
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|AND
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Helper function for noce_try_cmove and noce_try_cmove_arith.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_emit_cmove
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|,
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|cmp_a
parameter_list|,
name|rtx
name|cmp_b
parameter_list|,
name|rtx
name|vfalse
parameter_list|,
name|rtx
name|vtrue
parameter_list|)
block|{
comment|/* If earliest == jump, try to build the cmove insn directly.      This is helpful when combine has created some complex condition      (like for alpha's cmovlbs) that we can't hope to regenerate      through the normal interface.  */
if|if
condition|(
name|if_info
operator|->
name|cond_earliest
operator|==
name|if_info
operator|->
name|jump
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
argument_list|,
name|cmp_a
argument_list|,
name|cmp_b
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|vtrue
argument_list|,
name|vfalse
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Don't even try if the comparison operands are weird.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|cmp_a
argument_list|,
name|GET_MODE
argument_list|(
name|cmp_a
argument_list|)
argument_list|)
operator|||
operator|!
name|general_operand
argument_list|(
name|cmp_b
argument_list|,
name|GET_MODE
argument_list|(
name|cmp_b
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|#
directive|if
name|HAVE_conditional_move
return|return
name|emit_conditional_move
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|cmp_a
argument_list|,
name|cmp_b
argument_list|,
name|VOIDmode
argument_list|,
name|vtrue
argument_list|,
name|vfalse
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|)
argument_list|)
return|;
else|#
directive|else
comment|/* We'll never get here, as noce_process_if_block doesn't call the      functions involved.  Ifdef code, however, should be discouraged      because it leads to typos in the code not selected.  However,      emit_conditional_move won't exist either.  */
return|return
name|NULL_RTX
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Try only simple constants and registers here.  More complex cases    are handled in noce_try_cmove_arith after noce_try_store_flag_arith    has had a go at it.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_cmove
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|||
name|register_operand
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|||
name|register_operand
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
expr_stmt|;
name|target
operator|=
name|noce_emit_cmove
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_info
operator|->
name|a
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Try more complex cases involving conditional_move.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_cmove_arith
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|a
init|=
name|if_info
operator|->
name|a
decl_stmt|;
name|rtx
name|b
init|=
name|if_info
operator|->
name|b
decl_stmt|;
name|rtx
name|x
init|=
name|if_info
operator|->
name|x
decl_stmt|;
name|rtx
name|orig_a
decl_stmt|,
name|orig_b
decl_stmt|;
name|rtx
name|insn_a
decl_stmt|,
name|insn_b
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|target
decl_stmt|;
name|int
name|is_mem
init|=
literal|0
decl_stmt|;
name|int
name|insn_cost
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* A conditional move from two memory sources is equivalent to a      conditional on their addresses followed by a load.  Don't do this      early because it'll screw alias analysis.  Note that we've      already checked for no side effects.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|cse_not_expected
operator|&&
name|MEM_P
argument_list|(
name|a
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|b
argument_list|)
operator|&&
name|BRANCH_COST
operator|>=
literal|5
condition|)
block|{
name|a
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|is_mem
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ??? We could handle this if we knew that a load from A or B could      not fault.  This is also true if we've already loaded      from the address along the path from ENTRY.  */
elseif|else
if|if
condition|(
name|may_trap_p
argument_list|(
name|a
argument_list|)
operator|||
name|may_trap_p
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* if (test) x = a + b; else x = c - d;      => y = a + b;         x = c - d; 	if (test) 	  x = y;   */
name|code
operator|=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
expr_stmt|;
name|insn_a
operator|=
name|if_info
operator|->
name|insn_a
expr_stmt|;
name|insn_b
operator|=
name|if_info
operator|->
name|insn_b
expr_stmt|;
comment|/* Total insn_rtx_cost should be smaller than branch cost.  Exit      if insn_rtx_cost can't be estimated.  */
if|if
condition|(
name|insn_a
condition|)
block|{
name|insn_cost
operator|=
name|insn_rtx_cost
argument_list|(
name|PATTERN
argument_list|(
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_cost
operator|==
literal|0
operator|||
name|insn_cost
operator|>
name|COSTS_N_INSNS
argument_list|(
name|BRANCH_COST
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|insn_cost
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insn_b
condition|)
block|{
name|insn_cost
operator|+=
name|insn_rtx_cost
argument_list|(
name|PATTERN
argument_list|(
name|insn_b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_cost
operator|==
literal|0
operator|||
name|insn_cost
operator|>
name|COSTS_N_INSNS
argument_list|(
name|BRANCH_COST
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Possibly rearrange operands to make things come out more natural.  */
if|if
condition|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
condition|)
block|{
name|int
name|reversep
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|b
argument_list|,
name|x
argument_list|)
condition|)
name|reversep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|general_operand
argument_list|(
name|b
argument_list|,
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
name|reversep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
block|{
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|a
operator|,
name|a
operator|=
name|b
operator|,
name|b
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|insn_a
operator|,
name|insn_a
operator|=
name|insn_b
operator|,
name|insn_b
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|orig_a
operator|=
name|a
expr_stmt|;
name|orig_b
operator|=
name|b
expr_stmt|;
comment|/* If either operand is complex, load it into a register first.      The best way to do this is to copy the original insn.  In this      way we preserve any clobbers etc that the insn may have had.      This is of course not possible in the IS_MEM case.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|a
argument_list|,
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|no_new_pseudos
condition|)
goto|goto
name|end_seq_and_fail
goto|;
if|if
condition|(
name|is_mem
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insn_a
condition|)
goto|goto
name|end_seq_and_fail
goto|;
else|else
block|{
name|a
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|copy_rtx
argument_list|(
name|insn_a
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|a
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|end_seq_and_fail
goto|;
block|}
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|b
argument_list|,
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|set
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|no_new_pseudos
condition|)
goto|goto
name|end_seq_and_fail
goto|;
if|if
condition|(
name|is_mem
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insn_b
condition|)
goto|goto
name|end_seq_and_fail
goto|;
else|else
block|{
name|b
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|copy_rtx
argument_list|(
name|insn_b
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|b
expr_stmt|;
name|tmp
operator|=
name|PATTERN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* If insn to set up A clobbers any registers B depends on, try to 	 swap insn that sets up A with the one that sets up B.  If even 	 that doesn't help, punt.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|modified_in_p
argument_list|(
name|orig_b
argument_list|,
name|last
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|emit_insn_before
argument_list|(
name|tmp
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified_in_p
argument_list|(
name|orig_a
argument_list|,
name|tmp
argument_list|)
condition|)
goto|goto
name|end_seq_and_fail
goto|;
block|}
else|else
name|tmp
operator|=
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|end_seq_and_fail
goto|;
block|}
name|target
operator|=
name|noce_emit_cmove
argument_list|(
name|if_info
argument_list|,
name|x
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
goto|goto
name|end_seq_and_fail
goto|;
comment|/* If we're handling a memory for above, emit the load now.  */
if|if
condition|(
name|is_mem
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Copy over flags as appropriate.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|&&
name|MEM_IN_STRUCT_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_SCALAR_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|&&
name|MEM_SCALAR_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|MEM_SCALAR_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_ALIAS_SET
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|MEM_ALIAS_SET
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
name|MEM_ALIAS_SET
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|tmp
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|!=
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|tmp
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|end_seq_and_fail
label|:
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* For most cases, the simplified condition we found is the best    choice, but this is not the case for the min/max/abs transforms.    For these we wish to know that it is A or B in the condition.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_get_alt_condition
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
modifier|*
name|earliest
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|,
name|set
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|reverse
decl_stmt|;
comment|/* If target is already mentioned in the known condition, return it.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|if_info
operator|->
name|cond
argument_list|)
condition|)
block|{
operator|*
name|earliest
operator|=
name|if_info
operator|->
name|cond_earliest
expr_stmt|;
return|return
name|if_info
operator|->
name|cond
return|;
block|}
name|set
operator|=
name|pc_set
argument_list|(
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reverse
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
comment|/* If we're looking for a constant, try to make the conditional      have that constant in it.  There are two reasons why it may      not have the constant we want:       1. GCC may have needed to put the constant in a register, because         the target can't compare directly against that constant.  For         this case, we look for a SET immediately before the comparison         that puts a constant in that register.       2. GCC may have canonicalized the conditional, for example 	replacing "if x< 4" with "if x<= 3".  We can undo that (or 	make equivalent types of changes) to get the constants we need 	if they're off by one in the right direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
decl_stmt|;
name|rtx
name|op_a
init|=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op_b
init|=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|;
comment|/* First, look to see if we put a constant in a register.  */
name|prev_insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_insn
operator|&&
name|INSN_P
argument_list|(
name|prev_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|src
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|prev_insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|src
condition|)
name|src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op_a
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
argument_list|)
condition|)
name|op_a
operator|=
name|src
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op_b
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
argument_list|)
condition|)
name|op_b
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op_a
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tmp
init|=
name|op_a
decl_stmt|;
name|op_a
operator|=
name|op_b
expr_stmt|;
name|op_b
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, look to see if we can get the right constant by 	 adjusting the conditional.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op_b
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|desired_val
init|=
name|INTVAL
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|actual_val
init|=
name|INTVAL
argument_list|(
name|op_b
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|+
literal|1
condition|)
block|{
name|code
operator|=
name|LE
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|-
literal|1
condition|)
block|{
name|code
operator|=
name|LT
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|-
literal|1
condition|)
block|{
name|code
operator|=
name|GE
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|+
literal|1
condition|)
block|{
name|code
operator|=
name|GT
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If we made any changes, generate a new conditional that is 	 equivalent to what we started with, but has the right 	 constants in it.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
operator|||
name|op_a
operator|!=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
operator|||
name|op_b
operator|!=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|op_a
argument_list|,
name|op_b
argument_list|)
expr_stmt|;
operator|*
name|earliest
operator|=
name|if_info
operator|->
name|cond_earliest
expr_stmt|;
return|return
name|cond
return|;
block|}
block|}
name|cond
operator|=
name|canonicalize_condition
argument_list|(
name|if_info
operator|->
name|jump
argument_list|,
name|cond
argument_list|,
name|reverse
argument_list|,
name|earliest
argument_list|,
name|target
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|cond
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* We almost certainly searched back to a different place.      Need to re-verify correct lifetimes.  */
comment|/* X may not be mentioned in the range (cond_earliest, jump].  */
for|for
control|(
name|insn
operator|=
name|if_info
operator|->
name|jump
init|;
name|insn
operator|!=
operator|*
name|earliest
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* A and B may not be modified in the range [cond_earliest, jump).  */
for|for
control|(
name|insn
operator|=
operator|*
name|earliest
init|;
name|insn
operator|!=
name|if_info
operator|->
name|jump
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|modified_in_p
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|insn
argument_list|)
operator|||
name|modified_in_p
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (a< b) x = a; else x = b;" to "x = min(a, b);", etc.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_minmax
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|,
name|earliest
decl_stmt|,
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|,
name|op
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
comment|/* ??? Can't guarantee that expand_binop won't create pseudos.  */
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|FALSE
return|;
comment|/* ??? Reject modes with NaNs or signed zeros since we don't know how      they will be resolved with an SMIN/SMAX.  It wouldn't be too hard      to get the target to tell us...  */
if|if
condition|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
operator|||
name|HONOR_NANS
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|noce_get_alt_condition
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|a
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* Verify the condition is of the form we expect, and canonicalize      the comparison code.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_info
operator|->
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_info
operator|->
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* Determine what sort of operation this is.  Note that the code is for      a taken branch, so the code->operation mapping appears backwards.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
name|op
operator|=
name|SMAX
expr_stmt|;
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
name|op
operator|=
name|SMIN
expr_stmt|;
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LTU
case|:
case|case
name|LEU
case|:
name|op
operator|=
name|UMAX
expr_stmt|;
name|unsignedp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GTU
case|:
case|case
name|GEU
case|:
name|op
operator|=
name|UMIN
expr_stmt|;
name|unsignedp
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|op
argument_list|,
name|if_info
operator|->
name|a
argument_list|,
name|if_info
operator|->
name|b
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
name|if_info
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|if_info
operator|->
name|cond_earliest
operator|=
name|earliest
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (a< 0) x = -a; else x = a;" to "x = abs(a);", etc.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_abs
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|,
name|earliest
decl_stmt|,
name|target
decl_stmt|,
name|seq
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
name|int
name|negate
decl_stmt|;
comment|/* ??? Can't guarantee that expand_binop won't create pseudos.  */
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|FALSE
return|;
comment|/* Recognize A and B as constituting an ABS or NABS.  The canonical      form is a branch around the negation, taken when the object is the      first operand of a comparison against 0 that evaluates to true.  */
name|a
operator|=
name|if_info
operator|->
name|a
expr_stmt|;
name|b
operator|=
name|if_info
operator|->
name|b
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|NEG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
argument_list|)
condition|)
name|negate
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|NEG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|a
argument_list|)
condition|)
block|{
name|c
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
name|negate
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
name|cond
operator|=
name|noce_get_alt_condition
argument_list|(
name|if_info
argument_list|,
name|b
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* Verify the condition is of the form we expect.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
argument_list|)
condition|)
name|c
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|c
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* Verify that C is zero.  Search one step backward for a      REG_EQUAL note or a simple source if necessary.  */
if|if
condition|(
name|REG_P
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|rtx
name|set
decl_stmt|,
name|insn
init|=
name|prev_nonnote_insn
argument_list|(
name|earliest
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|c
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|MEM_P
argument_list|(
name|c
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|c
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Work around funny ideas get_condition has wrt canonicalization.      Note that these rtx constants are known to be CONST_INT, and      therefore imply integer comparisons.  */
if|if
condition|(
name|c
operator|==
name|constm1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|GT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|LT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Determine what sort of operation this is.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_abs_nojump
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|b
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? It's a quandary whether cmove would be better here, especially      for integers.  Perhaps combine will clean things up.  */
if|if
condition|(
name|target
operator|&&
name|negate
condition|)
name|target
operator|=
name|expand_simple_unop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|NEG
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
name|if_info
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|if_info
operator|->
name|cond_earliest
operator|=
name|earliest
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (m< 0) x = b; else x = 0;" to "x = (m>> C)& b;".  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_sign_mask
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|,
name|t
decl_stmt|,
name|m
decl_stmt|,
name|c
decl_stmt|,
name|seq
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|if_info
operator|->
name|cond
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|m
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|if_info
operator|->
name|a
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|LT
operator|&&
name|c
operator|==
name|const0_rtx
operator|)
operator|||
operator|(
name|code
operator|==
name|LE
operator|&&
name|c
operator|==
name|constm1_rtx
operator|)
condition|)
name|t
operator|=
name|if_info
operator|->
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_info
operator|->
name|b
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|GE
operator|&&
name|c
operator|==
name|const0_rtx
operator|)
operator|||
operator|(
name|code
operator|==
name|GT
operator|&&
name|c
operator|==
name|constm1_rtx
operator|)
condition|)
name|t
operator|=
name|if_info
operator|->
name|a
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|t
operator|||
name|side_effects_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We currently don't handle different modes.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
comment|/* This is only profitable if T is cheap, or T is unconditionally      executed/evaluated in the original insn sequence.  */
if|if
condition|(
name|rtx_cost
argument_list|(
name|t
argument_list|,
name|SET
argument_list|)
operator|>=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
operator|&&
operator|(
operator|!
name|if_info
operator|->
name|b_unconditional
operator|||
name|t
operator|!=
name|if_info
operator|->
name|b
operator|)
condition|)
return|return
name|FALSE
return|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Use emit_store_flag to generate "m< 0 ? -1 : 0" instead of expanding      "(signed) m>> 31" directly.  This benefits targets with specialized      insns to obtain the signmask, but still uses ashr_optab otherwise.  */
name|m
operator|=
name|emit_store_flag
argument_list|(
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
argument_list|,
name|LT
argument_list|,
name|m
argument_list|,
name|const0_rtx
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|m
condition|?
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|m
argument_list|,
name|t
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
else|:
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Optimize away "if (x& C) x |= C" and similar bit manipulation    transformations.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_bitop
parameter_list|(
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|,
name|x
decl_stmt|,
name|a
decl_stmt|,
name|result
decl_stmt|,
name|seq
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|bitnum
decl_stmt|;
name|x
operator|=
name|if_info
operator|->
name|x
expr_stmt|;
name|cond
operator|=
name|if_info
operator|->
name|cond
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
comment|/* Check for no else condition.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Check for a suitable condition.  */
if|if
condition|(
name|code
operator|!=
name|NE
operator|&&
name|code
operator|!=
name|EQ
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? We could also handle AND here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|!=
name|const1_rtx
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bitnum
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|bitnum
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|-
name|bitnum
expr_stmt|;
if|if
condition|(
name|bitnum
operator|<
literal|0
operator|||
name|bitnum
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|FALSE
return|;
block|}
else|else
return|return
name|FALSE
return|;
name|a
operator|=
name|if_info
operator|->
name|a
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|XOR
condition|)
block|{
comment|/* Check for "if (X& C) x = x op C".  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|!=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitnum
condition|)
return|return
name|FALSE
return|;
comment|/* if ((x& C) == 0) x |= C; is transformed to x |= C.   */
comment|/* if ((x& C) != 0) x |= C; is transformed to nothing.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|IOR
condition|)
name|result
operator|=
operator|(
name|code
operator|==
name|NE
operator|)
condition|?
name|a
else|:
name|NULL_RTX
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NE
condition|)
block|{
comment|/* if ((x& C) == 0) x ^= C; is transformed to x |= C.   */
name|result
operator|=
name|gen_int_mode
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitnum
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|result
operator|=
name|simplify_gen_binary
argument_list|(
name|IOR
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if ((x& C) != 0) x ^= C; is transformed to x&= ~C.  */
name|result
operator|=
name|gen_int_mode
argument_list|(
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitnum
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|result
operator|=
name|simplify_gen_binary
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|AND
condition|)
block|{
comment|/* Check for "if (X& C) x&= ~C".  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|!=
operator|(
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitnum
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* if ((x& C) == 0) x&= ~C; is transformed to nothing.  */
comment|/* if ((x& C) != 0) x&= ~C; is transformed to x&= ~C.  */
name|result
operator|=
operator|(
name|code
operator|==
name|EQ
operator|)
condition|?
name|a
else|:
name|NULL_RTX
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|result
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|noce_emit_move_insn
argument_list|(
name|x
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|if_info
operator|->
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Similar to get_condition, only the resulting condition must be    valid at JUMP, instead of at EARLIEST.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_get_condition
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
modifier|*
name|earliest
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|,
name|set
decl_stmt|,
name|tmp
decl_stmt|;
name|bool
name|reverse
decl_stmt|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|set
operator|=
name|pc_set
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false,      reverse the condition.  */
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|)
expr_stmt|;
comment|/* If the condition variable is a register and is MODE_INT, accept it.  */
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|tmp
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
operator|*
name|earliest
operator|=
name|jump
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cond
return|;
block|}
comment|/* Otherwise, fall back on canonicalize_condition to do the dirty      work of manipulating MODE_CC values and COMPARE rtx codes.  */
return|return
name|canonicalize_condition
argument_list|(
name|jump
argument_list|,
name|cond
argument_list|,
name|reverse
argument_list|,
name|earliest
argument_list|,
name|NULL_RTX
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize for a simple IF-THEN or IF-THEN-ELSE block.  We will not    be using conditional execution.  Set some fields of IF_INFO based    on CE_INFO: test_bb, cond, jump, cond_earliest.  Return TRUE if    things look OK.  */
end_comment

begin_function
specifier|static
name|int
name|noce_init_if_info
parameter_list|(
name|struct
name|ce_if_block
modifier|*
name|ce_info
parameter_list|,
name|struct
name|noce_if_info
modifier|*
name|if_info
parameter_list|)
block|{
name|basic_block
name|test_bb
init|=
name|ce_info
operator|->
name|test_bb
decl_stmt|;
name|rtx
name|cond
decl_stmt|,
name|jump
decl_stmt|;
comment|/* If test is comprised of&& or || elements, don't handle it unless      it is the special case of&& elements without an ELSE block.  */
if|if
condition|(
name|ce_info
operator|->
name|num_multiple_test_blocks
condition|)
block|{
if|if
condition|(
name|ce_info
operator|->
name|else_bb
operator|||
operator|!
name|ce_info
operator|->
name|and_and_p
condition|)
return|return
name|FALSE
return|;
name|ce_info
operator|->
name|test_bb
operator|=
name|test_bb
operator|=
name|ce_info
operator|->
name|last_test_bb
expr_stmt|;
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|=
literal|0
expr_stmt|;
name|ce_info
operator|->
name|num_and_and_blocks
operator|=
literal|0
expr_stmt|;
name|ce_info
operator|->
name|num_or_or_blocks
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is not a standard conditional jump, we can't parse it.  */
name|jump
operator|=
name|BB_END
argument_list|(
name|test_bb
argument_list|)
expr_stmt|;
name|cond
operator|=
name|noce_get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* If the conditional jump is more than just a conditional      jump, then we can not do if-conversion on this block.  */
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We must be comparing objects whose modes imply the size.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|FALSE
return|;
name|if_info
operator|->
name|test_bb
operator|=
name|test_bb
expr_stmt|;
name|if_info
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|if_info
operator|->
name|jump
operator|=
name|jump
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is ok for if-then-else processing.  */
end_comment

begin_function
specifier|static
name|int
name|noce_operand_ok
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* We special-case memories, so handle any of them with      no address side effects.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
operator|!
name|may_trap_p
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if a write into MEM may trap or fault.  */
end_comment

begin_function
specifier|static
name|bool
name|noce_mem_write_may_trap_or_fault_p
parameter_list|(
name|rtx
name|mem
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|MEM_READONLY_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|may_trap_or_fault_p
argument_list|(
name|mem
argument_list|)
condition|)
return|return
name|true
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call target hook to avoid the effects of -fpic etc....  */
name|addr
operator|=
name|targetm
operator|.
name|delegitimize_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_MODIFY
case|:
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_SUM
case|:
case|case
name|PRE_MODIFY
case|:
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
break|break;
case|case
name|LABEL_REF
case|:
return|return
name|true
return|;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|SYMBOL_REF_DECL
argument_list|(
name|addr
argument_list|)
operator|&&
name|decl_readonly_section
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it    without using conditional execution.  Return TRUE if we were    successful at converting the block.  */
end_comment

begin_function
specifier|static
name|int
name|noce_process_if_block
parameter_list|(
name|struct
name|ce_if_block
modifier|*
name|ce_info
parameter_list|)
block|{
name|basic_block
name|test_bb
init|=
name|ce_info
operator|->
name|test_bb
decl_stmt|;
comment|/* test block */
name|basic_block
name|then_bb
init|=
name|ce_info
operator|->
name|then_bb
decl_stmt|;
comment|/* THEN */
name|basic_block
name|else_bb
init|=
name|ce_info
operator|->
name|else_bb
decl_stmt|;
comment|/* ELSE or NULL */
name|struct
name|noce_if_info
name|if_info
decl_stmt|;
name|rtx
name|insn_a
decl_stmt|,
name|insn_b
decl_stmt|;
name|rtx
name|set_a
decl_stmt|,
name|set_b
decl_stmt|;
name|rtx
name|orig_x
decl_stmt|,
name|x
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|rtx
name|jump
decl_stmt|,
name|cond
decl_stmt|;
comment|/* We're looking for patterns of the form       (1) if (...) x = a; else x = b;      (2) x = b; if (...) x = a;      (3) if (...) x = a;   // as if with an initial x = x.       The later patterns require jumps to be more expensive.       ??? For future expansion, look for multiple X in such patterns.  */
if|if
condition|(
operator|!
name|noce_init_if_info
argument_list|(
name|ce_info
argument_list|,
operator|&
name|if_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|if_info
operator|.
name|cond
expr_stmt|;
name|jump
operator|=
name|if_info
operator|.
name|jump
expr_stmt|;
comment|/* Look for one of the potential sets.  */
name|insn_a
operator|=
name|first_active_insn
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_a
operator|||
name|insn_a
operator|!=
name|last_active_insn
argument_list|(
name|then_bb
argument_list|,
name|FALSE
argument_list|)
operator|||
operator|(
name|set_a
operator|=
name|single_set
argument_list|(
name|insn_a
argument_list|)
operator|)
operator|==
name|NULL_RTX
condition|)
return|return
name|FALSE
return|;
name|x
operator|=
name|SET_DEST
argument_list|(
name|set_a
argument_list|)
expr_stmt|;
name|a
operator|=
name|SET_SRC
argument_list|(
name|set_a
argument_list|)
expr_stmt|;
comment|/* Look for the other potential set.  Make sure we've got equivalent      destinations.  */
comment|/* ??? This is overconservative.  Storing to two different mems is      as easy as conditionally computing the address.  Storing to a      single mem merely requires a scratch memory to use as one of the      destination addresses; often the memory immediately below the      stack pointer is available for this.  */
name|set_b
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
block|{
name|insn_b
operator|=
name|first_active_insn
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_b
operator|||
name|insn_b
operator|!=
name|last_active_insn
argument_list|(
name|else_bb
argument_list|,
name|FALSE
argument_list|)
operator|||
operator|(
name|set_b
operator|=
name|single_set
argument_list|(
name|insn_b
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set_b
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|insn_b
operator|=
name|prev_nonnote_insn
argument_list|(
name|if_info
operator|.
name|cond_earliest
argument_list|)
expr_stmt|;
comment|/* We're going to be moving the evaluation of B down from above 	 COND_EARLIEST to JUMP.  Make sure the relevant data is still 	 intact.  */
if|if
condition|(
operator|!
name|insn_b
operator|||
operator|!
name|NONJUMP_INSN_P
argument_list|(
name|insn_b
argument_list|)
operator|||
operator|(
name|set_b
operator|=
name|single_set
argument_list|(
name|insn_b
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set_b
argument_list|)
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_SRC
argument_list|(
name|set_b
argument_list|)
argument_list|)
operator|||
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|set_b
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|if_info
operator|.
name|cond_earliest
argument_list|)
argument_list|,
name|jump
argument_list|)
comment|/* Likewise with X.  In particular this can happen when 	     noce_get_condition looks farther back in the instruction 	     stream than one might expect.  */
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|cond
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
operator|||
name|modified_between_p
argument_list|(
name|x
argument_list|,
name|PREV_INSN
argument_list|(
name|if_info
operator|.
name|cond_earliest
argument_list|)
argument_list|,
name|jump
argument_list|)
condition|)
name|insn_b
operator|=
name|set_b
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* If x has side effects then only the if-then-else form is safe to      convert.  But even in that case we would need to restore any notes      (such as REG_INC) at then end.  That can be tricky if      noce_emit_move_insn expands to more than one insn, so disable the      optimization entirely for now if there are side effects.  */
if|if
condition|(
name|side_effects_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|b
operator|=
operator|(
name|set_b
condition|?
name|SET_SRC
argument_list|(
name|set_b
argument_list|)
else|:
name|x
operator|)
expr_stmt|;
comment|/* Only operate on register destinations, and even then avoid extending      the lifetime of hard registers on small register class machines.  */
name|orig_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
return|return
name|FALSE
return|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|?
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
else|:
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Don't operate on sources that may trap or are volatile.  */
if|if
condition|(
operator|!
name|noce_operand_ok
argument_list|(
name|a
argument_list|)
operator|||
operator|!
name|noce_operand_ok
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Set up the info block for our subroutines.  */
name|if_info
operator|.
name|insn_a
operator|=
name|insn_a
expr_stmt|;
name|if_info
operator|.
name|insn_b
operator|=
name|insn_b
expr_stmt|;
name|if_info
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|if_info
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|if_info
operator|.
name|b
operator|=
name|b
expr_stmt|;
name|if_info
operator|.
name|b_unconditional
operator|=
name|else_bb
operator|==
literal|0
expr_stmt|;
comment|/* Try optimizations in some approximation of a useful order.  */
comment|/* ??? Should first look to see if X is live incoming at all.  If it      isn't, we don't need anything but an unconditional set.  */
comment|/* Look and see if A and B are really the same.  Avoid creating silly      cmove constructs that no one will fix up later.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
comment|/* If we have an INSN_B, we don't have to create any new rtl.  Just 	 move the instruction that we already have.  If we don't have an 	 INSN_B, that means that A == X, and we've got a noop move.  In 	 that case don't do anything and let the code below delete INSN_A.  */
if|if
condition|(
name|insn_b
operator|&&
name|else_bb
condition|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|else_bb
operator|&&
name|insn_b
operator|==
name|BB_END
argument_list|(
name|else_bb
argument_list|)
condition|)
name|BB_END
argument_list|(
name|else_bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn_b
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|insn_b
argument_list|,
name|insn_b
argument_list|,
name|PREV_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there was a REG_EQUAL note, delete it since it may have been 	     true due to this insn being after a jump.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn_b
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|remove_note
argument_list|(
name|insn_b
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|insn_b
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* If we have "x = b; if (...) x = a;", and x has side-effects, then 	 x must be executed twice.  */
elseif|else
if|if
condition|(
name|insn_b
operator|&&
name|side_effects_p
argument_list|(
name|orig_x
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|x
operator|=
name|orig_x
expr_stmt|;
goto|goto
name|success
goto|;
block|}
comment|/* Disallow the "if (...) x = a;" form (with an implicit "else x = x;")      for optimizations if writing to x may trap or fault, i.e. it's a memory      other than a static var or a stack slot, is misaligned on strict      aligned machines or is read-only.      If x is a read-only memory, then the program is valid only if we      avoid the store into it.  If there are stores on both the THEN and      ELSE arms, then we can go ahead with the conversion; either the      program is broken, or the condition is always false such that the      other memory is selected.  */
if|if
condition|(
operator|!
name|set_b
operator|&&
name|MEM_P
argument_list|(
name|orig_x
argument_list|)
operator|&&
name|noce_mem_write_may_trap_or_fault_p
argument_list|(
name|orig_x
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|noce_try_move
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_store_flag
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_bitop
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_minmax
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_abs
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|HAVE_conditional_move
operator|&&
name|noce_try_cmove
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
operator|!
name|HAVE_conditional_execution
condition|)
block|{
if|if
condition|(
name|noce_try_store_flag_constants
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_addcc
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_store_flag_mask
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|HAVE_conditional_move
operator|&&
name|noce_try_cmove_arith
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_sign_mask
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
block|}
return|return
name|FALSE
return|;
name|success
label|:
comment|/* The original sets may now be killed.  */
name|delete_insn
argument_list|(
name|insn_a
argument_list|)
expr_stmt|;
comment|/* Several special cases here: First, we may have reused insn_b above,      in which case insn_b is now NULL.  Second, we want to delete insn_b      if it came from the ELSE block, because follows the now correct      write that appears in the TEST block.  However, if we got insn_b from      the TEST block, it may in fact be loading data needed for the comparison.      We'll let life_analysis remove the insn if it's really dead.  */
if|if
condition|(
name|insn_b
operator|&&
name|else_bb
condition|)
name|delete_insn
argument_list|(
name|insn_b
argument_list|)
expr_stmt|;
comment|/* The new insns will have been inserted immediately before the jump.  We      should be able to remove the jump with impunity, but the condition itself      may have been modified by gcse to be shared across basic blocks.  */
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* If we used a temporary, fix it up now.  */
if|if
condition|(
name|orig_x
operator|!=
name|x
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|noce_emit_move_insn
argument_list|(
name|orig_x
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|insn_b
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|set_used_flags
argument_list|(
name|orig_x
argument_list|)
expr_stmt|;
name|unshare_all_rtl_in_chain
argument_list|(
name|insn_b
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after_setloc
argument_list|(
name|insn_b
argument_list|,
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|insn_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the blocks!  */
name|merge_if_block
argument_list|(
name|ce_info
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check whether a block is suitable for conditional move conversion.    Every insn must be a simple set of a register to a constant or a    register.  For each assignment, store the value in the array VALS,    indexed by register number.  COND is the condition we will    test.  */
end_comment

begin_function
specifier|static
name|int
name|check_cond_move_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
modifier|*
name|vals
parameter_list|,
name|rtx
name|cond
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|dest
decl_stmt|,
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|FALSE
return|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|||
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|HARD_REGISTER_P
argument_list|(
name|dest
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|src
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|may_trap_p
argument_list|(
name|src
argument_list|)
operator|||
name|may_trap_p
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Don't try to handle this if the source register was 	 modified earlier in the block.  */
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|vals
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|&&
name|vals
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
index|]
operator|!=
name|NULL
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Don't try to handle this if the destination register was 	 modified earlier in the block.  */
if|if
condition|(
name|vals
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Don't try to handle this if the condition uses the 	 destination register.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|cond
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|vals
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|src
expr_stmt|;
comment|/* Don't try to handle this if the source register is modified 	 later in the block.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|&&
name|modified_between_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it    using only conditional moves.  Return TRUE if we were successful at    converting the block.  */
end_comment

begin_function
specifier|static
name|int
name|cond_move_process_if_block
parameter_list|(
name|struct
name|ce_if_block
modifier|*
name|ce_info
parameter_list|)
block|{
name|basic_block
name|then_bb
init|=
name|ce_info
operator|->
name|then_bb
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|ce_info
operator|->
name|else_bb
decl_stmt|;
name|struct
name|noce_if_info
name|if_info
decl_stmt|;
name|rtx
name|jump
decl_stmt|,
name|cond
decl_stmt|,
name|insn
decl_stmt|,
name|seq
decl_stmt|,
name|cond_arg0
decl_stmt|,
name|cond_arg1
decl_stmt|,
name|loc_insn
decl_stmt|;
name|int
name|max_reg
decl_stmt|,
name|size
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|;
name|rtx
modifier|*
name|then_vals
decl_stmt|;
name|rtx
modifier|*
name|else_vals
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_conditional_move
operator|||
name|no_new_pseudos
condition|)
return|return
name|FALSE
return|;
name|memset
argument_list|(
operator|&
name|if_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noce_init_if_info
argument_list|(
name|ce_info
argument_list|,
operator|&
name|if_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|if_info
operator|.
name|cond
expr_stmt|;
name|jump
operator|=
name|if_info
operator|.
name|jump
expr_stmt|;
comment|/* Build a mapping for each block to the value used for each      register.  */
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|size
operator|=
operator|(
name|max_reg
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
expr_stmt|;
name|then_vals
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|else_vals
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|then_vals
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|else_vals
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Make sure the blocks are suitable.  */
if|if
condition|(
operator|!
name|check_cond_move_block
argument_list|(
name|then_bb
argument_list|,
name|then_vals
argument_list|,
name|cond
argument_list|)
operator|||
operator|(
name|else_bb
operator|&&
operator|!
name|check_cond_move_block
argument_list|(
name|else_bb
argument_list|,
name|else_vals
argument_list|,
name|cond
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Make sure the blocks can be used together.  If the same register      is set in both blocks, and is not set to a constant in both      cases, then both blocks must set it to the same register.  We      have already verified that if it is set to a register, that the      source register does not change after the assignment.  Also count      the number of registers set in only one of the blocks.  */
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_reg
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|then_vals
index|[
name|i
index|]
operator|&&
operator|!
name|else_vals
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|then_vals
index|[
name|i
index|]
operator|||
operator|!
name|else_vals
index|[
name|i
index|]
condition|)
operator|++
name|c
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|then_vals
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|else_vals
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|then_vals
index|[
name|i
index|]
argument_list|,
name|else_vals
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Make sure it is reasonable to convert this block.  What matters      is the number of assignments currently made in only one of the      branches, since if we convert we are going to always execute      them.  */
if|if
condition|(
name|c
operator|>
name|MAX_CONDITIONAL_EXECUTE
condition|)
return|return
name|FALSE
return|;
comment|/* Emit the conditional moves.  First do the then block, then do      anything left in the else blocks.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|cond_arg0
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond_arg1
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|then_bb
argument_list|,
argument|insn
argument_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|target
decl_stmt|,
name|dest
decl_stmt|,
name|t
decl_stmt|,
name|e
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|t
operator|=
name|then_vals
index|[
name|regno
index|]
expr_stmt|;
name|e
operator|=
name|else_vals
index|[
name|regno
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|e
operator|=
name|dest
expr_stmt|;
name|target
operator|=
name|noce_emit_cmove
argument_list|(
operator|&
name|if_info
argument_list|,
name|dest
argument_list|,
name|code
argument_list|,
name|cond_arg0
argument_list|,
name|cond_arg1
argument_list|,
name|t
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|dest
condition|)
name|noce_emit_move_insn
argument_list|(
name|dest
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|else_bb
condition|)
block|{
name|FOR_BB_INSNS
argument_list|(
argument|else_bb
argument_list|,
argument|insn
argument_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|target
decl_stmt|,
name|dest
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If this register was set in the then block, we already 	     handled this case above.  */
if|if
condition|(
name|then_vals
index|[
name|regno
index|]
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|else_vals
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|target
operator|=
name|noce_emit_cmove
argument_list|(
operator|&
name|if_info
argument_list|,
name|dest
argument_list|,
name|code
argument_list|,
name|cond_arg0
argument_list|,
name|cond_arg1
argument_list|,
name|dest
argument_list|,
name|else_vals
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|dest
condition|)
name|noce_emit_move_insn
argument_list|(
name|dest
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
name|seq
operator|=
name|end_ifcvt_sequence
argument_list|(
operator|&
name|if_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seq
condition|)
return|return
name|FALSE
return|;
name|loc_insn
operator|=
name|first_active_insn
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc_insn
condition|)
block|{
name|loc_insn
operator|=
name|first_active_insn
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loc_insn
argument_list|)
expr_stmt|;
block|}
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|jump
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|loc_insn
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|then_bb
argument_list|,
argument|insn
argument_list|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
block|{
name|FOR_BB_INSNS
argument_list|(
argument|else_bb
argument_list|,
argument|insn
argument_list|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|merge_if_block
argument_list|(
name|ce_info
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to convert an IF-THEN or IF-THEN-ELSE block into    straight line code.  Return true if successful.  */
end_comment

begin_function
specifier|static
name|int
name|process_if_block
parameter_list|(
name|struct
name|ce_if_block
modifier|*
name|ce_info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|noce_process_if_block
argument_list|(
name|ce_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|HAVE_conditional_move
operator|&&
name|cond_move_process_if_block
argument_list|(
name|ce_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|HAVE_conditional_execution
operator|&&
name|reload_completed
condition|)
block|{
comment|/* If we have&& and || tests, try to first handle combining the&& and          || tests into the conditional code, and if that fails, go back and          handle it without the&& and ||, which at present handles the&& case          if there was no ELSE block.  */
if|if
condition|(
name|cond_exec_process_if_block
argument_list|(
name|ce_info
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ce_info
operator|->
name|num_multiple_test_blocks
condition|)
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_exec_process_if_block
argument_list|(
name|ce_info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Merge the blocks and mark for local life update.  */
end_comment

begin_function
specifier|static
name|void
name|merge_if_block
parameter_list|(
name|struct
name|ce_if_block
modifier|*
name|ce_info
parameter_list|)
block|{
name|basic_block
name|test_bb
init|=
name|ce_info
operator|->
name|test_bb
decl_stmt|;
comment|/* last test block */
name|basic_block
name|then_bb
init|=
name|ce_info
operator|->
name|then_bb
decl_stmt|;
comment|/* THEN */
name|basic_block
name|else_bb
init|=
name|ce_info
operator|->
name|else_bb
decl_stmt|;
comment|/* ELSE or NULL */
name|basic_block
name|join_bb
init|=
name|ce_info
operator|->
name|join_bb
decl_stmt|;
comment|/* join block */
name|basic_block
name|combo_bb
decl_stmt|;
comment|/* All block merging is done into the lower block numbers.  */
name|combo_bb
operator|=
name|test_bb
expr_stmt|;
comment|/* Merge any basic blocks to handle&& and || subtests.  Each of      the blocks are on the fallthru path from the predecessor block.  */
if|if
condition|(
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|>
literal|0
condition|)
block|{
name|basic_block
name|bb
init|=
name|test_bb
decl_stmt|;
name|basic_block
name|last_test_bb
init|=
name|ce_info
operator|->
name|last_test_bb
decl_stmt|;
name|basic_block
name|fallthru
init|=
name|block_fallthru
argument_list|(
name|bb
argument_list|)
decl_stmt|;
do|do
block|{
name|bb
operator|=
name|fallthru
expr_stmt|;
name|fallthru
operator|=
name|block_fallthru
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|merge_blocks
argument_list|(
name|combo_bb
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|num_true_changes
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|bb
operator|!=
name|last_test_bb
condition|)
do|;
block|}
comment|/* Merge TEST block into THEN block.  Normally the THEN block won't have a      label, but it might if there were || tests.  That label's count should be      zero, and it normally should be removed.  */
if|if
condition|(
name|then_bb
condition|)
block|{
if|if
condition|(
name|combo_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
condition|)
name|COPY_REG_SET
argument_list|(
name|combo_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|then_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|merge_blocks
argument_list|(
name|combo_bb
argument_list|,
name|then_bb
argument_list|)
expr_stmt|;
name|num_true_changes
operator|++
expr_stmt|;
block|}
comment|/* The ELSE block, if it existed, had a label.  That label count      will almost always be zero, but odd things can happen when labels      get their addresses taken.  */
if|if
condition|(
name|else_bb
condition|)
block|{
name|merge_blocks
argument_list|(
name|combo_bb
argument_list|,
name|else_bb
argument_list|)
expr_stmt|;
name|num_true_changes
operator|++
expr_stmt|;
block|}
comment|/* If there was no join block reported, that means it was not adjacent      to the others, and so we cannot merge them.  */
if|if
condition|(
operator|!
name|join_bb
condition|)
block|{
name|rtx
name|last
init|=
name|BB_END
argument_list|(
name|combo_bb
argument_list|)
decl_stmt|;
comment|/* The outgoing edge for the current COMBO block should already 	 be correct.  Verify this.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|combo_bb
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
name|gcc_assert
argument_list|(
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL
argument_list|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|last
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|TRAP_IF
operator|&&
operator|(
name|TRAP_CONDITION
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|const_true_rtx
operator|)
operator|)
argument_list|)
expr_stmt|;
else|else
comment|/* There should still be something at the end of the THEN or ELSE          blocks taking us to our final destination.  */
name|gcc_assert
argument_list|(
name|JUMP_P
argument_list|(
name|last
argument_list|)
operator|||
operator|(
name|EDGE_SUCC
argument_list|(
name|combo_bb
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|CALL_P
argument_list|(
name|last
argument_list|)
operator|&&
name|SIBLING_CALL_P
argument_list|(
name|last
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|EDGE_SUCC
argument_list|(
name|combo_bb
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
operator|&&
name|can_throw_internal
argument_list|(
name|last
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* The JOIN block may have had quite a number of other predecessors too.      Since we've already merged the TEST, THEN and ELSE blocks, we should      have only one remaining edge from our if-then-else diamond.  If there      is more than one remaining edge, it must come from elsewhere.  There      may be zero incoming edges if the THEN block didn't actually join      back up (as with a call to a non-return function).  */
elseif|else
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|join_bb
operator|->
name|preds
argument_list|)
operator|<
literal|2
operator|&&
name|join_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* We can merge the JOIN.  */
if|if
condition|(
name|combo_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
condition|)
name|COPY_REG_SET
argument_list|(
name|combo_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|join_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|merge_blocks
argument_list|(
name|combo_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
name|num_true_changes
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* We cannot merge the JOIN.  */
comment|/* The outgoing edge for the current COMBO block should already 	 be correct.  Verify this.  */
name|gcc_assert
argument_list|(
name|single_succ_p
argument_list|(
name|combo_bb
argument_list|)
operator|&&
name|single_succ
argument_list|(
name|combo_bb
argument_list|)
operator|==
name|join_bb
argument_list|)
expr_stmt|;
comment|/* Remove the jump and cruft from the end of the COMBO block.  */
if|if
condition|(
name|join_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|tidy_fallthru_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|combo_bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|num_updated_if_blocks
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a block ending in a simple IF condition and try to transform it    in some way.  When converting a multi-block condition, put the new code    in the first such block and delete the rest.  Return a pointer to this    first block if some transformation was done.  Return NULL otherwise.  */
end_comment

begin_function
specifier|static
name|basic_block
name|find_if_header
parameter_list|(
name|basic_block
name|test_bb
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|ce_if_block_t
name|ce_info
decl_stmt|;
name|edge
name|then_edge
decl_stmt|;
name|edge
name|else_edge
decl_stmt|;
comment|/* The kind of block we're looking for has exactly two successors.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|test_bb
operator|->
name|succs
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|NULL
return|;
name|then_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|test_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|else_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|test_bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Neither edge should be abnormal.  */
if|if
condition|(
operator|(
name|then_edge
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|||
operator|(
name|else_edge
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Nor exit the loop.  */
if|if
condition|(
operator|(
name|then_edge
operator|->
name|flags
operator|&
name|EDGE_LOOP_EXIT
operator|)
operator|||
operator|(
name|else_edge
operator|->
name|flags
operator|&
name|EDGE_LOOP_EXIT
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* The THEN edge is canonically the one that falls through.  */
if|if
condition|(
name|then_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|else_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|edge
name|e
init|=
name|else_edge
decl_stmt|;
name|else_edge
operator|=
name|then_edge
expr_stmt|;
name|then_edge
operator|=
name|e
expr_stmt|;
block|}
else|else
comment|/* Otherwise this must be a multiway branch of some sort.  */
return|return
name|NULL
return|;
name|memset
argument_list|(
operator|&
name|ce_info
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ce_info
argument_list|)
argument_list|)
expr_stmt|;
name|ce_info
operator|.
name|test_bb
operator|=
name|test_bb
expr_stmt|;
name|ce_info
operator|.
name|then_bb
operator|=
name|then_edge
operator|->
name|dest
expr_stmt|;
name|ce_info
operator|.
name|else_bb
operator|=
name|else_edge
operator|->
name|dest
expr_stmt|;
name|ce_info
operator|.
name|pass
operator|=
name|pass
expr_stmt|;
ifdef|#
directive|ifdef
name|IFCVT_INIT_EXTRA_FIELDS
name|IFCVT_INIT_EXTRA_FIELDS
argument_list|(
operator|&
name|ce_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|find_if_block
argument_list|(
operator|&
name|ce_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|HAVE_trap
operator|&&
name|HAVE_conditional_trap
operator|&&
name|find_cond_trap
argument_list|(
name|test_bb
argument_list|,
name|then_edge
argument_list|,
name|else_edge
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_POST_DOMINATORS
index|]
operator|>=
name|DOM_NO_FAST_QUERY
operator|&&
operator|(
operator|!
name|HAVE_conditional_execution
operator|||
name|reload_completed
operator|)
condition|)
block|{
if|if
condition|(
name|find_if_case_1
argument_list|(
name|test_bb
argument_list|,
name|then_edge
argument_list|,
name|else_edge
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|find_if_case_2
argument_list|(
name|test_bb
argument_list|,
name|then_edge
argument_list|,
name|else_edge
argument_list|)
condition|)
goto|goto
name|success
goto|;
block|}
return|return
name|NULL
return|;
name|success
label|:
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Conversion succeeded on pass %d.\n"
argument_list|,
name|pass
argument_list|)
expr_stmt|;
return|return
name|ce_info
operator|.
name|test_bb
return|;
block|}
end_function

begin_comment
comment|/* Return true if a block has two edges, one of which falls through to the next    block, and the other jumps to a specific block, so that we can tell if the    block is part of an&& test or an || test.  Returns either -1 or the number    of non-note, non-jump, non-USE/CLOBBER insns in the block.  */
end_comment

begin_function
specifier|static
name|int
name|block_jumps_and_fallthru_p
parameter_list|(
name|basic_block
name|cur_bb
parameter_list|,
name|basic_block
name|target_bb
parameter_list|)
block|{
name|edge
name|cur_edge
decl_stmt|;
name|int
name|fallthru_p
init|=
name|FALSE
decl_stmt|;
name|int
name|jump_p
init|=
name|FALSE
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|int
name|n_insns
init|=
literal|0
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|cur_bb
operator|||
operator|!
name|target_bb
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If no edges, obviously it doesn't jump or fallthru.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|cur_bb
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|FOR_EACH_EDGE
argument_list|(
argument|cur_edge
argument_list|,
argument|ei
argument_list|,
argument|cur_bb->succs
argument_list|)
block|{
if|if
condition|(
name|cur_edge
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
comment|/* Anything complex isn't what we want.  */
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|cur_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|fallthru_p
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_edge
operator|->
name|dest
operator|==
name|target_bb
condition|)
name|jump_p
operator|=
name|TRUE
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|jump_p
operator|&
name|fallthru_p
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Don't allow calls in the block, since this is used to group&& and ||      together for conditional execution support.  ??? we should support      conditional execution support across calls for IA-64 some day, but      for now it makes the code simpler.  */
name|end
operator|=
name|BB_END
argument_list|(
name|cur_bb
argument_list|)
expr_stmt|;
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|cur_bb
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|n_insns
operator|++
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|n_insns
return|;
block|}
end_function

begin_comment
comment|/* Determine if a given basic block heads a simple IF-THEN or IF-THEN-ELSE    block.  If so, we'll try to convert the insns to not require the branch.    Return TRUE if we were successful at converting the block.  */
end_comment

begin_function
specifier|static
name|int
name|find_if_block
parameter_list|(
name|struct
name|ce_if_block
modifier|*
name|ce_info
parameter_list|)
block|{
name|basic_block
name|test_bb
init|=
name|ce_info
operator|->
name|test_bb
decl_stmt|;
name|basic_block
name|then_bb
init|=
name|ce_info
operator|->
name|then_bb
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|ce_info
operator|->
name|else_bb
decl_stmt|;
name|basic_block
name|join_bb
init|=
name|NULL_BLOCK
decl_stmt|;
name|edge
name|cur_edge
decl_stmt|;
name|basic_block
name|next
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|ce_info
operator|->
name|last_test_bb
operator|=
name|test_bb
expr_stmt|;
comment|/* Discover if any fall through predecessors of the current test basic block      were&& tests (which jump to the else block) or || tests (which jump to      the then block).  */
if|if
condition|(
name|HAVE_conditional_execution
operator|&&
name|reload_completed
operator|&&
name|single_pred_p
argument_list|(
name|test_bb
argument_list|)
operator|&&
name|single_pred_edge
argument_list|(
name|test_bb
argument_list|)
operator|->
name|flags
operator|==
name|EDGE_FALLTHRU
condition|)
block|{
name|basic_block
name|bb
init|=
name|single_pred
argument_list|(
name|test_bb
argument_list|)
decl_stmt|;
name|basic_block
name|target_bb
decl_stmt|;
name|int
name|max_insns
init|=
name|MAX_CONDITIONAL_EXECUTE
decl_stmt|;
name|int
name|n_insns
decl_stmt|;
comment|/* Determine if the preceding block is an&& or || block.  */
if|if
condition|(
operator|(
name|n_insns
operator|=
name|block_jumps_and_fallthru_p
argument_list|(
name|bb
argument_list|,
name|else_bb
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|ce_info
operator|->
name|and_and_p
operator|=
name|TRUE
expr_stmt|;
name|target_bb
operator|=
name|else_bb
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|n_insns
operator|=
name|block_jumps_and_fallthru_p
argument_list|(
name|bb
argument_list|,
name|then_bb
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|ce_info
operator|->
name|and_and_p
operator|=
name|FALSE
expr_stmt|;
name|target_bb
operator|=
name|then_bb
expr_stmt|;
block|}
else|else
name|target_bb
operator|=
name|NULL_BLOCK
expr_stmt|;
if|if
condition|(
name|target_bb
operator|&&
name|n_insns
operator|<=
name|max_insns
condition|)
block|{
name|int
name|total_insns
init|=
literal|0
decl_stmt|;
name|int
name|blocks
init|=
literal|0
decl_stmt|;
name|ce_info
operator|->
name|last_test_bb
operator|=
name|test_bb
expr_stmt|;
comment|/* Found at least one&& or || block, look for more.  */
do|do
block|{
name|ce_info
operator|->
name|test_bb
operator|=
name|test_bb
operator|=
name|bb
expr_stmt|;
name|total_insns
operator|+=
name|n_insns
expr_stmt|;
name|blocks
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|bb
operator|=
name|single_pred
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|n_insns
operator|=
name|block_jumps_and_fallthru_p
argument_list|(
name|bb
argument_list|,
name|target_bb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n_insns
operator|>=
literal|0
operator|&&
operator|(
name|total_insns
operator|+
name|n_insns
operator|)
operator|<=
name|max_insns
condition|)
do|;
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|=
name|blocks
expr_stmt|;
name|ce_info
operator|->
name|num_multiple_test_insns
operator|=
name|total_insns
expr_stmt|;
if|if
condition|(
name|ce_info
operator|->
name|and_and_p
condition|)
name|ce_info
operator|->
name|num_and_and_blocks
operator|=
name|blocks
expr_stmt|;
else|else
name|ce_info
operator|->
name|num_or_or_blocks
operator|=
name|blocks
expr_stmt|;
block|}
block|}
comment|/* The THEN block of an IF-THEN combo must have exactly one predecessor,      other than any || blocks which jump to the THEN block.  */
if|if
condition|(
operator|(
name|EDGE_COUNT
argument_list|(
name|then_bb
operator|->
name|preds
argument_list|)
operator|-
name|ce_info
operator|->
name|num_or_or_blocks
operator|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
comment|/* The edges of the THEN and ELSE blocks cannot have complex edges.  */
name|FOR_EACH_EDGE
argument_list|(
argument|cur_edge
argument_list|,
argument|ei
argument_list|,
argument|then_bb->preds
argument_list|)
block|{
if|if
condition|(
name|cur_edge
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
return|return
name|FALSE
return|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|cur_edge
argument_list|,
argument|ei
argument_list|,
argument|else_bb->preds
argument_list|)
block|{
if|if
condition|(
name|cur_edge
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* The THEN block of an IF-THEN combo must have zero or one successors.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|then_bb
operator|->
name|succs
argument_list|)
operator|>
literal|0
operator|&&
operator|(
operator|!
name|single_succ_p
argument_list|(
name|then_bb
argument_list|)
operator|||
operator|(
name|single_succ_edge
argument_list|(
name|then_bb
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|||
operator|(
name|flow2_completed
operator|&&
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|then_bb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the THEN block has no successors, conditional execution can still      make a conditional call.  Don't do this unless the ELSE block has      only one incoming edge -- the CFG manipulation is too ugly otherwise.      Check for the last insn of the THEN block being an indirect jump, which      is listed as not having any successors, but confuses the rest of the CE      code processing.  ??? we should fix this in the future.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|then_bb
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|single_pred_p
argument_list|(
name|else_bb
argument_list|)
condition|)
block|{
name|rtx
name|last_insn
init|=
name|BB_END
argument_list|(
name|then_bb
argument_list|)
decl_stmt|;
while|while
condition|(
name|last_insn
operator|&&
name|NOTE_P
argument_list|(
name|last_insn
argument_list|)
operator|&&
name|last_insn
operator|!=
name|BB_HEAD
argument_list|(
name|then_bb
argument_list|)
condition|)
name|last_insn
operator|=
name|PREV_INSN
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_insn
operator|&&
name|JUMP_P
argument_list|(
name|last_insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|join_bb
operator|=
name|else_bb
expr_stmt|;
name|else_bb
operator|=
name|NULL_BLOCK
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
comment|/* If the THEN block's successor is the other edge out of the TEST block,      then we have an IF-THEN combo without an ELSE.  */
elseif|else
if|if
condition|(
name|single_succ
argument_list|(
name|then_bb
argument_list|)
operator|==
name|else_bb
condition|)
block|{
name|join_bb
operator|=
name|else_bb
expr_stmt|;
name|else_bb
operator|=
name|NULL_BLOCK
expr_stmt|;
block|}
comment|/* If the THEN and ELSE block meet in a subsequent block, and the ELSE      has exactly one predecessor and one successor, and the outgoing edge      is not complex, then we have an IF-THEN-ELSE combo.  */
elseif|else
if|if
condition|(
name|single_succ_p
argument_list|(
name|else_bb
argument_list|)
operator|&&
name|single_succ
argument_list|(
name|then_bb
argument_list|)
operator|==
name|single_succ
argument_list|(
name|else_bb
argument_list|)
operator|&&
name|single_pred_p
argument_list|(
name|else_bb
argument_list|)
operator|&&
operator|!
operator|(
name|single_succ_edge
argument_list|(
name|else_bb
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
operator|!
operator|(
name|flow2_completed
operator|&&
name|tablejump_p
argument_list|(
name|BB_END
argument_list|(
name|else_bb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|join_bb
operator|=
name|single_succ
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
comment|/* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */
else|else
return|return
name|FALSE
return|;
name|num_possible_if_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIF-THEN%s block found, pass %d, start block %d "
literal|"[insn %d], then %d [%d]"
argument_list|,
operator|(
name|else_bb
operator|)
condition|?
literal|"-ELSE"
else|:
literal|""
argument_list|,
name|ce_info
operator|->
name|pass
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|BB_HEAD
argument_list|(
name|test_bb
argument_list|)
condition|?
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|BB_HEAD
argument_list|(
name|test_bb
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|then_bb
operator|->
name|index
argument_list|,
name|BB_HEAD
argument_list|(
name|then_bb
argument_list|)
condition|?
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|BB_HEAD
argument_list|(
name|then_bb
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|", else %d [%d]"
argument_list|,
name|else_bb
operator|->
name|index
argument_list|,
name|BB_HEAD
argument_list|(
name|else_bb
argument_list|)
condition|?
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|BB_HEAD
argument_list|(
name|else_bb
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|", join %d [%d]"
argument_list|,
name|join_bb
operator|->
name|index
argument_list|,
name|BB_HEAD
argument_list|(
name|join_bb
argument_list|)
condition|?
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|BB_HEAD
argument_list|(
name|join_bb
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|", %d %s block%s last test %d [%d]"
argument_list|,
name|ce_info
operator|->
name|num_multiple_test_blocks
argument_list|,
operator|(
name|ce_info
operator|->
name|and_and_p
operator|)
condition|?
literal|"&&"
else|:
literal|"||"
argument_list|,
operator|(
name|ce_info
operator|->
name|num_multiple_test_blocks
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|ce_info
operator|->
name|last_test_bb
operator|->
name|index
argument_list|,
operator|(
operator|(
name|BB_HEAD
argument_list|(
name|ce_info
operator|->
name|last_test_bb
argument_list|)
operator|)
condition|?
operator|(
name|int
operator|)
name|INSN_UID
argument_list|(
name|BB_HEAD
argument_list|(
name|ce_info
operator|->
name|last_test_bb
argument_list|)
argument_list|)
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure IF, THEN, and ELSE, blocks are adjacent.  Actually, we get the      first condition for free, since we've already asserted that there's a      fallthru edge from IF to THEN.  Likewise for the&& and || blocks, since      we checked the FALLTHRU flag, those are already adjacent to the last IF      block.  */
comment|/* ??? As an enhancement, move the ELSE block.  Have to deal with      BLOCK notes, if by no other means than backing out the merge if they      exist.  Sticky enough I don't want to think about it now.  */
name|next
operator|=
name|then_bb
expr_stmt|;
if|if
condition|(
name|else_bb
operator|&&
operator|(
name|next
operator|=
name|next
operator|->
name|next_bb
operator|)
operator|!=
name|else_bb
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|next
operator|=
name|next
operator|->
name|next_bb
operator|)
operator|!=
name|join_bb
operator|&&
name|join_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
if|if
condition|(
name|else_bb
condition|)
name|join_bb
operator|=
name|NULL
expr_stmt|;
else|else
return|return
name|FALSE
return|;
block|}
comment|/* Do the real work.  */
name|ce_info
operator|->
name|else_bb
operator|=
name|else_bb
expr_stmt|;
name|ce_info
operator|->
name|join_bb
operator|=
name|join_bb
expr_stmt|;
return|return
name|process_if_block
argument_list|(
name|ce_info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a branch over a trap, or a branch    to a trap, into a conditional trap.  */
end_comment

begin_function
specifier|static
name|int
name|find_cond_trap
parameter_list|(
name|basic_block
name|test_bb
parameter_list|,
name|edge
name|then_edge
parameter_list|,
name|edge
name|else_edge
parameter_list|)
block|{
name|basic_block
name|then_bb
init|=
name|then_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|else_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|other_bb
decl_stmt|,
name|trap_bb
decl_stmt|;
name|rtx
name|trap
decl_stmt|,
name|jump
decl_stmt|,
name|cond
decl_stmt|,
name|cond_earliest
decl_stmt|,
name|seq
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* Locate the block with the trap instruction.  */
comment|/* ??? While we look for no successors, we really ought to allow      EH successors.  Need to fix merge_if_block for that to work.  */
if|if
condition|(
operator|(
name|trap
operator|=
name|block_has_only_trap
argument_list|(
name|then_bb
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|trap_bb
operator|=
name|then_bb
operator|,
name|other_bb
operator|=
name|else_bb
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|trap
operator|=
name|block_has_only_trap
argument_list|(
name|else_bb
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|trap_bb
operator|=
name|else_bb
operator|,
name|other_bb
operator|=
name|then_bb
expr_stmt|;
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nTRAP-IF block found, start %d, trap %d\n"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|trap_bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* If this is not a standard conditional jump, we can't parse it.  */
name|jump
operator|=
name|BB_END
argument_list|(
name|test_bb
argument_list|)
expr_stmt|;
name|cond
operator|=
name|noce_get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|cond_earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* If the conditional jump is more than just a conditional jump, then      we can not do if-conversion on this block.  */
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We must be comparing objects whose modes imply the size.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|FALSE
return|;
comment|/* Reverse the comparison code, if necessary.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|then_bb
operator|==
name|trap_bb
condition|)
block|{
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Attempt to generate the conditional trap.  */
name|seq
operator|=
name|gen_cond_trap
argument_list|(
name|code
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TRAP_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|num_true_changes
operator|++
expr_stmt|;
comment|/* Emit the new insns before cond_earliest.  */
name|emit_insn_before_setloc
argument_list|(
name|seq
argument_list|,
name|cond_earliest
argument_list|,
name|INSN_LOCATOR
argument_list|(
name|trap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete the trap block if possible.  */
name|remove_edge
argument_list|(
name|trap_bb
operator|==
name|then_bb
condition|?
name|then_edge
else|:
name|else_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|trap_bb
operator|->
name|preds
argument_list|)
operator|==
literal|0
condition|)
name|delete_basic_block
argument_list|(
name|trap_bb
argument_list|)
expr_stmt|;
comment|/* If the non-trap block and the test are now adjacent, merge them.      Otherwise we must insert a direct branch.  */
if|if
condition|(
name|test_bb
operator|->
name|next_bb
operator|==
name|other_bb
condition|)
block|{
name|struct
name|ce_if_block
name|new_ce_info
decl_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|new_ce_info
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|new_ce_info
argument_list|)
argument_list|)
expr_stmt|;
name|new_ce_info
operator|.
name|test_bb
operator|=
name|test_bb
expr_stmt|;
name|new_ce_info
operator|.
name|then_bb
operator|=
name|NULL
expr_stmt|;
name|new_ce_info
operator|.
name|else_bb
operator|=
name|NULL
expr_stmt|;
name|new_ce_info
operator|.
name|join_bb
operator|=
name|other_bb
expr_stmt|;
name|merge_if_block
argument_list|(
operator|&
name|new_ce_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|lab
decl_stmt|,
name|newjump
decl_stmt|;
name|lab
operator|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|newjump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|lab
argument_list|)
argument_list|,
name|jump
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|lab
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|newjump
argument_list|)
operator|=
name|lab
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|newjump
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of find_cond_trap: if BB contains only a trap insn,    return it.  */
end_comment

begin_function
specifier|static
name|rtx
name|block_has_only_trap
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|trap
decl_stmt|;
comment|/* We're not the exit block.  */
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|NULL_RTX
return|;
comment|/* The block must have no successors.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* The only instruction in the THEN block must be the trap.  */
name|trap
operator|=
name|first_active_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|trap
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trap
argument_list|)
argument_list|)
operator|==
name|TRAP_IF
operator|&&
name|TRAP_CONDITION
argument_list|(
name|PATTERN
argument_list|(
name|trap
argument_list|)
argument_list|)
operator|==
name|const_true_rtx
operator|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|trap
return|;
block|}
end_function

begin_comment
comment|/* Look for IF-THEN-ELSE cases in which one of THEN or ELSE is    transformable, but not necessarily the other.  There need be no    JOIN block.     Return TRUE if we were successful at converting the block.     Cases we'd like to look at:     (1) 	if (test) goto over; // x not live 	x = a; 	goto label; 	over:     becomes  	x = a; 	if (! test) goto label;     (2) 	if (test) goto E; // x not live 	x = big(); 	goto L; 	E: 	x = b; 	goto M;     becomes  	x = b; 	if (test) goto M; 	x = big(); 	goto L;     (3) // This one's really only interesting for targets that can do        // multiway branching, e.g. IA-64 BBB bundles.  For other targets        // it results in multiple branches on a cache line, which often        // does not sit well with predictors.  	if (test1) goto E; // predicted not taken 	x = a; 	if (test2) goto F; 	... 	E: 	x = b; 	J:     becomes  	x = a; 	if (test1) goto E; 	if (test2) goto F;     Notes:     (A) Don't do (2) if the branch is predicted against the block we're    eliminating.  Do it anyway if we can eliminate a branch; this requires    that the sole successor of the eliminated block postdominate the other    side of the if.     (B) With CE, on (3) we can steal from both sides of the if, creating  	if (test1) x = a; 	if (!test1) x = b; 	if (test1) goto J; 	if (test2) goto F; 	... 	J:     Again, this is most useful if J postdominates.     (C) CE substitutes for helpful life information.     (D) These heuristics need a lot of work.  */
end_comment

begin_comment
comment|/* Tests for case 1 above.  */
end_comment

begin_function
specifier|static
name|int
name|find_if_case_1
parameter_list|(
name|basic_block
name|test_bb
parameter_list|,
name|edge
name|then_edge
parameter_list|,
name|edge
name|else_edge
parameter_list|)
block|{
name|basic_block
name|then_bb
init|=
name|then_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|else_edge
operator|->
name|dest
decl_stmt|,
name|new_bb
decl_stmt|;
name|int
name|then_bb_index
decl_stmt|;
comment|/* If we are partitioning hot/cold basic blocks, we don't want to      mess up unconditional or indirect jumps that cross between hot      and cold sections.         Basic block partitioning may result in some jumps that appear to      be optimizable (or blocks that appear to be mergeable), but which really       must be left untouched (they are required to make it safely across       partition boundaries).  See  the comments at the top of       bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */
if|if
condition|(
operator|(
name|BB_END
argument_list|(
name|then_bb
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|then_bb
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
operator|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
operator|(
name|BB_END
argument_list|(
name|else_bb
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|else_bb
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* THEN has one successor.  */
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|then_bb
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* THEN does not fall through, but is not strange either.  */
if|if
condition|(
name|single_succ_edge
argument_list|(
name|then_bb
argument_list|)
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FALLTHRU
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* THEN has one predecessor.  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|then_bb
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* THEN must do something.  */
if|if
condition|(
name|forwarder_block_p
argument_list|(
name|then_bb
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|num_possible_if_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIF-CASE-1 found, start %d, then %d\n"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|then_bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* THEN is small.  */
if|if
condition|(
operator|!
name|cheap_bb_rtx_cost_p
argument_list|(
name|then_bb
argument_list|,
name|COSTS_N_INSNS
argument_list|(
name|BRANCH_COST
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Registers set are dead, or are predicable.  */
if|if
condition|(
operator|!
name|dead_or_predicable
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|single_succ
argument_list|(
name|then_bb
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Conversion went ok, including moving the insns and fixing up the      jump.  Adjust the CFG to match.  */
name|bitmap_ior
argument_list|(
name|test_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|else_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|then_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
comment|/* We can avoid creating a new basic block if then_bb is immediately      followed by else_bb, i.e. deleting then_bb allows test_bb to fall      thru to else_bb.  */
if|if
condition|(
name|then_bb
operator|->
name|next_bb
operator|==
name|else_bb
operator|&&
name|then_bb
operator|->
name|prev_bb
operator|==
name|test_bb
operator|&&
name|else_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|redirect_edge_succ
argument_list|(
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|else_bb
argument_list|)
expr_stmt|;
name|new_bb
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|new_bb
operator|=
name|redirect_edge_and_branch_force
argument_list|(
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|else_bb
argument_list|)
expr_stmt|;
name|then_bb_index
operator|=
name|then_bb
operator|->
name|index
expr_stmt|;
name|delete_basic_block
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
comment|/* Make rest of code believe that the newly created block is the THEN_BB      block we removed.  */
if|if
condition|(
name|new_bb
condition|)
block|{
name|new_bb
operator|->
name|index
operator|=
name|then_bb_index
expr_stmt|;
name|SET_BASIC_BLOCK
argument_list|(
name|then_bb_index
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
comment|/* Since the fallthru edge was redirected from test_bb to new_bb,          we need to ensure that new_bb is in the same partition as          test bb (you can not fall through across section boundaries).  */
name|BB_COPY_PARTITION
argument_list|(
name|new_bb
argument_list|,
name|test_bb
argument_list|)
expr_stmt|;
block|}
comment|/* We've possibly created jump to next insn, cleanup_cfg will solve that      later.  */
name|num_true_changes
operator|++
expr_stmt|;
name|num_updated_if_blocks
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Test for case 2 above.  */
end_comment

begin_function
specifier|static
name|int
name|find_if_case_2
parameter_list|(
name|basic_block
name|test_bb
parameter_list|,
name|edge
name|then_edge
parameter_list|,
name|edge
name|else_edge
parameter_list|)
block|{
name|basic_block
name|then_bb
init|=
name|then_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|else_edge
operator|->
name|dest
decl_stmt|;
name|edge
name|else_succ
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* If we are partitioning hot/cold basic blocks, we don't want to      mess up unconditional or indirect jumps that cross between hot      and cold sections.         Basic block partitioning may result in some jumps that appear to      be optimizable (or blocks that appear to be mergeable), but which really       must be left untouched (they are required to make it safely across       partition boundaries).  See  the comments at the top of       bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */
if|if
condition|(
operator|(
name|BB_END
argument_list|(
name|then_bb
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|then_bb
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
operator|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
operator|(
name|BB_END
argument_list|(
name|else_bb
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|else_bb
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* ELSE has one successor.  */
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|else_bb
argument_list|)
condition|)
return|return
name|FALSE
return|;
else|else
name|else_succ
operator|=
name|single_succ_edge
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
comment|/* ELSE outgoing edge is not complex.  */
if|if
condition|(
name|else_succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
return|return
name|FALSE
return|;
comment|/* ELSE has one predecessor.  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|else_bb
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* THEN is not EXIT.  */
if|if
condition|(
name|then_bb
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
condition|)
return|return
name|FALSE
return|;
comment|/* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|else_succ
operator|->
name|dest
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
operator|||
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|then_bb
argument_list|,
name|else_succ
operator|->
name|dest
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
name|FALSE
return|;
name|num_possible_if_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nIF-CASE-2 found, start %d, else %d\n"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|else_bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* ELSE is small.  */
if|if
condition|(
operator|!
name|cheap_bb_rtx_cost_p
argument_list|(
name|else_bb
argument_list|,
name|COSTS_N_INSNS
argument_list|(
name|BRANCH_COST
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Registers set are dead, or are predicable.  */
if|if
condition|(
operator|!
name|dead_or_predicable
argument_list|(
name|test_bb
argument_list|,
name|else_bb
argument_list|,
name|then_bb
argument_list|,
name|else_succ
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Conversion went ok, including moving the insns and fixing up the      jump.  Adjust the CFG to match.  */
name|bitmap_ior
argument_list|(
name|test_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|then_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|else_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|delete_basic_block
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
name|num_true_changes
operator|++
expr_stmt|;
name|num_updated_if_blocks
operator|++
expr_stmt|;
comment|/* ??? We may now fallthru from one of THEN's successors into a join      block.  Rerun cleanup_cfg?  Examine things manually?  Wait?  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of dead_or_predicable called through for_each_rtx.    Return 1 if a memory is found.  */
end_comment

begin_function
specifier|static
name|int
name|find_memory
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|MEM_P
argument_list|(
operator|*
name|px
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used by the code above to perform the actual rtl transformations.    Return TRUE if successful.     TEST_BB is the block containing the conditional branch.  MERGE_BB    is the block containing the code to manipulate.  NEW_DEST is the    label TEST_BB should be branching to after the conversion.    REVERSEP is true if the sense of the branch should be reversed.  */
end_comment

begin_function
specifier|static
name|int
name|dead_or_predicable
parameter_list|(
name|basic_block
name|test_bb
parameter_list|,
name|basic_block
name|merge_bb
parameter_list|,
name|basic_block
name|other_bb
parameter_list|,
name|basic_block
name|new_dest
parameter_list|,
name|int
name|reversep
parameter_list|)
block|{
name|rtx
name|head
decl_stmt|,
name|end
decl_stmt|,
name|jump
decl_stmt|,
name|earliest
init|=
name|NULL_RTX
decl_stmt|,
name|old_dest
decl_stmt|,
name|new_label
init|=
name|NULL_RTX
decl_stmt|;
name|jump
operator|=
name|BB_END
argument_list|(
name|test_bb
argument_list|)
expr_stmt|;
comment|/* Find the extent of the real code in the merge block.  */
name|head
operator|=
name|BB_HEAD
argument_list|(
name|merge_bb
argument_list|)
expr_stmt|;
name|end
operator|=
name|BB_END
argument_list|(
name|merge_bb
argument_list|)
expr_stmt|;
comment|/* If merge_bb ends with a tablejump, predicating/moving insn's      into test_bb and then deleting merge_bb will result in the jumptable      that follows merge_bb being removed along with merge_bb and then we      get an unresolved reference to the jumptable.  */
if|if
condition|(
name|tablejump_p
argument_list|(
name|end
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|head
argument_list|)
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|end
condition|)
block|{
name|head
operator|=
name|end
operator|=
name|NULL_RTX
expr_stmt|;
goto|goto
name|no_body
goto|;
block|}
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|JUMP_P
argument_list|(
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|end
condition|)
block|{
name|head
operator|=
name|end
operator|=
name|NULL_RTX
expr_stmt|;
goto|goto
name|no_body
goto|;
block|}
name|end
operator|=
name|PREV_INSN
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* Disable handling dead code by conditional execution if the machine needs      to do anything funny with the tests, etc.  */
ifndef|#
directive|ifndef
name|IFCVT_MODIFY_TESTS
if|if
condition|(
name|HAVE_conditional_execution
condition|)
block|{
comment|/* In the conditional execution case, we have things easy.  We know 	 the condition is reversible.  We don't have to check life info 	 because we're going to conditionally execute the code anyway. 	 All that's left is making sure the insns involved can actually 	 be predicated.  */
name|rtx
name|cond
decl_stmt|,
name|prob_val
decl_stmt|;
name|cond
operator|=
name|cond_exec_get_condition
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
name|prob_val
operator|=
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|prob_val
condition|)
name|prob_val
operator|=
name|XEXP
argument_list|(
name|prob_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
block|{
name|enum
name|rtx_code
name|rev
init|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|==
name|UNKNOWN
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|rev
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prob_val
condition|)
name|prob_val
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|prob_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cond_exec_process_insns
argument_list|(
operator|(
name|ce_if_block_t
operator|*
operator|)
literal|0
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|cond
argument_list|,
name|prob_val
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|cancel
goto|;
name|earliest
operator|=
name|jump
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* In the non-conditional execution case, we have to verify that there 	 are no trapping operations, no calls, no references to memory, and 	 that any registers modified are dead at the branch site.  */
name|rtx
name|insn
decl_stmt|,
name|cond
decl_stmt|,
name|prev
decl_stmt|;
name|regset
name|merge_set
decl_stmt|,
name|tmp
decl_stmt|,
name|test_live
decl_stmt|,
name|test_set
decl_stmt|;
name|struct
name|propagate_block_info
modifier|*
name|pbi
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|fail
init|=
literal|0
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Check for no calls or trapping operations.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* ??? Even non-trapping memories such as stack frame 		 references must be avoided.  For stores, we collect 		 no lifetime info; for reads, we'd have to assert 		 true_dependence false against every store in the 		 TEST range.  */
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_memory
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Find the extent of the conditional.  */
name|cond
operator|=
name|noce_get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* Collect: 	   MERGE_SET = set of registers set in MERGE_BB 	   TEST_LIVE = set of registers live at EARLIEST 	   TEST_SET  = set of registers set between EARLIEST and the 		       end of the block.  */
name|tmp
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|merge_set
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|test_live
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|test_set
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
comment|/* ??? bb->local_set is only valid during calculate_global_regs_live, 	 so we must recompute usage for MERGE_BB.  Not so bad, I suppose,          since we've already asserted that MERGE_BB is small.  */
comment|/* If we allocated new pseudos (e.g. in the conditional move 	 expander called from noce_emit_cmove), we must resize the 	 array first.  */
if|if
condition|(
name|max_regno
operator|<
name|max_reg_num
argument_list|()
condition|)
block|{
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|propagate_block
argument_list|(
name|merge_bb
argument_list|,
name|tmp
argument_list|,
name|merge_set
argument_list|,
name|merge_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For small register class machines, don't lengthen lifetimes of 	 hard registers before reload.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|!
name|reload_completed
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|merge_set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* For TEST, we're interested in a range of insns, not a whole block. 	 Moreover, we're interested in the insns live from OTHER_BB.  */
name|COPY_REG_SET
argument_list|(
name|test_live
argument_list|,
name|other_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|test_bb
argument_list|,
name|test_live
argument_list|,
name|test_set
argument_list|,
name|test_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|jump
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|earliest
condition|)
break|break;
block|}
name|free_propagate_block_info
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
comment|/* We can perform the transformation if 	   MERGE_SET& (TEST_SET | TEST_LIVE) 	 and 	   TEST_SET& merge_bb->il.rtl->global_live_at_start 	 are empty.  */
if|if
condition|(
name|bitmap_intersect_p
argument_list|(
name|test_set
argument_list|,
name|merge_set
argument_list|)
operator|||
name|bitmap_intersect_p
argument_list|(
name|test_live
argument_list|,
name|merge_set
argument_list|)
operator|||
name|bitmap_intersect_p
argument_list|(
name|test_set
argument_list|,
name|merge_bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|merge_set
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|test_live
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|test_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
return|return
name|FALSE
return|;
block|}
name|no_body
label|:
comment|/* We don't want to use normal invert_jump or redirect_jump because      we don't want to delete_insn called.  Also, we want to do our own      change group management.  */
name|old_dest
operator|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_bb
operator|!=
name|new_dest
condition|)
block|{
name|new_label
operator|=
name|block_label
argument_list|(
name|new_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|?
operator|!
name|invert_jump_1
argument_list|(
name|jump
argument_list|,
name|new_label
argument_list|)
else|:
operator|!
name|redirect_jump_1
argument_list|(
name|jump
argument_list|,
name|new_label
argument_list|)
condition|)
goto|goto
name|cancel
goto|;
block|}
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|other_bb
operator|!=
name|new_dest
condition|)
block|{
name|redirect_jump_2
argument_list|(
name|jump
argument_list|,
name|old_dest
argument_list|,
name|new_label
argument_list|,
operator|-
literal|1
argument_list|,
name|reversep
argument_list|)
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
block|{
name|gcov_type
name|count
decl_stmt|,
name|probability
decl_stmt|;
name|count
operator|=
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
expr_stmt|;
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|probability
operator|=
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
expr_stmt|;
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
operator|=
name|probability
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|test_bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move the insns out of MERGE_BB to before the branch.  */
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|BB_END
argument_list|(
name|merge_bb
argument_list|)
condition|)
name|BB_END
argument_list|(
name|merge_bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|end
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* PR 21767: When moving insns above a conditional branch, REG_EQUAL 	 notes might become invalid.  */
name|insn
operator|=
name|head
expr_stmt|;
do|do
block|{
name|rtx
name|note
decl_stmt|,
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
continue|continue;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
operator|!
name|function_invariant_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|end
operator|&&
operator|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
do|;
name|reorder_insns
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|PREV_INSN
argument_list|(
name|earliest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the jump and edge if we can.  */
if|if
condition|(
name|other_bb
operator|==
name|new_dest
condition|)
block|{
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|remove_edge
argument_list|(
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Can't merge blocks here, as then_bb is still in use. 	 At minimum, the merge will get done just before bb-reorder.  */
block|}
return|return
name|TRUE
return|;
name|cancel
label|:
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point for all if-conversion.  */
end_comment

begin_function
specifier|static
name|void
name|if_convert
parameter_list|(
name|int
name|x_life_data_ok
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|num_possible_if_blocks
operator|=
literal|0
expr_stmt|;
name|num_updated_if_blocks
operator|=
literal|0
expr_stmt|;
name|num_true_changes
operator|=
literal|0
expr_stmt|;
name|life_data_ok
operator|=
operator|(
name|x_life_data_ok
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|targetm
operator|.
name|cannot_modify_jumps_p
argument_list|()
operator|)
operator|&&
operator|(
operator|!
name|flag_reorder_blocks_and_partition
operator|||
operator|!
name|no_new_pseudos
operator|||
operator|!
name|targetm
operator|.
name|have_named_sections
operator|)
condition|)
block|{
name|struct
name|loops
name|loops
decl_stmt|;
name|flow_loops_find
argument_list|(
operator|&
name|loops
argument_list|)
expr_stmt|;
name|mark_loop_exit_edges
argument_list|(
operator|&
name|loops
argument_list|)
expr_stmt|;
name|flow_loops_free
argument_list|(
operator|&
name|loops
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
block|}
comment|/* Compute postdominators if we think we'll use them.  */
if|if
condition|(
name|HAVE_conditional_execution
operator|||
name|life_data_ok
condition|)
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|life_data_ok
condition|)
name|clear_bb_flags
argument_list|()
expr_stmt|;
comment|/* Go through each of the basic blocks looking for things to convert.  If we      have conditional execution, we make multiple passes to allow us to handle      IF-THEN{-ELSE} blocks within other IF-THEN{-ELSE} blocks.  */
name|pass
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cond_exec_changed_p
operator|=
name|FALSE
expr_stmt|;
name|pass
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IFCVT_MULTIPLE_DUMPS
if|if
condition|(
name|dump_file
operator|&&
name|pass
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n========== Pass %d ==========\n"
argument_list|,
name|pass
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
while|while
condition|(
operator|(
name|new_bb
operator|=
name|find_if_header
argument_list|(
name|bb
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
name|bb
operator|=
name|new_bb
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IFCVT_MULTIPLE_DUMPS
if|if
condition|(
name|dump_file
operator|&&
name|cond_exec_changed_p
condition|)
name|print_rtl_with_bb
argument_list|(
name|dump_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|cond_exec_changed_p
condition|)
do|;
ifdef|#
directive|ifdef
name|IFCVT_MULTIPLE_DUMPS
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n========== no more changes\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fflush
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
comment|/* Rebuild life info for basic blocks that require it.  */
if|if
condition|(
name|num_true_changes
operator|&&
name|life_data_ok
condition|)
block|{
comment|/* If we allocated new pseudos, we must resize the array for sched1.  */
if|if
condition|(
name|max_regno
operator|<
name|max_reg_num
argument_list|()
condition|)
block|{
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|update_life_info_in_dirty_blocks
argument_list|(
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
block|}
comment|/* Write the final stats.  */
if|if
condition|(
name|dump_file
operator|&&
name|num_possible_if_blocks
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n%d possible IF blocks searched.\n"
argument_list|,
name|num_possible_if_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d IF blocks converted.\n"
argument_list|,
name|num_updated_if_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d true changes made.\n\n\n"
argument_list|,
name|num_true_changes
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_if_conversion
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If-conversion and CFG cleanup.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_if_conversion
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_if_conversion
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|dump_flow_info
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|if_convert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|timevar_push
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_JUMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_rtl_ifcvt
init|=
block|{
literal|"ce1"
block|,
comment|/* name */
name|gate_handle_if_conversion
block|,
comment|/* gate */
name|rest_of_handle_if_conversion
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IFCVT
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'C'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|gate_handle_if_after_combine
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_if_conversion
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Rerun if-conversion, as combine may have simplified things enough    to now meet sequence length restrictions.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_if_after_combine
parameter_list|(
name|void
parameter_list|)
block|{
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|if_convert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_if_after_combine
init|=
block|{
literal|"ce2"
block|,
comment|/* name */
name|gate_handle_if_after_combine
block|,
comment|/* gate */
name|rest_of_handle_if_after_combine
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IFCVT
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'C'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|gate_handle_if_after_reload
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_if_after_reload
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Last attempt to optimize CFG, as scheduling, peepholing and insn      splitting possibly introduced more crossjumping opportunities.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
operator||
operator|(
name|flag_crossjumping
condition|?
name|CLEANUP_CROSSJUMP
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_if_conversion2
condition|)
name|if_convert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_if_after_reload
init|=
block|{
literal|"ce3"
block|,
comment|/* name */
name|gate_handle_if_after_reload
block|,
comment|/* gate */
name|rest_of_handle_if_after_reload
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IFCVT2
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'E'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

