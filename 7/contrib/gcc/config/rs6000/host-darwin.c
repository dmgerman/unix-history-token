begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Darwin/powerpc host-specific hook definitions.    Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucontext.h>
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks-def.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"config/host-darwin.h"
end_include

begin_function_decl
specifier|static
name|void
name|segv_crash_handler
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|segv_handler
parameter_list|(
name|int
parameter_list|,
name|siginfo_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|darwin_rs6000_extra_signals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_DECL_SIGALTSTACK
end_ifndef

begin_comment
comment|/* This doesn't have a prototype in signal.h in 10.2.x and earlier,    fixed in later releases.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|sigaltstack
parameter_list|(
specifier|const
name|struct
name|sigaltstack
modifier|*
parameter_list|,
name|struct
name|sigaltstack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The fields of the mcontext_t type have acquired underscores in later    OS versions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_MCONTEXT_T_UNDERSCORES
end_ifdef

begin_define
define|#
directive|define
name|MC_FLD
parameter_list|(
name|x
parameter_list|)
value|__ ## x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MC_FLD
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_EXTRA_SIGNALS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_EXTRA_SIGNALS
value|darwin_rs6000_extra_signals
end_define

begin_comment
comment|/* On Darwin/powerpc, hitting the stack limit turns into a SIGSEGV.    This code detects the difference between hitting the stack limit and    a true wild pointer dereference by looking at the instruction that    faulted; only a few kinds of instruction are used to access below    the previous bottom of the stack.  */
end_comment

begin_function
specifier|static
name|void
name|segv_crash_handler
parameter_list|(
name|int
name|sig
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"Segmentation Fault (code)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|segv_handler
parameter_list|(
name|int
name|sig
name|ATTRIBUTE_UNUSED
parameter_list|,
name|siginfo_t
modifier|*
name|sip
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|scp
parameter_list|)
block|{
name|ucontext_t
modifier|*
name|uc
init|=
operator|(
name|ucontext_t
operator|*
operator|)
name|scp
decl_stmt|;
name|sigset_t
name|sigset
decl_stmt|;
name|unsigned
name|faulting_insn
decl_stmt|;
comment|/* The fault might have happened when trying to run some instruction, in      which case the next line will segfault _again_.  Handle this case.  */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|segv_crash_handler
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigset
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sigset
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|faulting_insn
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|uc
operator|->
name|uc_mcontext
operator|->
name|MC_FLD
argument_list|(
name|ss
argument_list|)
operator|.
name|MC_FLD
argument_list|(
name|srr0
argument_list|)
expr_stmt|;
comment|/* Note that this only has to work for GCC, so we don't have to deal      with all the possible cases (GCC has no AltiVec code, for      instance).  It's complicated because Darwin allows stores to      below the stack pointer, and the prologue code takes advantage of      this.  */
if|if
condition|(
operator|(
name|faulting_insn
operator|&
literal|0xFFFF8000
operator|)
operator|==
literal|0x94218000
comment|/* stwu %r1, -xxx(%r1) */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFC1F03FF
operator|)
operator|==
literal|0x7C01016E
comment|/* stwux xxx, %r1, xxx */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFC1F8000
operator|)
operator|==
literal|0x90018000
comment|/* stw xxx, -yyy(%r1) */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFC1F8000
operator|)
operator|==
literal|0xD8018000
comment|/* stfd xxx, -yyy(%r1) */
operator|||
operator|(
name|faulting_insn
operator|&
literal|0xFC1F8000
operator|)
operator|==
literal|0xBC018000
comment|/* stmw xxx, -yyy(%r1) */
condition|)
block|{
name|char
modifier|*
name|shell_name
decl_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Out of stack space.\n"
argument_list|)
expr_stmt|;
name|shell_name
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_name
operator|!=
name|NULL
condition|)
name|shell_name
operator|=
name|strrchr
argument_list|(
name|shell_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_name
operator|!=
name|NULL
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|shell_commands
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|"sh"
block|,
literal|"ulimit -S -s unlimited"
block|}
block|,
block|{
literal|"bash"
block|,
literal|"ulimit -S -s unlimited"
block|}
block|,
block|{
literal|"tcsh"
block|,
literal|"limit stacksize unlimited"
block|}
block|,
block|{
literal|"csh"
block|,
literal|"limit stacksize unlimited"
block|}
block|,
comment|/* zsh doesn't have "unlimited", this will work under the 	       default configuration.  */
block|{
literal|"zsh"
block|,
literal|"limit stacksize 32m"
block|}
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|shell_commands
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|shell_commands
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|shell_name
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Try running '%s' in the shell to raise its limit.\n"
argument_list|,
name|shell_commands
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|global_dc
operator|->
name|abort_on_error
condition|)
name|fancy_abort
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[address=%08lx pc=%08x]\n"
argument_list|,
name|uc
operator|->
name|uc_mcontext
operator|->
name|MC_FLD
argument_list|(
name|es
argument_list|)
operator|.
name|MC_FLD
argument_list|(
name|dar
argument_list|)
argument_list|,
name|uc
operator|->
name|uc_mcontext
operator|->
name|MC_FLD
argument_list|(
name|ss
argument_list|)
operator|.
name|MC_FLD
argument_list|(
name|srr0
argument_list|)
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"Segmentation Fault"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|darwin_rs6000_extra_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|sact
decl_stmt|;
name|stack_t
name|sigstk
decl_stmt|;
name|sigstk
operator|.
name|ss_sp
operator|=
name|xmalloc
argument_list|(
name|SIGSTKSZ
argument_list|)
expr_stmt|;
name|sigstk
operator|.
name|ss_size
operator|=
name|SIGSTKSZ
expr_stmt|;
name|sigstk
operator|.
name|ss_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigaltstack
argument_list|(
operator|&
name|sigstk
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"While setting up signal stack: %m"
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sact
operator|.
name|sa_flags
operator|=
name|SA_ONSTACK
operator||
name|SA_SIGINFO
expr_stmt|;
name|sact
operator|.
name|sa_sigaction
operator|=
name|segv_handler
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGSEGV
argument_list|,
operator|&
name|sact
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"While setting up signal handler: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|struct
name|host_hooks
name|host_hooks
init|=
name|HOST_HOOKS_INITIALIZER
decl_stmt|;
end_decl_stmt

end_unit

