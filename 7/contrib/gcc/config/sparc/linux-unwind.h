begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 EH unwinding support for SPARC Linux.    Copyright 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file with other programs, and to distribute those programs without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into another program.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Do code reading to identify a signal frame, and set the frame    state data appropriately.  See unwind-dw2.c for the structs.  */
end_comment

begin_comment
comment|/* Handle multilib correctly.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__arch64__
argument_list|)
end_if

begin_comment
comment|/* 64-bit SPARC version */
end_comment

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
value|sparc64_fallback_frame_state
end_define

begin_function
specifier|static
name|_Unwind_Reason_Code
name|sparc64_fallback_frame_state
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|pc
init|=
name|context
operator|->
name|ra
decl_stmt|;
name|long
name|new_cfa
decl_stmt|,
name|i
decl_stmt|;
name|long
name|regs_off
decl_stmt|,
name|fpu_save_off
decl_stmt|;
name|long
name|this_cfa
decl_stmt|,
name|fpu_save
decl_stmt|;
if|if
condition|(
name|pc
index|[
literal|0
index|]
operator|!=
literal|0x82102065
comment|/* mov NR_rt_sigreturn, %g1 */
operator|||
name|pc
index|[
literal|1
index|]
operator|!=
literal|0x91d0206d
condition|)
comment|/* ta 0x6d */
return|return
name|_URC_END_OF_STACK
return|;
name|regs_off
operator|=
literal|192
operator|+
literal|128
expr_stmt|;
name|fpu_save_off
operator|=
name|regs_off
operator|+
operator|(
literal|16
operator|*
literal|8
operator|)
operator|+
operator|(
literal|3
operator|*
literal|8
operator|)
operator|+
operator|(
literal|2
operator|*
literal|4
operator|)
expr_stmt|;
name|this_cfa
operator|=
operator|(
name|long
operator|)
name|context
operator|->
name|cfa
expr_stmt|;
name|new_cfa
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
operator|(
name|context
operator|->
name|cfa
operator|)
operator|+
operator|(
name|regs_off
operator|+
operator|(
literal|14
operator|*
literal|8
operator|)
operator|)
operator|)
expr_stmt|;
name|new_cfa
operator|+=
literal|2047
expr_stmt|;
comment|/* Stack bias */
name|fpu_save
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
operator|(
name|this_cfa
operator|)
operator|+
operator|(
name|fpu_save_off
operator|)
operator|)
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
literal|14
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|new_cfa
operator|-
operator|(
name|long
operator|)
name|context
operator|->
name|cfa
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|this_cfa
operator|+
operator|(
name|regs_off
operator|+
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|-
name|new_cfa
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|16
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|16
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|this_cfa
operator|+
operator|(
name|i
operator|*
literal|8
operator|)
operator|-
name|new_cfa
expr_stmt|;
block|}
if|if
condition|(
name|fpu_save
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|32
operator|&&
operator|(
name|i
operator|&
literal|0x1
operator|)
condition|)
continue|continue;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|32
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|32
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|fpu_save
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
operator|-
name|new_cfa
expr_stmt|;
block|}
block|}
comment|/* Stick return address into %g0, same trick Alpha uses.  */
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|this_cfa
operator|+
operator|(
name|regs_off
operator|+
operator|(
literal|16
operator|*
literal|8
operator|)
operator|+
literal|8
operator|)
operator|-
name|new_cfa
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
literal|0
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* 32-bit SPARC version */
end_comment

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
value|sparc_fallback_frame_state
end_define

begin_function
specifier|static
name|_Unwind_Reason_Code
name|sparc_fallback_frame_state
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|pc
init|=
name|context
operator|->
name|ra
decl_stmt|;
name|int
name|new_cfa
decl_stmt|,
name|i
decl_stmt|,
name|oldstyle
decl_stmt|;
name|int
name|regs_off
decl_stmt|,
name|fpu_save_off
decl_stmt|;
name|int
name|fpu_save
decl_stmt|,
name|this_cfa
decl_stmt|;
if|if
condition|(
name|pc
index|[
literal|1
index|]
operator|!=
literal|0x91d02010
condition|)
comment|/* ta 0x10 */
return|return
name|_URC_END_OF_STACK
return|;
if|if
condition|(
name|pc
index|[
literal|0
index|]
operator|==
literal|0x821020d8
condition|)
comment|/* mov NR_sigreturn, %g1 */
name|oldstyle
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|pc
index|[
literal|0
index|]
operator|==
literal|0x82102065
condition|)
comment|/* mov NR_rt_sigreturn, %g1 */
name|oldstyle
operator|=
literal|0
expr_stmt|;
else|else
return|return
name|_URC_END_OF_STACK
return|;
if|if
condition|(
name|oldstyle
condition|)
block|{
name|regs_off
operator|=
literal|96
expr_stmt|;
name|fpu_save_off
operator|=
name|regs_off
operator|+
operator|(
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
literal|16
operator|*
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|regs_off
operator|=
literal|96
operator|+
literal|128
expr_stmt|;
name|fpu_save_off
operator|=
name|regs_off
operator|+
operator|(
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
literal|16
operator|*
literal|4
operator|)
operator|+
operator|(
literal|2
operator|*
literal|4
operator|)
expr_stmt|;
block|}
name|this_cfa
operator|=
operator|(
name|int
operator|)
name|context
operator|->
name|cfa
expr_stmt|;
name|new_cfa
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|context
operator|->
name|cfa
operator|)
operator|+
operator|(
name|regs_off
operator|+
operator|(
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
literal|14
operator|*
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
name|fpu_save
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|this_cfa
operator|)
operator|+
operator|(
name|fpu_save_off
operator|)
operator|)
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
literal|14
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|new_cfa
operator|-
operator|(
name|int
operator|)
name|context
operator|->
name|cfa
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|14
condition|)
continue|continue;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|this_cfa
operator|+
operator|(
name|regs_off
operator|+
operator|(
literal|4
operator|*
literal|4
operator|)
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
operator|-
name|new_cfa
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|16
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|16
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|this_cfa
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|-
name|new_cfa
expr_stmt|;
block|}
if|if
condition|(
name|fpu_save
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|32
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
operator|+
literal|32
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|fpu_save
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
operator|-
name|new_cfa
expr_stmt|;
block|}
block|}
comment|/* Stick return address into %g0, same trick Alpha uses.  */
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
literal|0
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|this_cfa
operator|+
operator|(
name|regs_off
operator|+
literal|4
operator|)
operator|-
name|new_cfa
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
literal|0
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

