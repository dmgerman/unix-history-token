begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target support for C++ classes on Windows.    Contributed by Danny Smith (dannysmith@users.sourceforge.net)    Copyright (C) 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp/cp-tree.h"
end_include

begin_comment
comment|/* this is why we're a separate module */
end_comment

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_function
name|bool
name|i386_pe_type_dllimport_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_NOP_FUN_DLLIMPORT
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
comment|/* We ignore the dllimport attribute for inline member functions.       This differs from MSVC behavior which treats it like GNUC       'extern inline' extension.  Also ignore for template       instantiations with linkonce semantics and artificial methods.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Since we can't treat a pointer to a dllimport'd symbol as a        constant address, we turn off the attribute on C++ virtual        methods to allow creation of vtables using thunks.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Even though we ignore the attribute from the start, warn if we later see 	   an out-of class definition, as we do for other member functions in 	   tree.c:merge_dllimport_decl_attributes.  If this is the key method, the 	   definition may affect the import-export status of vtables, depending            on how we handle MULTIPLE_SYMBOL_SPACES in cp/decl2.c.   */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%q+D redeclared without dllimport attribute: "
literal|"previous dllimport ignored"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PE_DLL_DEBUG
if|if
condition|(
name|decl
operator|==
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"key method %q+D of dllimport'd class defined"
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|false
return|;
block|}
comment|/* Don't mark defined functions as dllimport.  This code will only be          reached if we see a non-inline function defined out-of-class.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/*  Don't allow definitions of static data members in dllimport class,         If vtable data is marked as DECL_EXTERNAL, import it; otherwise just         ignore the class attribute.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"definition of static data member %q+D of "
literal|"dllimport'd class"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|i386_pe_type_dllexport_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* Avoid exporting compiler-generated default dtors and copy ctors.       The only artificial methods that need to be exported are virtual       and non-virtual thunks.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_THUNK_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|maybe_add_dllimport
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|i386_pe_type_dllimport_p
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386_pe_adjust_class_at_definition
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|member
decl_stmt|;
name|gcc_assert
argument_list|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only look at dllimport.  The only thing that dllexport does is     add stuff to a '.drectiv' section at end-of-file, so no need to do     anything for dllexport'd classes until we generate RTL. */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* We don't actually add the attribute to the decl, just set the flag      that signals that the address of this symbol is not a compile-time      constant.   Any subsequent out-of-class declaration of members wil      cause the DECL_DLLIMPORT_P flag to be unset.      (See  tree.c: merge_dllimport_decl_attributes).      That is just right since out-of class declarations can only be a      definition.  We recheck the class members  at RTL generation to      emit warnings if this has happened.  Definition of static data member      of dllimport'd class always causes an error (as per MS compiler).      */
comment|/* Check static VAR_DECL's.  */
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|maybe_add_dllimport
argument_list|(
name|member
argument_list|)
expr_stmt|;
comment|/* Check FUNCTION_DECL's.  */
for|for
control|(
name|member
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|maybe_add_dllimport
argument_list|(
name|member
argument_list|)
expr_stmt|;
comment|/* Check vtables  */
for|for
control|(
name|member
operator|=
name|CLASSTYPE_VTABLES
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|maybe_add_dllimport
argument_list|(
name|member
argument_list|)
expr_stmt|;
comment|/* We leave typeinfo tables alone.  We can't mark TI objects as      dllimport, since the address of a secondary VTT may be needed      for static initialization of a primary VTT.  VTT's  of      dllimport'd classes should always be link-once COMDAT.  */
block|}
end_function

end_unit

