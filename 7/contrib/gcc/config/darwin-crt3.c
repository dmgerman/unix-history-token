begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* __cxa_atexit backwards-compatibility support for Darwin.    Copyright (C) 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Don't do anything if we are compiling for a kext multilib. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__PIC__
end_ifdef

begin_comment
comment|/* It is incorrect to include config.h here, because this file is being    compiled for the target, and hence definitions concerning only the host    do not apply.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* This file works around two different problems.     The first problem is that there is no __cxa_atexit on Mac OS versions    before 10.4.  It fixes this by providing a complete atexit and    __cxa_atexit emulation called from the regular atexit.     The second problem is that on all shipping versions of Mac OS,    __cxa_finalize and exit() don't work right: they don't run routines    that were registered while other atexit routines are running.  This    is worked around by wrapping each atexit/__cxa_atexit routine with    our own routine which ensures that any __cxa_atexit calls while it    is running are honoured.     There are still problems which this does not solve.  Before 10.4,    shared objects linked with previous compilers won't have their    atexit calls properly interleaved with code compiled with newer    compilers.  Also, atexit routines registered from shared objects    linked with previous compilers won't get the bug fix.  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|cxa_atexit_p
function_decl|)
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|void
modifier|*
name|dso
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|cxa_finalize_p
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|dso
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|atexit_p
function_decl|)
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* These are from "keymgr.h".  */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|_keymgr_get_and_lock_processwide_ptr
parameter_list|(
name|unsigned
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_keymgr_get_and_lock_processwide_ptr_2
parameter_list|(
name|unsigned
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_keymgr_set_and_unlock_processwide_ptr
parameter_list|(
name|unsigned
name|key
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|__keymgr_global
index|[]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_Sinfo_Node
block|{
name|unsigned
name|int
name|size
decl_stmt|;
comment|/*size of this node*/
name|unsigned
name|short
name|major_version
decl_stmt|;
comment|/*API major version.*/
name|unsigned
name|short
name|minor_version
decl_stmt|;
comment|/*API minor version.*/
block|}
name|_Tinfo_Node
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__ppc__
end_ifdef

begin_define
define|#
directive|define
name|CHECK_KEYMGR_ERROR
parameter_list|(
name|e
parameter_list|)
define|\
value|(((_Tinfo_Node *)__keymgr_global[2])->major_version>= 4 ? (e) : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_KEYMGR_ERROR
parameter_list|(
name|e
parameter_list|)
value|(e)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Our globals are stored under this keymgr index.  */
end_comment

begin_define
define|#
directive|define
name|KEYMGR_ATEXIT_LIST
value|14
end_define

begin_comment
comment|/* The different kinds of callback routines.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|atexit_callback
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|cxa_atexit_callback
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* This structure holds a routine to call.  There may be extra fields    at the end of the structure that this code doesn't know about.  */
end_comment

begin_struct
struct|struct
name|one_atexit_routine
block|{
union|union
block|{
name|atexit_callback
name|ac
decl_stmt|;
name|cxa_atexit_callback
name|cac
decl_stmt|;
block|}
name|callback
union|;
comment|/* has_arg is 0/2/4 if 'ac' is live, 1/3/5 if 'cac' is live.        Higher numbers indicate a later version of the structure that this      code doesn't understand and will ignore.  */
name|int
name|has_arg
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|atexit_routine_list
block|{
name|struct
name|atexit_routine_list
modifier|*
name|next
decl_stmt|;
name|struct
name|one_atexit_routine
name|r
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The various possibilities for status of atexit().  */
end_comment

begin_enum
enum|enum
name|atexit_status
block|{
name|atexit_status_unknown
init|=
literal|0
block|,
name|atexit_status_missing
init|=
literal|1
block|,
name|atexit_status_broken
init|=
literal|2
block|,
name|atexit_status_working
init|=
literal|16
block|}
enum|;
end_enum

begin_struct
struct|struct
name|keymgr_atexit_list
block|{
comment|/* Version of this list.  This code knows only about version 0.      If the version is higher than 0, this code may add new atexit routines      but should not attempt to run the list.  */
name|short
name|version
decl_stmt|;
comment|/* 1 if an atexit routine is currently being run by this code, 0      otherwise.  */
name|char
name|running_routines
decl_stmt|;
comment|/* Holds a value from 'enum atexit_status'.  */
name|unsigned
name|char
name|atexit_status
decl_stmt|;
comment|/* The list of atexit and cxa_atexit routines registered.  If    atexit_status_missing it contains all routines registered while    linked with this code.  If atexit_status_broken it contains all    routines registered during cxa_finalize while linked with this    code.  */
name|struct
name|atexit_routine_list
modifier|*
name|l
decl_stmt|;
comment|/*&__cxa_atexit; set if atexit_status>= atexit_status_broken.  */
name|cxa_atexit_p
name|cxa_atexit_f
decl_stmt|;
comment|/*&__cxa_finalize; set if atexit_status>= atexit_status_broken.  */
name|cxa_finalize_p
name|cxa_finalize_f
decl_stmt|;
comment|/*&atexit; set if atexit_status>= atexit_status_working      or atexit_status == atexit_status_missing.  */
name|atexit_p
name|atexit_f
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return 0 if __cxa_atexit has the bug it has in Mac OS 10.4: it    fails to call routines registered while an atexit routine is    running.  Return 1 if it works properly, and -1 if an error occurred.  */
end_comment

begin_struct
struct|struct
name|atexit_data
block|{
name|int
name|result
decl_stmt|;
name|cxa_atexit_p
name|cxa_atexit
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|cxa_atexit_check_2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|atexit_data
operator|*
operator|)
name|arg
operator|)
operator|->
name|result
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxa_atexit_check_1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|atexit_data
modifier|*
name|aed
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|aed
operator|->
name|cxa_atexit
argument_list|(
name|cxa_atexit_check_2
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|aed
operator|->
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_cxa_atexit
parameter_list|(
name|cxa_atexit_p
name|cxa_atexit
parameter_list|,
name|cxa_finalize_p
name|cxa_finalize
parameter_list|)
block|{
name|struct
name|atexit_data
name|aed
init|=
block|{
literal|0
block|,
name|cxa_atexit
block|}
decl_stmt|;
comment|/* We re-use&aed as the 'dso' parameter, since it's a unique address.  */
if|if
condition|(
name|cxa_atexit
argument_list|(
name|cxa_atexit_check_1
argument_list|,
operator|&
name|aed
argument_list|,
operator|&
name|aed
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|cxa_finalize
argument_list|(
operator|&
name|aed
argument_list|)
expr_stmt|;
if|if
condition|(
name|aed
operator|.
name|result
operator|==
literal|0
condition|)
block|{
comment|/* Call __cxa_finalize again to make sure that cxa_atexit_check_2 	 is removed from the list before AED goes out of scope.  */
name|cxa_finalize
argument_list|(
operator|&
name|aed
argument_list|)
expr_stmt|;
name|aed
operator|.
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|aed
operator|.
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__ppc__
end_ifdef

begin_comment
comment|/* This comes from Csu.  It works only before 10.4.  The prototype has    been altered a bit to avoid casting.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|_dyld_func_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|dyld_func_name
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|our_atexit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We're running on 10.3.9.  Find the address of the system atexit()    function.  So easy to say, so hard to do.  */
end_comment

begin_function
specifier|static
name|atexit_p
name|find_atexit_10_3
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
argument_list|(
operator|*
name|dyld_image_count_fn
argument_list|)
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|dyld_get_image_name_fn
function_decl|)
parameter_list|(
name|unsigned
name|int
name|image_index
parameter_list|)
function_decl|;
specifier|const
name|void
modifier|*
function_decl|(
modifier|*
name|dyld_get_image_header_fn
function_decl|)
parameter_list|(
name|unsigned
name|int
name|image_index
parameter_list|)
function_decl|;
specifier|const
name|void
modifier|*
function_decl|(
modifier|*
name|NSLookupSymbolInImage_fn
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|image
parameter_list|,
specifier|const
name|char
modifier|*
name|symbolName
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
function_decl|;
name|void
modifier|*
function_decl|(
modifier|*
name|NSAddressOfSymbol_fn
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|symbol
parameter_list|)
function_decl|;
name|unsigned
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* Find some dyld functions.  */
name|_dyld_func_lookup
argument_list|(
literal|"__dyld_image_count"
argument_list|,
operator|&
name|dyld_image_count_fn
argument_list|)
expr_stmt|;
name|_dyld_func_lookup
argument_list|(
literal|"__dyld_get_image_name"
argument_list|,
operator|&
name|dyld_get_image_name_fn
argument_list|)
expr_stmt|;
name|_dyld_func_lookup
argument_list|(
literal|"__dyld_get_image_header"
argument_list|,
operator|&
name|dyld_get_image_header_fn
argument_list|)
expr_stmt|;
name|_dyld_func_lookup
argument_list|(
literal|"__dyld_NSLookupSymbolInImage"
argument_list|,
operator|&
name|NSLookupSymbolInImage_fn
argument_list|)
expr_stmt|;
name|_dyld_func_lookup
argument_list|(
literal|"__dyld_NSAddressOfSymbol"
argument_list|,
operator|&
name|NSAddressOfSymbol_fn
argument_list|)
expr_stmt|;
comment|/* If any of these don't exist, that's an error.  */
if|if
condition|(
operator|!
name|dyld_image_count_fn
operator|||
operator|!
name|dyld_get_image_name_fn
operator|||
operator|!
name|dyld_get_image_header_fn
operator|||
operator|!
name|NSLookupSymbolInImage_fn
operator|||
operator|!
name|NSAddressOfSymbol_fn
condition|)
return|return
name|NULL
return|;
name|count
operator|=
name|dyld_image_count_fn
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|dyld_get_image_name_fn
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|image
decl_stmt|;
specifier|const
name|void
modifier|*
name|symbol
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
literal|"/usr/lib/libSystem.B.dylib"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|image
operator|=
name|dyld_get_image_header_fn
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
condition|)
return|return
name|NULL
return|;
comment|/* '4' is NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR.  */
name|symbol
operator|=
name|NSLookupSymbolInImage_fn
argument_list|(
name|image
argument_list|,
literal|"_atexit"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbol
condition|)
return|return
name|NULL
return|;
return|return
name|NSAddressOfSymbol_fn
argument_list|(
name|symbol
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Create (if necessary), find, lock, fill in, and return our globals.      Return NULL on error, in which case the globals will not be locked.      The caller should call keymgr_set_and_unlock.  */
end_comment

begin_function
specifier|static
name|struct
name|keymgr_atexit_list
modifier|*
name|get_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|keymgr_atexit_list
modifier|*
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|__ppc__
comment|/* 10.3.9 doesn't have _keymgr_get_and_lock_processwide_ptr_2 so the      PPC side can't use it.  On 10.4 this just means the error gets      reported a little later when      _keymgr_set_and_unlock_processwide_ptr finds that the key was      never locked.  */
name|r
operator|=
name|_keymgr_get_and_lock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|)
expr_stmt|;
else|#
directive|else
name|void
modifier|*
name|rr
decl_stmt|;
if|if
condition|(
name|_keymgr_get_and_lock_processwide_ptr_2
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
operator|&
name|rr
argument_list|)
condition|)
return|return
name|NULL
return|;
name|r
operator|=
name|rr
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|keymgr_atexit_list
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|r
operator|->
name|atexit_status
operator|==
name|atexit_status_unknown
condition|)
block|{
name|void
modifier|*
name|handle
decl_stmt|;
name|handle
operator|=
name|dlopen
argument_list|(
literal|"/usr/lib/libSystem.B.dylib"
argument_list|,
name|RTLD_NOLOAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
block|{
ifdef|#
directive|ifdef
name|__ppc__
name|r
operator|->
name|atexit_status
operator|=
name|atexit_status_missing
expr_stmt|;
name|r
operator|->
name|atexit_f
operator|=
name|find_atexit_10_3
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|atexit_f
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|r
operator|->
name|atexit_f
argument_list|(
name|our_atexit
argument_list|)
condition|)
goto|goto
name|error
goto|;
else|#
directive|else
goto|goto
name|error
goto|;
endif|#
directive|endif
block|}
else|else
block|{
name|int
name|chk_result
decl_stmt|;
name|r
operator|->
name|cxa_atexit_f
operator|=
operator|(
name|cxa_atexit_p
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"__cxa_atexit"
argument_list|)
expr_stmt|;
name|r
operator|->
name|cxa_finalize_f
operator|=
operator|(
name|cxa_finalize_p
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"__cxa_finalize"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|cxa_atexit_f
operator|||
operator|!
name|r
operator|->
name|cxa_finalize_f
condition|)
goto|goto
name|error
goto|;
name|chk_result
operator|=
name|check_cxa_atexit
argument_list|(
name|r
operator|->
name|cxa_atexit_f
argument_list|,
name|r
operator|->
name|cxa_finalize_f
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_result
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
elseif|else
if|if
condition|(
name|chk_result
operator|==
literal|0
condition|)
name|r
operator|->
name|atexit_status
operator|=
name|atexit_status_broken
expr_stmt|;
else|else
block|{
name|r
operator|->
name|atexit_f
operator|=
operator|(
name|atexit_p
operator|)
name|dlsym
argument_list|(
name|handle
argument_list|,
literal|"atexit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|atexit_f
condition|)
goto|goto
name|error
goto|;
name|r
operator|->
name|atexit_status
operator|=
name|atexit_status_working
expr_stmt|;
block|}
block|}
block|}
return|return
name|r
return|;
name|error
label|:
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add TO_ADD to ATEXIT_LIST.  ATEXIT_LIST may be NULL but is    always the result of calling _keymgr_get_and_lock_processwide_ptr and    so KEYMGR_ATEXIT_LIST is known to be locked; this routine is responsible    for unlocking it.  */
end_comment

begin_function
specifier|static
name|int
name|add_routine
parameter_list|(
name|struct
name|keymgr_atexit_list
modifier|*
name|g
parameter_list|,
specifier|const
name|struct
name|one_atexit_routine
modifier|*
name|to_add
parameter_list|)
block|{
name|struct
name|atexit_routine_list
modifier|*
name|s
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|atexit_routine_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|s
operator|->
name|r
operator|=
operator|*
name|to_add
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|g
operator|->
name|l
expr_stmt|;
name|g
operator|->
name|l
operator|=
name|s
expr_stmt|;
name|result
operator|=
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
return|return
name|CHECK_KEYMGR_ERROR
argument_list|(
name|result
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This runs the routines in G->L up to STOP.  */
end_comment

begin_function
specifier|static
name|struct
name|keymgr_atexit_list
modifier|*
name|run_routines
parameter_list|(
name|struct
name|keymgr_atexit_list
modifier|*
name|g
parameter_list|,
name|struct
name|atexit_routine_list
modifier|*
name|stop
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|atexit_routine_list
modifier|*
name|cur
init|=
name|g
operator|->
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|cur
operator|||
name|cur
operator|==
name|stop
condition|)
break|break;
name|g
operator|->
name|l
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cur
operator|->
name|r
operator|.
name|has_arg
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
name|cur
operator|->
name|r
operator|.
name|callback
operator|.
name|ac
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
case|case
literal|5
case|:
name|cur
operator|->
name|r
operator|.
name|callback
operator|.
name|cac
argument_list|(
name|cur
operator|->
name|r
operator|.
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Don't understand, so don't call it.  */
break|break;
block|}
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|g
operator|=
name|_keymgr_get_and_lock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
break|break;
block|}
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Call the routine described by ROUTINE_PARAM and then call any    routines added to KEYMGR_ATEXIT_LIST while that routine was    running, all with in_cxa_finalize set.  */
end_comment

begin_function
specifier|static
name|void
name|cxa_atexit_wrapper
parameter_list|(
name|void
modifier|*
name|routine_param
parameter_list|)
block|{
name|struct
name|one_atexit_routine
modifier|*
name|routine
init|=
name|routine_param
decl_stmt|;
name|struct
name|keymgr_atexit_list
modifier|*
name|g
decl_stmt|;
name|struct
name|atexit_routine_list
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|char
name|prev_running
init|=
literal|0
decl_stmt|;
name|g
operator|=
name|_keymgr_get_and_lock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
condition|)
block|{
name|prev_running
operator|=
name|g
operator|->
name|running_routines
expr_stmt|;
name|g
operator|->
name|running_routines
operator|=
literal|1
expr_stmt|;
name|base
operator|=
name|g
operator|->
name|l
expr_stmt|;
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|routine
operator|->
name|has_arg
condition|)
name|routine
operator|->
name|callback
operator|.
name|cac
argument_list|(
name|routine
operator|->
name|arg
argument_list|)
expr_stmt|;
else|else
name|routine
operator|->
name|callback
operator|.
name|ac
argument_list|()
expr_stmt|;
if|if
condition|(
name|g
condition|)
name|g
operator|=
name|_keymgr_get_and_lock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
condition|)
name|g
operator|=
name|run_routines
argument_list|(
name|g
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
condition|)
block|{
name|g
operator|->
name|running_routines
operator|=
name|prev_running
expr_stmt|;
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__ppc__
end_ifdef

begin_comment
comment|/* This code is used while running on 10.3.9, when __cxa_atexit doesn't    exist in the system library.  10.3.9 only supported regular PowerPC,    so this code isn't necessary on x86 or ppc64.  */
end_comment

begin_comment
comment|/* This routine is called from the system atexit(); it runs everything    registered on the KEYMGR_ATEXIT_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|our_atexit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|keymgr_atexit_list
modifier|*
name|g
decl_stmt|;
name|char
name|prev_running
decl_stmt|;
name|g
operator|=
name|_keymgr_get_and_lock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
operator|||
name|g
operator|->
name|version
operator|!=
literal|0
operator|||
name|g
operator|->
name|atexit_status
operator|!=
name|atexit_status_missing
condition|)
return|return;
name|prev_running
operator|=
name|g
operator|->
name|running_routines
expr_stmt|;
name|g
operator|->
name|running_routines
operator|=
literal|1
expr_stmt|;
name|g
operator|=
name|run_routines
argument_list|(
name|g
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
return|return;
name|g
operator|->
name|running_routines
operator|=
name|prev_running
expr_stmt|;
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is our wrapper around atexit and __cxa_atexit.  It will return    nonzero if an error occurs, and otherwise:    - if in_cxa_finalize is set, or running on 10.3.9, add R to      KEYMGR_ATEXIT_LIST; or    - call the system __cxa_atexit to add cxa_atexit_wrapper with an argument      that indicates how cxa_atexit_wrapper should call R.  */
end_comment

begin_function
specifier|static
name|int
name|atexit_common
parameter_list|(
specifier|const
name|struct
name|one_atexit_routine
modifier|*
name|r
parameter_list|,
specifier|const
name|void
modifier|*
name|dso
parameter_list|)
block|{
name|struct
name|keymgr_atexit_list
modifier|*
name|g
init|=
name|get_globals
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|g
operator|->
name|running_routines
operator|||
name|g
operator|->
name|atexit_status
operator|==
name|atexit_status_missing
condition|)
return|return
name|add_routine
argument_list|(
name|g
argument_list|,
name|r
argument_list|)
return|;
if|if
condition|(
name|g
operator|->
name|atexit_status
operator|>=
name|atexit_status_working
condition|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|has_arg
condition|)
block|{
name|cxa_atexit_p
name|cxa_atexit
init|=
name|g
operator|->
name|cxa_atexit_f
decl_stmt|;
name|result
operator|=
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_KEYMGR_ERROR
argument_list|(
name|result
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|cxa_atexit
argument_list|(
name|r
operator|->
name|callback
operator|.
name|cac
argument_list|,
name|r
operator|->
name|arg
argument_list|,
name|dso
argument_list|)
return|;
block|}
else|else
block|{
name|atexit_p
name|atexit_f
init|=
name|g
operator|->
name|atexit_f
decl_stmt|;
name|result
operator|=
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_KEYMGR_ERROR
argument_list|(
name|result
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|atexit_f
argument_list|(
name|r
operator|->
name|callback
operator|.
name|ac
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|cxa_atexit_p
name|cxa_atexit
init|=
name|g
operator|->
name|cxa_atexit_f
decl_stmt|;
name|struct
name|one_atexit_routine
modifier|*
name|alloced
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|_keymgr_set_and_unlock_processwide_ptr
argument_list|(
name|KEYMGR_ATEXIT_LIST
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_KEYMGR_ERROR
argument_list|(
name|result
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|alloced
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|one_atexit_routine
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alloced
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|alloced
operator|=
operator|*
name|r
expr_stmt|;
return|return
name|cxa_atexit
argument_list|(
name|cxa_atexit_wrapper
argument_list|,
name|alloced
argument_list|,
name|dso
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* These are the actual replacement routines; they just funnel into    atexit_common.  */
end_comment

begin_function_decl
name|int
name|__cxa_atexit
parameter_list|(
name|cxa_atexit_callback
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|void
modifier|*
name|dso
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function
name|int
name|__cxa_atexit
parameter_list|(
name|cxa_atexit_callback
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|void
modifier|*
name|dso
parameter_list|)
block|{
name|struct
name|one_atexit_routine
name|r
decl_stmt|;
name|r
operator|.
name|callback
operator|.
name|cac
operator|=
name|func
expr_stmt|;
name|r
operator|.
name|has_arg
operator|=
literal|1
expr_stmt|;
name|r
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
return|return
name|atexit_common
argument_list|(
operator|&
name|r
argument_list|,
name|dso
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|int
name|atexit
parameter_list|(
name|atexit_callback
name|func
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Use __dso_handle to allow even bundles that call atexit() to be unloaded    on 10.4.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|__dso_handle
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|atexit
parameter_list|(
name|atexit_callback
name|func
parameter_list|)
block|{
name|struct
name|one_atexit_routine
name|r
decl_stmt|;
name|r
operator|.
name|callback
operator|.
name|ac
operator|=
name|func
expr_stmt|;
name|r
operator|.
name|has_arg
operator|=
literal|0
expr_stmt|;
return|return
name|atexit_common
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|__dso_handle
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __PIC__ */
end_comment

end_unit

