begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Darwin support needed only by C/C++ frontends.    Copyright (C) 2001, 2003, 2004, 2005  Free Software Foundation, Inc.    Contributed by Apple Computer Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-incpath.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cppdefault.h"
end_include

begin_include
include|#
directive|include
file|"prefix.h"
end_include

begin_comment
comment|/* Pragmas.  */
end_comment

begin_define
define|#
directive|define
name|BAD
parameter_list|(
name|gmsgid
parameter_list|)
value|do { warning (OPT_Wpragmas, gmsgid); return; } while (0)
end_define

begin_define
define|#
directive|define
name|BAD2
parameter_list|(
name|msgid
parameter_list|,
name|arg
parameter_list|)
value|do { warning (OPT_Wpragmas, msgid, arg); return; } while (0)
end_define

begin_decl_stmt
specifier|static
name|bool
name|using_frameworks
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maintain a small stack of alignments.  This is similar to pragma    pack's stack, but simpler.  */
end_comment

begin_function_decl
specifier|static
name|void
name|push_field_alignment
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_field_alignment
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|find_subframework_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_system_framework_path
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|find_subframework_header
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|cpp_dir
modifier|*
modifier|*
name|dirp
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|align_stack
block|{
name|int
name|alignment
decl_stmt|;
name|struct
name|align_stack
modifier|*
name|prev
decl_stmt|;
block|}
name|align_stack
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|align_stack
modifier|*
name|field_align_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_field_alignment
parameter_list|(
name|int
name|bit_alignment
parameter_list|)
block|{
name|align_stack
modifier|*
name|entry
init|=
name|XNEW
argument_list|(
name|align_stack
argument_list|)
decl_stmt|;
name|entry
operator|->
name|alignment
operator|=
name|maximum_field_alignment
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|field_align_stack
expr_stmt|;
name|field_align_stack
operator|=
name|entry
expr_stmt|;
name|maximum_field_alignment
operator|=
name|bit_alignment
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_field_alignment
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|field_align_stack
condition|)
block|{
name|align_stack
modifier|*
name|entry
init|=
name|field_align_stack
decl_stmt|;
name|maximum_field_alignment
operator|=
name|entry
operator|->
name|alignment
expr_stmt|;
name|field_align_stack
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many #pragma options align=reset"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handlers for Darwin-specific pragmas.  */
end_comment

begin_function
name|void
name|darwin_pragma_ignore
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Do nothing.  */
block|}
end_function

begin_comment
comment|/* #pragma options align={mac68k|power|reset} */
end_comment

begin_function
name|void
name|darwin_pragma_options
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"align"
argument_list|)
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_EQ
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma options', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
name|OPT_Wpragmas
argument_list|,
literal|"junk at end of '#pragma options'"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"mac68k"
argument_list|)
condition|)
name|push_field_alignment
argument_list|(
literal|16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"power"
argument_list|)
condition|)
name|push_field_alignment
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"reset"
argument_list|)
condition|)
name|pop_field_alignment
argument_list|()
expr_stmt|;
else|else
name|BAD
argument_list|(
literal|"malformed '#pragma options align={mac68k|power|reset}', ignoring"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* #pragma unused ([var {, var}*]) */
end_comment

begin_function
name|void
name|darwin_pragma_unused
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|x
decl_stmt|;
name|int
name|tok
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_OPEN_PAREN
condition|)
name|BAD
argument_list|(
literal|"missing '(' after '#pragma unused', ignoring"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tok
operator|=
name|pragma_lex
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|CPP_NAME
operator|&&
name|decl
condition|)
block|{
name|tree
name|local
init|=
name|lookup_name
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|local
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|local
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|local
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|TREE_USED
argument_list|(
name|local
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tok
operator|=
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|CPP_COMMA
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|tok
operator|!=
name|CPP_CLOSE_PAREN
condition|)
name|BAD
argument_list|(
literal|"missing ')' after '#pragma unused', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|BAD
argument_list|(
literal|"junk at end of '#pragma unused'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the ms_struct pragma.  */
end_comment

begin_function
name|void
name|darwin_pragma_ms_struct
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_NAME
condition|)
name|BAD
argument_list|(
literal|"malformed '#pragma ms_struct', ignoring"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"on"
argument_list|)
condition|)
name|darwin_ms_struct
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"off"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"reset"
argument_list|)
condition|)
name|darwin_ms_struct
operator|=
name|false
expr_stmt|;
else|else
name|BAD
argument_list|(
literal|"malformed '#pragma ms_struct {on|off|reset}', ignoring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|t
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|BAD
argument_list|(
literal|"junk at end of '#pragma ms_struct'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|cpp_dir
modifier|*
name|dir
decl_stmt|;
block|}
modifier|*
name|frameworks_in_use
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|num_frameworks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_frameworks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember which frameworks have been seen, so that we can ensure    that all uses of that framework come from the same framework.  DIR    is the place where the named framework NAME, which is of length    LEN, was found.  We copy the directory name from NAME, as it will be    freed by others.  */
end_comment

begin_function
specifier|static
name|void
name|add_framework
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|cpp_dir
modifier|*
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|dir_name
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_frameworks
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|len
operator|==
name|frameworks_in_use
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|frameworks_in_use
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|max_frameworks
condition|)
block|{
name|max_frameworks
operator|=
name|i
operator|*
literal|2
expr_stmt|;
name|max_frameworks
operator|+=
name|i
operator|==
literal|0
expr_stmt|;
name|frameworks_in_use
operator|=
name|xrealloc
argument_list|(
name|frameworks_in_use
argument_list|,
name|max_frameworks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|frameworks_in_use
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dir_name
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dir_name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dir_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|frameworks_in_use
index|[
name|num_frameworks
index|]
operator|.
name|name
operator|=
name|dir_name
expr_stmt|;
name|frameworks_in_use
index|[
name|num_frameworks
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|frameworks_in_use
index|[
name|num_frameworks
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
operator|++
name|num_frameworks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recall if we have seen the named framework NAME, before, and where    we saw it.  NAME is LEN bytes long.  The return value is the place    where it was seen before.  */
end_comment

begin_function
specifier|static
name|struct
name|cpp_dir
modifier|*
name|find_framework
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_frameworks
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|len
operator|==
name|frameworks_in_use
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|frameworks_in_use
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|frameworks_in_use
index|[
name|i
index|]
operator|.
name|dir
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* There are two directories in a framework that contain header files,    Headers and PrivateHeaders.  We search Headers first as it is more    common to upgrade a header from PrivateHeaders to Headers and when    that is done, the old one might hang around and be out of data,    causing grief.  */
end_comment

begin_struct
struct|struct
name|framework_header
block|{
specifier|const
name|char
modifier|*
name|dirName
decl_stmt|;
name|int
name|dirNameLen
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|framework_header
name|framework_header_dirs
index|[]
init|=
block|{
block|{
literal|"Headers"
block|,
literal|7
block|}
block|,
block|{
literal|"PrivateHeaders"
block|,
literal|14
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns a pointer to a malloced string that contains the real pathname    to the file, given the base name and the name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|framework_construct_pathname
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|cpp_dir
modifier|*
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|fname_len
decl_stmt|,
name|frname_len
decl_stmt|;
name|cpp_dir
modifier|*
name|fast_dir
decl_stmt|;
name|char
modifier|*
name|frname
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Framework names must have a / in them.  */
name|buf
operator|=
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|fname_len
operator|=
name|buf
operator|-
name|fname
expr_stmt|;
else|else
return|return
literal|0
return|;
name|fast_dir
operator|=
name|find_framework
argument_list|(
name|fname
argument_list|,
name|fname_len
argument_list|)
expr_stmt|;
comment|/* Framework includes must all come from one framework.  */
if|if
condition|(
name|fast_dir
operator|&&
name|dir
operator|!=
name|fast_dir
condition|)
return|return
literal|0
return|;
name|frname
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|dir
operator|->
name|len
operator|+
literal|2
operator|+
name|strlen
argument_list|(
literal|".framework/"
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"PrivateHeaders"
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|frname
index|[
literal|0
index|]
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|len
argument_list|)
expr_stmt|;
name|frname_len
operator|=
name|dir
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|frname_len
operator|&&
name|frname
index|[
name|frname_len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|frname
index|[
name|frname_len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|frname
index|[
name|frname_len
index|]
argument_list|,
name|fname
argument_list|,
name|fname_len
argument_list|)
expr_stmt|;
name|frname_len
operator|+=
name|fname_len
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|frname
index|[
name|frname_len
index|]
argument_list|,
literal|".framework/"
argument_list|,
name|strlen
argument_list|(
literal|".framework/"
argument_list|)
argument_list|)
expr_stmt|;
name|frname_len
operator|+=
name|strlen
argument_list|(
literal|".framework/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast_dir
operator|==
literal|0
condition|)
block|{
name|frname
index|[
name|frname_len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|frname
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* As soon as we find the first instance of the framework, 	     we stop and never use any later instance of that 	     framework.  */
name|add_framework
argument_list|(
name|fname
argument_list|,
name|fname_len
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we can't find the parent directory, no point looking 	     further.  */
name|free
argument_list|(
name|frname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|frname
index|[
name|frname_len
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* Append framework_header_dirs and header file name */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirName
condition|;
name|i
operator|++
control|)
block|{
name|strncpy
argument_list|(
operator|&
name|frname
index|[
name|frname_len
index|]
argument_list|,
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirName
argument_list|,
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirNameLen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|frname
index|[
name|frname_len
operator|+
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirNameLen
index|]
argument_list|,
operator|&
name|fname
index|[
name|fname_len
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|frname
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
return|return
name|frname
return|;
block|}
name|free
argument_list|(
name|frname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search for FNAME in sub-frameworks.  pname is the context that we    wish to search in.  Return the path the file was found at,    otherwise return 0.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_subframework_file
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|)
block|{
name|char
modifier|*
name|sfrname
decl_stmt|;
specifier|const
name|char
modifier|*
name|dot_framework
init|=
literal|".framework/"
decl_stmt|;
name|char
modifier|*
name|bufptr
decl_stmt|;
name|int
name|sfrname_len
decl_stmt|,
name|i
decl_stmt|,
name|fname_len
decl_stmt|;
name|struct
name|cpp_dir
modifier|*
name|fast_dir
decl_stmt|;
specifier|static
name|struct
name|cpp_dir
name|subframe_dir
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|bufptr
operator|=
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Subframework files must have / in the name.  */
if|if
condition|(
name|bufptr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fname_len
operator|=
name|bufptr
operator|-
name|fname
expr_stmt|;
name|fast_dir
operator|=
name|find_framework
argument_list|(
name|fname
argument_list|,
name|fname_len
argument_list|)
expr_stmt|;
comment|/* Sub framework header filename includes parent framework name and      header name in the "CarbonCore/OSUtils.h" form. If it does not      include slash it is not a sub framework include.  */
name|bufptr
operator|=
name|strstr
argument_list|(
name|pname
argument_list|,
name|dot_framework
argument_list|)
expr_stmt|;
comment|/* If the parent header is not of any framework, then this header      cannot be part of any subframework.  */
if|if
condition|(
operator|!
name|bufptr
condition|)
return|return
literal|0
return|;
comment|/* Now translate. For example,                  +- bufptr      fname = CarbonCore/OSUtils.h                 |      pname = /System/Library/Frameworks/Foundation.framework/Headers/Foundation.h      into      sfrname = /System/Library/Frameworks/Foundation.framework/Frameworks/CarbonCore.framework/Headers/OSUtils.h */
name|sfrname
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|pname
argument_list|)
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
literal|"Frameworks/"
argument_list|)
operator|+
name|strlen
argument_list|(
literal|".framework/"
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"PrivateHeaders"
argument_list|)
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
name|strlen
argument_list|(
name|dot_framework
argument_list|)
expr_stmt|;
name|sfrname_len
operator|=
name|bufptr
operator|-
name|pname
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|sfrname
index|[
literal|0
index|]
argument_list|,
name|pname
argument_list|,
name|sfrname_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|sfrname
index|[
name|sfrname_len
index|]
argument_list|,
literal|"Frameworks/"
argument_list|,
name|strlen
argument_list|(
literal|"Frameworks/"
argument_list|)
argument_list|)
expr_stmt|;
name|sfrname_len
operator|+=
name|strlen
argument_list|(
literal|"Frameworks/"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|sfrname
index|[
name|sfrname_len
index|]
argument_list|,
name|fname
argument_list|,
name|fname_len
argument_list|)
expr_stmt|;
name|sfrname_len
operator|+=
name|fname_len
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|sfrname
index|[
name|sfrname_len
index|]
argument_list|,
literal|".framework/"
argument_list|,
name|strlen
argument_list|(
literal|".framework/"
argument_list|)
argument_list|)
expr_stmt|;
name|sfrname_len
operator|+=
name|strlen
argument_list|(
literal|".framework/"
argument_list|)
expr_stmt|;
comment|/* Append framework_header_dirs and header file name */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirName
condition|;
name|i
operator|++
control|)
block|{
name|strncpy
argument_list|(
operator|&
name|sfrname
index|[
name|sfrname_len
index|]
argument_list|,
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirName
argument_list|,
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirNameLen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|sfrname
index|[
name|sfrname_len
operator|+
name|framework_header_dirs
index|[
name|i
index|]
operator|.
name|dirNameLen
index|]
argument_list|,
operator|&
name|fname
index|[
name|fname_len
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|sfrname
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fast_dir
operator|!=
operator|&
name|subframe_dir
condition|)
block|{
if|if
condition|(
name|fast_dir
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"subframework include %s conflicts with framework include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|add_framework
argument_list|(
name|fname
argument_list|,
name|fname_len
argument_list|,
operator|&
name|subframe_dir
argument_list|)
expr_stmt|;
block|}
return|return
name|sfrname
return|;
block|}
block|}
name|free
argument_list|(
name|sfrname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add PATH to the system includes. PATH must be malloc-ed and    NUL-terminated.  System framework paths are C++ aware.  */
end_comment

begin_function
specifier|static
name|void
name|add_system_framework_path
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|cxx_aware
init|=
literal|1
decl_stmt|;
name|cpp_dir
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|XNEW
argument_list|(
name|cpp_dir
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|path
expr_stmt|;
name|p
operator|->
name|sysp
operator|=
literal|1
operator|+
operator|!
name|cxx_aware
expr_stmt|;
name|p
operator|->
name|construct
operator|=
name|framework_construct_pathname
expr_stmt|;
name|using_frameworks
operator|=
literal|1
expr_stmt|;
name|add_cpp_dir_path
argument_list|(
name|p
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add PATH to the bracket includes. PATH must be malloc-ed and    NUL-terminated.  */
end_comment

begin_function
name|void
name|add_framework_path
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|cpp_dir
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|XNEW
argument_list|(
name|cpp_dir
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|path
expr_stmt|;
name|p
operator|->
name|sysp
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|construct
operator|=
name|framework_construct_pathname
expr_stmt|;
name|using_frameworks
operator|=
literal|1
expr_stmt|;
name|add_cpp_dir_path
argument_list|(
name|p
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|framework_defaults
index|[]
init|=
block|{
literal|"/System/Library/Frameworks"
block|,
literal|"/Library/Frameworks"
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register the GNU objective-C runtime include path if STDINC.  */
end_comment

begin_function
name|void
name|darwin_register_objc_includes
parameter_list|(
specifier|const
name|char
modifier|*
name|sysroot
parameter_list|,
specifier|const
name|char
modifier|*
name|iprefix
parameter_list|,
name|int
name|stdinc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* We do not do anything if we do not want the standard includes. */
if|if
condition|(
operator|!
name|stdinc
condition|)
return|return;
name|fname
operator|=
name|GCC_INCLUDE_DIR
literal|"-gnu-runtime"
expr_stmt|;
comment|/* Register the GNU OBJC runtime include path if we are compiling  OBJC     with GNU-runtime.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
operator|!
name|flag_next_runtime
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* See if our directory starts with the standard prefix. 	 "Translate" them, i.e. replace /usr/local/lib/gcc... with 	 IPREFIX and search them first.  */
if|if
condition|(
name|iprefix
operator|&&
operator|(
name|len
operator|=
name|cpp_GCC_INCLUDE_DIR_len
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|sysroot
operator|&&
operator|!
name|strncmp
argument_list|(
name|fname
argument_list|,
name|cpp_GCC_INCLUDE_DIR
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|str
operator|=
name|concat
argument_list|(
name|iprefix
argument_list|,
name|fname
operator|+
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: wrap the headers for C++awareness.  */
name|add_path
argument_list|(
name|str
argument_list|,
name|SYSTEM
argument_list|,
comment|/*c++aware=*/
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Should this directory start with the sysroot?  */
if|if
condition|(
name|sysroot
condition|)
name|str
operator|=
name|concat
argument_list|(
name|sysroot
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
name|update_path
argument_list|(
name|fname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|add_path
argument_list|(
name|str
argument_list|,
name|SYSTEM
argument_list|,
comment|/*c++aware=*/
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Register all the system framework paths if STDINC is true and setup    the missing_header callback for subframework searching if any    frameworks had been registered.  */
end_comment

begin_function
name|void
name|darwin_register_frameworks
parameter_list|(
specifier|const
name|char
modifier|*
name|sysroot
parameter_list|,
specifier|const
name|char
modifier|*
name|iprefix
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|stdinc
parameter_list|)
block|{
if|if
condition|(
name|stdinc
condition|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* Setup default search path for frameworks.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|framework_defaults
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|sysroot
condition|)
name|str
operator|=
name|concat
argument_list|(
name|sysroot
argument_list|,
name|xstrdup
argument_list|(
name|framework_defaults
index|[
name|i
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
name|xstrdup
argument_list|(
name|framework_defaults
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* System Framework headers are cxx aware.  */
name|add_system_framework_path
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|using_frameworks
condition|)
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
operator|->
name|missing_header
operator|=
name|find_subframework_header
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search for HEADER in context dependent way.  The return value is    the malloced name of a header to try and open, if any, or NULL    otherwise.  This is called after normal header lookup processing    fails to find a header.  We search each file in the include stack,    using FUNC, starting from the most deeply nested include and    finishing with the main input file.  We stop searching when FUNC    returns nonzero.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_subframework_header
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|cpp_dir
modifier|*
modifier|*
name|dirp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
name|header
decl_stmt|;
name|struct
name|cpp_buffer
modifier|*
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|b
operator|=
name|cpp_get_buffer
argument_list|(
name|pfile
argument_list|)
init|;
name|b
operator|&&
name|cpp_get_file
argument_list|(
name|b
argument_list|)
operator|&&
name|cpp_get_path
argument_list|(
name|cpp_get_file
argument_list|(
name|b
argument_list|)
argument_list|)
condition|;
name|b
operator|=
name|cpp_get_prev
argument_list|(
name|b
argument_list|)
control|)
block|{
name|n
operator|=
name|find_subframework_file
argument_list|(
name|fname
argument_list|,
name|cpp_get_path
argument_list|(
name|cpp_get_file
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* Logically, the place where we found the subframework is 	     the place where we found the Framework that contains the 	     subframework.  This is useful for tracking wether or not 	     we are in a system header.  */
operator|*
name|dirp
operator|=
name|cpp_get_dir
argument_list|(
name|cpp_get_file
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the value of darwin_macosx_version_min suitable for the    __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ macro,    so '10.4.2' becomes 1042.    Print a warning if the version number is not known.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|version_as_macro
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|result
index|[]
init|=
literal|"1000"
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|darwin_macosx_version_min
argument_list|,
literal|"10."
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|darwin_macosx_version_min
index|[
literal|3
index|]
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|result
index|[
literal|2
index|]
operator|=
name|darwin_macosx_version_min
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|darwin_macosx_version_min
index|[
literal|4
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|darwin_macosx_version_min
index|[
literal|4
index|]
operator|!=
literal|'.'
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|darwin_macosx_version_min
index|[
literal|5
index|]
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|darwin_macosx_version_min
index|[
literal|6
index|]
operator|!=
literal|'\0'
condition|)
goto|goto
name|fail
goto|;
name|result
index|[
literal|3
index|]
operator|=
name|darwin_macosx_version_min
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
name|result
index|[
literal|3
index|]
operator|=
literal|'0'
expr_stmt|;
return|return
name|result
return|;
name|fail
label|:
name|error
argument_list|(
literal|"Unknown value %qs of -mmacosx-version-min"
argument_list|,
name|darwin_macosx_version_min
argument_list|)
expr_stmt|;
return|return
literal|"1000"
return|;
block|}
end_function

begin_comment
comment|/* Define additional CPP flags for Darwin.   */
end_comment

begin_define
define|#
directive|define
name|builtin_define
parameter_list|(
name|TXT
parameter_list|)
value|cpp_define (pfile, TXT)
end_define

begin_function
name|void
name|darwin_cpp_builtins
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|builtin_define
argument_list|(
literal|"__MACH__"
argument_list|)
expr_stmt|;
name|builtin_define
argument_list|(
literal|"__APPLE__"
argument_list|)
expr_stmt|;
comment|/* __APPLE_CC__ is defined as some old Apple include files expect it      to be defined and won't work if it isn't.  */
name|builtin_define_with_value
argument_list|(
literal|"__APPLE_CC__"
argument_list|,
literal|"1"
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|darwin_macosx_version_min
condition|)
name|builtin_define_with_value
argument_list|(
literal|"__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__"
argument_list|,
name|version_as_macro
argument_list|()
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

