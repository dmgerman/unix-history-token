begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Natural loop discovery code for GNU compiler.    Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_comment
comment|/* Ratio of frequencies of edges so that one of more latch edges is    considered to belong to inner loop with same header.  */
end_comment

begin_define
define|#
directive|define
name|HEAVY_EDGE_RATIO
value|8
end_define

begin_define
define|#
directive|define
name|HEADER_BLOCK
parameter_list|(
name|B
parameter_list|)
value|(* (int *) (B)->aux)
end_define

begin_define
define|#
directive|define
name|LATCH_EDGE
parameter_list|(
name|E
parameter_list|)
value|(*(int *) (E)->aux)
end_define

begin_function_decl
specifier|static
name|void
name|flow_loops_cfg_dump
parameter_list|(
specifier|const
name|struct
name|loops
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flow_loop_level_compute
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flow_loops_level_compute
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|establish_preds
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|canonicalize_loop_headers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|glb_enum_p
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Dump loop related CFG information.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loops_cfg_dump
parameter_list|(
specifier|const
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|loops
operator|->
name|num
operator|||
operator|!
name|file
condition|)
return|return;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|succ
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d succs { "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|succ
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|succ
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the DFS node order.  */
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
condition|)
block|{
name|fputs
argument_list|(
literal|";; DFS order: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_FIXED_BLOCKS
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Dump the reverse completion node order.  */
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|rc_order
condition|)
block|{
name|fputs
argument_list|(
literal|";; RC order: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_FIXED_BLOCKS
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|loops
operator|->
name|cfg
operator|.
name|rc_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the nodes of LOOP are a subset of OUTER.  */
end_comment

begin_function
name|bool
name|flow_loop_nested_p
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|outer
parameter_list|,
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
return|return
operator|(
name|loop
operator|->
name|depth
operator|>
name|outer
operator|->
name|depth
operator|&&
name|loop
operator|->
name|pred
index|[
name|outer
operator|->
name|depth
index|]
operator|==
name|outer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the loop such that LOOP is nested DEPTH (indexed from zero)    loops within LOOP.  */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|superloop_at_depth
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|unsigned
name|depth
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|depth
operator|<=
operator|(
name|unsigned
operator|)
name|loop
operator|->
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
operator|(
name|unsigned
operator|)
name|loop
operator|->
name|depth
condition|)
return|return
name|loop
return|;
return|return
name|loop
operator|->
name|pred
index|[
name|depth
index|]
return|;
block|}
end_function

begin_comment
comment|/* Dump the loop information specified by LOOP to the stream FILE    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */
end_comment

begin_function
name|void
name|flow_loop_dump
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|void
function_decl|(
modifier|*
name|loop_dump_aux
function_decl|)
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|||
operator|!
name|loop
operator|->
name|header
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;\n;; Loop %d\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  header %d, latch %d\n"
argument_list|,
name|loop
operator|->
name|header
operator|->
name|index
argument_list|,
name|loop
operator|->
name|latch
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  depth %d, level %d, outer %ld\n"
argument_list|,
name|loop
operator|->
name|depth
argument_list|,
name|loop
operator|->
name|level
argument_list|,
call|(
name|long
call|)
argument_list|(
name|loop
operator|->
name|outer
condition|?
name|loop
operator|->
name|outer
operator|->
name|num
else|:
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  nodes:"
argument_list|)
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|bbs
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_aux
condition|)
name|loop_dump_aux
argument_list|(
name|loop
argument_list|,
name|file
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the loop information specified by LOOPS to the stream FILE,    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */
end_comment

begin_function
name|void
name|flow_loops_dump
parameter_list|(
specifier|const
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|void
function_decl|(
modifier|*
name|loop_dump_aux
function_decl|)
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|num_loops
operator|=
name|loops
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|num_loops
operator|||
operator|!
name|file
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d loops found\n"
argument_list|,
name|num_loops
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_loops
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|flow_loop_dump
argument_list|(
name|loop
argument_list|,
name|file
argument_list|,
name|loop_dump_aux
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|flow_loops_cfg_dump
argument_list|(
name|loops
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free data allocated for LOOP.  */
end_comment

begin_function
name|void
name|flow_loop_free
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
if|if
condition|(
name|loop
operator|->
name|pred
condition|)
name|free
argument_list|(
name|loop
operator|->
name|pred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the memory allocated for LOOPS.  */
end_comment

begin_function
name|void
name|flow_loops_free
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
if|if
condition|(
name|loops
operator|->
name|parray
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|loops
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* Free the loop descriptors.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|flow_loop_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|loops
operator|->
name|parray
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
condition|)
name|free
argument_list|(
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|loops
operator|->
name|cfg
operator|.
name|rc_order
condition|)
name|free
argument_list|(
name|loops
operator|->
name|cfg
operator|.
name|rc_order
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the nodes contained within the LOOP with header HEADER.    Return the number of nodes within the loop.  */
end_comment

begin_function
name|int
name|flow_loop_nodes_find
parameter_list|(
name|basic_block
name|header
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|num_nodes
init|=
literal|1
decl_stmt|;
name|header
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|header
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|loop
operator|->
name|latch
expr_stmt|;
name|loop
operator|->
name|latch
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|latch
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|basic_block
name|node
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|node
operator|=
name|stack
index|[
operator|--
name|sp
index|]
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|node->preds
argument_list|)
block|{
name|basic_block
name|ancestor
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|ancestor
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|ancestor
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|ancestor
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|ancestor
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
name|num_nodes
operator|++
expr_stmt|;
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ancestor
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
return|return
name|num_nodes
return|;
block|}
end_function

begin_comment
comment|/* For each loop in the lOOPS tree that has just a single exit    record the exit edge.  */
end_comment

begin_function
name|void
name|mark_single_exit_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|loop
operator|->
name|single_exit
operator|=
name|NULL
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|==
name|loops
operator|->
name|tree_root
condition|)
continue|continue;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|bb
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|loop
operator|=
name|bb
operator|->
name|loop_father
init|;
name|loop
operator|!=
name|e
operator|->
name|dest
operator|->
name|loop_father
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
block|{
comment|/* If we have already seen an exit, mark this by the edge that 		 surely does not occur as any exit.  */
if|if
condition|(
name|loop
operator|->
name|single_exit
condition|)
name|loop
operator|->
name|single_exit
operator|=
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
else|else
name|loop
operator|->
name|single_exit
operator|=
name|e
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
name|loop
operator|->
name|single_exit
operator|==
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
condition|)
name|loop
operator|->
name|single_exit
operator|=
name|NULL
expr_stmt|;
block|}
name|loops
operator|->
name|state
operator||=
name|LOOPS_HAVE_MARKED_SINGLE_EXITS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|establish_preds
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|ploop
decl_stmt|,
modifier|*
name|father
init|=
name|loop
operator|->
name|outer
decl_stmt|;
name|loop
operator|->
name|depth
operator|=
name|father
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
comment|/* Remember the current loop depth if it is the largest seen so far.  */
name|cfun
operator|->
name|max_loop_depth
operator|=
name|MAX
argument_list|(
name|cfun
operator|->
name|max_loop_depth
argument_list|,
name|loop
operator|->
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|pred
condition|)
name|free
argument_list|(
name|loop
operator|->
name|pred
argument_list|)
expr_stmt|;
name|loop
operator|->
name|pred
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|loop
operator|*
argument_list|,
name|loop
operator|->
name|depth
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|loop
operator|->
name|pred
argument_list|,
name|father
operator|->
name|pred
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
operator|*
name|father
operator|->
name|depth
argument_list|)
expr_stmt|;
name|loop
operator|->
name|pred
index|[
name|father
operator|->
name|depth
index|]
operator|=
name|father
expr_stmt|;
for|for
control|(
name|ploop
operator|=
name|loop
operator|->
name|inner
init|;
name|ploop
condition|;
name|ploop
operator|=
name|ploop
operator|->
name|next
control|)
name|establish_preds
argument_list|(
name|ploop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add LOOP to the loop hierarchy tree where FATHER is father of the    added loop.  If LOOP has some children, take care of that their    pred field will be initialized correctly.  */
end_comment

begin_function
name|void
name|flow_loop_tree_node_add
parameter_list|(
name|struct
name|loop
modifier|*
name|father
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|loop
operator|->
name|next
operator|=
name|father
operator|->
name|inner
expr_stmt|;
name|father
operator|->
name|inner
operator|=
name|loop
expr_stmt|;
name|loop
operator|->
name|outer
operator|=
name|father
expr_stmt|;
name|establish_preds
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove LOOP from the loop hierarchy tree.  */
end_comment

begin_function
name|void
name|flow_loop_tree_node_remove
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|prev
decl_stmt|,
modifier|*
name|father
decl_stmt|;
name|father
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|loop
operator|->
name|outer
operator|=
name|NULL
expr_stmt|;
comment|/* Remove loop from the list of sons.  */
if|if
condition|(
name|father
operator|->
name|inner
operator|==
name|loop
condition|)
name|father
operator|->
name|inner
operator|=
name|loop
operator|->
name|next
expr_stmt|;
else|else
block|{
for|for
control|(
name|prev
operator|=
name|father
operator|->
name|inner
init|;
name|prev
operator|->
name|next
operator|!=
name|loop
condition|;
name|prev
operator|=
name|prev
operator|->
name|next
control|)
empty_stmt|;
name|prev
operator|->
name|next
operator|=
name|loop
operator|->
name|next
expr_stmt|;
block|}
name|loop
operator|->
name|depth
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|loop
operator|->
name|pred
argument_list|)
expr_stmt|;
name|loop
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function to compute loop nesting depth and enclosed loop level    for the natural loop specified by LOOP.  Returns the loop level.  */
end_comment

begin_function
specifier|static
name|int
name|flow_loop_level_compute
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|inner
decl_stmt|;
name|int
name|level
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
return|return
literal|0
return|;
comment|/* Traverse loop tree assigning depth and computing level as the      maximum level of all the inner loops of this loop.  The loop      level is equivalent to the height of the loop in the loop tree      and corresponds to the number of enclosed loop levels (including      itself).  */
for|for
control|(
name|inner
operator|=
name|loop
operator|->
name|inner
init|;
name|inner
condition|;
name|inner
operator|=
name|inner
operator|->
name|next
control|)
block|{
name|int
name|ilevel
init|=
name|flow_loop_level_compute
argument_list|(
name|inner
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|ilevel
operator|>
name|level
condition|)
name|level
operator|=
name|ilevel
expr_stmt|;
block|}
name|loop
operator|->
name|level
operator|=
name|level
expr_stmt|;
return|return
name|level
return|;
block|}
end_function

begin_comment
comment|/* Compute the loop nesting depth and enclosed loop level for the loop    hierarchy tree specified by LOOPS.  Return the maximum enclosed loop    level.  */
end_comment

begin_function
specifier|static
name|void
name|flow_loops_level_compute
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|flow_loop_level_compute
argument_list|(
name|loops
operator|->
name|tree_root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A callback to update latch and header info for basic block JUMP created    by redirecting an edge.  */
end_comment

begin_function
specifier|static
name|void
name|update_latch_info
parameter_list|(
name|basic_block
name|jump
parameter_list|)
block|{
name|alloc_aux_for_block
argument_list|(
name|jump
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|jump
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alloc_aux_for_edge
argument_list|(
name|single_pred_edge
argument_list|(
name|jump
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|single_pred_edge
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|jump
argument_list|,
name|single_pred
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A callback for make_forwarder block, to redirect all edges except for    MFB_KJ_EDGE to the entry part.  E is the edge for that we should decide    whether to redirect it.  */
end_comment

begin_decl_stmt
specifier|static
name|edge
name|mfb_kj_edge
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|mfb_keep_just
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
return|return
name|e
operator|!=
name|mfb_kj_edge
return|;
block|}
end_function

begin_comment
comment|/* A callback for make_forwarder block, to redirect the latch edges into an    entry part.  E is the edge for that we should decide whether to redirect    it.  */
end_comment

begin_function
specifier|static
name|bool
name|mfb_keep_nonlatch
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
return|return
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Takes care of merging natural loops with shared headers.  */
end_comment

begin_function
specifier|static
name|void
name|canonicalize_loop_headers
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|header
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split blocks so that each loop has only single latch.  */
name|FOR_EACH_BB
argument_list|(
argument|header
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|num_latches
init|=
literal|0
decl_stmt|;
name|int
name|have_abnormal_edge
init|=
literal|0
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|header->preds
argument_list|)
block|{
name|basic_block
name|latch
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|have_abnormal_edge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|latch
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|latch
argument_list|,
name|header
argument_list|)
condition|)
block|{
name|num_latches
operator|++
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_abnormal_edge
condition|)
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
operator|=
name|num_latches
expr_stmt|;
block|}
if|if
condition|(
name|HEADER_BLOCK
argument_list|(
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* We could not redirect edges freely here. On the other hand, 	 we can simply split the edge from entry block.  */
name|bb
operator|=
name|split_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_aux_for_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alloc_aux_for_block
argument_list|(
name|bb
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|bb
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|header
argument_list|)
block|{
name|int
name|max_freq
decl_stmt|,
name|is_heavy
decl_stmt|;
name|edge
name|heavy
decl_stmt|,
name|tmp_edge
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
operator|<=
literal|1
condition|)
continue|continue;
comment|/* Find a heavy edge.  */
name|is_heavy
operator|=
literal|1
expr_stmt|;
name|heavy
operator|=
name|NULL
expr_stmt|;
name|max_freq
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|header->preds
argument_list|)
if|if
condition|(
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|&&
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|>
name|max_freq
condition|)
name|max_freq
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|header->preds
argument_list|)
if|if
condition|(
name|LATCH_EDGE
argument_list|(
name|e
argument_list|)
operator|&&
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|>=
name|max_freq
operator|/
name|HEAVY_EDGE_RATIO
condition|)
block|{
if|if
condition|(
name|heavy
condition|)
block|{
name|is_heavy
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
name|heavy
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|is_heavy
condition|)
block|{
comment|/* Split out the heavy edge, and create inner loop for it.  */
name|mfb_kj_edge
operator|=
name|heavy
expr_stmt|;
name|tmp_edge
operator|=
name|make_forwarder_block
argument_list|(
name|header
argument_list|,
name|mfb_keep_just
argument_list|,
name|update_latch_info
argument_list|)
expr_stmt|;
name|alloc_aux_for_block
argument_list|(
name|tmp_edge
operator|->
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|tmp_edge
operator|->
name|dest
argument_list|)
operator|=
literal|1
expr_stmt|;
name|alloc_aux_for_edge
argument_list|(
name|tmp_edge
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|tmp_edge
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|HEADER_BLOCK
argument_list|(
name|header
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* Create a new latch block.  */
name|tmp_edge
operator|=
name|make_forwarder_block
argument_list|(
name|header
argument_list|,
name|mfb_keep_nonlatch
argument_list|,
name|update_latch_info
argument_list|)
expr_stmt|;
name|alloc_aux_for_block
argument_list|(
name|tmp_edge
operator|->
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|tmp_edge
operator|->
name|src
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HEADER_BLOCK
argument_list|(
name|tmp_edge
operator|->
name|dest
argument_list|)
operator|=
literal|1
expr_stmt|;
name|alloc_aux_for_edge
argument_list|(
name|tmp_edge
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|LATCH_EDGE
argument_list|(
name|tmp_edge
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
name|free_aux_for_edges
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Initialize all the parallel_p fields of the loops structure to true.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_loops_parallel_p
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
name|loop
operator|->
name|parallel_p
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find all the natural loops in the function and save in LOOPS structure and    recalculate loop_depth information in basic block structures.    Return the number of natural loops found.  */
end_comment

begin_function
name|int
name|flow_loops_find
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|int
name|b
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|sbitmap
name|headers
decl_stmt|;
name|int
modifier|*
name|dfs_order
decl_stmt|;
name|int
modifier|*
name|rc_order
decl_stmt|;
name|basic_block
name|header
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|memset
argument_list|(
name|loops
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|loops
argument_list|)
expr_stmt|;
comment|/* We are going to recount the maximum loop depth,      so throw away the last count.  */
name|cfun
operator|->
name|max_loop_depth
operator|=
literal|0
expr_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
name|NUM_FIXED_BLOCKS
condition|)
return|return
literal|0
return|;
name|dfs_order
operator|=
name|NULL
expr_stmt|;
name|rc_order
operator|=
name|NULL
expr_stmt|;
comment|/* Ensure that the dominators are computed.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Join loops with shared headers.  */
name|canonicalize_loop_headers
argument_list|()
expr_stmt|;
comment|/* Count the number of loop headers.  This should be the      same as the number of natural loops.  */
name|headers
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|num_loops
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|header
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|more_latches
init|=
literal|0
decl_stmt|;
name|header
operator|->
name|loop_depth
operator|=
literal|0
expr_stmt|;
comment|/* If we have an abnormal predecessor, do not consider the 	 loop (not worth the problems).  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|header->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
break|break;
if|if
condition|(
name|e
condition|)
continue|continue;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|header->preds
argument_list|)
block|{
name|basic_block
name|latch
init|=
name|e
operator|->
name|src
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Look for back edges where a predecessor is dominated 	     by this block.  A natural loop has a single entry 	     node (header) that dominates all the nodes in the 	     loop.  It also has single back edge to the header 	     from a latch node.  */
if|if
condition|(
name|latch
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|latch
argument_list|,
name|header
argument_list|)
condition|)
block|{
comment|/* Shared headers should be eliminated by now.  */
name|gcc_assert
argument_list|(
operator|!
name|more_latches
argument_list|)
expr_stmt|;
name|more_latches
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|headers
argument_list|,
name|header
operator|->
name|index
argument_list|)
expr_stmt|;
name|num_loops
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Allocate loop structures.  */
name|loops
operator|->
name|parray
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|loop
operator|*
argument_list|,
name|num_loops
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Dummy loop containing whole function.  */
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|=
name|XCNEW
argument_list|(
expr|struct
name|loop
argument_list|)
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|inner
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|outer
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|num_nodes
operator|=
name|n_basic_blocks
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|latch
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|loops
operator|->
name|parray
index|[
literal|0
index|]
operator|->
name|header
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|loop_father
operator|=
name|loops
operator|->
name|parray
index|[
literal|0
index|]
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|loop_father
operator|=
name|loops
operator|->
name|parray
index|[
literal|0
index|]
expr_stmt|;
name|loops
operator|->
name|tree_root
operator|=
name|loops
operator|->
name|parray
index|[
literal|0
index|]
expr_stmt|;
comment|/* Find and record information about all the natural loops      in the CFG.  */
name|loops
operator|->
name|num
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|bb
operator|->
name|loop_father
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
if|if
condition|(
name|num_loops
condition|)
block|{
comment|/* Compute depth first search order of the CFG so that outer 	 natural loops will be found before inner natural loops.  */
name|dfs_order
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|rc_order
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|pre_and_rev_post_order_compute
argument_list|(
name|dfs_order
argument_list|,
name|rc_order
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Save CFG derived information to avoid recomputing it.  */
name|loops
operator|->
name|cfg
operator|.
name|dfs_order
operator|=
name|dfs_order
expr_stmt|;
name|loops
operator|->
name|cfg
operator|.
name|rc_order
operator|=
name|rc_order
expr_stmt|;
name|num_loops
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
condition|;
name|b
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Search the nodes of the CFG in reverse completion order 	     so that we can find outer loops first.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|headers
argument_list|,
name|rc_order
index|[
name|b
index|]
argument_list|)
condition|)
continue|continue;
name|header
operator|=
name|BASIC_BLOCK
argument_list|(
name|rc_order
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|num_loops
index|]
operator|=
name|XCNEW
argument_list|(
expr|struct
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|header
operator|=
name|header
expr_stmt|;
name|loop
operator|->
name|num
operator|=
name|num_loops
expr_stmt|;
name|num_loops
operator|++
expr_stmt|;
comment|/* Look for the latch for this header block.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|header->preds
argument_list|)
block|{
name|basic_block
name|latch
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|latch
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|latch
argument_list|,
name|header
argument_list|)
condition|)
block|{
name|loop
operator|->
name|latch
operator|=
name|latch
expr_stmt|;
break|break;
block|}
block|}
name|flow_loop_tree_node_add
argument_list|(
name|header
operator|->
name|loop_father
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|num_nodes
operator|=
name|flow_loop_nodes_find
argument_list|(
name|loop
operator|->
name|header
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
comment|/* Assign the loop nesting depth and enclosed loop level for each 	 loop.  */
name|flow_loops_level_compute
argument_list|(
name|loops
argument_list|)
expr_stmt|;
name|loops
operator|->
name|num
operator|=
name|num_loops
expr_stmt|;
name|initialize_loops_parallel_p
argument_list|(
name|loops
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|loops
operator|->
name|state
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|loops
operator|->
name|num
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if basic block BB belongs to LOOP.  */
end_comment

begin_function
name|bool
name|flow_bb_inside_loop_p
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
specifier|const
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|source_loop
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
literal|0
return|;
name|source_loop
operator|=
name|bb
operator|->
name|loop_father
expr_stmt|;
return|return
name|loop
operator|==
name|source_loop
operator|||
name|flow_loop_nested_p
argument_list|(
name|loop
argument_list|,
name|source_loop
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Enumeration predicate for get_loop_body.  */
end_comment

begin_function
specifier|static
name|bool
name|glb_enum_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|glb_header
parameter_list|)
block|{
return|return
name|bb
operator|!=
operator|(
name|basic_block
operator|)
name|glb_header
return|;
block|}
end_function

begin_comment
comment|/* Gets basic blocks of a LOOP.  Header is the 0-th block, rest is in dfs    order against direction of edges from latch.  Specially, if    header != latch, latch is the 1-st block.  */
end_comment

begin_function
name|basic_block
modifier|*
name|get_loop_body
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|tovisit
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|tv
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|tovisit
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|tovisit
index|[
name|tv
operator|++
index|]
operator|=
name|loop
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* There may be blocks unreachable from EXIT_BLOCK.  */
name|gcc_assert
argument_list|(
name|loop
operator|->
name|num_nodes
operator|==
operator|(
name|unsigned
operator|)
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|tovisit
index|[
name|tv
operator|++
index|]
operator|=
name|bb
expr_stmt|;
name|tovisit
index|[
name|tv
operator|++
index|]
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop
operator|->
name|latch
operator|!=
name|loop
operator|->
name|header
condition|)
block|{
name|tv
operator|=
name|dfs_enumerate_from
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
literal|1
argument_list|,
name|glb_enum_p
argument_list|,
name|tovisit
operator|+
literal|1
argument_list|,
name|loop
operator|->
name|num_nodes
operator|-
literal|1
argument_list|,
name|loop
operator|->
name|header
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|tv
operator|==
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
return|return
name|tovisit
return|;
block|}
end_function

begin_comment
comment|/* Fills dominance descendants inside LOOP of the basic block BB into    array TOVISIT from index *TV.  */
end_comment

begin_function
specifier|static
name|void
name|fill_sons_in_loop
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|basic_block
modifier|*
name|tovisit
parameter_list|,
name|int
modifier|*
name|tv
parameter_list|)
block|{
name|basic_block
name|son
decl_stmt|,
name|postpone
init|=
name|NULL
decl_stmt|;
name|tovisit
index|[
operator|(
operator|*
name|tv
operator|)
operator|++
index|]
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|son
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|son
argument_list|)
condition|)
block|{
name|postpone
operator|=
name|son
expr_stmt|;
continue|continue;
block|}
name|fill_sons_in_loop
argument_list|(
name|loop
argument_list|,
name|son
argument_list|,
name|tovisit
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|postpone
condition|)
name|fill_sons_in_loop
argument_list|(
name|loop
argument_list|,
name|postpone
argument_list|,
name|tovisit
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gets body of a LOOP (that must be different from the outermost loop)    sorted by dominance relation.  Additionally, if a basic block s dominates    the latch, then only blocks dominated by s are be after it.  */
end_comment

begin_function
name|basic_block
modifier|*
name|get_loop_body_in_dom_order
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|tovisit
decl_stmt|;
name|int
name|tv
decl_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|tovisit
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|latch
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|tv
operator|=
literal|0
expr_stmt|;
name|fill_sons_in_loop
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|header
argument_list|,
name|tovisit
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|tv
operator|==
operator|(
name|int
operator|)
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
return|return
name|tovisit
return|;
block|}
end_function

begin_comment
comment|/* Get body of a LOOP in breadth first sort order.  */
end_comment

begin_function
name|basic_block
modifier|*
name|get_loop_body_in_bfs_order
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|blocks
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|bitmap
name|visited
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|vc
init|=
literal|1
decl_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|latch
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|visited
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb
operator|=
name|loop
operator|->
name|header
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* This basic block is now visited */
name|bitmap_set_bit
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|blocks
index|[
name|i
operator|++
index|]
operator|=
name|bb
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|blocks
index|[
name|i
operator|++
index|]
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
block|}
block|}
name|gcc_assert
argument_list|(
name|i
operator|>=
name|vc
argument_list|)
expr_stmt|;
name|bb
operator|=
name|blocks
index|[
name|vc
operator|++
index|]
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|blocks
return|;
block|}
end_function

begin_comment
comment|/* Gets exit edges of a LOOP, returning their number in N_EDGES.  */
end_comment

begin_function
name|edge
modifier|*
name|get_loop_exit_edges
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|unsigned
name|int
modifier|*
name|num_edges
parameter_list|)
block|{
name|edge
modifier|*
name|edges
decl_stmt|,
name|e
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|latch
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|body[i]->succs
argument_list|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
name|edges
operator|=
name|XNEWVEC
argument_list|(
name|edge
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|num_edges
operator|=
name|n
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|body[i]->succs
argument_list|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|edges
index|[
name|n
operator|++
index|]
operator|=
name|e
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|edges
return|;
block|}
end_function

begin_comment
comment|/* Counts the number of conditional branches inside LOOP.  */
end_comment

begin_function
name|unsigned
name|num_loop_branches
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|latch
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|body
index|[
name|i
index|]
operator|->
name|succs
argument_list|)
operator|>=
literal|2
condition|)
name|n
operator|++
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Adds basic block BB to LOOP.  */
end_comment

begin_function
name|void
name|add_bb_to_loop
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bb
operator|->
name|loop_father
operator|=
name|loop
expr_stmt|;
name|bb
operator|->
name|loop_depth
operator|=
name|loop
operator|->
name|depth
expr_stmt|;
name|loop
operator|->
name|num_nodes
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|depth
condition|;
name|i
operator|++
control|)
name|loop
operator|->
name|pred
index|[
name|i
index|]
operator|->
name|num_nodes
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove basic block BB from loops.  */
end_comment

begin_function
name|void
name|remove_bb_from_loops
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|bb
operator|->
name|loop_father
decl_stmt|;
name|loop
operator|->
name|num_nodes
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|depth
condition|;
name|i
operator|++
control|)
name|loop
operator|->
name|pred
index|[
name|i
index|]
operator|->
name|num_nodes
operator|--
expr_stmt|;
name|bb
operator|->
name|loop_father
operator|=
name|NULL
expr_stmt|;
name|bb
operator|->
name|loop_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds nearest common ancestor in loop tree for given loops.  */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|find_common_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop_s
parameter_list|,
name|struct
name|loop
modifier|*
name|loop_d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|loop_s
condition|)
return|return
name|loop_d
return|;
if|if
condition|(
operator|!
name|loop_d
condition|)
return|return
name|loop_s
return|;
if|if
condition|(
name|loop_s
operator|->
name|depth
operator|<
name|loop_d
operator|->
name|depth
condition|)
name|loop_d
operator|=
name|loop_d
operator|->
name|pred
index|[
name|loop_s
operator|->
name|depth
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|loop_s
operator|->
name|depth
operator|>
name|loop_d
operator|->
name|depth
condition|)
name|loop_s
operator|=
name|loop_s
operator|->
name|pred
index|[
name|loop_d
operator|->
name|depth
index|]
expr_stmt|;
while|while
condition|(
name|loop_s
operator|!=
name|loop_d
condition|)
block|{
name|loop_s
operator|=
name|loop_s
operator|->
name|outer
expr_stmt|;
name|loop_d
operator|=
name|loop_d
operator|->
name|outer
expr_stmt|;
block|}
return|return
name|loop_s
return|;
block|}
end_function

begin_comment
comment|/* Cancels the LOOP; it must be innermost one.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|loop
operator|->
name|inner
argument_list|)
expr_stmt|;
comment|/* Move blocks up one level (they should be removed as soon as possible).  */
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|bbs
index|[
name|i
index|]
operator|->
name|loop_father
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
comment|/* Remove the loop from structure.  */
name|flow_loop_tree_node_remove
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Remove loop from loops array.  */
name|loops
operator|->
name|parray
index|[
name|loop
operator|->
name|num
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free loop data.  */
name|flow_loop_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cancels LOOP and all its subloops.  */
end_comment

begin_function
name|void
name|cancel_loop_tree
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|cancel_loop_tree
argument_list|(
name|loops
argument_list|,
name|loop
operator|->
name|inner
argument_list|)
expr_stmt|;
name|cancel_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks that LOOPS are all right:      -- sizes of loops are all right      -- results of get_loop_body really belong to the loop      -- loop header have just single entry edge and single latch edge      -- loop latches have only single successor that is header of their loop      -- irreducible loops are correctly marked   */
end_comment

begin_function
name|void
name|verify_loop_structure
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
modifier|*
name|sizes
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sbitmap
name|irreds
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|,
name|bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Check sizes.  */
name|sizes
operator|=
name|XCNEWVEC
argument_list|(
name|unsigned
argument_list|,
name|loops
operator|->
name|num
argument_list|)
expr_stmt|;
name|sizes
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|loop
operator|=
name|bb
operator|->
name|loop_father
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
name|sizes
index|[
name|loop
operator|->
name|num
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|loops
operator|->
name|parray
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
operator|->
name|num_nodes
operator|!=
name|sizes
index|[
name|i
index|]
condition|)
block|{
name|error
argument_list|(
literal|"size of loop %d should be %d, not %d"
argument_list|,
name|i
argument_list|,
name|sizes
index|[
name|i
index|]
argument_list|,
name|loops
operator|->
name|parray
index|[
name|i
index|]
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check get_loop_body.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bbs
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"bb %d do not belong to loop %d"
argument_list|,
name|bbs
index|[
name|j
index|]
operator|->
name|index
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
comment|/* Check headers and latches.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
operator|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_PREHEADERS
operator|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|loop
operator|->
name|header
operator|->
name|preds
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"loop %d's header does not have exactly 2 entries"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_SIMPLE_LATCHES
condition|)
block|{
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"loop %d's latch does not have exactly 1 successor"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|single_succ
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
operator|!=
name|loop
operator|->
name|header
condition|)
block|{
name|error
argument_list|(
literal|"loop %d's latch does not have header as successor"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|->
name|latch
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|error
argument_list|(
literal|"loop %d's latch does not belong directly to it"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|loop_father
operator|!=
name|loop
condition|)
block|{
name|error
argument_list|(
literal|"loop %d's header does not belong directly to it"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
operator|)
operator|&&
operator|(
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"loop %d's latch is marked as part of irreducible region"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check irreducible loops.  */
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS
condition|)
block|{
comment|/* Record old info.  */
name|irreds
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
condition|)
name|SET_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|RESET_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_ALL_FLAGS
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Recount it.  */
name|mark_irreducible_loops
argument_list|(
name|loops
argument_list|)
expr_stmt|;
comment|/* Compare.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
operator|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"basic block %d should be marked irreducible"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
operator|)
operator|&&
name|TEST_BIT
argument_list|(
name|irreds
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"basic block %d should not be marked irreducible"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ALL_FLAGS
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"edge from %d to %d should be marked irreducible"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ALL_FLAGS
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"edge from %d to %d should not be marked irreducible"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|e
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EDGE_ALL_FLAGS
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|irreds
argument_list|)
expr_stmt|;
block|}
comment|/* Check the single_exit.  */
if|if
condition|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_MARKED_SINGLE_EXITS
condition|)
block|{
name|memset
argument_list|(
name|sizes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
name|loops
operator|->
name|num
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|loop_father
operator|==
name|loops
operator|->
name|tree_root
condition|)
continue|continue;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|bb
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|loop
operator|=
name|bb
operator|->
name|loop_father
init|;
name|loop
operator|!=
name|e
operator|->
name|dest
operator|->
name|loop_father
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
block|{
name|sizes
index|[
name|loop
operator|->
name|num
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|single_exit
operator|&&
name|loop
operator|->
name|single_exit
operator|!=
name|e
condition|)
block|{
name|error
argument_list|(
literal|"wrong single exit %d->%d recorded for loop %d"
argument_list|,
name|loop
operator|->
name|single_exit
operator|->
name|src
operator|->
name|index
argument_list|,
name|loop
operator|->
name|single_exit
operator|->
name|dest
operator|->
name|index
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"right exit is %d->%d"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
name|sizes
index|[
name|i
index|]
operator|==
literal|1
operator|&&
operator|!
name|loop
operator|->
name|single_exit
condition|)
block|{
name|error
argument_list|(
literal|"single exit not recorded for loop %d"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sizes
index|[
name|i
index|]
operator|!=
literal|1
operator|&&
name|loop
operator|->
name|single_exit
condition|)
block|{
name|error
argument_list|(
literal|"loop %d should not have single exit (%d -> %d)"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|loop
operator|->
name|single_exit
operator|->
name|src
operator|->
name|index
argument_list|,
name|loop
operator|->
name|single_exit
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|gcc_assert
argument_list|(
operator|!
name|err
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sizes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns latch edge of LOOP.  */
end_comment

begin_function
name|edge
name|loop_latch_edge
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
return|return
name|find_edge
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
name|loop
operator|->
name|header
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns preheader edge of LOOP.  */
end_comment

begin_function
name|edge
name|loop_preheader_edge
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|loop->header->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|loop
operator|->
name|latch
condition|)
break|break;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Returns true if E is an exit of LOOP.  */
end_comment

begin_function
name|bool
name|loop_exit_edge_p
parameter_list|(
specifier|const
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
return|return
operator|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|src
argument_list|)
operator|&&
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

