begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language independent return value optimizations    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* This file implements return value optimizations for functions which    return aggregate types.     Basically this pass searches the function for return statements which    return a local aggregate.  When converted to RTL such statements will    generate a copy from the local aggregate to final return value destination    mandated by the target's ABI.     That copy can often be avoided by directly constructing the return value    into the final destination mandated by the target's ABI.     This is basically a generic equivalent to the C++ front-end's     Named Return Value optimization.  */
end_comment

begin_struct
struct|struct
name|nrv_data
block|{
comment|/* This is the temporary (a VAR_DECL) which appears in all of      this function's RETURN_EXPR statements.  */
name|tree
name|var
decl_stmt|;
comment|/* This is the function's RESULT_DECL.  We will replace all occurrences      of VAR with RESULT_DECL when we apply this optimization.  */
name|tree
name|result
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|tree
name|finalize_nrv_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Callback for the tree walker.     If TP refers to a RETURN_EXPR, then set the expression being returned    to nrv_data->result.     If TP refers to nrv_data->var, then replace nrv_data->var with    nrv_data->result.     If we reach a node where we know all the subtrees are uninteresting,    then set *WALK_SUBTREES to zero.  */
end_comment

begin_function
specifier|static
name|tree
name|finalize_nrv_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|nrv_data
modifier|*
name|dp
init|=
operator|(
expr|struct
name|nrv_data
operator|*
operator|)
name|data
decl_stmt|;
comment|/* No need to walk into types.  */
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Otherwise replace all occurrences of VAR with RESULT.  */
elseif|else
if|if
condition|(
operator|*
name|tp
operator|==
name|dp
operator|->
name|var
condition|)
operator|*
name|tp
operator|=
name|dp
operator|->
name|result
expr_stmt|;
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Main entry point for return value optimizations.     If this function always returns the same local variable, and that    local variable is an aggregate type, then replace the variable with    the function's DECL_RESULT.     This is the equivalent of the C++ named return value optimization    applied to optimized trees in a language independent form.  If we    ever encounter languages which prevent this kind of optimization,    then we could either have the languages register the optimization or    we could change the gating function to check the current language.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_nrv
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|tree
name|found
init|=
name|NULL
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|struct
name|nrv_data
name|data
decl_stmt|;
comment|/* If this function does not return an aggregate type in memory, then      there is nothing to do.  */
if|if
condition|(
operator|!
name|aggregate_value_p
argument_list|(
name|result
argument_list|,
name|current_function_decl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Look through each block for assignments to the RESULT_DECL.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|tree
name|ret_expr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
block|{
comment|/* In a function with an aggregate return value, the 		 gimplifier has changed all non-empty RETURN_EXPRs to 		 return the RESULT_DECL.  */
name|ret_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_expr
condition|)
name|gcc_assert
argument_list|(
name|ret_expr
operator|==
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|==
name|result
condition|)
block|{
name|ret_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now verify that this return statement uses the same value 		 as any previously encountered return statement.  */
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
comment|/* If we found a return statement using a different variable 		     than previous return statements, then we can not perform 		     NRV optimizations.  */
if|if
condition|(
name|found
operator|!=
name|ret_expr
condition|)
return|return
literal|0
return|;
block|}
else|else
name|found
operator|=
name|ret_expr
expr_stmt|;
comment|/* The returned value must be a local automatic variable of the 		 same type and alignment as the function's result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|found
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|found
argument_list|)
operator|||
name|DECL_CONTEXT
argument_list|(
name|found
argument_list|)
operator|!=
name|current_function_decl
operator|||
name|TREE_STATIC
argument_list|(
name|found
argument_list|)
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|found
argument_list|)
operator|||
name|DECL_ALIGN
argument_list|(
name|found
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|result
argument_list|)
operator|||
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
argument_list|,
name|result_type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|addr
init|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If there's any MODIFY of component of RESULT,  		  then bail out.  */
if|if
condition|(
name|addr
operator|&&
name|addr
operator|==
name|result
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
literal|0
return|;
comment|/* If dumping details, then note once and only the NRV replacement.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"NRV Replaced: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|found
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  with: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|result
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* At this point we know that all the return statements return the      same local which has suitable attributes for NRV.   Copy debugging      information from FOUND to RESULT.  */
name|DECL_NAME
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|found
argument_list|)
expr_stmt|;
comment|/* Now walk through the function changing all references to VAR to be      RESULT.  */
name|data
operator|.
name|var
operator|=
name|found
expr_stmt|;
name|data
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|tree
modifier|*
name|tp
init|=
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
comment|/* If this is a copy from VAR to RESULT, remove it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
operator|==
name|result
operator|&&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
operator|==
name|found
condition|)
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|finalize_nrv_r
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* FOUND is no longer used.  Ensure it gets removed.  */
name|var_ann
argument_list|(
name|found
argument_list|)
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_nrv
init|=
block|{
literal|"nrv"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|tree_nrv
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_NRV
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine (pessimistically) whether DEST is available for NRV    optimization, where DEST is expected to be the LHS of a modify    expression where the RHS is a function returning an aggregate.     We search for a base VAR_DECL and look to see if it, or any of its    subvars are clobbered.  Note that we could do better, for example, by    attempting to doing points-to analysis on INDIRECT_REFs.  */
end_comment

begin_function
specifier|static
name|bool
name|dest_safe_for_nrv_p
parameter_list|(
name|tree
name|dest
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|dest
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
block|{
name|subvar_t
name|subvar
decl_stmt|;
if|if
condition|(
name|is_call_clobbered
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|subvar
operator|=
name|get_subvars_for_var
argument_list|(
name|dest
argument_list|)
init|;
name|subvar
condition|;
name|subvar
operator|=
name|subvar
operator|->
name|next
control|)
if|if
condition|(
name|is_call_clobbered
argument_list|(
name|subvar
operator|->
name|var
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
case|case
name|ARRAY_REF
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|dest_safe_for_nrv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Walk through the function looking for MODIFY_EXPRs with calls that    return in memory on the RHS.  For each of these, determine whether it is    safe to pass the address of the LHS as the return slot, and mark the    call appropriately if so.     The NRV shares the return slot with a local variable in the callee; this    optimization shares the return slot with the target of the call within    the caller.  If the NRV is performed (which we can't know in general),    this optimization is safe if the address of the target has not    escaped prior to the call.  If it has, modifications to the local    variable will produce visible changes elsewhere, as in PR c++/19317.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_return_slot_opt
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|call
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|(
name|call
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|,
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|CALL_EXPR
operator|)
operator|&&
operator|!
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
name|call
argument_list|)
operator|&&
name|aggregate_value_p
argument_list|(
name|call
argument_list|,
name|call
argument_list|)
condition|)
comment|/* Check if the location being assigned to is 	       call-clobbered.  */
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
name|call
argument_list|)
operator|=
name|dest_safe_for_nrv_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_return_slot
init|=
block|{
literal|"retslot"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|execute_return_slot_opt
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

