begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate (post)dominators in slightly super-linear time.    Copyright (C) 2000, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Michael Matz (matz@ifh.de).     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file implements the well known algorithm from Lengauer and Tarjan    to compute the dominators in a control flow graph.  A basic block D is said    to dominate another block X, when all paths from the entry node of the CFG    to X go also over D.  The dominance relation is a transitive reflexive    relation and its minimal transitive reduction is a tree, called the    dominator tree.  So for each block X besides the entry block exists a    block I(X), called the immediate dominator of X, which is the parent of X    in the dominator tree.     The algorithm computes this dominator tree implicitly by computing for    each block its immediate dominator.  We use tree balancing and path    compression, so it's the O(e*a(e,v)) variant, where a(e,v) is the very    slowly growing functional inverse of the Ackerman function.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"et-forest.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* Whether the dominators and the postdominators are available.  */
end_comment

begin_decl_stmt
name|enum
name|dom_state
name|dom_computed
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We name our nodes with integers, beginning with 1.  Zero is reserved for    'undefined' or 'end of list'.  The name of each node is given by the dfs    number of the corresponding basic block.  Please note, that we include the    artificial ENTRY_BLOCK (or EXIT_BLOCK in the post-dom case) in our lists to    support multiple entry points.  Its dfs number is of course 1.  */
end_comment

begin_comment
comment|/* Type of Basic Block aka. TBB */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|int
name|TBB
typedef|;
end_typedef

begin_comment
comment|/* We work in a poor-mans object oriented fashion, and carry an instance of    this structure through all our 'methods'.  It holds various arrays    reflecting the (sub)structure of the flowgraph.  Most of them are of type    TBB and are also indexed by TBB.  */
end_comment

begin_struct
struct|struct
name|dom_info
block|{
comment|/* The parent of a node in the DFS tree.  */
name|TBB
modifier|*
name|dfs_parent
decl_stmt|;
comment|/* For a node x key[x] is roughly the node nearest to the root from which      exists a way to x only over nodes behind x.  Such a node is also called      semidominator.  */
name|TBB
modifier|*
name|key
decl_stmt|;
comment|/* The value in path_min[x] is the node y on the path from x to the root of      the tree x is in with the smallest key[y].  */
name|TBB
modifier|*
name|path_min
decl_stmt|;
comment|/* bucket[x] points to the first node of the set of nodes having x as key.  */
name|TBB
modifier|*
name|bucket
decl_stmt|;
comment|/* And next_bucket[x] points to the next node.  */
name|TBB
modifier|*
name|next_bucket
decl_stmt|;
comment|/* After the algorithm is done, dom[x] contains the immediate dominator      of x.  */
name|TBB
modifier|*
name|dom
decl_stmt|;
comment|/* The following few fields implement the structures needed for disjoint      sets.  */
comment|/* set_chain[x] is the next node on the path from x to the representant      of the set containing x.  If set_chain[x]==0 then x is a root.  */
name|TBB
modifier|*
name|set_chain
decl_stmt|;
comment|/* set_size[x] is the number of elements in the set named by x.  */
name|unsigned
name|int
modifier|*
name|set_size
decl_stmt|;
comment|/* set_child[x] is used for balancing the tree representing a set.  It can      be understood as the next sibling of x.  */
name|TBB
modifier|*
name|set_child
decl_stmt|;
comment|/* If b is the number of a basic block (BB->index), dfs_order[b] is the      number of that node in DFS order counted from 1.  This is an index      into most of the other arrays in this structure.  */
name|TBB
modifier|*
name|dfs_order
decl_stmt|;
comment|/* If x is the DFS-index of a node which corresponds with a basic block,      dfs_to_bb[x] is that basic block.  Note, that in our structure there are      more nodes that basic blocks, so only dfs_to_bb[dfs_order[bb->index]]==bb      is true for every basic block bb, but not the opposite.  */
name|basic_block
modifier|*
name|dfs_to_bb
decl_stmt|;
comment|/* This is the next free DFS number when creating the DFS tree.  */
name|unsigned
name|int
name|dfsnum
decl_stmt|;
comment|/* The number of nodes in the DFS tree (==dfsnum-1).  */
name|unsigned
name|int
name|nodes
decl_stmt|;
comment|/* Blocks with bits set here have a fake edge to EXIT.  These are used      to turn a DFS forest into a proper tree.  */
name|bitmap
name|fake_exit_edge
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|init_dom_info
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|,
name|enum
name|cdi_direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_dom_info
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calc_dfs_tree_nonrec
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|enum
name|cdi_direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calc_dfs_tree
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|,
name|enum
name|cdi_direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compress
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|,
name|TBB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TBB
name|eval
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|,
name|TBB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_roots
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|,
name|TBB
parameter_list|,
name|TBB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calc_idoms
parameter_list|(
name|struct
name|dom_info
modifier|*
parameter_list|,
name|enum
name|cdi_direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_dominance_info
parameter_list|(
name|enum
name|cdi_direction
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Keeps track of the*/
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|n_bbs_in_dom_tree
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper macro for allocating and initializing an array,    for aesthetic reasons.  */
end_comment

begin_define
define|#
directive|define
name|init_ar
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|num
parameter_list|,
name|content
parameter_list|)
define|\
value|do								\     {								\       unsigned int i = 1;
comment|/* Catch content == i.  */
value|\       if (! (content))						\ 	(var) = XCNEWVEC (type, num);				\       else							\ 	{							\ 	  (var) = XNEWVEC (type, (num));			\ 	  for (i = 0; i< num; i++)				\ 	    (var)[i] = (content);				\ 	}							\     }								\   while (0)
end_define

begin_comment
comment|/* Allocate all needed memory in a pessimistic fashion (so we round up).    This initializes the contents of DI, which already must be allocated.  */
end_comment

begin_function
specifier|static
name|void
name|init_dom_info
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|,
name|enum
name|cdi_direction
name|dir
parameter_list|)
block|{
name|unsigned
name|int
name|num
init|=
name|n_basic_blocks
decl_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|dfs_parent
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|path_min
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|key
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|dom
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|bucket
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|next_bucket
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|set_chain
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
argument|di->set_size
argument_list|,
argument|unsigned int
argument_list|,
argument|num
argument_list|,
literal|1
argument_list|)
empty_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|set_child
argument_list|,
name|TBB
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|dfs_order
argument_list|,
name|TBB
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|last_basic_block
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_ar
argument_list|(
name|di
operator|->
name|dfs_to_bb
argument_list|,
name|basic_block
argument_list|,
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|di
operator|->
name|dfsnum
operator|=
literal|1
expr_stmt|;
name|di
operator|->
name|nodes
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|fake_exit_edge
operator|=
name|dir
condition|?
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|init_ar
end_undef

begin_comment
comment|/* Free all allocated memory in DI, but not DI itself.  */
end_comment

begin_function
specifier|static
name|void
name|free_dom_info
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|)
block|{
name|free
argument_list|(
name|di
operator|->
name|dfs_parent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|path_min
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|dom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|bucket
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|next_bucket
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|set_chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|set_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|set_child
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|dfs_order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
operator|->
name|dfs_to_bb
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|di
operator|->
name|fake_exit_edge
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The nonrecursive variant of creating a DFS tree.  DI is our working    structure, BB the starting basic block for this tree and REVERSE    is true, if predecessors should be visited instead of successors of a    node.  After this is done all nodes reachable from BB were visited, have    assigned their dfs number and are linked together to form a tree.  */
end_comment

begin_function
specifier|static
name|void
name|calc_dfs_tree_nonrec
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|enum
name|cdi_direction
name|reverse
parameter_list|)
block|{
comment|/* We call this _only_ if bb is not already visited.  */
name|edge
name|e
decl_stmt|;
name|TBB
name|child_i
decl_stmt|,
name|my_i
init|=
literal|0
decl_stmt|;
name|edge_iterator
modifier|*
name|stack
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|,
name|einext
decl_stmt|;
name|int
name|sp
decl_stmt|;
comment|/* Start block (ENTRY_BLOCK_PTR for forward problem, EXIT_BLOCK for backward      problem).  */
name|basic_block
name|en_block
decl_stmt|;
comment|/* Ending block.  */
name|basic_block
name|ex_block
decl_stmt|;
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|edge_iterator
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Initialize our border blocks, and the first edge.  */
if|if
condition|(
name|reverse
condition|)
block|{
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
expr_stmt|;
name|en_block
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|ex_block
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
block|}
else|else
block|{
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
expr_stmt|;
name|en_block
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|ex_block
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
block|}
comment|/* When the stack is empty we break out of this loop.  */
while|while
condition|(
literal|1
condition|)
block|{
name|basic_block
name|bn
decl_stmt|;
comment|/* This loop traverses edges e in depth first manner, and fills the          stack.  */
while|while
condition|(
operator|!
name|ei_end_p
argument_list|(
name|ei
argument_list|)
condition|)
block|{
name|e
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
expr_stmt|;
comment|/* Deduce from E the current and the next block (BB and BN), and the 	     next edge.  */
if|if
condition|(
name|reverse
condition|)
block|{
name|bn
operator|=
name|e
operator|->
name|src
expr_stmt|;
comment|/* If the next node BN is either already visited or a border 	         block the current edge is useless, and simply overwritten 	         with the next edge out of the current node.  */
if|if
condition|(
name|bn
operator|==
name|ex_block
operator|||
name|di
operator|->
name|dfs_order
index|[
name|bn
operator|->
name|index
index|]
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|einext
operator|=
name|ei_start
argument_list|(
name|bn
operator|->
name|preds
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bn
operator|=
name|e
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|bn
operator|==
name|ex_block
operator|||
name|di
operator|->
name|dfs_order
index|[
name|bn
operator|->
name|index
index|]
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|einext
operator|=
name|ei_start
argument_list|(
name|bn
operator|->
name|succs
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|bn
operator|!=
name|en_block
argument_list|)
expr_stmt|;
comment|/* Fill the DFS tree info calculatable _before_ recursing.  */
if|if
condition|(
name|bb
operator|!=
name|en_block
condition|)
name|my_i
operator|=
name|di
operator|->
name|dfs_order
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
else|else
name|my_i
operator|=
name|di
operator|->
name|dfs_order
index|[
name|last_basic_block
index|]
expr_stmt|;
name|child_i
operator|=
name|di
operator|->
name|dfs_order
index|[
name|bn
operator|->
name|index
index|]
operator|=
name|di
operator|->
name|dfsnum
operator|++
expr_stmt|;
name|di
operator|->
name|dfs_to_bb
index|[
name|child_i
index|]
operator|=
name|bn
expr_stmt|;
name|di
operator|->
name|dfs_parent
index|[
name|child_i
index|]
operator|=
name|my_i
expr_stmt|;
comment|/* Save the current point in the CFG on the stack, and recurse.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei
expr_stmt|;
name|ei
operator|=
name|einext
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sp
condition|)
break|break;
name|ei
operator|=
name|stack
index|[
operator|--
name|sp
index|]
expr_stmt|;
comment|/* OK.  The edge-list was exhausted, meaning normally we would          end the recursion.  After returning from the recursive call,          there were (may be) other statements which were run after a          child node was completely considered by DFS.  Here is the          point to do it in the non-recursive variant.          E.g. The block just completed is in e->dest for forward DFS,          the block not yet completed (the parent of the one above)          in e->src.  This could be used e.g. for computing the number of          descendants or the tree depth.  */
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The main entry for calculating the DFS tree or forest.  DI is our working    structure and REVERSE is true, if we are interested in the reverse flow    graph.  In that case the result is not necessarily a tree but a forest,    because there may be nodes from which the EXIT_BLOCK is unreachable.  */
end_comment

begin_function
specifier|static
name|void
name|calc_dfs_tree
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|,
name|enum
name|cdi_direction
name|reverse
parameter_list|)
block|{
comment|/* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */
name|basic_block
name|begin
init|=
name|reverse
condition|?
name|EXIT_BLOCK_PTR
else|:
name|ENTRY_BLOCK_PTR
decl_stmt|;
name|di
operator|->
name|dfs_order
index|[
name|last_basic_block
index|]
operator|=
name|di
operator|->
name|dfsnum
expr_stmt|;
name|di
operator|->
name|dfs_to_bb
index|[
name|di
operator|->
name|dfsnum
index|]
operator|=
name|begin
expr_stmt|;
name|di
operator|->
name|dfsnum
operator|++
expr_stmt|;
name|calc_dfs_tree_nonrec
argument_list|(
name|di
argument_list|,
name|begin
argument_list|,
name|reverse
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
comment|/* In the post-dom case we may have nodes without a path to EXIT_BLOCK.          They are reverse-unreachable.  In the dom-case we disallow such          nodes, but in post-dom we have to deal with them.  	 There are two situations in which this occurs.  First, noreturn 	 functions.  Second, infinite loops.  In the first case we need to 	 pretend that there is an edge to the exit block.  In the second 	 case, we wind up with a forest.  We need to process all noreturn 	 blocks before we know if we've got any infinite loops.  */
name|basic_block
name|b
decl_stmt|;
name|bool
name|saw_unconnected
init|=
name|false
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|b
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|di
operator|->
name|dfs_order
index|[
name|b
operator|->
name|index
index|]
operator|==
literal|0
condition|)
name|saw_unconnected
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|bitmap_set_bit
argument_list|(
name|di
operator|->
name|fake_exit_edge
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|di
operator|->
name|dfs_order
index|[
name|b
operator|->
name|index
index|]
operator|=
name|di
operator|->
name|dfsnum
expr_stmt|;
name|di
operator|->
name|dfs_to_bb
index|[
name|di
operator|->
name|dfsnum
index|]
operator|=
name|b
expr_stmt|;
name|di
operator|->
name|dfs_parent
index|[
name|di
operator|->
name|dfsnum
index|]
operator|=
name|di
operator|->
name|dfs_order
index|[
name|last_basic_block
index|]
expr_stmt|;
name|di
operator|->
name|dfsnum
operator|++
expr_stmt|;
name|calc_dfs_tree_nonrec
argument_list|(
name|di
argument_list|,
name|b
argument_list|,
name|reverse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saw_unconnected
condition|)
block|{
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|di
operator|->
name|dfs_order
index|[
name|b
operator|->
name|index
index|]
condition|)
continue|continue;
name|bitmap_set_bit
argument_list|(
name|di
operator|->
name|fake_exit_edge
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|di
operator|->
name|dfs_order
index|[
name|b
operator|->
name|index
index|]
operator|=
name|di
operator|->
name|dfsnum
expr_stmt|;
name|di
operator|->
name|dfs_to_bb
index|[
name|di
operator|->
name|dfsnum
index|]
operator|=
name|b
expr_stmt|;
name|di
operator|->
name|dfs_parent
index|[
name|di
operator|->
name|dfsnum
index|]
operator|=
name|di
operator|->
name|dfs_order
index|[
name|last_basic_block
index|]
expr_stmt|;
name|di
operator|->
name|dfsnum
operator|++
expr_stmt|;
name|calc_dfs_tree_nonrec
argument_list|(
name|di
argument_list|,
name|b
argument_list|,
name|reverse
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|di
operator|->
name|nodes
operator|=
name|di
operator|->
name|dfsnum
operator|-
literal|1
expr_stmt|;
comment|/* This aborts e.g. when there is _no_ path from ENTRY to EXIT at all.  */
name|gcc_assert
argument_list|(
name|di
operator|->
name|nodes
operator|==
operator|(
name|unsigned
name|int
operator|)
name|n_basic_blocks
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compress the path from V to the root of its set and update path_min at the    same time.  After compress(di, V) set_chain[V] is the root of the set V is    in and path_min[V] is the node with the smallest key[] value on the path    from V to that root.  */
end_comment

begin_function
specifier|static
name|void
name|compress
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|,
name|TBB
name|v
parameter_list|)
block|{
comment|/* Btw. It's not worth to unrecurse compress() as the depth is usually not      greater than 5 even for huge graphs (I've not seen call depth> 4).      Also performance wise compress() ranges _far_ behind eval().  */
name|TBB
name|parent
init|=
name|di
operator|->
name|set_chain
index|[
name|v
index|]
decl_stmt|;
if|if
condition|(
name|di
operator|->
name|set_chain
index|[
name|parent
index|]
condition|)
block|{
name|compress
argument_list|(
name|di
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|key
index|[
name|di
operator|->
name|path_min
index|[
name|parent
index|]
index|]
operator|<
name|di
operator|->
name|key
index|[
name|di
operator|->
name|path_min
index|[
name|v
index|]
index|]
condition|)
name|di
operator|->
name|path_min
index|[
name|v
index|]
operator|=
name|di
operator|->
name|path_min
index|[
name|parent
index|]
expr_stmt|;
name|di
operator|->
name|set_chain
index|[
name|v
index|]
operator|=
name|di
operator|->
name|set_chain
index|[
name|parent
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compress the path from V to the set root of V if needed (when the root has    changed since the last call).  Returns the node with the smallest key[]    value on the path from V to the root.  */
end_comment

begin_function
specifier|static
specifier|inline
name|TBB
name|eval
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|,
name|TBB
name|v
parameter_list|)
block|{
comment|/* The representant of the set V is in, also called root (as the set      representation is a tree).  */
name|TBB
name|rep
init|=
name|di
operator|->
name|set_chain
index|[
name|v
index|]
decl_stmt|;
comment|/* V itself is the root.  */
if|if
condition|(
operator|!
name|rep
condition|)
return|return
name|di
operator|->
name|path_min
index|[
name|v
index|]
return|;
comment|/* Compress only if necessary.  */
if|if
condition|(
name|di
operator|->
name|set_chain
index|[
name|rep
index|]
condition|)
block|{
name|compress
argument_list|(
name|di
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|rep
operator|=
name|di
operator|->
name|set_chain
index|[
name|v
index|]
expr_stmt|;
block|}
if|if
condition|(
name|di
operator|->
name|key
index|[
name|di
operator|->
name|path_min
index|[
name|rep
index|]
index|]
operator|>=
name|di
operator|->
name|key
index|[
name|di
operator|->
name|path_min
index|[
name|v
index|]
index|]
condition|)
return|return
name|di
operator|->
name|path_min
index|[
name|v
index|]
return|;
else|else
return|return
name|di
operator|->
name|path_min
index|[
name|rep
index|]
return|;
block|}
end_function

begin_comment
comment|/* This essentially merges the two sets of V and W, giving a single set with    the new root V.  The internal representation of these disjoint sets is a    balanced tree.  Currently link(V,W) is only used with V being the parent    of W.  */
end_comment

begin_function
specifier|static
name|void
name|link_roots
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|,
name|TBB
name|v
parameter_list|,
name|TBB
name|w
parameter_list|)
block|{
name|TBB
name|s
init|=
name|w
decl_stmt|;
comment|/* Rebalance the tree.  */
while|while
condition|(
name|di
operator|->
name|key
index|[
name|di
operator|->
name|path_min
index|[
name|w
index|]
index|]
operator|<
name|di
operator|->
name|key
index|[
name|di
operator|->
name|path_min
index|[
name|di
operator|->
name|set_child
index|[
name|s
index|]
index|]
index|]
condition|)
block|{
if|if
condition|(
name|di
operator|->
name|set_size
index|[
name|s
index|]
operator|+
name|di
operator|->
name|set_size
index|[
name|di
operator|->
name|set_child
index|[
name|di
operator|->
name|set_child
index|[
name|s
index|]
index|]
index|]
operator|>=
literal|2
operator|*
name|di
operator|->
name|set_size
index|[
name|di
operator|->
name|set_child
index|[
name|s
index|]
index|]
condition|)
block|{
name|di
operator|->
name|set_chain
index|[
name|di
operator|->
name|set_child
index|[
name|s
index|]
index|]
operator|=
name|s
expr_stmt|;
name|di
operator|->
name|set_child
index|[
name|s
index|]
operator|=
name|di
operator|->
name|set_child
index|[
name|di
operator|->
name|set_child
index|[
name|s
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
name|di
operator|->
name|set_size
index|[
name|di
operator|->
name|set_child
index|[
name|s
index|]
index|]
operator|=
name|di
operator|->
name|set_size
index|[
name|s
index|]
expr_stmt|;
name|s
operator|=
name|di
operator|->
name|set_chain
index|[
name|s
index|]
operator|=
name|di
operator|->
name|set_child
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
name|di
operator|->
name|path_min
index|[
name|s
index|]
operator|=
name|di
operator|->
name|path_min
index|[
name|w
index|]
expr_stmt|;
name|di
operator|->
name|set_size
index|[
name|v
index|]
operator|+=
name|di
operator|->
name|set_size
index|[
name|w
index|]
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|set_size
index|[
name|v
index|]
operator|<
literal|2
operator|*
name|di
operator|->
name|set_size
index|[
name|w
index|]
condition|)
block|{
name|TBB
name|tmp
init|=
name|s
decl_stmt|;
name|s
operator|=
name|di
operator|->
name|set_child
index|[
name|v
index|]
expr_stmt|;
name|di
operator|->
name|set_child
index|[
name|v
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Merge all subtrees.  */
while|while
condition|(
name|s
condition|)
block|{
name|di
operator|->
name|set_chain
index|[
name|s
index|]
operator|=
name|v
expr_stmt|;
name|s
operator|=
name|di
operator|->
name|set_child
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This calculates the immediate dominators (or post-dominators if REVERSE is    true).  DI is our working structure and should hold the DFS forest.    On return the immediate dominator to node V is in di->dom[V].  */
end_comment

begin_function
specifier|static
name|void
name|calc_idoms
parameter_list|(
name|struct
name|dom_info
modifier|*
name|di
parameter_list|,
name|enum
name|cdi_direction
name|reverse
parameter_list|)
block|{
name|TBB
name|v
decl_stmt|,
name|w
decl_stmt|,
name|k
decl_stmt|,
name|par
decl_stmt|;
name|basic_block
name|en_block
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|,
name|einext
decl_stmt|;
if|if
condition|(
name|reverse
condition|)
name|en_block
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
else|else
name|en_block
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
comment|/* Go backwards in DFS order, to first look at the leafs.  */
name|v
operator|=
name|di
operator|->
name|nodes
expr_stmt|;
while|while
condition|(
name|v
operator|>
literal|1
condition|)
block|{
name|basic_block
name|bb
init|=
name|di
operator|->
name|dfs_to_bb
index|[
name|v
index|]
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|par
operator|=
name|di
operator|->
name|dfs_parent
index|[
name|v
index|]
expr_stmt|;
name|k
operator|=
name|v
expr_stmt|;
name|ei
operator|=
operator|(
name|reverse
operator|)
condition|?
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
else|:
name|ei_start
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
comment|/* If this block has a fake edge to exit, process that first.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|di
operator|->
name|fake_exit_edge
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|einext
operator|=
name|ei
expr_stmt|;
name|einext
operator|.
name|index
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_fake_exit_edge
goto|;
block|}
block|}
comment|/* Search all direct predecessors for the smallest node with a path          to them.  That way we have the smallest node with also a path to          us only over nodes behind us.  In effect we search for our          semidominator.  */
while|while
condition|(
operator|!
name|ei_end_p
argument_list|(
name|ei
argument_list|)
condition|)
block|{
name|TBB
name|k1
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
name|e
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|reverse
operator|)
condition|?
name|e
operator|->
name|dest
else|:
name|e
operator|->
name|src
expr_stmt|;
name|einext
operator|=
name|ei
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|einext
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|en_block
condition|)
block|{
name|do_fake_exit_edge
label|:
name|k1
operator|=
name|di
operator|->
name|dfs_order
index|[
name|last_basic_block
index|]
expr_stmt|;
block|}
else|else
name|k1
operator|=
name|di
operator|->
name|dfs_order
index|[
name|b
operator|->
name|index
index|]
expr_stmt|;
comment|/* Call eval() only if really needed.  If k1 is above V in DFS tree, 	     then we know, that eval(k1) == k1 and key[k1] == k1.  */
if|if
condition|(
name|k1
operator|>
name|v
condition|)
name|k1
operator|=
name|di
operator|->
name|key
index|[
name|eval
argument_list|(
name|di
argument_list|,
name|k1
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|k1
operator|<
name|k
condition|)
name|k
operator|=
name|k1
expr_stmt|;
name|ei
operator|=
name|einext
expr_stmt|;
block|}
name|di
operator|->
name|key
index|[
name|v
index|]
operator|=
name|k
expr_stmt|;
name|link_roots
argument_list|(
name|di
argument_list|,
name|par
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|di
operator|->
name|next_bucket
index|[
name|v
index|]
operator|=
name|di
operator|->
name|bucket
index|[
name|k
index|]
expr_stmt|;
name|di
operator|->
name|bucket
index|[
name|k
index|]
operator|=
name|v
expr_stmt|;
comment|/* Transform semidominators into dominators.  */
for|for
control|(
name|w
operator|=
name|di
operator|->
name|bucket
index|[
name|par
index|]
init|;
name|w
condition|;
name|w
operator|=
name|di
operator|->
name|next_bucket
index|[
name|w
index|]
control|)
block|{
name|k
operator|=
name|eval
argument_list|(
name|di
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|key
index|[
name|k
index|]
operator|<
name|di
operator|->
name|key
index|[
name|w
index|]
condition|)
name|di
operator|->
name|dom
index|[
name|w
index|]
operator|=
name|k
expr_stmt|;
else|else
name|di
operator|->
name|dom
index|[
name|w
index|]
operator|=
name|par
expr_stmt|;
block|}
comment|/* We don't need to cleanup next_bucket[].  */
name|di
operator|->
name|bucket
index|[
name|par
index|]
operator|=
literal|0
expr_stmt|;
name|v
operator|--
expr_stmt|;
block|}
comment|/* Explicitly define the dominators.  */
name|di
operator|->
name|dom
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
literal|2
init|;
name|v
operator|<=
name|di
operator|->
name|nodes
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|di
operator|->
name|dom
index|[
name|v
index|]
operator|!=
name|di
operator|->
name|key
index|[
name|v
index|]
condition|)
name|di
operator|->
name|dom
index|[
name|v
index|]
operator|=
name|di
operator|->
name|dom
index|[
name|di
operator|->
name|dom
index|[
name|v
index|]
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assign dfs numbers starting from NUM to NODE and its sons.  */
end_comment

begin_function
specifier|static
name|void
name|assign_dfs_numbers
parameter_list|(
name|struct
name|et_node
modifier|*
name|node
parameter_list|,
name|int
modifier|*
name|num
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|son
decl_stmt|;
name|node
operator|->
name|dfs_num_in
operator|=
operator|(
operator|*
name|num
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|son
condition|)
block|{
name|assign_dfs_numbers
argument_list|(
name|node
operator|->
name|son
argument_list|,
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|son
operator|=
name|node
operator|->
name|son
operator|->
name|right
init|;
name|son
operator|!=
name|node
operator|->
name|son
condition|;
name|son
operator|=
name|son
operator|->
name|right
control|)
name|assign_dfs_numbers
argument_list|(
name|son
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|dfs_num_out
operator|=
operator|(
operator|*
name|num
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the data necessary for fast resolving of dominator queries in a    static dominator tree.  */
end_comment

begin_function
specifier|static
name|void
name|compute_dom_fast_query
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_info_available_p
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
condition|)
return|return;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
operator|!
name|bb
operator|->
name|dom
index|[
name|dir
index|]
operator|->
name|father
condition|)
name|assign_dfs_numbers
argument_list|(
name|bb
operator|->
name|dom
index|[
name|dir
index|]
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
block|}
name|dom_computed
index|[
name|dir
index|]
operator|=
name|DOM_OK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The main entry point into this module.  DIR is set depending on whether    we want to compute dominators or postdominators.  */
end_comment

begin_function
name|void
name|calculate_dominance_info
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|)
block|{
name|struct
name|dom_info
name|di
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_DOMINANCE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dom_info_available_p
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|n_bbs_in_dom_tree
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|b
argument_list|)
block|{
name|b
operator|->
name|dom
index|[
name|dir
index|]
operator|=
name|et_new_tree
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|n_bbs_in_dom_tree
index|[
name|dir
index|]
operator|=
name|n_basic_blocks
expr_stmt|;
name|init_dom_info
argument_list|(
operator|&
name|di
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|calc_dfs_tree
argument_list|(
operator|&
name|di
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|calc_idoms
argument_list|(
operator|&
name|di
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
block|{
name|TBB
name|d
init|=
name|di
operator|.
name|dom
index|[
name|di
operator|.
name|dfs_order
index|[
name|b
operator|->
name|index
index|]
index|]
decl_stmt|;
if|if
condition|(
name|di
operator|.
name|dfs_to_bb
index|[
name|d
index|]
condition|)
name|et_set_father
argument_list|(
name|b
operator|->
name|dom
index|[
name|dir
index|]
argument_list|,
name|di
operator|.
name|dfs_to_bb
index|[
name|d
index|]
operator|->
name|dom
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
block|}
name|free_dom_info
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
name|dom_computed
index|[
name|dir
index|]
operator|=
name|DOM_NO_FAST_QUERY
expr_stmt|;
block|}
name|compute_dom_fast_query
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DOMINANCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free dominance information for direction DIR.  */
end_comment

begin_function
name|void
name|free_dominance_info
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|dom_info_available_p
argument_list|(
name|dir
argument_list|)
condition|)
return|return;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|et_free_tree_force
argument_list|(
name|bb
operator|->
name|dom
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
name|bb
operator|->
name|dom
index|[
name|dir
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|et_free_pools
argument_list|()
expr_stmt|;
name|n_bbs_in_dom_tree
index|[
name|dir
index|]
operator|=
literal|0
expr_stmt|;
name|dom_computed
index|[
name|dir
index|]
operator|=
name|DOM_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the immediate dominator of basic block BB.  */
end_comment

begin_function
name|basic_block
name|get_immediate_dominator
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|node
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|father
condition|)
return|return
name|NULL
return|;
return|return
name|node
operator|->
name|father
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Set the immediate dominator of the block possibly removing    existing edge.  NULL can be used to remove any edge.  */
end_comment

begin_function
specifier|inline
name|void
name|set_immediate_dominator
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|dominated_by
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|node
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|father
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|father
operator|->
name|data
operator|==
name|dominated_by
condition|)
return|return;
name|et_split
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dominated_by
condition|)
name|et_set_father
argument_list|(
name|node
argument_list|,
name|dominated_by
operator|->
name|dom
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
condition|)
name|dom_computed
index|[
name|dir
index|]
operator|=
name|DOM_NO_FAST_QUERY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all basic blocks immediately dominated by BB into BBS and return    their number.  */
end_comment

begin_function
name|int
name|get_dominated_by
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|basic_block
modifier|*
modifier|*
name|bbs
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|struct
name|et_node
modifier|*
name|node
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|,
modifier|*
name|son
init|=
name|node
operator|->
name|son
decl_stmt|,
modifier|*
name|ason
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|son
condition|)
block|{
operator|*
name|bbs
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|ason
operator|=
name|son
operator|->
name|right
operator|,
name|n
operator|=
literal|1
init|;
name|ason
operator|!=
name|son
condition|;
name|ason
operator|=
name|ason
operator|->
name|right
control|)
name|n
operator|++
expr_stmt|;
operator|*
name|bbs
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|bbs
operator|)
index|[
literal|0
index|]
operator|=
name|son
operator|->
name|data
expr_stmt|;
for|for
control|(
name|ason
operator|=
name|son
operator|->
name|right
operator|,
name|n
operator|=
literal|1
init|;
name|ason
operator|!=
name|son
condition|;
name|ason
operator|=
name|ason
operator|->
name|right
control|)
operator|(
operator|*
name|bbs
operator|)
index|[
name|n
operator|++
index|]
operator|=
name|ason
operator|->
name|data
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Find all basic blocks that are immediately dominated (in direction DIR)    by some block between N_REGION ones stored in REGION, except for blocks    in the REGION itself.  The found blocks are stored to DOMS and their number    is returned.  */
end_comment

begin_function
name|unsigned
name|get_dominated_by_region
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
modifier|*
name|region
parameter_list|,
name|unsigned
name|n_region
parameter_list|,
name|basic_block
modifier|*
name|doms
parameter_list|)
block|{
name|unsigned
name|n_doms
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|basic_block
name|dom
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
name|region
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|BB_DUPLICATED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
for|for
control|(
name|dom
operator|=
name|first_dom_son
argument_list|(
name|dir
argument_list|,
name|region
index|[
name|i
index|]
argument_list|)
init|;
name|dom
condition|;
name|dom
operator|=
name|next_dom_son
argument_list|(
name|dir
argument_list|,
name|dom
argument_list|)
control|)
if|if
condition|(
operator|!
operator|(
name|dom
operator|->
name|flags
operator|&
name|BB_DUPLICATED
operator|)
condition|)
name|doms
index|[
name|n_doms
operator|++
index|]
operator|=
name|dom
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_region
condition|;
name|i
operator|++
control|)
name|region
index|[
name|i
index|]
operator|->
name|flags
operator|&=
operator|~
name|BB_DUPLICATED
expr_stmt|;
return|return
name|n_doms
return|;
block|}
end_function

begin_comment
comment|/* Redirect all edges pointing to BB to TO.  */
end_comment

begin_function
name|void
name|redirect_immediate_dominators
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|to
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|bb_node
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|,
modifier|*
name|to_node
init|=
name|to
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|,
modifier|*
name|son
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_node
operator|->
name|son
condition|)
return|return;
while|while
condition|(
name|bb_node
operator|->
name|son
condition|)
block|{
name|son
operator|=
name|bb_node
operator|->
name|son
expr_stmt|;
name|et_split
argument_list|(
name|son
argument_list|)
expr_stmt|;
name|et_set_father
argument_list|(
name|son
argument_list|,
name|to_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
condition|)
name|dom_computed
index|[
name|dir
index|]
operator|=
name|DOM_NO_FAST_QUERY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find first basic block in the tree dominating both BB1 and BB2.  */
end_comment

begin_function
name|basic_block
name|nearest_common_dominator
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb1
condition|)
return|return
name|bb2
return|;
if|if
condition|(
operator|!
name|bb2
condition|)
return|return
name|bb1
return|;
return|return
name|et_nca
argument_list|(
name|bb1
operator|->
name|dom
index|[
name|dir
index|]
argument_list|,
name|bb2
operator|->
name|dom
index|[
name|dir
index|]
argument_list|)
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Find the nearest common dominator for the basic blocks in BLOCKS,    using dominance direction DIR.  */
end_comment

begin_function
name|basic_block
name|nearest_common_dominator_for_set
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|bitmap
name|blocks
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|first
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|basic_block
name|dom
decl_stmt|;
name|first
operator|=
name|bitmap_first_set_bit
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|dom
operator|=
name|BASIC_BLOCK
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
name|dom
operator|!=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
condition|)
name|dom
operator|=
name|nearest_common_dominator
argument_list|(
name|dir
argument_list|,
name|dom
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dom
return|;
block|}
end_function

begin_comment
comment|/*  Given a dominator tree, we can determine whether one thing     dominates another in constant time by using two DFS numbers:      1. The number for when we visit a node on the way down the tree     2. The number for when we visit a node on the way back up the tree      You can view these as bounds for the range of dfs numbers the     nodes in the subtree of the dominator tree rooted at that node     will contain.          The dominator tree is always a simple acyclic tree, so there are     only three possible relations two nodes in the dominator tree have     to each other:          1. Node A is above Node B (and thus, Node A dominates node B)       A      |      C     / \    B   D      In the above case, DFS_Number_In of A will be<= DFS_Number_In of    B, and DFS_Number_Out of A will be>= DFS_Number_Out of B.  This is    because we must hit A in the dominator tree *before* B on the walk    down, and we will hit A *after* B on the walk back up        2. Node A is below node B (and thus, node B dominates node A)              B      |      A     / \    C   D     In the above case, DFS_Number_In of A will be>= DFS_Number_In of    B, and DFS_Number_Out of A will be<= DFS_Number_Out of B.        This is because we must hit A in the dominator tree *after* B on    the walk down, and we will hit A *before* B on the walk back up        3. Node A and B are siblings (and thus, neither dominates the other)       C      |      D     / \    A   B     In the above case, DFS_Number_In of A will *always* be<=    DFS_Number_In of B, and DFS_Number_Out of A will *always* be<=    DFS_Number_Out of B.  This is because we will always finish the dfs    walk of one of the subtrees before the other, and thus, the dfs    numbers for one subtree can't intersect with the range of dfs    numbers for the other subtree.  If you swap A and B's position in    the dominator tree, the comparison changes direction, but the point    is that both comparisons will always go the same way if there is no    dominance relationship.     Thus, it is sufficient to write     A_Dominates_B (node A, node B)    {      return DFS_Number_In(A)<= DFS_Number_In(B)&& DFS_Number_Out (A)>= DFS_Number_Out(B);    }     A_Dominated_by_B (node A, node B)    {      return DFS_Number_In(A)>= DFS_Number_In(A)&& DFS_Number_Out (A)<= DFS_Number_Out(B);    }  */
end_comment

begin_comment
comment|/* Return TRUE in case BB1 is dominated by BB2.  */
end_comment

begin_function
name|bool
name|dominated_by_p
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|n1
init|=
name|bb1
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|,
modifier|*
name|n2
init|=
name|bb2
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
condition|)
return|return
operator|(
name|n1
operator|->
name|dfs_num_in
operator|>=
name|n2
operator|->
name|dfs_num_in
operator|&&
name|n1
operator|->
name|dfs_num_out
operator|<=
name|n2
operator|->
name|dfs_num_out
operator|)
return|;
return|return
name|et_below
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the entry dfs number for basic block BB, in the direction DIR.  */
end_comment

begin_function
name|unsigned
name|bb_dom_dfs_in
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|n
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
argument_list|)
expr_stmt|;
return|return
name|n
operator|->
name|dfs_num_in
return|;
block|}
end_function

begin_comment
comment|/* Returns the exit dfs number for basic block BB, in the direction DIR.  */
end_comment

begin_function
name|unsigned
name|bb_dom_dfs_out
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|n
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
argument_list|)
expr_stmt|;
return|return
name|n
operator|->
name|dfs_num_out
return|;
block|}
end_function

begin_comment
comment|/* Verify invariants of dominator structure.  */
end_comment

begin_function
name|void
name|verify_dominators
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_info_available_p
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|basic_block
name|dom_bb
decl_stmt|;
name|basic_block
name|imm_bb
decl_stmt|;
name|dom_bb
operator|=
name|recount_dominator
argument_list|(
name|dir
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|imm_bb
operator|=
name|get_immediate_dominator
argument_list|(
name|dir
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_bb
operator|!=
name|imm_bb
condition|)
block|{
if|if
condition|(
operator|(
name|dom_bb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|imm_bb
operator|==
name|NULL
operator|)
condition|)
name|error
argument_list|(
literal|"dominator of %d status unknown"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"dominator of %d should be %d, not %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|dom_bb
operator|->
name|index
argument_list|,
name|imm_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dir
operator|==
name|CDI_DOMINATORS
condition|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|dir
argument_list|,
name|bb
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"ENTRY does not dominate bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|gcc_assert
argument_list|(
operator|!
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine immediate dominator (or postdominator, according to DIR) of BB,    assuming that dominators of other blocks are correct.  We also use it to    recompute the dominators in a restricted area, by iterating it until it    reaches a fixed point.  */
end_comment

begin_function
name|basic_block
name|recount_dominator
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|basic_block
name|dom_bb
init|=
name|NULL
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|CDI_DOMINATORS
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
comment|/* Ignore the predecessors that either are not reachable from 	     the entry block, or whose dominator was not determined yet.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|dir
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|dir
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|bb
argument_list|)
condition|)
name|dom_bb
operator|=
name|nearest_common_dominator
argument_list|(
name|dir
argument_list|,
name|dom_bb
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|dir
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|bb
argument_list|)
condition|)
name|dom_bb
operator|=
name|nearest_common_dominator
argument_list|(
name|dir
argument_list|,
name|dom_bb
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dom_bb
return|;
block|}
end_function

begin_comment
comment|/* Iteratively recount dominators of BBS. The change is supposed to be local    and not to grow further.  */
end_comment

begin_function
name|void
name|iterate_fix_dominators
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|changed
init|=
literal|1
decl_stmt|;
name|basic_block
name|old_dom
decl_stmt|,
name|new_dom
decl_stmt|;
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|set_immediate_dominator
argument_list|(
name|dir
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|old_dom
operator|=
name|get_immediate_dominator
argument_list|(
name|dir
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|new_dom
operator|=
name|recount_dominator
argument_list|(
name|dir
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_dom
operator|!=
name|new_dom
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|dir
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|,
name|new_dom
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|gcc_assert
argument_list|(
name|get_immediate_dominator
argument_list|(
name|dir
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_to_dominance_info
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|bb
operator|->
name|dom
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
name|n_bbs_in_dom_tree
index|[
name|dir
index|]
operator|++
expr_stmt|;
name|bb
operator|->
name|dom
index|[
name|dir
index|]
operator|=
name|et_new_tree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
condition|)
name|dom_computed
index|[
name|dir
index|]
operator|=
name|DOM_NO_FAST_QUERY
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_from_dominance_info
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
name|et_free_tree
argument_list|(
name|bb
operator|->
name|dom
index|[
name|dir
index|]
argument_list|)
expr_stmt|;
name|bb
operator|->
name|dom
index|[
name|dir
index|]
operator|=
name|NULL
expr_stmt|;
name|n_bbs_in_dom_tree
index|[
name|dir
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|dir
index|]
operator|==
name|DOM_OK
condition|)
name|dom_computed
index|[
name|dir
index|]
operator|=
name|DOM_NO_FAST_QUERY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the first son of BB in the dominator or postdominator tree    as determined by DIR.  */
end_comment

begin_function
name|basic_block
name|first_dom_son
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|son
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
operator|->
name|son
decl_stmt|;
return|return
name|son
condition|?
name|son
operator|->
name|data
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns the next dominance son after BB in the dominator or postdominator    tree as determined by DIR, or NULL if it was the last one.  */
end_comment

begin_function
name|basic_block
name|next_dom_son
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|next
init|=
name|bb
operator|->
name|dom
index|[
name|dir
index|]
operator|->
name|right
decl_stmt|;
return|return
name|next
operator|->
name|father
operator|->
name|son
operator|==
name|next
condition|?
name|NULL
else|:
name|next
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Returns true if dominance information for direction DIR is available.  */
end_comment

begin_function
name|bool
name|dom_info_available_p
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|)
block|{
return|return
name|dom_computed
index|[
name|dir
index|]
operator|!=
name|DOM_NONE
return|;
block|}
end_function

begin_function
name|void
name|debug_dominance_info
parameter_list|(
name|enum
name|cdi_direction
name|dir
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|bb2
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
operator|(
name|bb2
operator|=
name|get_immediate_dominator
argument_list|(
name|dir
argument_list|,
name|bb
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%i %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

