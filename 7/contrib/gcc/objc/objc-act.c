begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implement classes and message passing for Objective C.    Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Steve Naroff.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Purpose: This module implements the Objective-C 4.0 language.     compatibility issues (with the Stepstone translator):     - does not recognize the following 3.3 constructs.      @requires, @classes, @messages, = (...)    - methods with variable arguments must conform to ANSI standard.    - tagged structure definitions that appear in BOTH the interface      and implementation are not allowed.    - public/private: all instance variables are public within the      context of the implementation...I consider this to be a bug in      the translator.    - statically allocated objects are not supported. the user will      receive an error if this service is requested.     code generation `options':     */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"objc-act.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_define
define|#
directive|define
name|OBJC_VOID_AT_END
value|void_list_node
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|should_call_super_dealloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When building Objective-C++, we are not linking against the C front-end    and so need to replicate the C tree-construction functions in some way.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_define
define|#
directive|define
name|OBJCP_REMAP_FUNCTIONS
end_define

begin_include
include|#
directive|include
file|"objcp-decl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJCPLUS */
end_comment

begin_comment
comment|/* This is the default way of generating a method name.  */
end_comment

begin_comment
comment|/* I am not sure it is really correct.    Perhaps there's a danger that it will make name conflicts    if method names contain underscores. -- rms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_GEN_METHOD_LABEL
end_ifndef

begin_define
define|#
directive|define
name|OBJC_GEN_METHOD_LABEL
parameter_list|(
name|BUF
parameter_list|,
name|IS_INST
parameter_list|,
name|CLASS_NAME
parameter_list|,
name|CAT_NAME
parameter_list|,
name|SEL_NAME
parameter_list|,
name|NUM
parameter_list|)
define|\
value|do {					    \     char *temp;				    \     sprintf ((BUF), "_%s_%s_%s_%s",	    \ 	     ((IS_INST) ? "i" : "c"),	    \ 	     (CLASS_NAME),		    \ 	     ((CAT_NAME)? (CAT_NAME) : ""), \ 	     (SEL_NAME));		    \     for (temp = (BUF); *temp; temp++)	    \       if (*temp == ':') *temp = '_';	    \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These need specifying.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_FORWARDING_STACK_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|OBJC_FORWARDING_STACK_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_FORWARDING_MIN_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|OBJC_FORWARDING_MIN_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Set up for use of obstacks.  */
end_comment

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* This obstack is used to accumulate the encoding of a data type.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|util_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the beginning of obstack contents, so we can free    the whole contents.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|util_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The version identifies which language generation and runtime    the module (file) was compiled for, and is recorded in the    module descriptor.  */
end_comment

begin_define
define|#
directive|define
name|OBJC_VERSION
value|(flag_next_runtime ? 6 : 8)
end_define

begin_define
define|#
directive|define
name|PROTOCOL_VERSION
value|2
end_define

begin_comment
comment|/* (Decide if these can ever be validly changed.) */
end_comment

begin_define
define|#
directive|define
name|OBJC_ENCODE_INLINE_DEFS
value|0
end_define

begin_define
define|#
directive|define
name|OBJC_ENCODE_DONT_INLINE_DEFS
value|1
end_define

begin_comment
comment|/*** Private Interface (procedures) ***/
end_comment

begin_comment
comment|/* Used by compile_file.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_objc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_objc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Code generation.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|objc_build_constructor
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_objc_method_call
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_proto_encoding
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_interface
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_add_static_instance
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|start_class
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|continue_class
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_class
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_method_def
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_function_decl
specifier|static
name|void
name|objc_start_function
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|objc_start_function
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|struct
name|c_arg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|tree
name|start_protocol
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_method_decl
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|objc_add_method
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|add_instance_variable
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ivar_reference
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|is_ivar
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_objc_exception_stuff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_next_objc_exception_stuff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We only need the following for ObjC; ObjC++ will use C++'s definition    of DERIVED_FROM_P.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJCPLUS
end_ifndef

begin_function_decl
specifier|static
name|bool
name|objc_derived_from_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DERIVED_FROM_P
parameter_list|(
name|PARENT
parameter_list|,
name|CHILD
parameter_list|)
value|objc_derived_from_p (PARENT, CHILD)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|objc_xref_basetypes
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_class_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_selector_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_category_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_super_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_protocol_initializer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_class_ivars
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|generate_protocol_list
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_protocol_reference
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_function_decl
specifier|static
name|void
name|objc_generate_cxx_cdtors
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|synth_id_with_class_suffix
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hash tables to manage the global pool of method prototypes.  */
end_comment

begin_decl_stmt
name|hash
modifier|*
name|nst_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hash
modifier|*
name|cls_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|hash
name|hash_lookup
parameter_list|(
name|hash
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_method
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_method_static
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|string_section
block|{
name|class_names
block|,
comment|/* class, category, protocol, module names */
name|meth_var_names
block|,
comment|/* method and variable names */
name|meth_var_types
comment|/* method and variable type descriptors */
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|tree
name|add_objc_string
parameter_list|(
name|tree
parameter_list|,
name|enum
name|string_section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_objc_string_decl
parameter_list|(
name|enum
name|string_section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_selector_table_decl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Protocol additions.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|lookup_protocol
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_and_install_protocols
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Type encoding.  */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_type_qualifiers
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_type
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_field_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_function_decl
specifier|static
name|void
name|really_start_method
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|really_start_method
parameter_list|(
name|tree
parameter_list|,
name|struct
name|c_arg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|comp_proto_with_proto
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|objc_push_parm
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_function_decl
specifier|static
name|tree
name|objc_get_parm_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|struct
name|c_arg_info
modifier|*
name|objc_get_parm_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Utilities for debugging and error diagnostics.  */
end_comment

begin_function_decl
specifier|static
name|void
name|warn_with_method
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_type_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_type_name_0
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_method_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_declaration
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Everything else.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|create_field_decl
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_class_reference
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_protocol_template
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|encode_method_prototype
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_classref_translation_entry
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_class_ref
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|generate_struct_by_value_array
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mark_referenced_methods
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_objc_image_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*** Private Interface (data) ***/
end_comment

begin_comment
comment|/* Reserved tag definitions.  */
end_comment

begin_define
define|#
directive|define
name|OBJECT_TYPEDEF_NAME
value|"id"
end_define

begin_define
define|#
directive|define
name|CLASS_TYPEDEF_NAME
value|"Class"
end_define

begin_define
define|#
directive|define
name|TAG_OBJECT
value|"objc_object"
end_define

begin_define
define|#
directive|define
name|TAG_CLASS
value|"objc_class"
end_define

begin_define
define|#
directive|define
name|TAG_SUPER
value|"objc_super"
end_define

begin_define
define|#
directive|define
name|TAG_SELECTOR
value|"objc_selector"
end_define

begin_define
define|#
directive|define
name|UTAG_CLASS
value|"_objc_class"
end_define

begin_define
define|#
directive|define
name|UTAG_IVAR
value|"_objc_ivar"
end_define

begin_define
define|#
directive|define
name|UTAG_IVAR_LIST
value|"_objc_ivar_list"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD
value|"_objc_method"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_LIST
value|"_objc_method_list"
end_define

begin_define
define|#
directive|define
name|UTAG_CATEGORY
value|"_objc_category"
end_define

begin_define
define|#
directive|define
name|UTAG_MODULE
value|"_objc_module"
end_define

begin_define
define|#
directive|define
name|UTAG_SYMTAB
value|"_objc_symtab"
end_define

begin_define
define|#
directive|define
name|UTAG_SUPER
value|"_objc_super"
end_define

begin_define
define|#
directive|define
name|UTAG_SELECTOR
value|"_objc_selector"
end_define

begin_define
define|#
directive|define
name|UTAG_PROTOCOL
value|"_objc_protocol"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_PROTOTYPE
value|"_objc_method_prototype"
end_define

begin_define
define|#
directive|define
name|UTAG_METHOD_PROTOTYPE_LIST
value|"_objc__method_prototype_list"
end_define

begin_comment
comment|/* Note that the string object global name is only needed for the    NeXT runtime.  */
end_comment

begin_define
define|#
directive|define
name|STRING_OBJECT_GLOBAL_FORMAT
value|"_%sClassReference"
end_define

begin_define
define|#
directive|define
name|PROTOCOL_OBJECT_CLASS_NAME
value|"Protocol"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_GETCLASS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_GETMETACLASS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSEND
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSENDSUPER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The NeXT Objective-C messenger may have two extra entry points, for use    when returning a structure. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSEND_STRET
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|TAG_MSGSENDSUPER_STRET
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_constant_string_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Runtime metadata flags.  */
end_comment

begin_define
define|#
directive|define
name|CLS_FACTORY
value|0x0001L
end_define

begin_define
define|#
directive|define
name|CLS_META
value|0x0002L
end_define

begin_define
define|#
directive|define
name|CLS_HAS_CXX_STRUCTORS
value|0x2000L
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_STATIC
value|0x00000001
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_FINAL
value|0x00000002
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_PUBLIC
value|0x00000004
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_PRIVATE
value|0x00000008
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_PROTECTED
value|0x00000010
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_NATIVE
value|0x00000020
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_SYNCHRONIZED
value|0x00000040
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_ABSTRACT
value|0x00000080
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_VOLATILE
value|0x00000100
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_TRANSIENT
value|0x00000200
end_define

begin_define
define|#
directive|define
name|OBJC_MODIFIER_NONE_SPECIFIED
value|0x80000000
end_define

begin_comment
comment|/* NeXT-specific tags.  */
end_comment

begin_define
define|#
directive|define
name|TAG_MSGSEND_NONNIL
value|"objc_msgSendNonNil"
end_define

begin_define
define|#
directive|define
name|TAG_MSGSEND_NONNIL_STRET
value|"objc_msgSendNonNil_stret"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONEXTRACT
value|"objc_exception_extract"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONTRYENTER
value|"objc_exception_try_enter"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONTRYEXIT
value|"objc_exception_try_exit"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONMATCH
value|"objc_exception_match"
end_define

begin_define
define|#
directive|define
name|TAG_EXCEPTIONTHROW
value|"objc_exception_throw"
end_define

begin_define
define|#
directive|define
name|TAG_SYNCENTER
value|"objc_sync_enter"
end_define

begin_define
define|#
directive|define
name|TAG_SYNCEXIT
value|"objc_sync_exit"
end_define

begin_define
define|#
directive|define
name|TAG_SETJMP
value|"_setjmp"
end_define

begin_define
define|#
directive|define
name|UTAG_EXCDATA
value|"_objc_exception_data"
end_define

begin_define
define|#
directive|define
name|TAG_ASSIGNIVAR
value|"objc_assign_ivar"
end_define

begin_define
define|#
directive|define
name|TAG_ASSIGNGLOBAL
value|"objc_assign_global"
end_define

begin_define
define|#
directive|define
name|TAG_ASSIGNSTRONGCAST
value|"objc_assign_strongCast"
end_define

begin_comment
comment|/* Branch entry points.  All that matters here are the addresses;    functions with these names do not really exist in libobjc.  */
end_comment

begin_define
define|#
directive|define
name|TAG_MSGSEND_FAST
value|"objc_msgSend_Fast"
end_define

begin_define
define|#
directive|define
name|TAG_ASSIGNIVAR_FAST
value|"objc_assign_ivar_Fast"
end_define

begin_define
define|#
directive|define
name|TAG_CXX_CONSTRUCT
value|".cxx_construct"
end_define

begin_define
define|#
directive|define
name|TAG_CXX_DESTRUCT
value|".cxx_destruct"
end_define

begin_comment
comment|/* GNU-specific tags.  */
end_comment

begin_define
define|#
directive|define
name|TAG_EXECCLASS
value|"__objc_exec_class"
end_define

begin_define
define|#
directive|define
name|TAG_GNUINIT
value|"__objc_gnu_init"
end_define

begin_comment
comment|/* Flags for lookup_method_static().  */
end_comment

begin_define
define|#
directive|define
name|OBJC_LOOKUP_CLASS
value|1
end_define

begin_comment
comment|/* Look for class methods.  */
end_comment

begin_define
define|#
directive|define
name|OBJC_LOOKUP_NO_SUPER
value|2
end_define

begin_comment
comment|/* Do not examine superclasses.  */
end_comment

begin_comment
comment|/* The OCTI_... enumeration itself is in objc/objc-act.h.  */
end_comment

begin_decl_stmt
name|tree
name|objc_global_trees
index|[
name|OCTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|handle_impent
parameter_list|(
name|struct
name|imp_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|imp_entry
modifier|*
name|imp_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|imp_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@implementation' */
end_comment

begin_decl_stmt
name|int
name|cat_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@category' */
end_comment

begin_decl_stmt
name|enum
name|tree_code
name|objc_inherit_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|objc_public_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use to generate method labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|method_slot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for error diagnostics */
end_comment

begin_comment
comment|/* Data imported from tree.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|enum
name|debug_info_type
name|write_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data imported from toplev.c.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|flag_typed_selectors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store all constructed constant strings in a hash table so that    they get uniqued properly.  */
end_comment

begin_decl_stmt
name|struct
name|string_descriptor
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The literal argument .  */
name|tree
name|literal
decl_stmt|;
comment|/* The resulting constant string.  */
name|tree
name|constructor
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct string_descriptor))
argument_list|)
name|htab_t
name|string_htab
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Store the EH-volatilized types in a hash table, for easy retrieval.  */
end_comment

begin_decl_stmt
name|struct
name|volatilized_type
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|type
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct volatilized_type))
argument_list|)
name|htab_t
name|volatilized_htab
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|gen_declaration_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tells "encode_pointer/encode_aggregate" whether we are generating    type descriptors for instance variables (as opposed to methods).    Type descriptors for instance variables contain more information    than methods (for static typing and embedded structures).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|generating_instance_variables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some platforms pass small structures through registers versus    through an invisible pointer.  Determine at what size structure is    the transition point between the two possibilities.  */
end_comment

begin_function
specifier|static
name|void
name|generate_struct_by_value_array
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|aggregate_in_mem
index|[
literal|32
index|]
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Presumably no platform passes 32 byte structures in a register.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|char
name|buffer
index|[
literal|5
index|]
decl_stmt|;
comment|/* Create an unnamed struct that has `i' character components */
name|type
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"c1"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|char_type_node
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"c%d"
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|char_type_node
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
name|finish_struct
argument_list|(
name|type
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|aggregate_in_mem
index|[
name|i
index|]
operator|=
name|aggregate_value_p
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aggregate_in_mem
index|[
name|i
index|]
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We found some structures that are returned in registers instead of memory      so output the necessary data.  */
if|if
condition|(
name|found
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|aggregate_in_mem
index|[
name|i
index|]
condition|)
break|break;
name|printf
argument_list|(
literal|"#define OBJC_MAX_STRUCT_BY_VALUE %d\n\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The first member of the structure is always 0 because we don't handle 	 structures with 0 members */
name|printf
argument_list|(
literal|"static int struct_forward_array[] = {\n  0"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|", %d"
argument_list|,
name|aggregate_in_mem
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n};\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|objc_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|cxx_init
argument_list|()
operator|==
name|false
condition|)
else|#
directive|else
if|if
condition|(
name|c_objc_common_init
argument_list|()
operator|==
name|false
condition|)
endif|#
directive|endif
return|return
name|false
return|;
ifndef|#
directive|ifndef
name|USE_MAPPED_LOCATION
comment|/* Force the line number back to 0; check_newline will have      raised it to 1, which will make the builtin functions appear      not to be built in.  */
name|input_line
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* If gen_declaration desired, open the output file.  */
if|if
condition|(
name|flag_gen_declaration
condition|)
block|{
specifier|register
name|char
modifier|*
specifier|const
name|dumpname
init|=
name|concat
argument_list|(
name|dump_base_name
argument_list|,
literal|".decl"
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|gen_declaration_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_declaration_file
operator|==
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't open %s: %m"
argument_list|,
name|dumpname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|TAG_GETCLASS
operator|=
literal|"objc_getClass"
expr_stmt|;
name|TAG_GETMETACLASS
operator|=
literal|"objc_getMetaClass"
expr_stmt|;
name|TAG_MSGSEND
operator|=
literal|"objc_msgSend"
expr_stmt|;
name|TAG_MSGSENDSUPER
operator|=
literal|"objc_msgSendSuper"
expr_stmt|;
name|TAG_MSGSEND_STRET
operator|=
literal|"objc_msgSend_stret"
expr_stmt|;
name|TAG_MSGSENDSUPER_STRET
operator|=
literal|"objc_msgSendSuper_stret"
expr_stmt|;
name|default_constant_string_class_name
operator|=
literal|"NSConstantString"
expr_stmt|;
block|}
else|else
block|{
name|TAG_GETCLASS
operator|=
literal|"objc_get_class"
expr_stmt|;
name|TAG_GETMETACLASS
operator|=
literal|"objc_get_meta_class"
expr_stmt|;
name|TAG_MSGSEND
operator|=
literal|"objc_msg_lookup"
expr_stmt|;
name|TAG_MSGSENDSUPER
operator|=
literal|"objc_msg_lookup_super"
expr_stmt|;
comment|/* GNU runtime does not provide special functions to support 	 structure-returning methods.  */
name|default_constant_string_class_name
operator|=
literal|"NXConstantString"
expr_stmt|;
name|flag_typed_selectors
operator|=
literal|1
expr_stmt|;
block|}
name|init_objc
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_struct_values
condition|)
name|generate_struct_by_value_array
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|objc_finish_file
parameter_list|(
name|void
parameter_list|)
block|{
name|mark_referenced_methods
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* We need to instantiate templates _before_ we emit ObjC metadata;      if we do not, some metadata (such as selectors) may go missing.  */
name|at_eof
operator|=
literal|1
expr_stmt|;
name|instantiate_pending_templates
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Finalize Objective-C runtime data.  No need to generate tables      and code if only checking syntax, or if generating a PCH file.  */
if|if
condition|(
operator|!
name|flag_syntax_only
operator|&&
operator|!
name|pch_file
condition|)
name|finish_objc
argument_list|()
expr_stmt|;
if|if
condition|(
name|gen_declaration_file
condition|)
name|fclose
argument_list|(
name|gen_declaration_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|cp_finish_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the first occurrence of a method declaration corresponding    to sel_name in rproto_list.  Search rproto_list recursively.    If is_class is 0, search for instance methods, otherwise for class    methods.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_method_in_protocol_list
parameter_list|(
name|tree
name|rproto_list
parameter_list|,
name|tree
name|sel_name
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|tree
name|rproto
decl_stmt|,
name|p
decl_stmt|;
name|tree
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
operator|(
name|fnd
operator|=
name|lookup_method
argument_list|(
name|is_class
condition|?
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
else|:
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|sel_name
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|fnd
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|,
name|sel_name
argument_list|,
name|is_class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
empty_stmt|;
comment|/* An identifier...if we could not find a protocol.  */
block|}
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_protocol_in_reflist
parameter_list|(
name|tree
name|rproto_list
parameter_list|,
name|tree
name|lproto
parameter_list|)
block|{
name|tree
name|rproto
decl_stmt|,
name|p
decl_stmt|;
comment|/* Make sure the protocol is supported by the object on the rhs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lproto
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|tree
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rproto
operator|=
name|rproto_list
init|;
name|rproto
condition|;
name|rproto
operator|=
name|TREE_CHAIN
argument_list|(
name|rproto
argument_list|)
control|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|rproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
name|lproto
operator|==
name|p
condition|)
name|fnd
operator|=
name|lproto
expr_stmt|;
elseif|else
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|fnd
operator|=
name|lookup_protocol_in_reflist
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|,
name|lproto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fnd
condition|)
return|return
name|fnd
return|;
block|}
block|}
else|else
block|{
empty_stmt|;
comment|/* An identifier...if we could not find a protocol.  */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|objc_start_class_interface
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|super_class
parameter_list|,
name|tree
name|protos
parameter_list|)
block|{
name|objc_interface_context
operator|=
name|objc_ivar_context
operator|=
name|start_class
argument_list|(
name|CLASS_INTERFACE_TYPE
argument_list|,
name|class
argument_list|,
name|super_class
argument_list|,
name|protos
argument_list|)
expr_stmt|;
name|objc_public_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_start_category_interface
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|categ
parameter_list|,
name|tree
name|protos
parameter_list|)
block|{
name|objc_interface_context
operator|=
name|start_class
argument_list|(
name|CATEGORY_INTERFACE_TYPE
argument_list|,
name|class
argument_list|,
name|categ
argument_list|,
name|protos
argument_list|)
expr_stmt|;
name|objc_ivar_chain
operator|=
name|continue_class
argument_list|(
name|objc_interface_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_start_protocol
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|protos
parameter_list|)
block|{
name|objc_interface_context
operator|=
name|start_protocol
argument_list|(
name|PROTOCOL_INTERFACE_TYPE
argument_list|,
name|name
argument_list|,
name|protos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_continue_interface
parameter_list|(
name|void
parameter_list|)
block|{
name|objc_ivar_chain
operator|=
name|continue_class
argument_list|(
name|objc_interface_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_finish_interface
parameter_list|(
name|void
parameter_list|)
block|{
name|finish_class
argument_list|(
name|objc_interface_context
argument_list|)
expr_stmt|;
name|objc_interface_context
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_start_class_implementation
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|super_class
parameter_list|)
block|{
name|objc_implementation_context
operator|=
name|objc_ivar_context
operator|=
name|start_class
argument_list|(
name|CLASS_IMPLEMENTATION_TYPE
argument_list|,
name|class
argument_list|,
name|super_class
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_public_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_start_category_implementation
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|categ
parameter_list|)
block|{
name|objc_implementation_context
operator|=
name|start_class
argument_list|(
name|CATEGORY_IMPLEMENTATION_TYPE
argument_list|,
name|class
argument_list|,
name|categ
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_ivar_chain
operator|=
name|continue_class
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_continue_implementation
parameter_list|(
name|void
parameter_list|)
block|{
name|objc_ivar_chain
operator|=
name|continue_class
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_finish_implementation
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|flag_objc_call_cxx_cdtors
condition|)
name|objc_generate_cxx_cdtors
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|objc_implementation_context
condition|)
block|{
name|finish_class
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
name|objc_ivar_chain
operator|=
name|NULL_TREE
expr_stmt|;
name|objc_implementation_context
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<@end%> must appear in an @implementation context"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_set_visibility
parameter_list|(
name|int
name|visibility
parameter_list|)
block|{
name|objc_public_flag
operator|=
name|visibility
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_set_method_type
parameter_list|(
name|enum
name|tree_code
name|type
parameter_list|)
block|{
name|objc_inherit_code
operator|=
operator|(
name|type
operator|==
name|PLUS_EXPR
condition|?
name|CLASS_METHOD_DECL
else|:
name|INSTANCE_METHOD_DECL
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|objc_build_method_signature
parameter_list|(
name|tree
name|rettype
parameter_list|,
name|tree
name|selector
parameter_list|,
name|tree
name|optparms
parameter_list|,
name|bool
name|ellipsis
parameter_list|)
block|{
return|return
name|build_method_decl
argument_list|(
name|objc_inherit_code
argument_list|,
name|rettype
argument_list|,
name|selector
argument_list|,
name|optparms
argument_list|,
name|ellipsis
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|objc_add_method_declaration
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|objc_interface_context
condition|)
name|fatal_error
argument_list|(
literal|"method declaration not in @interface context"
argument_list|)
expr_stmt|;
name|objc_add_method
argument_list|(
name|objc_interface_context
argument_list|,
name|decl
argument_list|,
name|objc_inherit_code
operator|==
name|CLASS_METHOD_DECL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_start_method_definition
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|objc_implementation_context
condition|)
name|fatal_error
argument_list|(
literal|"method definition not in @implementation context"
argument_list|)
expr_stmt|;
name|objc_add_method
argument_list|(
name|objc_implementation_context
argument_list|,
name|decl
argument_list|,
name|objc_inherit_code
operator|==
name|CLASS_METHOD_DECL
argument_list|)
expr_stmt|;
name|start_method_def
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_add_instance_variable
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
operator|(
name|void
operator|)
name|add_instance_variable
argument_list|(
name|objc_ivar_context
argument_list|,
name|objc_public_flag
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if IDENT is an ObjC/ObjC++ reserved keyword in the context of    an '@'.  */
end_comment

begin_function
name|int
name|objc_is_reserved_word
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|unsigned
name|char
name|code
init|=
name|C_RID_CODE
argument_list|(
name|ident
argument_list|)
decl_stmt|;
return|return
operator|(
name|OBJC_IS_AT_KEYWORD
argument_list|(
name|code
argument_list|)
ifdef|#
directive|ifdef
name|OBJCPLUS
operator|||
name|code
operator|==
name|RID_CLASS
operator|||
name|code
operator|==
name|RID_PUBLIC
operator|||
name|code
operator|==
name|RID_PROTECTED
operator|||
name|code
operator|==
name|RID_PRIVATE
operator|||
name|code
operator|==
name|RID_TRY
operator|||
name|code
operator|==
name|RID_THROW
operator|||
name|code
operator|==
name|RID_CATCH
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE is 'id'.  */
end_comment

begin_function
specifier|static
name|bool
name|objc_is_object_id
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|OBJC_TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|objc_object_id
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|objc_is_class_id
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|OBJC_TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|objc_class_id
return|;
block|}
end_function

begin_comment
comment|/* Construct a C struct with same name as CLASS, a base struct with tag    SUPER_NAME (if any), and FIELDS indicated.  */
end_comment

begin_function
specifier|static
name|tree
name|objc_build_struct
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|fields
parameter_list|,
name|tree
name|super_name
parameter_list|)
block|{
name|tree
name|name
init|=
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
decl_stmt|;
name|tree
name|s
init|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|tree
name|super
init|=
operator|(
name|super_name
condition|?
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|super_name
argument_list|)
else|:
name|NULL_TREE
operator|)
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|objc_info
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|super
condition|)
block|{
comment|/* Prepend a packed variant of the base class into the layout.  This 	 is necessary to preserve ObjC ABI compatibility.  */
name|tree
name|base
init|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|super
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|super
argument_list|)
decl_stmt|;
while|while
condition|(
name|field
operator|&&
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* For ObjC ABI purposes, the "packed" size of a base class is the 	 the sum of the offset and the size (in bits) of the last field 	 in the class.  */
name|DECL_SIZE
argument_list|(
name|base
argument_list|)
operator|=
operator|(
name|field
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|?
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
else|:
name|bitsize_zero_node
operator|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|base
argument_list|)
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|DECL_SIZE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|base
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|base
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|base
argument_list|)
operator|=
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|DECL_FIELD_IS_BASE
argument_list|(
name|base
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fields
condition|)
name|TREE_NO_WARNING
argument_list|(
name|fields
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Suppress C++ ABI warnings -- we   */
endif|#
directive|endif
comment|/* are following the ObjC ABI here.  */
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|base
expr_stmt|;
block|}
comment|/* NB: Calling finish_struct() may cause type TYPE_LANG_SPECIFIC fields      in all variants of this RECORD_TYPE to be clobbered, but it is therein      that we store protocol conformance info (e.g., 'NSObject<MyProtocol>').      Hence, we must squirrel away the ObjC-specific information before calling      finish_struct(), and then reinstate it afterwards.  */
for|for
control|(
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|s
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
name|objc_info
operator|=
name|chainon
argument_list|(
name|objc_info
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_OBJC_INFO
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Point the struct at its related Objective-C class.  */
name|INIT_TYPE_OBJC_INFO
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TYPE_OBJC_INTERFACE
argument_list|(
name|s
argument_list|)
operator|=
name|class
expr_stmt|;
name|s
operator|=
name|finish_struct
argument_list|(
name|s
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|s
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|,
name|objc_info
operator|=
name|TREE_CHAIN
argument_list|(
name|objc_info
argument_list|)
control|)
block|{
name|TYPE_OBJC_INFO
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|objc_info
argument_list|)
expr_stmt|;
comment|/* Replace the IDENTIFIER_NODE with an actual @interface.  */
name|TYPE_OBJC_INTERFACE
argument_list|(
name|t
argument_list|)
operator|=
name|class
expr_stmt|;
block|}
comment|/* Use TYPE_BINFO structures to point at the super class, if any.  */
name|objc_xref_basetypes
argument_list|(
name|s
argument_list|,
name|super
argument_list|)
expr_stmt|;
comment|/* Mark this struct as a class template.  */
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Build a type differing from TYPE only in that TYPE_VOLATILE is set.    Unlike tree.c:build_qualified_type(), preserve TYPE_LANG_SPECIFIC in the    process.  */
end_comment

begin_function
specifier|static
name|tree
name|objc_build_volatilized_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Check if we have not constructed the desired variant already.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
block|{
comment|/* The type qualifiers must (obviously) match up.  */
if|if
condition|(
operator|!
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_RESTRICT
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_RESTRICT
argument_list|(
name|type
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* For pointer types, the pointees (and hence their TYPE_LANG_SPECIFIC 	 info, if any) must match up.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Everything matches up!  */
return|return
name|t
return|;
block|}
comment|/* Ok, we could not re-use any of the pre-existing variants.  Create      a new one.  */
name|t
operator|=
name|build_variant_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Mark DECL as being 'volatile' for purposes of Darwin    _setjmp()/_longjmp() exception handling.  Called from    objc_mark_locals_volatile().  */
end_comment

begin_function
name|void
name|objc_volatilize_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Do not mess with variables that are 'static' or (already)      'volatile'.  */
if|if
condition|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|struct
name|volatilized_type
name|key
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|t
operator|=
name|objc_build_volatilized_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|key
operator|.
name|type
operator|=
name|t
expr_stmt|;
name|loc
operator|=
name|htab_find_slot
argument_list|(
name|volatilized_htab
argument_list|,
operator|&
name|key
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
block|{
operator|*
name|loc
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|volatilized_type
operator|*
operator|)
operator|*
name|loc
operator|)
operator|->
name|type
operator|=
name|t
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJCPLUS
name|C_DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Check if protocol PROTO is adopted (directly or indirectly) by class CLS    (including its categoreis and superclasses) or by object type TYP.    Issue a warning if PROTO is not adopted anywhere and WARN is set.  */
end_comment

begin_function
specifier|static
name|bool
name|objc_lookup_protocol
parameter_list|(
name|tree
name|proto
parameter_list|,
name|tree
name|cls
parameter_list|,
name|tree
name|typ
parameter_list|,
name|bool
name|warn
parameter_list|)
block|{
name|bool
name|class_type
init|=
operator|(
name|cls
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
while|while
condition|(
name|cls
condition|)
block|{
name|tree
name|c
decl_stmt|;
comment|/* Check protocols adopted by the class and its categories.  */
for|for
control|(
name|c
operator|=
name|cls
init|;
name|c
condition|;
name|c
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|c
argument_list|)
control|)
block|{
if|if
condition|(
name|lookup_protocol_in_reflist
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|c
argument_list|)
argument_list|,
name|proto
argument_list|)
condition|)
return|return
name|true
return|;
block|}
comment|/* Repeat for superclasses.  */
name|cls
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|cls
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for any protocols attached directly to the object type.  */
if|if
condition|(
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|typ
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_protocol_in_reflist
argument_list|(
name|TYPE_OBJC_PROTOCOL_LIST
argument_list|(
name|typ
argument_list|)
argument_list|,
name|proto
argument_list|)
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|warn
condition|)
block|{
name|strcpy
argument_list|(
name|errbuf
argument_list|,
name|class_type
condition|?
literal|"class \'"
else|:
literal|"type \'"
argument_list|)
expr_stmt|;
name|gen_type_name_0
argument_list|(
name|class_type
condition|?
name|typ
else|:
name|TYPE_POINTER_TO
argument_list|(
name|typ
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errbuf
argument_list|,
literal|"\' does not "
argument_list|)
expr_stmt|;
comment|/* NB: Types 'id' and 'Class' cannot reasonably be described as 	 "implementing" a given protocol, since they do not have an 	 implementation.  */
name|strcat
argument_list|(
name|errbuf
argument_list|,
name|class_type
condition|?
literal|"implement"
else|:
literal|"conform to"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errbuf
argument_list|,
literal|" the \'"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errbuf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|proto
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|errbuf
argument_list|,
literal|"\' protocol"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check if class RCLS and instance struct type RTYP conform to at least the    same protocols that LCLS and LTYP conform to.  */
end_comment

begin_function
specifier|static
name|bool
name|objc_compare_protocols
parameter_list|(
name|tree
name|lcls
parameter_list|,
name|tree
name|ltyp
parameter_list|,
name|tree
name|rcls
parameter_list|,
name|tree
name|rtyp
parameter_list|,
name|bool
name|warn
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
name|bool
name|have_lproto
init|=
name|false
decl_stmt|;
while|while
condition|(
name|lcls
condition|)
block|{
comment|/* NB: We do _not_ look at categories defined for LCLS; these may or 	 may not get loaded in, and therefore it is unreasonable to require 	 that RCLS/RTYP must implement any of their protocols.  */
for|for
control|(
name|p
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|lcls
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|have_lproto
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|objc_lookup_protocol
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|,
name|rcls
argument_list|,
name|rtyp
argument_list|,
name|warn
argument_list|)
condition|)
return|return
name|warn
return|;
block|}
comment|/* Repeat for superclasses.  */
name|lcls
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|lcls
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for any protocols attached directly to the object type.  */
if|if
condition|(
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|ltyp
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|TYPE_OBJC_PROTOCOL_LIST
argument_list|(
name|ltyp
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|have_lproto
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|objc_lookup_protocol
argument_list|(
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
argument_list|,
name|rcls
argument_list|,
name|rtyp
argument_list|,
name|warn
argument_list|)
condition|)
return|return
name|warn
return|;
block|}
block|}
comment|/* NB: If LTYP and LCLS have no protocols to search for, return 'true'      vacuously, _unless_ RTYP is a protocol-qualified 'id'.  We can get      away with simply checking for 'id' or 'Class' (!RCLS), since this      routine will not get called in other cases.  */
return|return
name|have_lproto
operator|||
operator|(
name|rcls
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if it is permissible to assign (if ARGNO is greater than -3)    an instance of RTYP to an instance of LTYP or to compare the two    (if ARGNO is equal to -3), per ObjC type system rules.  Before    returning 'true', this routine may issue warnings related to, e.g.,    protocol conformance.  When returning 'false', the routine must    produce absolutely no warnings; the C or C++ front-end will do so    instead, if needed.  If either LTYP or RTYP is not an Objective-C type,    the routine must return 'false'.     The ARGNO parameter is encoded as follows:>= 1	Parameter number (CALLEE contains function being called);      0		Return value;      -1		Assignment;      -2		Initialization;      -3		Comparison (LTYP and RTYP may match in either direction).  */
end_comment

begin_function
name|bool
name|objc_compare_types
parameter_list|(
name|tree
name|ltyp
parameter_list|,
name|tree
name|rtyp
parameter_list|,
name|int
name|argno
parameter_list|,
name|tree
name|callee
parameter_list|)
block|{
name|tree
name|lcls
decl_stmt|,
name|rcls
decl_stmt|,
name|lproto
decl_stmt|,
name|rproto
decl_stmt|;
name|bool
name|pointers_compatible
decl_stmt|;
comment|/* We must be dealing with pointer types */
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|ltyp
argument_list|)
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|rtyp
argument_list|)
condition|)
return|return
name|false
return|;
do|do
block|{
name|ltyp
operator|=
name|TREE_TYPE
argument_list|(
name|ltyp
argument_list|)
expr_stmt|;
comment|/* Remove indirections.  */
name|rtyp
operator|=
name|TREE_TYPE
argument_list|(
name|rtyp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|ltyp
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|rtyp
argument_list|)
condition|)
do|;
comment|/* Past this point, we are only interested in ObjC class instances,      or 'id' or 'Class'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ltyp
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|rtyp
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|objc_is_object_id
argument_list|(
name|ltyp
argument_list|)
operator|&&
operator|!
name|objc_is_class_id
argument_list|(
name|ltyp
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|ltyp
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|objc_is_object_id
argument_list|(
name|rtyp
argument_list|)
operator|&&
operator|!
name|objc_is_class_id
argument_list|(
name|rtyp
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|rtyp
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Past this point, we are committed to returning 'true' to the caller.      However, we can still warn about type and/or protocol mismatches.  */
if|if
condition|(
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|ltyp
argument_list|)
condition|)
block|{
name|lcls
operator|=
name|TYPE_OBJC_INTERFACE
argument_list|(
name|ltyp
argument_list|)
expr_stmt|;
name|lproto
operator|=
name|TYPE_OBJC_PROTOCOL_LIST
argument_list|(
name|ltyp
argument_list|)
expr_stmt|;
block|}
else|else
name|lcls
operator|=
name|lproto
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|rtyp
argument_list|)
condition|)
block|{
name|rcls
operator|=
name|TYPE_OBJC_INTERFACE
argument_list|(
name|rtyp
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|TYPE_OBJC_PROTOCOL_LIST
argument_list|(
name|rtyp
argument_list|)
expr_stmt|;
block|}
else|else
name|rcls
operator|=
name|rproto
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If we could not find an @interface declaration, we must have      only seen a @class declaration; for purposes of type comparison,      treat it as a stand-alone (root) class.  */
if|if
condition|(
name|lcls
operator|&&
name|TREE_CODE
argument_list|(
name|lcls
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|lcls
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|rcls
operator|&&
name|TREE_CODE
argument_list|(
name|rcls
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|rcls
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If either type is an unqualified 'id', we're done.  */
if|if
condition|(
operator|(
operator|!
name|lproto
operator|&&
name|objc_is_object_id
argument_list|(
name|ltyp
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|rproto
operator|&&
name|objc_is_object_id
argument_list|(
name|rtyp
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
name|pointers_compatible
operator|=
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ltyp
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rtyp
argument_list|)
operator|)
expr_stmt|;
comment|/* If the underlying types are the same, and at most one of them has      a protocol list, we do not need to issue any diagnostics.  */
if|if
condition|(
name|pointers_compatible
operator|&&
operator|(
operator|!
name|lproto
operator|||
operator|!
name|rproto
operator|)
condition|)
return|return
name|true
return|;
comment|/* If exactly one of the types is 'Class', issue a diagnostic; any      exceptions of this rule have already been handled.  */
if|if
condition|(
name|objc_is_class_id
argument_list|(
name|ltyp
argument_list|)
operator|^
name|objc_is_class_id
argument_list|(
name|rtyp
argument_list|)
condition|)
name|pointers_compatible
operator|=
name|false
expr_stmt|;
comment|/* Otherwise, check for inheritance relations.  */
else|else
block|{
if|if
condition|(
operator|!
name|pointers_compatible
condition|)
name|pointers_compatible
operator|=
operator|(
name|objc_is_object_id
argument_list|(
name|ltyp
argument_list|)
operator|||
name|objc_is_object_id
argument_list|(
name|rtyp
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|pointers_compatible
condition|)
name|pointers_compatible
operator|=
name|DERIVED_FROM_P
argument_list|(
name|ltyp
argument_list|,
name|rtyp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pointers_compatible
operator|&&
name|argno
operator|==
operator|-
literal|3
condition|)
name|pointers_compatible
operator|=
name|DERIVED_FROM_P
argument_list|(
name|rtyp
argument_list|,
name|ltyp
argument_list|)
expr_stmt|;
block|}
comment|/* If the pointers match modulo protocols, check for protocol conformance      mismatches.  */
if|if
condition|(
name|pointers_compatible
condition|)
block|{
name|pointers_compatible
operator|=
name|objc_compare_protocols
argument_list|(
name|lcls
argument_list|,
name|ltyp
argument_list|,
name|rcls
argument_list|,
name|rtyp
argument_list|,
name|argno
operator|!=
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pointers_compatible
operator|&&
name|argno
operator|==
operator|-
literal|3
condition|)
name|pointers_compatible
operator|=
name|objc_compare_protocols
argument_list|(
name|rcls
argument_list|,
name|rtyp
argument_list|,
name|lcls
argument_list|,
name|ltyp
argument_list|,
name|argno
operator|!=
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pointers_compatible
condition|)
block|{
comment|/* NB: For the time being, we shall make our warnings look like their 	 C counterparts.  In the future, we may wish to make them more 	 ObjC-specific.  */
switch|switch
condition|(
name|argno
condition|)
block|{
case|case
operator|-
literal|3
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison of distinct Objective-C types lacks a cast"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"initialization from distinct Objective-C type"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"assignment from distinct Objective-C type"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"distinct Objective-C type in return"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing argument %d of %qE from distinct "
literal|"Objective-C type"
argument_list|,
name|argno
argument_list|,
name|callee
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check if LTYP and RTYP have the same type qualifiers.  If either type    lives in the volatilized hash table, ignore the 'volatile' bit when    making the comparison.  */
end_comment

begin_function
name|bool
name|objc_type_quals_match
parameter_list|(
name|tree
name|ltyp
parameter_list|,
name|tree
name|rtyp
parameter_list|)
block|{
name|int
name|lquals
init|=
name|TYPE_QUALS
argument_list|(
name|ltyp
argument_list|)
decl_stmt|,
name|rquals
init|=
name|TYPE_QUALS
argument_list|(
name|rtyp
argument_list|)
decl_stmt|;
name|struct
name|volatilized_type
name|key
decl_stmt|;
name|key
operator|.
name|type
operator|=
name|ltyp
expr_stmt|;
if|if
condition|(
name|htab_find_slot
argument_list|(
name|volatilized_htab
argument_list|,
operator|&
name|key
argument_list|,
name|NO_INSERT
argument_list|)
condition|)
name|lquals
operator|&=
operator|~
name|TYPE_QUAL_VOLATILE
expr_stmt|;
name|key
operator|.
name|type
operator|=
name|rtyp
expr_stmt|;
if|if
condition|(
name|htab_find_slot
argument_list|(
name|volatilized_htab
argument_list|,
operator|&
name|key
argument_list|,
name|NO_INSERT
argument_list|)
condition|)
name|rquals
operator|&=
operator|~
name|TYPE_QUAL_VOLATILE
expr_stmt|;
return|return
operator|(
name|lquals
operator|==
name|rquals
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OBJCPLUS
end_ifndef

begin_comment
comment|/* Determine if CHILD is derived from PARENT.  The routine assumes that    both parameters are RECORD_TYPEs, and is non-reflexive.  */
end_comment

begin_function
specifier|static
name|bool
name|objc_derived_from_p
parameter_list|(
name|tree
name|parent
parameter_list|,
name|tree
name|child
parameter_list|)
block|{
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
for|for
control|(
name|child
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|child
argument_list|)
init|;
name|TYPE_BINFO
argument_list|(
name|child
argument_list|)
operator|&&
name|BINFO_N_BASE_BINFOS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|child
argument_list|)
argument_list|)
condition|;
control|)
block|{
name|child
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASE_BINFO
argument_list|(
name|TYPE_BINFO
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|parent
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|tree
name|objc_build_component_ref
parameter_list|(
name|tree
name|datum
parameter_list|,
name|tree
name|component
parameter_list|)
block|{
comment|/* If COMPONENT is NULL, the caller is referring to the anonymous      base class field.  */
if|if
condition|(
operator|!
name|component
condition|)
block|{
name|tree
name|base
init|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|datum
argument_list|,
name|base
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
comment|/* The 'build_component_ref' routine has been removed from the C++      front-end, but 'finish_class_member_access_expr' seems to be      a worthy substitute.  */
ifdef|#
directive|ifdef
name|OBJCPLUS
return|return
name|finish_class_member_access_expr
argument_list|(
name|datum
argument_list|,
name|component
argument_list|,
name|false
argument_list|)
return|;
else|#
directive|else
return|return
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|component
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Recursively copy inheritance information rooted at BINFO.  To do this,    we emulate the song and dance performed by cp/tree.c:copy_binfo().  */
end_comment

begin_function
specifier|static
name|tree
name|objc_copy_binfo
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|btype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|binfo2
init|=
name|make_tree_binfo
argument_list|(
name|BINFO_N_BASE_BINFOS
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|BINFO_TYPE
argument_list|(
name|binfo2
argument_list|)
operator|=
name|btype
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|binfo2
argument_list|)
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo2
argument_list|)
operator|=
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Recursively copy base binfos of BINFO.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|base_binfo2
init|=
name|objc_copy_binfo
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo2
argument_list|)
operator|=
name|binfo2
expr_stmt|;
name|BINFO_BASE_APPEND
argument_list|(
name|binfo2
argument_list|,
name|base_binfo2
argument_list|)
expr_stmt|;
block|}
return|return
name|binfo2
return|;
block|}
end_function

begin_comment
comment|/* Record superclass information provided in BASETYPE for ObjC class REF.    This is loosely based on cp/decl.c:xref_basetypes().  */
end_comment

begin_function
specifier|static
name|void
name|objc_xref_basetypes
parameter_list|(
name|tree
name|ref
parameter_list|,
name|tree
name|basetype
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|make_tree_binfo
argument_list|(
name|basetype
condition|?
literal|1
else|:
literal|0
argument_list|)
decl_stmt|;
name|TYPE_BINFO
argument_list|(
name|ref
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|=
name|ref
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
block|{
name|tree
name|base_binfo
init|=
name|objc_copy_binfo
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|)
decl_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BINFO_BASE_APPEND
argument_list|(
name|binfo
argument_list|,
name|base_binfo
argument_list|)
expr_stmt|;
name|BINFO_BASE_ACCESS_APPEND
argument_list|(
name|binfo
argument_list|,
name|access_public_node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|volatilized_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|tree
name|typ
init|=
operator|(
operator|(
expr|struct
name|volatilized_type
operator|*
operator|)
name|ptr
operator|)
operator|->
name|type
decl_stmt|;
return|return
name|htab_hash_pointer
argument_list|(
name|typ
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|volatilized_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr1
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr2
parameter_list|)
block|{
name|tree
name|typ1
init|=
operator|(
operator|(
expr|struct
name|volatilized_type
operator|*
operator|)
name|ptr1
operator|)
operator|->
name|type
decl_stmt|;
name|tree
name|typ2
init|=
operator|(
operator|(
expr|struct
name|volatilized_type
operator|*
operator|)
name|ptr2
operator|)
operator|->
name|type
decl_stmt|;
return|return
name|typ1
operator|==
name|typ2
return|;
block|}
end_function

begin_comment
comment|/* Called from finish_decl.  */
end_comment

begin_function
name|void
name|objc_check_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return;
if|if
condition|(
name|OBJC_TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|type
operator|=
name|objc_is_class_name
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"statically allocated instance of Objective-C class %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct a PROTOCOLS-qualified variant of INTERFACE, where INTERFACE may    either name an Objective-C class, or refer to the special 'id' or 'Class'    types.  If INTERFACE is not a valid ObjC type, just return it unchanged.  */
end_comment

begin_function
name|tree
name|objc_get_protocol_qualified_type
parameter_list|(
name|tree
name|interface
parameter_list|,
name|tree
name|protocols
parameter_list|)
block|{
comment|/* If INTERFACE is not provided, default to 'id'.  */
name|tree
name|type
init|=
operator|(
name|interface
condition|?
name|objc_is_id
argument_list|(
name|interface
argument_list|)
else|:
name|objc_object_type
operator|)
decl_stmt|;
name|bool
name|is_ptr
init|=
operator|(
name|type
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_ptr
condition|)
block|{
name|type
operator|=
name|objc_is_class_name
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|type
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
return|return
name|interface
return|;
block|}
if|if
condition|(
name|protocols
condition|)
block|{
name|type
operator|=
name|build_variant_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* For pointers (i.e., 'id' or 'Class'), attach the protocol(s) 	 to the pointee.  */
if|if
condition|(
name|is_ptr
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|build_variant_type_copy
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Look up protocols and install in lang specific list.  */
name|DUP_TYPE_OBJC_INFO
argument_list|(
name|type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_OBJC_PROTOCOL_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|lookup_and_install_protocols
argument_list|(
name|protocols
argument_list|)
expr_stmt|;
comment|/* For RECORD_TYPEs, point to the @interface; for 'id' and 'Class', 	 return the pointer to the new pointee variant.  */
if|if
condition|(
name|is_ptr
condition|)
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|TYPE_OBJC_INTERFACE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OBJC_INTERFACE
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Check for circular dependencies in protocols.  The arguments are    PROTO, the protocol to check, and LIST, a list of protocol it    conforms to.  */
end_comment

begin_function
specifier|static
name|void
name|check_protocol_recursively
parameter_list|(
name|tree
name|proto
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|pp
init|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pp
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|pp
operator|=
name|lookup_protocol
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|proto
condition|)
name|fatal_error
argument_list|(
literal|"protocol %qs has circular dependency"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|pp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
name|check_protocol_recursively
argument_list|(
name|proto
argument_list|,
name|PROTOCOL_LIST
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look up PROTOCOLS, and return a list of those that are found.    If none are found, return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_and_install_protocols
parameter_list|(
name|tree
name|protocols
parameter_list|)
block|{
name|tree
name|proto
decl_stmt|;
name|tree
name|return_value
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|proto
operator|=
name|protocols
init|;
name|proto
condition|;
name|proto
operator|=
name|TREE_CHAIN
argument_list|(
name|proto
argument_list|)
control|)
block|{
name|tree
name|ident
init|=
name|TREE_VALUE
argument_list|(
name|proto
argument_list|)
decl_stmt|;
name|tree
name|p
init|=
name|lookup_protocol
argument_list|(
name|ident
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|return_value
operator|=
name|chainon
argument_list|(
name|return_value
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ident
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"cannot find protocol declaration for %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* Create a declaration for field NAME of a given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|create_field_decl
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a global, static declaration for variable NAME of a given TYPE.  The    finish_var_decl() routine will need to be called on it afterwards.  */
end_comment

begin_function
specifier|static
name|tree
name|start_var_decl
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|tree
name|var
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* A real initializer is coming... */
name|DECL_IGNORED_P
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|DECL_THIS_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* squash redeclaration errors */
endif|#
directive|endif
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Finish off the variable declaration created by start_var_decl().  */
end_comment

begin_function
specifier|static
name|void
name|finish_var_decl
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|initializer
parameter_list|)
block|{
name|finish_decl
argument_list|(
name|var
argument_list|,
name|initializer
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Ensure that the variable actually gets output.  */
name|mark_decl_referenced
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Mark the decl to avoid "defined but not used" warning.  */
name|TREE_USED
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the decl for the constant string class reference.  This is only    used for the NeXT runtime.  */
end_comment

begin_function
specifier|static
name|tree
name|setup_string_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* %s in format will provide room for terminating null */
name|length
operator|=
name|strlen
argument_list|(
name|STRING_OBJECT_GLOBAL_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|constant_string_class_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|STRING_OBJECT_GLOBAL_FORMAT
argument_list|,
name|constant_string_class_name
argument_list|)
expr_stmt|;
name|constant_string_global_id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string_class_decl
operator|=
name|lookup_name
argument_list|(
name|constant_string_global_id
argument_list|)
expr_stmt|;
return|return
name|string_class_decl
return|;
block|}
end_function

begin_comment
comment|/* Purpose: "play" parser, creating/installing representations    of the declarations that are required by Objective-C.     Model:  	type_spec--------->sc_spec 	(tree_list)        (tree_list) 	    |                  | 	    |                  | 	identifier_node    identifier_node  */
end_comment

begin_function
specifier|static
name|void
name|synth_module_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|enum
name|debug_info_type
name|save_write_symbols
init|=
name|write_symbols
decl_stmt|;
specifier|const
name|struct
name|gcc_debug_hooks
modifier|*
specifier|const
name|save_hooks
init|=
name|debug_hooks
decl_stmt|;
comment|/* Suppress outputting debug symbols, because      dbxout_init hasn'r been called yet.  */
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* extern "C" */
endif|#
directive|endif
comment|/* The following are also defined in<objc/objc.h> and friends.  */
name|objc_object_id
operator|=
name|get_identifier
argument_list|(
name|TAG_OBJECT
argument_list|)
expr_stmt|;
name|objc_class_id
operator|=
name|get_identifier
argument_list|(
name|TAG_CLASS
argument_list|)
expr_stmt|;
name|objc_object_reference
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_object_id
argument_list|)
expr_stmt|;
name|objc_class_reference
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_class_id
argument_list|)
expr_stmt|;
name|objc_object_type
operator|=
name|build_pointer_type
argument_list|(
name|objc_object_reference
argument_list|)
expr_stmt|;
name|objc_class_type
operator|=
name|build_pointer_type
argument_list|(
name|objc_class_reference
argument_list|)
expr_stmt|;
name|objc_object_name
operator|=
name|get_identifier
argument_list|(
name|OBJECT_TYPEDEF_NAME
argument_list|)
expr_stmt|;
name|objc_class_name
operator|=
name|get_identifier
argument_list|(
name|CLASS_TYPEDEF_NAME
argument_list|)
expr_stmt|;
comment|/* Declare the 'id' and 'Class' typedefs.  */
name|type
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|objc_object_name
argument_list|,
name|objc_object_type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|objc_class_name
argument_list|,
name|objc_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Forward-declare '@interface Protocol'.  */
name|type
operator|=
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
expr_stmt|;
name|objc_declare_class
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|objc_protocol_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Declare type of selector-objects that represent an operation name.  */
if|if
condition|(
name|flag_next_runtime
condition|)
comment|/* `struct objc_selector *' */
name|objc_selector_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* `const struct objc_selector *' */
name|objc_selector_type
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Declare receiver type used for dispatching messages to 'super'.  */
comment|/* `struct objc_super *' */
name|objc_super_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SUPER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Declare pointers to method and ivar lists.  */
name|objc_method_list_ptr
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_method_proto_list_ptr
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_ivar_list_ptr
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_IVAR_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TREE_NOTHROW is cleared for the message-sending functions,      because the function that gets called can throw in Obj-C++, or      could itself call something that can throw even in Obj-C.  */
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* NB: In order to call one of the ..._stret (struct-returning)       functions, the function *MUST* first be cast to a signature that       corresponds to the actual ObjC method being invoked.  This is       what is done by the build_objc_method_call() routine below.  */
comment|/* id objc_msgSend (id, SEL, ...); */
comment|/* id objc_msgSendNonNil (id, SEL, ...); */
comment|/* id objc_msgSend_stret (id, SEL, ...); */
comment|/* id objc_msgSendNonNil_stret (id, SEL, ...); */
name|type
operator|=
name|build_function_type
argument_list|(
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|umsg_nonnil_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND_NONNIL
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|umsg_stret_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND_STRET
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|umsg_nonnil_stret_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND_NONNIL_STRET
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* These can throw, because the function that gets called can throw 	 in Obj-C++, or could itself call something that can throw even 	 in Obj-C.  */
name|TREE_NOTHROW
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_nonnil_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_stret_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_nonnil_stret_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* id objc_msgSend_Fast (id, SEL, ...) 	   __attribute__ ((hard_coded_address (OFFS_MSGSEND_FAST))); */
ifdef|#
directive|ifdef
name|OFFS_MSGSEND_FAST
name|umsg_fast_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND_FAST
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_fast_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ATTRIBUTES
argument_list|(
name|umsg_fast_decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"hard_coded_address"
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|OFFS_MSGSEND_FAST
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* No direct dispatch availible.  */
name|umsg_fast_decl
operator|=
name|umsg_decl
expr_stmt|;
endif|#
directive|endif
comment|/* id objc_msgSendSuper (struct objc_super *, SEL, ...); */
comment|/* id objc_msgSendSuper_stret (struct objc_super *, SEL, ...); */
name|type
operator|=
name|build_function_type
argument_list|(
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_super_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_super_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSENDSUPER
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|umsg_super_stret_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSENDSUPER_STRET
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_super_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_super_stret_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* GNU runtime messenger entry points.  */
comment|/* typedef id (*IMP)(id, SEL, ...); */
name|tree
name|IMP_type
init|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_selector_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* IMP objc_msg_lookup (id, SEL); */
name|type
operator|=
name|build_function_type
argument_list|(
name|IMP_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_selector_type
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSEND
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* IMP objc_msg_lookup_super (struct objc_super *, SEL); */
name|type
operator|=
name|build_function_type
argument_list|(
name|IMP_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_super_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_selector_type
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|umsg_super_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_MSGSENDSUPER
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|umsg_super_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The following GNU runtime entry point is called to initialize 	 each module:  	 __objc_exec_class (void *); */
name|type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|execclass_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXECCLASS
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* id objc_getClass (const char *); */
name|type
operator|=
name|build_function_type
argument_list|(
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_get_class_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_GETCLASS
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* id objc_getMetaClass (const char *); */
name|objc_get_meta_class_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_GETMETACLASS
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|build_class_template
argument_list|()
expr_stmt|;
name|build_super_template
argument_list|()
expr_stmt|;
name|build_protocol_template
argument_list|()
expr_stmt|;
name|build_category_template
argument_list|()
expr_stmt|;
name|build_objc_exception_stuff
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
name|build_next_objc_exception_stuff
argument_list|()
expr_stmt|;
comment|/* static SEL _OBJC_SELECTOR_TABLE[]; */
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
name|build_selector_table_decl
argument_list|()
expr_stmt|;
comment|/* Forward declare constant_string_id and constant_string_type.  */
if|if
condition|(
operator|!
name|constant_string_class_name
condition|)
name|constant_string_class_name
operator|=
name|default_constant_string_class_name
expr_stmt|;
name|constant_string_id
operator|=
name|get_identifier
argument_list|(
name|constant_string_class_name
argument_list|)
expr_stmt|;
name|objc_declare_class
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|constant_string_id
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pre-build the following entities - for speed/convenience.  */
name|self_id
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
name|ucmd_id
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|pop_lang_context
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|write_symbols
operator|=
name|save_write_symbols
expr_stmt|;
name|debug_hooks
operator|=
name|save_hooks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure that the ivar list for NSConstantString/NXConstantString    (or whatever was specified via `-fconstant-string-class')    contains fields at least as large as the following three, so that    the runtime can stomp on them with confidence:     struct STRING_OBJECT_CLASS_NAME    {      Object isa;      char *cString;      unsigned int length;    }; */
end_comment

begin_function
specifier|static
name|int
name|check_string_class_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
init|=
name|objc_get_class_ivars
argument_list|(
name|constant_string_id
argument_list|)
decl_stmt|;
define|#
directive|define
name|AT_LEAST_AS_LARGE_AS
parameter_list|(
name|F
parameter_list|,
name|T
parameter_list|)
define|\
value|(F&& TREE_CODE (F) == FIELD_DECL \&& (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (F))) \>= TREE_INT_CST_LOW (TYPE_SIZE (T))))
if|if
condition|(
operator|!
name|AT_LEAST_AS_LARGE_AS
argument_list|(
name|field_decl
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AT_LEAST_AS_LARGE_AS
argument_list|(
name|field_decl
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
return|return
name|AT_LEAST_AS_LARGE_AS
argument_list|(
name|field_decl
argument_list|,
name|unsigned_type_node
argument_list|)
return|;
undef|#
directive|undef
name|AT_LEAST_AS_LARGE_AS
block|}
end_function

begin_comment
comment|/* Avoid calling `check_string_class_template ()' more than once.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|string_layout_checked
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Construct an internal string layout to be used as a template for    creating NSConstantString/NXConstantString instances.  */
end_comment

begin_function
specifier|static
name|tree
name|objc_build_internal_const_str_type
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|type
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
comment|/* NB: The finish_builtin_struct() routine expects FIELD_DECLs in      reverse order!  */
name|finish_builtin_struct
argument_list|(
name|type
argument_list|,
literal|"__builtin_ObjCString"
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Custom build_string which sets TREE_TYPE!  */
end_comment

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|fix_string_type
argument_list|(
name|build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a string with contents STR and length LEN and convert it to a    pointer.  */
end_comment

begin_function
specifier|static
name|tree
name|my_build_string_pointer
parameter_list|(
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|tree
name|string
init|=
name|my_build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
decl_stmt|;
name|tree
name|ptrtype
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|string_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|tree
name|str
init|=
operator|(
operator|(
expr|struct
name|string_descriptor
operator|*
operator|)
name|ptr
operator|)
operator|->
name|literal
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|TREE_STRING_POINTER
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|hashval_t
name|h
init|=
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|h
operator|=
operator|(
operator|(
name|h
operator|*
literal|613
operator|)
operator|+
name|p
index|[
name|i
index|]
operator|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|string_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr1
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr2
parameter_list|)
block|{
name|tree
name|str1
init|=
operator|(
operator|(
expr|struct
name|string_descriptor
operator|*
operator|)
name|ptr1
operator|)
operator|->
name|literal
decl_stmt|;
name|tree
name|str2
init|=
operator|(
operator|(
expr|struct
name|string_descriptor
operator|*
operator|)
name|ptr2
operator|)
operator|->
name|literal
decl_stmt|;
name|int
name|len1
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|str1
argument_list|)
decl_stmt|;
return|return
operator|(
name|len1
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|str2
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|str1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|str2
argument_list|)
argument_list|,
name|len1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of STRING_CST's, build a static instance of    NXConstantString which points at the concatenation of those    strings.  We place the string object in the __string_objects    section of the __OBJC segment.  The Objective-C runtime will    initialize the isa pointers of the string objects to point at the    NXConstantString class object.  */
end_comment

begin_function
name|tree
name|objc_build_string_object
parameter_list|(
name|tree
name|string
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|constructor
decl_stmt|,
name|constant_string_class
decl_stmt|;
name|int
name|length
decl_stmt|;
name|tree
name|fields
decl_stmt|,
name|addr
decl_stmt|;
name|struct
name|string_descriptor
modifier|*
name|desc
decl_stmt|,
name|key
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Prep the string argument.  */
name|string
operator|=
name|fix_string_type
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|string
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Check whether the string class being used actually exists and has the      correct ivar layout.  */
if|if
condition|(
operator|!
name|string_layout_checked
condition|)
block|{
name|string_layout_checked
operator|=
operator|-
literal|1
expr_stmt|;
name|constant_string_class
operator|=
name|lookup_interface
argument_list|(
name|constant_string_id
argument_list|)
expr_stmt|;
name|internal_const_str_type
operator|=
name|objc_build_internal_const_str_type
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|constant_string_class
operator|||
operator|!
operator|(
name|constant_string_type
operator|=
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|constant_string_class
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"cannot find interface declaration for %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constant_string_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The NSConstantString/NXConstantString ivar layout is now known.  */
elseif|else
if|if
condition|(
operator|!
name|check_string_class_template
argument_list|()
condition|)
name|error
argument_list|(
literal|"interface %qs does not have valid constant string layout"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constant_string_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the NeXT runtime, we can generate a literal reference 	 to the string class, don't need to run a constructor.  */
elseif|else
if|if
condition|(
name|flag_next_runtime
operator|&&
operator|!
name|setup_string_decl
argument_list|()
condition|)
name|error
argument_list|(
literal|"cannot find reference tag for class %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|constant_string_id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|string_layout_checked
operator|=
literal|1
expr_stmt|;
comment|/* Success!  */
name|add_class_reference
argument_list|(
name|constant_string_id
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|string_layout_checked
operator|==
operator|-
literal|1
condition|)
return|return
name|error_mark_node
return|;
comment|/* Perhaps we already constructed a constant string just like this one? */
name|key
operator|.
name|literal
operator|=
name|string
expr_stmt|;
name|loc
operator|=
name|htab_find_slot
argument_list|(
name|string_htab
argument_list|,
operator|&
name|key
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
operator|!
name|desc
condition|)
block|{
name|tree
name|var
decl_stmt|;
operator|*
name|loc
operator|=
name|desc
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|literal
operator|=
name|string
expr_stmt|;
comment|/* GNU:    (NXConstantString *)& ((__builtin_ObjCString) { NULL, string, length })  */
comment|/* NeXT:   (NSConstantString *)& ((__builtin_ObjCString) { isa, string, length })   */
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|internal_const_str_type
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|fields
argument_list|,
name|flag_next_runtime
condition|?
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_class_decl
argument_list|,
literal|0
argument_list|)
else|:
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string
argument_list|,
literal|1
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|length
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|objc_build_constructor
argument_list|(
name|internal_const_str_type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|constructor
argument_list|)
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
name|constructor
operator|=
name|objc_add_static_instance
argument_list|(
name|constructor
argument_list|,
name|constant_string_type
argument_list|)
expr_stmt|;
else|else
block|{
name|var
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|NULL
argument_list|,
name|TREE_TYPE
argument_list|(
name|constructor
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|=
name|constructor
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|constructor
operator|=
name|var
expr_stmt|;
block|}
name|desc
operator|->
name|constructor
operator|=
name|constructor
expr_stmt|;
block|}
name|addr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|constant_string_type
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|desc
operator|->
name|constructor
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Declare a static instance of CLASS_DECL initialized by CONSTRUCTOR.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|num_static_inst
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|objc_add_static_instance
parameter_list|(
name|tree
name|constructor
parameter_list|,
name|tree
name|class_decl
parameter_list|)
block|{
name|tree
modifier|*
name|chain
decl_stmt|,
name|decl
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* Find the list of static instances for the CLASS_DECL.  Create one if      not found.  */
for|for
control|(
name|chain
operator|=
operator|&
name|objc_static_instances
init|;
operator|*
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|!=
name|class_decl
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|chain
condition|)
block|{
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_objc_string
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|class_decl
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_INSTANCE_%d"
argument_list|,
name|num_static_inst
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|class_decl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|constructor
expr_stmt|;
comment|/* We may be writing something else just now.      Postpone till end of input.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add the DECL to the head of this CLASS' list.  */
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Build a static constant CONSTRUCTOR    with type TYPE and elements ELTS.  */
end_comment

begin_function
specifier|static
name|tree
name|objc_build_constructor
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|elts
parameter_list|)
block|{
name|tree
name|constructor
init|=
name|build_constructor_from_list
argument_list|(
name|type
argument_list|,
name|elts
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* Adjust for impedance mismatch.  We should figure out how to build      CONSTRUCTORs that consistently please both the C and C++ gods.  */
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|constructor
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|constructor
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|constructor
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take care of defining and initializing _OBJC_SYMBOLS.  */
end_comment

begin_comment
comment|/* Predefine the following data type:     struct _objc_symtab    {      long sel_ref_cnt;      SEL *refs;      short cls_def_cnt;      short cat_def_cnt;      void *defs[cls_def_cnt + cat_def_cnt];    }; */
end_comment

begin_function
specifier|static
name|void
name|build_objc_symtab_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_symtab_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SYMTAB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long sel_ref_cnt; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|long_integer_type_node
argument_list|,
literal|"sel_ref_cnt"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* SEL *refs; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_selector_type
argument_list|)
argument_list|,
literal|"refs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cls_def_cnt; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|short_integer_type_node
argument_list|,
literal|"cls_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cat_def_cnt; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|short_integer_type_node
argument_list|,
literal|"cat_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp_count
operator|||
name|cat_count
operator|||
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* void *defs[imp_count + cat_count (+ 1)]; */
comment|/* NB: The index is one less than the size of the array.  */
name|int
name|index
init|=
name|imp_count
operator|+
name|cat_count
operator|+
operator|(
name|flag_next_runtime
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|index
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"defs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
name|finish_struct
argument_list|(
name|objc_symtab_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the initial value for the `defs' field of _objc_symtab.    This is a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|tree
name|init_def_list
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|,
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
if|if
condition|(
name|imp_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cat_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* statics = { ..., _OBJC_STATIC_INSTANCES, ... }  */
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|static_instances_decl
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|static_instances_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct the initial value for all of _objc_symtab.  */
end_comment

begin_function
specifier|static
name|tree
name|init_objc_symtab
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|;
comment|/* sel_ref_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|long_integer_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */
if|if
condition|(
name|flag_next_runtime
operator|||
operator|!
name|sel_ref_chain
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_selector_type
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cls_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|imp_count
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cat_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|cat_count
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cls_def = { ..., {&Foo,&Bar, ...}, ... } */
if|if
condition|(
name|imp_count
operator|||
name|cat_count
operator|||
operator|!
name|flag_next_runtime
condition|)
block|{
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init_def_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate forward declarations for metadata such as   'OBJC_CLASS_...'.  */
end_comment

begin_function
specifier|static
name|tree
name|build_metadata_decl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* struct TYPE NAME_<name>; */
name|decl
operator|=
name|start_var_decl
argument_list|(
name|type
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Push forward-declarations of all the categories so that    init_def_list can use them in a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|void
name|forward_declare_categories
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|sav
init|=
name|objc_implementation_context
decl_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* Set an invisible arg to synth_id_with_class_suffix.  */
name|objc_implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
comment|/* extern struct objc_category _OBJC_CATEGORY_<name>; */
name|impent
operator|->
name|class_decl
operator|=
name|build_metadata_decl
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|,
name|objc_category_template
argument_list|)
expr_stmt|;
block|}
block|}
name|objc_implementation_context
operator|=
name|sav
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the declaration of _OBJC_SYMBOLS, with type `struct _objc_symtab'    and initialized appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|generate_objc_symtab_decl
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* forward declare categories */
if|if
condition|(
name|cat_count
condition|)
name|forward_declare_categories
argument_list|()
expr_stmt|;
name|build_objc_symtab_template
argument_list|()
expr_stmt|;
name|UOBJC_SYMBOLS_decl
operator|=
name|start_var_decl
argument_list|(
name|objc_symtab_template
argument_list|,
literal|"_OBJC_SYMBOLS"
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|,
name|init_objc_symtab
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_SYMBOLS_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|init_module_descriptor
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|expr
decl_stmt|;
comment|/* version = { 1, ... } */
name|expr
operator|=
name|build_int_cst
argument_list|(
name|long_integer_type_node
argument_list|,
name|OBJC_VERSION
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* size = { ..., sizeof (struct _objc_module), ... } */
name|expr
operator|=
name|convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|size_in_bytes
argument_list|(
name|objc_module_template
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* Don't provide any file name for security reasons. */
comment|/* name = { ..., "", ... } */
name|expr
operator|=
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
literal|""
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* symtab = { ..., _OBJC_SYMBOLS, ... } */
if|if
condition|(
name|UOBJC_SYMBOLS_decl
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_SYMBOLS_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the data structures to describe Objective C classes defined.     struct _objc_module { ... } _OBJC_MODULE = { ... };   */
end_comment

begin_function
specifier|static
name|void
name|build_module_descriptor
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* extern "C" */
endif|#
directive|endif
name|objc_module_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_MODULE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long version; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|long_integer_type_node
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* long size; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|long_integer_type_node
argument_list|,
literal|"size"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char *name; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc_symtab *symtab; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SYMTAB
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"symtab"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_module_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Create an instance of "_objc_module".  */
name|UOBJC_MODULES_decl
operator|=
name|start_var_decl
argument_list|(
name|objc_module_template
argument_list|,
literal|"_OBJC_MODULES"
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|UOBJC_MODULES_decl
argument_list|,
name|init_module_descriptor
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_MODULES_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|pop_lang_context
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The GNU runtime requires us to provide a static initializer function    for each module:     static void __objc_gnu_init (void) {      __objc_exec_class (&L_OBJC_MODULES);    }  */
end_comment

begin_function
specifier|static
name|void
name|build_module_initializer_routine
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|body
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* extern "C" */
endif|#
directive|endif
name|objc_push_parm
argument_list|(
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|objc_start_function
argument_list|(
name|get_identifier
argument_list|(
name|TAG_GNUINIT
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|objc_get_parm_info
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|c_begin_compound_stmt
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|build_function_call
argument_list|(
name|execclass_decl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_MODULES_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|c_end_compound_stmt
argument_list|(
name|body
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJCPLUS
comment|/* For Objective-C++, we will need to call __objc_gnu_init      from objc_generate_static_init_call() below.  */
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|GNU_INIT_decl
operator|=
name|current_function_decl
expr_stmt|;
name|finish_function
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|pop_lang_context
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_comment
comment|/* Return 1 if the __objc_gnu_init function has been synthesized and needs    to be called by the module initializer routine.  */
end_comment

begin_function
name|int
name|objc_static_init_needed_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|GNU_INIT_decl
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a call to the __objc_gnu_init initializer function.  */
end_comment

begin_function
name|tree
name|objc_generate_static_init_call
parameter_list|(
name|tree
name|ctors
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|build_function_call
argument_list|(
name|GNU_INIT_decl
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ctors
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJCPLUS */
end_comment

begin_comment
comment|/* Return the DECL of the string IDENT in the SECTION.  */
end_comment

begin_function
specifier|static
name|tree
name|get_objc_string_decl
parameter_list|(
name|tree
name|ident
parameter_list|,
name|enum
name|string_section
name|section
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|chain
operator|=
name|class_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|chain
operator|=
name|meth_var_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|chain
operator|=
name|meth_var_types_chain
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
operator|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
operator|)
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Output references to all statically allocated objects.  Return the DECL    for the array built.  */
end_comment

begin_function
specifier|static
name|void
name|generate_static_references
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decls
init|=
name|NULL_TREE
decl_stmt|,
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|class_name
decl_stmt|,
name|class
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|tree
name|cl_chain
decl_stmt|,
name|in_chain
decl_stmt|,
name|type
init|=
name|build_array_type
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|int
name|num_inst
decl_stmt|,
name|num_class
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|cl_chain
operator|=
name|objc_static_instances
operator|,
name|num_class
operator|=
literal|0
init|;
name|cl_chain
condition|;
name|cl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|cl_chain
argument_list|)
operator|,
name|num_class
operator|++
control|)
block|{
for|for
control|(
name|num_inst
operator|=
literal|0
operator|,
name|in_chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|cl_chain
argument_list|)
init|;
name|in_chain
condition|;
name|num_inst
operator|++
operator|,
name|in_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|in_chain
argument_list|)
control|)
empty_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_STATIC_INSTANCES_%d"
argument_list|,
name|num_class
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|type
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Output {class_name, ...}.  */
name|class
operator|=
name|TREE_VALUE
argument_list|(
name|cl_chain
argument_list|)
expr_stmt|;
name|class_name
operator|=
name|get_objc_string_decl
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|class
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output {..., instance, ...}.  */
for|for
control|(
name|in_chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|cl_chain
argument_list|)
init|;
name|in_chain
condition|;
name|in_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|in_chain
argument_list|)
control|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|in_chain
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* Output {..., NULL}.  */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decls
argument_list|)
expr_stmt|;
block|}
name|decls
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decls
argument_list|)
expr_stmt|;
name|expr
operator|=
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|decls
argument_list|)
argument_list|)
expr_stmt|;
name|static_instances_decl
operator|=
name|start_var_decl
argument_list|(
name|type
argument_list|,
literal|"_OBJC_STATIC_INSTANCES"
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|static_instances_decl
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|selector_reference_idx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|build_selector_reference_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES_%d"
argument_list|,
name|selector_reference_idx
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|objc_selector_type
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_selector_table_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|flag_typed_selectors
condition|)
block|{
name|build_selector_template
argument_list|()
expr_stmt|;
name|temp
operator|=
name|build_array_type
argument_list|(
name|objc_selector_template
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|build_array_type
argument_list|(
name|objc_selector_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|UOBJC_SELECTOR_TABLE_decl
operator|=
name|start_var_decl
argument_list|(
name|temp
argument_list|,
literal|"_OBJC_SELECTOR_TABLE"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just a handy wrapper for add_objc_string.  */
end_comment

begin_function
specifier|static
name|tree
name|build_selector
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
return|return
name|convert
argument_list|(
name|objc_selector_type
argument_list|,
name|add_objc_string
argument_list|(
name|ident
argument_list|,
name|meth_var_names
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_selector_translation_table
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|,
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|sel_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|warn_selector
operator|&&
name|objc_implementation_context
condition|)
block|{
name|tree
name|method_chain
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
for|for
control|(
name|method_chain
operator|=
name|meth_var_names_chain
init|;
name|method_chain
condition|;
name|method_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|method_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|method_chain
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|location_t
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|flag_next_runtime
operator|&&
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
condition|)
name|loc
operator|=
operator|&
name|DECL_SOURCE_LOCATION
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|input_location
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hcreating selector for nonexistent method %qE"
argument_list|,
name|loc
argument_list|,
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|expr
operator|=
name|build_selector
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add one for the '\0' character */
name|offset
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
name|decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag_typed_selectors
condition|)
block|{
name|tree
name|eltlist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|encoding
init|=
name|get_proto_encoding
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|encoding
argument_list|,
name|eltlist
argument_list|)
expr_stmt|;
name|expr
operator|=
name|objc_build_constructor
argument_list|(
name|objc_selector_template
argument_list|,
name|nreverse
argument_list|(
name|eltlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* Cause the selector table (previously forward-declared) 	 to be actually output.  */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|flag_typed_selectors
condition|?
name|objc_build_constructor
argument_list|(
name|objc_selector_template
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
else|:
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|get_proto_encoding
parameter_list|(
name|tree
name|proto
parameter_list|)
block|{
name|tree
name|encoding
decl_stmt|;
if|if
condition|(
name|proto
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
else|else
name|encoding
operator|=
name|METHOD_ENCODING
argument_list|(
name|proto
argument_list|)
expr_stmt|;
return|return
name|add_objc_string
argument_list|(
name|encoding
argument_list|,
name|meth_var_types
argument_list|)
return|;
block|}
else|else
return|return
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* sel_ref_chain is a list whose "value" fields will be instances of    identifier_node that represent the selector.  */
end_comment

begin_function
specifier|static
name|tree
name|build_typed_selector_reference
parameter_list|(
name|tree
name|ident
parameter_list|,
name|tree
name|prototype
parameter_list|)
block|{
name|tree
modifier|*
name|chain
init|=
operator|&
name|sel_ref_chain
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|prototype
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
goto|goto
name|return_at_index
goto|;
name|index
operator|++
expr_stmt|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|prototype
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|return_at_index
label|:
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|index
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|objc_selector_type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_selector_reference
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
modifier|*
name|chain
init|=
operator|&
name|sel_ref_chain
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
operator|(
name|flag_next_runtime
condition|?
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
else|:
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|index
argument_list|)
argument_list|)
operator|)
return|;
name|index
operator|++
expr_stmt|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
operator|(
name|flag_next_runtime
condition|?
name|build_selector_reference_decl
argument_list|()
else|:
name|NULL_TREE
operator|)
expr_stmt|;
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|expr
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
operator|(
name|flag_next_runtime
condition|?
name|expr
else|:
name|build_array_ref
argument_list|(
name|UOBJC_SELECTOR_TABLE_decl
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|index
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|class_reference_idx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|build_class_reference_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_CLASS_REFERENCES_%d"
argument_list|,
name|class_reference_idx
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|objc_class_type
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a class reference, but don't create a variable to reference    it.  */
end_comment

begin_function
specifier|static
name|void
name|add_class_reference
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
operator|(
name|chain
operator|=
name|cls_ref_chain
operator|)
condition|)
block|{
name|tree
name|tail
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return;
name|tail
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
comment|/* Append to the end of the list */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|cls_ref_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a class reference, creating it if necessary.  Also create the    reference variable.  */
end_comment

begin_function
name|tree
name|objc_get_class_reference
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|orig_ident
init|=
operator|(
name|DECL_P
argument_list|(
name|ident
argument_list|)
condition|?
name|DECL_NAME
argument_list|(
name|ident
argument_list|)
else|:
name|TYPE_P
argument_list|(
name|ident
argument_list|)
condition|?
name|OBJC_TYPE_NAME
argument_list|(
name|ident
argument_list|)
else|:
name|ident
operator|)
decl_stmt|;
name|bool
name|local_scope
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Must wait until template instantiation time.  */
return|return
name|build_min_nt
argument_list|(
name|CLASS_REFERENCE_EXPR
argument_list|,
name|ident
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ident
operator|=
operator|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|ident
argument_list|)
condition|?
name|DECL_ORIGINAL_TYPE
argument_list|(
name|ident
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|ident
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|TYPE_P
argument_list|(
name|ident
argument_list|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|ident
argument_list|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|ident
argument_list|)
operator|!=
name|global_namespace
condition|)
name|local_scope
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|local_scope
operator|||
operator|!
operator|(
name|ident
operator|=
name|objc_is_class_name
argument_list|(
name|ident
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%qs is not an Objective-C class name or alias"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|orig_ident
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|flag_next_runtime
operator|&&
operator|!
name|flag_zero_link
condition|)
block|{
name|tree
modifier|*
name|chain
decl_stmt|;
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|chain
operator|=
operator|&
name|cls_ref_chain
init|;
operator|*
name|chain
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|build_class_reference_decl
argument_list|()
expr_stmt|;
return|return
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
return|;
block|}
name|decl
operator|=
name|build_class_reference_decl
argument_list|()
expr_stmt|;
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
block|{
name|tree
name|params
decl_stmt|;
name|add_class_reference
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|params
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|my_build_string_pointer
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|ident
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|objc_get_class_decl
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|objc_get_class_decl
argument_list|,
name|params
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* For each string section we have a chain which maps identifier nodes    to decls for the strings.  */
end_comment

begin_function
specifier|static
name|tree
name|add_objc_string
parameter_list|(
name|tree
name|ident
parameter_list|,
name|enum
name|string_section
name|section
parameter_list|)
block|{
name|tree
modifier|*
name|chain
decl_stmt|,
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|string_expr
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|chain
operator|=
operator|&
name|class_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|chain
operator|=
operator|&
name|meth_var_names_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|chain
operator|=
operator|&
name|meth_var_types_chain
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|chain
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|==
name|ident
condition|)
return|return
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_objc_string_decl
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|ident
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|ident
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|string_expr
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|ident
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|class_names_idx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|meth_var_names_idx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|meth_var_types_idx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|build_objc_string_decl
parameter_list|(
name|enum
name|string_section
name|section
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|class_names
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_CLASS_NAME_%d"
argument_list|,
name|class_names_idx
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_names
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_METH_VAR_NAME_%d"
argument_list|,
name|meth_var_names_idx
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|==
name|meth_var_types
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_METH_VAR_TYPE_%d"
argument_list|,
name|meth_var_types_idx
operator|++
argument_list|)
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|DECL_THIS_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* squash redeclaration errors */
endif|#
directive|endif
name|make_decl_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
name|void
name|objc_declare_alias
parameter_list|(
name|tree
name|alias_ident
parameter_list|,
name|tree
name|class_ident
parameter_list|)
block|{
name|tree
name|underlying_class
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
block|{
name|error
argument_list|(
literal|"Objective-C declarations may only appear in global scope"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJCPLUS */
if|if
condition|(
operator|!
operator|(
name|underlying_class
operator|=
name|objc_is_class_name
argument_list|(
name|class_ident
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"cannot find class %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_ident
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|objc_is_class_name
argument_list|(
name|alias_ident
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"class %qs already exists"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|alias_ident
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Implement @compatibility_alias as a typedef.  */
ifdef|#
directive|ifdef
name|OBJCPLUS
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* extern "C" */
endif|#
directive|endif
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|alias_ident
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|underlying_class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|pop_lang_context
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|alias_chain
operator|=
name|tree_cons
argument_list|(
name|underlying_class
argument_list|,
name|alias_ident
argument_list|,
name|alias_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|objc_declare_class
parameter_list|(
name|tree
name|ident_list
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
block|{
name|error
argument_list|(
literal|"Objective-C declarations may only appear in global scope"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJCPLUS */
for|for
control|(
name|list
operator|=
name|ident_list
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
name|tree
name|ident
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|objc_is_class_name
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|tree
name|record
init|=
name|lookup_name
argument_list|(
name|ident
argument_list|)
decl_stmt|,
name|type
init|=
name|record
decl_stmt|;
if|if
condition|(
name|record
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|record
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|record
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_OBJC_INTERFACE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qs redeclared as different kind of symbol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of %q+D"
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
block|}
name|record
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|INIT_TYPE_OBJC_INFO
argument_list|(
name|record
argument_list|)
expr_stmt|;
name|TYPE_OBJC_INTERFACE
argument_list|(
name|record
argument_list|)
operator|=
name|ident
expr_stmt|;
name|class_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ident
argument_list|,
name|class_chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|tree
name|objc_is_class_name
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|identifier_global_value
argument_list|(
name|ident
argument_list|)
condition|)
name|ident
operator|=
name|identifier_global_value
argument_list|(
name|ident
argument_list|)
expr_stmt|;
while|while
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|ident
argument_list|)
condition|)
name|ident
operator|=
name|OBJC_TYPE_NAME
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|ident
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|ident
operator|=
name|OBJC_TYPE_NAME
argument_list|(
name|ident
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ident
operator|=
name|DECL_NAME
argument_list|(
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ident
operator|||
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|lookup_interface
argument_list|(
name|ident
argument_list|)
condition|)
return|return
name|ident
return|;
for|for
control|(
name|chain
operator|=
name|class_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|ident
return|;
block|}
for|for
control|(
name|chain
operator|=
name|alias_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is either 'id' or 'Class'.  */
end_comment

begin_function
name|tree
name|objc_is_id
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|identifier_global_value
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|identifier_global_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* NB: This function may be called before the ObjC front-end has      been initialized, in which case OBJC_OBJECT_TYPE will (still) be NULL.  */
return|return
operator|(
name|objc_object_type
operator|&&
name|type
operator|&&
operator|(
name|IS_ID
argument_list|(
name|type
argument_list|)
operator|||
name|IS_CLASS
argument_list|(
name|type
argument_list|)
operator|||
name|IS_SUPER
argument_list|(
name|type
argument_list|)
operator|)
condition|?
name|type
else|:
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether TYPE is either 'id', 'Class', or a pointer to an ObjC    class instance.  This is needed by other parts of the compiler to    handle ObjC types gracefully.  */
end_comment

begin_function
name|tree
name|objc_is_object_ptr
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|objc_is_id
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|objc_is_class_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objc_is_gcable_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|or_strong_p
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|objc_is_id
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|or_strong_p
operator|&&
name|lookup_attribute
argument_list|(
literal|"objc_gc"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|objc_is_class_name
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_substitute_decl
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|oldexpr
parameter_list|,
name|tree
name|newexpr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|oldexpr
condition|)
return|return
name|newexpr
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
return|return
name|objc_build_component_ref
argument_list|(
name|objc_substitute_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldexpr
argument_list|,
name|newexpr
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
return|return
name|build_array_ref
argument_list|(
name|objc_substitute_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldexpr
argument_list|,
name|newexpr
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
return|return
name|build_indirect_ref
argument_list|(
name|objc_substitute_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldexpr
argument_list|,
name|newexpr
argument_list|)
argument_list|,
literal|"->"
argument_list|)
return|;
default|default:
return|return
name|expr
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_build_ivar_assignment
parameter_list|(
name|tree
name|outervar
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|func_params
decl_stmt|;
comment|/* The LHS parameter contains the expression 'outervar->memberspec';      we need to transform it into '&((typeof(outervar) *) 0)->memberspec',      where memberspec may be arbitrarily complex (e.g., 'g->f.d[2].g[3]').   */
name|tree
name|offs
init|=
name|objc_substitute_decl
argument_list|(
name|lhs
argument_list|,
name|outervar
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|outervar
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|func
init|=
operator|(
name|flag_objc_direct_dispatch
condition|?
name|objc_assign_ivar_fast_decl
else|:
name|objc_assign_ivar_decl
operator|)
decl_stmt|;
name|offs
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|offs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|offs
operator|=
name|fold
argument_list|(
name|offs
argument_list|)
expr_stmt|;
name|func_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|objc_object_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|objc_object_type
argument_list|,
name|outervar
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|offs
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|func
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|func
argument_list|,
name|func_params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_build_global_assignment
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|func_params
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|objc_object_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_object_type
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|assemble_external
argument_list|(
name|objc_assign_global_decl
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|objc_assign_global_decl
argument_list|,
name|func_params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_build_strong_cast_assignment
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|func_params
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|objc_object_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_object_type
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|assemble_external
argument_list|(
name|objc_assign_strong_cast_decl
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|objc_assign_strong_cast_decl
argument_list|,
name|func_params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objc_is_gcable_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
condition|?
name|objc_is_gcable_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
condition|?
operator|(
name|objc_is_gcable_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|objc_is_gcable_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
else|:
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
name|objc_is_gcable_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
else|:
name|TYPE_P
argument_list|(
name|expr
argument_list|)
condition|?
name|objc_is_gcable_type
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|objc_is_gcable_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
operator|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"objc_gc"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objc_is_ivar_reference_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ARRAY_REF
condition|?
name|objc_is_ivar_reference_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
condition|?
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objc_is_global_reference_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PLUS_EXPR
condition|?
name|objc_is_global_reference_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|?
operator|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|expr
argument_list|)
operator|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|tree
name|objc_generate_write_barrier
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|enum
name|tree_code
name|modifycode
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|,
name|outer
decl_stmt|;
name|int
name|strong_cast_p
init|=
literal|0
decl_stmt|,
name|outer_gc_p
init|=
literal|0
decl_stmt|,
name|indirect_p
init|=
literal|0
decl_stmt|;
comment|/* See if we have any lhs casts, and strip them out.  NB: The lvalue casts      will have been transformed to the form '*(type *)&expr'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|outer
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strong_cast_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|outer
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|outer
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|outer
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
condition|)
block|{
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|outer
argument_list|)
decl_stmt|;
comment|/* Descend down the cast chain, and record the first objc_gc 	     attribute found.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|lhstype
argument_list|)
condition|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"objc_gc"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
name|strong_cast_p
operator|=
literal|1
expr_stmt|;
block|}
name|outer
operator|=
name|TREE_OPERAND
argument_list|(
name|outer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a __strong cast, it trumps all else.  */
if|if
condition|(
name|strong_cast_p
condition|)
block|{
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
goto|goto
name|invalid_pointer_arithmetic
goto|;
if|if
condition|(
name|warn_assign_intercept
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"strong-cast assignment has been intercepted"
argument_list|)
expr_stmt|;
name|result
operator|=
name|objc_build_strong_cast_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
goto|goto
name|exit_point
goto|;
block|}
comment|/* the lhs must be of a suitable type, regardless of its underlying      structure.  */
if|if
condition|(
operator|!
name|objc_is_gcable_p
argument_list|(
name|lhs
argument_list|)
condition|)
goto|goto
name|exit_point
goto|;
name|outer
operator|=
name|lhs
expr_stmt|;
while|while
condition|(
name|outer
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|outer
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|outer
argument_list|)
operator|==
name|ARRAY_REF
operator|)
condition|)
name|outer
operator|=
name|TREE_OPERAND
argument_list|(
name|outer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|outer
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|outer
operator|=
name|TREE_OPERAND
argument_list|(
name|outer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indirect_p
operator|=
literal|1
expr_stmt|;
block|}
name|outer_gc_p
operator|=
name|objc_is_gcable_p
argument_list|(
name|outer
argument_list|)
expr_stmt|;
comment|/* Handle ivar assignments. */
if|if
condition|(
name|objc_is_ivar_reference_p
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* if the struct to the left of the ivar is not an Objective-C object (__strong 	 doesn't cut it here), the best we can do here is suggest a cast.  */
if|if
condition|(
operator|!
name|objc_is_gcable_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|outer
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* We may still be able to use the global write barrier... */
if|if
condition|(
operator|!
name|indirect_p
operator|&&
name|objc_is_global_reference_p
argument_list|(
name|outer
argument_list|)
condition|)
goto|goto
name|global_reference
goto|;
name|suggest_cast
label|:
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
if|if
condition|(
name|warn_assign_intercept
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"strong-cast may possibly be needed"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exit_point
goto|;
block|}
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
goto|goto
name|invalid_pointer_arithmetic
goto|;
if|if
condition|(
name|warn_assign_intercept
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"instance variable assignment has been intercepted"
argument_list|)
expr_stmt|;
name|result
operator|=
name|objc_build_ivar_assignment
argument_list|(
name|outer
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
goto|goto
name|exit_point
goto|;
block|}
comment|/* Likewise, intercept assignment to global/static variables if their type is      GC-marked.  */
if|if
condition|(
name|objc_is_global_reference_p
argument_list|(
name|outer
argument_list|)
condition|)
block|{
if|if
condition|(
name|indirect_p
condition|)
goto|goto
name|suggest_cast
goto|;
name|global_reference
label|:
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|invalid_pointer_arithmetic
label|:
if|if
condition|(
name|outer_gc_p
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"pointer arithmetic for garbage-collected objects not allowed"
argument_list|)
expr_stmt|;
goto|goto
name|exit_point
goto|;
block|}
if|if
condition|(
name|warn_assign_intercept
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"global/static variable assignment has been intercepted"
argument_list|)
expr_stmt|;
name|result
operator|=
name|objc_build_global_assignment
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
comment|/* In all other cases, fall back to the normal mechanism.  */
name|exit_point
label|:
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|interface_tuple
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|id
decl_stmt|;
name|tree
name|class_name
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct interface_tuple))
argument_list|)
name|htab_t
name|interface_htab
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|hashval_t
name|hash_interface
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|interface_tuple
modifier|*
name|d
init|=
name|p
decl_stmt|;
return|return
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|d
operator|->
name|id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eq_interface
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|interface_tuple
modifier|*
name|d
init|=
name|p1
decl_stmt|;
return|return
name|d
operator|->
name|id
operator|==
name|p2
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_interface
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|ident
operator|&&
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ident
operator|=
name|DECL_NAME
argument_list|(
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ident
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|ident
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
name|NULL_TREE
return|;
block|{
name|struct
name|interface_tuple
modifier|*
modifier|*
name|slot
decl_stmt|;
name|tree
name|i
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|interface_htab
condition|)
block|{
name|slot
operator|=
operator|(
expr|struct
name|interface_tuple
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|interface_htab
argument_list|,
name|ident
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|ident
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|&&
operator|*
name|slot
condition|)
name|i
operator|=
operator|(
operator|*
name|slot
operator|)
operator|->
name|class_name
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implement @defs (<classname>) within struct bodies.  */
end_comment

begin_function
name|tree
name|objc_get_class_ivars
parameter_list|(
name|tree
name|class_name
parameter_list|)
block|{
name|tree
name|interface
init|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|interface
condition|)
return|return
name|get_class_ivars
argument_list|(
name|interface
argument_list|,
name|true
argument_list|)
return|;
name|error
argument_list|(
literal|"cannot find interface declaration for %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Used by: build_private_template, continue_class,    and for @defs constructs.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_ivars
parameter_list|(
name|tree
name|interface
parameter_list|,
name|bool
name|inherited
parameter_list|)
block|{
name|tree
name|ivar_chain
init|=
name|copy_list
argument_list|(
name|CLASS_RAW_IVARS
argument_list|(
name|interface
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Both CLASS_RAW_IVARS and CLASS_IVARS contain a list of ivars declared      by the current class (i.e., they do not include super-class ivars).      However, the CLASS_IVARS list will be side-effected by a call to      finish_struct(), which will fill in field offsets.  */
if|if
condition|(
operator|!
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
condition|)
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
operator|=
name|ivar_chain
expr_stmt|;
if|if
condition|(
operator|!
name|inherited
condition|)
return|return
name|ivar_chain
return|;
while|while
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
condition|)
block|{
comment|/* Prepend super-class ivars.  */
name|interface
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ivar_chain
operator|=
name|chainon
argument_list|(
name|copy_list
argument_list|(
name|CLASS_RAW_IVARS
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|,
name|ivar_chain
argument_list|)
expr_stmt|;
block|}
return|return
name|ivar_chain
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_create_temporary_var
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Exception handling constructs.  We begin by having the parser do most    of the work and passing us blocks.  What we do next depends on whether    we're doing "native" exception handling or legacy Darwin setjmp exceptions.    We abstract all of this in a handful of appropriately named routines.  */
end_comment

begin_comment
comment|/* Stack of open try blocks.  */
end_comment

begin_struct
struct|struct
name|objc_try_context
block|{
name|struct
name|objc_try_context
modifier|*
name|outer
decl_stmt|;
comment|/* Statements (or statement lists) as processed by the parser.  */
name|tree
name|try_body
decl_stmt|;
name|tree
name|finally_body
decl_stmt|;
comment|/* Some file position locations.  */
name|location_t
name|try_locus
decl_stmt|;
name|location_t
name|end_try_locus
decl_stmt|;
name|location_t
name|end_catch_locus
decl_stmt|;
name|location_t
name|finally_locus
decl_stmt|;
name|location_t
name|end_finally_locus
decl_stmt|;
comment|/* A STATEMENT_LIST of CATCH_EXPRs, appropriate for sticking into op1      of a TRY_CATCH_EXPR.  Even when doing Darwin setjmp.  */
name|tree
name|catch_list
decl_stmt|;
comment|/* The CATCH_EXPR of an open @catch clause.  */
name|tree
name|current_catch
decl_stmt|;
comment|/* The VAR_DECL holding the Darwin equivalent of EXC_PTR_EXPR.  */
name|tree
name|caught_decl
decl_stmt|;
name|tree
name|stack_decl
decl_stmt|;
name|tree
name|rethrow_decl
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|objc_try_context
modifier|*
name|cur_try_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This hook, called via lang_eh_runtime_type, generates a runtime object    that represents TYPE.  For Objective-C, this is just the class name.  */
end_comment

begin_comment
comment|/* ??? Isn't there a class object or some such?  Is it easy to get?  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJCPLUS
end_ifndef

begin_function
specifier|static
name|tree
name|objc_eh_runtime_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|add_objc_string
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|class_names
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize exception handling.  */
end_comment

begin_function
specifier|static
name|void
name|objc_init_exceptions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|bool
name|done
init|=
name|false
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
name|done
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|flag_objc_sjlj_exceptions
condition|)
block|{
comment|/* On Darwin, ObjC exceptions require a sufficiently recent 	 version of the runtime, so the user must ask for them explicitly.  */
if|if
condition|(
operator|!
name|flag_objc_exceptions
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"use %<-fobjc-exceptions%> to enable Objective-C "
literal|"exception syntax"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OBJCPLUS
else|else
block|{
name|c_eh_initialized_p
operator|=
name|true
expr_stmt|;
name|eh_personality_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"__gnu_objc_personality_sj0"
else|:
literal|"__gnu_objc_personality_v0"
argument_list|)
expr_stmt|;
name|default_init_unwind_resume_libfunc
argument_list|()
expr_stmt|;
name|using_eh_for_cleanups
argument_list|()
expr_stmt|;
name|lang_eh_runtime_type
operator|=
name|objc_eh_runtime_type
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Build an EXC_PTR_EXPR, or the moral equivalent.  In the case of Darwin,    we'll arrange for it to be initialized (and associated with a binding)    later.  */
end_comment

begin_function
specifier|static
name|tree
name|objc_build_exc_ptr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_objc_sjlj_exceptions
condition|)
block|{
name|tree
name|var
init|=
name|cur_try_context
operator|->
name|caught_decl
decl_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
block|{
name|var
operator|=
name|objc_create_temporary_var
argument_list|(
name|objc_object_type
argument_list|)
expr_stmt|;
name|cur_try_context
operator|->
name|caught_decl
operator|=
name|var
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
else|else
return|return
name|build0
argument_list|(
name|EXC_PTR_EXPR
argument_list|,
name|objc_object_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build "objc_exception_try_exit(&_stack)".  */
end_comment

begin_function
specifier|static
name|tree
name|next_sjlj_build_try_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|cur_try_context
operator|->
name|stack_decl
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call
argument_list|(
name|objc_exception_try_exit_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build 	objc_exception_try_enter (&_stack); 	if (_setjmp(&_stack.buf)) 	  ; 	else 	  ;    Return the COND_EXPR.  Note that the THEN and ELSE fields are left    empty, ready for the caller to fill them in.  */
end_comment

begin_function
specifier|static
name|tree
name|next_sjlj_build_enter_and_setjmp
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|enter
decl_stmt|,
name|sj
decl_stmt|,
name|cond
decl_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|cur_try_context
operator|->
name|stack_decl
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|enter
operator|=
name|build_function_call
argument_list|(
name|objc_exception_try_enter_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|objc_build_component_ref
argument_list|(
name|cur_try_context
operator|->
name|stack_decl
argument_list|,
name|get_identifier
argument_list|(
literal|"buf"
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* Convert _setjmp argument to type that is expected.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|objc_setjmp_decl
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|convert
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|objc_setjmp_decl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sj
operator|=
name|build_function_call
argument_list|(
name|objc_setjmp_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cond
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sj
argument_list|)
argument_list|,
name|enter
argument_list|,
name|sj
argument_list|)
expr_stmt|;
name|cond
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|cond
argument_list|)
expr_stmt|;
return|return
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build:     DECL = objc_exception_extract(&_stack);  */
end_comment

begin_function
specifier|static
name|tree
name|next_sjlj_build_exc_extract
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|cur_try_context
operator|->
name|stack_decl
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call
argument_list|(
name|objc_exception_extract_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build 	if (objc_exception_match(obj_get_class(TYPE), _caught) 	  BODY 	else if (...) 	  ... 	else 	  { 	    _rethrow = _caught; 	    objc_exception_try_exit(&_stack); 	  }    from the sequence of CATCH_EXPRs in the current try context.  */
end_comment

begin_function
specifier|static
name|tree
name|next_sjlj_build_catch_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree_stmt_iterator
name|i
init|=
name|tsi_start
argument_list|(
name|cur_try_context
operator|->
name|catch_list
argument_list|)
decl_stmt|;
name|tree
name|catch_seq
decl_stmt|,
name|t
decl_stmt|;
name|tree
modifier|*
name|last
init|=
operator|&
name|catch_seq
decl_stmt|;
name|bool
name|saw_id
init|=
name|false
decl_stmt|;
for|for
control|(
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|CATCH_TYPES
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|body
init|=
name|CATCH_BODY
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
operator|*
name|last
operator|=
name|body
expr_stmt|;
name|saw_id
operator|=
name|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tree
name|args
decl_stmt|,
name|cond
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|cond
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|cur_try_context
operator|->
name|caught_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|objc_get_class_reference
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call
argument_list|(
name|objc_exception_match_decl
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|cond
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|body
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|t
expr_stmt|;
name|last
operator|=
operator|&
name|COND_EXPR_ELSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|saw_id
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cur_try_context
operator|->
name|rethrow_decl
argument_list|,
name|cur_try_context
operator|->
name|caught_decl
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|cur_try_context
operator|->
name|end_catch_locus
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|t
operator|=
name|next_sjlj_build_try_exit
argument_list|()
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|cur_try_context
operator|->
name|end_catch_locus
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
return|return
name|catch_seq
return|;
block|}
end_function

begin_comment
comment|/* Build a complete @try-@catch-@finally block for legacy Darwin setjmp    exception handling.  We aim to build:  	{ 	  struct _objc_exception_data _stack; 	  id _rethrow = 0; 	  try 	    { 	      objc_exception_try_enter (&_stack); 	      if (_setjmp(&_stack.buf)) 	        { 		  id _caught = objc_exception_extract(&_stack); 		  objc_exception_try_enter (&_stack); 		  if (_setjmp(&_stack.buf)) 		    _rethrow = objc_exception_extract(&_stack); 		  else 		    CATCH-LIST 	        } 	      else 		TRY-BLOCK 	    } 	  finally 	    { 	      if (!_rethrow) 		objc_exception_try_exit(&_stack); 	      FINALLY-BLOCK 	      if (_rethrow) 		objc_exception_throw(_rethrow); 	    } 	}     If CATCH-LIST is empty, we can omit all of the block containing    "_caught" except for the setting of _rethrow.  Note the use of    a real TRY_FINALLY_EXPR here, which is not involved in EH per-se,    but handles goto and other exits from the block.  */
end_comment

begin_function
specifier|static
name|tree
name|next_sjlj_build_try_catch_finally
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|rethrow_decl
decl_stmt|,
name|stack_decl
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|catch_seq
decl_stmt|,
name|try_fin
decl_stmt|,
name|bind
decl_stmt|;
comment|/* Create the declarations involved.  */
name|t
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_EXCDATA
argument_list|)
argument_list|)
expr_stmt|;
name|stack_decl
operator|=
name|objc_create_temporary_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cur_try_context
operator|->
name|stack_decl
operator|=
name|stack_decl
expr_stmt|;
name|rethrow_decl
operator|=
name|objc_create_temporary_var
argument_list|(
name|objc_object_type
argument_list|)
expr_stmt|;
name|cur_try_context
operator|->
name|rethrow_decl
operator|=
name|rethrow_decl
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|rethrow_decl
argument_list|)
operator|=
name|stack_decl
expr_stmt|;
comment|/* Build the outermost variable binding level.  */
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|rethrow_decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|bind
argument_list|,
name|cur_try_context
operator|->
name|try_locus
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Initialize rethrow_decl.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|rethrow_decl
argument_list|,
name|convert
argument_list|(
name|objc_object_type
argument_list|,
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|cur_try_context
operator|->
name|try_locus
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build the outermost TRY_FINALLY_EXPR.  */
name|try_fin
operator|=
name|build2
argument_list|(
name|TRY_FINALLY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|try_fin
argument_list|,
name|cur_try_context
operator|->
name|try_locus
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|try_fin
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|try_fin
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the complete catch sequence.  */
if|if
condition|(
name|cur_try_context
operator|->
name|catch_list
condition|)
block|{
name|tree
name|caught_decl
init|=
name|objc_build_exc_ptr
argument_list|()
decl_stmt|;
name|catch_seq
operator|=
name|build_stmt
argument_list|(
name|BIND_EXPR
argument_list|,
name|caught_decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|catch_seq
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|next_sjlj_build_exc_extract
argument_list|(
name|caught_decl
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|catch_seq
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|next_sjlj_build_enter_and_setjmp
argument_list|()
expr_stmt|;
name|COND_EXPR_THEN
argument_list|(
name|t
argument_list|)
operator|=
name|next_sjlj_build_exc_extract
argument_list|(
name|rethrow_decl
argument_list|)
expr_stmt|;
name|COND_EXPR_ELSE
argument_list|(
name|t
argument_list|)
operator|=
name|next_sjlj_build_catch_list
argument_list|()
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|catch_seq
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|catch_seq
operator|=
name|next_sjlj_build_exc_extract
argument_list|(
name|rethrow_decl
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|catch_seq
argument_list|,
name|cur_try_context
operator|->
name|end_try_locus
argument_list|)
expr_stmt|;
comment|/* Build the main register-and-try if statement.  */
name|t
operator|=
name|next_sjlj_build_enter_and_setjmp
argument_list|()
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|cur_try_context
operator|->
name|try_locus
argument_list|)
expr_stmt|;
name|COND_EXPR_THEN
argument_list|(
name|t
argument_list|)
operator|=
name|catch_seq
expr_stmt|;
name|COND_EXPR_ELSE
argument_list|(
name|t
argument_list|)
operator|=
name|cur_try_context
operator|->
name|try_body
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|try_fin
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Build the complete FINALLY statement list.  */
name|t
operator|=
name|next_sjlj_build_try_exit
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_stmt
argument_list|(
name|COND_EXPR
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|rethrow_decl
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|cur_try_context
operator|->
name|finally_locus
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|try_fin
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|cur_try_context
operator|->
name|finally_body
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|try_fin
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|rethrow_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_call
argument_list|(
name|objc_exception_throw_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_stmt
argument_list|(
name|COND_EXPR
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|rethrow_decl
argument_list|)
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|cur_try_context
operator|->
name|end_finally_locus
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|try_fin
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bind
return|;
block|}
end_function

begin_comment
comment|/* Called just after parsing the @try and its associated BODY.  We now    must prepare for the tricky bits -- handling the catches and finally.  */
end_comment

begin_function
name|void
name|objc_begin_try_stmt
parameter_list|(
name|location_t
name|try_locus
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|struct
name|objc_try_context
modifier|*
name|c
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
decl_stmt|;
name|c
operator|->
name|outer
operator|=
name|cur_try_context
expr_stmt|;
name|c
operator|->
name|try_body
operator|=
name|body
expr_stmt|;
name|c
operator|->
name|try_locus
operator|=
name|try_locus
expr_stmt|;
name|c
operator|->
name|end_try_locus
operator|=
name|input_location
expr_stmt|;
name|cur_try_context
operator|=
name|c
expr_stmt|;
name|objc_init_exceptions
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_objc_sjlj_exceptions
condition|)
name|objc_mark_locals_volatile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called just after parsing "@catch (parm)".  Open a binding level,    enter DECL into the binding level, and initialize it.  Leave the    binding level open while the body of the compound statement is parsed.  */
end_comment

begin_function
name|void
name|objc_begin_catch_clause
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|compound
decl_stmt|,
name|type
decl_stmt|,
name|t
decl_stmt|;
comment|/* Begin a new scope that the entire catch clause will live in.  */
name|compound
operator|=
name|c_begin_compound_stmt
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* The parser passed in a PARM_DECL, but what we really want is a VAR_DECL.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Since a decl is required here by syntax, don't warn if its unused.  */
comment|/* ??? As opposed to __attribute__((unused))?  Anyway, this appears to      be what the previous objc implementation did.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Verify that the type of the catch is valid.  It must be a pointer      to an Objective-C class, or "id" (which is catch-all).  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|objc_is_object_id
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPED_OBJECT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"@catch parameter is not a known Objective-C class type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur_try_context
operator|->
name|catch_list
condition|)
block|{
comment|/* Examine previous @catch clauses and see if we've already 	 caught the type in question.  */
name|tree_stmt_iterator
name|i
init|=
name|tsi_start
argument_list|(
name|cur_try_context
operator|->
name|catch_list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|t
operator|=
name|CATCH_TYPES
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
operator|!
name|t
operator|||
name|DERIVED_FROM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"exception of type %<%T%> will be caught"
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%H   by earlier handler for %<%T%>"
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
condition|?
name|t
else|:
name|objc_object_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Record the data for the catch in the try context so that we can      finalize it later.  */
name|t
operator|=
name|build_stmt
argument_list|(
name|CATCH_EXPR
argument_list|,
name|type
argument_list|,
name|compound
argument_list|)
expr_stmt|;
name|cur_try_context
operator|->
name|current_catch
operator|=
name|t
expr_stmt|;
comment|/* Initialize the decl from the EXC_PTR_EXPR we get from the runtime.  */
name|t
operator|=
name|objc_build_exc_ptr
argument_list|()
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called just after parsing the closing brace of a @catch clause.  Close    the open binding level, and record a CATCH_EXPR for it.  */
end_comment

begin_function
name|void
name|objc_finish_catch_clause
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|c
init|=
name|cur_try_context
operator|->
name|current_catch
decl_stmt|;
name|cur_try_context
operator|->
name|current_catch
operator|=
name|NULL
expr_stmt|;
name|cur_try_context
operator|->
name|end_catch_locus
operator|=
name|input_location
expr_stmt|;
name|CATCH_BODY
argument_list|(
name|c
argument_list|)
operator|=
name|c_end_compound_stmt
argument_list|(
name|CATCH_BODY
argument_list|(
name|c
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|c
argument_list|,
operator|&
name|cur_try_context
operator|->
name|catch_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after parsing a @finally clause and its associated BODY.    Record the body for later placement.  */
end_comment

begin_function
name|void
name|objc_build_finally_clause
parameter_list|(
name|location_t
name|finally_locus
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|cur_try_context
operator|->
name|finally_body
operator|=
name|body
expr_stmt|;
name|cur_try_context
operator|->
name|finally_locus
operator|=
name|finally_locus
expr_stmt|;
name|cur_try_context
operator|->
name|end_finally_locus
operator|=
name|input_location
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called to finalize a @try construct.  */
end_comment

begin_function
name|tree
name|objc_finish_try_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objc_try_context
modifier|*
name|c
init|=
name|cur_try_context
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|catch_list
operator|==
name|NULL
operator|&&
name|c
operator|->
name|finally_body
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"%<@try%> without %<@catch%> or %<@finally%>"
argument_list|)
expr_stmt|;
comment|/* If we're doing Darwin setjmp exceptions, build the big nasty.  */
if|if
condition|(
name|flag_objc_sjlj_exceptions
condition|)
block|{
if|if
condition|(
operator|!
name|cur_try_context
operator|->
name|finally_body
condition|)
block|{
name|cur_try_context
operator|->
name|finally_locus
operator|=
name|input_location
expr_stmt|;
name|cur_try_context
operator|->
name|end_finally_locus
operator|=
name|input_location
expr_stmt|;
block|}
name|stmt
operator|=
name|next_sjlj_build_try_catch_finally
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, nest the CATCH inside a FINALLY.  */
name|stmt
operator|=
name|c
operator|->
name|try_body
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|catch_list
condition|)
block|{
name|stmt
operator|=
name|build_stmt
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|stmt
argument_list|,
name|c
operator|->
name|catch_list
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|cur_try_context
operator|->
name|try_locus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|finally_body
condition|)
block|{
name|stmt
operator|=
name|build_stmt
argument_list|(
name|TRY_FINALLY_EXPR
argument_list|,
name|stmt
argument_list|,
name|c
operator|->
name|finally_body
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|cur_try_context
operator|->
name|try_locus
argument_list|)
expr_stmt|;
block|}
block|}
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|cur_try_context
operator|=
name|c
operator|->
name|outer
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_function
name|tree
name|objc_build_throw_stmt
parameter_list|(
name|tree
name|throw_expr
parameter_list|)
block|{
name|tree
name|args
decl_stmt|;
name|objc_init_exceptions
argument_list|()
expr_stmt|;
if|if
condition|(
name|throw_expr
operator|==
name|NULL
condition|)
block|{
comment|/* If we're not inside a @catch block, there is no "current 	 exception" to be rethrown.  */
if|if
condition|(
name|cur_try_context
operator|==
name|NULL
operator|||
name|cur_try_context
operator|->
name|current_catch
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%<@throw%> (rethrow) used outside of a @catch block"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Otherwise the object is still sitting in the EXC_PTR_EXPR 	 value that we get from the runtime.  */
name|throw_expr
operator|=
name|objc_build_exc_ptr
argument_list|()
expr_stmt|;
block|}
comment|/* A throw is just a call to the runtime throw function with the      object as a parameter.  */
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|throw_expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_function_call
argument_list|(
name|objc_exception_throw_decl
argument_list|,
name|args
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|objc_build_synchronized
parameter_list|(
name|location_t
name|start_locus
parameter_list|,
name|tree
name|mutex
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|tree
name|args
decl_stmt|,
name|call
decl_stmt|;
comment|/* First lock the mutex.  */
name|mutex
operator|=
name|save_expr
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|call
operator|=
name|build_function_call
argument_list|(
name|objc_sync_enter_decl
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|call
argument_list|,
name|start_locus
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|/* Build the mutex unlock.  */
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|call
operator|=
name|build_function_call
argument_list|(
name|objc_sync_exit_decl
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|call
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
comment|/* Put the that and the body in a TRY_FINALLY.  */
name|objc_begin_try_stmt
argument_list|(
name|start_locus
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|objc_build_finally_clause
argument_list|(
name|input_location
argument_list|,
name|call
argument_list|)
expr_stmt|;
return|return
name|objc_finish_try_stmt
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Predefine the following data type:     struct _objc_exception_data    {      int buf[OBJC_JBLEN];      void *pointers[4];    }; */
end_comment

begin_comment
comment|/* The following yuckiness should prevent users from having to #include<setjmp.h> in their code... */
end_comment

begin_comment
comment|/* Define to a harmless positive value so the below code doesn't die.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_JBLEN
end_ifndef

begin_define
define|#
directive|define
name|OBJC_JBLEN
value|18
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|build_next_objc_exception_stuff
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|,
name|index
decl_stmt|,
name|temp_type
decl_stmt|;
name|objc_exception_data_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_EXCDATA
argument_list|)
argument_list|)
expr_stmt|;
comment|/* int buf[OBJC_JBLEN]; */
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|OBJC_JBLEN
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|index
argument_list|)
argument_list|,
literal|"buf"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* void *pointers[4]; */
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|4
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|index
argument_list|)
argument_list|,
literal|"pointers"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_exception_data_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int _setjmp(...); */
comment|/* If the user includes<setjmp.h>, this shall be superseded by      'int _setjmp(jmp_buf);' */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_setjmp_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_SETJMP
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* id objc_exception_extract(struct _objc_exception_data *); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|objc_exception_data_template
argument_list|)
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_extract_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONEXTRACT
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* void objc_exception_try_enter(struct _objc_exception_data *); */
comment|/* void objc_exception_try_exit(struct _objc_exception_data *); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|objc_exception_data_template
argument_list|)
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_try_enter_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONTRYENTER
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_exception_try_exit_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONTRYEXIT
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int objc_exception_match(id, id); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_match_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONMATCH
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* id objc_assign_ivar (id, id, unsigned int); */
comment|/* id objc_assign_ivar_Fast (id, id, unsigned int)        __attribute__ ((hard_coded_address (OFFS_ASSIGNIVAR_FAST))); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_assign_ivar_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_ASSIGNIVAR
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OFFS_ASSIGNIVAR_FAST
name|objc_assign_ivar_fast_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_ASSIGNIVAR_FAST
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_ATTRIBUTES
argument_list|(
name|objc_assign_ivar_fast_decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"hard_coded_address"
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|OFFS_ASSIGNIVAR_FAST
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Default to slower ivar method.  */
name|objc_assign_ivar_fast_decl
operator|=
name|objc_assign_ivar_decl
expr_stmt|;
endif|#
directive|endif
comment|/* id objc_assign_global (id, id *); */
comment|/* id objc_assign_strongCast (id, id *); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|objc_object_type
argument_list|)
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|objc_assign_global_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_ASSIGNGLOBAL
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|objc_assign_strong_cast_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_ASSIGNSTRONGCAST
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_objc_exception_stuff
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|noreturn_list
decl_stmt|,
name|nothrow_list
decl_stmt|,
name|temp_type
decl_stmt|;
name|noreturn_list
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"noreturn"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nothrow_list
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"nothrow"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* void objc_exception_throw(id) __attribute__((noreturn)); */
comment|/* void objc_sync_enter(id); */
comment|/* void objc_sync_exit(id); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
argument_list|)
expr_stmt|;
name|objc_exception_throw_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_EXCEPTIONTHROW
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|noreturn_list
argument_list|)
expr_stmt|;
name|objc_sync_enter_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_SYNCENTER
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|nothrow_list
argument_list|)
expr_stmt|;
name|objc_sync_exit_decl
operator|=
name|builtin_function
argument_list|(
name|TAG_SYNCEXIT
argument_list|,
name|temp_type
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|nothrow_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct a C struct corresponding to ObjC class CLASS, with the same    name as the class:     struct<classname> {      struct _objc_class *isa;      ...    };  */
end_comment

begin_function
specifier|static
name|void
name|build_private_template
parameter_list|(
name|tree
name|class
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|tree
name|record
init|=
name|objc_build_struct
argument_list|(
name|class
argument_list|,
name|get_class_ivars
argument_list|(
name|class
argument_list|,
name|false
argument_list|)
argument_list|,
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Set the TREE_USED bit for this struct, so that stab generator 	 can emit stabs for this struct type.  */
if|if
condition|(
name|flag_debug_only_used_symbols
operator|&&
name|TYPE_STUB_DECL
argument_list|(
name|record
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|record
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin code generation for protocols...  */
end_comment

begin_comment
comment|/* struct _objc_protocol {      struct _objc_class *isa;      char *protocol_name;      struct _objc_protocol **protocol_list;      struct _objc__method_prototype_list *instance_methods;      struct _objc__method_prototype_list *class_methods;    };  */
end_comment

begin_function
specifier|static
name|void
name|build_protocol_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_protocol_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct _objc_class *isa; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"isa"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *protocol_name; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"protocol_name"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc_protocol **protocol_list; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_protocol_template
argument_list|)
argument_list|)
argument_list|,
literal|"protocol_list"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc__method_prototype_list *instance_methods; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_method_proto_list_ptr
argument_list|,
literal|"instance_methods"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc__method_prototype_list *class_methods; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_method_proto_list_ptr
argument_list|,
literal|"class_methods"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_protocol_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_descriptor_table_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|entries
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|eltlist
init|=
name|NULL_TREE
decl_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_selector
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|entries
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|eltlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|eltlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|eltlist
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
condition|)
do|;
return|return
name|objc_build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* struct objc_method_prototype_list {      int count;      struct objc_method_prototype { 	SEL name; 	char *types;      } list[1];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_prototype_list_template
parameter_list|(
name|tree
name|list_type
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
comment|/* Generate an unnamed struct definition.  */
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int method_count; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|integer_type_node
argument_list|,
literal|"method_count"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_method method_list[]; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_array_type
argument_list|(
name|list_type
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"method_list"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_method_prototype_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|proto_record
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|proto_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD_PROTOTYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SEL _cmd; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_selector_type
argument_list|,
literal|"_cmd"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *method_types; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"method_types"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|proto_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|proto_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_method_parm_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objc_encoded_type_size
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|sz
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Make all integer and enum types at least as large      as an int.  */
if|if
condition|(
name|sz
operator|>
literal|0
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|sz
operator|=
name|MAX
argument_list|(
name|sz
argument_list|,
name|int_size_in_bytes
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Treat arrays as pointers, since that's how they're      passed in.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|sz
operator|=
name|int_size_in_bytes
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|encode_method_prototype
parameter_list|(
name|tree
name|method_decl
parameter_list|)
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|parm_offset
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* ONEWAY and BYCOPY, for remote object are the only method qualifiers.  */
name|encode_type_qualifiers
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encode return type.  */
name|encode_type
argument_list|(
name|objc_method_parm_type
argument_list|(
name|method_decl
argument_list|)
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Stack size.  */
comment|/* The first two arguments (self and _cmd) are pointers; account for      their size.  */
name|i
operator|=
name|int_size_in_bytes
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|parm_offset
operator|=
literal|2
operator|*
name|i
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|objc_method_parm_type
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|sz
init|=
name|objc_encoded_type_size
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If a type size is not known, bail out.  */
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"type %q+D does not have a known size"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Pretend that the encoding succeeded; the compilation will 	     fail nevertheless.  */
goto|goto
name|finish_encoding
goto|;
block|}
name|parm_offset
operator|+=
name|sz
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d@0:%d"
argument_list|,
name|parm_offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Argument types.  */
name|parm_offset
operator|=
literal|2
operator|*
name|i
expr_stmt|;
for|for
control|(
name|parms
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|objc_method_parm_type
argument_list|(
name|parms
argument_list|)
decl_stmt|;
comment|/* Process argument qualifiers for user supplied arguments.  */
name|encode_type_qualifiers
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Type.  */
name|encode_type
argument_list|(
name|type
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Compute offset.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|parm_offset
argument_list|)
expr_stmt|;
name|parm_offset
operator|+=
name|objc_encoded_type_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_encoding
label|:
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_descriptor_table
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|tree
name|list
parameter_list|,
name|tree
name|proto
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|type
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_method_descriptors
parameter_list|(
name|tree
name|protocol
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|chain
decl_stmt|,
name|method_list_template
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_method_prototype_template
condition|)
name|objc_method_prototype_template
operator|=
name|build_method_prototype_template
argument_list|()
expr_stmt|;
name|chain
operator|=
name|PROTOCOL_CLS_METHODS
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_prototype_list_template
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_descriptor_table_initializer
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_METHODS_decl
operator|=
name|generate_descriptor_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_PROTOCOL_CLASS_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_METHODS_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|PROTOCOL_NST_METHODS
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_prototype_list_template
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_descriptor_table_initializer
argument_list|(
name|objc_method_prototype_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_descriptor_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_PROTOCOL_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_METHODS_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_protocol_references
parameter_list|(
name|tree
name|plist
parameter_list|)
block|{
name|tree
name|lproto
decl_stmt|;
comment|/* Forward declare protocols referenced.  */
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|tree
name|proto
init|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|proto
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_NAME
argument_list|(
name|proto
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|proto
argument_list|)
condition|)
name|build_protocol_reference
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|proto
argument_list|)
condition|)
name|generate_protocol_references
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate either '- .cxx_construct' or '- .cxx_destruct' for the    current class.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJCPLUS
end_ifdef

begin_function
specifier|static
name|void
name|objc_generate_cxx_ctor_or_dtor
parameter_list|(
name|bool
name|dtor
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|,
name|body
decl_stmt|,
name|compound_stmt
decl_stmt|,
name|ivar
decl_stmt|;
comment|/* - (id) .cxx_construct { ... return self; } */
comment|/* - (void) .cxx_construct { ... }            */
name|objc_set_method_type
argument_list|(
name|MINUS_EXPR
argument_list|)
expr_stmt|;
name|objc_start_method_definition
argument_list|(
name|objc_build_method_signature
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|dtor
condition|?
name|void_type_node
else|:
name|objc_object_type
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
name|dtor
condition|?
name|TAG_CXX_DESTRUCT
else|:
name|TAG_CXX_CONSTRUCT
argument_list|)
argument_list|,
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ivar
operator|=
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
comment|/* Destroy ivars in reverse order.  */
if|if
condition|(
name|dtor
condition|)
name|ivar
operator|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|ivar
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ivar
condition|;
name|ivar
operator|=
name|TREE_CHAIN
argument_list|(
name|ivar
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ivar
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|ivar
argument_list|)
decl_stmt|;
comment|/* Call the ivar's default constructor or destructor.  Do not 	     call the destructor unless a corresponding constructor call 	     has also been made (or is not needed).  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|dtor
condition|?
operator|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
operator|)
else|:
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
operator|)
condition|)
name|finish_expr_stmt
argument_list|(
name|build_special_member_call
argument_list|(
name|build_ivar_reference
argument_list|(
name|DECL_NAME
argument_list|(
name|ivar
argument_list|)
argument_list|)
argument_list|,
name|dtor
condition|?
name|complete_dtor_identifier
else|:
name|complete_ctor_identifier
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The constructor returns 'self'.  */
if|if
condition|(
operator|!
name|dtor
condition|)
name|finish_return_stmt
argument_list|(
name|self_decl
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
name|finish_function_body
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|fn
operator|=
name|current_function_decl
expr_stmt|;
name|finish_function
argument_list|()
expr_stmt|;
name|objc_finish_method_definition
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following routine will examine the current @interface for any    non-POD C++ ivars requiring non-trivial construction and/or    destruction, and then synthesize special '- .cxx_construct' and/or    '- .cxx_destruct' methods which will run the appropriate    construction or destruction code.  Note that ivars inherited from    super-classes are _not_ considered.  */
end_comment

begin_function
specifier|static
name|void
name|objc_generate_cxx_cdtors
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|need_ctor
init|=
name|false
decl_stmt|,
name|need_dtor
init|=
name|false
decl_stmt|;
name|tree
name|ivar
decl_stmt|;
comment|/* We do not want to do this for categories, since they do not have      their own ivars.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|!=
name|CLASS_IMPLEMENTATION_TYPE
condition|)
return|return;
comment|/* First, determine if we even need a constructor and/or destructor.  */
for|for
control|(
name|ivar
operator|=
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
init|;
name|ivar
condition|;
name|ivar
operator|=
name|TREE_CHAIN
argument_list|(
name|ivar
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ivar
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|ivar
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
comment|/* NB: If a default constructor is not available, we will not 		   be able to initialize this ivar; the add_instance_variable() 		   routine will already have warned about this.  */
name|need_ctor
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
condition|)
comment|/* NB: If a default constructor is not available, we will not 		   call the destructor either, for symmetry.  */
name|need_dtor
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* Generate '- .cxx_construct' if needed.  */
if|if
condition|(
name|need_ctor
condition|)
name|objc_generate_cxx_ctor_or_dtor
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* Generate '- .cxx_destruct' if needed.  */
if|if
condition|(
name|need_dtor
condition|)
name|objc_generate_cxx_ctor_or_dtor
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* The 'imp_list' variable points at an imp_entry record for the current      @implementation.  Record the existence of '- .cxx_construct' and/or      '- .cxx_destruct' methods therein; it will be included in the      metadata for the class.  */
if|if
condition|(
name|flag_next_runtime
condition|)
name|imp_list
operator|->
name|has_cxx_cdtors
operator|=
operator|(
name|need_ctor
operator|||
name|need_dtor
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For each protocol which was referenced either from a @protocol()    expression, or because a class/category implements it (then a    pointer to the protocol is stored in the struct describing the    class/category), we create a statically allocated instance of the    Protocol class.  The code is written in such a way as to generate    as few Protocol objects as possible; we generate a unique Protocol    instance for each protocol, and we don't generate a Protocol    instance if the protocol is never referenced (either from a    @protocol() or from a class/category implementation).  These    statically allocated objects can be referred to via the static    (that is, private to this module) symbols _OBJC_PROTOCOL_n.     The statically allocated Protocol objects that we generate here    need to be fixed up at runtime in order to be used: the 'isa'    pointer of the objects need to be set up to point to the 'Protocol'    class, as known at runtime.     The NeXT runtime fixes up all protocols at program startup time,    before main() is entered.  It uses a low-level trick to look up all    those symbols, then loops on them and fixes them up.     The GNU runtime as well fixes up all protocols before user code    from the module is executed; it requires pointers to those symbols    to be put in the objc_symtab (which is then passed as argument to    the function __objc_exec_class() which the compiler sets up to be    executed automatically when the module is loaded); setup of those    Protocol objects happen in two ways in the GNU runtime: all    Protocol objects referred to by a class or category implementation    are fixed up when the class/category is loaded; all Protocol    objects referred to by a @protocol() expression are added by the    compiler to the list of statically allocated instances to fixup    (the same list holding the statically allocated constant string    objects).  Because, as explained above, the compiler generates as    few Protocol objects as possible, some Protocol object might end up    being referenced multiple times when compiled with the GNU runtime,    and end up being fixed up multiple times at runtime initialization.    But that doesn't hurt, it's just a little inefficient.  */
end_comment

begin_function
specifier|static
name|void
name|generate_protocols
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|p
decl_stmt|,
name|encoding
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|protocol_name_expr
decl_stmt|,
name|refs_decl
decl_stmt|,
name|refs_expr
decl_stmt|;
comment|/* If a protocol was directly referenced, pull in indirect references.  */
for|for
control|(
name|p
operator|=
name|protocol_chain
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
operator|&&
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|generate_protocol_references
argument_list|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|protocol_chain
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|nst_methods
init|=
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|tree
name|cls_methods
init|=
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If protocol wasn't referenced, don't generate any code.  */
name|decl
operator|=
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
continue|continue;
comment|/* Make sure we link in the Protocol class.  */
name|add_class_reference
argument_list|(
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nst_methods
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|nst_methods
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|nst_methods
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
name|nst_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cls_methods
condition|)
block|{
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|cls_methods
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|encode_method_prototype
argument_list|(
name|cls_methods
argument_list|)
expr_stmt|;
name|METHOD_ENCODING
argument_list|(
name|cls_methods
argument_list|)
operator|=
name|encoding
expr_stmt|;
block|}
name|cls_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|cls_methods
argument_list|)
expr_stmt|;
block|}
name|generate_method_descriptors
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
name|refs_decl
operator|=
name|generate_protocol_list
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|refs_decl
operator|=
literal|0
expr_stmt|;
comment|/* static struct objc_protocol _OBJC_PROTOCOL_<mumble>; */
name|protocol_name_expr
operator|=
name|add_objc_string
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs_decl
condition|)
name|refs_expr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_protocol_template
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|refs_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|refs_expr
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* UOBJC_INSTANCE_METHODS_decl/UOBJC_CLASS_METHODS_decl are set 	 by generate_method_descriptors, which is called above.  */
name|initlist
operator|=
name|build_protocol_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|protocol_name_expr
argument_list|,
name|refs_expr
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|build_protocol_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|protocol_name
parameter_list|,
name|tree
name|protocol_list
parameter_list|,
name|tree
name|instance_methods
parameter_list|,
name|tree
name|class_methods
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
name|tree
name|cast_type
init|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Filling the "isa" in with one allows the runtime system to      detect that the version change...should remove before final release.  */
name|expr
operator|=
name|build_int_cst
argument_list|(
name|cast_type
argument_list|,
name|PROTOCOL_VERSION
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|objc_method_proto_list_ptr
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance_methods
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|class_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|objc_method_proto_list_ptr
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_methods
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* struct _objc_category {      char *category_name;      char *class_name;      struct _objc_method_list *instance_methods;      struct _objc_method_list *class_methods;      struct _objc_protocol_list *protocols;    };   */
end_comment

begin_function
specifier|static
name|void
name|build_category_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_category_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CATEGORY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* char *category_name; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"category_name"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *class_name; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"class_name"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc_method_list *instance_methods; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_method_list_ptr
argument_list|,
literal|"instance_methods"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc_method_list *class_methods; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_method_list_ptr
argument_list|,
literal|"class_methods"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc_protocol **protocol_list; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_protocol_template
argument_list|)
argument_list|)
argument_list|,
literal|"protocol_list"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_category_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct _objc_selector {      SEL sel_id;      char *sel_type;    }; */
end_comment

begin_function
specifier|static
name|void
name|build_selector_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_selector_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SELECTOR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SEL sel_id; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_selector_type
argument_list|,
literal|"sel_id"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *sel_type; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"sel_type"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_selector_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct _objc_class {      struct _objc_class *isa;      struct _objc_class *super_class;      char *name;      long version;      long info;      long instance_size;      struct _objc_ivar_list *ivars;      struct _objc_method_list *methods;      #ifdef __NEXT_RUNTIME__        struct objc_cache *cache;      #else        struct sarray *dtable;        struct _objc_class *subclass_list;        struct _objc_class *sibling_class;      #endif      struct _objc_protocol_list *protocols;      #ifdef __NEXT_RUNTIME__        void *sel_id;      #endif      void *gc_object_type;    };  */
end_comment

begin_comment
comment|/* NB: The 'sel_id' and 'gc_object_type' fields are not being used by    the NeXT/Apple runtime; still, the compiler must generate them to    maintain backward binary compatibility (and to allow for future    expansion).  */
end_comment

begin_function
specifier|static
name|void
name|build_class_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_class_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_CLASS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct _objc_class *isa; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_class_template
argument_list|)
argument_list|,
literal|"isa"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct _objc_class *super_class; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_class_template
argument_list|)
argument_list|,
literal|"super_class"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char *name; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long version; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|long_integer_type_node
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long info; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|long_integer_type_node
argument_list|,
literal|"info"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long instance_size; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|long_integer_type_node
argument_list|,
literal|"instance_size"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc_ivar_list *ivars; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_ivar_list_ptr
argument_list|,
literal|"ivars"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct _objc_method_list *methods; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_method_list_ptr
argument_list|,
literal|"methods"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* struct objc_cache *cache; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
literal|"objc_cache"
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"cache"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* struct sarray *dtable; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
literal|"sarray"
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"dtable"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_class *subclass_list; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_class_template
argument_list|)
argument_list|,
literal|"subclass_list"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_class *sibling_class; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_class_template
argument_list|)
argument_list|,
literal|"sibling_class"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
comment|/* struct _objc_protocol **protocol_list; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_PROTOCOL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"protocol_list"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* void *sel_id; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
literal|"sel_id"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
block|}
comment|/* void *gc_object_type; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
literal|"gc_object_type"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_class_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate appropriate forward declarations for an implementation.  */
end_comment

begin_function
specifier|static
name|void
name|synth_forward_declarations
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|an_id
decl_stmt|;
comment|/* static struct objc_class _OBJC_CLASS_<my_name>; */
name|UOBJC_CLASS_decl
operator|=
name|build_metadata_decl
argument_list|(
literal|"_OBJC_CLASS"
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
comment|/* static struct objc_class _OBJC_METACLASS_<my_name>; */
name|UOBJC_METACLASS_decl
operator|=
name|build_metadata_decl
argument_list|(
literal|"_OBJC_METACLASS"
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
comment|/* Pre-build the following entities - for speed/convenience.  */
name|an_id
operator|=
name|get_identifier
argument_list|(
literal|"super_class"
argument_list|)
expr_stmt|;
name|ucls_super_ref
operator|=
name|objc_build_component_ref
argument_list|(
name|UOBJC_CLASS_decl
argument_list|,
name|an_id
argument_list|)
expr_stmt|;
name|uucls_super_ref
operator|=
name|objc_build_component_ref
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|,
name|an_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error_with_ivar
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|error
argument_list|(
literal|"%J%s %qs"
argument_list|,
name|decl
argument_list|,
name|message
argument_list|,
name|gen_declaration
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_ivars
parameter_list|(
name|tree
name|inter
parameter_list|,
name|tree
name|imp
parameter_list|)
block|{
name|tree
name|intdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|impdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|imp
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|intdecls
operator|&&
name|TREE_CODE
argument_list|(
name|intdecls
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|intdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|&&
name|impdecls
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|||
name|impdecls
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|DECL_INITIAL
argument_list|(
name|intdecls
argument_list|)
argument_list|,
name|DECL_INITIAL
argument_list|(
name|impdecls
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable type"
argument_list|,
name|impdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* both the type and the name don't match */
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable name"
argument_list|,
name|impdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|)
expr_stmt|;
block|}
name|intdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|impdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set 'objc_super_template' to the data type node for 'struct _objc_super'.    This needs to be done just once per compilation.  */
end_comment

begin_comment
comment|/* struct _objc_super {      struct _objc_object *self;      struct _objc_class *super_class;    };  */
end_comment

begin_function
specifier|static
name|void
name|build_super_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_super_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_SUPER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct _objc_object *self; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_object_type
argument_list|,
literal|"self"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct _objc_class *super_class; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_class_template
argument_list|)
argument_list|,
literal|"super_class"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_super_template
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct _objc_ivar {      char *ivar_name;      char *ivar_type;      int ivar_offset;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|objc_ivar_id
decl_stmt|,
name|objc_ivar_record
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_id
operator|=
name|get_identifier
argument_list|(
name|UTAG_IVAR
argument_list|)
expr_stmt|;
name|objc_ivar_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_ivar_id
argument_list|)
expr_stmt|;
comment|/* char *ivar_name; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"ivar_name"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *ivar_type; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"ivar_type"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* int ivar_offset; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|integer_type_node
argument_list|,
literal|"ivar_offset"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_record
return|;
block|}
end_function

begin_comment
comment|/* struct {      int ivar_count;      struct objc_ivar ivar_list[ivar_count];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_list_template
parameter_list|(
name|tree
name|list_type
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* int ivar_count; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|integer_type_node
argument_list|,
literal|"ivar_count"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_ivar ivar_list[]; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_array_type
argument_list|(
name|list_type
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"ivar_list"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_comment
comment|/* struct {      struct _objc__method_prototype_list *method_next;      int method_count;      struct objc_method method_list[method_count];    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_list_template
parameter_list|(
name|tree
name|list_type
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|tree
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* struct _objc__method_prototype_list *method_next; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_method_proto_list_ptr
argument_list|,
literal|"method_next"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* int method_count; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|integer_type_node
argument_list|,
literal|"method_count"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method method_list[]; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_array_type
argument_list|(
name|list_type
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"method_list"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_ivar_list_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|field_decl
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|ivar
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Set name.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
condition|)
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|meth_var_names
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
else|else
comment|/* Unnamed bit-field ivar (yuck).  */
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
comment|/* Set type.  */
name|encode_field_decl
argument_list|(
name|field_decl
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_DONT_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* Null terminate string.  */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
comment|/* Set offset.  */
name|ivar
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|byte_position
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|ivar
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
do|do
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
do|while
condition|(
name|field_decl
operator|&&
name|TREE_CODE
argument_list|(
name|field_decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
do|;
block|}
do|while
condition|(
name|field_decl
condition|)
do|;
return|return
name|objc_build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_ivars_list
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|type
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Count only the fields occurring in T.  */
end_comment

begin_function
specifier|static
name|int
name|ivar_list_length
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_ivar_lists
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|ivar_list_template
decl_stmt|,
name|chain
decl_stmt|;
name|int
name|size
decl_stmt|;
name|generating_instance_variables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|objc_ivar_template
condition|)
name|objc_ivar_template
operator|=
name|build_ivar_template
argument_list|()
expr_stmt|;
comment|/* Only generate class variables for the root of the inheritance      hierarchy since these will be the same for every class.  */
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|chain
operator|=
name|TYPE_FIELDS
argument_list|(
name|objc_class_template
argument_list|)
operator|)
condition|)
block|{
name|size
operator|=
name|ivar_list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|objc_ivar_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_CLASS_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|ivar_list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|objc_ivar_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_INSTANCE_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_INSTANCE_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
name|generating_instance_variables
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_dispatch_table_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|entries
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|;
do|do
block|{
name|tree
name|elemlist
init|=
name|NULL_TREE
decl_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_selector
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|entries
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Generate the method encoding if we don't have one already.  */
if|if
condition|(
operator|!
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
condition|)
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
operator|=
name|encode_method_prototype
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|add_objc_string
argument_list|(
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
argument_list|,
name|meth_var_types
argument_list|)
argument_list|,
name|elemlist
argument_list|)
expr_stmt|;
name|elemlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|METHOD_DEFINITION
argument_list|(
name|entries
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|elemlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|elemlist
argument_list|)
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
condition|)
do|;
return|return
name|objc_build_constructor
argument_list|(
name|build_array_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* To accomplish method prototyping without generating all kinds of    inane warnings, the definition of the dispatch table entries were    changed from:  	struct objc_method { SEL _cmd; ...; id (*_imp)(); };    to: 	struct objc_method { SEL _cmd; ...; void *_imp; };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_template
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|_SLT_record
decl_stmt|;
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|_SLT_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|UTAG_METHOD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SEL _cmd; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|objc_selector_type
argument_list|,
literal|"_cmd"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *method_types; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|string_type_node
argument_list|,
literal|"method_types"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* void *_imp; */
name|field_decl
operator|=
name|create_field_decl
argument_list|(
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
argument_list|,
literal|"_imp"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|_SLT_record
argument_list|,
name|field_decl_chain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|_SLT_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_dispatch_table
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|size
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|type
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_referenced_methods
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|METHOD_DEFINITION
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|METHOD_DEFINITION
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|generate_dispatch_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|,
name|chain
decl_stmt|,
name|method_list_template
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_method_template
condition|)
name|objc_method_template
operator|=
name|build_method_template
argument_list|()
expr_stmt|;
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|objc_method_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|UOBJC_CLASS_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
condition|?
literal|"_OBJC_CLASS_METHODS"
else|:
literal|"_OBJC_CATEGORY_CLASS_METHODS"
operator|)
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
else|else
name|UOBJC_CLASS_METHODS_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
name|list_length
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|objc_method_template
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
comment|/* We have a category.  */
name|UOBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_CATEGORY_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
else|else
name|UOBJC_INSTANCE_METHODS_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_protocol_list
parameter_list|(
name|tree
name|i_or_p
parameter_list|)
block|{
name|tree
name|initlist
decl_stmt|;
name|tree
name|refs_decl
decl_stmt|,
name|lproto
decl_stmt|,
name|e
decl_stmt|,
name|plist
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ref_name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|plist
operator|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|i_or_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
name|plist
operator|=
name|PROTOCOL_LIST
argument_list|(
name|i_or_p
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Compute size.  */
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
argument_list|)
condition|)
name|size
operator|++
expr_stmt|;
comment|/* Build initializer.  */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_int_cst
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_protocol_template
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
for|for
control|(
name|lproto
operator|=
name|plist
init|;
name|lproto
condition|;
name|lproto
operator|=
name|TREE_CHAIN
argument_list|(
name|lproto
argument_list|)
control|)
block|{
name|tree
name|pval
init|=
name|TREE_VALUE
argument_list|(
name|lproto
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|&&
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|pval
argument_list|)
condition|)
block|{
name|e
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|pval
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* static struct objc_protocol *refs[n]; */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
name|ref_name
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL_REFS"
argument_list|,
name|i_or_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
name|ref_name
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CLASS_PROTOCOLS"
argument_list|,
name|i_or_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i_or_p
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|ref_name
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY_PROTOCOLS"
argument_list|,
name|i_or_p
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|refs_decl
operator|=
name|start_var_decl
argument_list|(
name|build_array_type
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_protocol_template
argument_list|)
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ref_name
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|refs_decl
argument_list|,
name|objc_build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
name|refs_decl
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|refs_decl
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_category_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|cat_name
parameter_list|,
name|tree
name|class_name
parameter_list|,
name|tree
name|instance_methods
parameter_list|,
name|tree
name|class_methods
parameter_list|,
name|tree
name|protocol_list
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cat_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|objc_method_list_ptr
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance_methods
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|class_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|objc_method_list_ptr
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_methods
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* protocol_list = */
if|if
condition|(
operator|!
name|protocol_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_protocol_template
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|protocol_list
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* struct _objc_class {      struct objc_class *isa;      struct objc_class *super_class;      char *name;      long version;      long info;      long instance_size;      struct objc_ivar_list *ivars;      struct objc_method_list *methods;      if (flag_next_runtime)        struct objc_cache *cache;      else {        struct sarray *dtable;        struct objc_class *subclass_list;        struct objc_class *sibling_class;      }      struct objc_protocol_list *protocols;      if (flag_next_runtime)        void *sel_id;      void *gc_object_type;    };  */
end_comment

begin_function
specifier|static
name|tree
name|build_shared_structure_initializer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|isa
parameter_list|,
name|tree
name|super
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|size
parameter_list|,
name|int
name|status
parameter_list|,
name|tree
name|dispatch_table
parameter_list|,
name|tree
name|ivar_list
parameter_list|,
name|tree
name|protocol_list
parameter_list|)
block|{
name|tree
name|initlist
init|=
name|NULL_TREE
decl_stmt|,
name|expr
decl_stmt|;
comment|/* isa = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|isa
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* super_class = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|super
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* name = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|name
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* version = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|long_integer_type_node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* info = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|long_integer_type_node
argument_list|,
name|status
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* instance_size = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|long_integer_type_node
argument_list|,
name|size
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* objc_ivar_list = */
if|if
condition|(
operator|!
name|ivar_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|objc_ivar_list_ptr
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ivar_list
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* objc_method_list = */
if|if
condition|(
operator|!
name|dispatch_table
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|objc_method_list_ptr
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|dispatch_table
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
comment|/* method_cache = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* dtable = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* subclass_list = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* sibling_class = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* protocol_list = */
if|if
condition|(
operator|!
name|protocol_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|objc_protocol_template
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|protocol_list
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_next_runtime
condition|)
comment|/* sel_id = NULL */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* gc_object_type = NULL */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|objc_build_constructor
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve category interface CAT_NAME (if any) associated with CLASS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|lookup_category
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|cat_name
parameter_list|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
decl_stmt|;
while|while
condition|(
name|category
operator|&&
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
operator|!=
name|cat_name
condition|)
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
expr_stmt|;
return|return
name|category
return|;
block|}
end_function

begin_comment
comment|/* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_category
parameter_list|(
name|tree
name|cat
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|cat_name_expr
decl_stmt|,
name|class_name_expr
decl_stmt|;
name|tree
name|protocol_decl
decl_stmt|,
name|category
decl_stmt|;
name|add_class_reference
argument_list|(
name|CLASS_NAME
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
name|cat_name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|class_name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|cat
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|category
operator|=
name|lookup_category
argument_list|(
name|implementation_template
argument_list|,
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|&&
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
block|{
name|generate_protocol_references
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_decl
operator|=
name|generate_protocol_list
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
else|else
name|protocol_decl
operator|=
literal|0
expr_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|objc_category_template
argument_list|,
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|,
name|objc_implementation_context
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_category_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|cat_name_expr
argument_list|,
name|class_name_expr
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static struct objc_class _OBJC_METACLASS_Foo={ ... };    static struct objc_class _OBJC_CLASS_Foo={ ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_shared_structures
parameter_list|(
name|int
name|cls_flags
parameter_list|)
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|name_expr
decl_stmt|,
name|super_expr
decl_stmt|,
name|root_expr
decl_stmt|;
name|tree
name|my_root_id
init|=
name|NULL_TREE
decl_stmt|,
name|my_super_id
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cast_type
decl_stmt|,
name|initlist
decl_stmt|,
name|protocol_decl
decl_stmt|;
name|my_super_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_super_id
condition|)
block|{
name|add_class_reference
argument_list|(
name|my_super_id
argument_list|)
expr_stmt|;
comment|/* Compute "my_root_id" - this is required for code generation.          the "isa" for all meta class structures points to the root of          the inheritance hierarchy (e.g. "__Object")...  */
name|my_root_id
operator|=
name|my_super_id
expr_stmt|;
do|do
block|{
name|tree
name|my_root_int
init|=
name|lookup_interface
argument_list|(
name|my_root_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|my_root_int
operator|&&
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
condition|)
name|my_root_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
else|else
comment|/* No super class.  */
name|my_root_id
operator|=
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
name|cast_type
operator|=
name|build_pointer_type
argument_list|(
name|objc_class_template
argument_list|)
expr_stmt|;
name|name_expr
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
comment|/* Install class `isa' and `super' pointers at runtime.  */
if|if
condition|(
name|my_super_id
condition|)
block|{
name|super_expr
operator|=
name|add_objc_string
argument_list|(
name|my_super_id
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_c_cast
argument_list|(
name|cast_type
argument_list|,
name|super_expr
argument_list|)
expr_stmt|;
comment|/* cast! */
block|}
else|else
name|super_expr
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|root_expr
operator|=
name|add_objc_string
argument_list|(
name|my_root_id
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
name|root_expr
operator|=
name|build_c_cast
argument_list|(
name|cast_type
argument_list|,
name|root_expr
argument_list|)
expr_stmt|;
comment|/* cast! */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
condition|)
block|{
name|generate_protocol_references
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
name|protocol_decl
operator|=
name|generate_protocol_list
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
block|}
else|else
name|protocol_decl
operator|=
literal|0
expr_stmt|;
comment|/* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_class_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|objc_class_template
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|UOBJC_METACLASS_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|root_expr
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|objc_class_template
argument_list|)
argument_list|)
argument_list|,
literal|2
comment|/*CLS_META*/
argument_list|,
name|UOBJC_CLASS_METHODS_decl
argument_list|,
name|UOBJC_CLASS_VARIABLES_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* static struct objc_class _OBJC_CLASS_Foo={ ... }; */
name|decl
operator|=
name|start_var_decl
argument_list|(
name|objc_class_template
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|UOBJC_CLASS_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|UOBJC_METACLASS_decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
comment|/*CLS_FACTORY*/
operator||
name|cls_flags
argument_list|,
name|UOBJC_INSTANCE_METHODS_decl
argument_list|,
name|UOBJC_INSTANCE_VARIABLES_decl
argument_list|,
name|protocol_decl
argument_list|)
expr_stmt|;
name|finish_var_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|synth_id_with_class_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|preamble
parameter_list|,
name|tree
name|ctxt
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
name|BUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s"
argument_list|,
name|preamble
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|ctxt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
block|{
comment|/* We have a category.  */
specifier|const
name|char
modifier|*
specifier|const
name|class_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|class_super_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|preamble
argument_list|,
name|class_name
argument_list|,
name|class_super_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctxt
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
specifier|const
name|char
modifier|*
name|protocol_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|ctxt
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s"
argument_list|,
name|preamble
argument_list|,
name|protocol_name
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* If type is empty or only type qualifiers are present, add default    type of id (otherwise grokdeclarator will default to int).  */
end_comment

begin_function
specifier|static
name|tree
name|adjust_type_for_id_default
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|objc_object_type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPED_OBJECT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"can not use an object as parameter to a method"
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*   Usage: 		keyworddecl: 			selector ':' '(' typename ')' identifier       Purpose: 		Transform an Objective-C keyword argument into 		the C equivalent parameter declarator.       In:	key_name, an "identifier_node" (optional). 		arg_type, a  "tree_list" (optional). 		arg_name, an "identifier_node".       Note:	It would be really nice to strongly type the preceding 		arguments in the function prototype; however, then I 		could not use the "accessor" macros defined in "tree.h".       Out:	an instance of "keyword_decl".  */
end_comment

begin_function
name|tree
name|objc_build_keyword_decl
parameter_list|(
name|tree
name|key_name
parameter_list|,
name|tree
name|arg_type
parameter_list|,
name|tree
name|arg_name
parameter_list|)
block|{
name|tree
name|keyword_decl
decl_stmt|;
comment|/* If no type is specified, default to "id".  */
name|arg_type
operator|=
name|adjust_type_for_id_default
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|keyword_decl
operator|=
name|make_node
argument_list|(
name|KEYWORD_DECL
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_type
expr_stmt|;
name|KEYWORD_ARG_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_name
expr_stmt|;
name|KEYWORD_KEY_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|key_name
expr_stmt|;
return|return
name|keyword_decl
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of keyword_decl's, synthesize the full keyword selector.  */
end_comment

begin_function
specifier|static
name|tree
name|build_keyword_selector
parameter_list|(
name|tree
name|selector
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|tree
name|key_chain
decl_stmt|,
name|key_name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Scan the selector to see how much space we'll need.  */
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|len
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|key_name
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* Just a ':' arg.  */
name|len
operator|++
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Start the buffer out as an empty string.  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
comment|/* The keyword decl chain will later be used as a function argument 	     chain.  Unhook the selector itself so as to not confuse other 	     parts of the compiler.  */
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|key_name
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used for declarations and definitions.  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_decl
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|ret_type
parameter_list|,
name|tree
name|selector
parameter_list|,
name|tree
name|add_args
parameter_list|,
name|bool
name|ellipsis
parameter_list|)
block|{
name|tree
name|method_decl
decl_stmt|;
comment|/* If no type is specified, default to "id".  */
name|ret_type
operator|=
name|adjust_type_for_id_default
argument_list|(
name|ret_type
argument_list|)
expr_stmt|;
name|method_decl
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|method_decl
argument_list|)
operator|=
name|ret_type
expr_stmt|;
comment|/* If we have a keyword selector, create an identifier_node that      represents the full selector name (`:' included)...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|build_keyword_selector
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|add_args
expr_stmt|;
name|METHOD_ADD_ARGS_ELLIPSIS_P
argument_list|(
name|method_decl
argument_list|)
operator|=
name|ellipsis
expr_stmt|;
block|}
else|else
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|method_decl
return|;
block|}
end_function

begin_define
define|#
directive|define
name|METHOD_DEF
value|0
end_define

begin_define
define|#
directive|define
name|METHOD_REF
value|1
end_define

begin_comment
comment|/* Used by `build_objc_method_call' and `comp_proto_with_proto'.  Return    an argument list for method METH.  CONTEXT is either METHOD_DEF or    METHOD_REF, saying whether we are trying to define a method or call    one.  SUPERFLAG says this is for a send to super; this makes a    difference for the NeXT calling sequence in which the lookup and    the method call are done together.  If METH is null, user-defined    arguments (i.e., beyond self and _cmd) shall be represented by `...'.  */
end_comment

begin_function
specifier|static
name|tree
name|get_arg_type_list
parameter_list|(
name|tree
name|meth
parameter_list|,
name|int
name|context
parameter_list|,
name|int
name|superflag
parameter_list|)
block|{
name|tree
name|arglist
decl_stmt|,
name|akey
decl_stmt|;
comment|/* Receiver type.  */
if|if
condition|(
name|flag_next_runtime
operator|&&
name|superflag
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_super_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|==
name|METHOD_DEF
operator|&&
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_instance_type
argument_list|)
expr_stmt|;
else|else
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_object_type
argument_list|)
expr_stmt|;
comment|/* Selector type - will eventually change to `int'.  */
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|objc_selector_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No actual method prototype given -- assume that remaining arguments      are `...'.  */
if|if
condition|(
operator|!
name|meth
condition|)
return|return
name|arglist
return|;
comment|/* Build a list of argument types.  */
for|for
control|(
name|akey
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|meth
argument_list|)
init|;
name|akey
condition|;
name|akey
operator|=
name|TREE_CHAIN
argument_list|(
name|akey
argument_list|)
control|)
block|{
name|tree
name|arg_type
init|=
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|akey
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Decay arrays and functions into pointers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|arg_type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|arg_type
operator|=
name|build_pointer_type
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
condition|)
block|{
for|for
control|(
name|akey
operator|=
name|TREE_CHAIN
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
argument_list|)
init|;
name|akey
condition|;
name|akey
operator|=
name|TREE_CHAIN
argument_list|(
name|akey
argument_list|)
control|)
block|{
name|tree
name|arg_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|akey
argument_list|)
argument_list|)
decl_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|METHOD_ADD_ARGS_ELLIPSIS_P
argument_list|(
name|meth
argument_list|)
condition|)
goto|goto
name|lack_of_ellipsis
goto|;
block|}
else|else
block|{
name|lack_of_ellipsis
label|:
name|chainon
argument_list|(
name|arglist
argument_list|,
name|OBJC_VOID_AT_END
argument_list|)
expr_stmt|;
block|}
return|return
name|arglist
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|check_duplicates
parameter_list|(
name|hash
name|hsh
parameter_list|,
name|int
name|methods
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|tree
name|meth
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|hsh
condition|)
block|{
name|meth
operator|=
name|hsh
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
comment|/* We have two or more methods with the same name but 	     different types.  */
name|attr
name|loop
decl_stmt|;
comment|/* But just how different are those types?  If 	     -Wno-strict-selector-match is specified, we shall not 	     complain if the differences are solely among types with 	     identical size and alignment.  */
if|if
condition|(
operator|!
name|warn_strict_selector_match
condition|)
block|{
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|meth
argument_list|,
name|loop
operator|->
name|value
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|issue_warning
goto|;
return|return
name|meth
return|;
block|}
name|issue_warning
label|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"multiple %s named %<%c%s%> found"
argument_list|,
name|methods
condition|?
literal|"methods"
else|:
literal|"selectors"
argument_list|,
operator|(
name|is_class
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
name|methods
condition|?
literal|"using"
else|:
literal|"found"
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
operator|)
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"also found"
argument_list|,
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|loop
operator|->
name|value
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
operator|)
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|meth
return|;
block|}
end_function

begin_comment
comment|/* If RECEIVER is a class reference, return the identifier node for    the referenced class.  RECEIVER is created by objc_get_class_reference,    so we check the exact form created depending on which runtimes are    used.  */
end_comment

begin_function
specifier|static
name|tree
name|receiver_is_class_object
parameter_list|(
name|tree
name|receiver
parameter_list|,
name|int
name|self
parameter_list|,
name|int
name|super
parameter_list|)
block|{
name|tree
name|chain
decl_stmt|,
name|exp
decl_stmt|,
name|arg
decl_stmt|;
comment|/* The receiver is 'self' or 'super' in the context of a class method.  */
if|if
condition|(
name|objc_method_context
operator|&&
name|TREE_CODE
argument_list|(
name|objc_method_context
argument_list|)
operator|==
name|CLASS_METHOD_DECL
operator|&&
operator|(
name|self
operator|||
name|super
operator|)
condition|)
return|return
operator|(
name|super
condition|?
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
else|:
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|)
return|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* The receiver is a variable created by          build_class_reference_decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|IS_CLASS
argument_list|(
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
argument_list|)
condition|)
comment|/* Look up the identifier.  */
for|for
control|(
name|chain
operator|=
name|cls_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
operator|==
name|receiver
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
return|;
block|}
comment|/* The receiver is a function call that returns an id.  Check if      it is a call to objc_getClass, if so, pick up the class name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
comment|/* For some reason, we sometimes wind up with multiple FUNCTION_DECL 	 prototypes for objc_get_class().  Thankfully, they seem to share the 	 same function type.  */
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|objc_get_class_decl
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|TAG_GETCLASS
argument_list|)
comment|/* We have a call to objc_get_class/objc_getClass!  */
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|STRING_CST
condition|)
comment|/* Finally, we have the class name.  */
return|return
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are currently building a message expr, this holds    the identifier of the selector of the message.  This is    used when printing warnings about argument mismatches.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_objc_message_selector
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|objc_message_selector
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_objc_message_selector
return|;
block|}
end_function

begin_comment
comment|/* Construct an expression for sending a message.    MESS has the object to send to in TREE_PURPOSE    and the argument list (including selector) in TREE_VALUE.     (*(<abstract_decl>(*)())_msg)(receiver, selTransTbl[n], ...);    (*(<abstract_decl>(*)())_msgSuper)(receiver, selTransTbl[n], ...);  */
end_comment

begin_function
name|tree
name|objc_build_message_expr
parameter_list|(
name|tree
name|mess
parameter_list|)
block|{
name|tree
name|receiver
init|=
name|TREE_PURPOSE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
name|tree
name|sel_name
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
name|tree
name|args
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VALUE
argument_list|(
name|mess
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|tree
name|method_params
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Obtain the full selector name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* A unary selector.  */
name|sel_name
operator|=
name|args
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|sel_name
operator|=
name|build_keyword_selector
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Build the parameter list to give to the method.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
ifdef|#
directive|ifdef
name|OBJCPLUS
name|method_params
operator|=
name|chainon
argument_list|(
name|args
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|mess
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|tree
name|chain
init|=
name|args
decl_stmt|,
name|prev
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We have a keyword selector--check for comma expressions.  */
while|while
condition|(
name|chain
condition|)
block|{
name|tree
name|element
init|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
decl_stmt|;
comment|/* We have a comma expression, must collapse...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|element
expr_stmt|;
else|else
name|args
operator|=
name|element
expr_stmt|;
block|}
name|prev
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|method_params
operator|=
name|args
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Must wait until template instantiation time.  */
return|return
name|build_min_nt
argument_list|(
name|MESSAGE_SEND_EXPR
argument_list|,
name|receiver
argument_list|,
name|sel_name
argument_list|,
name|method_params
argument_list|)
return|;
endif|#
directive|endif
return|return
name|objc_finish_message_expr
argument_list|(
name|receiver
argument_list|,
name|sel_name
argument_list|,
name|method_params
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up method SEL_NAME that would be suitable for receiver    of type 'id' (if IS_CLASS is zero) or 'Class' (if IS_CLASS is    nonzero), and report on any duplicates.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_method_in_hash_lists
parameter_list|(
name|tree
name|sel_name
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|hash
name|method_prototype
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|is_class
condition|)
name|method_prototype
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|method_prototype
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
name|is_class
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|check_duplicates
argument_list|(
name|method_prototype
argument_list|,
literal|1
argument_list|,
name|is_class
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The 'objc_finish_message_expr' routine is called from within    'objc_build_message_expr' for non-template functions.  In the case of    C++ template functions, it is called from 'build_expr_from_tree'    (in decl2.c) after RECEIVER and METHOD_PARAMS have been expanded.  */
end_comment

begin_function
name|tree
name|objc_finish_message_expr
parameter_list|(
name|tree
name|receiver
parameter_list|,
name|tree
name|sel_name
parameter_list|,
name|tree
name|method_params
parameter_list|)
block|{
name|tree
name|method_prototype
init|=
name|NULL_TREE
decl_stmt|,
name|rprotos
init|=
name|NULL_TREE
decl_stmt|,
name|rtype
decl_stmt|;
name|tree
name|selector
decl_stmt|,
name|retval
decl_stmt|,
name|class_tree
decl_stmt|;
name|int
name|self
decl_stmt|,
name|super
decl_stmt|,
name|have_cast
decl_stmt|;
comment|/* Extract the receiver of the message, as well as its type      (where the latter may take the form of a cast or be inferred      from the implementation context).  */
name|rtype
operator|=
name|receiver
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|rtype
operator|=
name|TREE_OPERAND
argument_list|(
name|rtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|self
operator|=
operator|(
name|rtype
operator|==
name|self_decl
operator|)
expr_stmt|;
name|super
operator|=
operator|(
name|rtype
operator|==
name|UOBJC_SUPER_decl
operator|)
expr_stmt|;
name|rtype
operator|=
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|have_cast
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|NOP_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|!
name|IS_SUPER
argument_list|(
name|rtype
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* If we are calling [super dealloc], reset our warning flag.  */
if|if
condition|(
name|super
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"dealloc"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
condition|)
name|should_call_super_dealloc
operator|=
literal|0
expr_stmt|;
comment|/* If the receiver is a class object, retrieve the corresponding      @interface, if one exists. */
name|class_tree
operator|=
name|receiver_is_class_object
argument_list|(
name|receiver
argument_list|,
name|self
argument_list|,
name|super
argument_list|)
expr_stmt|;
comment|/* Now determine the receiver type (if an explicit cast has not been      provided).  */
if|if
condition|(
operator|!
name|have_cast
condition|)
block|{
if|if
condition|(
name|class_tree
condition|)
name|rtype
operator|=
name|lookup_interface
argument_list|(
name|class_tree
argument_list|)
expr_stmt|;
comment|/* Handle `self' and `super'.  */
elseif|else
if|if
condition|(
name|super
condition|)
block|{
if|if
condition|(
operator|!
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no super class declared in @interface for %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rtype
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|self
condition|)
name|rtype
operator|=
name|lookup_interface
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If receiver is of type `id' or `Class' (or if the @interface for a      class is not visible), we shall be satisfied with the existence of      any instance or class method. */
if|if
condition|(
name|objc_is_id
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|class_tree
operator|=
operator|(
name|IS_CLASS
argument_list|(
name|rtype
argument_list|)
condition|?
name|objc_class_name
else|:
name|NULL_TREE
operator|)
expr_stmt|;
name|rprotos
operator|=
operator|(
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
argument_list|)
condition|?
name|TYPE_OBJC_PROTOCOL_LIST
argument_list|(
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
name|rtype
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|rprotos
condition|)
block|{
comment|/* If messaging 'id<Protos>' or 'Class<Proto>', first search 	     in protocols themselves for the method prototype.  */
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|rprotos
argument_list|,
name|sel_name
argument_list|,
name|class_tree
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If messaging 'Class<Proto>' but did not find a class method 	     prototype, search for an instance method instead, and warn 	     about having done so.  */
if|if
condition|(
operator|!
name|method_prototype
operator|&&
operator|!
name|rtype
operator|&&
name|class_tree
operator|!=
name|NULL_TREE
condition|)
block|{
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|rprotos
argument_list|,
name|sel_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_prototype
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"found %<-%s%> instead of %<+%s%> in protocol(s)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rtype
condition|)
block|{
name|tree
name|orig_rtype
init|=
name|rtype
decl_stmt|,
name|saved_rtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|rtype
operator|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
comment|/* Traverse typedef aliases */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
condition|)
name|rtype
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
expr_stmt|;
name|saved_rtype
operator|=
name|rtype
expr_stmt|;
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|rprotos
operator|=
name|TYPE_OBJC_PROTOCOL_LIST
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|TYPE_OBJC_INTERFACE
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
block|}
comment|/* If we could not find an @interface declaration, we must have 	 only seen a @class declaration; so, we cannot say anything 	 more intelligent about which methods the receiver will 	 understand. */
if|if
condition|(
operator|!
name|rtype
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|rtype
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* We have a valid ObjC class name.  Look up the method name 	     in the published @interface for the class (and its 	     superclasses). */
name|method_prototype
operator|=
name|lookup_method_static
argument_list|(
name|rtype
argument_list|,
name|sel_name
argument_list|,
name|class_tree
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If the method was not found in the @interface, it may still 	     exist locally as part of the @implementation.  */
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|objc_implementation_context
operator|&&
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
condition|)
name|method_prototype
operator|=
name|lookup_method
argument_list|(
operator|(
name|class_tree
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
operator|)
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
comment|/* If we haven't found a candidate method by now, try looking for 	     it in the protocol list.  */
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|rprotos
condition|)
name|method_prototype
operator|=
name|lookup_method_in_protocol_list
argument_list|(
name|rprotos
argument_list|,
name|sel_name
argument_list|,
name|class_tree
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"invalid receiver type %qs"
argument_list|,
name|gen_type_name
argument_list|(
name|orig_rtype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* After issuing the "invalid receiver" warning, perform method 	     lookup as if we were messaging 'id'.  */
name|rtype
operator|=
name|rprotos
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* For 'id' or 'Class' receivers, search in the global hash table      as a last resort.  For all receivers, warn if protocol searches      have failed.  */
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
if|if
condition|(
name|rprotos
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<%c%s%> not found in protocol(s)"
argument_list|,
operator|(
name|class_tree
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtype
condition|)
name|method_prototype
operator|=
name|lookup_method_in_hash_lists
argument_list|(
name|sel_name
argument_list|,
name|class_tree
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
specifier|static
name|bool
name|warn_missing_methods
init|=
name|false
decl_stmt|;
if|if
condition|(
name|rtype
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qs may not respond to %<%c%s%>"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
argument_list|,
operator|(
name|class_tree
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are messaging an 'id' or 'Class' object and made it here, 	 then we have failed to find _any_ instance or class method, 	 respectively.  */
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"no %<%c%s%> method found"
argument_list|,
operator|(
name|class_tree
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|warn_missing_methods
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"(Messages without a matching method signature"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"will be assumed to return %<id%> and accept"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<...%> as arguments.)"
argument_list|)
expr_stmt|;
name|warn_missing_methods
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Save the selector name for printing error messages.  */
name|current_objc_message_selector
operator|=
name|sel_name
expr_stmt|;
comment|/* Build the parameters list for looking up the method.      These are the object itself and the selector.  */
if|if
condition|(
name|flag_typed_selectors
condition|)
name|selector
operator|=
name|build_typed_selector_reference
argument_list|(
name|sel_name
argument_list|,
name|method_prototype
argument_list|)
expr_stmt|;
else|else
name|selector
operator|=
name|build_selector_reference
argument_list|(
name|sel_name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_objc_method_call
argument_list|(
name|super
argument_list|,
name|method_prototype
argument_list|,
name|receiver
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
expr_stmt|;
name|current_objc_message_selector
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a tree expression to send OBJECT the operation SELECTOR,    looking up the method on object LOOKUP_OBJECT (often same as OBJECT),    assuming the method has prototype METHOD_PROTOTYPE.    (That is an INSTANCE_METHOD_DECL or CLASS_METHOD_DECL.)    Use METHOD_PARAMS as list of args to pass to the method.    If SUPER_FLAG is nonzero, we look up the superclass's method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_objc_method_call
parameter_list|(
name|int
name|super_flag
parameter_list|,
name|tree
name|method_prototype
parameter_list|,
name|tree
name|lookup_object
parameter_list|,
name|tree
name|selector
parameter_list|,
name|tree
name|method_params
parameter_list|)
block|{
name|tree
name|sender
init|=
operator|(
name|super_flag
condition|?
name|umsg_super_decl
else|:
operator|(
operator|!
name|flag_next_runtime
operator|||
name|flag_nil_receivers
condition|?
operator|(
name|flag_objc_direct_dispatch
condition|?
name|umsg_fast_decl
else|:
name|umsg_decl
operator|)
else|:
name|umsg_nonnil_decl
operator|)
operator|)
decl_stmt|;
name|tree
name|rcv_p
init|=
operator|(
name|super_flag
condition|?
name|objc_super_type
else|:
name|objc_object_type
operator|)
decl_stmt|;
comment|/* If a prototype for the method to be called exists, then cast      the sender's return type and arguments to match that of the method.      Otherwise, leave sender as is.  */
name|tree
name|ret_type
init|=
operator|(
name|method_prototype
condition|?
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_prototype
argument_list|)
argument_list|)
else|:
name|objc_object_type
operator|)
decl_stmt|;
name|tree
name|sender_cast
init|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|ret_type
argument_list|,
name|get_arg_type_list
argument_list|(
name|method_prototype
argument_list|,
name|METHOD_REF
argument_list|,
name|super_flag
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|method
decl_stmt|,
name|t
decl_stmt|;
name|lookup_object
operator|=
name|build_c_cast
argument_list|(
name|rcv_p
argument_list|,
name|lookup_object
argument_list|)
expr_stmt|;
comment|/* Use SAVE_EXPR to avoid evaluating the receiver twice.  */
name|lookup_object
operator|=
name|save_expr
argument_list|(
name|lookup_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_next_runtime
condition|)
block|{
comment|/* If we are returning a struct in memory, and the address 	 of that memory location is passed as a hidden first 	 argument, then change which messenger entry point this 	 expr will call.  NB: Note that sender_cast remains 	 unchanged (it already has a struct return type).  */
if|if
condition|(
operator|!
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|return_in_memory
argument_list|(
name|ret_type
argument_list|,
literal|0
argument_list|)
condition|)
name|sender
operator|=
operator|(
name|super_flag
condition|?
name|umsg_super_stret_decl
else|:
name|flag_nil_receivers
condition|?
name|umsg_stret_decl
else|:
name|umsg_nonnil_stret_decl
operator|)
expr_stmt|;
name|method_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
name|build_fold_addr_expr
argument_list|(
name|sender
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the portable (GNU) way.  */
name|tree
name|object
decl_stmt|;
comment|/* First, call the lookup function to get a pointer to the method, 	 then cast the pointer, then call it with the method arguments.  */
name|object
operator|=
operator|(
name|super_flag
condition|?
name|self_decl
else|:
name|lookup_object
operator|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lookup_object
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|method
operator|=
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pass the object to the method.  */
name|method_params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|object
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ??? Selector is not at this point something we can use inside      the compiler itself.  Set it to garbage for the nonce.  */
name|t
operator|=
name|build3
argument_list|(
name|OBJ_TYPE_REF
argument_list|,
name|sender_cast
argument_list|,
name|method
argument_list|,
name|lookup_object
argument_list|,
name|size_zero_node
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|t
argument_list|,
name|method_params
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|build_protocol_reference
parameter_list|(
name|tree
name|p
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto_name
decl_stmt|;
comment|/* static struct _objc_protocol _OBJC_PROTOCOL_<mumble>; */
name|proto_name
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_PROTOCOL"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_var_decl
argument_list|(
name|objc_protocol_template
argument_list|,
name|proto_name
argument_list|)
expr_stmt|;
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called by the parser when (and only when) a    @protocol() expression is found, in order to compile it.  */
end_comment

begin_function
name|tree
name|objc_build_protocol_expr
parameter_list|(
name|tree
name|protoname
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|p
init|=
name|lookup_protocol
argument_list|(
name|protoname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|error
argument_list|(
literal|"cannot find protocol declaration for %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|protoname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
condition|)
name|build_protocol_reference
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? Ideally we'd build the reference with objc_protocol_type directly,      if we have it, rather than converting it here.  */
name|expr
operator|=
name|convert
argument_list|(
name|objc_protocol_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* The @protocol() expression is being compiled into a pointer to a      statically allocated instance of the Protocol class.  To become      usable at runtime, the 'isa' pointer of the instance need to be      fixed up at runtime by the runtime library, to point to the      actual 'Protocol' class.  */
comment|/* For the GNU runtime, put the static Protocol instance in the list      of statically allocated instances, so that we make sure that its      'isa' pointer is fixed up at runtime by the GNU runtime library      to point to the Protocol class (at runtime, when loading the      module, the GNU runtime library loops on the statically allocated      instances (as found in the defs field in objc_symtab) and fixups      all the 'isa' pointers of those objects).  */
if|if
condition|(
operator|!
name|flag_next_runtime
condition|)
block|{
comment|/* This type is a struct containing the fields of a Protocol         object.  (Cfr. objc_protocol_type instead is the type of a pointer         to such a struct).  */
name|tree
name|protocol_struct_type
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|PROTOCOL_OBJECT_CLASS_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|chain
decl_stmt|;
comment|/* Look for the list of Protocol statically allocated instances         to fixup at runtime.  Create a new list to hold Protocol         statically allocated instances, if the list is not found.  At         present there is only another list, holding NSConstantString         static instances to be fixed up at runtime.  */
for|for
control|(
name|chain
operator|=
operator|&
name|objc_static_instances
init|;
operator|*
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|chain
argument_list|)
operator|!=
name|protocol_struct_type
condition|;
name|chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|chain
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|chain
condition|)
block|{
operator|*
name|chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|protocol_struct_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_objc_string
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|protocol_struct_type
argument_list|)
argument_list|,
name|class_names
argument_list|)
expr_stmt|;
block|}
comment|/* Add this statically allocated instance to the Protocol list.  */
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|PROTOCOL_FORWARD_DECL
argument_list|(
name|p
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
operator|*
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* This function is called by the parser when a @selector() expression    is found, in order to compile it.  It is only called by the parser    and only to compile a @selector().  */
end_comment

begin_function
name|tree
name|objc_build_selector_expr
parameter_list|(
name|tree
name|selnamelist
parameter_list|)
block|{
name|tree
name|selname
decl_stmt|;
comment|/* Obtain the full selector name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* A unary selector.  */
name|selname
operator|=
name|selnamelist
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|selname
operator|=
name|build_keyword_selector
argument_list|(
name|selnamelist
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If we are required to check @selector() expressions as they      are found, check that the selector has been declared.  */
if|if
condition|(
name|warn_undeclared_selector
condition|)
block|{
comment|/* Look the selector up in the list of all known class and          instance methods (up to this line) to check that the selector          exists.  */
name|hash
name|hsh
decl_stmt|;
comment|/* First try with instance methods.  */
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|selname
argument_list|)
expr_stmt|;
comment|/* If not found, try with class methods.  */
if|if
condition|(
operator|!
name|hsh
condition|)
block|{
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|selname
argument_list|)
expr_stmt|;
block|}
comment|/* If still not found, print out a warning.  */
if|if
condition|(
operator|!
name|hsh
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"undeclared selector %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|selname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_typed_selectors
condition|)
return|return
name|build_typed_selector_reference
argument_list|(
name|selname
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|build_selector_reference
argument_list|(
name|selname
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|objc_build_encode_expr
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|encode_type
argument_list|(
name|type
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* null terminate string */
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
comment|/* Synthesize a string that represents the encoded struct/union.  */
name|result
operator|=
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_ivar_reference
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_method_context
argument_list|)
operator|==
name|CLASS_METHOD_DECL
condition|)
block|{
comment|/* Historically, a class method that produced objects (factory 	 method) would assign `self' to the instance that it 	 allocated.  This would effectively turn the class method into 	 an instance method.  Following this assignment, the instance 	 variables could be accessed.  That practice, while safe, 	 violates the simple rule that a class method should not refer 	 to an instance variable.  It's better to catch the cases 	 where this is done unknowingly than to support the above 	 paradigm.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"instance variable %qs accessed in class method"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|self_decl
operator|=
name|convert
argument_list|(
name|objc_instance_type
argument_list|,
name|self_decl
argument_list|)
expr_stmt|;
comment|/* cast */
block|}
return|return
name|objc_build_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|self_decl
argument_list|,
literal|"->"
argument_list|)
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a hash value for a given method SEL_NAME.  */
end_comment

begin_function
specifier|static
name|size_t
name|hash_func
parameter_list|(
name|tree
name|sel_name
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
decl_stmt|;
name|size_t
name|h
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|h
operator|=
name|h
operator|*
literal|67
operator|+
operator|*
name|s
operator|++
operator|-
literal|113
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_init
parameter_list|(
name|void
parameter_list|)
block|{
name|nst_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|cls_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the hash table used to hold the constant string objects.  */
name|string_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|string_hash
argument_list|,
name|string_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Initialize the hash table used to hold EH-volatilized types.  */
name|volatilized_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|volatilized_hash
argument_list|,
name|volatilized_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WARNING!!!!  hash_enter is called with a method, and will peek    inside to find its selector!  But hash_lookup is given a selector    directly, and looks for the selector that's inside the found    entry's key (method) for comparison.  */
end_comment

begin_function
specifier|static
name|void
name|hash_enter
parameter_list|(
name|hash
modifier|*
name|hashlist
parameter_list|,
name|tree
name|method
parameter_list|)
block|{
name|hash
name|obj
decl_stmt|;
name|int
name|slot
init|=
name|hash_func
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|%
name|SIZEHASHTABLE
decl_stmt|;
name|obj
operator|=
operator|(
name|hash
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashed_entry
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|list
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|hashlist
index|[
name|slot
index|]
expr_stmt|;
name|obj
operator|->
name|key
operator|=
name|method
expr_stmt|;
name|hashlist
index|[
name|slot
index|]
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_function
specifier|static
name|hash
name|hash_lookup
parameter_list|(
name|hash
modifier|*
name|hashlist
parameter_list|,
name|tree
name|sel_name
parameter_list|)
block|{
name|hash
name|target
decl_stmt|;
name|target
operator|=
name|hashlist
index|[
name|hash_func
argument_list|(
name|sel_name
argument_list|)
operator|%
name|SIZEHASHTABLE
index|]
expr_stmt|;
while|while
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|sel_name
operator|==
name|METHOD_SEL_NAME
argument_list|(
name|target
operator|->
name|key
argument_list|)
condition|)
return|return
name|target
return|;
name|target
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_add_attr
parameter_list|(
name|hash
name|entry
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|attr
name|obj
decl_stmt|;
name|obj
operator|=
operator|(
name|attr
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashed_attribute
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|entry
operator|->
name|list
expr_stmt|;
name|obj
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|list
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|lookup_method
parameter_list|(
name|tree
name|mchain
parameter_list|,
name|tree
name|method
parameter_list|)
block|{
name|tree
name|key
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|key
operator|=
name|method
expr_stmt|;
else|else
name|key
operator|=
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
expr_stmt|;
while|while
condition|(
name|mchain
condition|)
block|{
if|if
condition|(
name|METHOD_SEL_NAME
argument_list|(
name|mchain
argument_list|)
operator|==
name|key
condition|)
return|return
name|mchain
return|;
name|mchain
operator|=
name|TREE_CHAIN
argument_list|(
name|mchain
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look up a class (if OBJC_LOOKUP_CLASS is set in FLAGS) or instance method    in INTERFACE, along with any categories and protocols attached thereto.    If method is not found, and the OBJC_LOOKUP_NO_SUPER is _not_ set in FLAGS,    recursively examine the INTERFACE's superclass.  If OBJC_LOOKUP_CLASS is    set, OBJC_LOOKUP_NO_SUPER is cleared, and no suitable class method could    be found in INTERFACE or any of its superclasses, look for an _instance_    method of the same name in the root class as a last resort.     If a suitable method cannot be found, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_method_static
parameter_list|(
name|tree
name|interface
parameter_list|,
name|tree
name|ident
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|meth
init|=
name|NULL_TREE
decl_stmt|,
name|root_inter
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|inter
init|=
name|interface
decl_stmt|;
name|int
name|is_class
init|=
operator|(
name|flags
operator|&
name|OBJC_LOOKUP_CLASS
operator|)
decl_stmt|;
name|int
name|no_superclasses
init|=
operator|(
name|flags
operator|&
name|OBJC_LOOKUP_NO_SUPER
operator|)
decl_stmt|;
while|while
condition|(
name|inter
condition|)
block|{
name|tree
name|chain
init|=
name|is_class
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|inter
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|category
init|=
name|inter
decl_stmt|;
comment|/* First, look up the method in the class itself.  */
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
comment|/* Failing that, look for the method in each category of the class.  */
while|while
condition|(
operator|(
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|)
condition|)
block|{
name|chain
operator|=
name|is_class
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
comment|/* Check directly in each category.  */
if|if
condition|(
operator|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
operator|)
condition|)
return|return
name|meth
return|;
comment|/* Failing that, check in each category's protocols.  */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|category
argument_list|)
argument_list|,
name|ident
argument_list|,
name|is_class
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
block|}
comment|/* If not found in categories, check in protocols of the main class.  */
if|if
condition|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|meth
operator|=
operator|(
name|lookup_method_in_protocol_list
argument_list|(
name|CLASS_PROTOCOL_LIST
argument_list|(
name|inter
argument_list|)
argument_list|,
name|ident
argument_list|,
name|is_class
argument_list|)
operator|)
operator|)
condition|)
return|return
name|meth
return|;
block|}
comment|/* If we were instructed not to look in superclasses, don't.  */
if|if
condition|(
name|no_superclasses
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Failing that, climb up the inheritance hierarchy.  */
name|root_inter
operator|=
name|inter
expr_stmt|;
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|inter
condition|)
empty_stmt|;
comment|/* If no class (factory) method was found, check if an _instance_      method of the same name exists in the root class.  This is what      the Objective-C runtime will do.  If an instance method was not      found, return 0.  */
return|return
name|is_class
condition|?
name|lookup_method_static
argument_list|(
name|root_inter
argument_list|,
name|ident
argument_list|,
literal|0
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Add the method to the hash list if it doesn't contain an identical    method already. */
end_comment

begin_function
specifier|static
name|void
name|add_method_to_hash_list
parameter_list|(
name|hash
modifier|*
name|hash_list
parameter_list|,
name|tree
name|method
parameter_list|)
block|{
name|hash
name|hsh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|hash_list
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Install on a global chain.  */
name|hash_enter
argument_list|(
name|hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check types against those; if different, add to a list.  */
name|attr
name|loop
decl_stmt|;
name|int
name|already_there
init|=
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|hsh
operator|->
name|key
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
operator|!
name|already_there
operator|&&
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|already_there
operator||=
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|loop
operator|->
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already_there
condition|)
name|hash_add_attr
argument_list|(
name|hsh
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_add_method
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|method
parameter_list|,
name|int
name|is_class
parameter_list|)
block|{
name|tree
name|mth
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mth
operator|=
name|lookup_method
argument_list|(
name|is_class
condition|?
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
else|:
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
argument_list|,
name|method
argument_list|)
operator|)
condition|)
block|{
comment|/* put method on list in reverse order */
if|if
condition|(
name|is_class
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* When processing an @interface for a class or category, give hard 	 errors on methods with identical selectors but differing argument 	 and/or return types. We do not do this for @implementations, because 	 C/C++ will do it for us (i.e., there will be duplicate function 	 definition errors).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
operator|)
operator|&&
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|mth
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate declaration of method %<%c%s%>"
argument_list|,
name|is_class
condition|?
literal|'+'
else|:
literal|'-'
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_class
condition|)
name|add_method_to_hash_list
argument_list|(
name|cls_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
else|else
block|{
name|add_method_to_hash_list
argument_list|(
name|nst_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
comment|/* Instance methods in root classes (and categories thereof) 	 may act as class methods as a last resort.  We also add 	 instance methods listed in @protocol declarations to 	 the class hash table, on the assumption that @protocols 	 may be adopted by root classes or categories.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|class
operator|=
name|lookup_interface
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
operator|||
operator|!
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
condition|)
name|add_method_to_hash_list
argument_list|(
name|cls_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
return|return
name|method
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|add_class
parameter_list|(
name|tree
name|class_name
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|struct
name|interface_tuple
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* Put interfaces on list in reverse order.  */
name|TREE_CHAIN
argument_list|(
name|class_name
argument_list|)
operator|=
name|interface_chain
expr_stmt|;
name|interface_chain
operator|=
name|class_name
expr_stmt|;
if|if
condition|(
name|interface_htab
operator|==
name|NULL
condition|)
name|interface_htab
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
name|hash_interface
argument_list|,
name|eq_interface
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|interface_tuple
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|interface_htab
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
block|{
operator|*
name|slot
operator|=
operator|(
expr|struct
name|interface_tuple
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|interface_tuple
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|id
operator|=
name|name
expr_stmt|;
block|}
operator|(
operator|*
name|slot
operator|)
operator|->
name|class_name
operator|=
name|class_name
expr_stmt|;
return|return
name|interface_chain
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_category
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|category
parameter_list|)
block|{
comment|/* Put categories on list in reverse order.  */
name|tree
name|cat
init|=
name|lookup_category
argument_list|(
name|class
argument_list|,
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cat
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"duplicate interface declaration for category %<%s(%s)%>"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
operator|=
name|category
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after parsing each instance variable declaration. Necessary to    preserve typedefs and implement public/private...     PUBLIC is 1 for public, 0 for protected, and 2 for private.  */
end_comment

begin_function
specifier|static
name|tree
name|add_instance_variable
parameter_list|(
name|tree
name|class
parameter_list|,
name|int
name|public
parameter_list|,
name|tree
name|field_decl
parameter_list|)
block|{
name|tree
name|field_type
init|=
name|TREE_TYPE
argument_list|(
name|field_decl
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ivar_name
init|=
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
argument_list|)
else|:
literal|"<unnamed>"
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"illegal reference type specified for instance variable %qs"
argument_list|,
name|ivar_name
argument_list|)
expr_stmt|;
comment|/* Return class as is without adding this ivar.  */
return|return
name|class
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|field_type
operator|==
name|error_mark_node
operator|||
operator|!
name|TYPE_SIZE
argument_list|(
name|field_type
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|field_type
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* 'type[0]' is allowed, but 'type[]' is not! */
block|{
name|error
argument_list|(
literal|"instance variable %qs has unknown size"
argument_list|,
name|ivar_name
argument_list|)
expr_stmt|;
comment|/* Return class as is without adding this ivar.  */
return|return
name|class
return|;
block|}
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* Check if the ivar being added has a non-POD C++ type.   If so, we will      need to either (1) warn the user about it or (2) generate suitable      constructor/destructor call from '- .cxx_construct' or '- .cxx_destruct'      methods (if '-fobjc-call-cxx-cdtors' was specified).  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|field_type
argument_list|)
operator|&&
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|field_type
argument_list|)
operator|||
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|field_type
argument_list|)
operator|||
name|TYPE_POLYMORPHIC_P
argument_list|(
name|field_type
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|type_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|field_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_objc_call_cxx_cdtors
condition|)
block|{
comment|/* Since the ObjC runtime will be calling the constructors and 	     destructors for us, the only thing we can't handle is the lack 	     of a default constructor.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|field_type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|field_type
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"type %qs has no default constructor to call"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
comment|/* If we cannot call a constructor, we should also avoid 		 calling the destructor, for symmetry.  */
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|field_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"destructor for %qs shall not be run either"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|static
name|bool
name|warn_cxx_ivars
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|field_type
argument_list|)
condition|)
block|{
comment|/* Vtable pointers are Real Bad(tm), since Obj-C cannot 		 initialize them.  */
name|error
argument_list|(
literal|"type %qs has virtual member functions"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"illegal aggregate type %qs specified "
literal|"for instance variable %qs"
argument_list|,
name|type_name
argument_list|,
name|ivar_name
argument_list|)
expr_stmt|;
comment|/* Return class as is without adding this ivar.  */
return|return
name|class
return|;
block|}
comment|/* User-defined constructors and destructors are not known to Obj-C 	     and hence will not be called.  This may or may not be a problem. */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|field_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"type %qs has a user-defined constructor"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|field_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"type %qs has a user-defined destructor"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|warn_cxx_ivars
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"C++ constructors and destructors will not "
literal|"be invoked for Objective-C fields"
argument_list|)
expr_stmt|;
name|warn_cxx_ivars
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Overload the public attribute, it is not used for FIELD_DECLs.  */
switch|switch
condition|(
name|public
condition|)
block|{
case|case
literal|0
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|is_ivar
parameter_list|(
name|tree
name|decl_chain
parameter_list|,
name|tree
name|ident
parameter_list|)
block|{
for|for
control|(
init|;
name|decl_chain
condition|;
name|decl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_chain
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl_chain
argument_list|)
operator|==
name|ident
condition|)
return|return
name|decl_chain
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* True if the ivar is private and we are not in its implementation.  */
end_comment

begin_function
specifier|static
name|int
name|is_private
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|is_ivar
argument_list|(
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We have an instance variable reference;, check to see if it is public.  */
end_comment

begin_function
name|int
name|objc_is_public
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|identifier
parameter_list|)
block|{
name|tree
name|basetype
decl_stmt|,
name|decl
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|processing_template_decl
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_OBJC_INFO
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_OBJC_INTERFACE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|class
init|=
name|lookup_interface
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|class
condition|)
block|{
name|error
argument_list|(
literal|"cannot find interface declaration for %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|OBJC_TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|decl
operator|=
name|is_ivar
argument_list|(
name|get_class_ivars
argument_list|(
name|class
argument_list|,
name|true
argument_list|)
argument_list|,
name|identifier
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Important difference between the Stepstone translator: 		 all instance variables should be public within the context 		 of the implementation.  */
if|if
condition|(
name|objc_implementation_context
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|)
operator|)
condition|)
block|{
name|tree
name|curtype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|basetype
operator|==
name|curtype
operator|||
name|DERIVED_FROM_P
argument_list|(
name|basetype
argument_list|,
name|curtype
argument_list|)
condition|)
block|{
name|int
name|private
init|=
name|is_private
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|private
condition|)
name|error
argument_list|(
literal|"instance variable %qs is declared private"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|private
return|;
block|}
block|}
comment|/* The 2.95.2 compiler sometimes allowed C functions to access 		 non-@public ivars.  We will let this slide for now...  */
if|if
condition|(
operator|!
name|objc_method_context
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"instance variable %qs is %s; "
literal|"this will be a hard error in the future"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|?
literal|"@private"
else|:
literal|"@protected"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|error
argument_list|(
literal|"instance variable %qs is declared %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|?
literal|"private"
else|:
literal|"protected"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure all entries in CHAIN are also in LIST.  */
end_comment

begin_function
specifier|static
name|int
name|check_methods
parameter_list|(
name|tree
name|chain
parameter_list|,
name|tree
name|list
parameter_list|,
name|int
name|mtype
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_method
argument_list|(
name|list
argument_list|,
name|chain
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"incomplete implementation of class %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"incomplete implementation of category %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|warning
argument_list|(
literal|0
argument_list|,
literal|"method definition for %<%c%s%> not found"
argument_list|,
name|mtype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Check if CLASS, or its superclasses, explicitly conforms to PROTOCOL.  */
end_comment

begin_function
specifier|static
name|int
name|conforms_to_protocol
parameter_list|(
name|tree
name|class
parameter_list|,
name|tree
name|protocol
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|protocol
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|tree
name|p
init|=
name|CLASS_PROTOCOL_LIST
argument_list|(
name|class
argument_list|)
decl_stmt|;
while|while
condition|(
name|p
operator|&&
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|!=
name|protocol
condition|)
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|tree
name|super
init|=
operator|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
decl_stmt|;
name|int
name|tmp
init|=
name|super
condition|?
name|conforms_to_protocol
argument_list|(
name|super
argument_list|,
name|protocol
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make sure all methods in CHAIN are accessible as MTYPE methods in    CONTEXT.  This is one of two mechanisms to check protocol integrity.  */
end_comment

begin_function
specifier|static
name|int
name|check_methods_accessible
parameter_list|(
name|tree
name|chain
parameter_list|,
name|tree
name|context
parameter_list|,
name|int
name|mtype
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|base_context
init|=
name|context
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
name|context
operator|=
name|base_context
expr_stmt|;
while|while
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|mtype
operator|==
literal|'+'
condition|)
name|list
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|list
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_method
argument_list|(
name|list
argument_list|,
name|chain
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
name|context
operator|=
operator|(
name|CLASS_SUPER_NAME
argument_list|(
name|context
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|CATEGORY_INTERFACE_TYPE
condition|)
name|context
operator|=
operator|(
name|CLASS_NAME
argument_list|(
name|context
argument_list|)
condition|?
name|lookup_interface
argument_list|(
name|CLASS_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"incomplete implementation of class %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|objc_implementation_context
argument_list|)
operator|==
name|CATEGORY_IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"incomplete implementation of category %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|warning
argument_list|(
literal|0
argument_list|,
literal|"method definition for %<%c%s%> not found"
argument_list|,
name|mtype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* next method...  */
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Check whether the current interface (accessible via    'objc_implementation_context') actually implements protocol P, along    with any protocols that P inherits.  */
end_comment

begin_function
specifier|static
name|void
name|check_protocol
parameter_list|(
name|tree
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PROTOCOL_INTERFACE_TYPE
condition|)
block|{
name|int
name|f1
decl_stmt|,
name|f2
decl_stmt|;
comment|/* Ensure that all protocols have bodies!  */
if|if
condition|(
name|warn_protocol
condition|)
block|{
name|f1
operator|=
name|check_methods
argument_list|(
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|CLASS_CLS_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|f2
operator|=
name|check_methods
argument_list|(
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|CLASS_NST_METHODS
argument_list|(
name|objc_implementation_context
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f1
operator|=
name|check_methods_accessible
argument_list|(
name|PROTOCOL_CLS_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|objc_implementation_context
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|f2
operator|=
name|check_methods_accessible
argument_list|(
name|PROTOCOL_NST_METHODS
argument_list|(
name|p
argument_list|)
argument_list|,
name|objc_implementation_context
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1
operator|||
operator|!
name|f2
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%s %qs does not fully implement the %qs protocol"
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|PROTOCOL_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check protocols recursively.  */
if|if
condition|(
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|tree
name|subs
init|=
name|PROTOCOL_LIST
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|tree
name|super_class
init|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|subs
condition|)
block|{
name|tree
name|sub
init|=
name|TREE_VALUE
argument_list|(
name|subs
argument_list|)
decl_stmt|;
comment|/* If the superclass does not conform to the protocols 	     inherited by P, then we must!  */
if|if
condition|(
operator|!
name|super_class
operator|||
operator|!
name|conforms_to_protocol
argument_list|(
name|super_class
argument_list|,
name|sub
argument_list|)
condition|)
name|check_protocol
argument_list|(
name|sub
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|subs
operator|=
name|TREE_CHAIN
argument_list|(
name|subs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check whether the current interface (accessible via    'objc_implementation_context') actually implements the protocols listed    in PROTO_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|check_protocols
parameter_list|(
name|tree
name|proto_list
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
for|for
control|(
init|;
name|proto_list
condition|;
name|proto_list
operator|=
name|TREE_CHAIN
argument_list|(
name|proto_list
argument_list|)
control|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|proto_list
argument_list|)
decl_stmt|;
name|check_protocol
argument_list|(
name|p
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the class CLASS_NAME is defined    CODE says which kind of thing CLASS_NAME ought to be.    It can be CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,    CATEGORY_INTERFACE_TYPE, or CATEGORY_IMPLEMENTATION_TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|start_class
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|class_name
parameter_list|,
name|tree
name|super_name
parameter_list|,
name|tree
name|protocol_list
parameter_list|)
block|{
name|tree
name|class
decl_stmt|,
name|decl
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJCPLUS
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
block|{
name|error
argument_list|(
literal|"Objective-C declarations may only appear in global scope"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJCPLUS */
if|if
condition|(
name|objc_implementation_context
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<@end%> missing in implementation context"
argument_list|)
expr_stmt|;
name|finish_class
argument_list|(
name|objc_implementation_context
argument_list|)
expr_stmt|;
name|objc_ivar_chain
operator|=
name|NULL_TREE
expr_stmt|;
name|objc_implementation_context
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|class
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TYPE_LANG_SLOT_1
argument_list|(
name|class
argument_list|)
operator|=
name|make_tree_vec
argument_list|(
name|CLASS_LANG_SLOT_ELTS
argument_list|)
expr_stmt|;
comment|/* Check for existence of the super class, if one was specified.  Note      that we must have seen an @interface, not just a @class.  If we      are looking at a @compatibility_alias, traverse it first.  */
if|if
condition|(
operator|(
name|code
operator|==
name|CLASS_INTERFACE_TYPE
operator|||
name|code
operator|==
name|CLASS_IMPLEMENTATION_TYPE
operator|)
operator|&&
name|super_name
condition|)
block|{
name|tree
name|super
init|=
name|objc_is_class_name
argument_list|(
name|super_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|super
operator|||
operator|!
name|lookup_interface
argument_list|(
name|super
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot find interface declaration for %qs, superclass of %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super
condition|?
name|super
else|:
name|super_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|super_name
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|super_name
operator|=
name|super
expr_stmt|;
block|}
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|class_name
expr_stmt|;
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|super_name
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|objc_is_class_name
argument_list|(
name|class_name
argument_list|)
operator|&&
operator|(
name|decl
operator|=
name|lookup_name
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%qs redeclared as different kind of symbol"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|CLASS_IMPLEMENTATION_TYPE
condition|)
block|{
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|implemented_classes
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|==
name|class_name
condition|)
block|{
name|error
argument_list|(
literal|"reimplementation of class %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|implemented_classes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_name
argument_list|,
name|implemented_classes
argument_list|)
expr_stmt|;
block|}
comment|/* Reset for multiple classes per file.  */
name|method_slot
operator|=
literal|0
expr_stmt|;
name|objc_implementation_context
operator|=
name|class
expr_stmt|;
comment|/* Lookup the interface for this implementation.  */
if|if
condition|(
operator|!
operator|(
name|implementation_template
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"cannot find interface declaration for %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|add_class
argument_list|(
name|implementation_template
operator|=
name|objc_implementation_context
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
block|}
comment|/* If a super class has been specified in the implementation, 	 insure it conforms to the one specified in the interface.  */
if|if
condition|(
name|super_name
operator|&&
operator|(
name|super_name
operator|!=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|)
condition|)
block|{
name|tree
name|previous_name
init|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|previous_name
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|previous_name
argument_list|)
else|:
literal|""
decl_stmt|;
name|error
argument_list|(
literal|"conflicting super class name %qs"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|super_name
condition|)
block|{
name|CLASS_SUPER_NAME
argument_list|(
name|objc_implementation_context
argument_list|)
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CLASS_INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|OBJCPLUS
name|error
argument_list|(
literal|"duplicate interface declaration for class %qs"
argument_list|,
else|#
directive|else
argument|warning (
literal|0
argument|,
literal|"duplicate interface declaration for class %qs"
argument|,
endif|#
directive|endif
argument|IDENTIFIER_POINTER (class_name));       else         add_class (class, class_name);        if (protocol_list) 	CLASS_PROTOCOL_LIST (class) 	  = lookup_and_install_protocols (protocol_list);     }    else if (code == CATEGORY_INTERFACE_TYPE)     {       tree class_category_is_assoc_with;
comment|/* For a category, class_name is really the name of the class that 	 the following set of methods will be associated with. We must 	 find the interface so that can derive the objects template.  */
argument|if (!(class_category_is_assoc_with = lookup_interface (class_name))) 	{ 	  error (
literal|"cannot find interface declaration for %qs"
argument|, 		 IDENTIFIER_POINTER (class_name)); 	  exit (FATAL_EXIT_CODE); 	}       else         add_category (class_category_is_assoc_with, class);        if (protocol_list) 	CLASS_PROTOCOL_LIST (class) 	  = lookup_and_install_protocols (protocol_list);     }    else if (code == CATEGORY_IMPLEMENTATION_TYPE)     {
comment|/* Reset for multiple classes per file.  */
argument|method_slot =
literal|0
argument|;        objc_implementation_context = class;
comment|/* For a category, class_name is really the name of the class that 	 the following set of methods will be associated with.  We must 	 find the interface so that can derive the objects template.  */
argument|if (!(implementation_template = lookup_interface (class_name)))         { 	  error (
literal|"cannot find interface declaration for %qs"
argument|, 		 IDENTIFIER_POINTER (class_name)); 	  exit (FATAL_EXIT_CODE);         }     }   return class; }  static tree continue_class (tree class) {   if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE       || TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)     {       struct imp_entry *imp_entry;
comment|/* Check consistency of the instance variables.  */
argument|if (CLASS_RAW_IVARS (class)) 	check_ivars (implementation_template, class);
comment|/* code generation */
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|push_lang_context (lang_name_c);
endif|#
directive|endif
argument|build_private_template (implementation_template);       uprivate_record = CLASS_STATIC_TEMPLATE (implementation_template);       objc_instance_type = build_pointer_type (uprivate_record);        imp_entry = (struct imp_entry *) ggc_alloc (sizeof (struct imp_entry));        imp_entry->next = imp_list;       imp_entry->imp_context = class;       imp_entry->imp_template = implementation_template;        synth_forward_declarations ();       imp_entry->class_decl = UOBJC_CLASS_decl;       imp_entry->meta_decl = UOBJC_METACLASS_decl;       imp_entry->has_cxx_cdtors =
literal|0
argument|;
comment|/* Append to front and increment count.  */
argument|imp_list = imp_entry;       if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE) 	imp_count++;       else 	cat_count++;
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|pop_lang_context ();
endif|#
directive|endif
comment|/* OBJCPLUS */
argument|return get_class_ivars (implementation_template, true);     }    else if (TREE_CODE (class) == CLASS_INTERFACE_TYPE)     {
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|push_lang_context (lang_name_c);
endif|#
directive|endif
comment|/* OBJCPLUS */
argument|build_private_template (class);
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|pop_lang_context ();
endif|#
directive|endif
comment|/* OBJCPLUS */
argument|return NULL_TREE;     }    else     return error_mark_node; }
comment|/* This is called once we see the "@end" in an interface/implementation.  */
argument|static void finish_class (tree class) {   if (TREE_CODE (class) == CLASS_IMPLEMENTATION_TYPE)     {
comment|/* All code generation is done in finish_objc.  */
argument|if (implementation_template != objc_implementation_context) 	{
comment|/* Ensure that all method listed in the interface contain bodies.  */
argument|check_methods (CLASS_CLS_METHODS (implementation_template), 			 CLASS_CLS_METHODS (objc_implementation_context),
literal|'+'
argument|); 	  check_methods (CLASS_NST_METHODS (implementation_template), 			 CLASS_NST_METHODS (objc_implementation_context),
literal|'-'
argument|);  	  if (CLASS_PROTOCOL_LIST (implementation_template)) 	    check_protocols (CLASS_PROTOCOL_LIST (implementation_template),
literal|"class"
argument|, 			     IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context))); 	}     }    else if (TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)     {       tree category = lookup_category (implementation_template, CLASS_SUPER_NAME (class));        if (category) 	{
comment|/* Ensure all method listed in the interface contain bodies.  */
argument|check_methods (CLASS_CLS_METHODS (category), 			 CLASS_CLS_METHODS (objc_implementation_context),
literal|'+'
argument|); 	  check_methods (CLASS_NST_METHODS (category), 			 CLASS_NST_METHODS (objc_implementation_context),
literal|'-'
argument|);  	  if (CLASS_PROTOCOL_LIST (category)) 	    check_protocols (CLASS_PROTOCOL_LIST (category),
literal|"category"
argument|, 			     IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context))); 	}     } }  static tree add_protocol (tree protocol) {
comment|/* Put protocol on list in reverse order.  */
argument|TREE_CHAIN (protocol) = protocol_chain;   protocol_chain = protocol;   return protocol_chain; }  static tree lookup_protocol (tree ident) {   tree chain;    for (chain = protocol_chain; chain; chain = TREE_CHAIN (chain))     if (ident == PROTOCOL_NAME (chain))       return chain;    return NULL_TREE; }
comment|/* This function forward declares the protocols named by NAMES.  If    they are already declared or defined, the function has no effect.  */
argument|void objc_declare_protocols (tree names) {   tree list;
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|if (current_namespace != global_namespace) {     error (
literal|"Objective-C declarations may only appear in global scope"
argument|);   }
endif|#
directive|endif
comment|/* OBJCPLUS */
argument|for (list = names; list; list = TREE_CHAIN (list))     {       tree name = TREE_VALUE (list);        if (lookup_protocol (name) == NULL_TREE) 	{ 	  tree protocol = make_node (PROTOCOL_INTERFACE_TYPE);  	  TYPE_LANG_SLOT_1 (protocol) 	    = make_tree_vec (PROTOCOL_LANG_SLOT_ELTS); 	  PROTOCOL_NAME (protocol) = name; 	  PROTOCOL_LIST (protocol) = NULL_TREE; 	  add_protocol (protocol); 	  PROTOCOL_DEFINED (protocol) =
literal|0
argument|; 	  PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE; 	}     } }  static tree start_protocol (enum tree_code code, tree name, tree list) {   tree protocol;
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|if (current_namespace != global_namespace) {     error (
literal|"Objective-C declarations may only appear in global scope"
argument|);   }
endif|#
directive|endif
comment|/* OBJCPLUS */
argument|protocol = lookup_protocol (name);    if (!protocol)     {       protocol = make_node (code);       TYPE_LANG_SLOT_1 (protocol) = make_tree_vec (PROTOCOL_LANG_SLOT_ELTS);        PROTOCOL_NAME (protocol) = name;       PROTOCOL_LIST (protocol) = lookup_and_install_protocols (list);       add_protocol (protocol);       PROTOCOL_DEFINED (protocol) =
literal|1
argument|;       PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE;        check_protocol_recursively (protocol, list);     }   else if (! PROTOCOL_DEFINED (protocol))     {       PROTOCOL_DEFINED (protocol) =
literal|1
argument|;       PROTOCOL_LIST (protocol) = lookup_and_install_protocols (list);        check_protocol_recursively (protocol, list);     }   else     {       warning (
literal|0
argument|,
literal|"duplicate declaration for protocol %qs"
argument|, 	       IDENTIFIER_POINTER (name));     }   return protocol; }
comment|/* "Encode" a data type into a string, which grows in util_obstack.    ??? What is the FORMAT?  Someone please document this!  */
argument|static void encode_type_qualifiers (tree declspecs) {   tree spec;    for (spec = declspecs; spec; spec = TREE_CHAIN (spec))     {       if (ridpointers[(int) RID_IN] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'n'
argument|);       else if (ridpointers[(int) RID_INOUT] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'N'
argument|);       else if (ridpointers[(int) RID_OUT] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'o'
argument|);       else if (ridpointers[(int) RID_BYCOPY] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'O'
argument|);       else if (ridpointers[(int) RID_BYREF] == TREE_VALUE (spec))         obstack_1grow (&util_obstack,
literal|'R'
argument|);       else if (ridpointers[(int) RID_ONEWAY] == TREE_VALUE (spec)) 	obstack_1grow (&util_obstack,
literal|'V'
argument|);     } }
comment|/* Encode a pointer type.  */
argument|static void encode_pointer (tree type, int curtype, int format) {   tree pointer_to = TREE_TYPE (type);    if (TREE_CODE (pointer_to) == RECORD_TYPE)     {       if (OBJC_TYPE_NAME (pointer_to)&& TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE) 	{ 	  const char *name = IDENTIFIER_POINTER (OBJC_TYPE_NAME (pointer_to));  	  if (strcmp (name, TAG_OBJECT) ==
literal|0
argument|)
comment|/* '@' */
argument|{ 	      obstack_1grow (&util_obstack,
literal|'@'
argument|); 	      return; 	    } 	  else if (TYPE_HAS_OBJC_INFO (pointer_to)&& TYPE_OBJC_INTERFACE (pointer_to)) 	    {               if (generating_instance_variables) 	        { 	          obstack_1grow (&util_obstack,
literal|'@'
argument|); 	          obstack_1grow (&util_obstack,
literal|'"'
argument|); 	          obstack_grow (&util_obstack, name, strlen (name)); 	          obstack_1grow (&util_obstack,
literal|'"'
argument|); 	          return; 		}               else 	        { 	          obstack_1grow (&util_obstack,
literal|'@'
argument|); 	          return; 		} 	    } 	  else if (strcmp (name, TAG_CLASS) ==
literal|0
argument|)
comment|/* '#' */
argument|{ 	      obstack_1grow (&util_obstack,
literal|'#'
argument|); 	      return; 	    } 	  else if (strcmp (name, TAG_SELECTOR) ==
literal|0
argument|)
comment|/* ':' */
argument|{ 	      obstack_1grow (&util_obstack,
literal|':'
argument|); 	      return; 	    } 	}     }   else if (TREE_CODE (pointer_to) == INTEGER_TYPE&& TYPE_MODE (pointer_to) == QImode)     {       tree pname = TREE_CODE (OBJC_TYPE_NAME (pointer_to)) == IDENTIFIER_NODE 	          ? OBJC_TYPE_NAME (pointer_to) 	          : DECL_NAME (OBJC_TYPE_NAME (pointer_to));        if (!flag_next_runtime || strcmp (IDENTIFIER_POINTER (pname),
literal|"BOOL"
argument|)) 	{
comment|/* It appears that "r*" means "const char *" rather than 	     "char *const".  */
argument|if (TYPE_READONLY (pointer_to)) 	    obstack_1grow (&util_obstack,
literal|'r'
argument|);  	  obstack_1grow (&util_obstack,
literal|'*'
argument|); 	  return; 	}     }
comment|/* We have a type that does not get special treatment.  */
comment|/* NeXT extension */
argument|obstack_1grow (&util_obstack,
literal|'^'
argument|);   encode_type (pointer_to, curtype, format); }  static void encode_array (tree type, int curtype, int format) {   tree an_int_cst = TYPE_SIZE (type);   tree array_of = TREE_TYPE (type);   char buffer[
literal|40
argument|];
comment|/* An incomplete array is treated like a pointer.  */
argument|if (an_int_cst == NULL)     {       encode_pointer (type, curtype, format);       return;     }    if (TREE_INT_CST_LOW (TYPE_SIZE (array_of)) ==
literal|0
argument|)    sprintf (buffer,
literal|"["
argument|HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)
literal|0
argument|);   else     sprintf (buffer,
literal|"["
argument|HOST_WIDE_INT_PRINT_DEC, 	     TREE_INT_CST_LOW (an_int_cst) 	      / TREE_INT_CST_LOW (TYPE_SIZE (array_of)));    obstack_grow (&util_obstack, buffer, strlen (buffer));   encode_type (array_of, curtype, format);   obstack_1grow (&util_obstack,
literal|']'
argument|);   return; }
argument|static void encode_aggregate_fields (tree type, int pointed_to, int curtype, int format) {   tree field = TYPE_FIELDS (type);    for (; field; field = TREE_CHAIN (field))     {
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* C++ static members, and things that are not field at all, 	 should not appear in the encoding.  */
argument|if (TREE_CODE (field) != FIELD_DECL || TREE_STATIC (field)) 	continue;
endif|#
directive|endif
comment|/* Recursively encode fields of embedded base classes.  */
argument|if (DECL_ARTIFICIAL (field)&& !DECL_NAME (field)&& TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE) 	{ 	  encode_aggregate_fields (TREE_TYPE (field), 				   pointed_to, curtype, format); 	  continue; 	}        if (generating_instance_variables&& !pointed_to) 	{ 	  tree fname = DECL_NAME (field);  	  obstack_1grow (&util_obstack,
literal|'"'
argument|);  	  if (fname&& TREE_CODE (fname) == IDENTIFIER_NODE) 	    obstack_grow (&util_obstack, 			  IDENTIFIER_POINTER (fname), 			  strlen (IDENTIFIER_POINTER (fname)));  	  obstack_1grow (&util_obstack,
literal|'"'
argument|);         }        encode_field_decl (field, curtype, format);     } }  static void encode_aggregate_within (tree type, int curtype, int format, int left, 			 int right) {   tree name;
comment|/* NB: aggregates that are pointed to have slightly different encoding      rules in that you never encode the names of instance variables.  */
argument|int ob_size = obstack_object_size (&util_obstack);   char c1 = ob_size>
literal|1
argument|? *(obstack_next_free (&util_obstack) -
literal|2
argument|) :
literal|0
argument|;   char c0 = ob_size>
literal|0
argument|? *(obstack_next_free (&util_obstack) -
literal|1
argument|) :
literal|0
argument|;   int pointed_to = (c0 ==
literal|'^'
argument||| (c1 ==
literal|'^'
argument|&& c0 ==
literal|'r'
argument|));   int inline_contents    = ((format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)&& (!pointed_to || ob_size - curtype == (c1 ==
literal|'r'
argument|?
literal|2
argument|:
literal|1
argument|)));
comment|/* Traverse struct aliases; it is important to get the      original struct and its tag name (if any).  */
argument|type = TYPE_MAIN_VARIANT (type);   name = OBJC_TYPE_NAME (type);
comment|/* Open parenth/bracket.  */
argument|obstack_1grow (&util_obstack, left);
comment|/* Encode the struct/union tag name, or '?' if a tag was      not provided.  Typedef aliases do not qualify.  */
argument|if (name&& TREE_CODE (name) == IDENTIFIER_NODE
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* Did this struct have a tag?  */
argument|&& !TYPE_WAS_ANONYMOUS (type)
endif|#
directive|endif
argument|)     obstack_grow (&util_obstack, 		  IDENTIFIER_POINTER (name), 		  strlen (IDENTIFIER_POINTER (name)));   else     obstack_1grow (&util_obstack,
literal|'?'
argument|);
comment|/* Encode the types (and possibly names) of the inner fields,      if required.  */
argument|if (inline_contents)     {       obstack_1grow (&util_obstack,
literal|'='
argument|);       encode_aggregate_fields (type, pointed_to, curtype, format);     }
comment|/* Close parenth/bracket.  */
argument|obstack_1grow (&util_obstack, right); }  static void encode_aggregate (tree type, int curtype, int format) {   enum tree_code code = TREE_CODE (type);    switch (code)     {     case RECORD_TYPE:       { 	encode_aggregate_within (type, curtype, format,
literal|'{'
argument|,
literal|'}'
argument|); 	break;       }     case UNION_TYPE:       { 	encode_aggregate_within (type, curtype, format,
literal|'('
argument|,
literal|')'
argument|); 	break;       }      case ENUMERAL_TYPE:       obstack_1grow (&util_obstack,
literal|'i'
argument|);       break;      default:       break;     } }
comment|/* Encode a bitfield NeXT-style (i.e., without a bit offset or the underlying    field type.  */
argument|static void encode_next_bitfield (int width) {   char buffer[
literal|40
argument|];   sprintf (buffer,
literal|"b%d"
argument|, width);   obstack_grow (&util_obstack, buffer, strlen (buffer)); }
comment|/* FORMAT will be OBJC_ENCODE_INLINE_DEFS or OBJC_ENCODE_DONT_INLINE_DEFS.  */
argument|static void encode_type (tree type, int curtype, int format) {   enum tree_code code = TREE_CODE (type);   char c;    if (TYPE_READONLY (type))     obstack_1grow (&util_obstack,
literal|'r'
argument|);    if (code == INTEGER_TYPE)     {       switch (GET_MODE_BITSIZE (TYPE_MODE (type))) 	{ 	case
literal|8
argument|:  c = TYPE_UNSIGNED (type) ?
literal|'C'
argument|:
literal|'c'
argument|; break; 	case
literal|16
argument|: c = TYPE_UNSIGNED (type) ?
literal|'S'
argument|:
literal|'s'
argument|; break; 	case
literal|32
argument|: 	  if (type == long_unsigned_type_node 	      || type == long_integer_type_node) 	         c = TYPE_UNSIGNED (type) ?
literal|'L'
argument|:
literal|'l'
argument|; 	  else 	         c = TYPE_UNSIGNED (type) ?
literal|'I'
argument|:
literal|'i'
argument|; 	  break; 	case
literal|64
argument|: c = TYPE_UNSIGNED (type) ?
literal|'Q'
argument|:
literal|'q'
argument|; break; 	default: abort (); 	}       obstack_1grow (&util_obstack, c);     }    else if (code == REAL_TYPE)     {
comment|/* Floating point types.  */
argument|switch (GET_MODE_BITSIZE (TYPE_MODE (type))) 	{ 	case
literal|32
argument|:  c =
literal|'f'
argument|; break; 	case
literal|64
argument|: 	case
literal|96
argument|: 	case
literal|128
argument|: c =
literal|'d'
argument|; break; 	default: abort (); 	}       obstack_1grow (&util_obstack, c);     }    else if (code == VOID_TYPE)     obstack_1grow (&util_obstack,
literal|'v'
argument|);    else if (code == BOOLEAN_TYPE)     obstack_1grow (&util_obstack,
literal|'B'
argument|);    else if (code == ARRAY_TYPE)     encode_array (type, curtype, format);    else if (code == POINTER_TYPE)     encode_pointer (type, curtype, format);    else if (code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE)     encode_aggregate (type, curtype, format);    else if (code == FUNCTION_TYPE)
comment|/* '?' */
argument|obstack_1grow (&util_obstack,
literal|'?'
argument|);    else if (code == COMPLEX_TYPE)     {       obstack_1grow (&util_obstack,
literal|'j'
argument|);       encode_type (TREE_TYPE (type), curtype, format);     } }  static void encode_gnu_bitfield (int position, tree type, int size) {   enum tree_code code = TREE_CODE (type);   char buffer[
literal|40
argument|];   char charType =
literal|'?'
argument|;    if (code == INTEGER_TYPE)     {       if (integer_zerop (TYPE_MIN_VALUE (type))) 	{
comment|/* Unsigned integer types.  */
argument|if (TYPE_MODE (type) == QImode) 	    charType =
literal|'C'
argument|; 	  else if (TYPE_MODE (type) == HImode) 	    charType =
literal|'S'
argument|; 	  else if (TYPE_MODE (type) == SImode) 	    { 	      if (type == long_unsigned_type_node) 		charType =
literal|'L'
argument|; 	      else 		charType =
literal|'I'
argument|; 	    } 	  else if (TYPE_MODE (type) == DImode) 	    charType =
literal|'Q'
argument|; 	}        else
comment|/* Signed integer types.  */
argument|{ 	  if (TYPE_MODE (type) == QImode) 	    charType =
literal|'c'
argument|; 	  else if (TYPE_MODE (type) == HImode) 	    charType =
literal|'s'
argument|; 	  else if (TYPE_MODE (type) == SImode) 	    { 	      if (type == long_integer_type_node) 		charType =
literal|'l'
argument|; 	      else 		charType =
literal|'i'
argument|; 	    }  	  else if (TYPE_MODE (type) == DImode) 	    charType =
literal|'q'
argument|; 	}     }   else if (code == ENUMERAL_TYPE)     charType =
literal|'i'
argument|;   else     abort ();    sprintf (buffer,
literal|"b%d%c%d"
argument|, position, charType, size);   obstack_grow (&util_obstack, buffer, strlen (buffer)); }  static void encode_field_decl (tree field_decl, int curtype, int format) {   tree type;
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* C++ static members, and things that are not fields at all,      should not appear in the encoding.  */
argument|if (TREE_CODE (field_decl) != FIELD_DECL || TREE_STATIC (field_decl))     return;
endif|#
directive|endif
argument|type = TREE_TYPE (field_decl);
comment|/* Generate the bitfield typing information, if needed.  Note the difference      between GNU and NeXT runtimes.  */
argument|if (DECL_BIT_FIELD_TYPE (field_decl))     {       int size = tree_low_cst (DECL_SIZE (field_decl),
literal|1
argument|);        if (flag_next_runtime) 	encode_next_bitfield (size);       else 	encode_gnu_bitfield (int_bit_position (field_decl), 				  DECL_BIT_FIELD_TYPE (field_decl), size);     }   else     encode_type (TREE_TYPE (field_decl), curtype, format); }  static GTY(()) tree objc_parmlist = NULL_TREE;
comment|/* Append PARM to a list of formal parameters of a method, making a necessary    array-to-pointer adjustment along the way.  */
argument|static void objc_push_parm (tree parm) {   bool relayout_needed = false;
comment|/* Decay arrays and functions into pointers.  */
argument|if (TREE_CODE (TREE_TYPE (parm)) == ARRAY_TYPE)     {       TREE_TYPE (parm) = build_pointer_type (TREE_TYPE (TREE_TYPE (parm)));       relayout_needed = true;     }   else if (TREE_CODE (TREE_TYPE (parm)) == FUNCTION_TYPE)     {       TREE_TYPE (parm) = build_pointer_type (TREE_TYPE (parm));       relayout_needed = true;     }    if (relayout_needed)     relayout_decl (parm);       DECL_ARG_TYPE (parm)     = lang_hooks.types.type_promotes_to (TREE_TYPE (parm));
comment|/* Record constancy and volatility.  */
argument|c_apply_type_quals_to_decl   ((TYPE_READONLY (TREE_TYPE (parm)) ? TYPE_QUAL_CONST :
literal|0
argument|)    | (TYPE_RESTRICT (TREE_TYPE (parm)) ? TYPE_QUAL_RESTRICT :
literal|0
argument|)    | (TYPE_VOLATILE (TREE_TYPE (parm)) ? TYPE_QUAL_VOLATILE :
literal|0
argument|), parm);    objc_parmlist = chainon (objc_parmlist, parm); }
comment|/* Retrieve the formal parameter list constructed via preceding calls to    objc_push_parm().  */
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|static tree objc_get_parm_info (int have_ellipsis ATTRIBUTE_UNUSED)
else|#
directive|else
argument|static struct c_arg_info * objc_get_parm_info (int have_ellipsis)
endif|#
directive|endif
argument|{
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|tree parm_info = objc_parmlist;   objc_parmlist = NULL_TREE;    return parm_info;
else|#
directive|else
argument|tree parm_info = objc_parmlist;   struct c_arg_info *arg_info;
comment|/* The C front-end requires an elaborate song and dance at      this point.  */
argument|push_scope ();   declare_parm_level ();   while (parm_info)     {       tree next = TREE_CHAIN (parm_info);        TREE_CHAIN (parm_info) = NULL_TREE;       parm_info = pushdecl (parm_info);       finish_decl (parm_info, NULL_TREE, NULL_TREE);       parm_info = next;     }   arg_info = get_parm_info (have_ellipsis);   pop_scope ();   objc_parmlist = NULL_TREE;   return arg_info;
endif|#
directive|endif
argument|}
comment|/* Synthesize the formal parameters 'id self' and 'SEL _cmd' needed for ObjC    method definitions.  In the case of instance methods, we can be more    specific as to the type of 'self'.  */
argument|static void synth_self_and_ucmd_args (void) {   tree self_type;    if (objc_method_context&& TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL)     self_type = objc_instance_type;   else
comment|/* Really a `struct objc_class *'. However, we allow people to        assign to self, which changes its type midstream.  */
argument|self_type = objc_object_type;
comment|/* id self; */
argument|objc_push_parm (build_decl (PARM_DECL, self_id, self_type));
comment|/* SEL _cmd; */
argument|objc_push_parm (build_decl (PARM_DECL, ucmd_id, objc_selector_type)); }
comment|/* Transform an Objective-C method definition into a static C function    definition, synthesizing the first two arguments, "self" and "_cmd",    in the process.  */
argument|static void start_method_def (tree method) {   tree parmlist;
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|tree parm_info;
else|#
directive|else
argument|struct c_arg_info *parm_info;
endif|#
directive|endif
argument|int have_ellipsis =
literal|0
argument|;
comment|/* If we are defining a "dealloc" method in a non-root class, we      will need to check if a [super dealloc] is missing, and warn if      it is.  */
argument|if(CLASS_SUPER_NAME (objc_implementation_context)&& !strcmp (
literal|"dealloc"
argument|, IDENTIFIER_POINTER (METHOD_SEL_NAME (method))))     should_call_super_dealloc =
literal|1
argument|;   else     should_call_super_dealloc =
literal|0
argument|;
comment|/* Required to implement _msgSuper.  */
argument|objc_method_context = method;   UOBJC_SUPER_decl = NULL_TREE;
comment|/* Generate prototype declarations for arguments..."new-style".  */
argument|synth_self_and_ucmd_args ();
comment|/* Generate argument declarations if a keyword_decl.  */
argument|parmlist = METHOD_SEL_ARGS (method);   while (parmlist)     {       tree type = TREE_VALUE (TREE_TYPE (parmlist))
argument_list|,
argument|parm;        parm = build_decl (PARM_DECL, KEYWORD_ARG_NAME (parmlist), type);       objc_push_parm (parm);       parmlist = TREE_CHAIN (parmlist);     }    if (METHOD_ADD_ARGS (method))     {       tree akey;        for (akey = TREE_CHAIN (METHOD_ADD_ARGS (method)); 	   akey; akey = TREE_CHAIN (akey)) 	{ 	  objc_push_parm (TREE_VALUE (akey)); 	}        if (METHOD_ADD_ARGS_ELLIPSIS_P (method)) 	have_ellipsis =
literal|1
argument|;     }    parm_info = objc_get_parm_info (have_ellipsis);    really_start_method (objc_method_context, parm_info); }  static void warn_with_method (const char *message, int mtype, tree method) {
comment|/* Add a readable method name to the warning.  */
argument|warning (
literal|0
argument|,
literal|"%J%s %<%c%s%>"
argument|, method,            message, mtype, gen_method_decl (method)); }
comment|/* Return 1 if TYPE1 is equivalent to TYPE2    for purposes of method overloading.  */
argument|static int objc_types_are_equivalent (tree type1, tree type2) {   if (type1 == type2)     return
literal|1
argument|;
comment|/* Strip away indirections.  */
argument|while ((TREE_CODE (type1) == ARRAY_TYPE || TREE_CODE (type1) == POINTER_TYPE)&& (TREE_CODE (type1) == TREE_CODE (type2)))     type1 = TREE_TYPE (type1)
argument_list|,
argument|type2 = TREE_TYPE (type2);   if (TYPE_MAIN_VARIANT (type1) != TYPE_MAIN_VARIANT (type2))     return
literal|0
argument|;    type1 = (TYPE_HAS_OBJC_INFO (type1) 	   ? TYPE_OBJC_PROTOCOL_LIST (type1) 	   : NULL_TREE);   type2 = (TYPE_HAS_OBJC_INFO (type2) 	   ? TYPE_OBJC_PROTOCOL_LIST (type2) 	   : NULL_TREE);    if (list_length (type1) == list_length (type2))     {       for (; type2; type2 = TREE_CHAIN (type2)) 	if (!lookup_protocol_in_reflist (type1, TREE_VALUE (type2))) 	  return
literal|0
argument|;       return
literal|1
argument|;     }   return
literal|0
argument|; }
comment|/* Return 1 if TYPE1 has the same size and alignment as TYPE2.  */
argument|static int objc_types_share_size_and_alignment (tree type1, tree type2) {   return (simple_cst_equal (TYPE_SIZE (type1), TYPE_SIZE (type2))&& TYPE_ALIGN (type1) == TYPE_ALIGN (type2)); }
comment|/* Return 1 if PROTO1 is equivalent to PROTO2    for purposes of method overloading.  Ordinarily, the type signatures    should match up exactly, unless STRICT is zero, in which case we    shall allow differences in which the size and alignment of a type    is the same.  */
argument|static int comp_proto_with_proto (tree proto1, tree proto2, int strict) {   tree type1
argument_list|,
argument|type2;
comment|/* The following test is needed in case there are hashing      collisions.  */
argument|if (METHOD_SEL_NAME (proto1) != METHOD_SEL_NAME (proto2))     return
literal|0
argument|;
comment|/* Compare return types.  */
argument|type1 = TREE_VALUE (TREE_TYPE (proto1));   type2 = TREE_VALUE (TREE_TYPE (proto2));    if (!objc_types_are_equivalent (type1, type2)&& (strict || !objc_types_share_size_and_alignment (type1, type2)))     return
literal|0
argument|;
comment|/* Compare argument types.  */
argument|for (type1 = get_arg_type_list (proto1, METHOD_REF,
literal|0
argument|),        type2 = get_arg_type_list (proto2, METHOD_REF,
literal|0
argument|);        type1&& type2;        type1 = TREE_CHAIN (type1), type2 = TREE_CHAIN (type2))     {       if (!objc_types_are_equivalent (TREE_VALUE (type1), TREE_VALUE (type2))&& (strict 	      || !objc_types_share_size_and_alignment (TREE_VALUE (type1), 						       TREE_VALUE (type2)))) 	return
literal|0
argument|;     }    return (!type1&& !type2); }
comment|/* Fold an OBJ_TYPE_REF expression for ObjC method dispatches, where    this occurs.  ObjC method dispatches are _not_ like C++ virtual    member function dispatches, and we account for the difference here.  */
argument|tree
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|objc_fold_obj_type_ref (tree ref, tree known_type)
else|#
directive|else
argument|objc_fold_obj_type_ref (tree ref ATTRIBUTE_UNUSED, 			tree known_type ATTRIBUTE_UNUSED)
endif|#
directive|endif
argument|{
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|tree v = BINFO_VIRTUALS (TYPE_BINFO (known_type));
comment|/* If the receiver does not have virtual member functions, there      is nothing we can (or need to) do here.  */
argument|if (!v)     return NULL_TREE;
comment|/* Let C++ handle C++ virtual functions.  */
argument|return cp_fold_obj_type_ref (ref, known_type);
else|#
directive|else
comment|/* For plain ObjC, we currently do not need to do anything.  */
argument|return NULL_TREE;
endif|#
directive|endif
argument|}  static void objc_start_function (tree name, tree type, tree attrs,
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|tree params
else|#
directive|else
argument|struct c_arg_info *params
endif|#
directive|endif
argument|) {   tree fndecl = build_decl (FUNCTION_DECL, name, type);
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|DECL_ARGUMENTS (fndecl) = params;   DECL_INITIAL (fndecl) = error_mark_node;   DECL_EXTERNAL (fndecl) =
literal|0
argument|;   TREE_STATIC (fndecl) =
literal|1
argument|;   retrofit_lang_decl (fndecl);   cplus_decl_attributes (&fndecl, attrs,
literal|0
argument|);   start_preparsed_function (fndecl, attrs,
comment|/*flags=*/
argument|SF_DEFAULT);
else|#
directive|else
argument|struct c_label_context_se *nstack_se;   struct c_label_context_vm *nstack_vm;   nstack_se = XOBNEW (&parser_obstack, struct c_label_context_se);   nstack_se->labels_def = NULL;   nstack_se->labels_used = NULL;   nstack_se->next = label_context_stack_se;   label_context_stack_se = nstack_se;   nstack_vm = XOBNEW (&parser_obstack, struct c_label_context_vm);   nstack_vm->labels_def = NULL;   nstack_vm->labels_used = NULL;   nstack_vm->scope =
literal|0
argument|;   nstack_vm->next = label_context_stack_vm;   label_context_stack_vm = nstack_vm;   current_function_returns_value =
literal|0
argument|;
comment|/* Assume, until we see it does.  */
argument|current_function_returns_null =
literal|0
argument|;    decl_attributes (&fndecl, attrs,
literal|0
argument|);   announce_function (fndecl);   DECL_INITIAL (fndecl) = error_mark_node;   DECL_EXTERNAL (fndecl) =
literal|0
argument|;   TREE_STATIC (fndecl) =
literal|1
argument|;   current_function_decl = pushdecl (fndecl);   push_scope ();   declare_parm_level ();   DECL_RESULT (current_function_decl)     = build_decl (RESULT_DECL, NULL_TREE, 		  TREE_TYPE (TREE_TYPE (current_function_decl)));   DECL_ARTIFICIAL (DECL_RESULT (current_function_decl)) =
literal|1
argument|;   DECL_IGNORED_P (DECL_RESULT (current_function_decl)) =
literal|1
argument|;   start_fname_decls ();   store_parm_decls_from (params);
endif|#
directive|endif
argument|TREE_USED (current_function_decl) =
literal|1
argument|; }
comment|/* - Generate an identifier for the function. the format is "_n_cls",      where 1<= n<= nMethods, and cls is the name the implementation we      are processing.    - Install the return type from the method declaration.    - If we have a prototype, check for type consistency.  */
argument|static void really_start_method (tree method,
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|tree parmlist
else|#
directive|else
argument|struct c_arg_info *parmlist
endif|#
directive|endif
argument|) {   tree ret_type
argument_list|,
argument|meth_type;   tree method_id;   const char *sel_name
argument_list|,
argument|*class_name
argument_list|,
argument|*cat_name;   char *buf;
comment|/* Synth the storage class& assemble the return type.  */
argument|ret_type = TREE_VALUE (TREE_TYPE (method));    sel_name = IDENTIFIER_POINTER (METHOD_SEL_NAME (method));   class_name = IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context));   cat_name = ((TREE_CODE (objc_implementation_context) 	       == CLASS_IMPLEMENTATION_TYPE) 	      ? NULL 	      : IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context)));   method_slot++;
comment|/* Make sure this is big enough for any plausible method label.  */
argument|buf = (char *) alloca (
literal|50
argument|+ strlen (sel_name) + strlen (class_name) 			 + (cat_name ? strlen (cat_name) :
literal|0
argument|));    OBJC_GEN_METHOD_LABEL (buf, TREE_CODE (method) == INSTANCE_METHOD_DECL, 			 class_name, cat_name, sel_name, method_slot);    method_id = get_identifier (buf);
ifdef|#
directive|ifdef
name|OBJCPLUS
comment|/* Objective-C methods cannot be overloaded, so we don't need      the type encoding appended.  It looks bad anyway... */
argument|push_lang_context (lang_name_c);
endif|#
directive|endif
argument|meth_type     = build_function_type (ret_type, 			   get_arg_type_list (method, METHOD_DEF,
literal|0
argument|));   objc_start_function (method_id, meth_type, NULL_TREE, parmlist);
comment|/* Set self_decl from the first argument.  */
argument|self_decl = DECL_ARGUMENTS (current_function_decl);
comment|/* Suppress unused warnings.  */
argument|TREE_USED (self_decl) =
literal|1
argument|;   TREE_USED (TREE_CHAIN (self_decl)) =
literal|1
argument|;
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|pop_lang_context ();
endif|#
directive|endif
argument|METHOD_DEFINITION (method) = current_function_decl;
comment|/* Check consistency...start_function, pushdecl, duplicate_decls.  */
argument|if (implementation_template != objc_implementation_context)     {       tree proto 	= lookup_method_static (implementation_template, 				METHOD_SEL_NAME (method), 				((TREE_CODE (method) == CLASS_METHOD_DECL) 				 | OBJC_LOOKUP_NO_SUPER));        if (proto) 	{ 	  if (!comp_proto_with_proto (method, proto,
literal|1
argument|)) 	    { 	      char type = (TREE_CODE (method) == INSTANCE_METHOD_DECL ?
literal|'-'
argument|:
literal|'+'
argument|);  	      warn_with_method (
literal|"conflicting types for"
argument|, type, method); 	      warn_with_method (
literal|"previous declaration of"
argument|, type, proto); 	    } 	}       else 	{
comment|/* We have a method @implementation even though we did not 	     see a corresponding @interface declaration (which is allowed 	     by Objective-C rules).  Go ahead and place the method in 	     the @interface anyway, so that message dispatch lookups 	     will see it.  */
argument|tree interface = implementation_template;  	  if (TREE_CODE (objc_implementation_context) 	      == CATEGORY_IMPLEMENTATION_TYPE) 	    interface = lookup_category 			(interface, 			 CLASS_SUPER_NAME (objc_implementation_context));  	  if (interface) 	    objc_add_method (interface, copy_node (method), 			     TREE_CODE (method) == CLASS_METHOD_DECL); 	}     } }  static void *UOBJC_SUPER_scope =
literal|0
argument|;
comment|/* _n_Method (id self, SEL sel, ...)      {        struct objc_super _S;        _msgSuper ((_S.self = self, _S.class = _cls,&_S), ...);      }  */
argument|static tree get_super_receiver (void) {   if (objc_method_context)     {       tree super_expr
argument_list|,
argument|super_expr_list;        if (!UOBJC_SUPER_decl)       { 	UOBJC_SUPER_decl = build_decl (VAR_DECL, get_identifier (TAG_SUPER), 				       objc_super_template);
comment|/* This prevents `unused variable' warnings when compiling with -Wall.  */
argument|TREE_USED (UOBJC_SUPER_decl) =
literal|1
argument|; 	lang_hooks.decls.pushdecl (UOBJC_SUPER_decl);         finish_decl (UOBJC_SUPER_decl, NULL_TREE, NULL_TREE); 	UOBJC_SUPER_scope = objc_get_current_scope ();       }
comment|/* Set receiver to self.  */
argument|super_expr = objc_build_component_ref (UOBJC_SUPER_decl, self_id);       super_expr = build_modify_expr (super_expr, NOP_EXPR, self_decl);       super_expr_list = super_expr;
comment|/* Set class to begin searching.  */
argument|super_expr = objc_build_component_ref (UOBJC_SUPER_decl, 					     get_identifier (
literal|"super_class"
argument|));        if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE) 	{
comment|/* [_cls, __cls]Super are "pre-built" in 	     synth_forward_declarations.  */
argument|super_expr = build_modify_expr (super_expr, NOP_EXPR, 					  ((TREE_CODE (objc_method_context) 					    == INSTANCE_METHOD_DECL) 					   ? ucls_super_ref 					   : uucls_super_ref)); 	}        else
comment|/* We have a category.  */
argument|{ 	  tree super_name = CLASS_SUPER_NAME (implementation_template); 	  tree super_class;
comment|/* Barf if super used in a category of Object.  */
argument|if (!super_name) 	    { 	      error (
literal|"no super class declared in interface for %qs"
argument|, 		    IDENTIFIER_POINTER (CLASS_NAME (implementation_template))); 	      return error_mark_node; 	    }  	  if (flag_next_runtime&& !flag_zero_link) 	    { 	      super_class = objc_get_class_reference (super_name); 	      if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)
comment|/* If we are in a class method, we must retrieve the 		   _metaclass_ for the current class, pointed at by 		   the class's "isa" pointer.  The following assumes that 		   "isa" is the first ivar in a class (which it must be).  */
argument|super_class 		  = build_indirect_ref 		    (build_c_cast (build_pointer_type (objc_class_type), 				   super_class),
literal|"unary *"
argument|); 	    } 	  else 	    { 	      add_class_reference (super_name); 	      super_class = (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL 			     ? objc_get_class_decl : objc_get_meta_class_decl); 	      assemble_external (super_class); 	      super_class 		= build_function_call 		  (super_class, 		   build_tree_list 		   (NULL_TREE, 		    my_build_string_pointer 		    (IDENTIFIER_LENGTH (super_name) +
literal|1
argument|, 		     IDENTIFIER_POINTER (super_name)))); 	    }  	  super_expr 	    = build_modify_expr (super_expr, NOP_EXPR, 				 build_c_cast (TREE_TYPE (super_expr), 					       super_class)); 	}        super_expr_list = build_compound_expr (super_expr_list, super_expr);        super_expr = build_unary_op (ADDR_EXPR, UOBJC_SUPER_decl,
literal|0
argument|);       super_expr_list = build_compound_expr (super_expr_list, super_expr);        return super_expr_list;     }   else     {       error (
literal|"[super ...] must appear in a method context"
argument|);       return error_mark_node;     } }
comment|/* When exiting a scope, sever links to a 'super' declaration (if any)    therein contained.  */
argument|void objc_clear_super_receiver (void) {   if (objc_method_context&& UOBJC_SUPER_scope == objc_get_current_scope ()) {     UOBJC_SUPER_decl =
literal|0
argument|;     UOBJC_SUPER_scope =
literal|0
argument|;   } }  void objc_finish_method_definition (tree fndecl) {
comment|/* We cannot validly inline ObjC methods, at least not without a language      extension to declare that a method need not be dynamically      dispatched, so suppress all thoughts of doing so.  */
argument|DECL_INLINE (fndecl) =
literal|0
argument|;   DECL_UNINLINABLE (fndecl) =
literal|1
argument|;
ifndef|#
directive|ifndef
name|OBJCPLUS
comment|/* The C++ front-end will have called finish_function() for us.  */
argument|finish_function ();
endif|#
directive|endif
argument|METHOD_ENCODING (objc_method_context)     = encode_method_prototype (objc_method_context);
comment|/* Required to implement _msgSuper. This must be done AFTER finish_function,      since the optimizer may find "may be used before set" errors.  */
argument|objc_method_context = NULL_TREE;    if (should_call_super_dealloc)     warning (
literal|0
argument|,
literal|"method possibly missing a [super dealloc] call"
argument|); }
if|#
directive|if
literal|0
argument|int lang_report_error_function (tree decl) {   if (objc_method_context)     {       fprintf (stderr, "In method %qs\n", 	       IDENTIFIER_POINTER (METHOD_SEL_NAME (objc_method_context)));       return 1;     }    else     return 0; }
endif|#
directive|endif
comment|/* Given a tree DECL node, produce a printable description of it in the given    buffer, overwriting the buffer.  */
argument|static char * gen_declaration (tree decl) {   errbuf[
literal|0
argument|] =
literal|'\0'
argument|;    if (DECL_P (decl))     {       gen_type_name_0 (TREE_TYPE (decl));        if (DECL_NAME (decl)) 	{ 	  if (!POINTER_TYPE_P (TREE_TYPE (decl))) 	    strcat (errbuf,
literal|" "
argument|);  	  strcat (errbuf, IDENTIFIER_POINTER (DECL_NAME (decl))); 	}        if (DECL_INITIAL (decl)&& TREE_CODE (DECL_INITIAL (decl)) == INTEGER_CST) 	sprintf (errbuf + strlen (errbuf),
literal|": "
argument|HOST_WIDE_INT_PRINT_DEC, 		 TREE_INT_CST_LOW (DECL_INITIAL (decl)));     }    return errbuf; }
comment|/* Given a tree TYPE node, produce a printable description of it in the given    buffer, overwriting the buffer.  */
argument|static char * gen_type_name_0 (tree type) {   tree orig = type
argument_list|,
argument|proto;    if (TYPE_P (type)&& TYPE_NAME (type))     type = TYPE_NAME (type);   else if (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)     {       tree inner = TREE_TYPE (type);        while (TREE_CODE (inner) == ARRAY_TYPE) 	inner = TREE_TYPE (inner);        gen_type_name_0 (inner);        if (!POINTER_TYPE_P (inner)) 	strcat (errbuf,
literal|" "
argument|);        if (POINTER_TYPE_P (type)) 	strcat (errbuf,
literal|"*"
argument|);       else 	while (type != inner) 	  { 	    strcat (errbuf,
literal|"["
argument|);  	    if (TYPE_DOMAIN (type)) 	      { 		char sz[
literal|20
argument|];  		sprintf (sz, HOST_WIDE_INT_PRINT_DEC, 			 (TREE_INT_CST_LOW 			  (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) +
literal|1
argument|)); 		strcat (errbuf, sz); 	      }  	    strcat (errbuf,
literal|"]"
argument|); 	    type = TREE_TYPE (type); 	  }        goto exit_function;     }    if (TREE_CODE (type) == TYPE_DECL&& DECL_NAME (type))     type = DECL_NAME (type);    strcat (errbuf, TREE_CODE (type) == IDENTIFIER_NODE 	  	  ? IDENTIFIER_POINTER (type) 		  :
literal|""
argument|);
comment|/* For 'id' and 'Class', adopted protocols are stored in the pointee.  */
argument|if (objc_is_id (orig))     orig = TREE_TYPE (orig);    proto = TYPE_HAS_OBJC_INFO (orig) ? TYPE_OBJC_PROTOCOL_LIST (orig) : NULL_TREE;    if (proto)     {       strcat (errbuf,
literal|"<"
argument|);        while (proto) { 	strcat (errbuf, 		IDENTIFIER_POINTER (PROTOCOL_NAME (TREE_VALUE (proto)))); 	proto = TREE_CHAIN (proto); 	strcat (errbuf, proto ?
literal|", "
argument|:
literal|">"
argument|);       }     }   exit_function:   return errbuf; }  static char * gen_type_name (tree type) {   errbuf[
literal|0
argument|] =
literal|'\0'
argument|;    return gen_type_name_0 (type); }
comment|/* Given a method tree, put a printable description into the given    buffer (overwriting) and return a pointer to the buffer.  */
argument|static char * gen_method_decl (tree method) {   tree chain;    strcpy (errbuf,
literal|"("
argument|);
comment|/* NB: Do _not_ call strcat() here.  */
argument|gen_type_name_0 (TREE_VALUE (TREE_TYPE (method)));   strcat (errbuf,
literal|")"
argument|);   chain = METHOD_SEL_ARGS (method);    if (chain)     {
comment|/* We have a chain of keyword_decls.  */
argument|do         { 	  if (KEYWORD_KEY_NAME (chain)) 	    strcat (errbuf, IDENTIFIER_POINTER (KEYWORD_KEY_NAME (chain)));  	  strcat (errbuf,
literal|":("
argument|); 	  gen_type_name_0 (TREE_VALUE (TREE_TYPE (chain))); 	  strcat (errbuf,
literal|")"
argument|);  	  strcat (errbuf, IDENTIFIER_POINTER (KEYWORD_ARG_NAME (chain))); 	  if ((chain = TREE_CHAIN (chain))) 	    strcat (errbuf,
literal|" "
argument|);         }       while (chain);        if (METHOD_ADD_ARGS (method)) 	{ 	  chain = TREE_CHAIN (METHOD_ADD_ARGS (method));
comment|/* Know we have a chain of parm_decls.  */
argument|while (chain) 	    { 	      strcat (errbuf,
literal|", "
argument|); 	      gen_type_name_0 (TREE_TYPE (TREE_VALUE (chain))); 	      chain = TREE_CHAIN (chain); 	    }  	  if (METHOD_ADD_ARGS_ELLIPSIS_P (method)) 	    strcat (errbuf,
literal|", ..."
argument|); 	}     }    else
comment|/* We have a unary selector.  */
argument|strcat (errbuf, IDENTIFIER_POINTER (METHOD_SEL_NAME (method)));    return errbuf; }
comment|/* Debug info.  */
comment|/* Dump an @interface declaration of the supplied class CHAIN to the    supplied file FP.  Used to implement the -gen-decls option (which    prints out an @interface declaration of all classes compiled in    this run); potentially useful for debugging the compiler too.  */
argument|static void dump_interface (FILE *fp, tree chain) {
comment|/* FIXME: A heap overflow here whenever a method (or ivar)      declaration is so long that it doesn't fit in the buffer.  The      code and all the related functions should be rewritten to avoid      using fixed size buffers.  */
argument|const char *my_name = IDENTIFIER_POINTER (CLASS_NAME (chain));   tree ivar_decls = CLASS_RAW_IVARS (chain);   tree nst_methods = CLASS_NST_METHODS (chain);   tree cls_methods = CLASS_CLS_METHODS (chain);    fprintf (fp,
literal|"\n@interface %s"
argument|, my_name);
comment|/* CLASS_SUPER_NAME is used to store the superclass name for      classes, and the category name for categories.  */
argument|if (CLASS_SUPER_NAME (chain))     {       const char *name = IDENTIFIER_POINTER (CLASS_SUPER_NAME (chain));        if (TREE_CODE (chain) == CATEGORY_IMPLEMENTATION_TYPE 	  || TREE_CODE (chain) == CATEGORY_INTERFACE_TYPE) 	{ 	  fprintf (fp,
literal|" (%s)\n"
argument|, name); 	}       else 	{ 	  fprintf (fp,
literal|" : %s\n"
argument|, name); 	}     }   else     fprintf (fp,
literal|"\n"
argument|);
comment|/* FIXME - the following doesn't seem to work at the moment.  */
argument|if (ivar_decls)     {       fprintf (fp,
literal|"{\n"
argument|);       do 	{ 	  fprintf (fp,
literal|"\t%s;\n"
argument|, gen_declaration (ivar_decls)); 	  ivar_decls = TREE_CHAIN (ivar_decls); 	}       while (ivar_decls);       fprintf (fp,
literal|"}\n"
argument|);     }    while (nst_methods)     {       fprintf (fp,
literal|"- %s;\n"
argument|, gen_method_decl (nst_methods));       nst_methods = TREE_CHAIN (nst_methods);     }    while (cls_methods)     {       fprintf (fp,
literal|"+ %s;\n"
argument|, gen_method_decl (cls_methods));       cls_methods = TREE_CHAIN (cls_methods);     }    fprintf (fp,
literal|"@end\n"
argument|); }
comment|/* Demangle function for Objective-C */
argument|static const char * objc_demangle (const char *mangled) {   char *demangled
argument_list|,
argument|*cp;    if (mangled[
literal|0
argument|] ==
literal|'_'
argument|&&       (mangled[
literal|1
argument|] ==
literal|'i'
argument||| mangled[
literal|1
argument|] ==
literal|'c'
argument|)&&       mangled[
literal|2
argument|] ==
literal|'_'
argument|)     {       cp = demangled = XNEWVEC (char, strlen(mangled) +
literal|2
argument|);       if (mangled[
literal|1
argument|] ==
literal|'i'
argument|) 	*cp++ =
literal|'-'
argument|;
comment|/* for instance method */
argument|else 	*cp++ =
literal|'+'
argument|;
comment|/* for class method */
argument|*cp++ =
literal|'['
argument|;
comment|/* opening left brace */
argument|strcpy(cp, mangled+
literal|3
argument|);
comment|/* tack on the rest of the mangled name */
argument|while (*cp&& *cp ==
literal|'_'
argument|) 	cp++;
comment|/* skip any initial underbars in class name */
argument|cp = strchr(cp,
literal|'_'
argument|);
comment|/* find first non-initial underbar */
argument|if (cp == NULL) 	{ 	  free(demangled);
comment|/* not mangled name */
argument|return mangled; 	}       if (cp[
literal|1
argument|] ==
literal|'_'
argument|)
comment|/* easy case: no category name */
argument|{ 	  *cp++ =
literal|' '
argument|;
comment|/* replace two '_' with one ' ' */
argument|strcpy(cp, mangled + (cp - demangled) +
literal|2
argument|); 	}       else 	{ 	  *cp++ =
literal|'('
argument|;
comment|/* less easy case: category name */
argument|cp = strchr(cp,
literal|'_'
argument|); 	  if (cp ==
literal|0
argument|) 	    { 	      free(demangled);
comment|/* not mangled name */
argument|return mangled; 	    } 	  *cp++ =
literal|')'
argument|; 	  *cp++ =
literal|' '
argument|;
comment|/* overwriting 1st char of method name... */
argument|strcpy(cp, mangled + (cp - demangled));
comment|/* get it back */
argument|}       while (*cp&& *cp ==
literal|'_'
argument|) 	cp++;
comment|/* skip any initial underbars in method name */
argument|for (; *cp; cp++) 	if (*cp ==
literal|'_'
argument|) 	  *cp =
literal|':'
argument|;
comment|/* replace remaining '_' with ':' */
argument|*cp++ =
literal|']'
argument|;
comment|/* closing right brace */
argument|*cp++ =
literal|0
argument|;
comment|/* string terminator */
argument|return demangled;     }   else     return mangled;
comment|/* not an objc mangled name */
argument|}  const char * objc_printable_name (tree decl, int kind ATTRIBUTE_UNUSED) {   return objc_demangle (IDENTIFIER_POINTER (DECL_NAME (decl))); }  static void init_objc (void) {   gcc_obstack_init (&util_obstack);   util_firstobj = (char *) obstack_finish (&util_obstack);    errbuf = XNEWVEC (char,
literal|1024
argument|*
literal|10
argument|);   hash_init ();   synth_module_prologue (); }
argument|static void finish_objc (void) {   struct imp_entry *impent;   tree chain;
comment|/* The internally generated initializers appear to have missing braces.      Don't warn about this.  */
argument|int save_warn_missing_braces = warn_missing_braces;   warn_missing_braces =
literal|0
argument|;
comment|/* A missing @end may not be detected by the parser.  */
argument|if (objc_implementation_context)     {       warning (
literal|0
argument|,
literal|"%<@end%> missing in implementation context"
argument|);       finish_class (objc_implementation_context);       objc_ivar_chain = NULL_TREE;       objc_implementation_context = NULL_TREE;     }
comment|/* Process the static instances here because initialization of objc_symtab      depends on them.  */
argument|if (objc_static_instances)     generate_static_references ();    if (imp_list || class_names_chain       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)     generate_objc_symtab_decl ();    for (impent = imp_list; impent; impent = impent->next)     {       objc_implementation_context = impent->imp_context;       implementation_template = impent->imp_template;        UOBJC_CLASS_decl = impent->class_decl;       UOBJC_METACLASS_decl = impent->meta_decl;
comment|/* Dump the @interface of each class as we compile it, if the 	 -gen-decls option is in use.  TODO: Dump the classes in the          order they were found, rather than in reverse order as we          are doing now.  */
argument|if (flag_gen_declaration) 	{ 	  dump_interface (gen_declaration_file, objc_implementation_context); 	}        if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE) 	{
comment|/* all of the following reference the string pool...  */
argument|generate_ivar_lists (); 	  generate_dispatch_tables (); 	  generate_shared_structures (impent->has_cxx_cdtors 				      ? CLS_HAS_CXX_STRUCTORS 				      :
literal|0
argument|); 	}       else 	{ 	  generate_dispatch_tables (); 	  generate_category (objc_implementation_context); 	}     }
comment|/* If we are using an array of selectors, we must always      finish up the array decl even if no selectors were used.  */
argument|if (! flag_next_runtime || sel_ref_chain)     build_selector_translation_table ();    if (protocol_chain)     generate_protocols ();    if ((flag_replace_objc_classes&& imp_list) || flag_objc_gc)     generate_objc_image_info ();
comment|/* Arrange for ObjC data structures to be initialized at run time.  */
argument|if (objc_implementation_context || class_names_chain || objc_static_instances       || meth_var_names_chain || meth_var_types_chain || sel_ref_chain)     {       build_module_descriptor ();        if (!flag_next_runtime) 	build_module_initializer_routine ();     }
comment|/* Dump the class references.  This forces the appropriate classes      to be linked into the executable image, preserving unix archive      semantics.  This can be removed when we move to a more dynamically      linked environment.  */
argument|for (chain = cls_ref_chain; chain; chain = TREE_CHAIN (chain))     {       handle_class_ref (chain);       if (TREE_PURPOSE (chain)) 	generate_classref_translation_entry (chain);     }    for (impent = imp_list; impent; impent = impent->next)     handle_impent (impent);    if (warn_selector)     {       int slot;       hash hsh;
comment|/* Run through the selector hash tables and print a warning for any          selector which has multiple methods.  */
argument|for (slot =
literal|0
argument|; slot< SIZEHASHTABLE; slot++) 	{ 	  for (hsh = cls_method_hash_list[slot]; hsh; hsh = hsh->next) 	    check_duplicates (hsh,
literal|0
argument|,
literal|1
argument|); 	  for (hsh = nst_method_hash_list[slot]; hsh; hsh = hsh->next) 	    check_duplicates (hsh,
literal|0
argument|,
literal|1
argument|); 	}     }    warn_missing_braces = save_warn_missing_braces; }
comment|/* Subroutines of finish_objc.  */
argument|static void generate_classref_translation_entry (tree chain) {   tree expr
argument_list|,
argument|decl
argument_list|,
argument|type;    decl = TREE_PURPOSE (chain);   type = TREE_TYPE (decl);    expr = add_objc_string (TREE_VALUE (chain), class_names);   expr = convert (type, expr);
comment|/* cast! */
comment|/* The decl that is the one that we      forward declared in build_class_reference.  */
argument|finish_var_decl (decl, expr);   return; }  static void handle_class_ref (tree chain) {   const char *name = IDENTIFIER_POINTER (TREE_VALUE (chain));   char *string = (char *) alloca (strlen (name) +
literal|30
argument|);   tree decl;   tree exp;    sprintf (string,
literal|"%sobjc_class_name_%s"
argument|, 	   (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), name);
ifdef|#
directive|ifdef
name|ASM_DECLARE_UNRESOLVED_REFERENCE
argument|if (flag_next_runtime)     {       ASM_DECLARE_UNRESOLVED_REFERENCE (asm_out_file, string);       return;     }
endif|#
directive|endif
comment|/* Make a decl for this name, so we can use its address in a tree.  */
argument|decl = build_decl (VAR_DECL, get_identifier (string), char_type_node);   DECL_EXTERNAL (decl) =
literal|1
argument|;   TREE_PUBLIC (decl) =
literal|1
argument|;    pushdecl (decl);   rest_of_decl_compilation (decl,
literal|0
argument|,
literal|0
argument|);
comment|/* Make a decl for the address.  */
argument|sprintf (string,
literal|"%sobjc_class_ref_%s"
argument|, 	   (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), name);   exp = build1 (ADDR_EXPR, string_type_node, decl);   decl = build_decl (VAR_DECL, get_identifier (string), string_type_node);   DECL_INITIAL (decl) = exp;   TREE_STATIC (decl) =
literal|1
argument|;   TREE_USED (decl) =
literal|1
argument|;
comment|/* Force the output of the decl as this forces the reference of the class.  */
argument|mark_decl_referenced (decl);    pushdecl (decl);   rest_of_decl_compilation (decl,
literal|0
argument|,
literal|0
argument|); }  static void handle_impent (struct imp_entry *impent) {   char *string;    objc_implementation_context = impent->imp_context;   implementation_template = impent->imp_template;    if (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)     {       const char *const class_name = 	IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));        string = (char *) alloca (strlen (class_name) +
literal|30
argument|);        sprintf (string,
literal|"%sobjc_class_name_%s"
argument|,                (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), class_name);     }   else if (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)     {       const char *const class_name = 	IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));       const char *const class_super_name =         IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));        string = (char *) alloca (strlen (class_name) 				+ strlen (class_super_name) +
literal|30
argument|);
comment|/* Do the same for categories.  Even though no references to          these symbols are generated automatically by the compiler, it          gives you a handle to pull them into an archive by hand.  */
argument|sprintf (string,
literal|"*%sobjc_category_name_%s_%s"
argument|,                (flag_next_runtime ?
literal|"."
argument|:
literal|"__"
argument|), class_name, class_super_name);     }   else     return;
ifdef|#
directive|ifdef
name|ASM_DECLARE_CLASS_REFERENCE
argument|if (flag_next_runtime)     {       ASM_DECLARE_CLASS_REFERENCE (asm_out_file, string);       return;     }   else
endif|#
directive|endif
argument|{       tree decl
argument_list|,
argument|init;        init = build_int_cst (c_common_type_for_size (BITS_PER_WORD,
literal|1
argument|),
literal|0
argument|);       decl = build_decl (VAR_DECL, get_identifier (string), TREE_TYPE (init));       TREE_PUBLIC (decl) =
literal|1
argument|;       TREE_READONLY (decl) =
literal|1
argument|;       TREE_USED (decl) =
literal|1
argument|;       TREE_CONSTANT (decl) =
literal|1
argument|;       DECL_CONTEXT (decl) =
literal|0
argument|;       DECL_ARTIFICIAL (decl) =
literal|1
argument|;       DECL_INITIAL (decl) = init;       assemble_variable (decl,
literal|1
argument|,
literal|0
argument|,
literal|0
argument|);     } }
comment|/* The Fix-and-Continue functionality available in Mac OS X 10.3 and    later requires that ObjC translation units participating in F&C be    specially marked.  The following routine accomplishes this.  */
comment|/* static int _OBJC_IMAGE_INFO[2] = { 0, 1 }; */
argument|static void generate_objc_image_info (void) {   tree decl
argument_list|,
argument|initlist;   int flags     = ((flag_replace_objc_classes&& imp_list ?
literal|1
argument|:
literal|0
argument|)        | (flag_objc_gc ?
literal|2
argument|:
literal|0
argument|));    decl = start_var_decl (build_array_type 			 (integer_type_node, 			  build_index_type (build_int_cst (NULL_TREE,
literal|2
argument|-
literal|1
argument|))),
literal|"_OBJC_IMAGE_INFO"
argument|);    initlist = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE,
literal|0
argument|));   initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, flags), initlist);   initlist = objc_build_constructor (TREE_TYPE (decl), nreverse (initlist));    finish_var_decl (decl, initlist); }
comment|/* Look up ID as an instance variable.  OTHER contains the result of    the C or C++ lookup, which we may want to use instead.  */
argument|tree objc_lookup_ivar (tree other, tree id) {   tree ivar;
comment|/* If we are not inside of an ObjC method, ivar lookup makes no sense.  */
argument|if (!objc_method_context)     return other;    if (!strcmp (IDENTIFIER_POINTER (id),
literal|"super"
argument|))
comment|/* We have a message to super.  */
argument|return get_super_receiver ();
comment|/* In a class method, look up an instance variable only as a last      resort.  */
argument|if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL&& other&& other != error_mark_node)     return other;
comment|/* Look up the ivar, but do not use it if it is not accessible.  */
argument|ivar = is_ivar (objc_ivar_chain, id);    if (!ivar || is_private (ivar))     return other;
comment|/* In an instance method, a local variable (or parameter) may hide the      instance variable.  */
argument|if (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL&& other&& other != error_mark_node
ifdef|#
directive|ifdef
name|OBJCPLUS
argument|&& CP_DECL_CONTEXT (other) != global_namespace)
else|#
directive|else
argument|&& !DECL_FILE_SCOPE_P (other)
argument_list|)
endif|#
directive|endif
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"local declaration of %qs hides instance variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|other
return|;
block|}
comment|/* At this point, we are either in an instance method with no obscuring      local definitions, or in a class method with no alternate definitions      at all.  */
return|return
name|build_ivar_reference
argument_list|(
name|id
argument_list|)
return|;
block|}
comment|/* Possibly rewrite a function CALL into an OBJ_TYPE_REF expression.  This    needs to be done if we are calling a function through a cast.  */
name|tree
name|objc_rewrite_function_call
parameter_list|(
name|tree
name|function
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|function
operator|=
name|build3
argument_list|(
name|OBJ_TYPE_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
argument_list|,
name|size_zero_node
argument_list|)
expr_stmt|;
block|}
return|return
name|function
return|;
block|}
comment|/* Look for the special case of OBJC_TYPE_REF with the address of    a function in OBJ_TYPE_REF_EXPR (presumably objc_msgSend or one    of its cousins).  */
name|enum
name|gimplify_status
name|objc_gimplify_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|enum
name|gimplify_status
name|r0
decl_stmt|,
name|r1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|OBJ_TYPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|OBJ_TYPE_REF_EXPR
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|OBJ_TYPE_REF_EXPR
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Postincrements in OBJ_TYPE_REF_OBJECT don't affect the 	 value of the OBJ_TYPE_REF, so force them to be emitted 	 during subexpression evaluation rather than after the 	 OBJ_TYPE_REF. This permits objc_msgSend calls in Objective 	 C to use direct rather than indirect calls when the 	 object expression has a postincrement.  */
name|r0
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|OBJ_TYPE_REF_OBJECT
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|OBJ_TYPE_REF_EXPR
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|OBJCPLUS
return|return
name|cp_gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
return|;
else|#
directive|else
return|return
name|c_gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/* Given a CALL expression, find the function being called.  The ObjC    version looks for the OBJ_TYPE_REF_EXPR which is used for objc_msgSend.  */
name|tree
name|objc_get_callee_fndecl
parameter_list|(
name|tree
name|call_expr
parameter_list|)
block|{
name|tree
name|addr
init|=
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|OBJ_TYPE_REF
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|OBJ_TYPE_REF_EXPR
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If the address is just `&f' for some function `f', then we know      that `f' is being called.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-objc-objc-act.h"
end_include

end_unit

