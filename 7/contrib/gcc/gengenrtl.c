begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code to allocate RTL structures.    Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_struct
struct|struct
name|rtx_definition
block|{
specifier|const
name|char
modifier|*
specifier|const
name|enumname
decl_stmt|,
modifier|*
decl_stmt|const
name|name
decl_stmt|,
modifier|*
decl_stmt|const
name|format
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* rtl.def needs CONST_DOUBLE_FORMAT, but we don't care what    CONST_DOUBLE_FORMAT is because we're not going to be generating    anything for CONST_DOUBLE anyway.  */
end_comment

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|""
end_define

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|{ #ENUM, NAME, FORMAT },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|rtx_definition
name|defs
index|[]
init|=
block|{
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_RTX_CODE
value|ARRAY_SIZE(defs)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|formats
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|type_from_format
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|accessor_from_format
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|special_format
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|special_rtx
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|excluded_rtx
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_formats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gendecl
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|genmacro
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gendef
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|genlegend
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|genheader
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gencode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Decode a format letter into a C type string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_from_format
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
return|return
literal|"int "
return|;
case|case
literal|'w'
case|:
return|return
literal|"HOST_WIDE_INT "
return|;
case|case
literal|'s'
case|:
return|return
literal|"const char *"
return|;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
return|return
literal|"rtx "
return|;
case|case
literal|'E'
case|:
return|return
literal|"rtvec "
return|;
case|case
literal|'b'
case|:
return|return
literal|"struct bitmap_head_def *"
return|;
comment|/* bitmap - typedef not available */
case|case
literal|'t'
case|:
return|return
literal|"union tree_node *"
return|;
comment|/* tree - typedef not available */
case|case
literal|'B'
case|:
return|return
literal|"struct basic_block_def *"
return|;
comment|/* basic block - typedef not available */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode a format letter into the proper accessor function.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|accessor_from_format
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
return|return
literal|"XINT"
return|;
case|case
literal|'w'
case|:
return|return
literal|"XWINT"
return|;
case|case
literal|'s'
case|:
return|return
literal|"XSTR"
return|;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
return|return
literal|"XEXP"
return|;
case|case
literal|'E'
case|:
return|return
literal|"XVEC"
return|;
case|case
literal|'b'
case|:
return|return
literal|"XBITMAP"
return|;
case|case
literal|'t'
case|:
return|return
literal|"XTREE"
return|;
case|case
literal|'B'
case|:
return|return
literal|"XBBDEF"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if we should ignore FMT, an RTL format, when making    the list of formats we write routines to create.  */
end_comment

begin_function
specifier|static
name|int
name|special_format
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
return|return
operator|(
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'*'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'V'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'S'
argument_list|)
operator|!=
literal|0
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'n'
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the RTL code given by index IDX is one that we should    generate a gen_rtx_raw_FOO macro for, not gen_rtx_FOO (because gen_rtx_FOO    is a wrapper in emit-rtl.c).  */
end_comment

begin_function
specifier|static
name|int
name|special_rtx
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"CONST_INT"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"REG"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"SUBREG"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"MEM"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"CONST_VECTOR"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the RTL code given by index IDX is one that we should    generate no macro for at all (because gen_rtx_FOO is never used or    cannot have the obvious interface).  */
end_comment

begin_function
specifier|static
name|int
name|excluded_rtx
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|,
literal|"CONST_DOUBLE"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Place a list of all format specifiers we use into the array FORMAT.  */
end_comment

begin_function
specifier|static
name|void
name|find_formats
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|special_format
argument_list|(
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|f
operator|=
name|formats
init|;
operator|*
name|f
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|f
argument_list|,
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|f
operator|==
literal|0
condition|)
operator|*
name|f
operator|=
name|defs
index|[
name|i
index|]
operator|.
name|format
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the declarations for the routine to allocate RTL with FORMAT.  */
end_comment

begin_function
specifier|static
name|void
name|gendecl
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pos
decl_stmt|;
name|printf
argument_list|(
literal|"extern rtx gen_rtx_fmt_%s\t (RTX_CODE, "
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enum machine_mode mode"
argument_list|)
expr_stmt|;
comment|/* Write each parameter that is needed and start a new line when the line      would overflow.  */
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
literal|75
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
block|{
name|int
name|ourlen
init|=
name|strlen
argument_list|(
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|+
literal|6
operator|+
operator|(
name|i
operator|>
literal|9
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|ourlen
operator|>
literal|76
condition|)
name|printf
argument_list|(
literal|"\n\t\t\t\t      "
argument_list|)
operator|,
name|pos
operator|=
literal|39
expr_stmt|;
name|printf
argument_list|(
literal|" %sarg%d"
argument_list|,
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|ourlen
expr_stmt|;
block|}
name|printf
argument_list|(
literal|");\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate macros to generate RTL of code IDX using the functions we    write.  */
end_comment

begin_function
specifier|static
name|void
name|genmacro
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We write a macro that defines gen_rtx_RTLCODE to be an equivalent to      gen_rtx_fmt_FORMAT where FORMAT is the RTX_FORMAT of RTLCODE.  */
if|if
condition|(
name|excluded_rtx
argument_list|(
name|idx
argument_list|)
condition|)
comment|/* Don't define a macro for this code.  */
return|return;
name|printf
argument_list|(
literal|"#define gen_rtx_%s%s(MODE"
argument_list|,
name|special_rtx
argument_list|(
name|idx
argument_list|)
condition|?
literal|"raw_"
else|:
literal|""
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|defs
index|[
name|idx
index|]
operator|.
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|", ARG%d"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|") \\\n  gen_rtx_fmt_%s (%s, (MODE)"
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|format
argument_list|,
name|defs
index|[
name|idx
index|]
operator|.
name|enumname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|defs
index|[
name|idx
index|]
operator|.
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|", (ARG%d)"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code for the function to generate RTL whose    format is FORMAT.  */
end_comment

begin_function
specifier|static
name|void
name|gendef
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Start by writing the definition of the function name and the types      of the arguments.  */
name|printf
argument_list|(
literal|"rtx\ngen_rtx_fmt_%s (RTX_CODE code, enum machine_mode mode"
argument_list|,
name|format
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|",\n\t%sarg%d"
argument_list|,
name|type_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|/* Now write out the body of the function itself, which allocates      the memory and initializes it.  */
name|puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  rtx rt;"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  rt = rtx_alloc (code);\n"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  PUT_MODE (rt, mode);"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|format
operator|,
name|i
operator|=
name|j
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
operator|,
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'0'
condition|)
name|printf
argument_list|(
literal|"  %s (rt, %d) = arg%d;\n"
argument_list|,
name|accessor_from_format
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|i
argument_list|,
name|j
operator|++
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  X0EXP (rt, %d) = NULL_RTX;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n  return rt;\n}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the documentation header for files we write.  */
end_comment

begin_function
specifier|static
name|void
name|genlegend
parameter_list|(
name|void
parameter_list|)
block|{
name|puts
argument_list|(
literal|"/* Generated automatically by gengenrtl from rtl.def.  */\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the text of the header file we make, genrtl.h.  */
end_comment

begin_function
specifier|static
name|void
name|genheader
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|fmt
decl_stmt|;
name|puts
argument_list|(
literal|"#ifndef GCC_GENRTL_H"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#define GCC_GENRTL_H\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|formats
init|;
operator|*
name|fmt
condition|;
operator|++
name|fmt
control|)
name|gendecl
argument_list|(
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|special_format
argument_list|(
name|defs
index|[
name|i
index|]
operator|.
name|format
argument_list|)
condition|)
name|genmacro
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n#endif /* GCC_GENRTL_H */"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the text of the code file we write, genrtl.c.  */
end_comment

begin_function
specifier|static
name|void
name|gencode
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|fmt
decl_stmt|;
name|puts
argument_list|(
literal|"#include \"config.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"system.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"coretypes.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"tm.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"obstack.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"rtl.h\""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#include \"ggc.h\"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|formats
init|;
operator|*
name|fmt
operator|!=
literal|0
condition|;
name|fmt
operator|++
control|)
name|gendef
argument_list|(
operator|*
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the main program.  We accept only one argument, "-h", which    says we are writing the genrtl.h file.  Otherwise we are writing the    genrtl.c file.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|find_formats
argument_list|()
expr_stmt|;
name|genlegend
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
name|genheader
argument_list|()
expr_stmt|;
else|else
name|gencode
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

end_unit

