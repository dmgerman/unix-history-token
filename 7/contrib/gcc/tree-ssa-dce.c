begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dead code elimination pass for the GNU compiler.    Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Ben Elliston<bje@redhat.com>    and Andrew MacLeod<amacleod@redhat.com>    Adapted to use control dependence by Steven Bosscher, SUSE Labs.   This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Dead code elimination.     References:       Building an Optimizing Compiler,      Robert Morgan, Butterworth-Heinemann, 1998, Section 8.9.       Advanced Compiler Design and Implementation,      Steven Muchnick, Morgan Kaufmann, 1997, Section 18.10.     Dead-code elimination is the removal of statements which have no    impact on the program's output.  "Dead statements" have no impact    on the program's output, while "necessary statements" may have    impact on the output.     The algorithm consists of three phases:    1. Marking as necessary all statements known to be necessary,       e.g. most function calls, writing a value to memory, etc;    2. Propagating necessary statements, e.g., the statements       giving values to operands in necessary statements; and    3. Removing dead statements.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* These RTL headers are needed for basic-block.h.  */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_escape
end_escape

begin_struct
specifier|static
struct|struct
name|stmt_stats
block|{
name|int
name|total
decl_stmt|;
name|int
name|total_phis
decl_stmt|;
name|int
name|removed
decl_stmt|;
name|int
name|removed_phis
decl_stmt|;
block|}
name|stats
struct|;
end_struct

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|worklist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Vector indicating an SSA name has already been processed and marked    as necessary.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|processed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indicating that last_stmt if a basic block has already been    marked as necessary.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|last_stmt_necessary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Before we can determine whether a control branch is dead, we need to    compute which blocks are control dependent on which edges.     We expect each block to be control dependent on very few edges so we    use a bitmap for each block recording its edges.  An array holds the    bitmap.  The Ith bit in the bitmap is set if that block is dependent    on the Ith edge.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
modifier|*
name|control_dependence_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indicating that a basic block has already had all the edges    processed that it is control dependent on.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|visited_control_parents
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if this pass alters the CFG (by removing control statements).    FALSE otherwise.     If this pass alters the CFG, then it will arrange for the dominators    to be recomputed.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|cfg_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Execute code that follows the macro for each edge (given number    EDGE_NUMBER within the CODE) for which the block with index N is    control dependent.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_CONTROL_DEPENDENT
parameter_list|(
name|BI
parameter_list|,
name|N
parameter_list|,
name|EDGE_NUMBER
parameter_list|)
define|\
value|EXECUTE_IF_SET_IN_BITMAP (control_dependence_map[(N)], 0,	\ 			    (EDGE_NUMBER), (BI))
end_define

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|set_control_dependence_map_bit
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|clear_control_dependence_bitmap
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_all_control_dependences
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_control_dependence
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|basic_block
name|find_pdom
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mark_stmt_necessary
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mark_operand_necessary
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_stmt_if_obviously_necessary
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_obviously_necessary_stmts
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_control_dependent_edges_necessary
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_necessity
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_unnecessary_stmts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_dead_phis
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_dead_stmt
parameter_list|(
name|block_stmt_iterator
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tree_dce_init
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tree_dce_done
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Indicate block BB is control dependent on an edge with index EDGE_INDEX.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_control_dependence_map_bit
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|edge_index
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return;
name|gcc_assert
argument_list|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|control_dependence_map
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|edge_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear all control dependences for block BB.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|clear_control_dependence_bitmap
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|bitmap_clear
argument_list|(
name|control_dependence_map
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record all blocks' control dependences on all edges in the edge    list EL, ala Morgan, Section 3.6.  */
end_comment

begin_function
specifier|static
name|void
name|find_all_control_dependences
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
condition|;
operator|++
name|i
control|)
name|find_control_dependence
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine all blocks' control dependences on the given edge with edge_list    EL index EDGE_INDEX, ala Morgan, Section 3.6.  */
end_comment

begin_function
specifier|static
name|void
name|find_control_dependence
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|,
name|int
name|edge_index
parameter_list|)
block|{
name|basic_block
name|current_block
decl_stmt|;
name|basic_block
name|ending_block
decl_stmt|;
name|gcc_assert
argument_list|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|ending_block
operator|=
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
else|else
name|ending_block
operator|=
name|find_pdom
argument_list|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|current_block
operator|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
init|;
name|current_block
operator|!=
name|ending_block
operator|&&
name|current_block
operator|!=
name|EXIT_BLOCK_PTR
condition|;
name|current_block
operator|=
name|find_pdom
argument_list|(
name|current_block
argument_list|)
control|)
block|{
name|edge
name|e
init|=
name|INDEX_EDGE
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
decl_stmt|;
comment|/* For abnormal edges, we don't make current_block control 	 dependent because instructions that throw are always necessary 	 anyway.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
continue|continue;
name|set_control_dependence_map_bit
argument_list|(
name|current_block
argument_list|,
name|edge_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the immediate postdominator PDOM of the specified basic block BLOCK.    This function is necessary because some blocks have negative numbers.  */
end_comment

begin_function
specifier|static
specifier|inline
name|basic_block
name|find_pdom
parameter_list|(
name|basic_block
name|block
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|block
operator|!=
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|EXIT_BLOCK_PTR
return|;
else|else
block|{
name|basic_block
name|bb
init|=
name|get_immediate_dominator
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
return|return
name|EXIT_BLOCK_PTR
return|;
return|return
name|bb
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|NECESSARY
parameter_list|(
name|stmt
parameter_list|)
value|stmt->common.asm_written_flag
end_define

begin_comment
comment|/* If STMT is not already marked necessary, mark it, and add it to the    worklist if ADD_TO_WORKLIST is true.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_stmt_necessary
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
name|add_to_worklist
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|DECL_P
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Marking useful stmt: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|add_to_worklist
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the statement defining operand OP as necessary.  PHIONLY is true    if we should only mark it necessary if it is a phi node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_operand_necessary
parameter_list|(
name|tree
name|op
parameter_list|,
name|bool
name|phionly
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|int
name|ver
decl_stmt|;
name|gcc_assert
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ver
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|processed
argument_list|,
name|ver
argument_list|)
condition|)
return|return;
name|SET_BIT
argument_list|(
name|processed
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
operator|||
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
operator|||
operator|(
name|phionly
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
operator|)
condition|)
return|return;
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark STMT as necessary if it obviously is.  Add it to the worklist if    it can make other statements necessary.     If AGGRESSIVE is false, control statements are conservatively marked as    necessary.  */
end_comment

begin_function
specifier|static
name|void
name|mark_stmt_if_obviously_necessary
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
name|aggressive
parameter_list|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
name|tree
name|op
decl_stmt|;
comment|/* With non-call exceptions, we have to assume that all statements could      throw.  If a statement may throw, it is inherently necessary.  */
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|tree_could_throw_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Statements that are implicitly live.  Most function calls, asm and return      statements are required.  Labels and BIND_EXPR nodes are kept because      they are control flow, and we have no way of knowing whether they can be      removed.  DCE can eliminate all the other statements in a block, and CFG      can then remove the block and labels.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|BIND_EXPR
case|:
case|case
name|LABEL_EXPR
case|:
case|case
name|CASE_LABEL_EXPR
case|:
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
case|case
name|ASM_EXPR
case|:
case|case
name|RESX_EXPR
case|:
case|case
name|RETURN_EXPR
case|:
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
comment|/* Most, but not all function calls are required.  Function calls that 	 produce no result and have no side effects (i.e. const pure 	 functions) are unnecessary.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|stmt
argument_list|)
condition|)
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
name|op
operator|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* These values are mildly magic bits of the EH runtime.  We can't 	 see the entire lifetime of these values until landing pads are 	 generated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EXC_PTR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FILTER_EXPR
condition|)
block|{
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|GOTO_EXPR
case|:
name|gcc_assert
argument_list|(
operator|!
name|simple_goto_p
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXPR
case|:
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|succs
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|SWITCH_EXPR
case|:
if|if
condition|(
operator|!
name|aggressive
condition|)
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If the statement has volatile operands, it needs to be preserved.      Same for statements that can alter control flow in unpredictable      ways.  */
if|if
condition|(
name|ann
operator|->
name|has_volatile_ops
operator|||
name|is_ctrl_altering_stmt
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_hidden_global_store
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|mark_stmt_necessary
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find obviously necessary statements.  These are things like most function    calls, and stores to file level variables.     If EL is NULL, control statements are conservatively marked as    necessary.  Otherwise it contains the list of edges used by control    dependence analysis.  */
end_comment

begin_function
specifier|static
name|void
name|find_obviously_necessary_stmts
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
comment|/* Check any PHI nodes in the block.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|NECESSARY
argument_list|(
name|phi
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* PHIs for virtual variables do not directly affect code 	     generation and need not be considered inherently necessary 	     regardless of the bits set in their decl.  	     Thus, we only need to mark PHIs for real variables which 	     need their result preserved as being inherently necessary.  */
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|&&
name|is_global_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
condition|)
name|mark_stmt_necessary
argument_list|(
name|phi
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Check all statements in the block.  */
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
name|mark_stmt_if_obviously_necessary
argument_list|(
name|stmt
argument_list|,
name|el
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|el
condition|)
block|{
comment|/* Prevent the loops from being removed.  We must keep the infinite loops, 	 and we currently do not have a means to recognize the finite ones.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
condition|)
name|mark_control_dependent_edges_necessary
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|el
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make corresponding control dependent edges necessary.  We only    have to do this once for each basic block, so we clear the bitmap    after we're done.  */
end_comment

begin_function
specifier|static
name|void
name|mark_control_dependent_edges_necessary
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|edge_number
decl_stmt|;
name|gcc_assert
argument_list|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return;
name|EXECUTE_IF_CONTROL_DEPENDENT
argument_list|(
argument|bi
argument_list|,
argument|bb->index
argument_list|,
argument|edge_number
argument_list|)
block|{
name|tree
name|t
decl_stmt|;
name|basic_block
name|cd_bb
init|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|el
argument_list|,
name|edge_number
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|last_stmt_necessary
argument_list|,
name|cd_bb
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|last_stmt_necessary
argument_list|,
name|cd_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|t
operator|=
name|last_stmt
argument_list|(
name|cd_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|is_ctrl_stmt
argument_list|(
name|t
argument_list|)
condition|)
name|mark_stmt_necessary
argument_list|(
name|t
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Propagate necessity using the operands of necessary statements.  Process    the uses on each statement in the worklist, and add all feeding statements    which contribute to the calculation of this value to the worklist.     In conservative mode, EL is NULL.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_necessity
parameter_list|(
name|struct
name|edge_list
modifier|*
name|el
parameter_list|)
block|{
name|tree
name|i
decl_stmt|;
name|bool
name|aggressive
init|=
operator|(
name|el
condition|?
name|true
else|:
name|false
operator|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nProcessing worklist:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Take `i' from worklist.  */
name|i
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"processing: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|i
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aggressive
condition|)
block|{
comment|/* Mark the last statements of the basic blocks that the block 	     containing `i' is control dependent on, but only if we haven't 	     already done so.  */
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited_control_parents
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|visited_control_parents
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|mark_control_dependent_edges_necessary
argument_list|(
name|bb
argument_list|,
name|el
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|i
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
comment|/* PHI nodes are somewhat special in that each PHI alternative has 	     data and control dependencies.  All the statements feeding the 	     PHI node's arguments are always necessary.  In aggressive mode, 	     we also consider the control dependent edges leading to the 	     predecessor block associated with each PHI alternative as 	     necessary.  */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|i
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|mark_operand_necessary
argument_list|(
name|arg
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aggressive
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|i
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|basic_block
name|arg_bb
init|=
name|PHI_ARG_EDGE
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|arg_bb
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited_control_parents
argument_list|,
name|arg_bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|visited_control_parents
argument_list|,
name|arg_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|mark_control_dependent_edges_necessary
argument_list|(
name|arg_bb
argument_list|,
name|el
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Propagate through the operands.  Examine all the USE, VUSE and 	     V_MAY_DEF operands in this statement.  Mark all the statements  	     which feed this statement's uses as necessary.  */
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|use
decl_stmt|;
comment|/* The operands of V_MAY_DEF expressions are also needed as they 	     represent potential definitions that may reach this 	     statement (V_MAY_DEF operands allow us to follow def-def  	     links).  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|i
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES
argument_list|)
name|mark_operand_necessary
argument_list|(
name|use
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Propagate necessity around virtual phi nodes used in kill operands.    The reason this isn't done during propagate_necessity is because we don't    want to keep phis around that are just there for must-defs, unless we    absolutely have to.  After we've rewritten the reaching definitions to be    correct in the previous part of the fixup routine, we can simply propagate    around the information about which of these virtual phi nodes are really    used, and set the NECESSARY flag accordingly.    Note that we do the minimum here to ensure that we keep alive the phis that    are actually used in the corrected SSA form.  In particular, some of these    phis may now have all of the same operand, and will be deleted by some    other pass.  */
end_comment

begin_function
specifier|static
name|void
name|mark_really_necessary_kill_operand_phis
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Seed the worklist with the new virtual phi arguments and virtual      uses */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|&&
name|NECESSARY
argument_list|(
name|phi
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_operand_necessary
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|NECESSARY
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|use_operand_p
name|use_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|mark_operand_necessary
argument_list|(
name|use
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Mark all virtual phis still in use as necessary, and all of their      arguments that are phis as necessary.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|use
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|use
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_operand_necessary
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|use
argument_list|,
name|i
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Eliminate unnecessary statements. Any instruction not marked as necessary    contributes nothing to the program, and can be deleted.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_unnecessary_stmts
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|i
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nEliminating unnecessary statements:\n"
argument_list|)
expr_stmt|;
name|clear_special_calls
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Remove dead PHI nodes.  */
name|remove_dead_phis
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Remove dead statements.  */
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
control|)
block|{
name|tree
name|t
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|stats
operator|.
name|total
operator|++
expr_stmt|;
comment|/* If `i' is not necessary then remove it.  */
if|if
condition|(
operator|!
name|NECESSARY
argument_list|(
name|t
argument_list|)
condition|)
name|remove_dead_stmt
argument_list|(
operator|&
name|i
argument_list|,
name|bb
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
condition|)
name|notice_special_calls
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove dead PHI nodes from block BB.  */
end_comment

begin_function
specifier|static
name|void
name|remove_dead_phis
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|prev
decl_stmt|,
name|phi
decl_stmt|;
name|prev
operator|=
name|NULL_TREE
expr_stmt|;
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
name|phi
condition|)
block|{
name|stats
operator|.
name|total_phis
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|NECESSARY
argument_list|(
name|phi
argument_list|)
condition|)
block|{
name|tree
name|next
init|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Deleting : "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|remove_phi_node
argument_list|(
name|phi
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|stats
operator|.
name|removed_phis
operator|++
expr_stmt|;
name|phi
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|phi
expr_stmt|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove dead statement pointed to by iterator I.  Receives the basic block BB    containing I so that we don't have to look it up.  */
end_comment

begin_function
specifier|static
name|void
name|remove_dead_stmt
parameter_list|(
name|block_stmt_iterator
modifier|*
name|i
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|t
init|=
name|bsi_stmt
argument_list|(
operator|*
name|i
argument_list|)
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Deleting : "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|t
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|removed
operator|++
expr_stmt|;
comment|/* If we have determined that a conditional branch statement contributes      nothing to the program, then we not only remove it, but we also change      the flow graph so that the current block will simply fall-thru to its      immediate post-dominator.  The blocks we are circumventing will be      removed by cleanup_tree_cfg if this change in the flow graph makes them      unreachable.  */
if|if
condition|(
name|is_ctrl_stmt
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|basic_block
name|post_dom_bb
decl_stmt|;
comment|/* The post dominance info has to be up-to-date.  */
name|gcc_assert
argument_list|(
name|dom_computed
index|[
name|CDI_POST_DOMINATORS
index|]
operator|==
name|DOM_OK
argument_list|)
expr_stmt|;
comment|/* Get the immediate post dominator of bb.  */
name|post_dom_bb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* There are three particularly problematical cases.  	 1. Blocks that do not have an immediate post dominator.  This 	    can happen with infinite loops.  	 2. Blocks that are only post dominated by the exit block.  These 	    can also happen for infinite loops as we create fake edges 	    in the dominator tree.  	 3. If the post dominator has PHI nodes we may be able to compute 	    the right PHI args for them.   	 In each of these cases we must remove the control statement 	 as it may reference SSA_NAMEs which are going to be removed and 	 we remove all but one outgoing edge from the block.  */
if|if
condition|(
operator|!
name|post_dom_bb
operator|||
name|post_dom_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|phi_nodes
argument_list|(
name|post_dom_bb
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
comment|/* Redirect the first edge out of BB to reach POST_DOM_BB.  */
name|redirect_edge_and_branch
argument_list|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
argument_list|,
name|post_dom_bb
argument_list|)
expr_stmt|;
name|PENDING_STMT
argument_list|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
comment|/* The edge is no longer associated with a conditional, so it does 	 not have TRUE/FALSE flags.  */
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator|)
expr_stmt|;
comment|/* The lone outgoing edge from BB will be a fallthru edge.  */
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
comment|/* Remove the remaining the outgoing edges.  */
while|while
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
comment|/* FIXME.  When we remove the edge, we modify the CFG, which 	     in turn modifies the dominator and post-dominator tree. 	     Is it safe to postpone recomputing the dominator and 	     post-dominator tree until the end of this pass given that 	     the post-dominators are used above?  */
name|cfg_altered
operator|=
name|true
expr_stmt|;
name|remove_edge
argument_list|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|t
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
block|{
name|tree
name|def
init|=
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
decl_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bsi_remove
argument_list|(
name|i
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|release_defs
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out removed statement statistics.  */
end_comment

begin_function
specifier|static
name|void
name|print_stats
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
operator|(
name|TDF_STATS
operator||
name|TDF_DETAILS
operator|)
operator|)
condition|)
block|{
name|float
name|percg
decl_stmt|;
name|percg
operator|=
operator|(
operator|(
name|float
operator|)
name|stats
operator|.
name|removed
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|total
operator|)
operator|*
literal|100
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Removed %d of %d statements (%d%%)\n"
argument_list|,
name|stats
operator|.
name|removed
argument_list|,
name|stats
operator|.
name|total
argument_list|,
operator|(
name|int
operator|)
name|percg
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|total_phis
operator|==
literal|0
condition|)
name|percg
operator|=
literal|0
expr_stmt|;
else|else
name|percg
operator|=
operator|(
operator|(
name|float
operator|)
name|stats
operator|.
name|removed_phis
operator|/
operator|(
name|float
operator|)
name|stats
operator|.
name|total_phis
operator|)
operator|*
literal|100
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Removed %d of %d PHI nodes (%d%%)\n"
argument_list|,
name|stats
operator|.
name|removed_phis
argument_list|,
name|stats
operator|.
name|total_phis
argument_list|,
operator|(
name|int
operator|)
name|percg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialization for this pass.  Set up the used data structures.  */
end_comment

begin_function
specifier|static
name|void
name|tree_dce_init
parameter_list|(
name|bool
name|aggressive
parameter_list|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggressive
condition|)
block|{
name|int
name|i
decl_stmt|;
name|control_dependence_map
operator|=
name|XNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
condition|;
operator|++
name|i
control|)
name|control_dependence_map
index|[
name|i
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|last_stmt_necessary
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|last_stmt_necessary
argument_list|)
expr_stmt|;
block|}
name|processed
operator|=
name|sbitmap_alloc
argument_list|(
name|num_ssa_names
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|processed
argument_list|)
expr_stmt|;
name|worklist
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|cfg_altered
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup after this pass.  */
end_comment

begin_function
specifier|static
name|void
name|tree_dce_done
parameter_list|(
name|bool
name|aggressive
parameter_list|)
block|{
if|if
condition|(
name|aggressive
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_basic_block
condition|;
operator|++
name|i
control|)
name|BITMAP_FREE
argument_list|(
name|control_dependence_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|control_dependence_map
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited_control_parents
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|last_stmt_necessary
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|processed
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main routine to eliminate dead code.     AGGRESSIVE controls the aggressiveness of the algorithm.    In conservative mode, we ignore control dependence and simply declare    all but the most trivially dead branches necessary.  This mode is fast.    In aggressive mode, control dependences are taken into account, which    results in more dead code elimination, but at the cost of some time.     FIXME: Aggressive mode before PRE doesn't work currently because 	  the dominance info is not invalidated after DCE1.  This is 	  not an issue right now because we only run aggressive DCE 	  as the last tree SSA pass, but keep this in mind when you 	  start experimenting with pass ordering.  */
end_comment

begin_function
specifier|static
name|void
name|perform_tree_ssa_dce
parameter_list|(
name|bool
name|aggressive
parameter_list|)
block|{
name|struct
name|edge_list
modifier|*
name|el
init|=
name|NULL
decl_stmt|;
name|tree_dce_init
argument_list|(
name|aggressive
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggressive
condition|)
block|{
comment|/* Compute control dependence.  */
name|timevar_push
argument_list|(
name|TV_CONTROL_DEPENDENCES
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|el
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|find_all_control_dependences
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CONTROL_DEPENDENCES
argument_list|)
expr_stmt|;
name|visited_control_parents
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited_control_parents
argument_list|)
expr_stmt|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
block|}
name|find_obviously_necessary_stmts
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|propagate_necessity
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|mark_really_necessary_kill_operand_phis
argument_list|()
expr_stmt|;
name|eliminate_unnecessary_stmts
argument_list|()
expr_stmt|;
if|if
condition|(
name|aggressive
condition|)
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* If we removed paths in the CFG, then we need to update      dominators as well.  I haven't investigated the possibility      of incrementally updating dominators.  */
if|if
condition|(
name|cfg_altered
condition|)
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Debugging dumps.  */
if|if
condition|(
name|dump_file
condition|)
name|print_stats
argument_list|()
expr_stmt|;
name|tree_dce_done
argument_list|(
name|aggressive
argument_list|)
expr_stmt|;
name|free_edge_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass entry points.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_dce
parameter_list|(
name|void
parameter_list|)
block|{
name|perform_tree_ssa_dce
argument_list|(
comment|/*aggressive=*/
name|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_dce_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|perform_tree_ssa_dce
argument_list|(
comment|/*aggressive=*/
name|false
argument_list|)
expr_stmt|;
name|free_numbers_of_iterations_estimates
argument_list|(
name|current_loops
argument_list|)
expr_stmt|;
name|scev_reset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|tree_ssa_cd_dce
parameter_list|(
name|void
parameter_list|)
block|{
name|perform_tree_ssa_dce
argument_list|(
comment|/*aggressive=*/
name|optimize
operator|>=
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_dce
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_dce
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_dce
init|=
block|{
literal|"dce"
block|,
comment|/* name */
name|gate_dce
block|,
comment|/* gate */
name|tree_ssa_dce
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_DCE
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_cleanup_cfg
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_remove_unused_locals
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_dce_loop
init|=
block|{
literal|"dceloop"
block|,
comment|/* name */
name|gate_dce
block|,
comment|/* gate */
name|tree_ssa_dce_loop
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_DCE
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_cleanup_cfg
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_cd_dce
init|=
block|{
literal|"cddce"
block|,
comment|/* name */
name|gate_dce
block|,
comment|/* gate */
name|tree_ssa_cd_dce
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_CD_DCE
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_cleanup_cfg
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_verify_flow
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

