begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Global, SSA-based optimizations using mathematical identities.    Copyright (C) 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Currently, the only mini-pass in this file tries to CSE reciprocal    operations.  These are common in sequences such as this one:  	modulus = sqrt(x*x + y*y + z*z); 	x = x / modulus; 	y = y / modulus; 	z = z / modulus;     that can be optimized to  	modulus = sqrt(x*x + y*y + z*z);         rmodulus = 1.0 / modulus; 	x = x * rmodulus; 	y = y * rmodulus; 	z = z * rmodulus;     We do this for loop invariant divisors, and with this pass whenever    we notice that a division has the same divisor multiple times.     Of course, like in PRE, we don't insert a division if a dominator    already has one.  However, this cannot be done as an extension of    PRE for several reasons.     First of all, with some experiments it was found out that the    transformation is not always useful if there are only two divisions    hy the same divisor.  This is probably because modern processors    can pipeline the divisions; on older, in-order processors it should    still be effective to optimize two divisions by the same number.    We make this a param, and it shall be called N in the remainder of    this comment.     Second, if trapping math is active, we have less freedom on where    to insert divisions: we can only do so in basic blocks that already    contain one.  (If divisions don't trap, instead, we can insert    divisions elsewhere, which will be in blocks that are common dominators    of those that have the division).     We really don't want to compute the reciprocal unless a division will    be found.  To do this, we won't insert the division in a basic block    that has less than N divisions *post-dominating* it.     The algorithm constructs a subset of the dominator tree, holding the    blocks containing the divisions and the common dominators to them,    and walk it twice.  The first walk is in post-order, and it annotates    each block with the number of divisions that post-dominate it: this    gives information on where divisions can be inserted profitably.    The second walk is in pre-order, and it inserts divisions as explained    above, and replaces divisions by multiplications.     In the best case, the cost of the pass is O(n_statements).  In the    worst-case, the cost is due to creating the dominator tree subset,    with a cost of O(n_basic_blocks ^ 2); however this can only happen    for n_statements / n_basic_blocks statements.  So, the amortized cost    of creating the dominator tree subset is O(n_basic_blocks) and the    worst-case cost of the pass is O(n_statements * n_basic_blocks).     More practically, the cost will be small because there are few    divisions, and they tend to be in the same basic block, so insert_bb    is called very few times.     If we did this using domwalk.c, an efficient implementation would have    to work on all the variables in a single pass, because we could not    work on just a subset of the dominator tree, as we do now, and the    cost would also be something like O(n_statements * n_basic_blocks).    The data structures would be more complex in order to work on all the    variables in a single pass.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* This structure represents one basic block that either computes a    division, or is a common dominator for basic block that compute a    division.  */
end_comment

begin_struct
struct|struct
name|occurrence
block|{
comment|/* The basic block represented by this structure.  */
name|basic_block
name|bb
decl_stmt|;
comment|/* If non-NULL, the SSA_NAME holding the definition for a reciprocal      inserted in BB.  */
name|tree
name|recip_def
decl_stmt|;
comment|/* If non-NULL, the MODIFY_EXPR for a reciprocal computation that      was inserted in BB.  */
name|tree
name|recip_def_stmt
decl_stmt|;
comment|/* Pointer to a list of "struct occurrence"s for blocks dominated      by BB.  */
name|struct
name|occurrence
modifier|*
name|children
decl_stmt|;
comment|/* Pointer to the next "struct occurrence"s in the list of blocks      sharing a common dominator.  */
name|struct
name|occurrence
modifier|*
name|next
decl_stmt|;
comment|/* The number of divisions that are in BB before compute_merit.  The      number of divisions that are in BB or post-dominate it after      compute_merit.  */
name|int
name|num_divisions
decl_stmt|;
comment|/* True if the basic block has a division, false if it is a common      dominator for basic blocks that do.  If it is false and trapping      math is active, BB is not a candidate for inserting a reciprocal.  */
name|bool
name|bb_has_division
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The instance of "struct occurrence" representing the highest    interesting block in the dominator tree.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|occurrence
modifier|*
name|occ_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocation pool for getting instances of "struct occurrence".  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|occ_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate and return a new struct occurrence for basic block BB, and    whose children list is headed by CHILDREN.  */
end_comment

begin_function
specifier|static
name|struct
name|occurrence
modifier|*
name|occ_new
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|occurrence
modifier|*
name|children
parameter_list|)
block|{
name|struct
name|occurrence
modifier|*
name|occ
decl_stmt|;
name|occ
operator|=
name|bb
operator|->
name|aux
operator|=
name|pool_alloc
argument_list|(
name|occ_pool
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|occ
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|occurrence
argument_list|)
argument_list|)
expr_stmt|;
name|occ
operator|->
name|bb
operator|=
name|bb
expr_stmt|;
name|occ
operator|->
name|children
operator|=
name|children
expr_stmt|;
return|return
name|occ
return|;
block|}
end_function

begin_comment
comment|/* Insert NEW_OCC into our subset of the dominator tree.  P_HEAD points to a    list of "struct occurrence"s, one per basic block, having IDOM as    their common dominator.     We try to insert NEW_OCC as deep as possible in the tree, and we also    insert any other block that is a common dominator for BB and one    block already in the tree.  */
end_comment

begin_function
specifier|static
name|void
name|insert_bb
parameter_list|(
name|struct
name|occurrence
modifier|*
name|new_occ
parameter_list|,
name|basic_block
name|idom
parameter_list|,
name|struct
name|occurrence
modifier|*
modifier|*
name|p_head
parameter_list|)
block|{
name|struct
name|occurrence
modifier|*
name|occ
decl_stmt|,
modifier|*
modifier|*
name|p_occ
decl_stmt|;
for|for
control|(
name|p_occ
operator|=
name|p_head
init|;
operator|(
name|occ
operator|=
operator|*
name|p_occ
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|basic_block
name|bb
init|=
name|new_occ
operator|->
name|bb
decl_stmt|,
name|occ_bb
init|=
name|occ
operator|->
name|bb
decl_stmt|;
name|basic_block
name|dom
init|=
name|nearest_common_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|occ_bb
argument_list|,
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|dom
operator|==
name|bb
condition|)
block|{
comment|/* BB dominates OCC_BB.  OCC becomes NEW_OCC's child: remove OCC 	     from its list.  */
operator|*
name|p_occ
operator|=
name|occ
operator|->
name|next
expr_stmt|;
name|occ
operator|->
name|next
operator|=
name|new_occ
operator|->
name|children
expr_stmt|;
name|new_occ
operator|->
name|children
operator|=
name|occ
expr_stmt|;
comment|/* Try the next block (it may as well be dominated by BB).  */
block|}
elseif|else
if|if
condition|(
name|dom
operator|==
name|occ_bb
condition|)
block|{
comment|/* OCC_BB dominates BB.  Tail recurse to look deeper.  */
name|insert_bb
argument_list|(
name|new_occ
argument_list|,
name|dom
argument_list|,
operator|&
name|occ
operator|->
name|children
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|dom
operator|!=
name|idom
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|dom
operator|->
name|aux
argument_list|)
expr_stmt|;
comment|/* There is a dominator between IDOM and BB, add it and make 	     two children out of NEW_OCC and OCC.  First, remove OCC from 	     its list.	*/
operator|*
name|p_occ
operator|=
name|occ
operator|->
name|next
expr_stmt|;
name|new_occ
operator|->
name|next
operator|=
name|occ
expr_stmt|;
name|occ
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* None of the previous blocks has DOM as a dominator: if we tail 	     recursed, we would reexamine them uselessly. Just switch BB with 	     DOM, and go on looking for blocks dominated by DOM.  */
name|new_occ
operator|=
name|occ_new
argument_list|(
name|dom
argument_list|,
name|new_occ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Nothing special, go on with the next element.  */
name|p_occ
operator|=
operator|&
name|occ
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* No place was found as a child of IDOM.  Make BB a sibling of IDOM.  */
name|new_occ
operator|->
name|next
operator|=
operator|*
name|p_head
expr_stmt|;
operator|*
name|p_head
operator|=
name|new_occ
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register that we found a division in BB.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|register_division_in
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|occurrence
modifier|*
name|occ
decl_stmt|;
name|occ
operator|=
operator|(
expr|struct
name|occurrence
operator|*
operator|)
name|bb
operator|->
name|aux
expr_stmt|;
if|if
condition|(
operator|!
name|occ
condition|)
block|{
name|occ
operator|=
name|occ_new
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|insert_bb
argument_list|(
name|occ
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|,
operator|&
name|occ_head
argument_list|)
expr_stmt|;
block|}
name|occ
operator|->
name|bb_has_division
operator|=
name|true
expr_stmt|;
name|occ
operator|->
name|num_divisions
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the number of divisions that postdominate each block in OCC and    its children.  */
end_comment

begin_function
specifier|static
name|void
name|compute_merit
parameter_list|(
name|struct
name|occurrence
modifier|*
name|occ
parameter_list|)
block|{
name|struct
name|occurrence
modifier|*
name|occ_child
decl_stmt|;
name|basic_block
name|dom
init|=
name|occ
operator|->
name|bb
decl_stmt|;
for|for
control|(
name|occ_child
operator|=
name|occ
operator|->
name|children
init|;
name|occ_child
condition|;
name|occ_child
operator|=
name|occ_child
operator|->
name|next
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|occ_child
operator|->
name|children
condition|)
name|compute_merit
argument_list|(
name|occ_child
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_exceptions
condition|)
name|bb
operator|=
name|single_noncomplex_succ
argument_list|(
name|dom
argument_list|)
expr_stmt|;
else|else
name|bb
operator|=
name|dom
expr_stmt|;
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|occ_child
operator|->
name|bb
argument_list|)
condition|)
name|occ
operator|->
name|num_divisions
operator|+=
name|occ_child
operator|->
name|num_divisions
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return whether USE_STMT is a floating-point division by DEF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_division_by
parameter_list|(
name|tree
name|use_stmt
parameter_list|,
name|tree
name|def
parameter_list|)
block|{
return|return
name|TREE_CODE
argument_list|(
name|use_stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RDIV_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|def
return|;
block|}
end_function

begin_comment
comment|/* Walk the subset of the dominator tree rooted at OCC, setting the    RECIP_DEF field to a definition of 1.0 / DEF that can be used in    the given basic block.  The field may be left NULL, of course,    if it is not possible or profitable to do the optimization.     DEF_BSI is an iterator pointing at the statement defining DEF.    If RECIP_DEF is set, a dominator already has a computation that can    be used.  */
end_comment

begin_function
specifier|static
name|void
name|insert_reciprocals
parameter_list|(
name|block_stmt_iterator
modifier|*
name|def_bsi
parameter_list|,
name|struct
name|occurrence
modifier|*
name|occ
parameter_list|,
name|tree
name|def
parameter_list|,
name|tree
name|recip_def
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|new_stmt
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|struct
name|occurrence
modifier|*
name|occ_child
decl_stmt|;
if|if
condition|(
operator|!
name|recip_def
operator|&&
operator|(
name|occ
operator|->
name|bb_has_division
operator|||
operator|!
name|flag_trapping_math
operator|)
operator|&&
name|occ
operator|->
name|num_divisions
operator|>=
name|threshold
condition|)
block|{
comment|/* Make a variable with the replacement and substitute it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|recip_def
operator|=
name|make_rename_temp
argument_list|(
name|type
argument_list|,
literal|"reciptmp"
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|recip_def
argument_list|,
name|fold_build2
argument_list|(
name|RDIV_EXPR
argument_list|,
name|type
argument_list|,
name|build_one_cst
argument_list|(
name|type
argument_list|)
argument_list|,
name|def
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|bb_has_division
condition|)
block|{
comment|/* Case 1: insert before an existing division.  */
name|bsi
operator|=
name|bsi_after_labels
argument_list|(
name|occ
operator|->
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
operator|&&
operator|!
name|is_division_by
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|def
argument_list|)
condition|)
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|new_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|def_bsi
operator|&&
name|occ
operator|->
name|bb
operator|==
name|def_bsi
operator|->
name|bb
condition|)
block|{
comment|/* Case 2: insert right after the definition.  Note that this will 	     never happen if the definition statement can throw, because in 	     that case the sole successor of the statement's basic block will 	     dominate all the uses as well.  */
name|bsi_insert_after
argument_list|(
name|def_bsi
argument_list|,
name|new_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Case 3: insert in a basic block not containing defs/uses.  */
name|bsi
operator|=
name|bsi_after_labels
argument_list|(
name|occ
operator|->
name|bb
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|new_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|occ
operator|->
name|recip_def_stmt
operator|=
name|new_stmt
expr_stmt|;
block|}
name|occ
operator|->
name|recip_def
operator|=
name|recip_def
expr_stmt|;
for|for
control|(
name|occ_child
operator|=
name|occ
operator|->
name|children
init|;
name|occ_child
condition|;
name|occ_child
operator|=
name|occ_child
operator|->
name|next
control|)
name|insert_reciprocals
argument_list|(
name|def_bsi
argument_list|,
name|occ_child
argument_list|,
name|def
argument_list|,
name|recip_def
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace the division at USE_P with a multiplication by the reciprocal, if    possible.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|replace_reciprocal
parameter_list|(
name|use_operand_p
name|use_p
parameter_list|)
block|{
name|tree
name|use_stmt
init|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
decl_stmt|;
name|struct
name|occurrence
modifier|*
name|occ
init|=
operator|(
expr|struct
name|occurrence
operator|*
operator|)
name|bb
operator|->
name|aux
decl_stmt|;
if|if
condition|(
name|occ
operator|->
name|recip_def
operator|&&
name|use_stmt
operator|!=
name|occ
operator|->
name|recip_def_stmt
condition|)
block|{
name|TREE_SET_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|MULT_EXPR
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|occ
operator|->
name|recip_def
argument_list|)
expr_stmt|;
name|fold_stmt_inplace
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free OCC and return one more "struct occurrence" to be freed.  */
end_comment

begin_function
specifier|static
name|struct
name|occurrence
modifier|*
name|free_bb
parameter_list|(
name|struct
name|occurrence
modifier|*
name|occ
parameter_list|)
block|{
name|struct
name|occurrence
modifier|*
name|child
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* First get the two pointers hanging off OCC.  */
name|next
operator|=
name|occ
operator|->
name|next
expr_stmt|;
name|child
operator|=
name|occ
operator|->
name|children
expr_stmt|;
name|occ
operator|->
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|pool_free
argument_list|(
name|occ_pool
argument_list|,
name|occ
argument_list|)
expr_stmt|;
comment|/* Now ensure that we don't recurse unless it is necessary.  */
if|if
condition|(
operator|!
name|child
condition|)
return|return
name|next
return|;
else|else
block|{
while|while
condition|(
name|next
condition|)
name|next
operator|=
name|free_bb
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|child
return|;
block|}
block|}
end_function

begin_comment
comment|/* Look for floating-point divisions among DEF's uses, and try to    replace them by multiplications with the reciprocal.  Add    as many statements computing the reciprocal as needed.     DEF must be a GIMPLE register of a floating-point type.  */
end_comment

begin_function
specifier|static
name|void
name|execute_cse_reciprocals_1
parameter_list|(
name|block_stmt_iterator
modifier|*
name|def_bsi
parameter_list|,
name|tree
name|def
parameter_list|)
block|{
name|use_operand_p
name|use_p
decl_stmt|;
name|imm_use_iterator
name|use_iter
decl_stmt|;
name|struct
name|occurrence
modifier|*
name|occ
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|threshold
decl_stmt|;
name|gcc_assert
argument_list|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
operator|&&
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|use_iter
argument_list|,
argument|def
argument_list|)
block|{
name|tree
name|use_stmt
init|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_division_by
argument_list|(
name|use_stmt
argument_list|,
name|def
argument_list|)
condition|)
block|{
name|register_division_in
argument_list|(
name|bb_for_stmt
argument_list|(
name|use_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Do the expensive part only if we can hope to optimize something.  */
name|threshold
operator|=
name|targetm
operator|.
name|min_divisions_for_recip_mul
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|threshold
condition|)
block|{
name|tree
name|use_stmt
decl_stmt|;
for|for
control|(
name|occ
operator|=
name|occ_head
init|;
name|occ
condition|;
name|occ
operator|=
name|occ
operator|->
name|next
control|)
block|{
name|compute_merit
argument_list|(
name|occ
argument_list|)
expr_stmt|;
name|insert_reciprocals
argument_list|(
name|def_bsi
argument_list|,
name|occ
argument_list|,
name|def
argument_list|,
name|NULL
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_IMM_USE_STMT
argument_list|(
argument|use_stmt
argument_list|,
argument|use_iter
argument_list|,
argument|def
argument_list|)
block|{
if|if
condition|(
name|is_division_by
argument_list|(
name|use_stmt
argument_list|,
name|def
argument_list|)
condition|)
block|{
name|FOR_EACH_IMM_USE_ON_STMT
argument_list|(
argument|use_p
argument_list|,
argument|use_iter
argument_list|)
name|replace_reciprocal
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|occ
operator|=
name|occ_head
init|;
name|occ
condition|;
control|)
name|occ
operator|=
name|free_bb
argument_list|(
name|occ
argument_list|)
expr_stmt|;
name|occ_head
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_cse_reciprocals
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|optimize
operator|&&
operator|!
name|optimize_size
operator|&&
name|flag_unsafe_math_optimizations
return|;
block|}
end_function

begin_comment
comment|/* Go through all the floating-point SSA_NAMEs, and call    execute_cse_reciprocals_1 on each of them.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_cse_reciprocals
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|occ_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"dominators for recip"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|occurrence
argument_list|)
argument_list|,
name|n_basic_blocks
operator|/
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|gcc_assert
argument_list|(
operator|!
name|bb
operator|->
name|aux
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|default_def
argument_list|(
name|arg
argument_list|)
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|is_gimple_reg
argument_list|(
name|arg
argument_list|)
condition|)
name|execute_cse_reciprocals_1
argument_list|(
name|NULL
argument_list|,
name|default_def
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|def
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|def
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
operator|&&
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
condition|)
name|execute_cse_reciprocals_1
argument_list|(
name|NULL
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_after_labels
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|(
name|def
operator|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_DEF
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|execute_cse_reciprocals_1
argument_list|(
operator|&
name|bsi
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|occ_pool
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_cse_reciprocals
init|=
block|{
literal|"recip"
block|,
comment|/* name */
name|gate_cse_reciprocals
block|,
comment|/* gate */
name|execute_cse_reciprocals
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_ssa
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_verify_ssa
operator||
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

