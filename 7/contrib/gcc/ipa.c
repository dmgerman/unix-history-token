begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic IPA optimizations and utilities.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_comment
comment|/* Fill array order with all nodes with output flag set in the reverse    topological order.  */
end_comment

begin_function
name|int
name|cgraph_postorder
parameter_list|(
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
name|int
name|stack_size
init|=
literal|0
decl_stmt|;
name|int
name|order_pos
init|=
literal|0
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|,
name|last
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|stack
init|=
name|XCNEWVEC
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|,
name|cgraph_n_nodes
argument_list|)
decl_stmt|;
comment|/* We have to deal with cycles nicely, so use a depth first traversal      output algorithm.  Ignore the fact that some functions won't need      to be output and put them into order as well, so we get dependencies      right through intline functions.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|node
operator|->
name|aux
condition|)
block|{
name|node2
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|callers
condition|)
name|node
operator|->
name|aux
operator|=
operator|&
name|last
expr_stmt|;
else|else
name|node
operator|->
name|aux
operator|=
name|node
operator|->
name|callers
expr_stmt|;
while|while
condition|(
name|node2
condition|)
block|{
while|while
condition|(
name|node2
operator|->
name|aux
operator|!=
operator|&
name|last
condition|)
block|{
name|edge
operator|=
name|node2
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|next_caller
condition|)
name|node2
operator|->
name|aux
operator|=
name|edge
operator|->
name|next_caller
expr_stmt|;
else|else
name|node2
operator|->
name|aux
operator|=
operator|&
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|caller
operator|->
name|aux
condition|)
block|{
if|if
condition|(
operator|!
name|edge
operator|->
name|caller
operator|->
name|callers
condition|)
name|edge
operator|->
name|caller
operator|->
name|aux
operator|=
operator|&
name|last
expr_stmt|;
else|else
name|edge
operator|->
name|caller
operator|->
name|aux
operator|=
name|edge
operator|->
name|caller
operator|->
name|callers
expr_stmt|;
name|stack
index|[
name|stack_size
operator|++
index|]
operator|=
name|node2
expr_stmt|;
name|node2
operator|=
name|edge
operator|->
name|caller
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|node2
operator|->
name|aux
operator|==
operator|&
name|last
condition|)
block|{
name|order
index|[
name|order_pos
operator|++
index|]
operator|=
name|node2
expr_stmt|;
if|if
condition|(
name|stack_size
condition|)
name|node2
operator|=
name|stack
index|[
operator|--
name|stack_size
index|]
expr_stmt|;
else|else
name|node2
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|order_pos
return|;
block|}
end_function

begin_comment
comment|/* Perform reachability analysis and reclaim all unreachable nodes.    If BEFORE_INLINING_P is true this function is called before inlining    decisions has been made.  If BEFORE_INLINING_P is false this function also     removes unneeded bodies of extern inline functions.  */
end_comment

begin_function
name|bool
name|cgraph_remove_unreachable_nodes
parameter_list|(
name|bool
name|before_inlining_p
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|first
init|=
operator|(
name|void
operator|*
operator|)
literal|1
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|int
name|insns
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_cgraph
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nReclaiming functions:"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|aux
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|needed
operator|&&
operator|!
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|&&
operator|(
operator|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|)
operator|||
operator|!
name|node
operator|->
name|analyzed
operator|||
name|before_inlining_p
operator|)
condition|)
block|{
name|node
operator|->
name|aux
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|node
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
operator|!
name|node
operator|->
name|aux
argument_list|)
expr_stmt|;
comment|/* Perform reachability analysis.  As a special case do not consider      extern inline functions not inlined as live because we won't output      them at all.  */
while|while
condition|(
name|first
operator|!=
operator|(
name|void
operator|*
operator|)
literal|1
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|node
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|aux
expr_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|callee
operator|->
name|aux
operator|&&
name|node
operator|->
name|analyzed
operator|&&
operator|(
operator|!
name|e
operator|->
name|inline_failed
operator|||
operator|!
name|e
operator|->
name|callee
operator|->
name|analyzed
operator|||
operator|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|e
operator|->
name|callee
operator|->
name|decl
argument_list|)
operator|)
operator|||
name|before_inlining_p
operator|)
condition|)
block|{
name|e
operator|->
name|callee
operator|->
name|aux
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|e
operator|->
name|callee
expr_stmt|;
block|}
block|}
comment|/* Remove unreachable nodes.  Extern inline functions need special care;      Unreachable extern inline functions shall be removed.      Reachable extern inline functions we never inlined shall get their bodies      eliminated.      Reachable extern inline functions we sometimes inlined will be turned into      unanalyzed nodes so they look like for true extern functions to the rest      of code.  Body of such functions is released via remove_node once the      inline clones are eliminated.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|aux
condition|)
block|{
name|int
name|local_insns
decl_stmt|;
name|tree
name|decl
init|=
name|node
operator|->
name|decl
decl_stmt|;
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
condition|)
name|local_insns
operator|=
name|node
operator|->
name|local
operator|.
name|self_insns
expr_stmt|;
else|else
name|local_insns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|analyzed
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|||
name|before_inlining_p
condition|)
name|cgraph_remove_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
if|if
condition|(
name|e
operator|->
name|caller
operator|->
name|aux
condition|)
break|break;
if|if
condition|(
name|e
operator|||
name|node
operator|->
name|needed
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|clone
decl_stmt|;
for|for
control|(
name|clone
operator|=
name|node
operator|->
name|next_clone
init|;
name|clone
condition|;
name|clone
operator|=
name|clone
operator|->
name|next_clone
control|)
if|if
condition|(
name|clone
operator|->
name|aux
condition|)
break|break;
if|if
condition|(
operator|!
name|clone
condition|)
block|{
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|node
operator|->
name|analyzed
operator|=
name|false
expr_stmt|;
block|}
name|cgraph_node_remove_callees
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|analyzed
operator|=
name|false
expr_stmt|;
block|}
else|else
name|cgraph_remove_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
name|insns
operator|+=
name|local_insns
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nReclaimed %i insns"
argument_list|,
name|insns
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

end_unit

