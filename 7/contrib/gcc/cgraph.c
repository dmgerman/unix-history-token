begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Callgraph handling code.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Jan Hubicka  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*  This file contains basic routines manipulating call graph and variable pool  The callgraph:      The call-graph is data structure designed for intra-procedural optimization     but it is also used in non-unit-at-a-time compilation to allow easier code     sharing.      The call-graph consist of nodes and edges represented via linked lists.     Each function (external or not) corresponds to the unique node (in     contrast to tree DECL nodes where we can have multiple nodes for each     function).      The mapping from declarations to call-graph nodes is done using hash table     based on DECL_ASSEMBLER_NAME, so it is essential for assembler name to     not change once the declaration is inserted into the call-graph.     The call-graph nodes are created lazily using cgraph_node function when     called for unknown declaration.      When built, there is one edge for each direct call.  It is possible that     the reference will be later optimized out.  The call-graph is built     conservatively in order to make conservative data flow analysis possible.      The callgraph at the moment does not represent indirect calls or calls     from other compilation unit.  Flag NEEDED is set for each node that may     be accessed in such an invisible way and it shall be considered an     entry point to the callgraph.      Interprocedural information:        Callgraph is place to store data needed for interprocedural optimization.       All data structures are divided into three components: local_info that       is produced while analyzing the function, global_info that is result       of global walking of the callgraph on the end of compilation and       rtl_info used by RTL backend to propagate data from already compiled       functions to their callers.      Inlining plans:        The function inlining information is decided in advance and maintained       in the callgraph as so called inline plan.       For each inlined call, the callee's node is cloned to represent the       new function copy produced by inliner.       Each inlined call gets a unique corresponding clone node of the callee       and the data structure is updated while inlining is performed, so       the clones are eliminated and their callee edges redirected to the       caller.        Each edge has "inline_failed" field.  When the field is set to NULL,       the call will be inlined.  When it is non-NULL it contains a reason       why inlining wasn't performed.   The varpool data structure:      Varpool is used to maintain variables in similar manner as call-graph     is used for functions.  Most of the API is symmetric replacing cgraph     function prefix by cgraph_varpool  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_function_decl
specifier|static
name|void
name|cgraph_node_remove_callers
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cgraph_edge_remove_caller
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cgraph_edge_remove_callee
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hash table used to convert declarations into nodes.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct cgraph_node))
argument_list|)
name|htab_t
name|cgraph_hash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The linked list of cgraph nodes.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_node
modifier|*
name|cgraph_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of cgraph nodes scheduled to be lowered.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_node
modifier|*
name|cgraph_nodes_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of cgraph nodes scheduled to be expanded.  This is a    secondary queue used during optimization to accommodate passes that    may generate new functions that need to be optimized and expanded.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_node
modifier|*
name|cgraph_expand_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of nodes in existence.  */
end_comment

begin_decl_stmt
name|int
name|cgraph_n_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximal uid used in cgraph nodes.  */
end_comment

begin_decl_stmt
name|int
name|cgraph_max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when whole unit has been analyzed so we can access global info.  */
end_comment

begin_decl_stmt
name|bool
name|cgraph_global_info_ready
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when the cgraph is fully build and the basic flags are computed.  */
end_comment

begin_decl_stmt
name|bool
name|cgraph_function_flags_ready
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table used to convert declarations into nodes.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct cgraph_varpool_node))
argument_list|)
name|htab_t
name|cgraph_varpool_hash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Queue of cgraph nodes scheduled to be lowered and output.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_nodes_queue
decl_stmt|,
modifier|*
name|cgraph_varpool_first_unanalyzed_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The linked list of cgraph varpool nodes.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of the varpool queue.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_last_needed_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of cgraph asm nodes.  */
end_comment

begin_decl_stmt
name|struct
name|cgraph_asm_node
modifier|*
name|cgraph_asm_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last node in cgraph_asm_nodes.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|cgraph_asm_node
operator|*
name|cgraph_asm_last_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The order index of the next cgraph node to be created.  This is    used so that we can sort the cgraph nodes in order by when we saw    them, to support -fno-toplevel-reorder.  */
end_comment

begin_decl_stmt
name|int
name|cgraph_order
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|hashval_t
name|hash_node
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eq_node
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Returns a hash code for P.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|cgraph_node
modifier|*
name|n
init|=
operator|(
specifier|const
expr|struct
name|cgraph_node
operator|*
operator|)
name|p
decl_stmt|;
return|return
operator|(
name|hashval_t
operator|)
name|DECL_UID
argument_list|(
name|n
operator|->
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if P1 and P2 are equal.  */
end_comment

begin_function
specifier|static
name|int
name|eq_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|cgraph_node
modifier|*
name|n1
init|=
operator|(
specifier|const
expr|struct
name|cgraph_node
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|cgraph_node
modifier|*
name|n2
init|=
operator|(
specifier|const
expr|struct
name|cgraph_node
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|DECL_UID
argument_list|(
name|n1
operator|->
name|decl
argument_list|)
operator|==
name|DECL_UID
argument_list|(
name|n2
operator|->
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate new callgraph node and insert it into basic data structures.  */
end_comment

begin_function
specifier|static
name|struct
name|cgraph_node
modifier|*
name|cgraph_create_node
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|cgraph_node
argument_list|)
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|cgraph_nodes
expr_stmt|;
name|node
operator|->
name|uid
operator|=
name|cgraph_max_uid
operator|++
expr_stmt|;
name|node
operator|->
name|order
operator|=
name|cgraph_order
operator|++
expr_stmt|;
if|if
condition|(
name|cgraph_nodes
condition|)
name|cgraph_nodes
operator|->
name|previous
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|global
operator|.
name|estimated_growth
operator|=
name|INT_MIN
expr_stmt|;
name|cgraph_nodes
operator|=
name|node
expr_stmt|;
name|cgraph_n_nodes
operator|++
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Return cgraph node assigned to DECL.  Create new one when needed.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|cgraph_node
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
name|key
decl_stmt|,
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_hash
condition|)
name|cgraph_hash
operator|=
name|htab_create_ggc
argument_list|(
literal|10
argument_list|,
name|hash_node
argument_list|,
name|eq_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|key
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|cgraph_node
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cgraph_hash
argument_list|,
operator|&
name|key
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
block|{
name|node
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|master_clone
condition|)
name|node
operator|->
name|master_clone
operator|=
name|node
expr_stmt|;
return|return
name|node
return|;
block|}
name|node
operator|=
name|cgraph_create_node
argument_list|()
expr_stmt|;
name|node
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|node
operator|->
name|origin
operator|=
name|cgraph_node
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|next_nested
operator|=
name|node
operator|->
name|origin
operator|->
name|nested
expr_stmt|;
name|node
operator|->
name|origin
operator|->
name|nested
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|master_clone
operator|=
name|node
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Insert already constructed node into hashtable.  */
end_comment

begin_function
name|void
name|cgraph_insert_node_to_hashtable
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|cgraph_node
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cgraph_hash
argument_list|,
name|node
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */
end_comment

begin_function
specifier|static
name|bool
name|decl_assembler_name_equal
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|asmname
parameter_list|)
block|{
name|tree
name|decl_asmname
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_asmname
operator|==
name|asmname
condition|)
return|return
name|true
return|;
comment|/* If the target assembler name was set by the user, things are trickier.      We have a leading '*' to begin with.  After that, it's arguable what      is the correct thing to do with -fleading-underscore.  Arguably, we've      historically been doing the wrong thing in assemble_alias by always      printing the leading underscore.  Since we're not changing that, make      sure user_label_prefix follows the '*' before matching.  */
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|decl_asmname
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
specifier|const
name|char
modifier|*
name|decl_str
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl_asmname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|ulp_len
init|=
name|strlen
argument_list|(
name|user_label_prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|ulp_len
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|decl_str
argument_list|,
name|user_label_prefix
argument_list|,
name|ulp_len
argument_list|)
operator|==
literal|0
condition|)
name|decl_str
operator|+=
name|ulp_len
expr_stmt|;
else|else
return|return
name|false
return|;
return|return
name|strcmp
argument_list|(
name|decl_str
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|asmname
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.    Return NULL if there's no such node.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|cgraph_node_for_asm
parameter_list|(
name|tree
name|asmname
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|decl_assembler_name_equal
argument_list|(
name|node
operator|->
name|decl
argument_list|,
name|asmname
argument_list|)
condition|)
return|return
name|node
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash value for X (which really is a die_struct).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|edge_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
return|return
name|htab_hash_pointer
argument_list|(
operator|(
operator|(
expr|struct
name|cgraph_edge
operator|*
operator|)
name|x
operator|)
operator|->
name|call_stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if decl_id of die_struct X is the same as UID of decl *Y.  */
end_comment

begin_function
specifier|static
name|int
name|edge_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|cgraph_edge
operator|*
operator|)
name|x
operator|)
operator|->
name|call_stmt
operator|==
name|y
return|;
block|}
end_function

begin_comment
comment|/* Return callgraph edge representing CALL_EXPR statement.  */
end_comment

begin_function
name|struct
name|cgraph_edge
modifier|*
name|cgraph_edge
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|,
name|tree
name|call_stmt
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|e2
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|call_site_hash
condition|)
return|return
name|htab_find_with_hash
argument_list|(
name|node
operator|->
name|call_site_hash
argument_list|,
name|call_stmt
argument_list|,
name|htab_hash_pointer
argument_list|(
name|call_stmt
argument_list|)
argument_list|)
return|;
comment|/* This loop may turn out to be performance problem.  In such case adding      hashtables into call nodes with very many edges is probably best      solution.  It is not good idea to add pointer into CALL_EXPR itself      because we want to make possible having multiple cgraph nodes representing      different clones of the same body before the body is actually cloned.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
if|if
condition|(
name|e
operator|->
name|call_stmt
operator|==
name|call_stmt
condition|)
break|break;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|100
condition|)
block|{
name|node
operator|->
name|call_site_hash
operator|=
name|htab_create_ggc
argument_list|(
literal|120
argument_list|,
name|edge_hash
argument_list|,
name|edge_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|e2
operator|=
name|node
operator|->
name|callees
init|;
name|e2
condition|;
name|e2
operator|=
name|e2
operator|->
name|next_callee
control|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|node
operator|->
name|call_site_hash
argument_list|,
name|e2
operator|->
name|call_stmt
argument_list|,
name|htab_hash_pointer
argument_list|(
name|e2
operator|->
name|call_stmt
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|e2
expr_stmt|;
block|}
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Change call_smtt of edge E to NEW_STMT.  */
end_comment

begin_function
name|void
name|cgraph_set_call_stmt
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|,
name|tree
name|new_stmt
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|caller
operator|->
name|call_site_hash
condition|)
block|{
name|htab_remove_elt_with_hash
argument_list|(
name|e
operator|->
name|caller
operator|->
name|call_site_hash
argument_list|,
name|e
operator|->
name|call_stmt
argument_list|,
name|htab_hash_pointer
argument_list|(
name|e
operator|->
name|call_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|call_stmt
operator|=
name|new_stmt
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|caller
operator|->
name|call_site_hash
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|e
operator|->
name|caller
operator|->
name|call_site_hash
argument_list|,
name|e
operator|->
name|call_stmt
argument_list|,
name|htab_hash_pointer
argument_list|(
name|e
operator|->
name|call_stmt
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create edge from CALLER to CALLEE in the cgraph.  */
end_comment

begin_function
name|struct
name|cgraph_edge
modifier|*
name|cgraph_create_edge
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|caller
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|callee
parameter_list|,
name|tree
name|call_stmt
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|int
name|nest
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
init|=
name|GGC_NEW
argument_list|(
expr|struct
name|cgraph_edge
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|caller
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
name|gcc_assert
argument_list|(
name|e
operator|->
name|call_stmt
operator|!=
name|call_stmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_assert
argument_list|(
name|get_call_expr_in
argument_list|(
name|call_stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|callee
operator|->
name|decl
argument_list|)
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function body not available"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|callee
operator|->
name|local
operator|.
name|redefined_extern_inline
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"redefined extern inline functions are not "
literal|"considered for inlining"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|callee
operator|->
name|local
operator|.
name|inlinable
condition|)
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not considered for inlining"
argument_list|)
expr_stmt|;
else|else
name|edge
operator|->
name|inline_failed
operator|=
name|N_
argument_list|(
literal|"function not inlinable"
argument_list|)
expr_stmt|;
name|edge
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|edge
operator|->
name|caller
operator|=
name|caller
expr_stmt|;
name|edge
operator|->
name|callee
operator|=
name|callee
expr_stmt|;
name|edge
operator|->
name|call_stmt
operator|=
name|call_stmt
expr_stmt|;
name|edge
operator|->
name|prev_caller
operator|=
name|NULL
expr_stmt|;
name|edge
operator|->
name|next_caller
operator|=
name|callee
operator|->
name|callers
expr_stmt|;
if|if
condition|(
name|callee
operator|->
name|callers
condition|)
name|callee
operator|->
name|callers
operator|->
name|prev_caller
operator|=
name|edge
expr_stmt|;
name|edge
operator|->
name|prev_callee
operator|=
name|NULL
expr_stmt|;
name|edge
operator|->
name|next_callee
operator|=
name|caller
operator|->
name|callees
expr_stmt|;
if|if
condition|(
name|caller
operator|->
name|callees
condition|)
name|caller
operator|->
name|callees
operator|->
name|prev_callee
operator|=
name|edge
expr_stmt|;
name|caller
operator|->
name|callees
operator|=
name|edge
expr_stmt|;
name|callee
operator|->
name|callers
operator|=
name|edge
expr_stmt|;
name|edge
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|edge
operator|->
name|loop_nest
operator|=
name|nest
expr_stmt|;
if|if
condition|(
name|caller
operator|->
name|call_site_hash
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|caller
operator|->
name|call_site_hash
argument_list|,
name|edge
operator|->
name|call_stmt
argument_list|,
name|htab_hash_pointer
argument_list|(
name|edge
operator|->
name|call_stmt
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|edge
expr_stmt|;
block|}
return|return
name|edge
return|;
block|}
end_function

begin_comment
comment|/* Remove the edge E from the list of the callers of the callee.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cgraph_edge_remove_callee
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|prev_caller
condition|)
name|e
operator|->
name|prev_caller
operator|->
name|next_caller
operator|=
name|e
operator|->
name|next_caller
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|next_caller
condition|)
name|e
operator|->
name|next_caller
operator|->
name|prev_caller
operator|=
name|e
operator|->
name|prev_caller
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|prev_caller
condition|)
name|e
operator|->
name|callee
operator|->
name|callers
operator|=
name|e
operator|->
name|next_caller
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the edge E from the list of the callees of the caller.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cgraph_edge_remove_caller
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|prev_callee
condition|)
name|e
operator|->
name|prev_callee
operator|->
name|next_callee
operator|=
name|e
operator|->
name|next_callee
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|next_callee
condition|)
name|e
operator|->
name|next_callee
operator|->
name|prev_callee
operator|=
name|e
operator|->
name|prev_callee
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|prev_callee
condition|)
name|e
operator|->
name|caller
operator|->
name|callees
operator|=
name|e
operator|->
name|next_callee
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|caller
operator|->
name|call_site_hash
condition|)
name|htab_remove_elt_with_hash
argument_list|(
name|e
operator|->
name|caller
operator|->
name|call_site_hash
argument_list|,
name|e
operator|->
name|call_stmt
argument_list|,
name|htab_hash_pointer
argument_list|(
name|e
operator|->
name|call_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the edge E in the cgraph.  */
end_comment

begin_function
name|void
name|cgraph_remove_edge
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|)
block|{
comment|/* Remove from callers list of the callee.  */
name|cgraph_edge_remove_callee
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Remove from callees list of the callers.  */
name|cgraph_edge_remove_caller
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redirect callee of E to N.  The function does not update underlying    call expression.  */
end_comment

begin_function
name|void
name|cgraph_redirect_edge_callee
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|)
block|{
comment|/* Remove from callers list of the current callee.  */
name|cgraph_edge_remove_callee
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Insert to callers list of the new callee.  */
name|e
operator|->
name|prev_caller
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|callers
condition|)
name|n
operator|->
name|callers
operator|->
name|prev_caller
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|next_caller
operator|=
name|n
operator|->
name|callers
expr_stmt|;
name|n
operator|->
name|callers
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|callee
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all callees from the node.  */
end_comment

begin_function
name|void
name|cgraph_node_remove_callees
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
comment|/* It is sufficient to remove the edges from the lists of callers of      the callees.  The callee list of the node can be zapped with one      assignment.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
name|cgraph_edge_remove_callee
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|node
operator|->
name|callees
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|call_site_hash
condition|)
block|{
name|htab_delete
argument_list|(
name|node
operator|->
name|call_site_hash
argument_list|)
expr_stmt|;
name|node
operator|->
name|call_site_hash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove all callers from the node.  */
end_comment

begin_function
specifier|static
name|void
name|cgraph_node_remove_callers
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
comment|/* It is sufficient to remove the edges from the lists of callees of      the callers.  The caller list of the node can be zapped with one      assignment.  */
for|for
control|(
name|e
operator|=
name|node
operator|->
name|callers
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_caller
control|)
name|cgraph_edge_remove_caller
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|node
operator|->
name|callers
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the node from cgraph.  */
end_comment

begin_function
name|void
name|cgraph_remove_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|bool
name|kill_body
init|=
name|false
decl_stmt|;
name|cgraph_node_remove_callers
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|cgraph_node_remove_callees
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Incremental inlining access removed nodes stored in the postorder list.      */
name|node
operator|->
name|needed
operator|=
name|node
operator|->
name|reachable
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|nested
condition|)
name|cgraph_remove_node
argument_list|(
name|node
operator|->
name|nested
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|origin
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
modifier|*
name|node2
init|=
operator|&
name|node
operator|->
name|origin
operator|->
name|nested
decl_stmt|;
while|while
condition|(
operator|*
name|node2
operator|!=
name|node
condition|)
name|node2
operator|=
operator|&
operator|(
operator|*
name|node2
operator|)
operator|->
name|next_nested
expr_stmt|;
operator|*
name|node2
operator|=
name|node
operator|->
name|next_nested
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|previous
condition|)
name|node
operator|->
name|previous
operator|->
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
else|else
name|cgraph_nodes
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next
condition|)
name|node
operator|->
name|next
operator|->
name|previous
operator|=
name|node
operator|->
name|previous
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|cgraph_hash
argument_list|,
name|node
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|next_clone
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|new_node
init|=
name|node
operator|->
name|next_clone
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|n
decl_stmt|;
comment|/* Make the next clone be the master clone */
for|for
control|(
name|n
operator|=
name|new_node
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next_clone
control|)
name|n
operator|->
name|master_clone
operator|=
name|new_node
expr_stmt|;
operator|*
name|slot
operator|=
name|new_node
expr_stmt|;
name|node
operator|->
name|next_clone
operator|->
name|prev_clone
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|htab_clear_slot
argument_list|(
name|cgraph_hash
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|kill_body
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|node
operator|->
name|prev_clone
operator|->
name|next_clone
operator|=
name|node
operator|->
name|next_clone
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next_clone
condition|)
name|node
operator|->
name|next_clone
operator|->
name|prev_clone
operator|=
name|node
operator|->
name|prev_clone
expr_stmt|;
block|}
comment|/* While all the clones are removed after being proceeded, the function      itself is kept in the cgraph even after it is compiled.  Check whether      we are done with this body and reclaim it proactively if this is the case.      */
if|if
condition|(
operator|!
name|kill_body
operator|&&
operator|*
name|slot
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
init|=
operator|(
expr|struct
name|cgraph_node
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|next_clone
operator|&&
operator|!
name|n
operator|->
name|global
operator|.
name|inlined_to
operator|&&
operator|(
name|cgraph_global_info_ready
operator|&&
operator|(
name|TREE_ASM_WRITTEN
argument_list|(
name|n
operator|->
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|n
operator|->
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|kill_body
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|kill_body
operator|&&
name|flag_unit_at_a_time
condition|)
block|{
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|node
operator|->
name|decl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|call_site_hash
condition|)
block|{
name|htab_delete
argument_list|(
name|node
operator|->
name|call_site_hash
argument_list|)
expr_stmt|;
name|node
operator|->
name|call_site_hash
operator|=
name|NULL
expr_stmt|;
block|}
name|cgraph_n_nodes
operator|--
expr_stmt|;
comment|/* Do not free the structure itself so the walk over chain can continue.  */
block|}
end_function

begin_comment
comment|/* Notify finalize_compilation_unit that given node is reachable.  */
end_comment

begin_function
name|void
name|cgraph_mark_reachable_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|reachable
operator|&&
name|node
operator|->
name|local
operator|.
name|finalized
condition|)
block|{
name|notice_global_symbol
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
name|node
operator|->
name|reachable
operator|=
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|cgraph_global_info_ready
argument_list|)
expr_stmt|;
name|node
operator|->
name|next_needed
operator|=
name|cgraph_nodes_queue
expr_stmt|;
name|cgraph_nodes_queue
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise indicate that a node is needed, i.e. reachable via some    external means.  */
end_comment

begin_function
name|void
name|cgraph_mark_needed_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|node
operator|->
name|needed
operator|=
literal|1
expr_stmt|;
name|cgraph_mark_reachable_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return local info for the compiled function.  */
end_comment

begin_function
name|struct
name|cgraph_local_info
modifier|*
name|cgraph_local_info
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|node
operator|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
operator|&
name|node
operator|->
name|local
return|;
block|}
end_function

begin_comment
comment|/* Return local info for the compiled function.  */
end_comment

begin_function
name|struct
name|cgraph_global_info
modifier|*
name|cgraph_global_info
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|cgraph_global_info_ready
argument_list|)
expr_stmt|;
name|node
operator|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
operator|&
name|node
operator|->
name|global
return|;
block|}
end_function

begin_comment
comment|/* Return local info for the compiled function.  */
end_comment

begin_function
name|struct
name|cgraph_rtl_info
modifier|*
name|cgraph_rtl_info
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|node
operator|=
name|cgraph_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|current_function_decl
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|node
operator|->
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Return name of the node used in debug output.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgraph_node_name
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
return|return
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|node
operator|->
name|decl
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return name of the node used in debug output.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cgraph_varpool_node_name
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|)
block|{
return|return
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|node
operator|->
name|decl
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Names used to print out the availability enum.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|availability_names
index|[]
init|=
block|{
literal|"unset"
block|,
literal|"not_available"
block|,
literal|"overwrittable"
block|,
literal|"available"
block|,
literal|"local"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump given cgraph node.  */
end_comment

begin_function
name|void
name|dump_cgraph_node
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s/%i:"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|inlined_to
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" (inline copy in %s/%i)"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|global
operator|.
name|inlined_to
argument_list|)
argument_list|,
name|node
operator|->
name|global
operator|.
name|inlined_to
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_function_flags_ready
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" availability:%s"
argument_list|,
name|availability_names
index|[
name|cgraph_function_body_availability
argument_list|(
name|node
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|master_clone
operator|&&
name|node
operator|->
name|master_clone
operator|->
name|uid
operator|!=
name|node
operator|->
name|uid
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(%i)"
argument_list|,
name|node
operator|->
name|master_clone
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|count
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" executed "
name|HOST_WIDEST_INT_PRINT_DEC
literal|"x"
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|node
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|self_insns
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %i insns"
argument_list|,
name|node
operator|->
name|local
operator|.
name|self_insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|global
operator|.
name|insns
operator|&&
name|node
operator|->
name|global
operator|.
name|insns
operator|!=
name|node
operator|->
name|local
operator|.
name|self_insns
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" (%i after inlining)"
argument_list|,
name|node
operator|->
name|global
operator|.
name|insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|origin
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" nested in: %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
operator|->
name|origin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|needed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" needed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|reachable
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" reachable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" tree"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|output
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|local
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" local"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|externally_visible
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" externally_visible"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|finalized
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" finalized"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|disregard_inline_limits
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" always_inline"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|inlinable
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" inlinable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|redefined_extern_inline
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" redefined_extern_inline"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" asm_written"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  called by: "
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callers
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_caller
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s/%i "
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|caller
argument_list|)
argument_list|,
name|edge
operator|->
name|caller
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|count
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"("
name|HOST_WIDEST_INT_PRINT_DEC
literal|"x) "
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|edge
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|inline_failed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(inlined) "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n  calls: "
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|node
operator|->
name|callees
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_callee
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s/%i "
argument_list|,
name|cgraph_node_name
argument_list|(
name|edge
operator|->
name|callee
argument_list|)
argument_list|,
name|edge
operator|->
name|callee
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edge
operator|->
name|inline_failed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(inlined) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|count
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"("
name|HOST_WIDEST_INT_PRINT_DEC
literal|"x) "
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|edge
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|loop_nest
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(nested in %i loops) "
argument_list|,
name|edge
operator|->
name|loop_nest
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the callgraph.  */
end_comment

begin_function
name|void
name|dump_cgraph
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"callgraph:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|dump_cgraph_node
argument_list|(
name|f
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump given cgraph node.  */
end_comment

begin_function
name|void
name|dump_cgraph_varpool_node
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s:"
argument_list|,
name|cgraph_varpool_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" availability:%s"
argument_list|,
name|cgraph_function_flags_ready
condition|?
name|availability_names
index|[
name|cgraph_variable_initializer_availability
argument_list|(
name|node
argument_list|)
index|]
else|:
literal|"not-ready"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" initialized"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|needed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" needed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|analyzed
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" analyzed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|finalized
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" finalized"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|output
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|externally_visible
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" externally_visible"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the callgraph.  */
end_comment

begin_function
name|void
name|dump_varpool
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"variable pool:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_varpool_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next_needed
control|)
name|dump_cgraph_varpool_node
argument_list|(
name|f
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for P.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_varpool_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|cgraph_varpool_node
modifier|*
name|n
init|=
operator|(
specifier|const
expr|struct
name|cgraph_varpool_node
operator|*
operator|)
name|p
decl_stmt|;
return|return
operator|(
name|hashval_t
operator|)
name|DECL_UID
argument_list|(
name|n
operator|->
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if P1 and P2 are equal.  */
end_comment

begin_function
specifier|static
name|int
name|eq_varpool_node
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|cgraph_varpool_node
modifier|*
name|n1
init|=
operator|(
specifier|const
expr|struct
name|cgraph_varpool_node
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|cgraph_varpool_node
modifier|*
name|n2
init|=
operator|(
specifier|const
expr|struct
name|cgraph_varpool_node
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|DECL_UID
argument_list|(
name|n1
operator|->
name|decl
argument_list|)
operator|==
name|DECL_UID
argument_list|(
name|n2
operator|->
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return cgraph_varpool node assigned to DECL.  Create new one when needed.  */
end_comment

begin_function
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_node
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
name|key
decl_stmt|,
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_varpool_hash
condition|)
name|cgraph_varpool_hash
operator|=
name|htab_create_ggc
argument_list|(
literal|10
argument_list|,
name|hash_varpool_node
argument_list|,
name|eq_varpool_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|key
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|cgraph_varpool_node
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|cgraph_varpool_hash
argument_list|,
operator|&
name|key
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
operator|*
name|slot
return|;
name|node
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|cgraph_varpool_node
argument_list|)
expr_stmt|;
name|node
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|node
operator|->
name|order
operator|=
name|cgraph_order
operator|++
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|cgraph_varpool_nodes
expr_stmt|;
name|cgraph_varpool_nodes
operator|=
name|node
expr_stmt|;
operator|*
name|slot
operator|=
name|node
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
name|struct
name|cgraph_varpool_node
modifier|*
name|cgraph_varpool_node_for_asm
parameter_list|(
name|tree
name|asmname
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_varpool_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|decl_assembler_name_equal
argument_list|(
name|node
operator|->
name|decl
argument_list|,
name|asmname
argument_list|)
condition|)
return|return
name|node
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the DECL_ASSEMBLER_NAME and update cgraph hashtables.  */
end_comment

begin_function
name|void
name|change_decl_assembler_name
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|name
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%D renamed after being referenced in assembly"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for finalization code - add node into lists so it will    be analyzed and compiled.  */
end_comment

begin_function
name|void
name|cgraph_varpool_enqueue_needed_node
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|cgraph_varpool_last_needed_node
condition|)
name|cgraph_varpool_last_needed_node
operator|->
name|next_needed
operator|=
name|node
expr_stmt|;
name|cgraph_varpool_last_needed_node
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|next_needed
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_varpool_nodes_queue
condition|)
name|cgraph_varpool_nodes_queue
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|cgraph_varpool_first_unanalyzed_node
condition|)
name|cgraph_varpool_first_unanalyzed_node
operator|=
name|node
expr_stmt|;
name|notice_global_symbol
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the queue of needed nodes.  */
end_comment

begin_function
name|void
name|cgraph_varpool_reset_queue
parameter_list|(
name|void
parameter_list|)
block|{
name|cgraph_varpool_last_needed_node
operator|=
name|NULL
expr_stmt|;
name|cgraph_varpool_nodes_queue
operator|=
name|NULL
expr_stmt|;
name|cgraph_varpool_first_unanalyzed_node
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Notify finalize_compilation_unit that given node is reachable    or needed.  */
end_comment

begin_function
name|void
name|cgraph_varpool_mark_needed_node
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|needed
operator|&&
name|node
operator|->
name|finalized
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|cgraph_varpool_enqueue_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|needed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if variable DECL is needed.  That is, visible to something    either outside this translation unit, something magic in the system    configury, or (if not doing unit-at-a-time) to something we haven't    seen yet.  */
end_comment

begin_function
name|bool
name|decide_is_variable_needed
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
comment|/* If the user told us it is used, then it must be so.  */
if|if
condition|(
name|node
operator|->
name|externally_visible
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
operator|&&
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* ??? If the assembler name is set by hand, it is possible to assemble      the name later after finalizing the function and the fact is noticed      in assemble_name then.  This is arguably a bug.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If we decided it was needed before, but at the time we didn't have      the definition available, then it's still needed.  */
if|if
condition|(
name|node
operator|->
name|needed
condition|)
return|return
name|true
return|;
comment|/* Externally visible variables must be output.  The exception is      COMDAT variables that must be output only when they are needed.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_whole_program
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* When not reordering top level variables, we have to assume that      we are going to keep everything.  */
if|if
condition|(
name|flag_unit_at_a_time
operator|&&
name|flag_toplevel_reorder
condition|)
return|return
name|false
return|;
comment|/* We want to emit COMDAT variables only when absolutely necessary.  */
if|if
condition|(
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|cgraph_varpool_finalize_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
init|=
name|cgraph_varpool_node
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|node
operator|->
name|finalized
condition|)
block|{
if|if
condition|(
name|cgraph_global_info_ready
operator|||
operator|(
operator|!
name|flag_unit_at_a_time
operator|&&
operator|!
name|flag_openmp
operator|)
condition|)
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|node
operator|->
name|needed
condition|)
name|cgraph_varpool_enqueue_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|finalized
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|decide_is_variable_needed
argument_list|(
name|node
argument_list|,
name|decl
argument_list|)
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Since we reclaim unreachable nodes at the end of every language      level unit, we need to be conservative about possible entry points      there.  */
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|cgraph_varpool_mark_needed_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgraph_global_info_ready
operator|||
operator|(
operator|!
name|flag_unit_at_a_time
operator|&&
operator|!
name|flag_openmp
operator|)
condition|)
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a top-level asm statement to the list.  */
end_comment

begin_function
name|struct
name|cgraph_asm_node
modifier|*
name|cgraph_add_asm_node
parameter_list|(
name|tree
name|asm_str
parameter_list|)
block|{
name|struct
name|cgraph_asm_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|cgraph_asm_node
argument_list|)
expr_stmt|;
name|node
operator|->
name|asm_str
operator|=
name|asm_str
expr_stmt|;
name|node
operator|->
name|order
operator|=
name|cgraph_order
operator|++
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cgraph_asm_nodes
operator|==
name|NULL
condition|)
name|cgraph_asm_nodes
operator|=
name|node
expr_stmt|;
else|else
name|cgraph_asm_last_node
operator|->
name|next
operator|=
name|node
expr_stmt|;
name|cgraph_asm_last_node
operator|=
name|node
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Return true when the DECL can possibly be inlined.  */
end_comment

begin_function
name|bool
name|cgraph_function_possibly_inlined_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cgraph_global_info_ready
condition|)
return|return
operator|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_really_no_inline
operator|)
return|;
return|return
name|DECL_POSSIBLY_INLINED
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */
end_comment

begin_function
name|struct
name|cgraph_edge
modifier|*
name|cgraph_clone_edge
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|e
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|,
name|tree
name|call_stmt
parameter_list|,
name|gcov_type
name|count_scale
parameter_list|,
name|int
name|loop_nest
parameter_list|,
name|bool
name|update_original
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|cgraph_create_edge
argument_list|(
name|n
argument_list|,
name|e
operator|->
name|callee
argument_list|,
name|call_stmt
argument_list|,
name|e
operator|->
name|count
operator|*
name|count_scale
operator|/
name|REG_BR_PROB_BASE
argument_list|,
name|e
operator|->
name|loop_nest
operator|+
name|loop_nest
argument_list|)
expr_stmt|;
name|new
operator|->
name|inline_failed
operator|=
name|e
operator|->
name|inline_failed
expr_stmt|;
if|if
condition|(
name|update_original
condition|)
block|{
name|e
operator|->
name|count
operator|-=
name|new
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
condition|)
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Create node representing clone of N executed COUNT times.  Decrease    the execution counts from original node too.     When UPDATE_ORIGINAL is true, the counts are subtracted from the original    function's profile to reflect the fact that part of execution is handled    by node.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|cgraph_clone_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|int
name|loop_nest
parameter_list|,
name|bool
name|update_original
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|new
init|=
name|cgraph_create_node
argument_list|()
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|gcov_type
name|count_scale
decl_stmt|;
name|new
operator|->
name|decl
operator|=
name|n
operator|->
name|decl
expr_stmt|;
name|new
operator|->
name|origin
operator|=
name|n
operator|->
name|origin
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|origin
condition|)
block|{
name|new
operator|->
name|next_nested
operator|=
name|new
operator|->
name|origin
operator|->
name|nested
expr_stmt|;
name|new
operator|->
name|origin
operator|->
name|nested
operator|=
name|new
expr_stmt|;
block|}
name|new
operator|->
name|analyzed
operator|=
name|n
operator|->
name|analyzed
expr_stmt|;
name|new
operator|->
name|local
operator|=
name|n
operator|->
name|local
expr_stmt|;
name|new
operator|->
name|global
operator|=
name|n
operator|->
name|global
expr_stmt|;
name|new
operator|->
name|rtl
operator|=
name|n
operator|->
name|rtl
expr_stmt|;
name|new
operator|->
name|master_clone
operator|=
name|n
operator|->
name|master_clone
expr_stmt|;
name|new
operator|->
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|count
condition|)
name|count_scale
operator|=
name|new
operator|->
name|count
operator|*
name|REG_BR_PROB_BASE
operator|/
name|n
operator|->
name|count
expr_stmt|;
else|else
name|count_scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|update_original
condition|)
block|{
name|n
operator|->
name|count
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|count
operator|<
literal|0
condition|)
name|n
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|n
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
name|cgraph_clone_edge
argument_list|(
name|e
argument_list|,
name|new
argument_list|,
name|e
operator|->
name|call_stmt
argument_list|,
name|count_scale
argument_list|,
name|loop_nest
argument_list|,
name|update_original
argument_list|)
expr_stmt|;
name|new
operator|->
name|next_clone
operator|=
name|n
operator|->
name|next_clone
expr_stmt|;
name|new
operator|->
name|prev_clone
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|next_clone
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|next_clone
condition|)
name|new
operator|->
name|next_clone
operator|->
name|prev_clone
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Return true if N is an master_clone, (see cgraph_master_clone).  */
end_comment

begin_function
name|bool
name|cgraph_is_master_clone
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|n
operator|==
name|cgraph_master_clone
argument_list|(
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cgraph_node
modifier|*
name|cgraph_master_clone
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|n
parameter_list|)
block|{
name|enum
name|availability
name|avail
init|=
name|cgraph_function_body_availability
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|avail
operator|==
name|AVAIL_NOT_AVAILABLE
operator|||
name|avail
operator|==
name|AVAIL_OVERWRITABLE
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|n
operator|->
name|master_clone
condition|)
name|n
operator|->
name|master_clone
operator|=
name|cgraph_node
argument_list|(
name|n
operator|->
name|decl
argument_list|)
expr_stmt|;
return|return
name|n
operator|->
name|master_clone
return|;
block|}
end_function

begin_comment
comment|/* NODE is no longer nested function; update cgraph accordingly.  */
end_comment

begin_function
name|void
name|cgraph_unnest_node
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
modifier|*
name|node2
init|=
operator|&
name|node
operator|->
name|origin
operator|->
name|nested
decl_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|->
name|origin
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|node2
operator|!=
name|node
condition|)
name|node2
operator|=
operator|&
operator|(
operator|*
name|node2
operator|)
operator|->
name|next_nested
expr_stmt|;
operator|*
name|node2
operator|=
name|node
operator|->
name|next_nested
expr_stmt|;
name|node
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return function availability.  See cgraph.h for description of individual    return values.  */
end_comment

begin_function
name|enum
name|availability
name|cgraph_function_body_availability
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|enum
name|availability
name|avail
decl_stmt|;
name|gcc_assert
argument_list|(
name|cgraph_function_flags_ready
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|analyzed
condition|)
name|avail
operator|=
name|AVAIL_NOT_AVAILABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|local
condition|)
name|avail
operator|=
name|AVAIL_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|externally_visible
condition|)
name|avail
operator|=
name|AVAIL_AVAILABLE
expr_stmt|;
comment|/* If the function can be overwritten, return OVERWRITABLE.  Take      care at least of two notable extensions - the COMDAT functions      used to share template instantiations in C++ (this is symmetric      to code cp_cannot_inline_tree_fn and probably shall be shared and      the inlinability hooks completely eliminated).       ??? Does the C++ one definition rule allow us to always return      AVAIL_AVAILABLE here?  That would be good reason to preserve this      hook Similarly deal with extern inline functions - this is again      necessary to get C++ shared functions having keyed templates      right and in the C extension documentation we probably should      document the requirement of both versions of function (extern      inline and offline) having same side effect characteristics as      good optimization is what this optimization is about.  */
elseif|else
if|if
condition|(
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
name|avail
operator|=
name|AVAIL_OVERWRITABLE
expr_stmt|;
else|else
name|avail
operator|=
name|AVAIL_AVAILABLE
expr_stmt|;
return|return
name|avail
return|;
block|}
end_function

begin_comment
comment|/* Return variable availability.  See cgraph.h for description of individual    return values.  */
end_comment

begin_function
name|enum
name|availability
name|cgraph_variable_initializer_availability
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|node
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|cgraph_function_flags_ready
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|finalized
condition|)
return|return
name|AVAIL_NOT_AVAILABLE
return|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
return|return
name|AVAIL_AVAILABLE
return|;
comment|/* If the variable can be overwritten, return OVERWRITABLE.  Takes      care of at least two notable extensions - the COMDAT variables      used to share template instantiations in C++.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|node
operator|->
name|decl
argument_list|)
condition|)
return|return
name|AVAIL_OVERWRITABLE
return|;
return|return
name|AVAIL_AVAILABLE
return|;
block|}
end_function

begin_comment
comment|/* Add the function FNDECL to the call graph.  FNDECL is assumed to be    in low GIMPLE form and ready to be processed by cgraph_finalize_function.     When operating in unit-at-a-time, a new callgraph node is added to    CGRAPH_EXPAND_QUEUE, which is processed after all the original    functions in the call graph .     When not in unit-at-a-time, the new callgraph node is added to    CGRAPH_NODES_QUEUE for cgraph_assemble_pending_functions to    process.  */
end_comment

begin_function
name|void
name|cgraph_add_new_function
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|n
init|=
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|n
operator|->
name|next_needed
operator|=
name|cgraph_expand_queue
expr_stmt|;
name|cgraph_expand_queue
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cgraph.h"
end_include

end_unit

