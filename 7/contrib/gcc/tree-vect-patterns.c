begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analysis Utilities for Loop Vectorization.    Copyright (C) 2006 Free Software Foundation, Inc.    Contributed by Dorit Nuzman<dorit@il.ibm.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-vectorizer.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|vect_pattern_recog_1
parameter_list|(
name|tree
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
parameter_list|,
name|block_stmt_iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|widened_name_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pattern recognition functions  */
end_comment

begin_function_decl
specifier|static
name|tree
name|vect_recog_widen_sum_pattern
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_recog_widen_mult_pattern
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_recog_dot_prod_pattern
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vect_recog_func_ptr
name|vect_vect_recog_func_ptrs
index|[
name|NUM_PATTERNS
index|]
init|=
block|{
name|vect_recog_widen_mult_pattern
block|,
name|vect_recog_widen_sum_pattern
block|,
name|vect_recog_dot_prod_pattern
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function widened_name_p     Check whether NAME, an ssa-name used in USE_STMT,    is a result of a type-promotion, such that:      DEF_STMT: NAME = NOP (name0)    where the type of name0 (HALF_TYPE) is smaller than the type of NAME.  */
end_comment

begin_function
specifier|static
name|bool
name|widened_name_p
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|use_stmt
parameter_list|,
name|tree
modifier|*
name|half_type
parameter_list|,
name|tree
modifier|*
name|def_stmt
parameter_list|)
block|{
name|tree
name|dummy
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
decl_stmt|;
name|stmt_vec_info
name|stmt_vinfo
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oprnd0
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|stmt_vinfo
operator|=
name|vinfo_for_stmt
argument_list|(
name|use_stmt
argument_list|)
expr_stmt|;
name|loop_vinfo
operator|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|name
argument_list|,
name|loop_vinfo
argument_list|,
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dt
operator|!=
name|vect_loop_def
operator|&&
name|dt
operator|!=
name|vect_invariant_def
operator|&&
name|dt
operator|!=
name|vect_constant_def
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|*
name|def_stmt
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|def_stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|def_stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|NOP_EXPR
condition|)
return|return
name|false
return|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|half_type
operator|=
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
operator|*
name|half_type
argument_list|)
operator|||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
operator|*
name|half_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
operator|(
name|TYPE_PRECISION
argument_list|(
operator|*
name|half_type
argument_list|)
operator|*
literal|2
operator|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|oprnd0
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dt
operator|!=
name|vect_invariant_def
operator|&&
name|dt
operator|!=
name|vect_constant_def
operator|&&
name|dt
operator|!=
name|vect_loop_def
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_recog_dot_prod_pattern     Try to find the following pattern:       type x_t, y_t;      TYPE1 prod;      TYPE2 sum = init;    loop:      sum_0 = phi<init, sum_1>      S1  x_t = ...      S2  y_t = ...      S3  x_T = (TYPE1) x_t;      S4  y_T = (TYPE1) y_t;      S5  prod = x_T * y_T;      [S6  prod = (TYPE2) prod;  #optional]      S7  sum_1 = prod + sum_0;     where 'TYPE1' is exactly double the size of type 'type', and 'TYPE2' is the     same size of 'TYPE1' or bigger. This is a special case of a reduction     computation.           Input:     * LAST_STMT: A stmt from which the pattern search begins. In the example,    when this function is called with S7, the pattern {S3,S4,S5,S6,S7} will be    detected.     Output:     * TYPE_IN: The type of the input arguments to the pattern.     * TYPE_OUT: The type of the output  of this pattern.     * Return value: A new stmt that will be used to replace the sequence of    stmts that constitute the pattern. In this case it will be:         WIDEN_DOT_PRODUCT<x_t, y_t, sum_0> */
end_comment

begin_function
specifier|static
name|tree
name|vect_recog_dot_prod_pattern
parameter_list|(
name|tree
name|last_stmt
parameter_list|,
name|tree
modifier|*
name|type_in
parameter_list|,
name|tree
modifier|*
name|type_out
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|expr
decl_stmt|;
name|tree
name|oprnd0
decl_stmt|,
name|oprnd1
decl_stmt|;
name|tree
name|oprnd00
decl_stmt|,
name|oprnd01
decl_stmt|;
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|last_stmt
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|half_type
decl_stmt|;
name|tree
name|pattern_expr
decl_stmt|;
name|tree
name|prod_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last_stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|NULL
return|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|last_stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Look for the following pattern            DX = (TYPE1) X;           DY = (TYPE1) Y;           DPROD = DX * DY;            DDPROD = (TYPE2) DPROD;           sum_1 = DDPROD + sum_0;      In which       - DX is double the size of X      - DY is double the size of Y      - DX, DY, DPROD all have the same type      - sum is the same size of DPROD or bigger      - sum has been recognized as a reduction variable.       This is equivalent to:        DPROD = X w* Y;          #widen mult        sum_1 = DPROD w+ sum_0;  #widen summation      or        DPROD = X w* Y;          #widen mult        sum_1 = DPROD + sum_0;   #summation    */
comment|/* Starting from LAST_STMT, follow the defs of its uses in search      of the above pattern.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|PLUS_EXPR
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|stmt_vinfo
argument_list|)
condition|)
block|{
comment|/* Has been detected as widening-summation?  */
name|stmt
operator|=
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|WIDEN_SUM_EXPR
condition|)
return|return
name|NULL
return|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|half_type
operator|=
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|def_stmt
decl_stmt|;
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|!=
name|vect_reduction_def
condition|)
return|return
name|NULL
return|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL
return|;
name|stmt
operator|=
name|last_stmt
expr_stmt|;
if|if
condition|(
name|widened_name_p
argument_list|(
name|oprnd0
argument_list|,
name|stmt
argument_list|,
operator|&
name|half_type
argument_list|,
operator|&
name|def_stmt
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|def_stmt
expr_stmt|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|half_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* So far so good. Since last_stmt was detected as a (summation) reduction,      we know that oprnd1 is the reduction variable (defined by a loop-header      phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.      Left to check that oprnd0 is defined by a (widen_)mult_expr  */
name|prod_type
operator|=
name|half_type
expr_stmt|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|oprnd0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt_vinfo
operator|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|!=
name|vect_loop_def
condition|)
return|return
name|NULL
return|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|MULT_EXPR
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|stmt_vinfo
argument_list|)
condition|)
block|{
comment|/* Has been detected as a widening multiplication?  */
name|stmt
operator|=
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|WIDEN_MULT_EXPR
condition|)
return|return
name|NULL
return|;
name|stmt_vinfo
operator|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|==
name|vect_loop_def
argument_list|)
expr_stmt|;
name|oprnd00
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd01
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|half_type0
decl_stmt|,
name|half_type1
decl_stmt|;
name|tree
name|def_stmt
decl_stmt|;
name|tree
name|oprnd0
decl_stmt|,
name|oprnd1
decl_stmt|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|prod_type
argument_list|)
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|prod_type
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|widened_name_p
argument_list|(
name|oprnd0
argument_list|,
name|stmt
argument_list|,
operator|&
name|half_type0
argument_list|,
operator|&
name|def_stmt
argument_list|)
condition|)
return|return
name|NULL
return|;
name|oprnd00
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widened_name_p
argument_list|(
name|oprnd1
argument_list|,
name|stmt
argument_list|,
operator|&
name|half_type1
argument_list|,
operator|&
name|def_stmt
argument_list|)
condition|)
return|return
name|NULL
return|;
name|oprnd01
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|half_type0
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|half_type1
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|prod_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|half_type0
argument_list|)
operator|*
literal|2
condition|)
return|return
name|NULL
return|;
block|}
name|half_type
operator|=
name|TREE_TYPE
argument_list|(
name|oprnd00
argument_list|)
expr_stmt|;
operator|*
name|type_in
operator|=
name|half_type
expr_stmt|;
operator|*
name|type_out
operator|=
name|type
expr_stmt|;
comment|/* Pattern detected. Create a stmt to be used to replace the pattern: */
name|pattern_expr
operator|=
name|build3
argument_list|(
name|DOT_PROD_EXPR
argument_list|,
name|type
argument_list|,
name|oprnd00
argument_list|,
name|oprnd01
argument_list|,
name|oprnd1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vect_recog_dot_prod_pattern: detected: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|pattern_expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|pattern_expr
return|;
block|}
end_function

begin_comment
comment|/* Function vect_recog_widen_mult_pattern     Try to find the following pattern:       type a_t, b_t;      TYPE a_T, b_T, prod_T;       S1  a_t = ;      S2  b_t = ;      S3  a_T = (TYPE) a_t;      S4  b_T = (TYPE) b_t;      S5  prod_T = a_T * b_T;     where type 'TYPE' is at least double the size of type 'type'.     Input:     * LAST_STMT: A stmt from which the pattern search begins. In the example,    when this function is called with S5, the pattern {S3,S4,S5} is be detected.     Output:     * TYPE_IN: The type of the input arguments to the pattern.     * TYPE_OUT: The type of the output  of this pattern.     * Return value: A new stmt that will be used to replace the sequence of    stmts that constitute the pattern. In this case it will be:         WIDEN_MULT<a_t, b_t> */
end_comment

begin_function
specifier|static
name|tree
name|vect_recog_widen_mult_pattern
parameter_list|(
name|tree
name|last_stmt
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
modifier|*
name|type_in
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
modifier|*
name|type_out
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Yet to be implemented.   */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Function vect_recog_widen_sum_pattern     Try to find the following pattern:       type x_t;       TYPE x_T, sum = init;    loop:      sum_0 = phi<init, sum_1>      S1  x_t = *p;      S2  x_T = (TYPE) x_t;      S3  sum_1 = x_T + sum_0;     where type 'TYPE' is at least double the size of type 'type', i.e - we're     summing elements of type 'type' into an accumulator of type 'TYPE'. This is    a special case of a reduction computation.     Input:     * LAST_STMT: A stmt from which the pattern search begins. In the example,    when this function is called with S3, the pattern {S2,S3} will be detected.             Output:           * TYPE_IN: The type of the input arguments to the pattern.     * TYPE_OUT: The type of the output of this pattern.     * Return value: A new stmt that will be used to replace the sequence of    stmts that constitute the pattern. In this case it will be:         WIDEN_SUM<x_t, sum_0> */
end_comment

begin_function
specifier|static
name|tree
name|vect_recog_widen_sum_pattern
parameter_list|(
name|tree
name|last_stmt
parameter_list|,
name|tree
modifier|*
name|type_in
parameter_list|,
name|tree
modifier|*
name|type_out
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|expr
decl_stmt|;
name|tree
name|oprnd0
decl_stmt|,
name|oprnd1
decl_stmt|;
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|last_stmt
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|half_type
decl_stmt|;
name|tree
name|pattern_expr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last_stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|NULL
return|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|last_stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Look for the following pattern           DX = (TYPE) X;           sum_1 = DX + sum_0;      In which DX is at least double the size of X, and sum_1 has been      recognized as a reduction variable.    */
comment|/* Starting from LAST_STMT, follow the defs of its uses in search      of the above pattern.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|PLUS_EXPR
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|!=
name|vect_reduction_def
condition|)
return|return
name|NULL
return|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* So far so good. Since last_stmt was detected as a (summation) reduction,      we know that oprnd1 is the reduction variable (defined by a loop-header      phi), and oprnd0 is an ssa-name defined by a stmt in the loop body.      Left to check that oprnd0 is defined by a cast from type 'type' to type      'TYPE'.  */
if|if
condition|(
operator|!
name|widened_name_p
argument_list|(
name|oprnd0
argument_list|,
name|last_stmt
argument_list|,
operator|&
name|half_type
argument_list|,
operator|&
name|stmt
argument_list|)
condition|)
return|return
name|NULL
return|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|type_in
operator|=
name|half_type
expr_stmt|;
operator|*
name|type_out
operator|=
name|type
expr_stmt|;
comment|/* Pattern detected. Create a stmt to be used to replace the pattern: */
name|pattern_expr
operator|=
name|build2
argument_list|(
name|WIDEN_SUM_EXPR
argument_list|,
name|type
argument_list|,
name|oprnd0
argument_list|,
name|oprnd1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vect_recog_widen_sum_pattern: detected: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|pattern_expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|pattern_expr
return|;
block|}
end_function

begin_comment
comment|/* Function vect_pattern_recog_1      Input:    PATTERN_RECOG_FUNC: A pointer to a function that detects a certain         computation pattern.    STMT: A stmt from which the pattern search should start.     If PATTERN_RECOG_FUNC successfully detected the pattern, it creates an    expression that computes the same functionality and can be used to     replace the sequence of stmts that are involved in the pattern.      Output:    This function checks if the expression returned by PATTERN_RECOG_FUNC is     supported in vector form by the target.  We use 'TYPE_IN' to obtain the     relevant vector type. If 'TYPE_IN' is already a vector type, then this     indicates that target support had already been checked by PATTERN_RECOG_FUNC.    If 'TYPE_OUT' is also returned by PATTERN_RECOG_FUNC, we check that it fits    to the available target pattern.     This function also does some bookkeeping, as explained in the documentation     for vect_recog_pattern.  */
end_comment

begin_function
specifier|static
name|void
name|vect_pattern_recog_1
parameter_list|(
name|tree
function_decl|(
modifier|*
name|vect_recog_func
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
parameter_list|,
name|block_stmt_iterator
name|si
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|pattern_stmt_info
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|pattern_expr
decl_stmt|;
name|tree
name|pattern_vectype
decl_stmt|;
name|tree
name|type_in
decl_stmt|,
name|type_out
decl_stmt|;
name|tree
name|pattern_type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|var_name
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|pattern_expr
operator|=
call|(
modifier|*
name|vect_recog_func
call|)
argument_list|(
name|stmt
argument_list|,
operator|&
name|type_in
argument_list|,
operator|&
name|type_out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pattern_expr
condition|)
return|return;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|type_in
argument_list|)
argument_list|)
condition|)
block|{
comment|/* No need to check target support (already checked by the pattern           recognition function).  */
name|pattern_vectype
operator|=
name|type_in
expr_stmt|;
block|}
else|else
block|{
name|enum
name|tree_code
name|vec_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|optab
name|optab
decl_stmt|;
comment|/* Check target support  */
name|pattern_vectype
operator|=
name|get_vectype_for_scalar_type
argument_list|(
name|type_in
argument_list|)
expr_stmt|;
name|optab
operator|=
name|optab_for_tree_code
argument_list|(
name|TREE_CODE
argument_list|(
name|pattern_expr
argument_list|)
argument_list|,
name|pattern_vectype
argument_list|)
expr_stmt|;
name|vec_mode
operator|=
name|TYPE_MODE
argument_list|(
name|pattern_vectype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optab
operator|||
operator|(
name|icode
operator|=
name|optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|vec_mode
index|]
operator|.
name|insn_code
operator|)
operator|==
name|CODE_FOR_nothing
operator|||
operator|(
name|type_out
operator|&&
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|!=
name|TYPE_MODE
argument_list|(
name|get_vectype_for_scalar_type
argument_list|(
name|type_out
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return;
block|}
comment|/* Found a vectorizable pattern.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"pattern recognized: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|pattern_expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the stmts that are involved in the pattern,      create a new stmt to express the pattern and insert it.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
name|pattern_expr
argument_list|)
expr_stmt|;
name|pattern_type
operator|=
name|TREE_TYPE
argument_list|(
name|pattern_expr
argument_list|)
expr_stmt|;
name|var
operator|=
name|create_tmp_var
argument_list|(
name|pattern_type
argument_list|,
literal|"patt"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|var_name
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pattern_expr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|var_name
argument_list|,
name|pattern_expr
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|var_name
argument_list|)
operator|=
name|pattern_expr
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|si
argument_list|,
name|pattern_expr
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|pattern_expr
argument_list|)
expr_stmt|;
name|set_stmt_info
argument_list|(
name|ann
argument_list|,
name|new_stmt_vec_info
argument_list|(
name|pattern_expr
argument_list|,
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|pattern_stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|pattern_expr
argument_list|)
expr_stmt|;
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|pattern_stmt_info
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|pattern_stmt_info
argument_list|)
operator|=
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|STMT_VINFO_VECTYPE
argument_list|(
name|pattern_stmt_info
argument_list|)
operator|=
name|pattern_vectype
expr_stmt|;
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|true
expr_stmt|;
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|pattern_expr
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Function vect_pattern_recog     Input:    LOOP_VINFO - a struct_loop_info of a loop in which we want to look for         computation idioms.     Output - for each computation idiom that is detected we insert a new stmt         that provides the same functionality and that can be vectorized. We         also record some information in the struct_stmt_info of the relevant         stmts, as explained below:     At the entry to this function we have the following stmts, with the    following initial value in the STMT_VINFO fields:           stmt                     in_pattern_p  related_stmt    vec_stmt          S1: a_i = ....                 -       -               -          S2: a_2 = ..use(a_i)..         -       -               -          S3: a_1 = ..use(a_2)..         -       -               -          S4: a_0 = ..use(a_1)..         -       -               -          S5: ... = ..use(a_0)..         -       -               -     Say the sequence {S1,S2,S3,S4} was detected as a pattern that can be    represented by a single stmt. We then:    - create a new stmt S6 that will replace the pattern.    - insert the new stmt S6 before the last stmt in the pattern    - fill in the STMT_VINFO fields as follows:                                    in_pattern_p  related_stmt    vec_stmt          S1: a_i = ....                 -       -               -                 S2: a_2 = ..use(a_i)..         -       -               -          S3: a_1 = ..use(a_2)..         -       -               -> S6: a_new = ....               -       S4              -          S4: a_0 = ..use(a_1)..         true    S6              -          S5: ... = ..use(a_0)..         -       -               -     (the last stmt in the pattern (S4) and the new pattern stmt (S6) point     to each other through the RELATED_STMT field).     S6 will be marked as relevant in vect_mark_stmts_to_be_vectorized instead    of S4 because it will replace all its uses.  Stmts {S1,S2,S3} will    remain irrelevant unless used by stmts other than S4.     If vectorization succeeds, vect_transform_stmt will skip over {S1,S2,S3}    (because they are marked as irrelevant). It will vectorize S6, and record    a pointer to the new vector stmt VS6 both from S6 (as usual), and also     from S4. We do that so that when we get to vectorizing stmts that use the    def of S4 (like S5 that uses a_0), we'll know where to take the relevant    vector-def from. S4 will be skipped, and S5 will be vectorized as usual:                                    in_pattern_p  related_stmt    vec_stmt          S1: a_i = ....                 -       -               -          S2: a_2 = ..use(a_i)..         -       -               -          S3: a_1 = ..use(a_2)..         -       -               -> VS6: va_new = ....             -       -               -          S6: a_new = ....               -       S4              VS6          S4: a_0 = ..use(a_1)..         true    S6              VS6> VS5: ... = ..vuse(va_new)..    -       -               -          S5: ... = ..use(a_0)..         -       -               -     DCE could then get rid of {S1,S2,S3,S4,S5,S6} (if their defs are not used    elsewhere), and we'll end up with:          VS6: va_new = ....          VS5: ... = ..vuse(va_new)..     If vectorization does not succeed, DCE will clean S6 away (its def is    not used), and we'll end up with the original sequence. */
end_comment

begin_function
name|void
name|vect_pattern_recog
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|LOOP_VINFO_BBS
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|nbbs
init|=
name|loop
operator|->
name|num_nodes
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tree
function_decl|(
modifier|*
name|vect_recog_func_ptr
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_pattern_recog ==="
argument_list|)
expr_stmt|;
comment|/* Scan through the loop stmts, applying the pattern recognition      functions starting at each stmt visited:  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|bbs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
comment|/* Scan over all generic vect_recog_xxx_pattern functions.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_PATTERNS
condition|;
name|j
operator|++
control|)
block|{
name|vect_recog_func_ptr
operator|=
name|vect_vect_recog_func_ptrs
index|[
name|j
index|]
expr_stmt|;
name|vect_pattern_recog_1
argument_list|(
name|vect_recog_func_ptr
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

