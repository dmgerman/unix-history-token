begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The tracer pass for the GNU compiler.    Contributed by Jan Hubicka, SuSE Labs.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This pass performs the tail duplication needed for superblock formation.    For more information see:       Design and Analysis of Profile-Based Optimization in Compaq's      Compilation Tools for Alpha; Journal of Instruction-Level      Parallelism 3 (2000) 1-25     Unlike Compaq's implementation we don't do the loop peeling as most    probably a better job can be done by a special pass and we don't    need to worry too much about the code size implications as the tail    duplicates are crossjumped again if optimizations are not    performed.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_function_decl
specifier|static
name|int
name|count_insns
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ignore_bb_p
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|better_p
parameter_list|(
name|edge
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|find_best_successor
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|find_best_predecessor
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_trace
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tail_duplicate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_superblocks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Minimal outgoing edge probability considered for superblock formation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|probability_cutoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|branch_ratio_cutoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if BB has been seen - it is connected to some trace    already.  */
end_comment

begin_define
define|#
directive|define
name|seen
parameter_list|(
name|bb
parameter_list|)
value|(bb->il.rtl->visited || bb->aux)
end_define

begin_comment
comment|/* Return true if we should ignore the basic block for purposes of tracing.  */
end_comment

begin_function
specifier|static
name|bool
name|ignore_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return number of instructions in the block.  */
end_comment

begin_function
specifier|static
name|int
name|count_insns
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Return true if E1 is more frequent than E2.  */
end_comment

begin_function
specifier|static
name|bool
name|better_p
parameter_list|(
name|edge
name|e1
parameter_list|,
name|edge
name|e2
parameter_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|count
operator|!=
name|e2
operator|->
name|count
condition|)
return|return
name|e1
operator|->
name|count
operator|>
name|e2
operator|->
name|count
return|;
if|if
condition|(
name|e1
operator|->
name|src
operator|->
name|frequency
operator|*
name|e1
operator|->
name|probability
operator|!=
name|e2
operator|->
name|src
operator|->
name|frequency
operator|*
name|e2
operator|->
name|probability
condition|)
return|return
operator|(
name|e1
operator|->
name|src
operator|->
name|frequency
operator|*
name|e1
operator|->
name|probability
operator|>
name|e2
operator|->
name|src
operator|->
name|frequency
operator|*
name|e2
operator|->
name|probability
operator|)
return|;
comment|/* This is needed to avoid changes in the decision after      CFG is modified.  */
if|if
condition|(
name|e1
operator|->
name|src
operator|!=
name|e2
operator|->
name|src
condition|)
return|return
name|e1
operator|->
name|src
operator|->
name|index
operator|>
name|e2
operator|->
name|src
operator|->
name|index
return|;
return|return
name|e1
operator|->
name|dest
operator|->
name|index
operator|>
name|e2
operator|->
name|dest
operator|->
name|index
return|;
block|}
end_function

begin_comment
comment|/* Return most frequent successor of basic block BB.  */
end_comment

begin_function
specifier|static
name|edge
name|find_best_successor
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge
name|best
init|=
name|NULL
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
name|best
operator|||
name|better_p
argument_list|(
name|e
argument_list|,
name|best
argument_list|)
condition|)
name|best
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
name|ignore_bb_p
argument_list|(
name|best
operator|->
name|dest
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|best
operator|->
name|probability
operator|<=
name|probability_cutoff
condition|)
return|return
name|NULL
return|;
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Return most frequent predecessor of basic block BB.  */
end_comment

begin_function
specifier|static
name|edge
name|find_best_predecessor
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge
name|best
init|=
name|NULL
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
operator|!
name|best
operator|||
name|better_p
argument_list|(
name|e
argument_list|,
name|best
argument_list|)
condition|)
name|best
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
name|ignore_bb_p
argument_list|(
name|best
operator|->
name|src
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|best
argument_list|)
operator|*
name|REG_BR_PROB_BASE
operator|<
name|bb
operator|->
name|frequency
operator|*
name|branch_ratio_cutoff
condition|)
return|return
name|NULL
return|;
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Find the trace using bb and record it in the TRACE array.    Return number of basic blocks recorded.  */
end_comment

begin_function
specifier|static
name|int
name|find_trace
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
modifier|*
name|trace
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Trace seed %i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|find_best_predecessor
argument_list|(
name|bb
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|basic_block
name|bb2
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|seen
argument_list|(
name|bb2
argument_list|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_DFS_BACK
operator||
name|EDGE_COMPLEX
operator|)
operator|)
operator|||
name|find_best_successor
argument_list|(
name|bb2
argument_list|)
operator|!=
name|e
condition|)
break|break;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|",%i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb2
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" forward %i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|trace
index|[
name|i
operator|++
index|]
operator|=
name|bb
expr_stmt|;
comment|/* Follow the trace in forward direction.  */
while|while
condition|(
operator|(
name|e
operator|=
name|find_best_successor
argument_list|(
name|bb
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|seen
argument_list|(
name|bb
argument_list|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_DFS_BACK
operator||
name|EDGE_COMPLEX
operator|)
operator|)
operator|||
name|find_best_predecessor
argument_list|(
name|bb
argument_list|)
operator|!=
name|e
condition|)
break|break;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|",%i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|trace
index|[
name|i
operator|++
index|]
operator|=
name|bb
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Look for basic blocks in frequency order, construct traces and tail duplicate    if profitable.  */
end_comment

begin_function
specifier|static
name|void
name|tail_duplicate
parameter_list|(
name|void
parameter_list|)
block|{
name|fibnode_t
modifier|*
name|blocks
init|=
name|XCNEWVEC
argument_list|(
name|fibnode_t
argument_list|,
name|last_basic_block
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|trace
init|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|int
modifier|*
name|counts
init|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
decl_stmt|;
name|int
name|ninsns
init|=
literal|0
decl_stmt|,
name|nduplicated
init|=
literal|0
decl_stmt|;
name|gcov_type
name|weighted_insns
init|=
literal|0
decl_stmt|,
name|traced_insns
init|=
literal|0
decl_stmt|;
name|fibheap_t
name|heap
init|=
name|fibheap_new
argument_list|()
decl_stmt|;
name|gcov_type
name|cover_insns
decl_stmt|;
name|int
name|max_dup_insns
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK
argument_list|)
expr_stmt|;
else|else
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY
argument_list|)
expr_stmt|;
name|probability_cutoff
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
name|probability_cutoff
expr_stmt|;
name|branch_ratio_cutoff
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_RATIO
argument_list|)
operator|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|n
init|=
name|count_insns
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|blocks
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
operator|-
name|bb
operator|->
name|frequency
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|counts
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|n
expr_stmt|;
name|ninsns
operator|+=
name|n
expr_stmt|;
name|weighted_insns
operator|+=
name|n
operator|*
name|bb
operator|->
name|frequency
expr_stmt|;
block|}
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
name|cover_insns
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_DYNAMIC_COVERAGE_FEEDBACK
argument_list|)
expr_stmt|;
else|else
name|cover_insns
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_DYNAMIC_COVERAGE
argument_list|)
expr_stmt|;
name|cover_insns
operator|=
operator|(
name|weighted_insns
operator|*
name|cover_insns
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|max_dup_insns
operator|=
operator|(
name|ninsns
operator|*
name|PARAM_VALUE
argument_list|(
name|TRACER_MAX_CODE_GROWTH
argument_list|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
while|while
condition|(
name|traced_insns
operator|<
name|cover_insns
operator|&&
name|nduplicated
operator|<
name|max_dup_insns
operator|&&
operator|!
name|fibheap_empty
argument_list|(
name|heap
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|,
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
break|break;
name|blocks
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ignore_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
name|gcc_assert
argument_list|(
operator|!
name|seen
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|find_trace
argument_list|(
name|bb
argument_list|,
name|trace
argument_list|)
expr_stmt|;
name|bb
operator|=
name|trace
index|[
literal|0
index|]
expr_stmt|;
name|traced_insns
operator|+=
name|bb
operator|->
name|frequency
operator|*
name|counts
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|blocks
index|[
name|bb
operator|->
name|index
index|]
condition|)
block|{
name|fibheap_delete_node
argument_list|(
name|heap
argument_list|,
name|blocks
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|blocks
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|pos
operator|=
literal|1
init|;
name|pos
operator|<
name|n
condition|;
name|pos
operator|++
control|)
block|{
name|basic_block
name|bb2
init|=
name|trace
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|blocks
index|[
name|bb2
operator|->
name|index
index|]
condition|)
block|{
name|fibheap_delete_node
argument_list|(
name|heap
argument_list|,
name|blocks
index|[
name|bb2
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|blocks
index|[
name|bb2
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|traced_insns
operator|+=
name|bb2
operator|->
name|frequency
operator|*
name|counts
index|[
name|bb2
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb2
operator|->
name|preds
argument_list|)
operator|>
literal|1
operator|&&
name|can_duplicate_block_p
argument_list|(
name|bb2
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|old
init|=
name|bb2
decl_stmt|;
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
name|nduplicated
operator|+=
name|counts
index|[
name|bb2
operator|->
name|index
index|]
expr_stmt|;
name|bb2
operator|=
name|duplicate_block
argument_list|(
name|bb2
argument_list|,
name|e
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Reconsider the original copy of block we've duplicated. 	         Removing the most common predecessor may make it to be 	         head.  */
name|blocks
index|[
name|old
operator|->
name|index
index|]
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
operator|-
name|old
operator|->
name|frequency
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Duplicated %i as %i [%i]\n"
argument_list|,
name|old
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
name|bb
operator|->
name|aux
operator|=
name|bb2
expr_stmt|;
name|bb2
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
name|bb
operator|=
name|bb2
expr_stmt|;
comment|/* In case the trace became infrequent, stop duplicating.  */
if|if
condition|(
name|ignore_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" covered now %.1f\n\n"
argument_list|,
name|traced_insns
operator|*
literal|100.0
operator|/
name|weighted_insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Duplicated %i insns (%i%%)\n"
argument_list|,
name|nduplicated
argument_list|,
name|nduplicated
operator|*
literal|100
operator|/
name|ninsns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|trace
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Connect the superblocks into linear sequence.  At the moment we attempt to keep    the original order as much as possible, but the algorithm may be made smarter    later if needed.  BB reordering pass should void most of the benefits of such    change though.  */
end_comment

begin_function
specifier|static
name|void
name|layout_superblocks
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|end
init|=
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|end
operator|->
name|next_bb
decl_stmt|;
while|while
condition|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|best
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|end
operator|->
name|aux
condition|)
name|end
operator|=
name|end
operator|->
name|aux
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|end->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|&&
operator|(
operator|!
name|best
operator|||
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|>
name|EDGE_FREQUENCY
argument_list|(
name|best
argument_list|)
operator|)
condition|)
name|best
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|best
condition|)
block|{
name|end
operator|->
name|aux
operator|=
name|best
operator|->
name|dest
expr_stmt|;
name|best
operator|->
name|dest
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|;
name|bb
operator|=
name|bb
operator|->
name|next_bb
control|)
block|{
if|if
condition|(
operator|!
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
condition|)
block|{
name|end
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Main entry point to this file.  FLAGS is the set of flags to pass    to cfg_layout_initialize().  */
end_comment

begin_function
name|void
name|tracer
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|n_basic_blocks
operator|<=
name|NUM_FIXED_BLOCKS
operator|+
literal|1
condition|)
return|return;
name|cfg_layout_initialize
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_flow_info
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|tail_duplicate
argument_list|()
expr_stmt|;
name|layout_superblocks
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_flow_info
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
comment|/* Merge basic blocks in duplicated traces.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_tracer
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_tracer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Run tracer.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_tracer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|dump_flow_info
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|tracer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_tracer
init|=
block|{
literal|"tracer"
block|,
comment|/* name */
name|gate_handle_tracer
block|,
comment|/* gate */
name|rest_of_handle_tracer
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TRACER
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'T'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

