begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Linear Loop transforms    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dberlin@dberlin.org>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"lambda.h"
end_include

begin_comment
comment|/* Linear loop transforms include any composition of interchange,    scaling, skewing, and reversal.  They are used to change the    iteration order of loop nests in order to optimize data locality of    traversals, or remove dependences that prevent    parallelization/vectorization/etc.       TODO: Determine reuse vectors/matrix and use it to determine optimal    transform matrix for locality purposes.    TODO: Completion of partial transforms.  */
end_comment

begin_comment
comment|/* Gather statistics for loop interchange.  LOOP is the loop being    considered. The first loop in the considered loop nest is    FIRST_LOOP, and consequently, the index of the considered loop is    obtained by LOOP->DEPTH - FIRST_LOOP->DEPTH        Initializes:    - DEPENDENCE_STEPS the sum of all the data dependence distances    carried by loop LOOP,     - NB_DEPS_NOT_CARRIED_BY_LOOP the number of dependence relations    for which the loop LOOP is not carrying any dependence,     - ACCESS_STRIDES the sum of all the strides in LOOP.     Example: for the following loop,     | loop_1 runs 1335 times    |   loop_2 runs 1335 times    |     A[{{0, +, 1}_1, +, 1335}_2]    |     B[{{0, +, 1}_1, +, 1335}_2]    |   endloop_2    |   A[{0, +, 1336}_1]    | endloop_1     gather_interchange_stats (in loop_1) will return     DEPENDENCE_STEPS = 3002    NB_DEPS_NOT_CARRIED_BY_LOOP = 5    ACCESS_STRIDES = 10694     gather_interchange_stats (in loop_2) will return     DEPENDENCE_STEPS = 3000    NB_DEPS_NOT_CARRIED_BY_LOOP = 7    ACCESS_STRIDES = 8010 */
end_comment

begin_decl_stmt
specifier|static
name|void
name|gather_interchange_stats
argument_list|(
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|dependence_relations
argument_list|,
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
argument_list|,
expr|struct
name|loop
operator|*
name|loop
argument_list|,
expr|struct
name|loop
operator|*
name|first_loop
argument_list|,
name|unsigned
name|int
operator|*
name|dependence_steps
argument_list|,
name|unsigned
name|int
operator|*
name|nb_deps_not_carried_by_loop
argument_list|,
name|unsigned
name|int
operator|*
name|access_strides
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
operator|*
name|dependence_steps
operator|=
literal|0
expr_stmt|;
operator|*
name|nb_deps_not_carried_by_loop
operator|=
literal|0
expr_stmt|;
operator|*
name|access_strides
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ddr_p
argument_list|,
name|dependence_relations
argument_list|,
name|i
argument_list|,
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* If we don't know anything about this dependence, or the distance 	 vector is NULL, or there is no dependence, then there is no reuse of 	 data.  */
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_dont_know
operator|||
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_known
operator|||
name|DDR_NUM_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DDR_NUM_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|dist
init|=
name|DDR_DIST_VECT
argument_list|(
name|ddr
argument_list|,
name|j
argument_list|)
index|[
name|loop
operator|->
name|depth
operator|-
name|first_loop
operator|->
name|depth
index|]
decl_stmt|;
if|if
condition|(
name|dist
operator|==
literal|0
condition|)
operator|(
operator|*
name|nb_deps_not_carried_by_loop
operator|)
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
operator|(
operator|*
name|dependence_steps
operator|)
operator|+=
operator|-
name|dist
expr_stmt|;
else|else
operator|(
operator|*
name|dependence_steps
operator|)
operator|+=
name|dist
expr_stmt|;
block|}
block|}
comment|/* Compute the access strides.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|it
decl_stmt|;
name|tree
name|stmt
init|=
name|DR_STMT
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|stmt_loop
init|=
name|loop_containing_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|inner_loop
init|=
name|first_loop
operator|->
name|inner
decl_stmt|;
if|if
condition|(
name|inner_loop
operator|!=
name|stmt_loop
operator|&&
operator|!
name|flow_loop_nested_p
argument_list|(
name|inner_loop
argument_list|,
name|stmt_loop
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|it
operator|=
literal|0
init|;
name|it
operator|<
name|DR_NUM_DIMENSIONS
argument_list|(
name|dr
argument_list|)
condition|;
name|it
operator|++
control|)
block|{
name|tree
name|chrec
init|=
name|DR_ACCESS_FN
argument_list|(
name|dr
argument_list|,
name|it
argument_list|)
decl_stmt|;
name|tree
name|tstride
init|=
name|evolution_part_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|loop
operator|->
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|tstride
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|tstride
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
continue|continue;
operator|(
operator|*
name|access_strides
operator|)
operator|+=
name|int_cst_value
argument_list|(
name|tstride
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Attempt to apply interchange transformations to TRANS to maximize the    spatial and temporal locality of the loop.      Returns the new transform matrix.  The smaller the reuse vector    distances in the inner loops, the fewer the cache misses.    FIRST_LOOP is the loop->num of the first loop in the analyzed loop    nest.  */
end_comment

begin_decl_stmt
specifier|static
name|lambda_trans_matrix
name|try_interchange_loops
argument_list|(
name|lambda_trans_matrix
name|trans
argument_list|,
name|unsigned
name|int
name|depth
argument_list|,
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|dependence_relations
argument_list|,
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
argument_list|,
expr|struct
name|loop
operator|*
name|first_loop
argument_list|)
block|{
name|struct
name|loop
modifier|*
name|loop_i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop_j
decl_stmt|;
name|unsigned
name|int
name|dependence_steps_i
decl_stmt|,
name|dependence_steps_j
decl_stmt|;
name|unsigned
name|int
name|access_strides_i
decl_stmt|,
name|access_strides_j
decl_stmt|;
name|unsigned
name|int
name|nb_deps_not_carried_by_i
decl_stmt|,
name|nb_deps_not_carried_by_j
decl_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|ddr_p
argument_list|,
name|dependence_relations
argument_list|)
operator|==
literal|0
condition|)
return|return
name|trans
return|;
comment|/* When there is an unknown relation in the dependence_relations, we      know that it is no worth looking at this loop nest: give up.  */
name|ddr
operator|=
name|VEC_index
argument_list|(
name|ddr_p
argument_list|,
name|dependence_relations
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddr
operator|==
name|NULL
operator|||
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_dont_know
condition|)
return|return
name|trans
return|;
comment|/* LOOP_I is always the outer loop.  */
for|for
control|(
name|loop_j
operator|=
name|first_loop
operator|->
name|inner
init|;
name|loop_j
condition|;
name|loop_j
operator|=
name|loop_j
operator|->
name|inner
control|)
for|for
control|(
name|loop_i
operator|=
name|first_loop
init|;
name|loop_i
operator|->
name|depth
operator|<
name|loop_j
operator|->
name|depth
condition|;
name|loop_i
operator|=
name|loop_i
operator|->
name|inner
control|)
block|{
name|gather_interchange_stats
argument_list|(
name|dependence_relations
argument_list|,
name|datarefs
argument_list|,
name|loop_i
argument_list|,
name|first_loop
argument_list|,
operator|&
name|dependence_steps_i
argument_list|,
operator|&
name|nb_deps_not_carried_by_i
argument_list|,
operator|&
name|access_strides_i
argument_list|)
expr_stmt|;
name|gather_interchange_stats
argument_list|(
name|dependence_relations
argument_list|,
name|datarefs
argument_list|,
name|loop_j
argument_list|,
name|first_loop
argument_list|,
operator|&
name|dependence_steps_j
argument_list|,
operator|&
name|nb_deps_not_carried_by_j
argument_list|,
operator|&
name|access_strides_j
argument_list|)
expr_stmt|;
comment|/* Heuristics for loop interchange profitability:  	   1. (spatial locality) Inner loops should have smallest               dependence steps.  	   2. (spatial locality) Inner loops should contain more 	   dependence relations not carried by the loop.  	   3. (temporal locality) Inner loops should have smallest  	      array access strides. 	*/
if|if
condition|(
name|dependence_steps_i
operator|<
name|dependence_steps_j
operator|||
name|nb_deps_not_carried_by_i
operator|>
name|nb_deps_not_carried_by_j
operator|||
name|access_strides_i
operator|<
name|access_strides_j
condition|)
block|{
name|lambda_matrix_row_exchange
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|loop_i
operator|->
name|depth
operator|-
name|first_loop
operator|->
name|depth
argument_list|,
name|loop_j
operator|->
name|depth
operator|-
name|first_loop
operator|->
name|depth
argument_list|)
expr_stmt|;
comment|/* Validate the resulting matrix.  When the transformation 	       is not valid, reverse to the previous transformation.  */
if|if
condition|(
operator|!
name|lambda_transform_legal_p
argument_list|(
name|trans
argument_list|,
name|depth
argument_list|,
name|dependence_relations
argument_list|)
condition|)
name|lambda_matrix_row_exchange
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|loop_i
operator|->
name|depth
operator|-
name|first_loop
operator|->
name|depth
argument_list|,
name|loop_j
operator|->
name|depth
operator|-
name|first_loop
operator|->
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|trans
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Perform a set of linear transforms on LOOPS.  */
end_comment

begin_function
name|void
name|linear_transform_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|bool
name|modified
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|oldivs
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|invariants
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|dependence_relations
expr_stmt|;
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
expr_stmt|;
name|struct
name|loop
modifier|*
name|loop_nest
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
name|struct
name|loop
modifier|*
name|temp
decl_stmt|;
name|lambda_loopnest
name|before
decl_stmt|,
name|after
decl_stmt|;
name|lambda_trans_matrix
name|trans
decl_stmt|;
name|bool
name|problem
init|=
name|false
decl_stmt|;
comment|/* If it's not a loop nest, we don't want it.          We also don't handle sibling loops properly,           which are loops of the following form:          for (i = 0; i< 50; i++)            {              for (j = 0; j< 50; j++)                { 	        ...                }              for (j = 0; j< 50; j++)                {                 ...                }            } */
if|if
condition|(
operator|!
name|loop_nest
operator|||
operator|!
name|loop_nest
operator|->
name|inner
operator|||
operator|!
name|loop_nest
operator|->
name|single_exit
condition|)
continue|continue;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|oldivs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|invariants
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|loop_nest
operator|->
name|inner
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|inner
control|)
block|{
comment|/* If we have a sibling loop or multiple exit edges, jump ship.  */
if|if
condition|(
name|temp
operator|->
name|next
operator|||
operator|!
name|temp
operator|->
name|single_exit
condition|)
block|{
name|problem
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|depth
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|problem
condition|)
continue|continue;
comment|/* Analyze data references and dependence relations using scev.  */
name|datarefs
operator|=
name|VEC_alloc
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|dependence_relations
operator|=
name|VEC_alloc
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|,
literal|10
operator|*
literal|10
argument_list|)
expr_stmt|;
name|compute_data_dependences_for_loop
argument_list|(
name|loop_nest
argument_list|,
name|true
argument_list|,
operator|&
name|datarefs
argument_list|,
operator|&
name|dependence_relations
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_ddrs
argument_list|(
name|dump_file
argument_list|,
name|dependence_relations
argument_list|)
expr_stmt|;
comment|/* Build the transformation matrix.  */
name|trans
operator|=
name|lambda_trans_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|lambda_matrix_id
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|trans
operator|=
name|try_interchange_loops
argument_list|(
name|trans
argument_list|,
name|depth
argument_list|,
name|dependence_relations
argument_list|,
name|datarefs
argument_list|,
name|loop_nest
argument_list|)
expr_stmt|;
if|if
condition|(
name|lambda_trans_matrix_id_p
argument_list|(
name|trans
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Won't transform loop. Optimal transform is the identity transform\n"
argument_list|)
expr_stmt|;
goto|goto
name|free_and_continue
goto|;
block|}
comment|/* Check whether the transformation is legal.  */
if|if
condition|(
operator|!
name|lambda_transform_legal_p
argument_list|(
name|trans
argument_list|,
name|depth
argument_list|,
name|dependence_relations
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Can't transform loop, transform is illegal:\n"
argument_list|)
expr_stmt|;
goto|goto
name|free_and_continue
goto|;
block|}
name|before
operator|=
name|gcc_loopnest_to_lambda_loopnest
argument_list|(
name|loops
argument_list|,
name|loop_nest
argument_list|,
operator|&
name|oldivs
argument_list|,
operator|&
name|invariants
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|before
condition|)
goto|goto
name|free_and_continue
goto|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Before:\n"
argument_list|)
expr_stmt|;
name|print_lambda_loopnest
argument_list|(
name|dump_file
argument_list|,
name|before
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
block|}
name|after
operator|=
name|lambda_loopnest_transform
argument_list|(
name|before
argument_list|,
name|trans
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"After:\n"
argument_list|)
expr_stmt|;
name|print_lambda_loopnest
argument_list|(
name|dump_file
argument_list|,
name|after
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
block|}
name|lambda_loopnest_to_gcc_loopnest
argument_list|(
name|loop_nest
argument_list|,
name|oldivs
argument_list|,
name|invariants
argument_list|,
name|after
argument_list|,
name|trans
argument_list|)
expr_stmt|;
name|modified
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Successfully transformed loop.\n"
argument_list|)
expr_stmt|;
name|free_and_continue
label|:
name|free_dependence_relations
argument_list|(
name|dependence_relations
argument_list|)
expr_stmt|;
name|free_data_refs
argument_list|(
name|datarefs
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|oldivs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|scev_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|modified
condition|)
name|rewrite_into_loop_closed_ssa
argument_list|(
name|NULL
argument_list|,
name|TODO_update_ssa_full_phi
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

