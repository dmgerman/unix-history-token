begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree browser.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Sebastian Pop<s.pop@laposte.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_define
define|#
directive|define
name|TB_OUT_FILE
value|stdout
end_define

begin_define
define|#
directive|define
name|TB_IN_FILE
value|stdin
end_define

begin_define
define|#
directive|define
name|TB_NIY
value|fprintf (TB_OUT_FILE, "Sorry this command is not yet implemented.\n")
end_define

begin_define
define|#
directive|define
name|TB_WF
value|fprintf (TB_OUT_FILE, "Warning, this command failed.\n")
end_define

begin_comment
comment|/* Structures for handling Tree Browser's commands.  */
end_comment

begin_define
define|#
directive|define
name|DEFTBCODE
parameter_list|(
name|COMMAND
parameter_list|,
name|STRING
parameter_list|,
name|HELP
parameter_list|)
value|COMMAND,
end_define

begin_enum
enum|enum
name|TB_Comm_code
block|{
include|#
directive|include
file|"tree-browser.def"
name|TB_UNUSED_COMMAND
block|}
enum|;
end_enum

begin_undef
undef|#
directive|undef
name|DEFTBCODE
end_undef

begin_typedef
typedef|typedef
name|enum
name|TB_Comm_code
name|TB_CODE
typedef|;
end_typedef

begin_struct
struct|struct
name|tb_command
block|{
specifier|const
name|char
modifier|*
name|help_msg
decl_stmt|;
specifier|const
name|char
modifier|*
name|comm_text
decl_stmt|;
name|size_t
name|comm_len
decl_stmt|;
name|TB_CODE
name|comm_code
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFTBCODE
parameter_list|(
name|code
parameter_list|,
name|str
parameter_list|,
name|help
parameter_list|)
value|{ help, str, sizeof(str) - 1, code },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tb_command
name|tb_commands
index|[]
init|=
block|{
include|#
directive|include
file|"tree-browser.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTBCODE
end_undef

begin_define
define|#
directive|define
name|TB_COMMAND_LEN
parameter_list|(
name|N
parameter_list|)
value|(tb_commands[N].comm_len)
end_define

begin_define
define|#
directive|define
name|TB_COMMAND_TEXT
parameter_list|(
name|N
parameter_list|)
value|(tb_commands[N].comm_text)
end_define

begin_define
define|#
directive|define
name|TB_COMMAND_CODE
parameter_list|(
name|N
parameter_list|)
value|(tb_commands[N].comm_code)
end_define

begin_define
define|#
directive|define
name|TB_COMMAND_HELP
parameter_list|(
name|N
parameter_list|)
value|(tb_commands[N].help_msg)
end_define

begin_comment
comment|/* Next structure is for parsing TREE_CODEs.  */
end_comment

begin_struct
struct|struct
name|tb_tree_code
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|code_string
decl_stmt|;
name|size_t
name|code_string_len
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|STRING
parameter_list|,
name|TYPE
parameter_list|,
name|NARGS
parameter_list|)
value|{ SYM, STRING, sizeof (STRING) - 1 },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tb_tree_code
name|tb_tree_codes
index|[]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_define
define|#
directive|define
name|TB_TREE_CODE
parameter_list|(
name|N
parameter_list|)
value|(tb_tree_codes[N].code)
end_define

begin_define
define|#
directive|define
name|TB_TREE_CODE_TEXT
parameter_list|(
name|N
parameter_list|)
value|(tb_tree_codes[N].code_string)
end_define

begin_define
define|#
directive|define
name|TB_TREE_CODE_LEN
parameter_list|(
name|N
parameter_list|)
value|(tb_tree_codes[N].code_string_len)
end_define

begin_comment
comment|/* Function declarations.  */
end_comment

begin_function_decl
specifier|static
name|long
name|TB_getline
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TB_CODE
name|TB_get_command
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|TB_get_tree_code
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_node_with_code
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|store_child_info
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|TB_update_up
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|TB_current_chain_node
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|TB_prev_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|TB_next_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|TB_up_expr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|TB_first_in_bind
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|TB_last_in_bind
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TB_parent_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|TB_history_prev
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIXME: To be declared in a .h file.  */
end_comment

begin_function_decl
name|void
name|browse_tree
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Static variables.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|TB_up_ht
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|TB_history_stack
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|TB_verbose
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry point in the Tree Browser.  */
end_comment

begin_function
name|void
name|browse_tree
parameter_list|(
name|tree
name|begin
parameter_list|)
block|{
name|tree
name|head
decl_stmt|;
name|TB_CODE
name|tbc
init|=
name|TB_UNUSED_COMMAND
decl_stmt|;
name|ssize_t
name|rd
decl_stmt|;
name|char
modifier|*
name|input
init|=
name|NULL
decl_stmt|;
name|long
name|input_size
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"\nTree Browser\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|TB_SET_HEAD
parameter_list|(
name|N
parameter_list|)
value|do {                                           \   TB_history_stack = tree_cons (NULL_TREE, (N), TB_history_stack);    \   head = N;                                                           \   if (TB_verbose)                                                     \     if (head)                                                         \       {                                                               \ 	print_generic_expr (TB_OUT_FILE, head, 0);                    \ 	fprintf (TB_OUT_FILE, "\n");                                  \       }                                                               \ } while (0)
name|TB_SET_HEAD
argument_list|(
name|begin
argument_list|)
expr_stmt|;
comment|/* Store in a hashtable information about previous and upper statements.  */
block|{
name|TB_up_ht
operator|=
name|htab_create
argument_list|(
literal|1023
argument_list|,
name|htab_hash_pointer
argument_list|,
operator|&
name|TB_parent_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TB_update_up
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|24
condition|)
block|{
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"TB> "
argument_list|)
expr_stmt|;
name|rd
operator|=
name|TB_getline
argument_list|(
operator|&
name|input
argument_list|,
operator|&
name|input_size
argument_list|,
name|TB_IN_FILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
operator|-
literal|1
condition|)
comment|/* EOF.  */
goto|goto
name|ret
goto|;
if|if
condition|(
name|rd
operator|!=
literal|1
condition|)
comment|/* Get a new command.  Otherwise the user just pressed enter, and thus 	   she expects the last command to be reexecuted.  */
name|tbc
operator|=
name|TB_get_command
argument_list|(
name|input
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tbc
condition|)
block|{
case|case
name|TB_UPDATE_UP
case|:
name|TB_update_up
argument_list|(
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|TB_MAX
case|:
if|if
condition|(
name|head
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|head
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|REAL_TYPE
operator|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_MIN
case|:
if|if
condition|(
name|head
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|head
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|REAL_TYPE
operator|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_ELT
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
comment|/* This command takes another argument: the element number: 		 for example "elt 1".  */
name|TB_NIY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|VECTOR_CST
condition|)
block|{
comment|/* This command takes another argument: the element number:                  for example "elt 1".  */
name|TB_NIY
expr_stmt|;
block|}
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_VALUE
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_VALUE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_PURPOSE
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_IMAG
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_REAL
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_REALPART
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_BLOCK
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_SUBBLOCKS
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BLOCK
condition|)
name|TB_SET_HEAD
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_SUPERCONTEXT
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BLOCK
condition|)
name|TB_SET_HEAD
argument_list|(
name|BLOCK_SUPERCONTEXT
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_VARS
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BLOCK
condition|)
name|TB_SET_HEAD
argument_list|(
name|BLOCK_VARS
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_REFERENCE_TO_THIS
case|:
if|if
condition|(
name|head
operator|&&
name|TYPE_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_REFERENCE_TO
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_POINTER_TO_THIS
case|:
if|if
condition|(
name|head
operator|&&
name|TYPE_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_BASETYPE
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_ARG_TYPES
case|:
if|if
condition|(
name|head
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_METHOD_BASE_TYPE
case|:
if|if
condition|(
name|head
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TYPE_METHOD_BASETYPE
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_FIELDS
case|:
if|if
condition|(
name|head
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_DOMAIN
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_VALUES
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_VALUES
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_ARG_TYPE
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_INITIAL
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_INITIAL
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_RESULT
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_RESULT_FLD
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_ARGUMENTS
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_ABSTRACT_ORIGIN
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BLOCK
condition|)
name|TB_SET_HEAD
argument_list|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_ATTRIBUTES
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_ATTRIBUTES
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|&&
name|TYPE_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_CONTEXT
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|&&
name|TYPE_P
argument_list|(
name|head
argument_list|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_OFFSET
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_BIT_OFFSET
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_UNIT_SIZE
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|&&
name|TYPE_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_SIZE
case|:
if|if
condition|(
name|head
operator|&&
name|DECL_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_SIZE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|&&
name|TYPE_P
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TYPE_SIZE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_TYPE
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_TYPE
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_TYPE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_DECL_SAVED_TREE
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_BODY
case|:
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_CHILD_0
case|:
if|if
condition|(
name|head
operator|&&
name|EXPR_P
argument_list|(
name|head
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|0
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_CHILD_1
case|:
if|if
condition|(
name|head
operator|&&
name|EXPR_P
argument_list|(
name|head
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|1
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_CHILD_2
case|:
if|if
condition|(
name|head
operator|&&
name|EXPR_P
argument_list|(
name|head
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|2
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_CHILD_3
case|:
if|if
condition|(
name|head
operator|&&
name|EXPR_P
argument_list|(
name|head
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|3
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|head
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_PRINT
case|:
if|if
condition|(
name|head
condition|)
name|debug_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_PRETTY_PRINT
case|:
if|if
condition|(
name|head
condition|)
block|{
name|print_generic_stmt
argument_list|(
name|TB_OUT_FILE
argument_list|,
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_SEARCH_NAME
case|:
break|break;
case|case
name|TB_SEARCH_CODE
case|:
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|char
modifier|*
name|arg_text
decl_stmt|;
name|arg_text
operator|=
name|strchr
argument_list|(
name|input
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_text
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"First argument is missing.  This isn't a valid search command.  \n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|code
operator|=
name|TB_get_tree_code
argument_list|(
name|arg_text
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Search in the subtree a node with the given code.  */
block|{
name|tree
name|res
decl_stmt|;
name|res
operator|=
name|walk_tree
argument_list|(
operator|&
name|head
argument_list|,
name|find_node_with_code
argument_list|,
operator|&
name|code
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL_TREE
condition|)
block|{
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"There's no node with this code (reachable via the walk_tree function from this node).\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"Achoo!  I got this node in the tree.\n"
argument_list|)
expr_stmt|;
name|TB_SET_HEAD
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
define|#
directive|define
name|TB_MOVE_HEAD
parameter_list|(
name|FCT
parameter_list|)
value|do {       \   if (head)                          \     {                                \       tree t;                        \       t = FCT (head);                \       if (t)                         \         TB_SET_HEAD (t);             \       else                           \ 	TB_WF;                       \     }                                \   else                               \     TB_WF;                           \ } while (0)
case|case
name|TB_FIRST
case|:
name|TB_MOVE_HEAD
argument_list|(
name|TB_first_in_bind
argument_list|)
expr_stmt|;
break|break;
case|case
name|TB_LAST
case|:
name|TB_MOVE_HEAD
argument_list|(
name|TB_last_in_bind
argument_list|)
expr_stmt|;
break|break;
case|case
name|TB_UP
case|:
name|TB_MOVE_HEAD
argument_list|(
name|TB_up_expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TB_PREV
case|:
name|TB_MOVE_HEAD
argument_list|(
name|TB_prev_expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TB_NEXT
case|:
name|TB_MOVE_HEAD
argument_list|(
name|TB_next_expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TB_HPREV
case|:
comment|/* This command is a little bit special, since it deals with history 	     stack.  For this reason it should keep the "head = ..." statement 	     and not use TB_MOVE_HEAD.  */
if|if
condition|(
name|head
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|TB_history_prev
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|head
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|TB_verbose
condition|)
block|{
name|print_generic_expr
argument_list|(
name|TB_OUT_FILE
argument_list|,
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|TB_WF
expr_stmt|;
block|}
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_CHAIN
case|:
comment|/* Don't go further if it's the last node in this chain.  */
if|if
condition|(
name|head
operator|&&
name|TREE_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|BLOCK
condition|)
name|TB_SET_HEAD
argument_list|(
name|BLOCK_CHAIN
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|&&
name|TREE_CHAIN
argument_list|(
name|head
argument_list|)
condition|)
name|TB_SET_HEAD
argument_list|(
name|TREE_CHAIN
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TB_WF
expr_stmt|;
break|break;
case|case
name|TB_FUN
case|:
comment|/* Go up to the current function declaration.  */
name|TB_SET_HEAD
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"Current function declaration.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TB_HELP
case|:
comment|/* Display a help message.  */
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"Possible commands are:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TB_UNUSED_COMMAND
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"%20s  -  %s\n"
argument_list|,
name|TB_COMMAND_TEXT
argument_list|(
name|i
argument_list|)
argument_list|,
name|TB_COMMAND_HELP
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TB_VERBOSE
case|:
if|if
condition|(
name|TB_verbose
operator|==
literal|0
condition|)
block|{
name|TB_verbose
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"Verbose on.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TB_verbose
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"Verbose off.\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TB_EXIT
case|:
case|case
name|TB_QUIT
case|:
comment|/* Just exit from this function.  */
goto|goto
name|ret
goto|;
default|default:
name|TB_NIY
expr_stmt|;
block|}
block|}
name|ret
label|:
empty_stmt|;
name|htab_delete
argument_list|(
name|TB_up_ht
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Search the first node in this BIND_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|TB_first_in_bind
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
while|while
condition|(
operator|(
name|t
operator|=
name|TB_prev_expr
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|node
operator|=
name|t
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Search the last node in this BIND_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|TB_last_in_bind
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
while|while
condition|(
operator|(
name|t
operator|=
name|TB_next_expr
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|node
operator|=
name|t
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Search the parent expression for this node.  */
end_comment

begin_function
specifier|static
name|tree
name|TB_up_expr
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|tree
name|res
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|res
operator|=
operator|(
name|tree
operator|)
name|htab_find
argument_list|(
name|TB_up_ht
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Search the previous expression in this BIND_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|TB_prev_expr
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|node
operator|=
name|TB_current_chain_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|node
operator|=
name|TB_up_expr
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|node
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Search the next expression in this BIND_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|TB_next_expr
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|node
operator|=
name|TB_current_chain_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|node
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|TB_current_chain_node
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|node
return|;
name|node
operator|=
name|TB_up_expr
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|node
return|;
name|node
operator|=
name|TB_up_expr
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|node
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* For each node store in its children nodes that the current node is their    parent.  This function is used by walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|store_child_info
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|node
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|node
operator|=
operator|*
name|tp
expr_stmt|;
comment|/* 'node' is the parent of 'TREE_OPERAND (node, *)'.  */
if|if
condition|(
name|EXPRESSION_CLASS_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
define|#
directive|define
name|STORE_CHILD
parameter_list|(
name|N
parameter_list|)
value|do {                                                \   tree op = TREE_OPERAND (node, N);                                        \   slot = htab_find_slot (TB_up_ht, op, INSERT);                               \   *slot = (void *) node;                                                   \ } while (0)
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|STORE_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|STORE_CHILD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|STORE_CHILD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|STORE_CHILD
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|STORE_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|STORE_CHILD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|STORE_CHILD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|STORE_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|STORE_CHILD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|STORE_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
comment|/* No children: nothing to do.  */
break|break;
block|}
undef|#
directive|undef
name|STORE_CHILD
block|}
comment|/* Never stop walk_tree.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Function used in TB_up_ht.  */
end_comment

begin_function
specifier|static
name|int
name|TB_parent_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|tree
name|node
decl_stmt|,
name|parent
decl_stmt|;
name|node
operator|=
operator|(
name|tree
operator|)
name|p2
expr_stmt|;
name|parent
operator|=
operator|(
name|tree
operator|)
name|p1
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
operator|||
name|p2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|EXPRESSION_CLASS_P
argument_list|(
name|parent
argument_list|)
condition|)
block|{
define|#
directive|define
name|TEST_CHILD
parameter_list|(
name|N
parameter_list|)
value|do {               \   if (node == TREE_OPERAND (parent, N))  \     return 1;                            \ } while (0)
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|TEST_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TEST_CHILD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TEST_CHILD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|TEST_CHILD
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|TEST_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TEST_CHILD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TEST_CHILD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|TEST_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TEST_CHILD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|TEST_CHILD
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
comment|/* No children: nothing to do.  */
break|break;
block|}
undef|#
directive|undef
name|TEST_CHILD
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update information about upper expressions in the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|TB_update_up
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
while|while
condition|(
name|node
condition|)
block|{
name|walk_tree
argument_list|(
operator|&
name|node
argument_list|,
name|store_child_info
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk function's body.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|node
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|node
argument_list|)
argument_list|,
name|store_child_info
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk rest of the chain.  */
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"Up/prev expressions updated.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the input string for determining the command the user asked for.  */
end_comment

begin_function
specifier|static
name|TB_CODE
name|TB_get_command
parameter_list|(
name|char
modifier|*
name|input
parameter_list|)
block|{
name|unsigned
name|int
name|mn
decl_stmt|,
name|size_tok
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|;
name|space
operator|=
name|strchr
argument_list|(
name|input
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|!=
name|NULL
condition|)
name|size_tok
operator|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|-
name|strlen
argument_list|(
name|space
argument_list|)
expr_stmt|;
else|else
name|size_tok
operator|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|mn
operator|=
literal|0
init|;
name|mn
operator|<
name|TB_UNUSED_COMMAND
condition|;
name|mn
operator|++
control|)
block|{
if|if
condition|(
name|size_tok
operator|!=
name|TB_COMMAND_LEN
argument_list|(
name|mn
argument_list|)
condition|)
continue|continue;
name|comp
operator|=
name|memcmp
argument_list|(
name|input
argument_list|,
name|TB_COMMAND_TEXT
argument_list|(
name|mn
argument_list|)
argument_list|,
name|TB_COMMAND_LEN
argument_list|(
name|mn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
comment|/* Here we just determined the command.  If this command takes 	   an argument, then the argument is determined later.  */
return|return
name|TB_COMMAND_CODE
argument_list|(
name|mn
argument_list|)
return|;
block|}
comment|/* Not a valid command.  */
return|return
name|TB_UNUSED_COMMAND
return|;
block|}
end_function

begin_comment
comment|/* Parse the input string for determining the tree code.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|TB_get_tree_code
parameter_list|(
name|char
modifier|*
name|input
parameter_list|)
block|{
name|unsigned
name|int
name|mn
decl_stmt|,
name|size_tok
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|;
name|space
operator|=
name|strchr
argument_list|(
name|input
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|!=
name|NULL
condition|)
name|size_tok
operator|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|-
name|strlen
argument_list|(
name|space
argument_list|)
expr_stmt|;
else|else
name|size_tok
operator|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|mn
operator|=
literal|0
init|;
name|mn
operator|<
name|LAST_AND_UNUSED_TREE_CODE
condition|;
name|mn
operator|++
control|)
block|{
if|if
condition|(
name|size_tok
operator|!=
name|TB_TREE_CODE_LEN
argument_list|(
name|mn
argument_list|)
condition|)
continue|continue;
name|comp
operator|=
name|memcmp
argument_list|(
name|input
argument_list|,
name|TB_TREE_CODE_TEXT
argument_list|(
name|mn
argument_list|)
argument_list|,
name|TB_TREE_CODE_LEN
argument_list|(
name|mn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|TB_OUT_FILE
argument_list|,
literal|"%s\n"
argument_list|,
name|TB_TREE_CODE_TEXT
argument_list|(
name|mn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TB_TREE_CODE
argument_list|(
name|mn
argument_list|)
return|;
block|}
block|}
comment|/* This isn't a valid code.  */
return|return
name|LAST_AND_UNUSED_TREE_CODE
return|;
block|}
end_function

begin_comment
comment|/* Find a node with a given code.  This function is used as an argument to    walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|find_node_with_code
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|tree_code
modifier|*
name|code
decl_stmt|;
name|code
operator|=
operator|(
expr|enum
name|tree_code
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|code
operator|==
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
return|return
operator|*
name|tp
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns a pointer to the last visited node.  */
end_comment

begin_function
specifier|static
name|tree
name|TB_history_prev
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TB_history_stack
condition|)
block|{
name|TB_history_stack
operator|=
name|TREE_CHAIN
argument_list|(
name|TB_history_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|TB_history_stack
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|TB_history_stack
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Read up to (and including) a '\n' from STREAM into *LINEPTR    (and null-terminate it). *LINEPTR is a pointer returned from malloc    (or NULL), pointing to *N characters of space.  It is realloc'd as    necessary.  Returns the number of characters read (not including the    null terminator), or -1 on error or EOF.    This function comes from sed (and is supposed to be a portable version    of getline).  */
end_comment

begin_function
specifier|static
name|long
name|TB_getline
parameter_list|(
name|char
modifier|*
modifier|*
name|lineptr
parameter_list|,
name|long
modifier|*
name|n
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|long
name|size
decl_stmt|,
name|copy
decl_stmt|;
if|if
condition|(
name|lineptr
operator|==
name|NULL
operator|||
name|n
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Make sure we have a line buffer to start with.  */
if|if
condition|(
operator|*
name|lineptr
operator|==
name|NULL
operator|||
operator|*
name|n
operator|<
literal|2
condition|)
comment|/* !seen and no buf yet need 2 chars.  */
block|{
ifndef|#
directive|ifndef
name|MAX_CANON
define|#
directive|define
name|MAX_CANON
value|256
endif|#
directive|endif
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|lineptr
argument_list|,
name|MAX_CANON
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|lineptr
operator|=
name|line
expr_stmt|;
operator|*
name|n
operator|=
name|MAX_CANON
expr_stmt|;
block|}
name|line
operator|=
operator|*
name|lineptr
expr_stmt|;
name|size
operator|=
operator|*
name|n
expr_stmt|;
name|copy
operator|=
name|size
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|long
name|len
decl_stmt|;
while|while
condition|(
operator|--
name|copy
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|lose
goto|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|c
operator|)
operator|==
literal|'\n'
condition|)
goto|goto
name|win
goto|;
block|}
comment|/* Need to enlarge the line buffer.  */
name|len
operator|=
name|p
operator|-
name|line
expr_stmt|;
name|size
operator|*=
literal|2
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
goto|goto
name|lose
goto|;
operator|*
name|lineptr
operator|=
name|line
expr_stmt|;
operator|*
name|n
operator|=
name|size
expr_stmt|;
name|p
operator|=
name|line
operator|+
name|len
expr_stmt|;
name|copy
operator|=
name|size
operator|-
name|len
expr_stmt|;
block|}
name|lose
label|:
if|if
condition|(
name|p
operator|==
operator|*
name|lineptr
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Return a partial line since we got an error in the middle.  */
name|win
label|:
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
if|if
condition|(
name|p
operator|-
literal|2
operator|>=
operator|*
name|lineptr
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
name|p
index|[
operator|-
literal|2
index|]
operator|=
name|p
index|[
operator|-
literal|1
index|]
operator|,
operator|--
name|p
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|-
operator|*
name|lineptr
return|;
block|}
end_function

end_unit

