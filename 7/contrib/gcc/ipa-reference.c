begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Callgraph based analysis of static variables.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.    Contributed by Kenneth Zadeck<zadeck@naturalbridge.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   */
end_comment

begin_comment
comment|/* This file gathers information about how variables whose scope is    confined to the compilation unit are used.       There are two categories of information produced by this pass:     1) The addressable (TREE_ADDRESSABLE) bit and readonly    (TREE_READONLY) bit associated with these variables is properly set    based on scanning all of the code withing the compilation unit.     2) The transitive call site specific clobber effects are computed    for the variables whose scope is contained within this compilation    unit.     First each function and static variable initialization is analyzed    to determine which local static variables are either read, written,    or have their address taken.  Any local static that has its address    taken is removed from consideration.  Once the local read and    writes are determined, a transitive closure of this information is    performed over the call graph to determine the worst case set of    side effects of each call.  In later parts of the compiler, these    local and global sets are examined to make the call clobbering less    traumatic, promote some statics to registers, and improve aliasing    information.        Currently must be run after inlining decisions have been made since    otherwise, the local sets will not contain information that is    consistent with post inlined state.  The global sets are not prone    to this problem since they are by definition transitive.   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"ipa-utils.h"
end_include

begin_include
include|#
directive|include
file|"ipa-reference.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* This splay tree contains all of the static variables that are    being considered by the compilation level alias analysis.  For    module_at_a_time compilation, this is the set of static but not    public variables.  Any variables that either have their address    taken or participate in otherwise unsavory operations are deleted    from this list.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param1_is(int), param2_is(tree))
argument_list|)
name|splay_tree
name|reference_vars_to_consider
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This bitmap is used to knock out the module static variables whose    addresses have been taken and passed around.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|module_statics_escape
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This bitmap is used to knock out the module static variables that    are not readonly.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|module_statics_written
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bit is set for every module static we are considering.  This is    ored into the local info when asm code is found that clobbers all    memory. */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|all_module_statics
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pointer_set_t
modifier|*
name|visited_nodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|ipa_obstack
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|initialization_status_t
block|{
name|UNINITIALIZED
block|,
name|RUNNING
block|,
name|FINISHED
block|}
enum|;
end_enum

begin_decl_stmt
name|tree
name|memory_identifier_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the ipa_reference_vars structure starting from the cgraph NODE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ipa_reference_vars_info_t
name|get_reference_vars_info_from_cgraph
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
return|return
name|get_function_ann
argument_list|(
name|node
operator|->
name|decl
argument_list|)
operator|->
name|reference_vars_info
return|;
block|}
end_function

begin_comment
comment|/* Get a bitmap that contains all of the locally referenced static    variables for function FN.  */
end_comment

begin_function
specifier|static
name|ipa_reference_local_vars_info_t
name|get_local_reference_vars_info
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_vars_info_t
name|info
init|=
name|get_function_ann
argument_list|(
name|fn
argument_list|)
operator|->
name|reference_vars_info
decl_stmt|;
if|if
condition|(
name|info
condition|)
return|return
name|info
operator|->
name|local
return|;
else|else
comment|/* This phase was not run.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Get a bitmap that contains all of the globally referenced static    variables for function FN.  */
end_comment

begin_function
specifier|static
name|ipa_reference_global_vars_info_t
name|get_global_reference_vars_info
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_vars_info_t
name|info
init|=
name|get_function_ann
argument_list|(
name|fn
argument_list|)
operator|->
name|reference_vars_info
decl_stmt|;
if|if
condition|(
name|info
condition|)
return|return
name|info
operator|->
name|global
return|;
else|else
comment|/* This phase was not run.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmap indexed by VAR_DECL uid for the static variables    that may be read locally by the execution of the function fn.    Returns NULL if no data is available.  */
end_comment

begin_function
name|bitmap
name|ipa_reference_get_read_local
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_local_vars_info_t
name|l
init|=
name|get_local_reference_vars_info
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
condition|)
return|return
name|l
operator|->
name|statics_read
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmap indexed by VAR_DECL uid for the static variables    that may be written locally by the execution of the function fn.    Returns NULL if no data is available.  */
end_comment

begin_function
name|bitmap
name|ipa_reference_get_written_local
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_local_vars_info_t
name|l
init|=
name|get_local_reference_vars_info
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
condition|)
return|return
name|l
operator|->
name|statics_written
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmap indexed by VAR_DECL uid for the static variables    that are read during the execution of the function FN.  Returns    NULL if no data is available.  */
end_comment

begin_function
name|bitmap
name|ipa_reference_get_read_global
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_global_vars_info_t
name|g
init|=
name|get_global_reference_vars_info
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
condition|)
return|return
name|g
operator|->
name|statics_read
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmap indexed by VAR_DECL uid for the static variables    that are written during the execution of the function FN.  Note    that variables written may or may not be read during the function    call.  Returns NULL if no data is available.  */
end_comment

begin_function
name|bitmap
name|ipa_reference_get_written_global
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_global_vars_info_t
name|g
init|=
name|get_global_reference_vars_info
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
condition|)
return|return
name|g
operator|->
name|statics_written
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmap indexed by_DECL_UID uid for the static variables    that are not read during the execution of the function FN.  Returns    NULL if no data is available.  */
end_comment

begin_function
name|bitmap
name|ipa_reference_get_not_read_global
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_global_vars_info_t
name|g
init|=
name|get_global_reference_vars_info
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
condition|)
return|return
name|g
operator|->
name|statics_not_read
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmap indexed by DECL_UID uid for the static variables    that are not written during the execution of the function FN.  Note    that variables written may or may not be read during the function    call.  Returns NULL if no data is available.  */
end_comment

begin_function
name|bitmap
name|ipa_reference_get_not_written_global
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|ipa_reference_global_vars_info_t
name|g
init|=
name|get_global_reference_vars_info
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
condition|)
return|return
name|g
operator|->
name|statics_not_written
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add VAR to all_module_statics and the two    reference_vars_to_consider* sets.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_static_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|int
name|uid
init|=
name|DECL_UID
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|all_module_statics
argument_list|,
name|uid
argument_list|)
condition|)
block|{
name|splay_tree_insert
argument_list|(
name|reference_vars_to_consider
argument_list|,
name|uid
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|var
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|all_module_statics
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the variable T is the right kind of static variable to    perform compilation unit scope escape analysis.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|has_proper_scope_for_analysis
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* If the variable has the "used" attribute, treat it as if it had a      been touched by the devil.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Do not want to do anything with volatile except mark any      function that uses one to be not const or pure.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Do not care about a local automatic that is not static.  */
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* This is a variable we care about.  Check if we have seen it      before, and if not add it the set of variables we care about.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|all_module_statics
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|add_static_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If T is a VAR_DECL for a static that we are interested in, add the    uid to the bitmap.  */
end_comment

begin_function
specifier|static
name|void
name|check_operand
parameter_list|(
name|ipa_reference_local_vars_info_t
name|local
parameter_list|,
name|tree
name|t
parameter_list|,
name|bool
name|checking_write
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|(
name|has_proper_scope_for_analysis
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|checking_write
condition|)
block|{
if|if
condition|(
name|local
condition|)
name|bitmap_set_bit
argument_list|(
name|local
operator|->
name|statics_written
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the write so we can tell which statics are 	     readonly.  */
name|bitmap_set_bit
argument_list|(
name|module_statics_written
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local
condition|)
name|bitmap_set_bit
argument_list|(
name|local
operator|->
name|statics_read
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Examine tree T for references to static variables. All internal    references like array references or indirect references are added    to the READ_BM. Direct references are added to either READ_BM or    WRITE_BM depending on the value of CHECKING_WRITE.   */
end_comment

begin_function
specifier|static
name|void
name|check_tree
parameter_list|(
name|ipa_reference_local_vars_info_t
name|local
parameter_list|,
name|tree
name|t
parameter_list|,
name|bool
name|checking_write
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|EXC_PTR_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FILTER_EXPR
operator|)
condition|)
return|return;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|||
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|check_operand
argument_list|(
name|local
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The bottom of an indirect reference can only be read, not      written.  So just recurse and whatever we find, check it against      the read bitmaps.  */
comment|/*  if (INDIRECT_REF_P (t) || TREE_CODE (t) == MEM_REF) */
comment|/* FIXME when we have array_ref's of pointers.  */
if|if
condition|(
name|INDIRECT_REF_P
argument_list|(
name|t
argument_list|)
condition|)
name|check_tree
argument_list|(
name|local
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|t
argument_list|)
condition|)
name|check_operand
argument_list|(
name|local
argument_list|,
name|t
argument_list|,
name|checking_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan tree T to see if there are any addresses taken in within T.  */
end_comment

begin_function
specifier|static
name|void
name|look_for_address_of
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|x
init|=
name|get_base_var
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|has_proper_scope_for_analysis
argument_list|(
name|x
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|module_statics_escape
argument_list|,
name|DECL_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check to see if T is a read or address of operation on a static var    we are interested in analyzing.  LOCAL is passed in to get access    to its bit vectors.  Local is NULL if this is called from a static    initializer.  */
end_comment

begin_function
specifier|static
name|void
name|check_rhs_var
parameter_list|(
name|ipa_reference_local_vars_info_t
name|local
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|look_for_address_of
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|==
name|NULL
condition|)
return|return;
name|check_tree
argument_list|(
name|local
argument_list|,
name|t
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see if T is an assignment to a static var we are    interested in analyzing.  LOCAL is passed in to get access to its bit    vectors.  */
end_comment

begin_function
specifier|static
name|void
name|check_lhs_var
parameter_list|(
name|ipa_reference_local_vars_info_t
name|local
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|local
operator|==
name|NULL
condition|)
return|return;
name|check_tree
argument_list|(
name|local
argument_list|,
name|t
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a scaled down version of get_asm_expr_operands from    tree_ssa_operands.c.  The version there runs much later and assumes    that aliasing information is already available. Here we are just    trying to find if the set of inputs and outputs contain references    or address of operations to local static variables.  FN is the    function being analyzed and STMT is the actual asm statement.  */
end_comment

begin_function
specifier|static
name|void
name|get_asm_expr_operands
parameter_list|(
name|ipa_reference_local_vars_info_t
name|local
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|noutputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|link
operator|=
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
expr_stmt|;
name|check_lhs_var
argument_list|(
name|local
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|ASM_CLOBBERS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|memory_identifier_string
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Abandon all hope, ye who enter here. */
name|local
operator|->
name|calls_read_all
operator|=
name|true
expr_stmt|;
name|local
operator|->
name|calls_write_all
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check the parameters of a function call from CALLER to CALL_EXPR to    see if any of them are static vars.  Also check to see if this is    either an indirect call, a call outside the compilation unit, or    has special attributes that effect the clobbers.  The caller    parameter is the tree node for the caller and the second operand is    the tree node for the entire call expression.  */
end_comment

begin_function
specifier|static
name|void
name|check_call
parameter_list|(
name|ipa_reference_local_vars_info_t
name|local
parameter_list|,
name|tree
name|call_expr
parameter_list|)
block|{
name|int
name|flags
init|=
name|call_expr_flags
argument_list|(
name|call_expr
argument_list|)
decl_stmt|;
name|tree
name|operand_list
init|=
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|operand
decl_stmt|;
name|tree
name|callee_t
init|=
name|get_callee_fndecl
argument_list|(
name|call_expr
argument_list|)
decl_stmt|;
name|enum
name|availability
name|avail
init|=
name|AVAIL_NOT_AVAILABLE
decl_stmt|;
for|for
control|(
name|operand
operator|=
name|operand_list
init|;
name|operand
operator|!=
name|NULL_TREE
condition|;
name|operand
operator|=
name|TREE_CHAIN
argument_list|(
name|operand
argument_list|)
control|)
block|{
name|tree
name|argument
init|=
name|TREE_VALUE
argument_list|(
name|operand
argument_list|)
decl_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callee_t
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|callee
init|=
name|cgraph_node
argument_list|(
name|callee_t
argument_list|)
decl_stmt|;
name|avail
operator|=
name|cgraph_function_body_availability
argument_list|(
name|callee
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|avail
operator|==
name|AVAIL_NOT_AVAILABLE
operator|||
name|avail
operator|==
name|AVAIL_OVERWRITABLE
condition|)
if|if
condition|(
name|local
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ECF_PURE
condition|)
name|local
operator|->
name|calls_read_all
operator|=
name|true
expr_stmt|;
else|else
block|{
name|local
operator|->
name|calls_read_all
operator|=
name|true
expr_stmt|;
name|local
operator|->
name|calls_write_all
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* TP is the part of the tree currently under the microscope.    WALK_SUBTREES is part of the walk_tree api but is unused here.    DATA is cgraph_node of the function being walked.  */
end_comment

begin_comment
comment|/* FIXME: When this is converted to run over SSA form, this code    should be converted to use the operand scanner.  */
end_comment

begin_function
specifier|static
name|tree
name|scan_for_static_refs
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|fn
init|=
name|data
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|local
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|local
operator|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|fn
argument_list|)
operator|->
name|local
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|scan_for_static_refs
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
block|{
comment|/* First look on the lhs and see what variable is stored to */
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|check_lhs_var
argument_list|(
name|local
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
comment|/* For the purposes of figuring out what the cast affects */
comment|/* Next check the operands on the rhs to see if they are ok. */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tcc_unary
case|:
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tcc_reference
case|:
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_declaration
case|:
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|check_call
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* This case is here to find addresses on rhs of constructors in 	 decl_initial of static variables. */
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Target of long jump. */
name|local
operator|->
name|calls_read_all
operator|=
name|true
expr_stmt|;
name|local
operator|->
name|calls_write_all
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
name|check_call
argument_list|(
name|local
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|get_asm_expr_operands
argument_list|(
name|local
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Lookup the tree node for the static variable that has UID.  */
end_comment

begin_function
specifier|static
name|tree
name|get_static_decl
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|splay_tree_node
name|stn
init|=
name|splay_tree_lookup
argument_list|(
name|reference_vars_to_consider
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|stn
condition|)
return|return
operator|(
name|tree
operator|)
name|stn
operator|->
name|value
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Lookup the tree node for the static variable that has UID and    convert the name to a string for debugging.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_static_name
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|splay_tree_node
name|stn
init|=
name|splay_tree_lookup
argument_list|(
name|reference_vars_to_consider
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|stn
condition|)
return|return
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
call|(
name|tree
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|,
literal|2
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Or in all of the bits from every callee into X, the caller's, bit    vector.  There are several cases to check to avoid the sparse    bitmap oring.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_bits
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|x
parameter_list|)
block|{
name|ipa_reference_vars_info_t
name|x_info
init|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|ipa_reference_global_vars_info_t
name|x_global
init|=
name|x_info
operator|->
name|global
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|x
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
name|struct
name|cgraph_node
modifier|*
name|y
init|=
name|e
operator|->
name|callee
decl_stmt|;
comment|/* Only look at the master nodes and skip external nodes.  */
name|y
operator|=
name|cgraph_master_clone
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
condition|)
block|{
if|if
condition|(
name|get_reference_vars_info_from_cgraph
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|ipa_reference_vars_info_t
name|y_info
init|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|ipa_reference_global_vars_info_t
name|y_global
init|=
name|y_info
operator|->
name|global
decl_stmt|;
if|if
condition|(
name|x_global
operator|->
name|statics_read
operator|!=
name|all_module_statics
condition|)
block|{
if|if
condition|(
name|y_global
operator|->
name|statics_read
operator|==
name|all_module_statics
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|x_global
operator|->
name|statics_read
argument_list|)
expr_stmt|;
name|x_global
operator|->
name|statics_read
operator|=
name|all_module_statics
expr_stmt|;
block|}
comment|/* Skip bitmaps that are pointer equal to node's bitmap 		     (no reason to spin within the cycle).  */
elseif|else
if|if
condition|(
name|x_global
operator|->
name|statics_read
operator|!=
name|y_global
operator|->
name|statics_read
condition|)
name|bitmap_ior_into
argument_list|(
name|x_global
operator|->
name|statics_read
argument_list|,
name|y_global
operator|->
name|statics_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_global
operator|->
name|statics_written
operator|!=
name|all_module_statics
condition|)
block|{
if|if
condition|(
name|y_global
operator|->
name|statics_written
operator|==
name|all_module_statics
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|x_global
operator|->
name|statics_written
argument_list|)
expr_stmt|;
name|x_global
operator|->
name|statics_written
operator|=
name|all_module_statics
expr_stmt|;
block|}
comment|/* Skip bitmaps that are pointer equal to node's bitmap 		     (no reason to spin within the cycle).  */
elseif|else
if|if
condition|(
name|x_global
operator|->
name|statics_written
operator|!=
name|y_global
operator|->
name|statics_written
condition|)
name|bitmap_ior_into
argument_list|(
name|x_global
operator|->
name|statics_written
argument_list|,
name|y_global
operator|->
name|statics_written
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look at all of the callees of X to see which ones represent inlined    calls.  For each of these callees, merge their local info into    TARGET and check their children recursively.       This function goes away when Jan changes the inliner and IPA    analysis so that this is not run between the time when inlining    decisions are made and when the inlining actually occurs.  */
end_comment

begin_function
specifier|static
name|void
name|merge_callee_local_info
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|target
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|x_l
init|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|target
argument_list|)
operator|->
name|local
decl_stmt|;
comment|/* Make the world safe for tail recursion.  */
name|struct
name|ipa_dfs_info
modifier|*
name|node_info
init|=
name|x
operator|->
name|aux
decl_stmt|;
if|if
condition|(
name|node_info
operator|->
name|aux
condition|)
return|return;
name|node_info
operator|->
name|aux
operator|=
name|x
expr_stmt|;
for|for
control|(
name|e
operator|=
name|x
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
name|struct
name|cgraph_node
modifier|*
name|y
init|=
name|e
operator|->
name|callee
decl_stmt|;
if|if
condition|(
name|y
operator|->
name|global
operator|.
name|inlined_to
condition|)
block|{
name|ipa_reference_vars_info_t
name|y_info
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|y_l
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|orig_y
init|=
name|y
decl_stmt|;
name|y
operator|=
name|cgraph_master_clone
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
condition|)
block|{
name|y_info
operator|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|y_l
operator|=
name|y_info
operator|->
name|local
expr_stmt|;
if|if
condition|(
name|x_l
operator|!=
name|y_l
condition|)
block|{
name|bitmap_ior_into
argument_list|(
name|x_l
operator|->
name|statics_read
argument_list|,
name|y_l
operator|->
name|statics_read
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|x_l
operator|->
name|statics_written
argument_list|,
name|y_l
operator|->
name|statics_written
argument_list|)
expr_stmt|;
block|}
name|x_l
operator|->
name|calls_read_all
operator||=
name|y_l
operator|->
name|calls_read_all
expr_stmt|;
name|x_l
operator|->
name|calls_write_all
operator||=
name|y_l
operator|->
name|calls_write_all
expr_stmt|;
name|merge_callee_local_info
argument_list|(
name|target
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"suspect inlining of "
argument_list|)
expr_stmt|;
name|dump_cgraph_node
argument_list|(
name|stderr
argument_list|,
name|orig_y
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninto "
argument_list|)
expr_stmt|;
name|dump_cgraph_node
argument_list|(
name|stderr
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|node_info
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The init routine for analyzing global static variable usage.  See    comments at top for description.  */
end_comment

begin_function
specifier|static
name|void
name|ipa_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|memory_identifier_string
operator|=
name|build_string
argument_list|(
literal|7
argument_list|,
literal|"memory"
argument_list|)
expr_stmt|;
name|reference_vars_to_consider
operator|=
name|splay_tree_new_ggc
argument_list|(
name|splay_tree_compare_ints
argument_list|)
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|module_statics_escape
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|module_statics_written
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|all_module_statics
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
comment|/* This will add NODE->DECL to the splay trees.  */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|has_proper_scope_for_analysis
argument_list|(
name|node
operator|->
name|decl
argument_list|)
expr_stmt|;
comment|/* There are some shared nodes, in particular the initializers on      static declarations.  We do not need to scan them more than once      since all we would be interested in are the addressof      operations.  */
name|visited_nodes
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check out the rhs of a static or global initialization VNODE to see    if any of them contain addressof operations.  Note that some of    these variables may  not even be referenced in the code in this    compilation unit but their right hand sides may contain references    to variables defined within this unit.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_variable
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
parameter_list|)
block|{
name|tree
name|global
init|=
name|vnode
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|global
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|global
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|global
argument_list|)
argument_list|,
name|scan_for_static_refs
argument_list|,
name|NULL
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the main routine for finding the reference patterns for    global variables within a function FN.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|fn
parameter_list|)
block|{
name|ipa_reference_vars_info_t
name|info
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipa_reference_vars_info_d
argument_list|)
argument_list|)
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|l
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipa_reference_local_vars_info_d
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|fn
operator|->
name|decl
decl_stmt|;
comment|/* Add the info to the tree's annotation.  */
name|get_function_ann
argument_list|(
name|fn
operator|->
name|decl
argument_list|)
operator|->
name|reference_vars_info
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|local
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|statics_read
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|l
operator|->
name|statics_written
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n local analysis of %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|struct
name|function
modifier|*
name|this_cfun
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|basic_block
name|this_block
decl_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|this_block
argument_list|,
argument|this_cfun
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|this_block
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|scan_for_static_refs
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There may be const decls with interesting right hand sides.  */
if|if
condition|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|step
decl_stmt|;
for|for
control|(
name|step
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
operator|->
name|unexpanded_var_list
init|;
name|step
condition|;
name|step
operator|=
name|TREE_CHAIN
argument_list|(
name|step
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
name|step
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
argument_list|,
name|scan_for_static_refs
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If FN is avail == AVAIL_OVERWRITABLE, replace the effects bit    vectors with worst case bit vectors.  We had to analyze it above to    find out if it took the address of any statics. However, now that    we know that, we can get rid of all of the other side effects.  */
end_comment

begin_function
specifier|static
name|void
name|clean_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|fn
parameter_list|)
block|{
name|ipa_reference_vars_info_t
name|info
init|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|l
init|=
name|info
operator|->
name|local
decl_stmt|;
name|ipa_reference_global_vars_info_t
name|g
init|=
name|info
operator|->
name|global
decl_stmt|;
if|if
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|statics_read
operator|&&
name|l
operator|->
name|statics_read
operator|!=
name|all_module_statics
condition|)
name|BITMAP_FREE
argument_list|(
name|l
operator|->
name|statics_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|statics_written
operator|&&
name|l
operator|->
name|statics_written
operator|!=
name|all_module_statics
condition|)
name|BITMAP_FREE
argument_list|(
name|l
operator|->
name|statics_written
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|statics_read
operator|&&
name|g
operator|->
name|statics_read
operator|!=
name|all_module_statics
condition|)
name|BITMAP_FREE
argument_list|(
name|g
operator|->
name|statics_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|statics_written
operator|&&
name|g
operator|->
name|statics_written
operator|!=
name|all_module_statics
condition|)
name|BITMAP_FREE
argument_list|(
name|g
operator|->
name|statics_written
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|statics_not_read
operator|&&
name|g
operator|->
name|statics_not_read
operator|!=
name|all_module_statics
condition|)
name|BITMAP_FREE
argument_list|(
name|g
operator|->
name|statics_not_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|statics_not_written
operator|&&
name|g
operator|->
name|statics_not_written
operator|!=
name|all_module_statics
condition|)
name|BITMAP_FREE
argument_list|(
name|g
operator|->
name|statics_not_written
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|get_function_ann
argument_list|(
name|fn
operator|->
name|decl
argument_list|)
operator|->
name|reference_vars_info
argument_list|)
expr_stmt|;
name|get_function_ann
argument_list|(
name|fn
operator|->
name|decl
argument_list|)
operator|->
name|reference_vars_info
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Produce the global information by preforming a transitive closure    on the local information that was produced by ipa_analyze_function    and ipa_analyze_variable.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|static_execute
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|w
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
init|=
name|xcalloc
argument_list|(
name|cgraph_n_nodes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|order_pos
init|=
name|order_pos
operator|=
name|ipa_utils_reduced_inorder
argument_list|(
name|order
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ipa_init
argument_list|()
expr_stmt|;
comment|/* Process all of the variables first.  */
for|for
control|(
name|vnode
operator|=
name|cgraph_varpool_nodes_queue
init|;
name|vnode
condition|;
name|vnode
operator|=
name|vnode
operator|->
name|next_needed
control|)
name|analyze_variable
argument_list|(
name|vnode
argument_list|)
expr_stmt|;
comment|/* Process all of the functions next.        We do not want to process any of the clones so we check that this      is a master clone.  However, we do need to process any      AVAIL_OVERWRITABLE functions (these are never clones) because      they may cause a static variable to escape.  The code that can      overwrite such a function cannot access the statics because it      would not be in the same compilation unit.  When the analysis is      finished, the computed information of these AVAIL_OVERWRITABLE is      replaced with worst case info.     */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
operator|(
name|cgraph_is_master_clone
argument_list|(
name|node
argument_list|)
operator|||
operator|(
name|cgraph_function_body_availability
argument_list|(
name|node
argument_list|)
operator|==
name|AVAIL_OVERWRITABLE
operator|)
operator|)
condition|)
name|analyze_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_cgraph
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
comment|/* Prune out the variables that were found to behave badly      (i.e. have their address taken).  */
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap
name|module_statics_readonly
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
decl_stmt|;
name|bitmap
name|module_statics_const
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
decl_stmt|;
name|bitmap
name|bm_temp
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|module_statics_escape
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|splay_tree_remove
argument_list|(
name|reference_vars_to_consider
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|bitmap_and_compl_into
argument_list|(
name|all_module_statics
argument_list|,
name|module_statics_escape
argument_list|)
expr_stmt|;
name|bitmap_and_compl
argument_list|(
name|module_statics_readonly
argument_list|,
name|all_module_statics
argument_list|,
name|module_statics_written
argument_list|)
expr_stmt|;
comment|/* If the address is not taken, we can unset the addressable bit        on this variable.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_module_statics
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|get_static_decl
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Not TREE_ADDRESSABLE var %s\n"
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the variable is never written, we can set the TREE_READONLY        flag.  Additionally if it has a DECL_INITIAL that is made up of        constants we can treat the entire global as a constant.  */
name|bitmap_and_compl
argument_list|(
name|module_statics_readonly
argument_list|,
name|all_module_statics
argument_list|,
name|module_statics_written
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|module_statics_readonly
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|get_static_decl
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|/* Readonly on a function decl is very different from the 	   variable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
continue|continue;
comment|/* Ignore variables in named sections - changing TREE_READONLY 	   changes the section flags, potentially causing conflicts with 	   other variables in the same named section.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|var
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"read-only var %s\n"
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|module_statics_const
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"read-only constant %s\n"
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|module_statics_escape
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|module_statics_written
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_module_statics
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nPromotable global:%s"
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
block|{
name|ipa_reference_local_vars_info_t
name|l
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|l
operator|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|node
argument_list|)
operator|->
name|local
expr_stmt|;
comment|/* Any variables that are not in all_module_statics are 	   removed from the local maps.  This will include all of the 	   variables that were found to escape in the function 	   scanning.  */
name|bitmap_and_into
argument_list|(
name|l
operator|->
name|statics_read
argument_list|,
name|all_module_statics
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|l
operator|->
name|statics_written
argument_list|,
name|all_module_statics
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|module_statics_readonly
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|module_statics_const
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bm_temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|l
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|l
operator|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|node
argument_list|)
operator|->
name|local
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nFunction name:%s/%i:"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|uid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n  locals read: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|l->statics_read
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n  locals written: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|l->statics_written
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Propagate the local information thru the call graph to produce      the global information.  All the nodes within a cycle will have      the same info so we collapse cycles first.  Then we can do the      propagation in one pass from the leaves to the roots.  */
name|order_pos
operator|=
name|ipa_utils_reduced_inorder
argument_list|(
name|order
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|ipa_utils_print_order
argument_list|(
name|dump_file
argument_list|,
literal|"reduced"
argument_list|,
name|order
argument_list|,
name|order_pos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
block|{
name|ipa_reference_vars_info_t
name|node_info
decl_stmt|;
name|ipa_reference_global_vars_info_t
name|node_g
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipa_reference_global_vars_info_d
argument_list|)
argument_list|)
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|node_l
decl_stmt|;
name|bool
name|read_all
decl_stmt|;
name|bool
name|write_all
decl_stmt|;
name|struct
name|ipa_dfs_info
modifier|*
name|w_info
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|node_info
operator|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node_info
condition|)
block|{
name|dump_cgraph_node
argument_list|(
name|stderr
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|dump_cgraph
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|node_info
operator|->
name|global
operator|=
name|node_g
expr_stmt|;
name|node_l
operator|=
name|node_info
operator|->
name|local
expr_stmt|;
name|read_all
operator|=
name|node_l
operator|->
name|calls_read_all
expr_stmt|;
name|write_all
operator|=
name|node_l
operator|->
name|calls_write_all
expr_stmt|;
comment|/* If any node in a cycle is calls_read_all or calls_write_all 	 they all are. */
name|w_info
operator|=
name|node
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|ipa_reference_local_vars_info_t
name|w_l
init|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|w
argument_list|)
operator|->
name|local
decl_stmt|;
name|read_all
operator||=
name|w_l
operator|->
name|calls_read_all
expr_stmt|;
name|write_all
operator||=
name|w_l
operator|->
name|calls_write_all
expr_stmt|;
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
block|}
comment|/* Initialized the bitmaps for the reduced nodes */
if|if
condition|(
name|read_all
condition|)
name|node_g
operator|->
name|statics_read
operator|=
name|all_module_statics
expr_stmt|;
else|else
block|{
name|node_g
operator|->
name|statics_read
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|node_g
operator|->
name|statics_read
argument_list|,
name|node_l
operator|->
name|statics_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_all
condition|)
name|node_g
operator|->
name|statics_written
operator|=
name|all_module_statics
expr_stmt|;
else|else
block|{
name|node_g
operator|->
name|statics_written
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|node_g
operator|->
name|statics_written
argument_list|,
name|node_l
operator|->
name|statics_written
argument_list|)
expr_stmt|;
block|}
name|w_info
operator|=
name|node
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|ipa_reference_vars_info_t
name|w_ri
init|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|w_l
init|=
name|w_ri
operator|->
name|local
decl_stmt|;
comment|/* All nodes within a cycle share the same global info bitmaps.  */
name|w_ri
operator|->
name|global
operator|=
name|node_g
expr_stmt|;
comment|/* These global bitmaps are initialized from the local info 	     of all of the nodes in the region.  However there is no 	     need to do any work if the bitmaps were set to 	     all_module_statics.  */
if|if
condition|(
operator|!
name|read_all
condition|)
name|bitmap_ior_into
argument_list|(
name|node_g
operator|->
name|statics_read
argument_list|,
name|w_l
operator|->
name|statics_read
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_all
condition|)
name|bitmap_ior_into
argument_list|(
name|node_g
operator|->
name|statics_written
argument_list|,
name|w_l
operator|->
name|statics_written
argument_list|)
expr_stmt|;
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
block|}
name|w
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|propagate_bits
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
block|}
block|}
comment|/* Need to fix up the local information sets.  The information that      has been gathered so far is preinlining.  However, the      compilation will progress post inlining so the local sets for the      inlined calls need to be merged into the callers.  Note that the      local sets are not shared between all of the nodes in a cycle so      those nodes in the cycle must be processed explicitly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ipa_dfs_info
modifier|*
name|w_info
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|merge_callee_local_info
argument_list|(
name|node
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|w_info
operator|=
name|node
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|merge_callee_local_info
argument_list|(
name|w
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
block|{
name|ipa_reference_vars_info_t
name|node_info
decl_stmt|;
name|ipa_reference_global_vars_info_t
name|node_g
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|node_l
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|ipa_dfs_info
modifier|*
name|w_info
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|node_info
operator|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node_g
operator|=
name|node_info
operator|->
name|global
expr_stmt|;
name|node_l
operator|=
name|node_info
operator|->
name|local
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nFunction name:%s/%i:"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|uid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n  locals read: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|node_l->statics_read
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n  locals written: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|node_l->statics_written
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|w_info
operator|=
name|node
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|ipa_reference_vars_info_t
name|w_ri
init|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|ipa_reference_local_vars_info_t
name|w_l
init|=
name|w_ri
operator|->
name|local
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n  next cycle: %s/%i "
argument_list|,
name|cgraph_node_name
argument_list|(
name|w
argument_list|)
argument_list|,
name|w
operator|->
name|uid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n    locals read: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|w_l->statics_read
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n    locals written: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|w_l->statics_written
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n  globals read: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|node_g->statics_read
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n  globals written: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|node_g->statics_written
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s "
argument_list|,
name|get_static_name
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Cleanup. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
block|{
name|ipa_reference_vars_info_t
name|node_info
decl_stmt|;
name|ipa_reference_global_vars_info_t
name|node_g
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|node_info
operator|=
name|get_reference_vars_info_from_cgraph
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node_g
operator|=
name|node_info
operator|->
name|global
expr_stmt|;
comment|/* Create the complimentary sets.  These are more useful for 	 certain apis.  */
name|node_g
operator|->
name|statics_not_read
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|node_g
operator|->
name|statics_not_written
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_g
operator|->
name|statics_read
operator|!=
name|all_module_statics
condition|)
block|{
name|bitmap_and_compl
argument_list|(
name|node_g
operator|->
name|statics_not_read
argument_list|,
name|all_module_statics
argument_list|,
name|node_g
operator|->
name|statics_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node_g
operator|->
name|statics_written
operator|!=
name|all_module_statics
condition|)
name|bitmap_and_compl
argument_list|(
name|node_g
operator|->
name|statics_not_written
argument_list|,
name|all_module_statics
argument_list|,
name|node_g
operator|->
name|statics_written
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|order
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
comment|/* Get rid of the aux information.  */
if|if
condition|(
name|node
operator|->
name|aux
condition|)
block|{
name|free
argument_list|(
name|node
operator|->
name|aux
argument_list|)
expr_stmt|;
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
operator|(
name|cgraph_function_body_availability
argument_list|(
name|node
argument_list|)
operator|==
name|AVAIL_OVERWRITABLE
operator|)
condition|)
name|clean_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_reference
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|flag_unit_at_a_time
operator|!=
literal|0
operator|&&
name|flag_ipa_reference
comment|/* Don't bother doing anything if the program has errors.  */
operator|&&
operator|!
operator|(
name|errorcount
operator|||
name|sorrycount
operator|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ipa_reference
init|=
block|{
literal|"static-var"
block|,
comment|/* name */
name|gate_reference
block|,
comment|/* gate */
name|static_execute
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IPA_REFERENCE
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-ipa-reference.h"
end_include

end_unit

