begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop unswitching.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* This file implements the loop unswitching, i.e. transformation of loops like     while (A)      {        if (inv)          B;         X;         if (!inv) 	 C;      }     where inv is the loop invariant, into     if (inv)      {        while (A) 	 {            B; 	   X; 	 }      }    else      {        while (A) 	 { 	   X; 	   C; 	 }      }     Inv is considered invariant iff the values it compares are both invariant;    tree-ssa-loop-im.c ensures that all the suitable conditions are in this    shape.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|loop
modifier|*
name|tree_unswitch_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tree_unswitch_single_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tree_may_unswitch_on
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */
end_comment

begin_function
name|unsigned
name|int
name|tree_ssa_unswitch_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
comment|/* Go through inner loops (only original ones).  */
name|num
operator|=
name|loops
operator|->
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Removed loop?  */
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
continue|continue;
name|changed
operator||=
name|tree_unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
return|return
name|TODO_cleanup_cfg
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Checks whether we can unswitch LOOP on condition at end of BB -- one of its    basic blocks (for what it means see comments below).  */
end_comment

begin_function
specifier|static
name|tree
name|tree_may_unswitch_on
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|def
decl_stmt|,
name|cond
decl_stmt|,
name|use
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
comment|/* BB must end in a simple conditional jump.  */
name|stmt
operator|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Condition must be invariant.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|def
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|use
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_bb
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|def_bb
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* To keep the things simple, we do not directly remove the conditions,      but just replace tests with 0/1.  Prevent the infinite loop where we      would unswitch again on such a condition.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|cond
argument_list|)
operator|||
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Simplifies COND using checks in front of the entry of the LOOP.  Just very    simplish (sufficient to prevent us from duplicating loop in unswitching    unnecessarily).  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_using_entry_checks
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|cond
parameter_list|)
block|{
name|edge
name|e
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|stmt
operator|=
name|last_stmt
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|?
name|boolean_true_node
else|:
name|boolean_false_node
operator|)
return|;
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|e
operator|->
name|src
argument_list|)
condition|)
return|return
name|cond
return|;
name|e
operator|=
name|single_pred_edge
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|cond
return|;
block|}
block|}
end_function

begin_comment
comment|/* Unswitch single LOOP.  NUM is number of unswitchings done; we do not allow    it to grow too much, it is too easy to create example on that the code would    grow exponentially.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_unswitch_single_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|tree
name|cond
init|=
name|NULL_TREE
decl_stmt|,
name|stmt
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
comment|/* Do not unswitch too much.  */
if|if
condition|(
name|num
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNSWITCH_LEVEL
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching anymore, hit max level\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Only unswitch innermost loops.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching, not innermost loop\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The loop should not be too large, to limit code growth.  */
if|if
condition|(
name|tree_num_loop_insns
argument_list|(
name|loop
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNSWITCH_INSNS
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching, loop too big\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find a bb to unswitch on.  */
for|for
control|(
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|cond
operator|=
name|tree_may_unswitch_on
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|loop
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|loop
operator|->
name|num_nodes
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
name|cond
operator|=
name|simplify_using_entry_checks
argument_list|(
name|loop
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|last_stmt
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
comment|/* Remove false path.  */
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|boolean_true_node
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
comment|/* Remove true path.  */
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|boolean_false_node
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
else|else
break|break;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unswitching loop\n"
argument_list|)
expr_stmt|;
name|initialize_original_copy_tables
argument_list|()
expr_stmt|;
comment|/* Unswitch the loop on this condition.  */
name|nloop
operator|=
name|tree_unswitch_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nloop
condition|)
block|{
name|free_original_copy_tables
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
comment|/* Update the SSA form after unswitching.  */
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
name|free_original_copy_tables
argument_list|()
expr_stmt|;
comment|/* Invoke itself on modified loops.  */
name|tree_unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|nloop
argument_list|,
name|num
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tree_unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|num
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support    unswitching of innermost loops.  COND is the condition determining which    loop is entered -- the new loop is entered if COND is true.  Returns NULL    if impossible, new loop otherwise.  */
end_comment

begin_function
specifier|static
name|struct
name|loop
modifier|*
name|tree_unswitch_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|unswitch_on
parameter_list|,
name|tree
name|cond
parameter_list|)
block|{
name|basic_block
name|condition_bb
decl_stmt|;
comment|/* Some sanity checking.  */
name|gcc_assert
argument_list|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|unswitch_on
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|unswitch_on
operator|->
name|succs
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop
operator|->
name|inner
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|loop_version
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|unshare_expr
argument_list|(
name|cond
argument_list|)
argument_list|,
operator|&
name|condition_bb
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

end_unit

