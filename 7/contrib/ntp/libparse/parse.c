begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp4-dev/libparse/parse.c,v 4.20 2005/08/06 17:39:40 kardel RELEASE_20050806_A  *    * parse.c,v 4.20 2005/08/06 17:39:40 kardel RELEASE_20050806_A  *  * Parser module for reference clock  *  * PARSEKERNEL define switches between two personalities of the module  * if PARSEKERNEL is defined this module can be used  * as kernel module. In this case the time stamps will be  * a struct timeval.  * when PARSEKERNEL is not defined NTP time stamps will be used.  *  * Copyright (c) 1995-2005 by Frank Kardel<kardel<AT> ntp.org>  * Copyright (c) 1989-1994 by Frank Kardel, Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_PARSE
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|lint
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"parse.c,v 4.20 2005/08/06 17:39:40 kardel RELEASE_20050806_A"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_comment
comment|/* (get Y2KFixes definitions) 	Y2KFixes */
end_comment

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PARSESTREAM
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"sys/parsestreams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|clockformat_t
modifier|*
name|clockformats
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|short
name|nformats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|timepacket
name|P
argument_list|(
operator|(
name|parse_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * strings support usually not in kernel - duplicated, but what the heck  */
end_comment

begin_function
specifier|static
name|int
name|Strlen
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
block|{
name|c
operator|++
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|Strcmp
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|t
parameter_list|)
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
operator|||
operator|(
name|s
operator|==
name|t
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|-
operator|*
name|t
operator|++
operator|)
operator|&&
operator|*
name|s
operator|&&
operator|*
name|t
condition|)
comment|/* empty loop */
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|parse_timedout
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|timestamp_t
modifier|*
name|tstamp
parameter_list|,
name|struct
name|timeval
modifier|*
name|del
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|delta
operator|.
name|tv_sec
operator|=
name|tstamp
operator|->
name|tv
operator|.
name|tv_sec
operator|-
name|parseio
operator|->
name|parse_lastchar
operator|.
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|tstamp
operator|->
name|tv
operator|.
name|tv_usec
operator|-
name|parseio
operator|->
name|parse_lastchar
operator|.
name|tv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
else|#
directive|else
specifier|extern
name|long
name|tstouslo
index|[]
decl_stmt|;
specifier|extern
name|long
name|tstousmid
index|[]
decl_stmt|;
specifier|extern
name|long
name|tstoushi
index|[]
decl_stmt|;
name|l_fp
name|delt
decl_stmt|;
name|delt
operator|=
name|tstamp
operator|->
name|fp
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|delt
argument_list|,
operator|&
name|parseio
operator|->
name|parse_lastchar
operator|.
name|fp
argument_list|)
expr_stmt|;
name|TSTOTV
argument_list|(
operator|&
name|delt
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|delta
argument_list|,
name|del
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: timedout: TRUE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: timedout: FALSE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_ioinit
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iostart\n"
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_plen
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_pdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_data
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_ldata
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_dsize
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_badformat
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_ioflags
operator|=
name|PARSE_IO_CS7
expr_stmt|;
comment|/* usual unix default */
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|parse_ioend
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioend\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_pdata
condition|)
name|FREE
argument_list|(
name|parseio
operator|->
name|parse_pdata
argument_list|,
name|parseio
operator|->
name|parse_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseio
operator|->
name|parse_data
condition|)
name|FREE
argument_list|(
name|parseio
operator|->
name|parse_data
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|parseio
operator|->
name|parse_dsize
operator|*
literal|2
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|parse_restart
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|)
block|{
name|unsigned
name|int
name|updated
init|=
name|PARSE_INP_SKIP
decl_stmt|;
comment|/* 	 * re-start packet - timeout - overflow - start symbol 	 */
if|if
condition|(
name|parseio
operator|->
name|parse_index
condition|)
block|{
comment|/* 		 * filled buffer - thus not end character found 		 * do processing now 		 */
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|parseio
operator|->
name|parse_index
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
expr_stmt|;
name|updated
operator|=
name|PARSE_INP_TIME
expr_stmt|;
block|}
name|parseio
operator|->
name|parse_index
operator|=
literal|1
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: parse_restart: buffer start (updated = %x)\n"
operator|,
name|updated
operator|)
argument_list|)
expr_stmt|;
return|return
name|updated
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|parse_addchar
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|,
name|unsigned
name|int
name|ch
parameter_list|)
block|{
comment|/* 	 * add to buffer 	 */
if|if
condition|(
name|parseio
operator|->
name|parse_index
operator|<
name|parseio
operator|->
name|parse_dsize
condition|)
block|{
comment|/* 		 * collect into buffer 		 */
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: parse_addchar: buffer[%d] = 0x%x\n"
operator|,
name|parseio
operator|->
name|parse_index
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
operator|++
index|]
operator|=
name|ch
expr_stmt|;
return|return
name|PARSE_INP_SKIP
return|;
block|}
else|else
comment|/* 		 * buffer overflow - attempt to make the best of it 		 */
return|return
name|parse_restart
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|parse_end
parameter_list|(
name|parse_t
modifier|*
name|parseio
parameter_list|)
block|{
comment|/* 	 * message complete processing 	 */
name|parseio
operator|->
name|parse_data
index|[
name|parseio
operator|->
name|parse_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_data
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|parseio
operator|->
name|parse_index
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_ldsize
operator|=
name|parseio
operator|->
name|parse_index
expr_stmt|;
name|parseio
operator|->
name|parse_index
operator|=
literal|0
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse: parse_end: buffer end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PARSE_INP_TIME
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_ioread
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|unsigned
name|int
name|ch
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|tstamp
parameter_list|)
block|{
specifier|register
name|unsigned
name|updated
init|=
name|CVT_NONE
decl_stmt|;
comment|/* 	 * within STREAMS CSx (x< 8) chars still have the upper bits set 	 * so we normalize the characters by masking unecessary bits off. 	 */
switch|switch
condition|(
name|parseio
operator|->
name|parse_ioflags
operator|&
name|PARSE_IO_CSIZE
condition|)
block|{
case|case
name|PARSE_IO_CS5
case|:
name|ch
operator|&=
literal|0x1F
expr_stmt|;
break|break;
case|case
name|PARSE_IO_CS6
case|:
name|ch
operator|&=
literal|0x3F
expr_stmt|;
break|break;
case|case
name|PARSE_IO_CS7
case|:
name|ch
operator|&=
literal|0x7F
expr_stmt|;
break|break;
case|case
name|PARSE_IO_CS8
case|:
name|ch
operator|&=
literal|0xFF
expr_stmt|;
break|break;
block|}
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread(0x%lx, char=0x%x, ..., ...)\n"
operator|,
operator|(
name|unsigned
name|long
operator|)
name|parseio
operator|,
name|ch
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|convert
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread: input dropped.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
if|if
condition|(
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|input
condition|)
block|{
name|unsigned
name|long
name|input_status
decl_stmt|;
name|input_status
operator|=
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|input
argument_list|(
name|parseio
argument_list|,
name|ch
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_status
operator|&
name|PARSE_INP_SYNTH
condition|)
block|{
name|updated
operator|=
name|CVT_OK
expr_stmt|;
block|}
if|if
condition|(
name|input_status
operator|&
name|PARSE_INP_TIME
condition|)
comment|/* time sample is available */
block|{
name|updated
operator|=
name|timepacket
argument_list|(
name|parseio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_status
operator|&
name|PARSE_INP_DATA
condition|)
comment|/* got additional data */
block|{
name|updated
operator||=
name|CVT_ADDITIONAL
expr_stmt|;
block|}
block|}
comment|/* 	 * remember last character time 	 */
name|parseio
operator|->
name|parse_lastchar
operator|=
operator|*
name|tstamp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|updated
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_NONE
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_ioread: time sample accumulated (status=0x%x)\n"
operator|,
name|updated
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_status
operator|=
name|updated
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|updated
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_NONE
operator|)
operator|||
operator|(
operator|(
name|updated
operator|&
name|CVT_ADDITIONAL
operator|)
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * parse_iopps  *  * take status line indication and derive synchronisation information  * from it.  * It can also be used to decode a serial serial data format (such as the  * ONE, ZERO, MINUTE sync data stream from DCF77)  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_iopps
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|int
name|status
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
specifier|register
name|unsigned
name|updated
init|=
name|CVT_NONE
decl_stmt|;
comment|/* 	 * PPS pulse information will only be delivered to ONE clock format 	 * this is either the last successful conversion module with a ppssync 	 * routine, or a fixed format with a ppssync routine 	 */
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iopps: STATUS %s\n"
operator|,
operator|(
name|status
operator|==
name|SYNC_ONE
operator|)
condition|?
literal|"ONE"
else|:
literal|"ZERO"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|syncpps
condition|)
block|{
name|updated
operator|=
name|clockformats
index|[
name|parseio
operator|->
name|parse_lformat
index|]
operator|->
name|syncpps
argument_list|(
name|parseio
argument_list|,
name|status
operator|==
name|SYNC_ONE
argument_list|,
name|ptime
argument_list|)
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iopps: updated = 0x%x\n"
operator|,
name|updated
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|updated
operator|&
name|CVT_MASK
operator|)
operator|!=
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * parse_iodone  *  * clean up internal status for new round  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|parse_iodone
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|)
block|{
comment|/* 	 * we need to clean up certain flags for the next round 	 */
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"parse_iodone: DONE\n"
operator|)
argument_list|)
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator|=
literal|0
expr_stmt|;
comment|/* no problems with ISRs */
block|}
end_function

begin_comment
comment|/*---------- conversion implementation --------------------*/
end_comment

begin_comment
comment|/*  * convert a struct clock to UTC since Jan, 1st 1970 0:00 (the UNIX EPOCH)  */
end_comment

begin_define
define|#
directive|define
name|days_per_year
parameter_list|(
name|x
parameter_list|)
value|((x) % 4 ? 365 : ((x % 400) ? ((x % 100) ? 366 : 365) : 366))
end_define

begin_function
name|time_t
name|parse_to_unixtime
parameter_list|(
specifier|register
name|clocktime_t
modifier|*
name|clock_time
parameter_list|,
specifier|register
name|u_long
modifier|*
name|cvtrtc
parameter_list|)
block|{
define|#
directive|define
name|SETRTC
parameter_list|(
name|_X_
parameter_list|)
value|{ if (cvtrtc) *cvtrtc = (_X_); }
specifier|static
name|int
name|days_of_month
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|clock_time
operator|->
name|utctime
condition|)
return|return
name|clock_time
operator|->
name|utctime
return|;
comment|/* if the conversion routine gets it right away - why not */
if|if
condition|(
name|clock_time
operator|->
name|year
operator|<
name|YEAR_PIVOT
condition|)
comment|/* Y2KFixes [ */
name|clock_time
operator|->
name|year
operator|+=
literal|100
expr_stmt|;
comment|/* convert 20xx%100 to 20xx-1900 */
if|if
condition|(
name|clock_time
operator|->
name|year
operator|<
name|YEAR_BREAK
condition|)
comment|/* expand to full four-digits */
name|clock_time
operator|->
name|year
operator|+=
literal|1900
expr_stmt|;
if|if
condition|(
name|clock_time
operator|->
name|year
operator|<
literal|1970
condition|)
comment|/* Y2KFixes ] */
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * sorry, slow section here - but it's not time critical anyway 	 */
name|t
operator|=
name|julian0
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
operator|-
name|julian0
argument_list|(
literal|1970
argument_list|)
expr_stmt|;
comment|/* Y2kFixes */
comment|/* month */
if|if
condition|(
name|clock_time
operator|->
name|month
operator|<=
literal|0
operator|||
name|clock_time
operator|->
name|month
operator|>
literal|12
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad month */
block|}
if|#
directive|if
literal|0
comment|/* Y2KFixes */
comment|/* adjust leap year */
block|if (clock_time->month< 3&& days_per_year(clock_time->year) == 366) 	    t--;
else|#
directive|else
comment|/* Y2KFixes [ */
if|if
condition|(
name|clock_time
operator|->
name|month
operator|>=
literal|3
operator|&&
name|isleap_4
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
comment|/* add one more if within leap year */
endif|#
directive|endif
comment|/* Y2KFixes ] */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|clock_time
operator|->
name|month
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|+=
name|days_of_month
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* day */
if|if
condition|(
name|clock_time
operator|->
name|day
operator|<
literal|1
operator|||
operator|(
operator|(
name|clock_time
operator|->
name|month
operator|==
literal|2
operator|&&
name|days_per_year
argument_list|(
name|clock_time
operator|->
name|year
argument_list|)
operator|==
literal|366
operator|)
condition|?
name|clock_time
operator|->
name|day
operator|>
literal|29
else|:
name|clock_time
operator|->
name|day
operator|>
name|days_of_month
index|[
name|clock_time
operator|->
name|month
index|]
operator|)
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADDATE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad day */
block|}
name|t
operator|+=
name|clock_time
operator|->
name|day
operator|-
literal|1
expr_stmt|;
comment|/* hour */
if|if
condition|(
name|clock_time
operator|->
name|hour
operator|<
literal|0
operator|||
name|clock_time
operator|->
name|hour
operator|>=
literal|24
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad hour */
block|}
name|t
operator|=
name|TIMES24
argument_list|(
name|t
argument_list|)
operator|+
name|clock_time
operator|->
name|hour
expr_stmt|;
comment|/* min */
if|if
condition|(
name|clock_time
operator|->
name|minute
operator|<
literal|0
operator|||
name|clock_time
operator|->
name|minute
operator|>
literal|59
condition|)
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad min */
block|}
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock_time
operator|->
name|minute
expr_stmt|;
comment|/* sec */
if|if
condition|(
name|clock_time
operator|->
name|second
operator|<
literal|0
operator|||
name|clock_time
operator|->
name|second
operator|>
literal|60
condition|)
comment|/* allow for LEAPs */
block|{
name|SETRTC
argument_list|(
name|CVT_FAIL
operator||
name|CVT_BADTIME
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* bad sec */
block|}
name|t
operator|=
name|TIMES60
argument_list|(
name|t
argument_list|)
operator|+
name|clock_time
operator|->
name|second
expr_stmt|;
name|t
operator|+=
name|clock_time
operator|->
name|utcoffset
expr_stmt|;
comment|/* warp to UTC */
comment|/* done */
name|clock_time
operator|->
name|utctime
operator|=
name|t
expr_stmt|;
comment|/* documentray only */
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*--------------- format conversion -----------------------------------*/
end_comment

begin_function
name|int
name|Stoi
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|zp
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|char
name|unsigned
specifier|const
modifier|*
name|b
init|=
name|s
decl_stmt|;
name|int
name|f
decl_stmt|,
name|z
decl_stmt|,
name|v
decl_stmt|;
name|char
name|unsigned
name|c
decl_stmt|;
name|f
operator|=
name|z
operator|=
name|v
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|v
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|||
operator|(
name|cnt
operator|&&
operator|(
operator|(
name|s
operator|-
name|b
operator|)
operator|>
name|cnt
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|v
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
operator|*
name|zp
operator|=
name|z
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|z
operator|=
operator|(
name|z
operator|<<
literal|3
operator|)
operator|+
operator|(
name|z
operator|<<
literal|1
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|f
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|Strok
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|m
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|m
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m
operator|==
literal|' '
operator|)
condition|?
literal|1
else|:
operator|(
operator|*
name|s
operator|==
operator|*
name|m
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
operator|!
operator|*
name|m
return|;
block|}
end_function

begin_function
name|u_long
name|updatetimeinfo
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|u_long
name|flags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PARSEKERNEL
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|parseio
operator|->
name|parse_lstate
operator|=
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator||
name|flags
operator||
name|PARSEB_TIMECODE
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator|=
name|parseio
operator|->
name|parse_lstate
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEKERNEL
operator|(
name|void
operator|)
name|splx
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"updatetimeinfo status=0x%x, time=%x\n"
operator|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"updatetimeinfo status=0x%lx, time=%x\n"
operator|,
operator|(
name|long
operator|)
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_OK
return|;
comment|/* everything fine and dandy... */
block|}
end_function

begin_comment
comment|/*  * syn_simple  *  * handle a sync time stamp  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|syn_simple
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|ts
parameter_list|,
specifier|register
name|struct
name|format
modifier|*
name|format
parameter_list|,
specifier|register
name|u_long
name|why
parameter_list|)
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_stime
operator|=
operator|*
name|ts
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pps_simple  *  * handle a pps time stamp  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|u_long
name|pps_simple
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|int
name|status
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_ptime
operator|=
operator|*
name|ptime
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_state
operator||=
name|PARSEB_PPS
operator||
name|PARSEB_S_PPS
expr_stmt|;
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * pps_one  *  * handle a pps time stamp in ONE edge  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|u_long
name|pps_one
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|int
name|status
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
if|if
condition|(
name|status
condition|)
return|return
name|pps_simple
argument_list|(
name|parseio
argument_list|,
name|status
argument_list|,
name|ptime
argument_list|)
return|;
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * pps_zero  *  * handle a pps time stamp in ZERO edge  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|u_long
name|pps_zero
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|,
specifier|register
name|int
name|status
parameter_list|,
specifier|register
name|timestamp_t
modifier|*
name|ptime
parameter_list|)
block|{
if|if
condition|(
operator|!
name|status
condition|)
return|return
name|pps_simple
argument_list|(
name|parseio
argument_list|,
name|status
argument_list|,
name|ptime
argument_list|)
return|;
return|return
name|CVT_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * timepacket  *  * process a data packet  */
end_comment

begin_function
specifier|static
name|u_long
name|timepacket
parameter_list|(
specifier|register
name|parse_t
modifier|*
name|parseio
parameter_list|)
block|{
specifier|register
name|unsigned
name|short
name|format
decl_stmt|;
specifier|register
name|time_t
name|t
decl_stmt|;
name|u_long
name|cvtrtc
decl_stmt|;
comment|/* current conversion result */
name|clocktime_t
name|clock_time
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|clock_time
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|clock_time
argument_list|)
expr_stmt|;
name|format
operator|=
name|parseio
operator|->
name|parse_lformat
expr_stmt|;
if|if
condition|(
name|format
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|~
literal|0
condition|)
return|return
name|CVT_NONE
return|;
switch|switch
condition|(
operator|(
name|cvtrtc
operator|=
name|clockformats
index|[
name|format
index|]
operator|->
name|convert
condition|?
name|clockformats
index|[
name|format
index|]
operator|->
name|convert
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|parseio
operator|->
name|parse_ldata
argument_list|,
name|parseio
operator|->
name|parse_ldsize
argument_list|,
operator|(
expr|struct
name|format
operator|*
operator|)
operator|(
name|clockformats
index|[
name|format
index|]
operator|->
name|data
operator|)
argument_list|,
operator|&
name|clock_time
argument_list|,
name|parseio
operator|->
name|parse_pdata
argument_list|)
else|:
name|CVT_NONE
operator|)
operator|&
name|CVT_MASK
condition|)
block|{
case|case
name|CVT_FAIL
case|:
name|parseio
operator|->
name|parse_badformat
operator|++
expr_stmt|;
break|break;
case|case
name|CVT_NONE
case|:
comment|/* 		 * too bad - pretend bad format 		 */
name|parseio
operator|->
name|parse_badformat
operator|++
expr_stmt|;
break|break;
case|case
name|CVT_OK
case|:
break|break;
case|case
name|CVT_SKIP
case|:
return|return
name|CVT_NONE
return|;
default|default:
comment|/* shouldn't happen */
ifndef|#
directive|ifndef
name|PARSEKERNEL
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"parse: INTERNAL error: bad return code of convert routine \"%s\"\n"
argument_list|,
name|clockformats
index|[
name|format
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|CVT_FAIL
operator||
name|cvtrtc
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|=
name|parse_to_unixtime
argument_list|(
operator|&
name|clock_time
argument_list|,
operator|&
name|cvtrtc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|cvtrtc
return|;
block|}
comment|/* 	 * time stamp 	 */
ifdef|#
directive|ifdef
name|PARSEKERNEL
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_sec
operator|=
name|t
expr_stmt|;
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|tv
operator|.
name|tv_usec
operator|=
name|clock_time
operator|.
name|usecond
expr_stmt|;
else|#
directive|else
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_ui
operator|=
name|t
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|clock_time
operator|.
name|usecond
argument_list|,
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_time
operator|.
name|fp
operator|.
name|l_uf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parseio
operator|->
name|parse_dtime
operator|.
name|parse_format
operator|=
name|format
expr_stmt|;
return|return
name|updatetimeinfo
argument_list|(
name|parseio
argument_list|,
name|clock_time
operator|.
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_timecode
parameter_list|(
name|parsectl_t
modifier|*
name|dct
parameter_list|,
name|parse_t
modifier|*
name|parse
parameter_list|)
block|{
name|dct
operator|->
name|parsegettc
operator|.
name|parse_state
operator|=
name|parse
operator|->
name|parse_lstate
expr_stmt|;
name|dct
operator|->
name|parsegettc
operator|.
name|parse_format
operator|=
name|parse
operator|->
name|parse_lformat
expr_stmt|;
comment|/* 	 * move out current bad packet count 	 * user program is expected to sum these up 	 * this is not a problem, as "parse" module are 	 * exclusive open only 	 */
name|dct
operator|->
name|parsegettc
operator|.
name|parse_badformat
operator|=
name|parse
operator|->
name|parse_badformat
expr_stmt|;
name|parse
operator|->
name|parse_badformat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_ldsize
operator|<=
name|PARSE_TCMAX
condition|)
block|{
name|dct
operator|->
name|parsegettc
operator|.
name|parse_count
operator|=
name|parse
operator|->
name|parse_ldsize
expr_stmt|;
name|memcpy
argument_list|(
name|dct
operator|->
name|parsegettc
operator|.
name|parse_buffer
argument_list|,
name|parse
operator|->
name|parse_ldata
argument_list|,
name|dct
operator|->
name|parsegettc
operator|.
name|parse_count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_setfmt
parameter_list|(
name|parsectl_t
modifier|*
name|dct
parameter_list|,
name|parse_t
modifier|*
name|parse
parameter_list|)
block|{
if|if
condition|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
operator|<=
name|PARSE_TCMAX
condition|)
block|{
if|if
condition|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
condition|)
block|{
specifier|register
name|unsigned
name|short
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nformats
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Strcmp
argument_list|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|clockformats
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|parse
operator|->
name|parse_pdata
condition|)
name|FREE
argument_list|(
name|parse
operator|->
name|parse_pdata
argument_list|,
name|parse
operator|->
name|parse_plen
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_pdata
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_plen
operator|=
name|clockformats
index|[
name|i
index|]
operator|->
name|plen
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_plen
condition|)
block|{
name|parse
operator|->
name|parse_pdata
operator|=
name|MALLOC
argument_list|(
name|parse
operator|->
name|parse_plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse
operator|->
name|parse_pdata
condition|)
block|{
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"set format failed: malloc for private data area failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parse
operator|->
name|parse_pdata
argument_list|,
literal|0
argument_list|,
name|parse
operator|->
name|parse_plen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parse
operator|->
name|parse_data
condition|)
name|FREE
argument_list|(
name|parse
operator|->
name|parse_data
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|parse
operator|->
name|parse_dsize
operator|*
literal|2
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_ldata
operator|=
name|parse
operator|->
name|parse_data
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_dsize
operator|=
name|clockformats
index|[
name|i
index|]
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_dsize
condition|)
block|{
name|parse
operator|->
name|parse_data
operator|=
operator|(
name|char
operator|*
operator|)
name|MALLOC
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|parse
operator|->
name|parse_dsize
operator|*
literal|2
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse
operator|->
name|parse_data
condition|)
block|{
if|if
condition|(
name|parse
operator|->
name|parse_pdata
condition|)
name|FREE
argument_list|(
name|parse
operator|->
name|parse_pdata
argument_list|,
name|parse
operator|->
name|parse_plen
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_pdata
operator|=
literal|0
expr_stmt|;
name|parseprintf
argument_list|(
name|DD_PARSE
argument_list|,
operator|(
literal|"init failed: malloc for data area failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 					 * leave room for '\0' 					 */
name|parse
operator|->
name|parse_ldata
operator|=
name|parse
operator|->
name|parse_data
operator|+
name|parse
operator|->
name|parse_dsize
operator|+
literal|1
expr_stmt|;
name|parse
operator|->
name|parse_lformat
operator|=
name|i
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_getfmt
parameter_list|(
name|parsectl_t
modifier|*
name|dct
parameter_list|,
name|parse_t
modifier|*
name|parse
parameter_list|)
block|{
if|if
condition|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
operator|<
name|nformats
operator|&&
name|Strlen
argument_list|(
name|clockformats
index|[
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
index|]
operator|->
name|name
argument_list|)
operator|<=
name|PARSE_TCMAX
condition|)
block|{
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
operator|=
name|Strlen
argument_list|(
name|clockformats
index|[
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
index|]
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|dct
operator|->
name|parseformat
operator|.
name|parse_buffer
argument_list|,
name|clockformats
index|[
name|dct
operator|->
name|parseformat
operator|.
name|parse_format
index|]
operator|->
name|name
argument_list|,
name|dct
operator|->
name|parseformat
operator|.
name|parse_count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|parse_setcs
parameter_list|(
name|parsectl_t
modifier|*
name|dct
parameter_list|,
name|parse_t
modifier|*
name|parse
parameter_list|)
block|{
name|parse
operator|->
name|parse_ioflags
operator|&=
operator|~
name|PARSE_IO_CSIZE
expr_stmt|;
name|parse
operator|->
name|parse_ioflags
operator||=
name|dct
operator|->
name|parsesetcs
operator|.
name|parse_cs
operator|&
name|PARSE_IO_CSIZE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE) */
end_comment

begin_decl_stmt
name|int
name|parse_bs
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (REFCLOCK&& CLOCK_PARSE) */
end_comment

begin_comment
comment|/*  * History:  *  * parse.c,v  * Revision 4.20  2005/08/06 17:39:40  kardel  * cleanup size handling wrt/ to buffer boundaries  *  * Revision 4.19  2005/04/16 17:32:10  kardel  * update copyright  *  * Revision 4.18  2004/11/14 16:11:05  kardel  * update Id tags  *  * Revision 4.17  2004/11/14 15:29:41  kardel  * support PPSAPI, upgrade Copyright to Berkeley style  *  * Revision 4.14  1999/11/28 09:13:52  kardel  * RECON_4_0_98F  *  * Revision 4.13  1999/02/28 11:50:20  kardel  * (timepacket): removed unecessary code  *  * Revision 4.12  1999/02/21 12:17:44  kardel  * 4.91f reconcilation  *  * Revision 4.11  1999/02/21 11:09:47  kardel  * unified debug output  *  * Revision 4.10  1998/12/20 23:45:30  kardel  * fix types and warnings  *  * Revision 4.9  1998/08/09 22:26:06  kardel  * Trimble TSIP support  *  * Revision 4.8  1998/06/14 21:09:39  kardel  * Sun acc cleanup  *  * Revision 4.7  1998/06/13 15:19:13  kardel  * fix mem*() to b*() function macro emulation  *  * Revision 4.6  1998/06/13 13:24:13  kardel  * printf fmt  *  * Revision 4.5  1998/06/13 13:01:10  kardel  * printf fmt  *  * Revision 4.4  1998/06/13 12:12:10  kardel  * bcopy/memcpy cleanup  * fix SVSV name clash  *  * Revision 4.3  1998/06/12 15:22:30  kardel  * fix prototypes  *  * Revision 4.2  1998/06/12 09:13:27  kardel  * conditional compile macros fixed  * printf prototype  *  * Revision 4.1  1998/05/24 09:39:55  kardel  * implementation of the new IO handling model  *  * Revision 4.0  1998/04/10 19:45:36  kardel  * Start 4.0 release version numbering  *  * from V3 3.46 log info deleted 1998/04/11 kardel  */
end_comment

end_unit

