begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2004,2005 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *   Author:  Juergen Pfeifer, 1995,1997                                    *  ****************************************************************************/
end_comment

begin_comment
comment|/*************************************************************************** * Module m_global                                                          * * Globally used internal routines and the default menu and item structures * ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"menu.priv.h"
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: m_global.c,v 1.23 2005/12/31 21:51:52 tom Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|char
name|mark
index|[]
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|MENU
argument_list|)
end_macro

begin_expr_stmt
name|_nc_Default_Menu
operator|=
block|{
literal|16
block|,
comment|/* Nr. of chars high */
literal|1
block|,
comment|/* Nr. of chars wide */
literal|16
block|,
comment|/* Nr. of items high */
literal|1
block|,
comment|/* Nr. of items wide */
literal|16
block|,
comment|/* Nr. of formatted items high */
literal|1
block|,
comment|/* Nr. of formatted items wide */
literal|16
block|,
comment|/* Nr. of items high (actual) */
literal|0
block|,
comment|/* length of widest name */
literal|0
block|,
comment|/* length of widest description */
literal|1
block|,
comment|/* length of mark */
literal|1
block|,
comment|/* length of one item */
literal|1
block|,
comment|/* Spacing for descriptor */
literal|1
block|,
comment|/* Spacing for columns */
literal|1
block|,
comment|/* Spacing for rows */
operator|(
name|char
operator|*
operator|)
literal|0
block|,
comment|/* buffer used to store match chars */
literal|0
block|,
comment|/* Index into pattern buffer */
operator|(
name|WINDOW
operator|*
operator|)
literal|0
block|,
comment|/* Window containing entire menu */
operator|(
name|WINDOW
operator|*
operator|)
literal|0
block|,
comment|/* Portion of menu displayed */
operator|(
name|WINDOW
operator|*
operator|)
literal|0
block|,
comment|/* User's window */
operator|(
name|WINDOW
operator|*
operator|)
literal|0
block|,
comment|/* User's subwindow */
operator|(
name|ITEM
operator|*
operator|*
operator|)
literal|0
block|,
comment|/* List of items */
literal|0
block|,
comment|/* Total Nr. of items in menu */
operator|(
name|ITEM
operator|*
operator|)
literal|0
block|,
comment|/* Current item */
literal|0
block|,
comment|/* Top row of menu */
operator|(
name|chtype
operator|)
name|A_REVERSE
block|,
comment|/* Attribute for selection */
operator|(
name|chtype
operator|)
name|A_NORMAL
block|,
comment|/* Attribute for nonselection */
operator|(
name|chtype
operator|)
name|A_UNDERLINE
block|,
comment|/* Attribute for inactive */
literal|' '
block|,
comment|/* Pad character */
operator|(
name|Menu_Hook
operator|)
literal|0
block|,
comment|/* Menu init */
operator|(
name|Menu_Hook
operator|)
literal|0
block|,
comment|/* Menu term */
operator|(
name|Menu_Hook
operator|)
literal|0
block|,
comment|/* Item init */
operator|(
name|Menu_Hook
operator|)
literal|0
block|,
comment|/* Item term */
operator|(
name|void
operator|*
operator|)
literal|0
block|,
comment|/* userptr */
name|mark
block|,
comment|/* mark */
name|ALL_MENU_OPTS
block|,
comment|/* options */
literal|0
comment|/* status */
block|}
expr_stmt|;
end_expr_stmt

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|ITEM
argument_list|)
end_macro

begin_expr_stmt
name|_nc_Default_Item
operator|=
block|{
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|,
comment|/* name */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|,
comment|/* description */
operator|(
name|MENU
operator|*
operator|)
literal|0
block|,
comment|/* Pointer to parent menu */
operator|(
name|char
operator|*
operator|)
literal|0
block|,
comment|/* Userpointer */
name|ALL_ITEM_OPTS
block|,
comment|/* options */
literal|0
block|,
comment|/* Item Nr. */
literal|0
block|,
comment|/* y */
literal|0
block|,
comment|/* x */
name|FALSE
block|,
comment|/* value */
operator|(
name|ITEM
operator|*
operator|)
literal|0
block|,
comment|/* left */
operator|(
name|ITEM
operator|*
operator|)
literal|0
block|,
comment|/* right */
operator|(
name|ITEM
operator|*
operator|)
literal|0
block|,
comment|/* up */
operator|(
name|ITEM
operator|*
operator|)
literal|0
comment|/* down */
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  static void ComputeMaximum_NameDesc_Lenths(MENU *menu) |    |   Description   :  Calculates the maximum name and description lengths |                    of the items connected to the menu | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|void
name|ComputeMaximum_NameDesc_Lengths
parameter_list|(
name|MENU
modifier|*
name|menu
parameter_list|)
block|{
name|unsigned
name|MaximumNameLength
init|=
literal|0
decl_stmt|;
name|unsigned
name|MaximumDescriptionLength
init|=
literal|0
decl_stmt|;
name|ITEM
modifier|*
modifier|*
name|items
decl_stmt|;
name|unsigned
name|check
decl_stmt|;
name|assert
argument_list|(
name|menu
operator|&&
name|menu
operator|->
name|items
argument_list|)
expr_stmt|;
for|for
control|(
name|items
operator|=
name|menu
operator|->
name|items
init|;
operator|*
name|items
condition|;
name|items
operator|++
control|)
block|{
name|check
operator|=
name|_nc_Calculate_Text_Width
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|items
operator|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|>
name|MaximumNameLength
condition|)
name|MaximumNameLength
operator|=
name|check
expr_stmt|;
name|check
operator|=
name|_nc_Calculate_Text_Width
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|items
operator|)
operator|->
name|description
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|>
name|MaximumDescriptionLength
condition|)
name|MaximumDescriptionLength
operator|=
name|check
expr_stmt|;
block|}
name|menu
operator|->
name|namelen
operator|=
name|MaximumNameLength
expr_stmt|;
name|menu
operator|->
name|desclen
operator|=
name|MaximumDescriptionLength
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"ComputeMaximum_NameDesc_Lengths %d,%d"
operator|,
name|menu
operator|->
name|namelen
operator|,
name|menu
operator|->
name|desclen
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  static void ResetConnectionInfo(MENU *, ITEM **) |    |   Description   :  Reset all informations in the menu and the items in |                    the item array that indicates a connection | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|void
name|ResetConnectionInfo
parameter_list|(
name|MENU
modifier|*
name|menu
parameter_list|,
name|ITEM
modifier|*
modifier|*
name|items
parameter_list|)
block|{
name|ITEM
modifier|*
modifier|*
name|item
decl_stmt|;
name|assert
argument_list|(
name|menu
operator|&&
name|items
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|items
init|;
operator|*
name|item
condition|;
name|item
operator|++
control|)
block|{
operator|(
operator|*
name|item
operator|)
operator|->
name|index
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|item
operator|)
operator|->
name|imenu
operator|=
operator|(
name|MENU
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|menu
operator|->
name|pattern
condition|)
name|free
argument_list|(
name|menu
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|menu
operator|->
name|pattern
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|menu
operator|->
name|pindex
operator|=
literal|0
expr_stmt|;
name|menu
operator|->
name|items
operator|=
operator|(
name|ITEM
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|menu
operator|->
name|nitems
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  bool _nc_Connect_Items(MENU *menu, ITEM **items) | |   Description   :  Connect the items in the item array to the menu. |                    Decorate all the items with a number and a backward |                    pointer to the menu. | |   Return Values :  TRUE       - successful connection |                    FALSE      - connection failed +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|_nc_Connect_Items
argument_list|(
argument|MENU * menu
argument_list|,
argument|ITEM ** items
argument_list|)
end_macro

begin_block
block|{
name|ITEM
modifier|*
modifier|*
name|item
decl_stmt|;
name|unsigned
name|int
name|ItemCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|menu
operator|&&
name|items
condition|)
block|{
for|for
control|(
name|item
operator|=
name|items
init|;
operator|*
name|item
condition|;
name|item
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|item
operator|)
operator|->
name|imenu
condition|)
block|{
comment|/* if a item is already connected, reject connection */
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|item
operator|)
condition|)
comment|/* we reached the end, so there was no connected item */
block|{
for|for
control|(
name|item
operator|=
name|items
init|;
operator|*
name|item
condition|;
name|item
operator|++
control|)
block|{
if|if
condition|(
name|menu
operator|->
name|opt
operator|&
name|O_ONEVALUE
condition|)
block|{
operator|(
operator|*
name|item
operator|)
operator|->
name|value
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
operator|*
name|item
operator|)
operator|->
name|index
operator|=
name|ItemCount
operator|++
expr_stmt|;
operator|(
operator|*
name|item
operator|)
operator|->
name|imenu
operator|=
name|menu
expr_stmt|;
block|}
block|}
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|ItemCount
operator|!=
literal|0
condition|)
block|{
name|menu
operator|->
name|items
operator|=
name|items
expr_stmt|;
name|menu
operator|->
name|nitems
operator|=
name|ItemCount
expr_stmt|;
name|ComputeMaximum_NameDesc_Lengths
argument_list|(
name|menu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|menu
operator|->
name|pattern
operator|=
name|typeMalloc
argument_list|(
name|char
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
literal|1
operator|+
name|menu
operator|->
name|namelen
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|Reset_Pattern
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|set_menu_format
argument_list|(
name|menu
argument_list|,
name|menu
operator|->
name|frows
argument_list|,
name|menu
operator|->
name|fcols
argument_list|)
expr_stmt|;
name|menu
operator|->
name|curitem
operator|=
operator|*
name|items
expr_stmt|;
name|menu
operator|->
name|toprow
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* If we fall through to this point, we have to reset all items connection       and inform about a reject connection */
name|ResetConnectionInfo
argument_list|(
name|menu
argument_list|,
name|items
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  void _nc_Disconnect_Items(MENU *menu) |    |   Description   :  Disconnect the menus item array from the menu | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_Disconnect_Items
argument_list|(
argument|MENU * menu
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|menu
operator|&&
name|menu
operator|->
name|items
condition|)
name|ResetConnectionInfo
argument_list|(
name|menu
argument_list|,
name|menu
operator|->
name|items
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  int _nc_Calculate_Text_Width(const TEXT * item) |    |   Description   :  Calculate the number of columns for a TEXT. | |   Return Values :  the width +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Calculate_Text_Width
argument_list|(
argument|const TEXT * item
comment|/*FIXME: limit length */
argument_list|)
end_macro

begin_block
block|{
if|#
directive|if
name|USE_WIDEC_SUPPORT
name|int
name|result
init|=
name|item
operator|->
name|length
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_menu_text_width(%p)"
argument_list|)
operator|,
name|item
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
name|item
operator|->
name|str
operator|!=
literal|0
condition|)
block|{
name|int
name|count
init|=
name|mbstowcs
argument_list|(
literal|0
argument_list|,
name|item
operator|->
name|str
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|wchar_t
modifier|*
name|temp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
operator|(
name|temp
operator|=
name|typeMalloc
argument_list|(
name|wchar_t
argument_list|,
literal|2
operator|+
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|mbstowcs
argument_list|(
name|temp
argument_list|,
name|item
operator|->
name|str
argument_list|,
operator|(
name|unsigned
operator|)
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
operator|++
name|n
control|)
block|{
name|int
name|test
init|=
name|wcwidth
argument_list|(
name|temp
index|[
name|n
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|<=
literal|0
condition|)
name|test
operator|=
literal|1
expr_stmt|;
name|result
operator|+=
name|test
expr_stmt|;
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
name|item
operator|->
name|length
return|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Calculate the actual width of a menu entry for wide-characters.  */
end_comment

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_function
specifier|static
name|int
name|calculate_actual_width
parameter_list|(
name|MENU
modifier|*
name|menu
parameter_list|,
name|bool
name|name
parameter_list|)
block|{
name|int
name|width
init|=
literal|0
decl_stmt|;
name|int
name|check
init|=
literal|0
decl_stmt|;
name|ITEM
modifier|*
modifier|*
name|items
decl_stmt|;
name|assert
argument_list|(
name|menu
operator|&&
name|menu
operator|->
name|items
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|items
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|items
operator|=
name|menu
operator|->
name|items
init|;
operator|*
name|items
condition|;
name|items
operator|++
control|)
block|{
if|if
condition|(
name|name
condition|)
block|{
name|check
operator|=
name|_nc_Calculate_Text_Width
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|items
operator|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check
operator|=
name|_nc_Calculate_Text_Width
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|items
operator|)
operator|->
name|description
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|>
name|width
condition|)
name|width
operator|=
name|check
expr_stmt|;
block|}
block|}
else|else
block|{
name|width
operator|=
operator|(
name|name
condition|?
name|menu
operator|->
name|namelen
else|:
name|menu
operator|->
name|desclen
operator|)
expr_stmt|;
block|}
name|T
argument_list|(
operator|(
literal|"calculate_actual_width %s = %d/%d"
operator|,
name|name
condition|?
literal|"name"
else|:
literal|"desc"
operator|,
name|width
operator|,
name|name
condition|?
name|menu
operator|->
name|namelen
else|:
name|menu
operator|->
name|desclen
operator|)
argument_list|)
expr_stmt|;
return|return
name|width
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|calculate_actual_width
parameter_list|(
name|menu
parameter_list|,
name|name
parameter_list|)
value|(name ? menu->namelen : menu->desclen)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  void _nc_Calculate_Item_Length_and_Width(MENU *menu) |    |   Description   :  Calculate the length of an item and the width of the |                    whole menu. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_Calculate_Item_Length_and_Width
argument_list|(
argument|MENU * menu
argument_list|)
end_macro

begin_block
block|{
name|int
name|l
decl_stmt|;
name|assert
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|menu
operator|->
name|height
operator|=
literal|1
operator|+
name|menu
operator|->
name|spc_rows
operator|*
operator|(
name|menu
operator|->
name|arows
operator|-
literal|1
operator|)
expr_stmt|;
name|l
operator|=
name|calculate_actual_width
argument_list|(
name|menu
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|l
operator|+=
name|menu
operator|->
name|marklen
expr_stmt|;
if|if
condition|(
operator|(
name|menu
operator|->
name|opt
operator|&
name|O_SHOWDESC
operator|)
operator|&&
operator|(
name|menu
operator|->
name|desclen
operator|>
literal|0
operator|)
condition|)
block|{
name|l
operator|+=
name|calculate_actual_width
argument_list|(
name|menu
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|l
operator|+=
name|menu
operator|->
name|spc_desc
expr_stmt|;
block|}
name|menu
operator|->
name|itemlen
operator|=
name|l
expr_stmt|;
name|l
operator|*=
name|menu
operator|->
name|cols
expr_stmt|;
name|l
operator|+=
operator|(
name|menu
operator|->
name|cols
operator|-
literal|1
operator|)
operator|*
name|menu
operator|->
name|spc_cols
expr_stmt|;
comment|/* for the padding between the columns */
name|menu
operator|->
name|width
operator|=
name|l
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"_nc_CalculateItem_Length_and_Width columns %d, item %d, width %d"
operator|,
name|menu
operator|->
name|cols
operator|,
name|menu
operator|->
name|itemlen
operator|,
name|menu
operator|->
name|width
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  void _nc_Link_Item(MENU *menu) |    |   Description   :  Statically calculate for every item its four neighbors. |                    This depends on the orientation of the menu. This |                    static approach simplifies navigation in the menu a lot. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_Link_Items
argument_list|(
argument|MENU * menu
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|menu
operator|&&
name|menu
operator|->
name|items
operator|&&
operator|*
operator|(
name|menu
operator|->
name|items
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ITEM
modifier|*
name|item
decl_stmt|;
name|int
name|Number_Of_Items
init|=
name|menu
operator|->
name|nitems
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|,
name|row
init|=
literal|0
decl_stmt|;
name|int
name|Last_in_Row
decl_stmt|;
name|int
name|Last_in_Column
decl_stmt|;
name|bool
name|cycle
init|=
operator|(
name|menu
operator|->
name|opt
operator|&
name|O_NONCYCLIC
operator|)
condition|?
name|FALSE
else|:
name|TRUE
decl_stmt|;
name|menu
operator|->
name|status
operator|&=
operator|~
name|_LINK_NEEDED
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|opt
operator|&
name|O_ROWMAJOR
condition|)
block|{
name|int
name|Number_Of_Columns
init|=
name|menu
operator|->
name|cols
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Number_Of_Items
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|i
index|]
expr_stmt|;
name|Last_in_Row
operator|=
name|row
operator|*
name|Number_Of_Columns
operator|+
operator|(
name|Number_Of_Columns
operator|-
literal|1
operator|)
expr_stmt|;
name|item
operator|->
name|left
operator|=
operator|(
name|col
operator|)
condition|?
comment|/* if we are not in the leftmost column, we can use the 	         predecessor in the items array */
name|menu
operator|->
name|items
index|[
name|i
operator|-
literal|1
index|]
else|:
operator|(
name|cycle
condition|?
name|menu
operator|->
name|items
index|[
operator|(
name|Last_in_Row
operator|>=
name|Number_Of_Items
operator|)
condition|?
name|Number_Of_Items
operator|-
literal|1
else|:
name|Last_in_Row
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|item
operator|->
name|right
operator|=
operator|(
operator|(
name|col
operator|<
operator|(
name|Number_Of_Columns
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|Number_Of_Items
operator|)
operator|)
condition|?
name|menu
operator|->
name|items
index|[
name|i
operator|+
literal|1
index|]
else|:
operator|(
name|cycle
condition|?
name|menu
operator|->
name|items
index|[
name|row
operator|*
name|Number_Of_Columns
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|Last_in_Column
operator|=
operator|(
name|menu
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
name|Number_Of_Columns
operator|+
name|col
expr_stmt|;
name|item
operator|->
name|up
operator|=
operator|(
name|row
operator|)
condition|?
name|menu
operator|->
name|items
index|[
name|i
operator|-
name|Number_Of_Columns
index|]
else|:
operator|(
name|cycle
condition|?
name|menu
operator|->
name|items
index|[
operator|(
name|Last_in_Column
operator|>=
name|Number_Of_Items
operator|)
condition|?
name|Number_Of_Items
operator|-
literal|1
else|:
name|Last_in_Column
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|item
operator|->
name|down
operator|=
operator|(
operator|(
name|i
operator|+
name|Number_Of_Columns
operator|)
operator|<
name|Number_Of_Items
operator|)
condition|?
name|menu
operator|->
name|items
index|[
name|i
operator|+
name|Number_Of_Columns
index|]
else|:
operator|(
name|cycle
condition|?
name|menu
operator|->
name|items
index|[
operator|(
name|row
operator|+
literal|1
operator|)
operator|<
name|menu
operator|->
name|rows
condition|?
name|Number_Of_Items
operator|-
literal|1
else|:
name|col
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|item
operator|->
name|x
operator|=
name|col
expr_stmt|;
name|item
operator|->
name|y
operator|=
name|row
expr_stmt|;
if|if
condition|(
operator|++
name|col
operator|==
name|Number_Of_Columns
condition|)
block|{
name|row
operator|++
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|Number_Of_Rows
init|=
name|menu
operator|->
name|rows
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Number_Of_Items
condition|;
name|j
operator|++
control|)
block|{
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|i
operator|=
operator|(
name|col
operator|*
name|Number_Of_Rows
operator|+
name|row
operator|)
index|]
expr_stmt|;
name|Last_in_Column
operator|=
operator|(
name|menu
operator|->
name|cols
operator|-
literal|1
operator|)
operator|*
name|Number_Of_Rows
operator|+
name|row
expr_stmt|;
name|item
operator|->
name|left
operator|=
operator|(
name|col
operator|)
condition|?
name|menu
operator|->
name|items
index|[
name|i
operator|-
name|Number_Of_Rows
index|]
else|:
operator|(
name|cycle
condition|?
operator|(
name|Last_in_Column
operator|>=
name|Number_Of_Items
operator|)
condition|?
name|menu
operator|->
name|items
index|[
name|Last_in_Column
operator|-
name|Number_Of_Rows
index|]
else|:
name|menu
operator|->
name|items
index|[
name|Last_in_Column
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|item
operator|->
name|right
operator|=
operator|(
operator|(
name|i
operator|+
name|Number_Of_Rows
operator|)
operator|<
name|Number_Of_Items
operator|)
condition|?
name|menu
operator|->
name|items
index|[
name|i
operator|+
name|Number_Of_Rows
index|]
else|:
operator|(
name|cycle
condition|?
name|menu
operator|->
name|items
index|[
name|row
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|Last_in_Row
operator|=
name|col
operator|*
name|Number_Of_Rows
operator|+
operator|(
name|Number_Of_Rows
operator|-
literal|1
operator|)
expr_stmt|;
name|item
operator|->
name|up
operator|=
operator|(
name|row
operator|)
condition|?
name|menu
operator|->
name|items
index|[
name|i
operator|-
literal|1
index|]
else|:
operator|(
name|cycle
condition|?
name|menu
operator|->
name|items
index|[
operator|(
name|Last_in_Row
operator|>=
name|Number_Of_Items
operator|)
condition|?
name|Number_Of_Items
operator|-
literal|1
else|:
name|Last_in_Row
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|item
operator|->
name|down
operator|=
operator|(
name|row
operator|<
operator|(
name|Number_Of_Rows
operator|-
literal|1
operator|)
operator|)
condition|?
operator|(
name|menu
operator|->
name|items
index|[
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|Number_Of_Items
operator|)
condition|?
name|i
operator|+
literal|1
else|:
operator|(
name|col
operator|-
literal|1
operator|)
operator|*
name|Number_Of_Rows
operator|+
name|row
operator|+
literal|1
index|]
operator|)
else|:
operator|(
name|cycle
condition|?
name|menu
operator|->
name|items
index|[
name|col
operator|*
name|Number_Of_Rows
index|]
else|:
operator|(
name|ITEM
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|item
operator|->
name|x
operator|=
name|col
expr_stmt|;
name|item
operator|->
name|y
operator|=
name|row
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|row
operator|)
operator|==
name|Number_Of_Rows
condition|)
block|{
name|col
operator|++
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  void _nc_Show_Menu(const MENU *menu) |    |   Description   :  Update the window that is associated with the menu | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_Show_Menu
argument_list|(
argument|const MENU * menu
argument_list|)
end_macro

begin_block
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|int
name|maxy
decl_stmt|,
name|maxx
decl_stmt|;
name|assert
argument_list|(
name|menu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|menu
operator|->
name|status
operator|&
name|_POSTED
operator|)
operator|&&
operator|!
operator|(
name|menu
operator|->
name|status
operator|&
name|_IN_DRIVER
operator|)
condition|)
block|{
comment|/* adjust the internal subwindow to start on the current top */
name|assert
argument_list|(
name|menu
operator|->
name|sub
argument_list|)
expr_stmt|;
name|mvderwin
argument_list|(
name|menu
operator|->
name|sub
argument_list|,
name|menu
operator|->
name|spc_rows
operator|*
name|menu
operator|->
name|toprow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|win
operator|=
name|Get_Menu_Window
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|maxy
operator|=
name|getmaxy
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|maxx
operator|=
name|getmaxx
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|height
operator|<
name|maxy
condition|)
name|maxy
operator|=
name|menu
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|width
operator|<
name|maxx
condition|)
name|maxx
operator|=
name|menu
operator|->
name|width
expr_stmt|;
name|copywin
argument_list|(
name|menu
operator|->
name|sub
argument_list|,
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|maxy
operator|-
literal|1
argument_list|,
name|maxx
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pos_menu_cursor
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu   |   Function      :  void _nc_New_TopRow_and_CurrentItem( |                            MENU *menu,  |                            int new_toprow,  |                            ITEM *new_current_item) |    |   Description   :  Redisplay the menu so that the given row becomes the |                    top row and the given item becomes the new current |                    item. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_New_TopRow_and_CurrentItem
argument_list|(
argument|MENU * menu
argument_list|,
argument|int new_toprow
argument_list|,
argument|ITEM * new_current_item
argument_list|)
end_macro

begin_block
block|{
name|ITEM
modifier|*
name|cur_item
decl_stmt|;
name|bool
name|mterm_called
init|=
name|FALSE
decl_stmt|;
name|bool
name|iterm_called
init|=
name|FALSE
decl_stmt|;
name|assert
argument_list|(
name|menu
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|status
operator|&
name|_POSTED
condition|)
block|{
if|if
condition|(
name|new_current_item
operator|!=
name|menu
operator|->
name|curitem
condition|)
block|{
name|Call_Hook
argument_list|(
name|menu
argument_list|,
name|itemterm
argument_list|)
expr_stmt|;
name|iterm_called
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|new_toprow
operator|!=
name|menu
operator|->
name|toprow
condition|)
block|{
name|Call_Hook
argument_list|(
name|menu
argument_list|,
name|menuterm
argument_list|)
expr_stmt|;
name|mterm_called
operator|=
name|TRUE
expr_stmt|;
block|}
name|cur_item
operator|=
name|menu
operator|->
name|curitem
expr_stmt|;
name|assert
argument_list|(
name|cur_item
argument_list|)
expr_stmt|;
name|menu
operator|->
name|toprow
operator|=
name|new_toprow
expr_stmt|;
name|menu
operator|->
name|curitem
operator|=
name|new_current_item
expr_stmt|;
if|if
condition|(
name|mterm_called
condition|)
block|{
name|Call_Hook
argument_list|(
name|menu
argument_list|,
name|menuinit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iterm_called
condition|)
block|{
comment|/* this means, move from the old current_item to the new one... */
name|Move_To_Current_Item
argument_list|(
name|menu
argument_list|,
name|cur_item
argument_list|)
expr_stmt|;
name|Call_Hook
argument_list|(
name|menu
argument_list|,
name|iteminit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mterm_called
operator|||
name|iterm_called
condition|)
block|{
name|_nc_Show_Menu
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
else|else
name|pos_menu_cursor
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if we are not posted, this is quite simple */
name|menu
operator|->
name|toprow
operator|=
name|new_toprow
expr_stmt|;
name|menu
operator|->
name|curitem
operator|=
name|new_current_item
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* m_global.c ends here */
end_comment

end_unit

