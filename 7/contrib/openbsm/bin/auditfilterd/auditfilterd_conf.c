begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by Robert Watson for the TrustedBSD Project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $P4: //depot/projects/trustedbsd/openbsm/bin/auditfilterd/auditfilterd_conf.c#5 $  */
end_comment

begin_comment
comment|/*  * Configuration file parser for auditfilterd.  The configuration file is a  * very simple format, similar to other BSM configuration files, consisting  * of configuration entries of one line each.  The configuration function is  * aware of previous runs, and will update the current configuration as  * needed.  *  * Modules are in one of two states: attached, or detached.  If attach fails,  * detach is not called because it was not attached.  If a module is attached  * and a call to its reinit method fails, we will detach it.  *  * Modules are passed a (void *) reference to their configuration state so  * that they may pass this into any common APIs we provide which may rely on  * that state.  Currently, the only such API is the cookie API, which allows  * per-instance state to be maintained by a module.  In the future, this will  * also be used to support per-instance preselection state.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<config/config.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FULL_QUEUE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<compat/queue.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_filter.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"auditfilterd.h"
end_include

begin_comment
comment|/*  * Free an individual auditfilter_module structure.  Will not shut down the  * module, just frees the memory.  Does so conditional on pointers being  * non-NULL so that it can be used on partially allocated structures.  */
end_comment

begin_function
specifier|static
name|void
name|auditfilter_module_free
parameter_list|(
name|struct
name|auditfilter_module
modifier|*
name|am
parameter_list|)
block|{
if|if
condition|(
name|am
operator|->
name|am_modulename
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|am
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_arg_buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|am
operator|->
name|am_arg_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_argv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|am
operator|->
name|am_argv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free all memory associated with an auditfilter_module list.  Does not  * dlclose() or shut down the modules, just free the memory.  Use  * auditfilter_module_list_detach() for that, if required.  */
end_comment

begin_function
specifier|static
name|void
name|auditfilter_module_list_free
parameter_list|(
name|struct
name|auditfilter_module_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|auditfilter_module
modifier|*
name|am
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|TAILQ_EMPTY
argument_list|(
name|list
argument_list|)
operator|)
condition|)
block|{
name|am
operator|=
name|TAILQ_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|list
argument_list|,
name|am
argument_list|,
name|am_list
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Detach an attached module from an auditfilter_module structure.  Does not  * free the data structure itself.  */
end_comment

begin_function
specifier|static
name|void
name|auditfilter_module_detach
parameter_list|(
name|struct
name|auditfilter_module
modifier|*
name|am
parameter_list|)
block|{
if|if
condition|(
name|am
operator|->
name|am_detach
operator|!=
name|NULL
condition|)
name|am
operator|->
name|am_detach
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_cookie
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|dlclose
argument_list|(
name|am
operator|->
name|am_dlhandle
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_dlhandle
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk an auditfilter_module list, detaching each module.  Intended to be  * combined with auditfilter_module_list_free().  */
end_comment

begin_function
specifier|static
name|void
name|auditfilter_module_list_detach
parameter_list|(
name|struct
name|auditfilter_module_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|auditfilter_module
modifier|*
name|am
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|am
argument_list|,
argument|list
argument_list|,
argument|am_list
argument_list|)
name|auditfilter_module_detach
argument_list|(
name|am
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a filled out auditfilter_module, use dlopen() and dlsym() to attach  * the module.  If we fail, leave fields in the state we found them.  *  * XXXRW: Need a better way to report errors.  */
end_comment

begin_function
specifier|static
name|int
name|auditfilter_module_attach
parameter_list|(
name|struct
name|auditfilter_module
modifier|*
name|am
parameter_list|)
block|{
name|am
operator|->
name|am_dlhandle
operator|=
name|dlopen
argument_list|(
name|am
operator|->
name|am_modulename
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_dlhandle
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"auditfilter_module_attach: %s: %s"
argument_list|,
name|am
operator|->
name|am_modulename
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Not implementing these is not considered a failure condition, 	 * although we might want to consider warning if obvious stuff is 	 * not implemented, such as am_record. 	 */
name|am
operator|->
name|am_attach
operator|=
name|dlsym
argument_list|(
name|am
operator|->
name|am_dlhandle
argument_list|,
name|AUDIT_FILTER_ATTACH_STRING
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_reinit
operator|=
name|dlsym
argument_list|(
name|am
operator|->
name|am_dlhandle
argument_list|,
name|AUDIT_FILTER_REINIT_STRING
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_record
operator|=
name|dlsym
argument_list|(
name|am
operator|->
name|am_dlhandle
argument_list|,
name|AUDIT_FILTER_RECORD_STRING
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_rawrecord
operator|=
name|dlsym
argument_list|(
name|am
operator|->
name|am_dlhandle
argument_list|,
name|AUDIT_FILTER_RAWRECORD_STRING
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_detach
operator|=
name|dlsym
argument_list|(
name|am
operator|->
name|am_dlhandle
argument_list|,
name|AUDIT_FILTER_DETACH_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_attach
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|am
operator|->
name|am_attach
argument_list|(
name|am
argument_list|,
name|am
operator|->
name|am_argc
argument_list|,
name|am
operator|->
name|am_argv
argument_list|)
operator|!=
name|AUDIT_FILTER_SUCCESS
condition|)
block|{
name|warnx
argument_list|(
literal|"auditfilter_module_attach: %s: failed"
argument_list|,
name|am
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|am
operator|->
name|am_dlhandle
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_dlhandle
operator|=
name|NULL
expr_stmt|;
name|am
operator|->
name|am_cookie
operator|=
name|NULL
expr_stmt|;
name|am
operator|->
name|am_attach
operator|=
name|NULL
expr_stmt|;
name|am
operator|->
name|am_reinit
operator|=
name|NULL
expr_stmt|;
name|am
operator|->
name|am_record
operator|=
name|NULL
expr_stmt|;
name|am
operator|->
name|am_rawrecord
operator|=
name|NULL
expr_stmt|;
name|am
operator|->
name|am_detach
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When the arguments for a module are changed, we notify the module through  * a call to its reinit method, if any.  Return 0 on success, or -1 on  * failure.  */
end_comment

begin_function
specifier|static
name|int
name|auditfilter_module_reinit
parameter_list|(
name|struct
name|auditfilter_module
modifier|*
name|am
parameter_list|)
block|{
if|if
condition|(
name|am
operator|->
name|am_reinit
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|am
operator|->
name|am_reinit
argument_list|(
name|am
argument_list|,
name|am
operator|->
name|am_argc
argument_list|,
name|am
operator|->
name|am_argv
argument_list|)
operator|!=
name|AUDIT_FILTER_SUCCESS
condition|)
block|{
name|warnx
argument_list|(
literal|"auditfilter_module_reinit: %s: failed"
argument_list|,
name|am
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a configuration line, generate an auditfilter_module structure that  * describes it; caller will not pass comments in, so they are not looked  * for.  Do not attempt to instantiate it.  Will destroy the contents of  * 'buffer'.  *  * Configuration lines consist of two parts: the module name and arguments  * separated by a ':', and then a ','-delimited list of arguments.  *  * XXXRW: Need to decide where to send the warning output -- stderr for now.  */
end_comment

begin_function
name|struct
name|auditfilter_module
modifier|*
name|auditfilter_module_parse
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|linenumber
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|arguments
decl_stmt|,
modifier|*
name|module
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|struct
name|auditfilter_module
modifier|*
name|am
decl_stmt|;
name|am
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|am
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"auditfilter_module_parse: %s:%d"
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|am
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|am
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, break out the module and arguments strings.  We look for 	 * one extra argument to make sure there are no more :'s in the line. 	 * That way, we prevent modules from using argument strings that, in 	 * the future, may cause problems for adding additional columns. 	 */
name|arguments
operator|=
name|buffer
expr_stmt|;
name|module
operator|=
name|strsep
argument_list|(
operator|&
name|arguments
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|module
operator|==
name|NULL
operator|||
name|arguments
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"auditfilter_module_parse: %s:%d: parse error"
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|am
operator|->
name|am_modulename
operator|=
name|strdup
argument_list|(
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_modulename
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"auditfilter_module_parse: %s:%d"
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|am
operator|->
name|am_arg_buffer
operator|=
name|strdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_arg_buffer
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"auditfilter_module_parse: %s:%d"
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now, break out the arguments string into a series of arguments. 	 * This is a bit more complicated, and requires cleanup if things go 	 * wrong. 	 */
name|am
operator|->
name|am_argv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|AUDITFILTERD_CONF_MAXARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|->
name|am_argv
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"auditfilter_module_parse: %s:%d"
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|am
operator|->
name|am_argv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|AUDITFILTERD_CONF_MAXARGS
argument_list|)
expr_stmt|;
name|am
operator|->
name|am_argc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|am
operator|->
name|am_argv
init|;
operator|(
operator|*
name|ap
operator|=
name|strsep
argument_list|(
operator|&
name|arguments
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|!=
literal|'\0'
condition|)
block|{
name|am
operator|->
name|am_argc
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|ap
operator|>=
operator|&
name|am
operator|->
name|am_argv
index|[
name|AUDITFILTERD_CONF_MAXARGS
index|]
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ap
operator|>=
operator|&
name|am
operator|->
name|am_argv
index|[
name|AUDITFILTERD_CONF_MAXARGS
index|]
condition|)
block|{
name|warnx
argument_list|(
literal|"auditfilter_module_parse: %s:%d: too many arguments"
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|am
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a configuration file, and populate 'list' with the configuration  * lines.  Does not attempt to instantiate the configuration, just read it  * into a useful set of data structures.  */
end_comment

begin_function
specifier|static
name|int
name|auditfilterd_conf_read
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|auditfilter_module_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|linenumber
decl_stmt|,
name|syntaxerror
decl_stmt|;
name|struct
name|auditfilter_module
modifier|*
name|am
decl_stmt|;
name|char
name|buffer
index|[
name|LINE_MAX
index|]
decl_stmt|;
name|syntaxerror
operator|=
literal|0
expr_stmt|;
name|linenumber
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|LINE_MAX
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|linenumber
operator|++
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
name|buffer
index|[
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|am
operator|=
name|auditfilter_module_parse
argument_list|(
name|filename
argument_list|,
name|linenumber
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
block|{
name|syntaxerror
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|am
argument_list|,
name|am_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * File I/O error. 	 */
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|auditfilter_module_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Syntax error. 	 */
if|if
condition|(
name|syntaxerror
condition|)
block|{
name|auditfilter_module_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Apply changes necessary to bring a new configuration into force.  The new  * configuration data is passed in, and the current configuration is updated  * to match it.  The contents of 'list' are freed or otherwise disposed of  * before return.  *  * The algorithms here are not very efficient, but this is an infrequent  * operation on very short lists.  */
end_comment

begin_function
specifier|static
name|void
name|auditfilterd_conf_apply
parameter_list|(
name|struct
name|auditfilter_module_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|auditfilter_module
modifier|*
name|am1
decl_stmt|,
modifier|*
name|am2
decl_stmt|,
modifier|*
name|am_tmp
decl_stmt|;
name|int
name|argc_tmp
decl_stmt|,
name|found
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv_tmp
decl_stmt|;
comment|/* 	 * First, remove remove and detach any entries that appear in the 	 * current configuration, but not the new configuration. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|am1
argument_list|,
argument|&filter_list
argument_list|,
argument|am_list
argument_list|,
argument|am_tmp
argument_list|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|am2
argument_list|,
argument|list
argument_list|,
argument|am_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|am1
operator|->
name|am_modulename
argument_list|,
name|am2
operator|->
name|am_modulename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
continue|continue;
comment|/* 		 * am1 appears in filter_list, but not the new list, detach 		 * and free the module. 		 */
name|warnx
argument_list|(
literal|"detaching module %s"
argument_list|,
name|am1
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|filter_list
argument_list|,
name|am1
argument_list|,
name|am_list
argument_list|)
expr_stmt|;
name|auditfilter_module_detach
argument_list|(
name|am1
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Next, update the configuration of any modules that appear in both 	 * lists.  We do this by swapping the two argc and argv values and 	 * freeing the new one, rather than detaching the old one and 	 * attaching the new one.  That way module state is preserved. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|am1
argument_list|,
argument|&filter_list
argument_list|,
argument|am_list
argument_list|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|am2
argument_list|,
argument|list
argument_list|,
argument|am_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|am1
operator|->
name|am_modulename
argument_list|,
name|am2
operator|->
name|am_modulename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
continue|continue;
comment|/* 		 * Swap the arguments. 		 */
name|argc_tmp
operator|=
name|am1
operator|->
name|am_argc
expr_stmt|;
name|argv_tmp
operator|=
name|am1
operator|->
name|am_argv
expr_stmt|;
name|am1
operator|->
name|am_argc
operator|=
name|am2
operator|->
name|am_argc
expr_stmt|;
name|am1
operator|->
name|am_argv
operator|=
name|am2
operator|->
name|am_argv
expr_stmt|;
name|am2
operator|->
name|am_argc
operator|=
name|argc_tmp
expr_stmt|;
name|am2
operator|->
name|am_argv
operator|=
name|argv_tmp
expr_stmt|;
comment|/* 		 * The reinit is a bit tricky: if reinit fails, we actually 		 * remove the old entry and detach that, as we don't allow 		 * running modules to be out of sync with the configuration 		 * file. 		 */
name|warnx
argument_list|(
literal|"reiniting module %s"
argument_list|,
name|am1
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
if|if
condition|(
name|auditfilter_module_reinit
argument_list|(
name|am1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"reinit failed for module %s, detaching"
argument_list|,
name|am1
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|filter_list
argument_list|,
name|am1
argument_list|,
name|am_list
argument_list|)
expr_stmt|;
name|auditfilter_module_detach
argument_list|(
name|am1
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Free the entry from the new list, which will discard the 		 * old arguments.  No need to detach, as it was never 		 * attached in the first place. 		 */
name|TAILQ_REMOVE
argument_list|(
name|list
argument_list|,
name|am2
argument_list|,
name|am_list
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finally, attach any new entries that don't appear in the old 	 * configuration, and if they attach successfully, move them to the 	 * real configuration list. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|am1
argument_list|,
argument|list
argument_list|,
argument|am_list
argument_list|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|am2
argument_list|,
argument|&filter_list
argument_list|,
argument|am_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|am1
operator|->
name|am_modulename
argument_list|,
name|am2
operator|->
name|am_modulename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
continue|continue;
comment|/* 		 * Attach the entry.  If it succeeds, add to filter_list, 		 * otherwise, free.  No need to detach if attach failed. 		 */
name|warnx
argument_list|(
literal|"attaching module %s"
argument_list|,
name|am1
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|list
argument_list|,
name|am1
argument_list|,
name|am_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|auditfilter_module_attach
argument_list|(
name|am1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"attaching module %s failed"
argument_list|,
name|am1
operator|->
name|am_modulename
argument_list|)
expr_stmt|;
name|auditfilter_module_free
argument_list|(
name|am1
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|filter_list
argument_list|,
name|am1
argument_list|,
name|am_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
name|list
argument_list|)
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"auditfilterd_conf_apply: new list not empty\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the new configuration file into a local list.  If the configuration  * file is parsed OK, then apply the changes.  */
end_comment

begin_function
name|int
name|auditfilterd_conf
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|auditfilter_module_list
name|list
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|auditfilterd_conf_read
argument_list|(
name|filename
argument_list|,
name|fp
argument_list|,
operator|&
name|list
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|auditfilterd_conf_apply
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach and free all active filter modules for daemon shutdown.  */
end_comment

begin_function
name|void
name|auditfilterd_conf_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|auditfilter_module_list_detach
argument_list|(
operator|&
name|filter_list
argument_list|)
expr_stmt|;
name|auditfilter_module_list_free
argument_list|(
operator|&
name|filter_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * APIs to allow modules to query and set their per-instance cookie.  */
end_comment

begin_function
name|void
name|audit_filter_getcookie
parameter_list|(
name|void
modifier|*
name|instance
parameter_list|,
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|auditfilter_module
modifier|*
name|am
decl_stmt|;
name|am
operator|=
operator|(
expr|struct
name|auditfilter_module
operator|*
operator|)
name|instance
expr_stmt|;
operator|*
name|cookie
operator|=
name|am
operator|->
name|am_cookie
expr_stmt|;
block|}
end_function

begin_function
name|void
name|audit_filter_setcookie
parameter_list|(
name|void
modifier|*
name|instance
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|auditfilter_module
modifier|*
name|am
decl_stmt|;
name|am
operator|=
operator|(
expr|struct
name|auditfilter_module
operator|*
operator|)
name|instance
expr_stmt|;
name|am
operator|->
name|am_cookie
operator|=
name|cookie
expr_stmt|;
block|}
end_function

end_unit

