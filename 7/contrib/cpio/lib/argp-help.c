begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hierarchial argument parsing help output    Copyright (C) 1995-2003, 2004 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Written by Miles Bader<miles@gnu.ai.mit.edu>.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_undef
undef|#
directive|undef
name|dgettext
end_undef

begin_define
define|#
directive|define
name|dgettext
parameter_list|(
name|domain
parameter_list|,
name|msgid
parameter_list|)
define|\
value|INTUSE(__dcgettext) (domain, msgid, LC_MESSAGES)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"gettext.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"argp.h"
end_include

begin_include
include|#
directive|include
file|"argp-fmtstream.h"
end_include

begin_include
include|#
directive|include
file|"argp-namefrob.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_MAX
end_ifndef

begin_define
define|#
directive|define
name|SIZE_MAX
value|((size_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* User-selectable (using an environment variable) formatting parameters.     These may be specified in an environment variable called `ARGP_HELP_FMT',    with a contents like:  VAR1=VAL1,VAR2=VAL2,BOOLVAR2,no-BOOLVAR2    Where VALn must be a positive integer.  The list of variables is in the    UPARAM_NAMES vector, below.  */
end_comment

begin_comment
comment|/* Default parameters.  */
end_comment

begin_define
define|#
directive|define
name|DUP_ARGS
value|0
end_define

begin_comment
comment|/* True if option argument can be duplicated. */
end_comment

begin_define
define|#
directive|define
name|DUP_ARGS_NOTE
value|1
end_define

begin_comment
comment|/* True to print a note about duplicate args. */
end_comment

begin_define
define|#
directive|define
name|SHORT_OPT_COL
value|2
end_define

begin_comment
comment|/* column in which short options start */
end_comment

begin_define
define|#
directive|define
name|LONG_OPT_COL
value|6
end_define

begin_comment
comment|/* column in which long options start */
end_comment

begin_define
define|#
directive|define
name|DOC_OPT_COL
value|2
end_define

begin_comment
comment|/* column in which doc options start */
end_comment

begin_define
define|#
directive|define
name|OPT_DOC_COL
value|29
end_define

begin_comment
comment|/* column in which option text starts */
end_comment

begin_define
define|#
directive|define
name|HEADER_COL
value|1
end_define

begin_comment
comment|/* column in which group headers are printed */
end_comment

begin_define
define|#
directive|define
name|USAGE_INDENT
value|12
end_define

begin_comment
comment|/* indentation of wrapped usage lines */
end_comment

begin_define
define|#
directive|define
name|RMARGIN
value|79
end_define

begin_comment
comment|/* right margin used for wrapping */
end_comment

begin_comment
comment|/* User-selectable (using an environment variable) formatting parameters.    They must all be of type `int' for the parsing code to work.  */
end_comment

begin_struct
struct|struct
name|uparams
block|{
comment|/* If true, arguments for an option are shown with both short and long      options, even when a given option has both, e.g. `-x ARG, --longx=ARG'.      If false, then if an option has both, the argument is only shown with      the long one, e.g., `-x, --longx=ARG', and a message indicating that      this really means both is printed below the options.  */
name|int
name|dup_args
decl_stmt|;
comment|/* This is true if when DUP_ARGS is false, and some duplicate arguments have      been suppressed, an explanatory message should be printed.  */
name|int
name|dup_args_note
decl_stmt|;
comment|/* Various output columns.  */
name|int
name|short_opt_col
decl_stmt|;
name|int
name|long_opt_col
decl_stmt|;
name|int
name|doc_opt_col
decl_stmt|;
name|int
name|opt_doc_col
decl_stmt|;
name|int
name|header_col
decl_stmt|;
name|int
name|usage_indent
decl_stmt|;
name|int
name|rmargin
decl_stmt|;
name|int
name|valid
decl_stmt|;
comment|/* True when the values in here are valid.  */
block|}
struct|;
end_struct

begin_comment
comment|/* This is a global variable, as user options are only ever read once.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uparams
name|uparams
init|=
block|{
name|DUP_ARGS
block|,
name|DUP_ARGS_NOTE
block|,
name|SHORT_OPT_COL
block|,
name|LONG_OPT_COL
block|,
name|DOC_OPT_COL
block|,
name|OPT_DOC_COL
block|,
name|HEADER_COL
block|,
name|USAGE_INDENT
block|,
name|RMARGIN
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A particular uparam, and what the user name is.  */
end_comment

begin_struct
struct|struct
name|uparam_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* User name.  */
name|int
name|is_bool
decl_stmt|;
comment|/* Whether it's `boolean'.  */
name|size_t
name|uparams_offs
decl_stmt|;
comment|/* Location of the (int) field in UPARAMS.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The name-field mappings we know about.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uparam_name
name|uparam_names
index|[]
init|=
block|{
block|{
literal|"dup-args"
block|,
literal|1
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|dup_args
argument_list|)
block|}
block|,
block|{
literal|"dup-args-note"
block|,
literal|1
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|dup_args_note
argument_list|)
block|}
block|,
block|{
literal|"short-opt-col"
block|,
literal|0
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|short_opt_col
argument_list|)
block|}
block|,
block|{
literal|"long-opt-col"
block|,
literal|0
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|long_opt_col
argument_list|)
block|}
block|,
block|{
literal|"doc-opt-col"
block|,
literal|0
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|doc_opt_col
argument_list|)
block|}
block|,
block|{
literal|"opt-doc-col"
block|,
literal|0
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|opt_doc_col
argument_list|)
block|}
block|,
block|{
literal|"header-col"
block|,
literal|0
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|header_col
argument_list|)
block|}
block|,
block|{
literal|"usage-indent"
block|,
literal|0
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|usage_indent
argument_list|)
block|}
block|,
block|{
literal|"rmargin"
block|,
literal|0
block|,
name|offsetof
argument_list|(
argument|struct uparams
argument_list|,
argument|rmargin
argument_list|)
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read user options from the environment, and fill in UPARAMS appropiately.  */
end_comment

begin_function
specifier|static
name|void
name|fill_in_uparams
parameter_list|(
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|var
init|=
name|getenv
argument_list|(
literal|"ARGP_HELP_FMT"
argument_list|)
decl_stmt|;
define|#
directive|define
name|SKIPWS
parameter_list|(
name|p
parameter_list|)
value|do { while (isspace (*p)) p++; } while (0);
if|if
condition|(
name|var
condition|)
comment|/* Parse var. */
while|while
condition|(
operator|*
name|var
condition|)
block|{
name|SKIPWS
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|var
argument_list|)
condition|)
block|{
name|size_t
name|var_len
decl_stmt|;
specifier|const
name|struct
name|uparam_name
modifier|*
name|un
decl_stmt|;
name|int
name|unspec
init|=
literal|0
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
init|=
name|var
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|arg
argument_list|)
operator|||
operator|*
name|arg
operator|==
literal|'-'
operator|||
operator|*
name|arg
operator|==
literal|'_'
condition|)
name|arg
operator|++
expr_stmt|;
name|var_len
operator|=
name|arg
operator|-
name|var
expr_stmt|;
name|SKIPWS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
operator|||
operator|*
name|arg
operator|==
literal|','
condition|)
name|unspec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|==
literal|'='
condition|)
block|{
name|arg
operator|++
expr_stmt|;
name|SKIPWS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unspec
condition|)
block|{
if|if
condition|(
name|var
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|var
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|var
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|var
operator|+=
literal|3
expr_stmt|;
name|var_len
operator|-=
literal|3
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|val
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
name|arg
operator|++
expr_stmt|;
name|SKIPWS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|un
operator|=
name|uparam_names
init|;
name|un
operator|->
name|name
condition|;
name|un
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
name|un
operator|->
name|name
argument_list|)
operator|==
name|var_len
operator|&&
name|strncmp
argument_list|(
name|var
argument_list|,
name|un
operator|->
name|name
argument_list|,
name|var_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|unspec
operator|&&
operator|!
name|un
operator|->
name|is_bool
condition|)
name|__argp_failure
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dgettext
argument_list|(
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
literal|"\ %.*s: ARGP_HELP_FMT parameter requires a value"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|var_len
argument_list|,
name|var
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uparams
operator|+
name|un
operator|->
name|uparams_offs
operator|)
operator|=
name|val
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|un
operator|->
name|name
condition|)
name|__argp_failure
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dgettext
argument_list|(
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
literal|"\ %.*s: Unknown ARGP_HELP_FMT parameter"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|var_len
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|var
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|var
operator|==
literal|','
condition|)
name|var
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|var
condition|)
block|{
name|__argp_failure
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dgettext
argument_list|(
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
literal|"Garbage in ARGP_HELP_FMT: %s"
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns true if OPT hasn't been marked invisible.  Visibility only affects    whether OPT is displayed or used in sorting, not option shadowing.  */
end_comment

begin_define
define|#
directive|define
name|ovisible
parameter_list|(
name|opt
parameter_list|)
value|(! ((opt)->flags& OPTION_HIDDEN))
end_define

begin_comment
comment|/* Returns true if OPT is an alias for an earlier option.  */
end_comment

begin_define
define|#
directive|define
name|oalias
parameter_list|(
name|opt
parameter_list|)
value|((opt)->flags& OPTION_ALIAS)
end_define

begin_comment
comment|/* Returns true if OPT is an documentation-only entry.  */
end_comment

begin_define
define|#
directive|define
name|odoc
parameter_list|(
name|opt
parameter_list|)
value|((opt)->flags& OPTION_DOC)
end_define

begin_comment
comment|/* Returns true if OPT should not be translated */
end_comment

begin_define
define|#
directive|define
name|onotrans
parameter_list|(
name|opt
parameter_list|)
value|((opt)->flags& OPTION_NO_TRANS)
end_define

begin_comment
comment|/* Returns true if OPT is the end-of-list marker for a list of options.  */
end_comment

begin_define
define|#
directive|define
name|oend
parameter_list|(
name|opt
parameter_list|)
value|__option_is_end (opt)
end_define

begin_comment
comment|/* Returns true if OPT has a short option.  */
end_comment

begin_define
define|#
directive|define
name|oshort
parameter_list|(
name|opt
parameter_list|)
value|__option_is_short (opt)
end_define

begin_escape
end_escape

begin_comment
comment|/*    The help format for a particular option is like:       -xARG, -yARG, --long1=ARG, --long2=ARG        Documentation...     Where ARG will be omitted if there's no argument, for this option, or    will be surrounded by "[" and "]" appropiately if the argument is    optional.  The documentation string is word-wrapped appropiately, and if    the list of options is long enough, it will be started on a separate line.    If there are no short options for a given option, the first long option is    indented slighly in a way that's supposed to make most long options appear    to be in a separate column.     For example, the following output (from ps):       -p PID, --pid=PID          List the process PID 	 --pgrp=PGRP            List processes in the process group PGRP      -P, -x, --no-parent        Include processes without parents      -Q, --all-fields           Don't elide unusable fields (normally if there's 				some reason ps can't print a field for any 				process, it's removed from the output entirely)      -r, --reverse, --gratuitously-long-reverse-option 				Reverse the order of any sort 	 --session[=SID]        Add the processes from the session SID (which 				defaults to the sid of the current process)      Here are some more options:      -f ZOT, --foonly=ZOT       Glork a foonly      -z, --zaza                 Snit a zar       -?, --help                 Give this help list 	 --usage                Give a short usage message      -V, --version              Print program version     The struct argp_option array for the above could look like:     {      {"pid",       'p',      "PID",  0, "List the process PID"},      {"pgrp",      OPT_PGRP, "PGRP", 0, "List processes in the process group PGRP"},      {"no-parent", 'P',	      0,     0, "Include processes without parents"},      {0,           'x',       0,     OPTION_ALIAS},      {"all-fields",'Q',       0,     0, "Don't elide unusable fields (normally"                                         " if there's some reason ps can't" 					" print a field for any process, it's"                                         " removed from the output entirely)" },      {"reverse",   'r',       0,     0, "Reverse the order of any sort"},      {"gratuitously-long-reverse-option", 0, 0, OPTION_ALIAS},      {"session",   OPT_SESS,  "SID", OPTION_ARG_OPTIONAL,                                         "Add the processes from the session" 					" SID (which defaults to the sid of" 					" the current process)" },       {0,0,0,0, "Here are some more options:"},      {"foonly", 'f', "ZOT", 0, "Glork a foonly"},      {"zaza", 'z', 0, 0, "Snit a zar"},       {0}    }     Note that the last three options are automatically supplied by argp_parse,    unless you tell it not to with ARGP_NO_HELP.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Returns true if CH occurs between BEG and END.  */
end_comment

begin_function
specifier|static
name|int
name|find_char
parameter_list|(
name|char
name|ch
parameter_list|,
name|char
modifier|*
name|beg
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
while|while
condition|(
name|beg
operator|<
name|end
condition|)
if|if
condition|(
operator|*
name|beg
operator|==
name|ch
condition|)
return|return
literal|1
return|;
else|else
name|beg
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_struct_decl
struct_decl|struct
name|hol_cluster
struct_decl|;
end_struct_decl

begin_comment
comment|/* fwd decl */
end_comment

begin_struct
struct|struct
name|hol_entry
block|{
comment|/* First option.  */
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
decl_stmt|;
comment|/* Number of options (including aliases).  */
name|unsigned
name|num
decl_stmt|;
comment|/* A pointers into the HOL's short_options field, to the first short option      letter for this entry.  The order of the characters following this point      corresponds to the order of options pointed to by OPT, and there are at      most NUM.  A short option recorded in a option following OPT is only      valid if it occurs in the right place in SHORT_OPTIONS (otherwise it's      probably been shadowed by some other entry).  */
name|char
modifier|*
name|short_options
decl_stmt|;
comment|/* Entries are sorted by their group first, in the order:        1, 2, ..., n, 0, -m, ..., -2, -1      and then alphabetically within each group.  The default is 0.  */
name|int
name|group
decl_stmt|;
comment|/* The cluster of options this entry belongs to, or 0 if none.  */
name|struct
name|hol_cluster
modifier|*
name|cluster
decl_stmt|;
comment|/* The argp from which this option came.  */
specifier|const
name|struct
name|argp
modifier|*
name|argp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A cluster of entries to reflect the argp tree structure.  */
end_comment

begin_struct
struct|struct
name|hol_cluster
block|{
comment|/* A descriptive header printed before options in this cluster.  */
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
comment|/* Used to order clusters within the same group with the same parent,      according to the order in which they occurred in the parent argp's child      list.  */
name|int
name|index
decl_stmt|;
comment|/* How to sort this cluster with respect to options and other clusters at the      same depth (clusters always follow options in the same group).  */
name|int
name|group
decl_stmt|;
comment|/* The cluster to which this cluster belongs, or 0 if it's at the base      level.  */
name|struct
name|hol_cluster
modifier|*
name|parent
decl_stmt|;
comment|/* The argp from which this cluster is (eventually) derived.  */
specifier|const
name|struct
name|argp
modifier|*
name|argp
decl_stmt|;
comment|/* The distance this cluster is from the root.  */
name|int
name|depth
decl_stmt|;
comment|/* Clusters in a given hol are kept in a linked list, to make freeing them      possible.  */
name|struct
name|hol_cluster
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of options for help.  */
end_comment

begin_struct
struct|struct
name|hol
block|{
comment|/* An array of hol_entry's.  */
name|struct
name|hol_entry
modifier|*
name|entries
decl_stmt|;
comment|/* The number of entries in this hol.  If this field is zero, the others      are undefined.  */
name|unsigned
name|num_entries
decl_stmt|;
comment|/* A string containing all short options in this HOL.  Each entry contains      pointers into this string, so the order can't be messed with blindly.  */
name|char
modifier|*
name|short_options
decl_stmt|;
comment|/* Clusters of entries in this hol.  */
name|struct
name|hol_cluster
modifier|*
name|clusters
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Create a struct hol from the options in ARGP.  CLUSTER is the    hol_cluster in which these entries occur, or 0, if at the root.  */
end_comment

begin_function
specifier|static
name|struct
name|hol
modifier|*
name|make_hol
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|struct
name|hol_cluster
modifier|*
name|cluster
parameter_list|)
block|{
name|char
modifier|*
name|so
decl_stmt|;
specifier|const
name|struct
name|argp_option
modifier|*
name|o
decl_stmt|;
specifier|const
name|struct
name|argp_option
modifier|*
name|opts
init|=
name|argp
operator|->
name|options
decl_stmt|;
name|struct
name|hol_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|num_short_options
init|=
literal|0
decl_stmt|;
name|struct
name|hol
modifier|*
name|hol
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hol
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|hol
argument_list|)
expr_stmt|;
name|hol
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
name|hol
operator|->
name|clusters
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opts
condition|)
block|{
name|int
name|cur_group
init|=
literal|0
decl_stmt|;
comment|/* The first option must not be an alias.  */
name|assert
argument_list|(
operator|!
name|oalias
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate the space needed.  */
for|for
control|(
name|o
operator|=
name|opts
init|;
operator|!
name|oend
argument_list|(
name|o
argument_list|)
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|oalias
argument_list|(
name|o
argument_list|)
condition|)
name|hol
operator|->
name|num_entries
operator|++
expr_stmt|;
if|if
condition|(
name|oshort
argument_list|(
name|o
argument_list|)
condition|)
name|num_short_options
operator|++
expr_stmt|;
comment|/* This is an upper bound.  */
block|}
name|hol
operator|->
name|entries
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hol_entry
argument_list|)
operator|*
name|hol
operator|->
name|num_entries
argument_list|)
expr_stmt|;
name|hol
operator|->
name|short_options
operator|=
name|malloc
argument_list|(
name|num_short_options
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|hol
operator|->
name|entries
operator|&&
name|hol
operator|->
name|short_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIZE_MAX
operator|<=
name|UINT_MAX
condition|)
name|assert
argument_list|(
name|hol
operator|->
name|num_entries
operator|<=
name|SIZE_MAX
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|hol_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the entries.  */
name|so
operator|=
name|hol
operator|->
name|short_options
expr_stmt|;
for|for
control|(
name|o
operator|=
name|opts
operator|,
name|entry
operator|=
name|hol
operator|->
name|entries
init|;
operator|!
name|oend
argument_list|(
name|o
argument_list|)
condition|;
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|opt
operator|=
name|o
expr_stmt|;
name|entry
operator|->
name|num
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|short_options
operator|=
name|so
expr_stmt|;
name|entry
operator|->
name|group
operator|=
name|cur_group
operator|=
name|o
operator|->
name|group
condition|?
name|o
operator|->
name|group
else|:
operator|(
operator|(
operator|!
name|o
operator|->
name|name
operator|&&
operator|!
name|o
operator|->
name|key
operator|)
condition|?
name|cur_group
operator|+
literal|1
else|:
name|cur_group
operator|)
expr_stmt|;
name|entry
operator|->
name|cluster
operator|=
name|cluster
expr_stmt|;
name|entry
operator|->
name|argp
operator|=
name|argp
expr_stmt|;
do|do
block|{
name|entry
operator|->
name|num
operator|++
expr_stmt|;
if|if
condition|(
name|oshort
argument_list|(
name|o
argument_list|)
operator|&&
operator|!
name|find_char
argument_list|(
name|o
operator|->
name|key
argument_list|,
name|hol
operator|->
name|short_options
argument_list|,
name|so
argument_list|)
condition|)
comment|/* O has a valid short option which hasn't already been used.*/
operator|*
name|so
operator|++
operator|=
name|o
operator|->
name|key
expr_stmt|;
name|o
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|oend
argument_list|(
name|o
argument_list|)
operator|&&
name|oalias
argument_list|(
name|o
argument_list|)
condition|)
do|;
block|}
operator|*
name|so
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminated so we can find the length */
block|}
return|return
name|hol
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a new cluster to HOL, with the given GROUP and HEADER (taken from the    associated argp child list entry), INDEX, and PARENT, and return a pointer    to it.  ARGP is the argp that this cluster results from.  */
end_comment

begin_function
specifier|static
name|struct
name|hol_cluster
modifier|*
name|hol_add_cluster
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|,
name|int
name|group
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|hol_cluster
modifier|*
name|parent
parameter_list|,
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|)
block|{
name|struct
name|hol_cluster
modifier|*
name|cl
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hol_cluster
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cl
condition|)
block|{
name|cl
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|cl
operator|->
name|header
operator|=
name|header
expr_stmt|;
name|cl
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|cl
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|cl
operator|->
name|argp
operator|=
name|argp
expr_stmt|;
name|cl
operator|->
name|depth
operator|=
name|parent
condition|?
name|parent
operator|->
name|depth
operator|+
literal|1
else|:
literal|0
expr_stmt|;
name|cl
operator|->
name|next
operator|=
name|hol
operator|->
name|clusters
expr_stmt|;
name|hol
operator|->
name|clusters
operator|=
name|cl
expr_stmt|;
block|}
return|return
name|cl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free HOL and any resources it uses.  */
end_comment

begin_function
specifier|static
name|void
name|hol_free
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|)
block|{
name|struct
name|hol_cluster
modifier|*
name|cl
init|=
name|hol
operator|->
name|clusters
decl_stmt|;
while|while
condition|(
name|cl
condition|)
block|{
name|struct
name|hol_cluster
modifier|*
name|next
init|=
name|cl
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|cl
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|hol
operator|->
name|num_entries
operator|>
literal|0
condition|)
block|{
name|free
argument_list|(
name|hol
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hol
operator|->
name|short_options
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|hol_entry_short_iterate
parameter_list|(
specifier|const
name|struct
name|hol_entry
modifier|*
name|entry
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
parameter_list|,
specifier|const
name|struct
name|argp_option
modifier|*
name|real
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|unsigned
name|nopts
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
decl_stmt|,
modifier|*
name|real
init|=
name|entry
operator|->
name|opt
decl_stmt|;
name|char
modifier|*
name|so
init|=
name|entry
operator|->
name|short_options
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|real
operator|,
name|nopts
operator|=
name|entry
operator|->
name|num
init|;
name|nopts
operator|>
literal|0
operator|&&
operator|!
name|val
condition|;
name|opt
operator|++
operator|,
name|nopts
operator|--
control|)
if|if
condition|(
name|oshort
argument_list|(
name|opt
argument_list|)
operator|&&
operator|*
name|so
operator|==
name|opt
operator|->
name|key
condition|)
block|{
if|if
condition|(
operator|!
name|oalias
argument_list|(
name|opt
argument_list|)
condition|)
name|real
operator|=
name|opt
expr_stmt|;
if|if
condition|(
name|ovisible
argument_list|(
name|opt
argument_list|)
condition|)
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|opt
argument_list|,
name|real
argument_list|,
name|domain
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|so
operator|++
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|__attribute__
argument_list|(
operator|(
name|always_inline
operator|)
argument_list|)
name|hol_entry_long_iterate
argument_list|(
specifier|const
expr|struct
name|hol_entry
operator|*
name|entry
argument_list|,
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
specifier|const
expr|struct
name|argp_option
operator|*
name|opt
argument_list|,
specifier|const
expr|struct
name|argp_option
operator|*
name|real
argument_list|,
specifier|const
name|char
operator|*
name|domain
argument_list|,
name|void
operator|*
name|cookie
argument_list|)
argument_list|,
specifier|const
name|char
operator|*
name|domain
argument_list|,
name|void
operator|*
name|cookie
argument_list|)
block|{
name|unsigned
name|nopts
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
decl_stmt|,
modifier|*
name|real
init|=
name|entry
operator|->
name|opt
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|real
operator|,
name|nopts
operator|=
name|entry
operator|->
name|num
init|;
name|nopts
operator|>
literal|0
operator|&&
operator|!
name|val
condition|;
name|opt
operator|++
operator|,
name|nopts
operator|--
control|)
if|if
condition|(
name|opt
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|oalias
argument_list|(
name|opt
argument_list|)
condition|)
name|real
operator|=
name|opt
expr_stmt|;
if|if
condition|(
name|ovisible
argument_list|(
name|opt
argument_list|)
condition|)
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|opt
argument_list|,
name|real
argument_list|,
name|domain
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Iterator that returns true for the first short option.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|until_short
parameter_list|(
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
parameter_list|,
specifier|const
name|struct
name|argp_option
modifier|*
name|real
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
return|return
name|oshort
argument_list|(
name|opt
argument_list|)
condition|?
name|opt
operator|->
name|key
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the first valid short option in ENTRY, or 0 if there is none.  */
end_comment

begin_function
specifier|static
name|char
name|hol_entry_first_short
parameter_list|(
specifier|const
name|struct
name|hol_entry
modifier|*
name|entry
parameter_list|)
block|{
return|return
name|hol_entry_short_iterate
argument_list|(
name|entry
argument_list|,
name|until_short
argument_list|,
name|entry
operator|->
name|argp
operator|->
name|argp_domain
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the first valid long option in ENTRY, or 0 if there is none.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hol_entry_first_long
parameter_list|(
specifier|const
name|struct
name|hol_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
decl_stmt|;
name|unsigned
name|num
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|entry
operator|->
name|opt
operator|,
name|num
operator|=
name|entry
operator|->
name|num
init|;
name|num
operator|>
literal|0
condition|;
name|opt
operator|++
operator|,
name|num
operator|--
control|)
if|if
condition|(
name|opt
operator|->
name|name
operator|&&
name|ovisible
argument_list|(
name|opt
argument_list|)
condition|)
return|return
name|opt
operator|->
name|name
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the entry in HOL with the long option name NAME, or 0 if there is    none.  */
end_comment

begin_function
specifier|static
name|struct
name|hol_entry
modifier|*
name|hol_find_entry
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|hol_entry
modifier|*
name|entry
init|=
name|hol
operator|->
name|entries
decl_stmt|;
name|unsigned
name|num_entries
init|=
name|hol
operator|->
name|num_entries
decl_stmt|;
while|while
condition|(
name|num_entries
operator|--
operator|>
literal|0
condition|)
block|{
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
init|=
name|entry
operator|->
name|opt
decl_stmt|;
name|unsigned
name|num_opts
init|=
name|entry
operator|->
name|num
decl_stmt|;
while|while
condition|(
name|num_opts
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
name|opt
operator|->
name|name
operator|&&
name|ovisible
argument_list|(
name|opt
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|opt
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|entry
return|;
else|else
name|opt
operator|++
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If an entry with the long option NAME occurs in HOL, set it's special    sort position to GROUP.  */
end_comment

begin_function
specifier|static
name|void
name|hol_set_group
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|group
parameter_list|)
block|{
name|struct
name|hol_entry
modifier|*
name|entry
init|=
name|hol_find_entry
argument_list|(
name|hol
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry
operator|->
name|group
operator|=
name|group
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Order by group:  0, 1, 2, ..., n, -m, ..., -2, -1.    EQ is what to return if GROUP1 and GROUP2 are the same.  */
end_comment

begin_function
specifier|static
name|int
name|group_cmp
parameter_list|(
name|int
name|group1
parameter_list|,
name|int
name|group2
parameter_list|,
name|int
name|eq
parameter_list|)
block|{
if|if
condition|(
name|group1
operator|==
name|group2
condition|)
return|return
name|eq
return|;
elseif|else
if|if
condition|(
operator|(
name|group1
operator|<
literal|0
operator|&&
name|group2
operator|<
literal|0
operator|)
operator|||
operator|(
name|group1
operator|>=
literal|0
operator|&&
name|group2
operator|>=
literal|0
operator|)
condition|)
return|return
name|group1
operator|-
name|group2
return|;
else|else
return|return
name|group2
operator|-
name|group1
return|;
block|}
end_function

begin_comment
comment|/* Compare clusters CL1& CL2 by the order that they should appear in    output.  */
end_comment

begin_function
specifier|static
name|int
name|hol_cluster_cmp
parameter_list|(
specifier|const
name|struct
name|hol_cluster
modifier|*
name|cl1
parameter_list|,
specifier|const
name|struct
name|hol_cluster
modifier|*
name|cl2
parameter_list|)
block|{
comment|/* If one cluster is deeper than the other, use its ancestor at the same      level, so that finding the common ancestor is straightforward.  */
while|while
condition|(
name|cl1
operator|->
name|depth
operator|<
name|cl2
operator|->
name|depth
condition|)
name|cl1
operator|=
name|cl1
operator|->
name|parent
expr_stmt|;
while|while
condition|(
name|cl2
operator|->
name|depth
operator|<
name|cl1
operator|->
name|depth
condition|)
name|cl2
operator|=
name|cl2
operator|->
name|parent
expr_stmt|;
comment|/* Now reduce both clusters to their ancestors at the point where both have      a common parent; these can be directly compared.  */
while|while
condition|(
name|cl1
operator|->
name|parent
operator|!=
name|cl2
operator|->
name|parent
condition|)
name|cl1
operator|=
name|cl1
operator|->
name|parent
operator|,
name|cl2
operator|=
name|cl2
operator|->
name|parent
expr_stmt|;
return|return
name|group_cmp
argument_list|(
name|cl1
operator|->
name|group
argument_list|,
name|cl2
operator|->
name|group
argument_list|,
name|cl2
operator|->
name|index
operator|-
name|cl1
operator|->
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the ancestor of CL that's just below the root (i.e., has a parent    of 0).  */
end_comment

begin_function
specifier|static
name|struct
name|hol_cluster
modifier|*
name|hol_cluster_base
parameter_list|(
name|struct
name|hol_cluster
modifier|*
name|cl
parameter_list|)
block|{
while|while
condition|(
name|cl
operator|->
name|parent
condition|)
name|cl
operator|=
name|cl
operator|->
name|parent
expr_stmt|;
return|return
name|cl
return|;
block|}
end_function

begin_comment
comment|/* Return true if CL1 is a child of CL2.  */
end_comment

begin_function
specifier|static
name|int
name|hol_cluster_is_child
parameter_list|(
specifier|const
name|struct
name|hol_cluster
modifier|*
name|cl1
parameter_list|,
specifier|const
name|struct
name|hol_cluster
modifier|*
name|cl2
parameter_list|)
block|{
while|while
condition|(
name|cl1
operator|&&
name|cl1
operator|!=
name|cl2
condition|)
name|cl1
operator|=
name|cl1
operator|->
name|parent
expr_stmt|;
return|return
name|cl1
operator|==
name|cl2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given the name of a OPTION_DOC option, modifies NAME to start at the tail    that should be used for comparisons, and returns true iff it should be    treated as a non-option.  */
end_comment

begin_function
specifier|static
name|int
name|canon_doc_option
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|int
name|non_opt
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
name|non_opt
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Skip initial whitespace.  */
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|name
argument_list|)
condition|)
operator|(
operator|*
name|name
operator|)
operator|++
expr_stmt|;
comment|/* Decide whether this looks like an option (leading `-') or not.  */
name|non_opt
operator|=
operator|(
operator|*
operator|*
name|name
operator|!=
literal|'-'
operator|)
expr_stmt|;
comment|/* Skip until part of name used for sorting.  */
while|while
condition|(
operator|*
operator|*
name|name
operator|&&
operator|!
name|isalnum
argument_list|(
operator|*
operator|*
name|name
argument_list|)
condition|)
operator|(
operator|*
name|name
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|non_opt
return|;
block|}
end_function

begin_comment
comment|/* Order ENTRY1& ENTRY2 by the order which they should appear in a help    listing.  */
end_comment

begin_function
specifier|static
name|int
name|hol_entry_cmp
parameter_list|(
specifier|const
name|struct
name|hol_entry
modifier|*
name|entry1
parameter_list|,
specifier|const
name|struct
name|hol_entry
modifier|*
name|entry2
parameter_list|)
block|{
comment|/* The group numbers by which the entries should be ordered; if either is      in a cluster, then this is just the group within the cluster.  */
name|int
name|group1
init|=
name|entry1
operator|->
name|group
decl_stmt|,
name|group2
init|=
name|entry2
operator|->
name|group
decl_stmt|;
if|if
condition|(
name|entry1
operator|->
name|cluster
operator|!=
name|entry2
operator|->
name|cluster
condition|)
block|{
comment|/* The entries are not within the same cluster, so we can't compare them 	 directly, we have to use the appropiate clustering level too.  */
if|if
condition|(
operator|!
name|entry1
operator|->
name|cluster
condition|)
comment|/* ENTRY1 is at the `base level', not in a cluster, so we have to 	   compare it's group number with that of the base cluster in which 	   ENTRY2 resides.  Note that if they're in the same group, the 	   clustered option always comes laster.  */
return|return
name|group_cmp
argument_list|(
name|group1
argument_list|,
name|hol_cluster_base
argument_list|(
name|entry2
operator|->
name|cluster
argument_list|)
operator|->
name|group
argument_list|,
operator|-
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|entry2
operator|->
name|cluster
condition|)
comment|/* Likewise, but ENTRY2's not in a cluster.  */
return|return
name|group_cmp
argument_list|(
name|hol_cluster_base
argument_list|(
name|entry1
operator|->
name|cluster
argument_list|)
operator|->
name|group
argument_list|,
name|group2
argument_list|,
literal|1
argument_list|)
return|;
else|else
comment|/* Both entries are in clusters, we can just compare the clusters.  */
return|return
name|hol_cluster_cmp
argument_list|(
name|entry1
operator|->
name|cluster
argument_list|,
name|entry2
operator|->
name|cluster
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|group1
operator|==
name|group2
condition|)
comment|/* The entries are both in the same cluster and group, so compare them        alphabetically.  */
block|{
name|int
name|short1
init|=
name|hol_entry_first_short
argument_list|(
name|entry1
argument_list|)
decl_stmt|;
name|int
name|short2
init|=
name|hol_entry_first_short
argument_list|(
name|entry2
argument_list|)
decl_stmt|;
name|int
name|doc1
init|=
name|odoc
argument_list|(
name|entry1
operator|->
name|opt
argument_list|)
decl_stmt|;
name|int
name|doc2
init|=
name|odoc
argument_list|(
name|entry2
operator|->
name|opt
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|long1
init|=
name|hol_entry_first_long
argument_list|(
name|entry1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|long2
init|=
name|hol_entry_first_long
argument_list|(
name|entry2
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc1
condition|)
name|doc1
operator|=
name|canon_doc_option
argument_list|(
operator|&
name|long1
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc2
condition|)
name|doc2
operator|=
name|canon_doc_option
argument_list|(
operator|&
name|long2
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc1
operator|!=
name|doc2
condition|)
comment|/* `documentation' options always follow normal options (or 	   documentation options that *look* like normal options).  */
return|return
name|doc1
operator|-
name|doc2
return|;
elseif|else
if|if
condition|(
operator|!
name|short1
operator|&&
operator|!
name|short2
operator|&&
name|long1
operator|&&
name|long2
condition|)
comment|/* Only long options.  */
return|return
name|__strcasecmp
argument_list|(
name|long1
argument_list|,
name|long2
argument_list|)
return|;
else|else
comment|/* Compare short/short, long/short, short/long, using the first 	   character of long options.  Entries without *any* valid 	   options (such as options with OPTION_HIDDEN set) will be put 	   first, but as they're not displayed, it doesn't matter where 	   they are.  */
block|{
name|char
name|first1
init|=
name|short1
condition|?
name|short1
else|:
name|long1
condition|?
operator|*
name|long1
else|:
literal|0
decl_stmt|;
name|char
name|first2
init|=
name|short2
condition|?
name|short2
else|:
name|long2
condition|?
operator|*
name|long2
else|:
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|_tolower
name|int
name|lower_cmp
init|=
name|_tolower
argument_list|(
name|first1
argument_list|)
operator|-
name|_tolower
argument_list|(
name|first2
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|lower_cmp
init|=
name|tolower
argument_list|(
name|first1
argument_list|)
operator|-
name|tolower
argument_list|(
name|first2
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Compare ignoring case, except when the options are both the 	     same letter, in which case lower-case always comes first.  */
return|return
name|lower_cmp
condition|?
name|lower_cmp
else|:
name|first2
operator|-
name|first1
return|;
block|}
block|}
else|else
comment|/* Within the same cluster, but not the same group, so just compare        groups.  */
return|return
name|group_cmp
argument_list|(
name|group1
argument_list|,
name|group2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Version of hol_entry_cmp with correct signature for qsort.  */
end_comment

begin_function
specifier|static
name|int
name|hol_entry_qcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1_v
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2_v
parameter_list|)
block|{
return|return
name|hol_entry_cmp
argument_list|(
name|entry1_v
argument_list|,
name|entry2_v
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort HOL by group and alphabetically by option name (with short options    taking precedence over long).  Since the sorting is for display purposes    only, the shadowing of options isn't effected.  */
end_comment

begin_function
specifier|static
name|void
name|hol_sort
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|)
block|{
if|if
condition|(
name|hol
operator|->
name|num_entries
operator|>
literal|0
condition|)
name|qsort
argument_list|(
name|hol
operator|->
name|entries
argument_list|,
name|hol
operator|->
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hol_entry
argument_list|)
argument_list|,
name|hol_entry_qcmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Append MORE to HOL, destroying MORE in the process.  Options in HOL shadow    any in MORE with the same name.  */
end_comment

begin_function
specifier|static
name|void
name|hol_append
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|,
name|struct
name|hol
modifier|*
name|more
parameter_list|)
block|{
name|struct
name|hol_cluster
modifier|*
modifier|*
name|cl_end
init|=
operator|&
name|hol
operator|->
name|clusters
decl_stmt|;
comment|/* Steal MORE's cluster list, and add it to the end of HOL's.  */
while|while
condition|(
operator|*
name|cl_end
condition|)
name|cl_end
operator|=
operator|&
operator|(
operator|*
name|cl_end
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|cl_end
operator|=
name|more
operator|->
name|clusters
expr_stmt|;
name|more
operator|->
name|clusters
operator|=
literal|0
expr_stmt|;
comment|/* Merge entries.  */
if|if
condition|(
name|more
operator|->
name|num_entries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|hol
operator|->
name|num_entries
operator|==
literal|0
condition|)
block|{
name|hol
operator|->
name|num_entries
operator|=
name|more
operator|->
name|num_entries
expr_stmt|;
name|hol
operator|->
name|entries
operator|=
name|more
operator|->
name|entries
expr_stmt|;
name|hol
operator|->
name|short_options
operator|=
name|more
operator|->
name|short_options
expr_stmt|;
name|more
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
comment|/* Mark MORE's fields as invalid.  */
block|}
else|else
comment|/* Append the entries in MORE to those in HOL, taking care to only add 	   non-shadowed SHORT_OPTIONS values.  */
block|{
name|unsigned
name|left
decl_stmt|;
name|char
modifier|*
name|so
decl_stmt|,
modifier|*
name|more_so
decl_stmt|;
name|struct
name|hol_entry
modifier|*
name|e
decl_stmt|;
name|unsigned
name|num_entries
init|=
name|hol
operator|->
name|num_entries
operator|+
name|more
operator|->
name|num_entries
decl_stmt|;
name|struct
name|hol_entry
modifier|*
name|entries
init|=
name|malloc
argument_list|(
name|num_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hol_entry
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|hol_so_len
init|=
name|strlen
argument_list|(
name|hol
operator|->
name|short_options
argument_list|)
decl_stmt|;
name|char
modifier|*
name|short_options
init|=
name|malloc
argument_list|(
name|hol_so_len
operator|+
name|strlen
argument_list|(
name|more
operator|->
name|short_options
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|entries
operator|&&
name|short_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIZE_MAX
operator|<=
name|UINT_MAX
condition|)
name|assert
argument_list|(
name|num_entries
operator|<=
name|SIZE_MAX
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|hol_entry
argument_list|)
argument_list|)
expr_stmt|;
name|__mempcpy
argument_list|(
name|__mempcpy
argument_list|(
name|entries
argument_list|,
name|hol
operator|->
name|entries
argument_list|,
name|hol
operator|->
name|num_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hol_entry
argument_list|)
argument_list|)
argument_list|,
name|more
operator|->
name|entries
argument_list|,
name|more
operator|->
name|num_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hol_entry
argument_list|)
argument_list|)
expr_stmt|;
name|__mempcpy
argument_list|(
name|short_options
argument_list|,
name|hol
operator|->
name|short_options
argument_list|,
name|hol_so_len
argument_list|)
expr_stmt|;
comment|/* Fix up the short options pointers from HOL.  */
for|for
control|(
name|e
operator|=
name|entries
operator|,
name|left
operator|=
name|hol
operator|->
name|num_entries
init|;
name|left
operator|>
literal|0
condition|;
name|e
operator|++
operator|,
name|left
operator|--
control|)
name|e
operator|->
name|short_options
operator|+=
operator|(
name|short_options
operator|-
name|hol
operator|->
name|short_options
operator|)
expr_stmt|;
comment|/* Now add the short options from MORE, fixing up its entries 	     too.  */
name|so
operator|=
name|short_options
operator|+
name|hol_so_len
expr_stmt|;
name|more_so
operator|=
name|more
operator|->
name|short_options
expr_stmt|;
for|for
control|(
name|left
operator|=
name|more
operator|->
name|num_entries
init|;
name|left
operator|>
literal|0
condition|;
name|e
operator|++
operator|,
name|left
operator|--
control|)
block|{
name|int
name|opts_left
decl_stmt|;
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
decl_stmt|;
name|e
operator|->
name|short_options
operator|=
name|so
expr_stmt|;
for|for
control|(
name|opts_left
operator|=
name|e
operator|->
name|num
operator|,
name|opt
operator|=
name|e
operator|->
name|opt
init|;
name|opts_left
condition|;
name|opt
operator|++
operator|,
name|opts_left
operator|--
control|)
block|{
name|int
name|ch
init|=
operator|*
name|more_so
decl_stmt|;
if|if
condition|(
name|oshort
argument_list|(
name|opt
argument_list|)
operator|&&
name|ch
operator|==
name|opt
operator|->
name|key
condition|)
comment|/* The next short option in MORE_SO, CH, is from OPT.  */
block|{
if|if
condition|(
operator|!
name|find_char
argument_list|(
name|ch
argument_list|,
name|short_options
argument_list|,
name|short_options
operator|+
name|hol_so_len
argument_list|)
condition|)
comment|/* The short option CH isn't shadowed by HOL's options, 			   so add it to the sum.  */
operator|*
name|so
operator|++
operator|=
name|ch
expr_stmt|;
name|more_so
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|so
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|hol
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hol
operator|->
name|short_options
argument_list|)
expr_stmt|;
name|hol
operator|->
name|entries
operator|=
name|entries
expr_stmt|;
name|hol
operator|->
name|num_entries
operator|=
name|num_entries
expr_stmt|;
name|hol
operator|->
name|short_options
operator|=
name|short_options
expr_stmt|;
block|}
block|}
name|hol_free
argument_list|(
name|more
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Inserts enough spaces to make sure STREAM is at column COL.  */
end_comment

begin_function
specifier|static
name|void
name|indent_to
parameter_list|(
name|argp_fmtstream_t
name|stream
parameter_list|,
name|unsigned
name|col
parameter_list|)
block|{
name|int
name|needed
init|=
name|col
operator|-
name|__argp_fmtstream_point
argument_list|(
name|stream
argument_list|)
decl_stmt|;
while|while
condition|(
name|needed
operator|--
operator|>
literal|0
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output to STREAM either a space, or a newline if there isn't room for at    least ENSURE characters before the right margin.  */
end_comment

begin_function
specifier|static
name|void
name|space
parameter_list|(
name|argp_fmtstream_t
name|stream
parameter_list|,
name|size_t
name|ensure
parameter_list|)
block|{
if|if
condition|(
name|__argp_fmtstream_point
argument_list|(
name|stream
argument_list|)
operator|+
name|ensure
operator|>=
name|__argp_fmtstream_rmargin
argument_list|(
name|stream
argument_list|)
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the option REAL has an argument, we print it in using the printf    format REQ_FMT or OPT_FMT depending on whether it's a required or    optional argument.  */
end_comment

begin_function
specifier|static
name|void
name|arg
parameter_list|(
specifier|const
name|struct
name|argp_option
modifier|*
name|real
parameter_list|,
specifier|const
name|char
modifier|*
name|req_fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|opt_fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|argp_fmtstream_t
name|stream
parameter_list|)
block|{
if|if
condition|(
name|real
operator|->
name|arg
condition|)
block|{
if|if
condition|(
name|real
operator|->
name|flags
operator|&
name|OPTION_ARG_OPTIONAL
condition|)
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
name|opt_fmt
argument_list|,
name|dgettext
argument_list|(
name|domain
argument_list|,
name|real
operator|->
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
name|req_fmt
argument_list|,
name|dgettext
argument_list|(
name|domain
argument_list|,
name|real
operator|->
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions for hol_entry_help.  */
end_comment

begin_comment
comment|/* State used during the execution of hol_help.  */
end_comment

begin_struct
struct|struct
name|hol_help_state
block|{
comment|/* PREV_ENTRY should contain the previous entry printed, or 0.  */
name|struct
name|hol_entry
modifier|*
name|prev_entry
decl_stmt|;
comment|/* If an entry is in a different group from the previous one, and SEP_GROUPS      is true, then a blank line will be printed before any output. */
name|int
name|sep_groups
decl_stmt|;
comment|/* True if a duplicate option argument was suppressed (only ever set if      UPARAMS.dup_args is false).  */
name|int
name|suppressed_dup_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Some state used while printing a help entry (used to communicate with    helper functions).  See the doc for hol_entry_help for more info, as most    of the fields are copied from its arguments.  */
end_comment

begin_struct
struct|struct
name|pentry_state
block|{
specifier|const
name|struct
name|hol_entry
modifier|*
name|entry
decl_stmt|;
name|argp_fmtstream_t
name|stream
decl_stmt|;
name|struct
name|hol_help_state
modifier|*
name|hhstate
decl_stmt|;
comment|/* True if nothing's been printed so far.  */
name|int
name|first
decl_stmt|;
comment|/* If non-zero, the state that was used to print this help.  */
specifier|const
name|struct
name|argp_state
modifier|*
name|state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If a user doc filter should be applied to DOC, do so.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|filter_doc
parameter_list|(
specifier|const
name|char
modifier|*
name|doc
parameter_list|,
name|int
name|key
parameter_list|,
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|argp
operator|->
name|help_filter
condition|)
comment|/* We must apply a user filter to this output.  */
block|{
name|void
modifier|*
name|input
init|=
name|__argp_input
argument_list|(
name|argp
argument_list|,
name|state
argument_list|)
decl_stmt|;
return|return
call|(
modifier|*
name|argp
operator|->
name|help_filter
call|)
argument_list|(
name|key
argument_list|,
name|doc
argument_list|,
name|input
argument_list|)
return|;
block|}
else|else
comment|/* No filter.  */
return|return
name|doc
return|;
block|}
end_function

begin_comment
comment|/* Prints STR as a header line, with the margin lines set appropiately, and    notes the fact that groups should be separated with a blank line.  ARGP is    the argp that should dictate any user doc filtering to take place.  Note    that the previous wrap margin isn't restored, but the left margin is reset    to 0.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|struct
name|pentry_state
modifier|*
name|pest
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tstr
init|=
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
name|str
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fstr
init|=
name|filter_doc
argument_list|(
name|tstr
argument_list|,
name|ARGP_KEY_HELP_HEADER
argument_list|,
name|argp
argument_list|,
name|pest
operator|->
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|fstr
condition|)
block|{
if|if
condition|(
operator|*
name|fstr
condition|)
block|{
if|if
condition|(
name|pest
operator|->
name|hhstate
operator|->
name|prev_entry
condition|)
comment|/* Precede with a blank line.  */
name|__argp_fmtstream_putc
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|indent_to
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
name|uparams
operator|.
name|header_col
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_lmargin
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
name|uparams
operator|.
name|header_col
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_wmargin
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
name|uparams
operator|.
name|header_col
argument_list|)
expr_stmt|;
name|__argp_fmtstream_puts
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
name|fstr
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_lmargin
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__argp_fmtstream_putc
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|pest
operator|->
name|hhstate
operator|->
name|sep_groups
operator|=
literal|1
expr_stmt|;
comment|/* Separate subsequent groups. */
block|}
if|if
condition|(
name|fstr
operator|!=
name|tstr
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inserts a comma if this isn't the first item on the line, and then makes    sure we're at least to column COL.  If this *is* the first item on a line,    prints any pending whitespace/headers that should precede this line. Also    clears FIRST.  */
end_comment

begin_function
specifier|static
name|void
name|comma
parameter_list|(
name|unsigned
name|col
parameter_list|,
name|struct
name|pentry_state
modifier|*
name|pest
parameter_list|)
block|{
if|if
condition|(
name|pest
operator|->
name|first
condition|)
block|{
specifier|const
name|struct
name|hol_entry
modifier|*
name|pe
init|=
name|pest
operator|->
name|hhstate
operator|->
name|prev_entry
decl_stmt|;
specifier|const
name|struct
name|hol_cluster
modifier|*
name|cl
init|=
name|pest
operator|->
name|entry
operator|->
name|cluster
decl_stmt|;
if|if
condition|(
name|pest
operator|->
name|hhstate
operator|->
name|sep_groups
operator|&&
name|pe
operator|&&
name|pest
operator|->
name|entry
operator|->
name|group
operator|!=
name|pe
operator|->
name|group
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|&&
name|cl
operator|->
name|header
operator|&&
operator|*
name|cl
operator|->
name|header
operator|&&
operator|(
operator|!
name|pe
operator|||
operator|(
name|pe
operator|->
name|cluster
operator|!=
name|cl
operator|&&
operator|!
name|hol_cluster_is_child
argument_list|(
name|pe
operator|->
name|cluster
argument_list|,
name|cl
argument_list|)
operator|)
operator|)
condition|)
comment|/* If we're changing clusters, then this must be the start of the 	   ENTRY's cluster unless that is an ancestor of the previous one 	   (in which case we had just popped into a sub-cluster for a bit). 	   If so, then print the cluster's header line.  */
block|{
name|int
name|old_wm
init|=
name|__argp_fmtstream_wmargin
argument_list|(
name|pest
operator|->
name|stream
argument_list|)
decl_stmt|;
name|print_header
argument_list|(
name|cl
operator|->
name|header
argument_list|,
name|cl
operator|->
name|argp
argument_list|,
name|pest
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_wmargin
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
name|old_wm
argument_list|)
expr_stmt|;
block|}
name|pest
operator|->
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|__argp_fmtstream_puts
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|indent_to
argument_list|(
name|pest
operator|->
name|stream
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print help for ENTRY to STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|hol_entry_help
parameter_list|(
name|struct
name|hol_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|argp_fmtstream_t
name|stream
parameter_list|,
name|struct
name|hol_help_state
modifier|*
name|hhstate
parameter_list|)
block|{
name|unsigned
name|num
decl_stmt|;
specifier|const
name|struct
name|argp_option
modifier|*
name|real
init|=
name|entry
operator|->
name|opt
decl_stmt|,
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|so
init|=
name|entry
operator|->
name|short_options
decl_stmt|;
name|int
name|have_long_opt
init|=
literal|0
decl_stmt|;
comment|/* We have any long options.  */
comment|/* Saved margins.  */
name|int
name|old_lm
init|=
name|__argp_fmtstream_set_lmargin
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|old_wm
init|=
name|__argp_fmtstream_wmargin
argument_list|(
name|stream
argument_list|)
decl_stmt|;
comment|/* PEST is a state block holding some of our variables that we'd like to      share with helper functions.  */
name|struct
name|pentry_state
name|pest
init|=
block|{
name|entry
block|,
name|stream
block|,
name|hhstate
block|,
literal|1
block|,
name|state
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|odoc
argument_list|(
name|real
argument_list|)
condition|)
for|for
control|(
name|opt
operator|=
name|real
operator|,
name|num
operator|=
name|entry
operator|->
name|num
init|;
name|num
operator|>
literal|0
condition|;
name|opt
operator|++
operator|,
name|num
operator|--
control|)
if|if
condition|(
name|opt
operator|->
name|name
operator|&&
name|ovisible
argument_list|(
name|opt
argument_list|)
condition|)
block|{
name|have_long_opt
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* First emit short options.  */
name|__argp_fmtstream_set_wmargin
argument_list|(
name|stream
argument_list|,
name|uparams
operator|.
name|short_opt_col
argument_list|)
expr_stmt|;
comment|/* For truly bizarre cases. */
for|for
control|(
name|opt
operator|=
name|real
operator|,
name|num
operator|=
name|entry
operator|->
name|num
init|;
name|num
operator|>
literal|0
condition|;
name|opt
operator|++
operator|,
name|num
operator|--
control|)
if|if
condition|(
name|oshort
argument_list|(
name|opt
argument_list|)
operator|&&
name|opt
operator|->
name|key
operator|==
operator|*
name|so
condition|)
comment|/* OPT has a valid (non shadowed) short option.  */
block|{
if|if
condition|(
name|ovisible
argument_list|(
name|opt
argument_list|)
condition|)
block|{
name|comma
argument_list|(
name|uparams
operator|.
name|short_opt_col
argument_list|,
operator|&
name|pest
argument_list|)
expr_stmt|;
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
operator|*
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_long_opt
operator|||
name|uparams
operator|.
name|dup_args
condition|)
name|arg
argument_list|(
name|real
argument_list|,
literal|" %s"
argument_list|,
literal|"[%s]"
argument_list|,
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|real
operator|->
name|arg
condition|)
name|hhstate
operator|->
name|suppressed_dup_arg
operator|=
literal|1
expr_stmt|;
block|}
name|so
operator|++
expr_stmt|;
block|}
comment|/* Now, long options.  */
if|if
condition|(
name|odoc
argument_list|(
name|real
argument_list|)
condition|)
comment|/* A `documentation' option.  */
block|{
name|__argp_fmtstream_set_wmargin
argument_list|(
name|stream
argument_list|,
name|uparams
operator|.
name|doc_opt_col
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|real
operator|,
name|num
operator|=
name|entry
operator|->
name|num
init|;
name|num
operator|>
literal|0
condition|;
name|opt
operator|++
operator|,
name|num
operator|--
control|)
if|if
condition|(
name|opt
operator|->
name|name
operator|&&
operator|*
name|opt
operator|->
name|name
operator|&&
name|ovisible
argument_list|(
name|opt
argument_list|)
condition|)
block|{
name|comma
argument_list|(
name|uparams
operator|.
name|doc_opt_col
argument_list|,
operator|&
name|pest
argument_list|)
expr_stmt|;
comment|/* Calling dgettext here isn't quite right, since sorting will 	       have been done on the original; but documentation options 	       should be pretty rare anyway...  */
name|__argp_fmtstream_puts
argument_list|(
name|stream
argument_list|,
name|onotrans
argument_list|(
name|opt
argument_list|)
condition|?
name|opt
operator|->
name|name
else|:
name|dgettext
argument_list|(
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
name|opt
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* A real long option.  */
block|{
name|int
name|first_long_opt
init|=
literal|1
decl_stmt|;
name|__argp_fmtstream_set_wmargin
argument_list|(
name|stream
argument_list|,
name|uparams
operator|.
name|long_opt_col
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|real
operator|,
name|num
operator|=
name|entry
operator|->
name|num
init|;
name|num
operator|>
literal|0
condition|;
name|opt
operator|++
operator|,
name|num
operator|--
control|)
if|if
condition|(
name|opt
operator|->
name|name
operator|&&
name|ovisible
argument_list|(
name|opt
argument_list|)
condition|)
block|{
name|comma
argument_list|(
name|uparams
operator|.
name|long_opt_col
argument_list|,
operator|&
name|pest
argument_list|)
expr_stmt|;
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
literal|"--%s"
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_long_opt
operator|||
name|uparams
operator|.
name|dup_args
condition|)
name|arg
argument_list|(
name|real
argument_list|,
literal|"=%s"
argument_list|,
literal|"[=%s]"
argument_list|,
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|real
operator|->
name|arg
condition|)
name|hhstate
operator|->
name|suppressed_dup_arg
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Next, documentation strings.  */
name|__argp_fmtstream_set_lmargin
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pest
operator|.
name|first
condition|)
block|{
comment|/* Didn't print any switches, what's up?  */
if|if
condition|(
operator|!
name|oshort
argument_list|(
name|real
argument_list|)
operator|&&
operator|!
name|real
operator|->
name|name
condition|)
comment|/* This is a group header, print it nicely.  */
name|print_header
argument_list|(
name|real
operator|->
name|doc
argument_list|,
name|entry
operator|->
name|argp
argument_list|,
operator|&
name|pest
argument_list|)
expr_stmt|;
else|else
comment|/* Just a totally shadowed option or null header; print nothing.  */
goto|goto
name|cleanup
goto|;
comment|/* Just return, after cleaning up.  */
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|tstr
init|=
name|real
operator|->
name|doc
condition|?
name|dgettext
argument_list|(
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
name|real
operator|->
name|doc
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|fstr
init|=
name|filter_doc
argument_list|(
name|tstr
argument_list|,
name|real
operator|->
name|key
argument_list|,
name|entry
operator|->
name|argp
argument_list|,
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|fstr
operator|&&
operator|*
name|fstr
condition|)
block|{
name|unsigned
name|int
name|col
init|=
name|__argp_fmtstream_point
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|__argp_fmtstream_set_lmargin
argument_list|(
name|stream
argument_list|,
name|uparams
operator|.
name|opt_doc_col
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_wmargin
argument_list|(
name|stream
argument_list|,
name|uparams
operator|.
name|opt_doc_col
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|>
call|(
name|unsigned
name|int
call|)
argument_list|(
name|uparams
operator|.
name|opt_doc_col
operator|+
literal|3
argument_list|)
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|col
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|uparams
operator|.
name|opt_doc_col
condition|)
name|__argp_fmtstream_puts
argument_list|(
name|stream
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
else|else
name|indent_to
argument_list|(
name|stream
argument_list|,
name|uparams
operator|.
name|opt_doc_col
argument_list|)
expr_stmt|;
name|__argp_fmtstream_puts
argument_list|(
name|stream
argument_list|,
name|fstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstr
operator|&&
name|fstr
operator|!=
name|tstr
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fstr
argument_list|)
expr_stmt|;
comment|/* Reset the left margin.  */
name|__argp_fmtstream_set_lmargin
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|hhstate
operator|->
name|prev_entry
operator|=
name|entry
expr_stmt|;
name|cleanup
label|:
name|__argp_fmtstream_set_lmargin
argument_list|(
name|stream
argument_list|,
name|old_lm
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_wmargin
argument_list|(
name|stream
argument_list|,
name|old_wm
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a long help message about the options in HOL to STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|hol_help
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|,
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|argp_fmtstream_t
name|stream
parameter_list|)
block|{
name|unsigned
name|num
decl_stmt|;
name|struct
name|hol_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|hol_help_state
name|hhstate
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|hol
operator|->
name|entries
operator|,
name|num
operator|=
name|hol
operator|->
name|num_entries
init|;
name|num
operator|>
literal|0
condition|;
name|entry
operator|++
operator|,
name|num
operator|--
control|)
name|hol_entry_help
argument_list|(
name|entry
argument_list|,
name|state
argument_list|,
name|stream
argument_list|,
operator|&
name|hhstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|hhstate
operator|.
name|suppressed_dup_arg
operator|&&
name|uparams
operator|.
name|dup_args_note
condition|)
block|{
specifier|const
name|char
modifier|*
name|tstr
init|=
name|dgettext
argument_list|(
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
literal|"\ Mandatory or optional arguments to long options are also mandatory or \ optional for any corresponding short options."
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fstr
init|=
name|filter_doc
argument_list|(
name|tstr
argument_list|,
name|ARGP_KEY_HELP_DUP_ARGS_NOTE
argument_list|,
name|state
condition|?
name|state
operator|->
name|root_argp
else|:
literal|0
argument_list|,
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|fstr
operator|&&
operator|*
name|fstr
condition|)
block|{
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|__argp_fmtstream_puts
argument_list|(
name|stream
argument_list|,
name|fstr
argument_list|)
expr_stmt|;
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstr
operator|&&
name|fstr
operator|!=
name|tstr
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fstr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper functions for hol_usage.  */
end_comment

begin_comment
comment|/* If OPT is a short option without an arg, append its key to the string    pointer pointer to by COOKIE, and advance the pointer.  */
end_comment

begin_function
specifier|static
name|int
name|add_argless_short_opt
parameter_list|(
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
parameter_list|,
specifier|const
name|struct
name|argp_option
modifier|*
name|real
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|snao_end
init|=
name|cookie
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|opt
operator|->
name|arg
operator|||
name|real
operator|->
name|arg
operator|)
operator|&&
operator|!
operator|(
operator|(
name|opt
operator|->
name|flags
operator||
name|real
operator|->
name|flags
operator|)
operator|&
name|OPTION_NO_USAGE
operator|)
condition|)
operator|*
operator|(
operator|*
name|snao_end
operator|)
operator|++
operator|=
name|opt
operator|->
name|key
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If OPT is a short option with an arg, output a usage entry for it to the    stream pointed at by COOKIE.  */
end_comment

begin_function
specifier|static
name|int
name|usage_argful_short_opt
parameter_list|(
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
parameter_list|,
specifier|const
name|struct
name|argp_option
modifier|*
name|real
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|argp_fmtstream_t
name|stream
init|=
name|cookie
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
init|=
name|opt
operator|->
name|arg
decl_stmt|;
name|int
name|flags
init|=
name|opt
operator|->
name|flags
operator||
name|real
operator|->
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|arg
operator|=
name|real
operator|->
name|arg
expr_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|!
operator|(
name|flags
operator|&
name|OPTION_NO_USAGE
operator|)
condition|)
block|{
name|arg
operator|=
name|dgettext
argument_list|(
name|domain
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPTION_ARG_OPTIONAL
condition|)
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
literal|" [-%c[%s]]"
argument_list|,
name|opt
operator|->
name|key
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Manually do line wrapping so that it (probably) won't 	     get wrapped at the embedded space.  */
name|space
argument_list|(
name|stream
argument_list|,
literal|6
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
literal|"[-%c %s]"
argument_list|,
name|opt
operator|->
name|key
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output a usage entry for the long option opt to the stream pointed at by    COOKIE.  */
end_comment

begin_function
specifier|static
name|int
name|usage_long_opt
parameter_list|(
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
parameter_list|,
specifier|const
name|struct
name|argp_option
modifier|*
name|real
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|argp_fmtstream_t
name|stream
init|=
name|cookie
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
init|=
name|opt
operator|->
name|arg
decl_stmt|;
name|int
name|flags
init|=
name|opt
operator|->
name|flags
operator||
name|real
operator|->
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|arg
operator|=
name|real
operator|->
name|arg
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|OPTION_NO_USAGE
operator|)
condition|)
block|{
if|if
condition|(
name|arg
condition|)
block|{
name|arg
operator|=
name|dgettext
argument_list|(
name|domain
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|OPTION_ARG_OPTIONAL
condition|)
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
literal|" [--%s[=%s]]"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
literal|" [--%s=%s]"
argument_list|,
name|opt
operator|->
name|name
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
literal|" [--%s]"
argument_list|,
name|opt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a short usage description for the arguments in HOL to STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|hol_usage
parameter_list|(
name|struct
name|hol
modifier|*
name|hol
parameter_list|,
name|argp_fmtstream_t
name|stream
parameter_list|)
block|{
if|if
condition|(
name|hol
operator|->
name|num_entries
operator|>
literal|0
condition|)
block|{
name|unsigned
name|nentries
decl_stmt|;
name|struct
name|hol_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|short_no_arg_opts
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|hol
operator|->
name|short_options
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|snao_end
init|=
name|short_no_arg_opts
decl_stmt|;
comment|/* First we put a list of short options without arguments.  */
for|for
control|(
name|entry
operator|=
name|hol
operator|->
name|entries
operator|,
name|nentries
operator|=
name|hol
operator|->
name|num_entries
init|;
name|nentries
operator|>
literal|0
condition|;
name|entry
operator|++
operator|,
name|nentries
operator|--
control|)
name|hol_entry_short_iterate
argument_list|(
name|entry
argument_list|,
name|add_argless_short_opt
argument_list|,
name|entry
operator|->
name|argp
operator|->
name|argp_domain
argument_list|,
operator|&
name|snao_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|snao_end
operator|>
name|short_no_arg_opts
condition|)
block|{
operator|*
name|snao_end
operator|++
operator|=
literal|0
expr_stmt|;
name|__argp_fmtstream_printf
argument_list|(
name|stream
argument_list|,
literal|" [-%s]"
argument_list|,
name|short_no_arg_opts
argument_list|)
expr_stmt|;
block|}
comment|/* Now a list of short options *with* arguments.  */
for|for
control|(
name|entry
operator|=
name|hol
operator|->
name|entries
operator|,
name|nentries
operator|=
name|hol
operator|->
name|num_entries
init|;
name|nentries
operator|>
literal|0
condition|;
name|entry
operator|++
operator|,
name|nentries
operator|--
control|)
name|hol_entry_short_iterate
argument_list|(
name|entry
argument_list|,
name|usage_argful_short_opt
argument_list|,
name|entry
operator|->
name|argp
operator|->
name|argp_domain
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Finally, a list of long options (whew!).  */
for|for
control|(
name|entry
operator|=
name|hol
operator|->
name|entries
operator|,
name|nentries
operator|=
name|hol
operator|->
name|num_entries
init|;
name|nentries
operator|>
literal|0
condition|;
name|entry
operator|++
operator|,
name|nentries
operator|--
control|)
name|hol_entry_long_iterate
argument_list|(
name|entry
argument_list|,
name|usage_long_opt
argument_list|,
name|entry
operator|->
name|argp
operator|->
name|argp_domain
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a HOL containing all levels of options in ARGP.  CLUSTER is the    cluster in which ARGP's entries should be clustered, or 0.  */
end_comment

begin_function
specifier|static
name|struct
name|hol
modifier|*
name|argp_hol
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|struct
name|hol_cluster
modifier|*
name|cluster
parameter_list|)
block|{
specifier|const
name|struct
name|argp_child
modifier|*
name|child
init|=
name|argp
operator|->
name|children
decl_stmt|;
name|struct
name|hol
modifier|*
name|hol
init|=
name|make_hol
argument_list|(
name|argp
argument_list|,
name|cluster
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
condition|)
while|while
condition|(
name|child
operator|->
name|argp
condition|)
block|{
name|struct
name|hol_cluster
modifier|*
name|child_cluster
init|=
operator|(
operator|(
name|child
operator|->
name|group
operator|||
name|child
operator|->
name|header
operator|)
comment|/* Put CHILD->argp within its own cluster.  */
condition|?
name|hol_add_cluster
argument_list|(
name|hol
argument_list|,
name|child
operator|->
name|group
argument_list|,
name|child
operator|->
name|header
argument_list|,
name|child
operator|-
name|argp
operator|->
name|children
argument_list|,
name|cluster
argument_list|,
name|argp
argument_list|)
comment|/* Just merge it into the parent's cluster.  */
else|:
name|cluster
operator|)
decl_stmt|;
name|hol_append
argument_list|(
name|hol
argument_list|,
name|argp_hol
argument_list|(
name|child
operator|->
name|argp
argument_list|,
name|child_cluster
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|++
expr_stmt|;
block|}
return|return
name|hol
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate how many different levels with alternative args strings exist in    ARGP.  */
end_comment

begin_function
specifier|static
name|size_t
name|argp_args_levels
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|)
block|{
name|size_t
name|levels
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|argp_child
modifier|*
name|child
init|=
name|argp
operator|->
name|children
decl_stmt|;
if|if
condition|(
name|argp
operator|->
name|args_doc
operator|&&
name|strchr
argument_list|(
name|argp
operator|->
name|args_doc
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|levels
operator|++
expr_stmt|;
if|if
condition|(
name|child
condition|)
while|while
condition|(
name|child
operator|->
name|argp
condition|)
name|levels
operator|+=
name|argp_args_levels
argument_list|(
operator|(
name|child
operator|++
operator|)
operator|->
name|argp
argument_list|)
expr_stmt|;
return|return
name|levels
return|;
block|}
end_function

begin_comment
comment|/* Print all the non-option args documented in ARGP to STREAM.  Any output is    preceded by a space.  LEVELS is a pointer to a byte vector the length    returned by argp_args_levels; it should be initialized to zero, and    updated by this routine for the next call if ADVANCE is true.  True is    returned as long as there are more patterns to output.  */
end_comment

begin_function
specifier|static
name|int
name|argp_args_usage
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|char
modifier|*
modifier|*
name|levels
parameter_list|,
name|int
name|advance
parameter_list|,
name|argp_fmtstream_t
name|stream
parameter_list|)
block|{
name|char
modifier|*
name|our_level
init|=
operator|*
name|levels
decl_stmt|;
name|int
name|multiple
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|argp_child
modifier|*
name|child
init|=
name|argp
operator|->
name|children
decl_stmt|;
specifier|const
name|char
modifier|*
name|tdoc
init|=
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
name|argp
operator|->
name|args_doc
argument_list|)
decl_stmt|,
modifier|*
name|nl
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|fdoc
init|=
name|filter_doc
argument_list|(
name|tdoc
argument_list|,
name|ARGP_KEY_HELP_ARGS_DOC
argument_list|,
name|argp
argument_list|,
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|fdoc
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
name|fdoc
decl_stmt|;
name|nl
operator|=
name|__strchrnul
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nl
operator|!=
literal|'\0'
condition|)
comment|/* This is a `multi-level' args doc; advance to the correct position 	   as determined by our state in LEVELS, and update LEVELS.  */
block|{
name|int
name|i
decl_stmt|;
name|multiple
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|our_level
condition|;
name|i
operator|++
control|)
name|cp
operator|=
name|nl
operator|+
literal|1
operator|,
name|nl
operator|=
name|__strchrnul
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
operator|*
name|levels
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Manually do line wrapping so that it (probably) won't get wrapped at 	 any embedded spaces.  */
name|space
argument_list|(
name|stream
argument_list|,
literal|1
operator|+
name|nl
operator|-
name|cp
argument_list|)
expr_stmt|;
name|__argp_fmtstream_write
argument_list|(
name|stream
argument_list|,
name|cp
argument_list|,
name|nl
operator|-
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdoc
operator|&&
name|fdoc
operator|!=
name|tdoc
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fdoc
argument_list|)
expr_stmt|;
comment|/* Free user's modified doc string.  */
if|if
condition|(
name|child
condition|)
while|while
condition|(
name|child
operator|->
name|argp
condition|)
name|advance
operator|=
operator|!
name|argp_args_usage
argument_list|(
operator|(
name|child
operator|++
operator|)
operator|->
name|argp
argument_list|,
name|state
argument_list|,
name|levels
argument_list|,
name|advance
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|advance
operator|&&
name|multiple
condition|)
block|{
comment|/* Need to increment our level.  */
if|if
condition|(
operator|*
name|nl
condition|)
comment|/* There's more we can do here.  */
block|{
operator|(
operator|*
name|our_level
operator|)
operator|++
expr_stmt|;
name|advance
operator|=
literal|0
expr_stmt|;
comment|/* Our parent shouldn't advance also. */
block|}
elseif|else
if|if
condition|(
operator|*
name|our_level
operator|>
literal|0
condition|)
comment|/* We had multiple levels, but used them up; reset to zero.  */
operator|*
name|our_level
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|!
name|advance
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the documentation for ARGP to STREAM; if POST is false, then    everything preceeding a `\v' character in the documentation strings (or    the whole string, for those with none) is printed, otherwise, everything    following the `\v' character (nothing for strings without).  Each separate    bit of documentation is separated a blank line, and if PRE_BLANK is true,    then the first is as well.  If FIRST_ONLY is true, only the first    occurrence is output.  Returns true if anything was output.  */
end_comment

begin_function
specifier|static
name|int
name|argp_doc
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|int
name|post
parameter_list|,
name|int
name|pre_blank
parameter_list|,
name|int
name|first_only
parameter_list|,
name|argp_fmtstream_t
name|stream
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
specifier|const
name|char
modifier|*
name|inp_text
decl_stmt|;
name|void
modifier|*
name|input
init|=
literal|0
decl_stmt|;
name|int
name|anything
init|=
literal|0
decl_stmt|;
name|size_t
name|inp_text_limit
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|doc
init|=
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
name|argp
operator|->
name|doc
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|argp_child
modifier|*
name|child
init|=
name|argp
operator|->
name|children
decl_stmt|;
if|if
condition|(
name|doc
condition|)
block|{
name|char
modifier|*
name|vt
init|=
name|strchr
argument_list|(
name|doc
argument_list|,
literal|'\v'
argument_list|)
decl_stmt|;
name|inp_text
operator|=
name|post
condition|?
operator|(
name|vt
condition|?
name|vt
operator|+
literal|1
else|:
literal|0
operator|)
else|:
name|doc
expr_stmt|;
name|inp_text_limit
operator|=
operator|(
operator|!
name|post
operator|&&
name|vt
operator|)
condition|?
operator|(
name|vt
operator|-
name|doc
operator|)
else|:
literal|0
expr_stmt|;
block|}
else|else
name|inp_text
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|help_filter
condition|)
comment|/* We have to filter the doc strings.  */
block|{
if|if
condition|(
name|inp_text_limit
condition|)
comment|/* Copy INP_TEXT so that it's nul-terminated.  */
name|inp_text
operator|=
name|__strndup
argument_list|(
name|inp_text
argument_list|,
name|inp_text_limit
argument_list|)
expr_stmt|;
name|input
operator|=
name|__argp_input
argument_list|(
name|argp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|text
operator|=
call|(
modifier|*
name|argp
operator|->
name|help_filter
call|)
argument_list|(
name|post
condition|?
name|ARGP_KEY_HELP_POST_DOC
else|:
name|ARGP_KEY_HELP_PRE_DOC
argument_list|,
name|inp_text
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
else|else
name|text
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|inp_text
expr_stmt|;
if|if
condition|(
name|text
condition|)
block|{
if|if
condition|(
name|pre_blank
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|inp_text
operator|&&
name|inp_text_limit
condition|)
name|__argp_fmtstream_write
argument_list|(
name|stream
argument_list|,
name|inp_text
argument_list|,
name|inp_text_limit
argument_list|)
expr_stmt|;
else|else
name|__argp_fmtstream_puts
argument_list|(
name|stream
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|__argp_fmtstream_point
argument_list|(
name|stream
argument_list|)
operator|>
name|__argp_fmtstream_lmargin
argument_list|(
name|stream
argument_list|)
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|anything
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|text
operator|&&
name|text
operator|!=
name|inp_text
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|text
argument_list|)
expr_stmt|;
comment|/* Free TEXT returned from the help filter.  */
if|if
condition|(
name|inp_text
operator|&&
name|inp_text_limit
operator|&&
name|argp
operator|->
name|help_filter
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inp_text
argument_list|)
expr_stmt|;
comment|/* We copied INP_TEXT, so free it now.  */
if|if
condition|(
name|post
operator|&&
name|argp
operator|->
name|help_filter
condition|)
comment|/* Now see if we have to output a ARGP_KEY_HELP_EXTRA text.  */
block|{
name|text
operator|=
call|(
modifier|*
name|argp
operator|->
name|help_filter
call|)
argument_list|(
name|ARGP_KEY_HELP_EXTRA
argument_list|,
literal|0
argument_list|,
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
condition|)
block|{
if|if
condition|(
name|anything
operator|||
name|pre_blank
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|__argp_fmtstream_puts
argument_list|(
name|stream
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|__argp_fmtstream_point
argument_list|(
name|stream
argument_list|)
operator|>
name|__argp_fmtstream_lmargin
argument_list|(
name|stream
argument_list|)
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|stream
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|anything
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
condition|)
while|while
condition|(
name|child
operator|->
name|argp
operator|&&
operator|!
operator|(
name|first_only
operator|&&
name|anything
operator|)
condition|)
name|anything
operator||=
name|argp_doc
argument_list|(
operator|(
name|child
operator|++
operator|)
operator|->
name|argp
argument_list|,
name|state
argument_list|,
name|post
argument_list|,
name|anything
operator|||
name|pre_blank
argument_list|,
name|first_only
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
name|anything
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a usage message for ARGP to STREAM.  If called from    argp_state_help, STATE is the relevent parsing state.  FLAGS are from the    set ARGP_HELP_*.  NAME is what to use wherever a `program name' is    needed. */
end_comment

begin_function
specifier|static
name|void
name|_help
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|anything
init|=
literal|0
decl_stmt|;
comment|/* Whether we've output anything.  */
name|struct
name|hol
modifier|*
name|hol
init|=
literal|0
decl_stmt|;
name|argp_fmtstream_t
name|fs
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_FLOCKFILE
operator|&&
name|HAVE_FUNLOCKFILE
operator|)
name|__flockfile
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|uparams
operator|.
name|valid
condition|)
name|fill_in_uparams
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|fs
operator|=
name|__argp_make_fmtstream
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|,
name|uparams
operator|.
name|rmargin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
condition|)
block|{
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_FLOCKFILE
operator|&&
name|HAVE_FUNLOCKFILE
operator|)
name|__funlockfile
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|ARGP_HELP_USAGE
operator||
name|ARGP_HELP_SHORT_USAGE
operator||
name|ARGP_HELP_LONG
operator|)
condition|)
block|{
name|hol
operator|=
name|argp_hol
argument_list|(
name|argp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If present, these options always come last.  */
name|hol_set_group
argument_list|(
name|hol
argument_list|,
literal|"help"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hol_set_group
argument_list|(
name|hol
argument_list|,
literal|"version"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hol_sort
argument_list|(
name|hol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|ARGP_HELP_USAGE
operator||
name|ARGP_HELP_SHORT_USAGE
operator|)
condition|)
comment|/* Print a short `Usage:' message.  */
block|{
name|int
name|first_pattern
init|=
literal|1
decl_stmt|,
name|more_patterns
decl_stmt|;
name|size_t
name|num_pattern_levels
init|=
name|argp_args_levels
argument_list|(
name|argp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pattern_levels
init|=
name|alloca
argument_list|(
name|num_pattern_levels
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|pattern_levels
argument_list|,
literal|0
argument_list|,
name|num_pattern_levels
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|old_lm
decl_stmt|;
name|int
name|old_wm
init|=
name|__argp_fmtstream_set_wmargin
argument_list|(
name|fs
argument_list|,
name|uparams
operator|.
name|usage_indent
argument_list|)
decl_stmt|;
name|char
modifier|*
name|levels
init|=
name|pattern_levels
decl_stmt|;
if|if
condition|(
name|first_pattern
condition|)
name|__argp_fmtstream_printf
argument_list|(
name|fs
argument_list|,
literal|"%s %s"
argument_list|,
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
literal|"Usage:"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|__argp_fmtstream_printf
argument_list|(
name|fs
argument_list|,
literal|"%s %s"
argument_list|,
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
literal|"  or: "
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* We set the lmargin as well as the wmargin, because hol_usage 	     manually wraps options with newline to avoid annoying breaks.  */
name|old_lm
operator|=
name|__argp_fmtstream_set_lmargin
argument_list|(
name|fs
argument_list|,
name|uparams
operator|.
name|usage_indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ARGP_HELP_SHORT_USAGE
condition|)
comment|/* Just show where the options go.  */
block|{
if|if
condition|(
name|hol
operator|->
name|num_entries
operator|>
literal|0
condition|)
name|__argp_fmtstream_puts
argument_list|(
name|fs
argument_list|,
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
literal|" [OPTION...]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Actually print the options.  */
block|{
name|hol_usage
argument_list|(
name|hol
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ARGP_HELP_SHORT_USAGE
expr_stmt|;
comment|/* But only do so once.  */
block|}
name|more_patterns
operator|=
name|argp_args_usage
argument_list|(
name|argp
argument_list|,
name|state
argument_list|,
operator|&
name|levels
argument_list|,
literal|1
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_wmargin
argument_list|(
name|fs
argument_list|,
name|old_wm
argument_list|)
expr_stmt|;
name|__argp_fmtstream_set_lmargin
argument_list|(
name|fs
argument_list|,
name|old_lm
argument_list|)
expr_stmt|;
name|__argp_fmtstream_putc
argument_list|(
name|fs
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|anything
operator|=
literal|1
expr_stmt|;
name|first_pattern
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|more_patterns
condition|)
do|;
block|}
if|if
condition|(
name|flags
operator|&
name|ARGP_HELP_PRE_DOC
condition|)
name|anything
operator||=
name|argp_doc
argument_list|(
name|argp
argument_list|,
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ARGP_HELP_SEE
condition|)
block|{
name|__argp_fmtstream_printf
argument_list|(
name|fs
argument_list|,
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
literal|"\ Try `%s --help' or `%s --usage' for more information.\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|anything
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ARGP_HELP_LONG
condition|)
comment|/* Print a long, detailed help message.  */
block|{
comment|/* Print info about all the options.  */
if|if
condition|(
name|hol
operator|->
name|num_entries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|anything
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|fs
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|hol_help
argument_list|(
name|hol
argument_list|,
name|state
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|anything
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|ARGP_HELP_POST_DOC
condition|)
comment|/* Print any documentation strings at the end.  */
name|anything
operator||=
name|argp_doc
argument_list|(
name|argp
argument_list|,
name|state
argument_list|,
literal|1
argument_list|,
name|anything
argument_list|,
literal|0
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARGP_HELP_BUG_ADDR
operator|)
operator|&&
name|argp_program_bug_address
condition|)
block|{
if|if
condition|(
name|anything
condition|)
name|__argp_fmtstream_putc
argument_list|(
name|fs
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|__argp_fmtstream_printf
argument_list|(
name|fs
argument_list|,
name|dgettext
argument_list|(
name|argp
operator|->
name|argp_domain
argument_list|,
literal|"Report bugs to %s.\n"
argument_list|)
argument_list|,
name|argp_program_bug_address
argument_list|)
expr_stmt|;
name|anything
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_FLOCKFILE
operator|&&
name|HAVE_FUNLOCKFILE
operator|)
name|__funlockfile
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hol
condition|)
name|hol_free
argument_list|(
name|hol
argument_list|)
expr_stmt|;
name|__argp_fmtstream_free
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a usage message for ARGP to STREAM.  FLAGS are from the set    ARGP_HELP_*.  NAME is what to use wherever a `program name' is needed. */
end_comment

begin_function
name|void
name|__argp_help
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|_help
argument_list|(
name|argp
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__argp_help
argument_list|,
argument|argp_help
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|_LIBC
operator|||
name|HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME
operator|)
end_if

begin_function
name|char
modifier|*
name|__argp_short_program_name
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|HAVE_DECL_PROGRAM_INVOCATION_NAME
name|char
modifier|*
name|name
init|=
name|strrchr
argument_list|(
name|program_invocation_name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
return|return
name|name
condition|?
name|name
operator|+
literal|1
else|:
name|program_invocation_name
return|;
else|#
directive|else
comment|/* FIXME: What now? Miles suggests that it is better to use NULL,      but currently the value is passed on directly to fputs_unlocked,      so that requires more changes. */
if|#
directive|if
name|__GNUC__
warning|#
directive|warning
warning|No reasonable value to return
endif|#
directive|endif
comment|/* __GNUC__ */
return|return
literal|""
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output, if appropriate, a usage message for STATE to STREAM.  FLAGS are    from the set ARGP_HELP_*.  */
end_comment

begin_function
name|void
name|__argp_state_help
parameter_list|(
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|ARGP_NO_ERRS
operator|)
operator|)
operator|&&
name|stream
condition|)
block|{
if|if
condition|(
name|state
operator|&&
operator|(
name|state
operator|->
name|flags
operator|&
name|ARGP_LONG_ONLY
operator|)
condition|)
name|flags
operator||=
name|ARGP_HELP_LONG_ONLY
expr_stmt|;
name|_help
argument_list|(
name|state
condition|?
name|state
operator|->
name|root_argp
else|:
literal|0
argument_list|,
name|state
argument_list|,
name|stream
argument_list|,
name|flags
argument_list|,
name|state
condition|?
name|state
operator|->
name|name
else|:
name|__argp_short_program_name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|ARGP_NO_EXIT
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ARGP_HELP_EXIT_ERR
condition|)
name|exit
argument_list|(
name|argp_err_exit_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ARGP_HELP_EXIT_OK
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__argp_state_help
argument_list|,
argument|argp_state_help
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* If appropriate, print the printf string FMT and following args, preceded    by the program name and `:', to stderr, and followed by a `Try ... --help'    message, then exit (1).  */
end_comment

begin_function
name|void
name|__argp_error
parameter_list|(
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|ARGP_NO_ERRS
operator|)
condition|)
block|{
name|FILE
modifier|*
name|stream
init|=
name|state
condition|?
name|state
operator|->
name|err_stream
else|:
name|stderr
decl_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_FLOCKFILE
operator|&&
name|HAVE_FUNLOCKFILE
operator|)
name|__flockfile
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|__fwprintf
argument_list|(
name|stream
argument_list|,
literal|L"%s: %s\n"
argument_list|,
name|state
condition|?
name|state
operator|->
name|name
else|:
name|__argp_short_program_name
argument_list|()
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fputs_unlocked
argument_list|(
name|state
condition|?
name|state
operator|->
name|name
else|:
name|__argp_short_program_name
argument_list|()
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|putc_unlocked
argument_list|(
literal|':'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|putc_unlocked
argument_list|(
literal|' '
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|putc_unlocked
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|__argp_state_help
argument_list|(
name|state
argument_list|,
name|stream
argument_list|,
name|ARGP_HELP_STD_ERR
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_FLOCKFILE
operator|&&
name|HAVE_FUNLOCKFILE
operator|)
name|__funlockfile
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__argp_error
argument_list|,
argument|argp_error
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Similar to the standard gnu error-reporting function error(), but will    respect the ARGP_NO_EXIT and ARGP_NO_ERRS flags in STATE, and will print    to STATE->err_stream.  This is useful for argument parsing code that is    shared between program startup (when exiting is desired) and runtime    option parsing (when typically an error code is returned instead).  The    difference between this function and argp_error is that the latter is for    *parsing errors*, and the former is for other problems that occur during    parsing but don't reflect a (syntactic) problem with the input.  */
end_comment

begin_function
name|void
name|__argp_failure
parameter_list|(
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|errnum
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|ARGP_NO_ERRS
operator|)
condition|)
block|{
name|FILE
modifier|*
name|stream
init|=
name|state
condition|?
name|state
operator|->
name|err_stream
else|:
name|stderr
decl_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_FLOCKFILE
operator|&&
name|HAVE_FUNLOCKFILE
operator|)
name|__flockfile
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stream
argument_list|,
literal|L"%s"
argument_list|,
name|state
condition|?
name|state
operator|->
name|name
else|:
name|__argp_short_program_name
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fputs_unlocked
argument_list|(
name|state
condition|?
name|state
operator|->
name|name
else|:
name|__argp_short_program_name
argument_list|()
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|__asprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|__fwprintf
argument_list|(
name|stream
argument_list|,
literal|L": %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|putc_unlocked
argument_list|(
literal|':'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|putc_unlocked
argument_list|(
literal|' '
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errnum
condition|)
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|stream
argument_list|,
literal|L": %s"
argument_list|,
name|__strerror_r
argument_list|(
name|errnum
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|char
specifier|const
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|putc_unlocked
argument_list|(
literal|':'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|putc_unlocked
argument_list|(
literal|' '
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_DECL_STRERROR_R
operator|&&
name|STRERROR_R_CHAR_P
operator|)
name|s
operator|=
name|__strerror_r
argument_list|(
name|errnum
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|HAVE_DECL_STRERROR_R
if|if
condition|(
name|__strerror_r
argument_list|(
name|errnum
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|_LIBC
if|if
condition|(
operator|!
name|s
operator|&&
operator|!
operator|(
name|s
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
operator|)
condition|)
name|s
operator|=
literal|"Unknown system error"
expr_stmt|;
comment|/* FIXME: translate this */
endif|#
directive|endif
name|fputs
argument_list|(
name|s
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|putwc_unlocked
argument_list|(
literal|L'
expr|\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|putc_unlocked
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|#
directive|if
name|_LIBC
operator|||
operator|(
name|HAVE_FLOCKFILE
operator|&&
name|HAVE_FUNLOCKFILE
operator|)
name|__funlockfile
argument_list|(
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|&&
operator|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|ARGP_NO_EXIT
operator|)
operator|)
condition|)
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__argp_failure
argument_list|,
argument|argp_failure
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

