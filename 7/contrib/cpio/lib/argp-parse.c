begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hierarchial argument parsing, layered over getopt    Copyright (C) 1995-2000, 2002, 2003, 2004 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Written by Miles Bader<miles@gnu.ai.mit.edu>.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<getopt_int.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_undef
undef|#
directive|undef
name|dgettext
end_undef

begin_define
define|#
directive|define
name|dgettext
parameter_list|(
name|domain
parameter_list|,
name|msgid
parameter_list|)
define|\
value|INTUSE(__dcgettext) (domain, msgid, LC_MESSAGES)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"gettext.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|N_
parameter_list|(
name|msgid
parameter_list|)
value|(msgid)
end_define

begin_include
include|#
directive|include
file|"argp.h"
end_include

begin_include
include|#
directive|include
file|"argp-namefrob.h"
end_include

begin_comment
comment|/* Getopt return values.  */
end_comment

begin_define
define|#
directive|define
name|KEY_END
value|(-1)
end_define

begin_comment
comment|/* The end of the options.  */
end_comment

begin_define
define|#
directive|define
name|KEY_ARG
value|1
end_define

begin_comment
comment|/* A non-option argument.  */
end_comment

begin_define
define|#
directive|define
name|KEY_ERR
value|'?'
end_define

begin_comment
comment|/* An error parsing the options.  */
end_comment

begin_comment
comment|/* The meta-argument used to prevent any further arguments being interpreted    as options.  */
end_comment

begin_define
define|#
directive|define
name|QUOTE
value|"--"
end_define

begin_comment
comment|/* The number of bits we steal in a long-option value for our own use.  */
end_comment

begin_define
define|#
directive|define
name|GROUP_BITS
value|CHAR_BIT
end_define

begin_comment
comment|/* The number of bits available for the user value.  */
end_comment

begin_define
define|#
directive|define
name|USER_BITS
value|((sizeof ((struct option *)0)->val * CHAR_BIT) - GROUP_BITS)
end_define

begin_define
define|#
directive|define
name|USER_MASK
value|((1<< USER_BITS) - 1)
end_define

begin_comment
comment|/* EZ alias for ARGP_ERR_UNKNOWN.  */
end_comment

begin_define
define|#
directive|define
name|EBADKEY
value|ARGP_ERR_UNKNOWN
end_define

begin_escape
end_escape

begin_comment
comment|/* Default options.  */
end_comment

begin_comment
comment|/* When argp is given the --HANG switch, _ARGP_HANG is set and argp will sleep    for one second intervals, decrementing _ARGP_HANG until it's zero.  Thus    you can force the program to continue by attaching a debugger and setting    it to 0 yourself.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|_argp_hang
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPT_PROGNAME
value|-2
end_define

begin_define
define|#
directive|define
name|OPT_USAGE
value|-3
end_define

begin_define
define|#
directive|define
name|OPT_HANG
value|-4
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|argp_option
name|argp_default_options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|'?'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Give this help list"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"usage"
block|,
name|OPT_USAGE
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Give a short usage message"
argument_list|)
block|,
literal|0
block|}
block|,
block|{
literal|"program-name"
block|,
name|OPT_PROGNAME
block|,
literal|"NAME"
block|,
name|OPTION_HIDDEN
block|,
name|N_
argument_list|(
literal|"Set the program name"
argument_list|)
block|,
literal|0
block|}
block|,
block|{
literal|"HANG"
block|,
name|OPT_HANG
block|,
literal|"SECS"
block|,
name|OPTION_ARG_OPTIONAL
operator||
name|OPTION_HIDDEN
block|,
name|N_
argument_list|(
literal|"Hang for SECS seconds (default 3600)"
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|error_t
name|argp_default_parser
parameter_list|(
name|int
name|key
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|argp_state
modifier|*
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'?'
case|:
name|__argp_state_help
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|out_stream
argument_list|,
name|ARGP_HELP_STD_HELP
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_USAGE
case|:
name|__argp_state_help
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|out_stream
argument_list|,
name|ARGP_HELP_USAGE
operator||
name|ARGP_HELP_EXIT_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_PROGNAME
case|:
comment|/* Set the program name.  */
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|HAVE_DECL_PROGRAM_INVOCATION_NAME
name|program_invocation_name
operator|=
name|arg
expr_stmt|;
endif|#
directive|endif
comment|/* [Note that some systems only have PROGRAM_INVOCATION_SHORT_NAME (aka 	 __PROGNAME), in which case, PROGRAM_INVOCATION_NAME is just defined 	 to be that, so we have to be a bit careful here.]  */
comment|/* Update what we use for messages.  */
name|state
operator|->
name|name
operator|=
name|strrchr
argument_list|(
name|arg
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|name
condition|)
name|state
operator|->
name|name
operator|++
expr_stmt|;
else|else
name|state
operator|->
name|name
operator|=
name|arg
expr_stmt|;
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME
name|program_invocation_short_name
operator|=
name|state
operator|->
name|name
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|state
operator|->
name|flags
operator|&
operator|(
name|ARGP_PARSE_ARGV0
operator||
name|ARGP_NO_ERRS
operator|)
operator|)
operator|==
name|ARGP_PARSE_ARGV0
condition|)
comment|/* Update what getopt uses too.  */
name|state
operator|->
name|argv
index|[
literal|0
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_HANG
case|:
name|_argp_hang
operator|=
name|atoi
argument_list|(
name|arg
condition|?
name|arg
else|:
literal|"3600"
argument_list|)
expr_stmt|;
while|while
condition|(
name|_argp_hang
operator|--
operator|>
literal|0
condition|)
name|__sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EBADKEY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|argp
name|argp_default_argp
init|=
block|{
name|argp_default_options
block|,
operator|&
name|argp_default_parser
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"libc"
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|argp_option
name|argp_version_options
index|[]
init|=
block|{
block|{
literal|"version"
block|,
literal|'V'
block|,
literal|0
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Print program version"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|error_t
name|argp_version_parser
parameter_list|(
name|int
name|key
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|argp_state
modifier|*
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'V'
case|:
if|if
condition|(
name|argp_program_version_hook
condition|)
call|(
modifier|*
name|argp_program_version_hook
call|)
argument_list|(
name|state
operator|->
name|out_stream
argument_list|,
name|state
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argp_program_version
condition|)
name|fprintf
argument_list|(
name|state
operator|->
name|out_stream
argument_list|,
literal|"%s\n"
argument_list|,
name|argp_program_version
argument_list|)
expr_stmt|;
else|else
name|__argp_error
argument_list|(
name|state
argument_list|,
name|dgettext
argument_list|(
name|state
operator|->
name|root_argp
operator|->
name|argp_domain
argument_list|,
literal|"(PROGRAM ERROR) No version known!?"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|ARGP_NO_EXIT
operator|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EBADKEY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|argp
name|argp_version_argp
init|=
block|{
name|argp_version_options
block|,
operator|&
name|argp_version_parser
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"libc"
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns the offset into the getopt long options array LONG_OPTIONS of a    long option with called NAME, or -1 if none is found.  Passing NULL as    NAME will return the number of options.  */
end_comment

begin_function
specifier|static
name|int
name|find_long_option
parameter_list|(
name|struct
name|option
modifier|*
name|long_options
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|option
modifier|*
name|l
init|=
name|long_options
decl_stmt|;
while|while
condition|(
name|l
operator|->
name|name
operator|!=
name|NULL
condition|)
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|l
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|l
operator|-
name|long_options
return|;
else|else
name|l
operator|++
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|l
operator|-
name|long_options
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The state of a `group' during parsing.  Each group corresponds to a    particular argp structure from the tree of such descending from the top    level argp passed to argp_parse.  */
end_comment

begin_struct
struct|struct
name|group
block|{
comment|/* This group's parsing function.  */
name|argp_parser_t
name|parser
decl_stmt|;
comment|/* Which argp this group is from.  */
specifier|const
name|struct
name|argp
modifier|*
name|argp
decl_stmt|;
comment|/* Points to the point in SHORT_OPTS corresponding to the end of the short      options for this group.  We use it to determine from which group a      particular short options is from.  */
name|char
modifier|*
name|short_end
decl_stmt|;
comment|/* The number of non-option args sucessfully handled by this parser.  */
name|unsigned
name|args_processed
decl_stmt|;
comment|/* This group's parser's parent's group.  */
name|struct
name|group
modifier|*
name|parent
decl_stmt|;
name|unsigned
name|parent_index
decl_stmt|;
comment|/* And the our position in the parent.   */
comment|/* These fields are swapped into and out of the state structure when      calling this group's parser.  */
name|void
modifier|*
name|input
decl_stmt|,
modifier|*
modifier|*
name|child_inputs
decl_stmt|;
name|void
modifier|*
name|hook
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Call GROUP's parser with KEY and ARG, swapping any group-specific info    from STATE before calling, and back into state afterwards.  If GROUP has    no parser, EBADKEY is returned.  */
end_comment

begin_function
specifier|static
name|error_t
name|group_parse
parameter_list|(
name|struct
name|group
modifier|*
name|group
parameter_list|,
name|struct
name|argp_state
modifier|*
name|state
parameter_list|,
name|int
name|key
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|group
operator|->
name|parser
condition|)
block|{
name|error_t
name|err
decl_stmt|;
name|state
operator|->
name|hook
operator|=
name|group
operator|->
name|hook
expr_stmt|;
name|state
operator|->
name|input
operator|=
name|group
operator|->
name|input
expr_stmt|;
name|state
operator|->
name|child_inputs
operator|=
name|group
operator|->
name|child_inputs
expr_stmt|;
name|state
operator|->
name|arg_num
operator|=
name|group
operator|->
name|args_processed
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|group
operator|->
name|parser
call|)
argument_list|(
name|key
argument_list|,
name|arg
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|group
operator|->
name|hook
operator|=
name|state
operator|->
name|hook
expr_stmt|;
return|return
name|err
return|;
block|}
else|else
return|return
name|EBADKEY
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|parser
block|{
specifier|const
name|struct
name|argp
modifier|*
name|argp
decl_stmt|;
comment|/* SHORT_OPTS is the getopt short options string for the union of all the      groups of options.  */
name|char
modifier|*
name|short_opts
decl_stmt|;
comment|/* LONG_OPTS is the array of getop long option structures for the union of      all the groups of options.  */
name|struct
name|option
modifier|*
name|long_opts
decl_stmt|;
comment|/* OPT_DATA is the getopt data used for the re-entrant getopt.  */
name|struct
name|_getopt_data
name|opt_data
decl_stmt|;
comment|/* States of the various parsing groups.  */
name|struct
name|group
modifier|*
name|groups
decl_stmt|;
comment|/* The end of the GROUPS array.  */
name|struct
name|group
modifier|*
name|egroup
decl_stmt|;
comment|/* An vector containing storage for the CHILD_INPUTS field in all groups.  */
name|void
modifier|*
modifier|*
name|child_inputs
decl_stmt|;
comment|/* True if we think using getopt is still useful; if false, then      remaining arguments are just passed verbatim with ARGP_KEY_ARG.  This is      cleared whenever getopt returns KEY_END, but may be set again if the user      moves the next argument pointer backwards.  */
name|int
name|try_getopt
decl_stmt|;
comment|/* State block supplied to parsing routines.  */
name|struct
name|argp_state
name|state
decl_stmt|;
comment|/* Memory used by this parser.  */
name|void
modifier|*
name|storage
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* The next usable entries in the various parser tables being filled in by    convert_options.  */
end_comment

begin_struct
struct|struct
name|parser_convert_state
block|{
name|struct
name|parser
modifier|*
name|parser
decl_stmt|;
name|char
modifier|*
name|short_end
decl_stmt|;
name|struct
name|option
modifier|*
name|long_end
decl_stmt|;
name|void
modifier|*
modifier|*
name|child_inputs_end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Converts all options in ARGP (which is put in GROUP) and ancestors    into getopt options stored in SHORT_OPTS and LONG_OPTS; SHORT_END and    CVT->LONG_END are the points at which new options are added.  Returns the    next unused group entry.  CVT holds state used during the conversion.  */
end_comment

begin_function
specifier|static
name|struct
name|group
modifier|*
name|convert_options
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|struct
name|group
modifier|*
name|parent
parameter_list|,
name|unsigned
name|parent_index
parameter_list|,
name|struct
name|group
modifier|*
name|group
parameter_list|,
name|struct
name|parser_convert_state
modifier|*
name|cvt
parameter_list|)
block|{
comment|/* REAL is the most recent non-alias value of OPT.  */
specifier|const
name|struct
name|argp_option
modifier|*
name|real
init|=
name|argp
operator|->
name|options
decl_stmt|;
specifier|const
name|struct
name|argp_child
modifier|*
name|children
init|=
name|argp
operator|->
name|children
decl_stmt|;
if|if
condition|(
name|real
operator|||
name|argp
operator|->
name|parser
condition|)
block|{
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
decl_stmt|;
if|if
condition|(
name|real
condition|)
for|for
control|(
name|opt
operator|=
name|real
init|;
operator|!
name|__option_is_end
argument_list|(
name|opt
argument_list|)
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|opt
operator|->
name|flags
operator|&
name|OPTION_ALIAS
operator|)
condition|)
comment|/* OPT isn't an alias, so we can use values from it.  */
name|real
operator|=
name|opt
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|real
operator|->
name|flags
operator|&
name|OPTION_DOC
operator|)
condition|)
comment|/* A real option (not just documentation).  */
block|{
if|if
condition|(
name|__option_is_short
argument_list|(
name|opt
argument_list|)
condition|)
comment|/* OPT can be used as a short option.  */
block|{
operator|*
name|cvt
operator|->
name|short_end
operator|++
operator|=
name|opt
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|real
operator|->
name|arg
condition|)
block|{
operator|*
name|cvt
operator|->
name|short_end
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|real
operator|->
name|flags
operator|&
name|OPTION_ARG_OPTIONAL
condition|)
operator|*
name|cvt
operator|->
name|short_end
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
operator|*
name|cvt
operator|->
name|short_end
operator|=
literal|'\0'
expr_stmt|;
comment|/* keep 0 terminated */
block|}
if|if
condition|(
name|opt
operator|->
name|name
operator|&&
name|find_long_option
argument_list|(
name|cvt
operator|->
name|parser
operator|->
name|long_opts
argument_list|,
name|opt
operator|->
name|name
argument_list|)
operator|<
literal|0
condition|)
comment|/* OPT can be used as a long option.  */
block|{
name|cvt
operator|->
name|long_end
operator|->
name|name
operator|=
name|opt
operator|->
name|name
expr_stmt|;
name|cvt
operator|->
name|long_end
operator|->
name|has_arg
operator|=
operator|(
name|real
operator|->
name|arg
condition|?
operator|(
name|real
operator|->
name|flags
operator|&
name|OPTION_ARG_OPTIONAL
condition|?
name|optional_argument
else|:
name|required_argument
operator|)
else|:
name|no_argument
operator|)
expr_stmt|;
name|cvt
operator|->
name|long_end
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* we add a disambiguating code to all the user's 		       values (which is removed before we actually call 		       the function to parse the value); this means that 		       the user loses use of the high 8 bits in all his 		       values (the sign of the lower bits is preserved 		       however)...  */
name|cvt
operator|->
name|long_end
operator|->
name|val
operator|=
operator|(
operator|(
name|opt
operator|->
name|key
operator||
name|real
operator|->
name|key
operator|)
operator|&
name|USER_MASK
operator|)
operator|+
operator|(
operator|(
operator|(
name|group
operator|-
name|cvt
operator|->
name|parser
operator|->
name|groups
operator|)
operator|+
literal|1
operator|)
operator|<<
name|USER_BITS
operator|)
expr_stmt|;
comment|/* Keep the LONG_OPTS list terminated.  */
operator|(
operator|++
name|cvt
operator|->
name|long_end
operator|)
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|group
operator|->
name|parser
operator|=
name|argp
operator|->
name|parser
expr_stmt|;
name|group
operator|->
name|argp
operator|=
name|argp
expr_stmt|;
name|group
operator|->
name|short_end
operator|=
name|cvt
operator|->
name|short_end
expr_stmt|;
name|group
operator|->
name|args_processed
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|group
operator|->
name|parent_index
operator|=
name|parent_index
expr_stmt|;
name|group
operator|->
name|input
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|hook
operator|=
literal|0
expr_stmt|;
name|group
operator|->
name|child_inputs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|children
condition|)
comment|/* Assign GROUP's CHILD_INPUTS field some space from            CVT->child_inputs_end.*/
block|{
name|unsigned
name|num_children
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|children
index|[
name|num_children
index|]
operator|.
name|argp
condition|)
name|num_children
operator|++
expr_stmt|;
name|group
operator|->
name|child_inputs
operator|=
name|cvt
operator|->
name|child_inputs_end
expr_stmt|;
name|cvt
operator|->
name|child_inputs_end
operator|+=
name|num_children
expr_stmt|;
block|}
name|parent
operator|=
name|group
operator|++
expr_stmt|;
block|}
else|else
name|parent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|children
condition|)
block|{
name|unsigned
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|children
operator|->
name|argp
condition|)
name|group
operator|=
name|convert_options
argument_list|(
name|children
operator|++
operator|->
name|argp
argument_list|,
name|parent
argument_list|,
name|index
operator|++
argument_list|,
name|group
argument_list|,
name|cvt
argument_list|)
expr_stmt|;
block|}
return|return
name|group
return|;
block|}
end_function

begin_comment
comment|/* Find the merged set of getopt options, with keys appropiately prefixed. */
end_comment

begin_function
specifier|static
name|void
name|parser_convert
parameter_list|(
name|struct
name|parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|parser_convert_state
name|cvt
decl_stmt|;
name|cvt
operator|.
name|parser
operator|=
name|parser
expr_stmt|;
name|cvt
operator|.
name|short_end
operator|=
name|parser
operator|->
name|short_opts
expr_stmt|;
name|cvt
operator|.
name|long_end
operator|=
name|parser
operator|->
name|long_opts
expr_stmt|;
name|cvt
operator|.
name|child_inputs_end
operator|=
name|parser
operator|->
name|child_inputs
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ARGP_IN_ORDER
condition|)
operator|*
name|cvt
operator|.
name|short_end
operator|++
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ARGP_NO_ARGS
condition|)
operator|*
name|cvt
operator|.
name|short_end
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|cvt
operator|.
name|short_end
operator|=
literal|'\0'
expr_stmt|;
name|cvt
operator|.
name|long_end
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|parser
operator|->
name|argp
operator|=
name|argp
expr_stmt|;
if|if
condition|(
name|argp
condition|)
name|parser
operator|->
name|egroup
operator|=
name|convert_options
argument_list|(
name|argp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|parser
operator|->
name|groups
argument_list|,
operator|&
name|cvt
argument_list|)
expr_stmt|;
else|else
name|parser
operator|->
name|egroup
operator|=
name|parser
operator|->
name|groups
expr_stmt|;
comment|/* No parsers at all! */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lengths of various parser fields which we will allocated.  */
end_comment

begin_struct
struct|struct
name|parser_sizes
block|{
name|size_t
name|short_len
decl_stmt|;
comment|/* Getopt short options string.  */
name|size_t
name|long_len
decl_stmt|;
comment|/* Getopt long options vector.  */
name|size_t
name|num_groups
decl_stmt|;
comment|/* Group structures we allocate.  */
name|size_t
name|num_child_inputs
decl_stmt|;
comment|/* Child input slots.  */
block|}
struct|;
end_struct

begin_comment
comment|/* For ARGP, increments the NUM_GROUPS field in SZS by the total number of  argp structures descended from it, and the SHORT_LEN& LONG_LEN fields by  the maximum lengths of the resulting merged getopt short options string and  long-options array, respectively.  */
end_comment

begin_function
specifier|static
name|void
name|calc_sizes
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|struct
name|parser_sizes
modifier|*
name|szs
parameter_list|)
block|{
specifier|const
name|struct
name|argp_child
modifier|*
name|child
init|=
name|argp
operator|->
name|children
decl_stmt|;
specifier|const
name|struct
name|argp_option
modifier|*
name|opt
init|=
name|argp
operator|->
name|options
decl_stmt|;
if|if
condition|(
name|opt
operator|||
name|argp
operator|->
name|parser
condition|)
block|{
name|szs
operator|->
name|num_groups
operator|++
expr_stmt|;
if|if
condition|(
name|opt
condition|)
block|{
name|int
name|num_opts
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|__option_is_end
argument_list|(
name|opt
operator|++
argument_list|)
condition|)
name|num_opts
operator|++
expr_stmt|;
name|szs
operator|->
name|short_len
operator|+=
name|num_opts
operator|*
literal|3
expr_stmt|;
comment|/* opt + up to 2 `:'s */
name|szs
operator|->
name|long_len
operator|+=
name|num_opts
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
condition|)
while|while
condition|(
name|child
operator|->
name|argp
condition|)
block|{
name|calc_sizes
argument_list|(
operator|(
name|child
operator|++
operator|)
operator|->
name|argp
argument_list|,
name|szs
argument_list|)
expr_stmt|;
name|szs
operator|->
name|num_child_inputs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initializes PARSER to parse ARGP in a manner described by FLAGS.  */
end_comment

begin_function
specifier|static
name|error_t
name|parser_init
parameter_list|(
name|struct
name|parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|input
parameter_list|)
block|{
name|error_t
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|struct
name|parser_sizes
name|szs
decl_stmt|;
name|struct
name|_getopt_data
name|opt_data
init|=
name|_GETOPT_DATA_INITIALIZER
decl_stmt|;
name|szs
operator|.
name|short_len
operator|=
operator|(
name|flags
operator|&
name|ARGP_NO_ARGS
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|szs
operator|.
name|long_len
operator|=
literal|0
expr_stmt|;
name|szs
operator|.
name|num_groups
operator|=
literal|0
expr_stmt|;
name|szs
operator|.
name|num_child_inputs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argp
condition|)
name|calc_sizes
argument_list|(
name|argp
argument_list|,
operator|&
name|szs
argument_list|)
expr_stmt|;
comment|/* Lengths of the various bits of storage used by PARSER.  */
define|#
directive|define
name|GLEN
value|(szs.num_groups + 1) * sizeof (struct group)
define|#
directive|define
name|CLEN
value|(szs.num_child_inputs * sizeof (void *))
define|#
directive|define
name|LLEN
value|((szs.long_len + 1) * sizeof (struct option))
define|#
directive|define
name|SLEN
value|(szs.short_len + 1)
name|parser
operator|->
name|storage
operator|=
name|malloc
argument_list|(
name|GLEN
operator|+
name|CLEN
operator|+
name|LLEN
operator|+
name|SLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parser
operator|->
name|storage
condition|)
return|return
name|ENOMEM
return|;
name|parser
operator|->
name|groups
operator|=
name|parser
operator|->
name|storage
expr_stmt|;
name|parser
operator|->
name|child_inputs
operator|=
name|parser
operator|->
name|storage
operator|+
name|GLEN
expr_stmt|;
name|parser
operator|->
name|long_opts
operator|=
name|parser
operator|->
name|storage
operator|+
name|GLEN
operator|+
name|CLEN
expr_stmt|;
name|parser
operator|->
name|short_opts
operator|=
name|parser
operator|->
name|storage
operator|+
name|GLEN
operator|+
name|CLEN
operator|+
name|LLEN
expr_stmt|;
name|parser
operator|->
name|opt_data
operator|=
name|opt_data
expr_stmt|;
name|memset
argument_list|(
name|parser
operator|->
name|child_inputs
argument_list|,
literal|0
argument_list|,
name|szs
operator|.
name|num_child_inputs
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|parser_convert
argument_list|(
name|parser
argument_list|,
name|argp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|parser
operator|->
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|argp_state
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|state
operator|.
name|root_argp
operator|=
name|parser
operator|->
name|argp
expr_stmt|;
name|parser
operator|->
name|state
operator|.
name|argc
operator|=
name|argc
expr_stmt|;
name|parser
operator|->
name|state
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|parser
operator|->
name|state
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|parser
operator|->
name|state
operator|.
name|err_stream
operator|=
name|stderr
expr_stmt|;
name|parser
operator|->
name|state
operator|.
name|out_stream
operator|=
name|stdout
expr_stmt|;
name|parser
operator|->
name|state
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Tell getopt to initialize.  */
name|parser
operator|->
name|state
operator|.
name|pstate
operator|=
name|parser
expr_stmt|;
name|parser
operator|->
name|try_getopt
operator|=
literal|1
expr_stmt|;
comment|/* Call each parser for the first time, giving it a chance to propagate      values to child parsers.  */
if|if
condition|(
name|parser
operator|->
name|groups
operator|<
name|parser
operator|->
name|egroup
condition|)
name|parser
operator|->
name|groups
operator|->
name|input
operator|=
name|input
expr_stmt|;
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|groups
init|;
name|group
operator|<
name|parser
operator|->
name|egroup
operator|&&
operator|(
operator|!
name|err
operator|||
name|err
operator|==
name|EBADKEY
operator|)
condition|;
name|group
operator|++
control|)
block|{
if|if
condition|(
name|group
operator|->
name|parent
condition|)
comment|/* If a child parser, get the initial input value from the parent. */
name|group
operator|->
name|input
operator|=
name|group
operator|->
name|parent
operator|->
name|child_inputs
index|[
name|group
operator|->
name|parent_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|group
operator|->
name|parser
operator|&&
name|group
operator|->
name|argp
operator|->
name|children
operator|&&
name|group
operator|->
name|argp
operator|->
name|children
operator|->
name|argp
condition|)
comment|/* For the special case where no parsing function is supplied for an 	   argp, propagate its input to its first child, if any (this just 	   makes very simple wrapper argps more convenient).  */
name|group
operator|->
name|child_inputs
index|[
literal|0
index|]
operator|=
name|group
operator|->
name|input
expr_stmt|;
name|err
operator|=
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|ARGP_KEY_INIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
name|err
operator|=
literal|0
expr_stmt|;
comment|/* Some parser didn't understand.  */
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|flags
operator|&
name|ARGP_NO_ERRS
condition|)
block|{
name|parser
operator|->
name|opt_data
operator|.
name|opterr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|flags
operator|&
name|ARGP_PARSE_ARGV0
condition|)
comment|/* getopt always skips ARGV[0], so we have to fake it out.  As long 	   as OPTERR is 0, then it shouldn't actually try to access it.  */
name|parser
operator|->
name|state
operator|.
name|argv
operator|--
operator|,
name|parser
operator|->
name|state
operator|.
name|argc
operator|++
expr_stmt|;
block|}
else|else
name|parser
operator|->
name|opt_data
operator|.
name|opterr
operator|=
literal|1
expr_stmt|;
comment|/* Print error messages.  */
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|argv
operator|==
name|argv
operator|&&
name|argv
index|[
literal|0
index|]
condition|)
comment|/* There's an argv[0]; use it for messages.  */
block|{
name|char
modifier|*
name|short_name
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|parser
operator|->
name|state
operator|.
name|name
operator|=
name|short_name
condition|?
name|short_name
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|parser
operator|->
name|state
operator|.
name|name
operator|=
name|__argp_short_program_name
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free any storage consumed by PARSER (but not PARSER itself).  */
end_comment

begin_function
specifier|static
name|error_t
name|parser_finalize
parameter_list|(
name|struct
name|parser
modifier|*
name|parser
parameter_list|,
name|error_t
name|err
parameter_list|,
name|int
name|arg_ebadkey
parameter_list|,
name|int
modifier|*
name|end_index
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|group
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADKEY
operator|&&
name|arg_ebadkey
condition|)
comment|/* Suppress errors generated by unparsed arguments.  */
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|next
operator|==
name|parser
operator|->
name|state
operator|.
name|argc
condition|)
comment|/* We successfully parsed all arguments!  Call all the parsers again, 	   just a few more times... */
block|{
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|groups
init|;
name|group
operator|<
name|parser
operator|->
name|egroup
operator|&&
operator|(
operator|!
name|err
operator|||
name|err
operator|==
name|EBADKEY
operator|)
condition|;
name|group
operator|++
control|)
if|if
condition|(
name|group
operator|->
name|args_processed
operator|==
literal|0
condition|)
name|err
operator|=
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|ARGP_KEY_NO_ARGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|egroup
operator|-
literal|1
init|;
name|group
operator|>=
name|parser
operator|->
name|groups
operator|&&
operator|(
operator|!
name|err
operator|||
name|err
operator|==
name|EBADKEY
operator|)
condition|;
name|group
operator|--
control|)
name|err
operator|=
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|ARGP_KEY_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
name|err
operator|=
literal|0
expr_stmt|;
comment|/* Some parser didn't understand.  */
comment|/* Tell the user that all arguments are parsed.  */
if|if
condition|(
name|end_index
condition|)
operator|*
name|end_index
operator|=
name|parser
operator|->
name|state
operator|.
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end_index
condition|)
comment|/* Return any remaining arguments to the user.  */
operator|*
name|end_index
operator|=
name|parser
operator|->
name|state
operator|.
name|next
expr_stmt|;
else|else
comment|/* No way to return the remaining arguments, they must be bogus. */
block|{
if|if
condition|(
operator|!
operator|(
name|parser
operator|->
name|state
operator|.
name|flags
operator|&
name|ARGP_NO_ERRS
operator|)
operator|&&
name|parser
operator|->
name|state
operator|.
name|err_stream
condition|)
name|fprintf
argument_list|(
name|parser
operator|->
name|state
operator|.
name|err_stream
argument_list|,
name|dgettext
argument_list|(
name|parser
operator|->
name|argp
operator|->
name|argp_domain
argument_list|,
literal|"%s: Too many arguments\n"
argument_list|)
argument_list|,
name|parser
operator|->
name|state
operator|.
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|EBADKEY
expr_stmt|;
block|}
block|}
comment|/* Okay, we're all done, with either an error or success; call the parsers      to indicate which one.  */
if|if
condition|(
name|err
condition|)
block|{
comment|/* Maybe print an error message.  */
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
comment|/* An appropriate message describing what the error was should have 	   been printed earlier.  */
name|__argp_state_help
argument_list|(
operator|&
name|parser
operator|->
name|state
argument_list|,
name|parser
operator|->
name|state
operator|.
name|err_stream
argument_list|,
name|ARGP_HELP_STD_ERR
argument_list|)
expr_stmt|;
comment|/* Since we didn't exit, give each parser an error indication.  */
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|groups
init|;
name|group
operator|<
name|parser
operator|->
name|egroup
condition|;
name|group
operator|++
control|)
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|ARGP_KEY_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Notify parsers of success, and propagate back values from parsers.  */
block|{
comment|/* We pass over the groups in reverse order so that child groups are 	 given a chance to do there processing before passing back a value to 	 the parent.  */
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|egroup
operator|-
literal|1
init|;
name|group
operator|>=
name|parser
operator|->
name|groups
operator|&&
operator|(
operator|!
name|err
operator|||
name|err
operator|==
name|EBADKEY
operator|)
condition|;
name|group
operator|--
control|)
name|err
operator|=
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|ARGP_KEY_SUCCESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
name|err
operator|=
literal|0
expr_stmt|;
comment|/* Some parser didn't understand.  */
block|}
comment|/* Call parsers once more, to do any final cleanup.  Errors are ignored.  */
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|egroup
operator|-
literal|1
init|;
name|group
operator|>=
name|parser
operator|->
name|groups
condition|;
name|group
operator|--
control|)
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|ARGP_KEY_FINI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
name|err
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|parser
operator|->
name|storage
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call the user parsers to parse the non-option argument VAL, at the current    position, returning any error.  The state NEXT pointer is assumed to have    been adjusted (by getopt) to point after this argument; this function will    adjust it correctly to reflect however many args actually end up being    consumed.  */
end_comment

begin_function
specifier|static
name|error_t
name|parser_parse_arg
parameter_list|(
name|struct
name|parser
modifier|*
name|parser
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
comment|/* Save the starting value of NEXT, first adjusting it so that the arg      we're parsing is again the front of the arg vector.  */
name|int
name|index
init|=
operator|--
name|parser
operator|->
name|state
operator|.
name|next
decl_stmt|;
name|error_t
name|err
init|=
name|EBADKEY
decl_stmt|;
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|int
name|key
init|=
literal|0
decl_stmt|;
comment|/* Which of ARGP_KEY_ARG[S] we used.  */
comment|/* Try to parse the argument in each parser.  */
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|groups
init|;
name|group
operator|<
name|parser
operator|->
name|egroup
operator|&&
name|err
operator|==
name|EBADKEY
condition|;
name|group
operator|++
control|)
block|{
name|parser
operator|->
name|state
operator|.
name|next
operator|++
expr_stmt|;
comment|/* For ARGP_KEY_ARG, consume the arg.  */
name|key
operator|=
name|ARGP_KEY_ARG
expr_stmt|;
name|err
operator|=
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
comment|/* This parser doesn't like ARGP_KEY_ARG; try ARGP_KEY_ARGS instead. */
block|{
name|parser
operator|->
name|state
operator|.
name|next
operator|--
expr_stmt|;
comment|/* For ARGP_KEY_ARGS, put back the arg.  */
name|key
operator|=
name|ARGP_KEY_ARGS
expr_stmt|;
name|err
operator|=
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
if|if
condition|(
name|key
operator|==
name|ARGP_KEY_ARGS
condition|)
comment|/* The default for ARGP_KEY_ARGS is to assume that if NEXT isn't 	   changed by the user, *all* arguments should be considered 	   consumed.  */
name|parser
operator|->
name|state
operator|.
name|next
operator|=
name|parser
operator|->
name|state
operator|.
name|argc
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|next
operator|>
name|index
condition|)
comment|/* Remember that we successfully processed a non-option 	   argument -- but only if the user hasn't gotten tricky and set 	   the clock back.  */
operator|(
operator|--
name|group
operator|)
operator|->
name|args_processed
operator|+=
operator|(
name|parser
operator|->
name|state
operator|.
name|next
operator|-
name|index
operator|)
expr_stmt|;
else|else
comment|/* The user wants to reparse some args, give getopt another try.  */
name|parser
operator|->
name|try_getopt
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call the user parsers to parse the option OPT, with argument VAL, at the    current position, returning any error.  */
end_comment

begin_function
specifier|static
name|error_t
name|parser_parse_opt
parameter_list|(
name|struct
name|parser
modifier|*
name|parser
parameter_list|,
name|int
name|opt
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
comment|/* The group key encoded in the high bits; 0 for short opts or      group_number + 1 for long opts.  */
name|int
name|group_key
init|=
name|opt
operator|>>
name|USER_BITS
decl_stmt|;
name|error_t
name|err
init|=
name|EBADKEY
decl_stmt|;
if|if
condition|(
name|group_key
operator|==
literal|0
condition|)
comment|/* A short option.  By comparing OPT's position in SHORT_OPTS to the        various starting positions in each group's SHORT_END field, we can        determine which group OPT came from.  */
block|{
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
name|short_index
init|=
name|strchr
argument_list|(
name|parser
operator|->
name|short_opts
argument_list|,
name|opt
argument_list|)
decl_stmt|;
if|if
condition|(
name|short_index
condition|)
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|groups
init|;
name|group
operator|<
name|parser
operator|->
name|egroup
condition|;
name|group
operator|++
control|)
if|if
condition|(
name|group
operator|->
name|short_end
operator|>
name|short_index
condition|)
block|{
name|err
operator|=
name|group_parse
argument_list|(
name|group
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
name|opt
argument_list|,
name|parser
operator|->
name|opt_data
operator|.
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* A long option.  We use shifts instead of masking for extracting        the user value in order to preserve the sign.  */
name|err
operator|=
name|group_parse
argument_list|(
operator|&
name|parser
operator|->
name|groups
index|[
name|group_key
operator|-
literal|1
index|]
argument_list|,
operator|&
name|parser
operator|->
name|state
argument_list|,
operator|(
name|opt
operator|<<
name|GROUP_BITS
operator|)
operator|>>
name|GROUP_BITS
argument_list|,
name|parser
operator|->
name|opt_data
operator|.
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
comment|/* At least currently, an option not recognized is an error in the        parser, because we pre-compute which parser is supposed to deal        with each option.  */
block|{
specifier|static
specifier|const
name|char
name|bad_key_err
index|[]
init|=
name|N_
argument_list|(
literal|"(PROGRAM ERROR) Option should have been recognized!?"
argument_list|)
decl_stmt|;
if|if
condition|(
name|group_key
operator|==
literal|0
condition|)
name|__argp_error
argument_list|(
operator|&
name|parser
operator|->
name|state
argument_list|,
literal|"-%c: %s"
argument_list|,
name|opt
argument_list|,
name|dgettext
argument_list|(
name|parser
operator|->
name|argp
operator|->
name|argp_domain
argument_list|,
name|bad_key_err
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|option
modifier|*
name|long_opt
init|=
name|parser
operator|->
name|long_opts
decl_stmt|;
while|while
condition|(
name|long_opt
operator|->
name|val
operator|!=
name|opt
operator|&&
name|long_opt
operator|->
name|name
condition|)
name|long_opt
operator|++
expr_stmt|;
name|__argp_error
argument_list|(
operator|&
name|parser
operator|->
name|state
argument_list|,
literal|"--%s: %s"
argument_list|,
name|long_opt
operator|->
name|name
condition|?
name|long_opt
operator|->
name|name
else|:
literal|"???"
argument_list|,
name|dgettext
argument_list|(
name|parser
operator|->
name|argp
operator|->
name|argp_domain
argument_list|,
name|bad_key_err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the next argument in PARSER (as indicated by PARSER->state.next).    Any error from the parsers is returned, and *ARGP_EBADKEY indicates    whether a value of EBADKEY is due to an unrecognized argument (which is    generally not fatal).  */
end_comment

begin_function
specifier|static
name|error_t
name|parser_parse_next
parameter_list|(
name|struct
name|parser
modifier|*
name|parser
parameter_list|,
name|int
modifier|*
name|arg_ebadkey
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|error_t
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|quoted
operator|&&
name|parser
operator|->
name|state
operator|.
name|next
operator|<
name|parser
operator|->
name|state
operator|.
name|quoted
condition|)
comment|/* The next argument pointer has been moved to before the quoted        region, so pretend we never saw the quoting `--', and give getopt        another chance.  If the user hasn't removed it, getopt will just        process it again.  */
name|parser
operator|->
name|state
operator|.
name|quoted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|try_getopt
operator|&&
operator|!
name|parser
operator|->
name|state
operator|.
name|quoted
condition|)
comment|/* Give getopt a chance to parse this.  */
block|{
comment|/* Put it back in OPTIND for getopt.  */
name|parser
operator|->
name|opt_data
operator|.
name|optind
operator|=
name|parser
operator|->
name|state
operator|.
name|next
expr_stmt|;
comment|/* Distinguish KEY_ERR from a real option.  */
name|parser
operator|->
name|opt_data
operator|.
name|optopt
operator|=
name|KEY_END
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|flags
operator|&
name|ARGP_LONG_ONLY
condition|)
name|opt
operator|=
name|_getopt_long_only_r
argument_list|(
name|parser
operator|->
name|state
operator|.
name|argc
argument_list|,
name|parser
operator|->
name|state
operator|.
name|argv
argument_list|,
name|parser
operator|->
name|short_opts
argument_list|,
name|parser
operator|->
name|long_opts
argument_list|,
literal|0
argument_list|,
operator|&
name|parser
operator|->
name|opt_data
argument_list|)
expr_stmt|;
else|else
name|opt
operator|=
name|_getopt_long_r
argument_list|(
name|parser
operator|->
name|state
operator|.
name|argc
argument_list|,
name|parser
operator|->
name|state
operator|.
name|argv
argument_list|,
name|parser
operator|->
name|short_opts
argument_list|,
name|parser
operator|->
name|long_opts
argument_list|,
literal|0
argument_list|,
operator|&
name|parser
operator|->
name|opt_data
argument_list|)
expr_stmt|;
comment|/* And see what getopt did.  */
name|parser
operator|->
name|state
operator|.
name|next
operator|=
name|parser
operator|->
name|opt_data
operator|.
name|optind
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|KEY_END
condition|)
comment|/* Getopt says there are no more options, so stop using 	   getopt; we'll continue if necessary on our own.  */
block|{
name|parser
operator|->
name|try_getopt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|next
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|parser
operator|->
name|state
operator|.
name|argv
index|[
name|parser
operator|->
name|state
operator|.
name|next
operator|-
literal|1
index|]
argument_list|,
name|QUOTE
argument_list|)
operator|==
literal|0
condition|)
comment|/* Not only is this the end of the options, but it's a 	       `quoted' region, which may have args that *look* like 	       options, so we definitely shouldn't try to use getopt past 	       here, whatever happens.  */
name|parser
operator|->
name|state
operator|.
name|quoted
operator|=
name|parser
operator|->
name|state
operator|.
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|==
name|KEY_ERR
operator|&&
name|parser
operator|->
name|opt_data
operator|.
name|optopt
operator|!=
name|KEY_END
condition|)
comment|/* KEY_ERR can have the same value as a valid user short 	   option, but in the case of a real error, getopt sets OPTOPT 	   to the offending character, which can never be KEY_END.  */
block|{
operator|*
name|arg_ebadkey
operator|=
literal|0
expr_stmt|;
return|return
name|EBADKEY
return|;
block|}
block|}
else|else
name|opt
operator|=
name|KEY_END
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|KEY_END
condition|)
block|{
comment|/* We're past what getopt considers the options.  */
if|if
condition|(
name|parser
operator|->
name|state
operator|.
name|next
operator|>=
name|parser
operator|->
name|state
operator|.
name|argc
operator|||
operator|(
name|parser
operator|->
name|state
operator|.
name|flags
operator|&
name|ARGP_NO_ARGS
operator|)
condition|)
comment|/* Indicate that we're done.  */
block|{
operator|*
name|arg_ebadkey
operator|=
literal|1
expr_stmt|;
return|return
name|EBADKEY
return|;
block|}
else|else
comment|/* A non-option arg; simulate what getopt might have done.  */
block|{
name|opt
operator|=
name|KEY_ARG
expr_stmt|;
name|parser
operator|->
name|opt_data
operator|.
name|optarg
operator|=
name|parser
operator|->
name|state
operator|.
name|argv
index|[
name|parser
operator|->
name|state
operator|.
name|next
operator|++
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opt
operator|==
name|KEY_ARG
condition|)
comment|/* A non-option argument; try each parser in turn.  */
name|err
operator|=
name|parser_parse_arg
argument_list|(
name|parser
argument_list|,
name|parser
operator|->
name|opt_data
operator|.
name|optarg
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|parser_parse_opt
argument_list|(
name|parser
argument_list|,
name|opt
argument_list|,
name|parser
operator|->
name|opt_data
operator|.
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EBADKEY
condition|)
operator|*
name|arg_ebadkey
operator|=
operator|(
name|opt
operator|==
name|KEY_END
operator|||
name|opt
operator|==
name|KEY_ARG
operator|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the options strings in ARGC& ARGV according to the argp in ARGP.    FLAGS is one of the ARGP_ flags above.  If END_INDEX is non-NULL, the    index in ARGV of the first unparsed option is returned in it.  If an    unknown option is present, EINVAL is returned; if some parser routine    returned a non-zero value, it is returned; otherwise 0 is returned.  */
end_comment

begin_function
name|error_t
name|__argp_parse
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|int
modifier|*
name|end_index
parameter_list|,
name|void
modifier|*
name|input
parameter_list|)
block|{
name|error_t
name|err
decl_stmt|;
name|struct
name|parser
name|parser
decl_stmt|;
comment|/* If true, then err == EBADKEY is a result of a non-option argument failing      to be parsed (which in some cases isn't actually an error).  */
name|int
name|arg_ebadkey
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARGP_NO_HELP
operator|)
condition|)
comment|/* Add our own options.  */
block|{
name|struct
name|argp_child
modifier|*
name|child
init|=
name|alloca
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argp_child
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|argp
modifier|*
name|top_argp
init|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|argp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* TOP_ARGP has no options, it just serves to group the user& default 	 argps.  */
name|memset
argument_list|(
name|top_argp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|top_argp
argument_list|)
argument_list|)
expr_stmt|;
name|top_argp
operator|->
name|children
operator|=
name|child
expr_stmt|;
name|memset
argument_list|(
name|child
argument_list|,
literal|0
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argp_child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
condition|)
operator|(
name|child
operator|++
operator|)
operator|->
name|argp
operator|=
name|argp
expr_stmt|;
operator|(
name|child
operator|++
operator|)
operator|->
name|argp
operator|=
operator|&
name|argp_default_argp
expr_stmt|;
if|if
condition|(
name|argp_program_version
operator|||
name|argp_program_version_hook
condition|)
operator|(
name|child
operator|++
operator|)
operator|->
name|argp
operator|=
operator|&
name|argp_version_argp
expr_stmt|;
name|child
operator|->
name|argp
operator|=
literal|0
expr_stmt|;
name|argp
operator|=
name|top_argp
expr_stmt|;
block|}
comment|/* Construct a parser for these arguments.  */
name|err
operator|=
name|parser_init
argument_list|(
operator|&
name|parser
argument_list|,
name|argp
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|,
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
comment|/* Parse! */
block|{
while|while
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|parser_parse_next
argument_list|(
operator|&
name|parser
argument_list|,
operator|&
name|arg_ebadkey
argument_list|)
expr_stmt|;
name|err
operator|=
name|parser_finalize
argument_list|(
operator|&
name|parser
argument_list|,
name|err
argument_list|,
name|arg_ebadkey
argument_list|,
name|end_index
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__argp_parse
argument_list|,
argument|argp_parse
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return the input field for ARGP in the parser corresponding to STATE; used    by the help routines.  */
end_comment

begin_function
name|void
modifier|*
name|__argp_input
parameter_list|(
specifier|const
name|struct
name|argp
modifier|*
name|argp
parameter_list|,
specifier|const
name|struct
name|argp_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
condition|)
block|{
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|struct
name|parser
modifier|*
name|parser
init|=
name|state
operator|->
name|pstate
decl_stmt|;
for|for
control|(
name|group
operator|=
name|parser
operator|->
name|groups
init|;
name|group
operator|<
name|parser
operator|->
name|egroup
condition|;
name|group
operator|++
control|)
if|if
condition|(
name|group
operator|->
name|argp
operator|==
name|argp
condition|)
return|return
name|group
operator|->
name|input
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_macro
name|weak_alias
argument_list|(
argument|__argp_input
argument_list|,
argument|_argp_input
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

