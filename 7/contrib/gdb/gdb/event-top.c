begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level stuff for GDB, the GNU debugger.    Copyright 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.    Written by Elena Zannoni<ezannoni@cygnus.com> of Cygnus Solutions.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_comment
comment|/* for job_control */
end_comment

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"interps.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* For dont_repeat() */
end_comment

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* readline include files */
end_comment

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"readline/history.h"
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_function_decl
specifier|static
name|void
name|rl_callback_read_char_wrapper
parameter_list|(
name|gdb_client_data
name|client_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|command_line_handler
parameter_list|(
name|char
modifier|*
name|rl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|command_line_handler_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_line_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_annotation_level
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|command_handler
parameter_list|(
name|char
modifier|*
name|command
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_do_nothing
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_disconnect
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_stop_sig
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_float_handler
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Signal handlers. */
end_comment

begin_function_decl
specifier|static
name|void
name|handle_sigquit
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_sighup
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_sigfpe
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|handle_sigwinch
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions to be invoked by the event loop in response to    signals. */
end_comment

begin_function_decl
specifier|static
name|void
name|async_do_nothing
parameter_list|(
name|gdb_client_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_disconnect
parameter_list|(
name|gdb_client_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_float_handler
parameter_list|(
name|gdb_client_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_stop_sig
parameter_list|(
name|gdb_client_data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Readline offers an alternate interface, via callback    functions. These are all included in the file callback.c in the    readline distribution.  This file provides (mainly) a function, which    the event loop uses as callback (i.e. event handler) whenever an event    is detected on the standard input file descriptor.    readline_callback_read_char is called (by the GDB event loop) whenever    there is a new character ready on the input stream. This function    incrementally builds a buffer internal to readline where it    accumulates the line read up to the point of invocation.  In the    special case in which the character read is newline, the function    invokes a GDB supplied callback routine, which does the processing of    a full command line.  This latter routine is the asynchronous analog    of the old command_line_input in gdb. Instead of invoking (and waiting    for) readline to read the command line and pass it back to    command_loop for processing, the new command_line_handler function has    the command line already available as its parameter.  INPUT_HANDLER is    to be set to the function that readline will invoke when a complete    line of input is ready.  CALL_READLINE is to be set to the function    that readline offers as callback to the event_loop. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|input_handler
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|call_readline
function_decl|)
parameter_list|(
name|gdb_client_data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Important variables for the event loop. */
end_comment

begin_comment
comment|/* This is used to determine if GDB is using the readline library or    its own simplified form of readline. It is used by the asynchronous    form of the set editing command.    ezannoni: as of 1999-04-29 I expect that this    variable will not be used after gdb is changed to use the event    loop as default engine, and event-top.c is merged into top.c. */
end_comment

begin_decl_stmt
name|int
name|async_command_editing_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable contains the new prompt that the user sets with the    set prompt command. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|new_async_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the annotation suffix that will be used when the    annotation_level is 2. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|async_annotation_suffix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used to display the notification of the completion of an    asynchronous execution command. */
end_comment

begin_decl_stmt
name|int
name|exec_done_display_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the file descriptor for the input stream that GDB uses to    read commands from. */
end_comment

begin_decl_stmt
name|int
name|input_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the prompt stack. Prompts will be pushed on the stack as    needed by the different 'kinds' of user inputs GDB is asking    for. See event-loop.h. */
end_comment

begin_decl_stmt
name|struct
name|prompts
name|the_prompts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal handling variables */
end_comment

begin_comment
comment|/* Each of these is a pointer to a function that the event loop will    invoke if the corresponding signal has received. The real signal    handlers mark these functions as ready to be executed and the event    loop, in a later iteration, calls them. See the function    invoke_async_signal_handler. */
end_comment

begin_decl_stmt
name|void
modifier|*
name|sigint_token
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGHUP
end_ifdef

begin_decl_stmt
name|void
modifier|*
name|sighup_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
modifier|*
name|sigquit_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|sigfpe_token
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
end_if

begin_decl_stmt
name|void
modifier|*
name|sigwinch_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_SIGNAL
end_ifdef

begin_decl_stmt
name|void
modifier|*
name|sigtstp_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Structure to save a partially entered command.  This is used when    the user types '\' at the end of a command line. This is necessary    because each line of input is handled by a different call to    command_line_handler, and normally there is no state retained    between different calls. */
end_comment

begin_decl_stmt
name|int
name|more_to_come
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|readline_input_state
block|{
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|char
modifier|*
name|linebuffer_ptr
decl_stmt|;
block|}
name|readline_input_state
struct|;
end_struct

begin_comment
comment|/* This hook is called by rl_callback_read_char_wrapper after each    character is processed.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|after_char_processing_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Wrapper function for calling into the readline library. The event    loop expects the callback function to have a paramter, while readline     expects none. */
end_comment

begin_function
specifier|static
name|void
name|rl_callback_read_char_wrapper
parameter_list|(
name|gdb_client_data
name|client_data
parameter_list|)
block|{
name|rl_callback_read_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|after_char_processing_hook
condition|)
call|(
modifier|*
name|after_char_processing_hook
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize all the necessary variables, start the event loop,    register readline, and stdin, start the loop. */
end_comment

begin_function
name|void
name|cli_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|a_prompt
decl_stmt|;
name|char
modifier|*
name|gdb_prompt
init|=
name|get_prompt
argument_list|()
decl_stmt|;
comment|/* If we are using readline, set things up and display the first      prompt, otherwise just print the prompt. */
if|if
condition|(
name|async_command_editing_p
condition|)
block|{
comment|/* Tell readline what the prompt to display is and what function it          will need to call after a whole line is read. This also displays          the first prompt. */
name|length
operator|=
name|strlen
argument_list|(
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|gdb_prompt
argument_list|)
operator|+
name|strlen
argument_list|(
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|a_prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|a_prompt
argument_list|,
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|a_prompt
argument_list|,
name|gdb_prompt
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|a_prompt
argument_list|,
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rl_callback_handler_install
argument_list|(
name|a_prompt
argument_list|,
name|input_handler
argument_list|)
expr_stmt|;
block|}
else|else
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Now it's time to start the event loop. */
name|start_event_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the function to be invoked every time there is a character    ready on stdin. This is used when the user sets the editing off,    therefore bypassing readline, and letting gdb handle the input    itself, via gdb_readline2. Also it is used in the opposite case in    which the user sets editing on again, by restoring readline    handling of the input. */
end_comment

begin_function
specifier|static
name|void
name|change_line_handler
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* NOTE: this operates on input_fd, not instream. If we are reading      commands from a file, instream will point to the file. However in      async mode, we always read commands from a file with editing      off. This means that the 'set editing on/off' will have effect      only on the interactive session. */
if|if
condition|(
name|async_command_editing_p
condition|)
block|{
comment|/* Turn on editing by using readline. */
name|call_readline
operator|=
name|rl_callback_read_char_wrapper
expr_stmt|;
name|input_handler
operator|=
name|command_line_handler
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off editing by using gdb_readline2. */
name|rl_callback_handler_remove
argument_list|()
expr_stmt|;
name|call_readline
operator|=
name|gdb_readline2
expr_stmt|;
comment|/* Set up the command handler as well, in case we are called as          first thing from .gdbinit. */
name|input_handler
operator|=
name|command_line_handler
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Displays the prompt. The prompt that is displayed is the current    top of the prompt stack, if the argument NEW_PROMPT is    0. Otherwise, it displays whatever NEW_PROMPT is. This is used    after each gdb command has completed, and in the following cases:    1. when the user enters a command line which is ended by '\'    indicating that the command will continue on the next line.    In that case the prompt that is displayed is the empty string.    2. When the user is entering 'commands' for a breakpoint, or    actions for a tracepoint. In this case the prompt will be '>'    3. Other????    FIXME: 2.& 3. not implemented yet for async. */
end_comment

begin_function
name|void
name|display_gdb_prompt
parameter_list|(
name|char
modifier|*
name|new_prompt
parameter_list|)
block|{
name|int
name|prompt_length
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|gdb_prompt
init|=
name|get_prompt
argument_list|()
decl_stmt|;
comment|/* Each interpreter has its own rules on displaying the command      prompt.  */
if|if
condition|(
operator|!
name|current_interp_display_prompt_p
argument_list|()
condition|)
return|return;
if|if
condition|(
name|target_executing
operator|&&
name|sync_execution
condition|)
block|{
comment|/* This is to trick readline into not trying to display the          prompt.  Even though we display the prompt using this          function, readline still tries to do its own display if we          don't call rl_callback_handler_install and          rl_callback_handler_remove (which readline detects because a          global variable is not set). If readline did that, it could          mess up gdb signal handlers for SIGINT.  Readline assumes          that between calls to rl_set_signals and rl_clear_signals gdb          doesn't do anything with the signal handlers. Well, that's          not the case, because when the target executes we change the          SIGINT signal handler. If we allowed readline to display the          prompt, the signal handler change would happen exactly          between the calls to the above two functions.          Calling rl_callback_handler_remove(), does the job. */
name|rl_callback_handler_remove
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|new_prompt
condition|)
block|{
comment|/* Just use the top of the prompt stack. */
name|prompt_length
operator|=
name|strlen
argument_list|(
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|gdb_prompt
argument_list|)
operator|+
literal|1
expr_stmt|;
name|new_prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|prompt_length
argument_list|)
expr_stmt|;
comment|/* Prefix needs to have new line at end. */
name|strcpy
argument_list|(
name|new_prompt
argument_list|,
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new_prompt
argument_list|,
name|gdb_prompt
argument_list|)
expr_stmt|;
comment|/* Suffix needs to have a new line at end and \032 \032 at          beginning. */
name|strcat
argument_list|(
name|new_prompt
argument_list|,
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|async_command_editing_p
condition|)
block|{
name|rl_callback_handler_remove
argument_list|()
expr_stmt|;
name|rl_callback_handler_install
argument_list|(
name|new_prompt
argument_list|,
name|input_handler
argument_list|)
expr_stmt|;
block|}
comment|/* new_prompt at this point can be the top of the stack or the one passed in */
elseif|else
if|if
condition|(
name|new_prompt
condition|)
block|{
comment|/* Don't use a _filtered function here.  It causes the assumed          character position to be off, since the newline we read from          the user is not accounted for.  */
name|fputs_unfiltered
argument_list|(
name|new_prompt
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used when the user requests a different annotation level, with    'set annotate'. It pushes a new prompt (with prefix and suffix) on top    of the prompt stack, if the annotation level desired is 2, otherwise    it pops the top of the prompt stack when we want the annotation level    to be the normal ones (1 or 0). */
end_comment

begin_function
specifier|static
name|void
name|change_annotation_level
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
literal|0
argument_list|)
operator|||
operator|!
name|PROMPT
argument_list|(
literal|0
argument_list|)
operator|||
operator|!
name|SUFFIX
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|/* The prompt stack has not been initialized to "", we are          using gdb w/o the --async switch */
name|warning
argument_list|(
literal|"Command has same effect as set annotate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|annotation_level
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
condition|)
block|{
comment|/* Push a new prompt if the previous annotation_level was not>1. */
name|prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|async_annotation_suffix
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prefix
argument_list|,
literal|"\n\032\032pre-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|prefix
argument_list|,
name|async_annotation_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|prefix
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|suffix
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|async_annotation_suffix
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|suffix
argument_list|,
literal|"\n\032\032"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|suffix
argument_list|,
name|async_annotation_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|suffix
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|push_prompt
argument_list|(
name|prefix
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
condition|)
block|{
comment|/* Pop the top of the stack, we are going back to annotation< 1. */
name|pop_prompt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Pushes a new prompt on the prompt stack. Each prompt has three    parts: prefix, prompt, suffix. Usually prefix and suffix are empty    strings, except when the annotation level is 2. Memory is allocated    within savestring for the new prompt. */
end_comment

begin_function
name|void
name|push_prompt
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|prompt
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|the_prompts
operator|.
name|top
operator|++
expr_stmt|;
name|PREFIX
argument_list|(
literal|0
argument_list|)
operator|=
name|savestring
argument_list|(
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that this function is used by the set annotate 2      command. This is why we take care of saving the old prompt      in case a new one is not specified. */
if|if
condition|(
name|prompt
condition|)
name|PROMPT
argument_list|(
literal|0
argument_list|)
operator|=
name|savestring
argument_list|(
name|prompt
argument_list|,
name|strlen
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PROMPT
argument_list|(
literal|0
argument_list|)
operator|=
name|savestring
argument_list|(
name|PROMPT
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|PROMPT
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SUFFIX
argument_list|(
literal|0
argument_list|)
operator|=
name|savestring
argument_list|(
name|suffix
argument_list|,
name|strlen
argument_list|(
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pops the top of the prompt stack, and frees the memory allocated for it. */
end_comment

begin_function
name|void
name|pop_prompt
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If we are not during a 'synchronous' execution command, in which      case, the top prompt would be empty. */
if|if
condition|(
name|strcmp
argument_list|(
name|PROMPT
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
condition|)
comment|/* This is for the case in which the prompt is set while the        annotation level is 2. The top prompt will be changed, but when        we return to annotation level< 2, we want that new prompt to be        in effect, until the user does another 'set prompt'. */
if|if
condition|(
name|strcmp
argument_list|(
name|PROMPT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PROMPT
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|PROMPT
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PROMPT
argument_list|(
operator|-
literal|1
argument_list|)
operator|=
name|savestring
argument_list|(
name|PROMPT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|PROMPT
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|PREFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|PROMPT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|SUFFIX
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|the_prompts
operator|.
name|top
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When there is an event ready on the stdin file desriptor, instead    of calling readline directly throught the callback function, or    instead of calling gdb_readline2, give gdb a chance to detect    errors and do something. */
end_comment

begin_function
name|void
name|stdin_event_handler
parameter_list|(
name|int
name|error
parameter_list|,
name|gdb_client_data
name|client_data
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"error detected on stdin\n"
argument_list|)
expr_stmt|;
name|delete_file_handler
argument_list|(
name|input_fd
argument_list|)
expr_stmt|;
name|discard_all_continuations
argument_list|()
expr_stmt|;
comment|/* If stdin died, we may as well kill gdb. */
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|stdin
operator|==
name|instream
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|call_readline
call|)
argument_list|(
name|client_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Re-enable stdin after the end of an execution command in    synchronous mode, or after an error from the target, and we aborted    the exec operation. */
end_comment

begin_function
name|void
name|async_enable_stdin
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* See NOTE in async_disable_stdin() */
comment|/* FIXME: cagney/1999-09-27: Call this before clearing      sync_execution.  Current target_terminal_ours() implementations      check for sync_execution before switching the terminal. */
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|pop_prompt
argument_list|()
expr_stmt|;
name|sync_execution
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disable reads from stdin (the console) marking the command as    synchronous. */
end_comment

begin_function
name|void
name|async_disable_stdin
parameter_list|(
name|void
parameter_list|)
block|{
name|sync_execution
operator|=
literal|1
expr_stmt|;
name|push_prompt
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/1999-09-27: At present this call is technically      redundant since infcmd.c and infrun.c both already call      target_terminal_inferior().  As the terminal handling (in      sync/async mode) is refined, the duplicate calls can be      eliminated (Here or in infcmd.c/infrun.c). */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Add the reinstate of stdin to the list of cleanups to be done      in case the target errors out and dies. These cleanups are also      done in case of normal successful termination of the execution      command, by complete_execution(). */
name|make_exec_error_cleanup
argument_list|(
name|async_enable_stdin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handles a gdb command. This function is called by    command_line_handler, which has processed one or more input lines    into COMMAND. */
end_comment

begin_comment
comment|/* NOTE: 1999-04-30 This is the asynchronous version of the command_loop    function.  The command_loop function will be obsolete when we    switch to use the event loop at every execution of gdb. */
end_comment

begin_function
specifier|static
name|void
name|command_handler
parameter_list|(
name|char
modifier|*
name|command
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|stdin_is_tty
init|=
name|ISATTY
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|struct
name|continuation_arg
modifier|*
name|arg1
decl_stmt|;
name|struct
name|continuation_arg
modifier|*
name|arg2
decl_stmt|;
name|long
name|time_at_cmd_start
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|long
name|space_at_cmd_start
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|display_time
decl_stmt|;
specifier|extern
name|int
name|display_space
decl_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|stdin_is_tty
condition|)
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If readline returned a NULL command, it means that the       connection with the terminal is gone. This happens at the      end of a testsuite run, after Expect has hung up       but GDB is still alive. In such a case, we just quit gdb      killing the inferior program too. */
if|if
condition|(
name|command
operator|==
literal|0
condition|)
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|stdin
operator|==
name|instream
argument_list|)
expr_stmt|;
name|time_at_cmd_start
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|space_at_cmd_start
operator|=
name|lim
operator|-
name|lim_at_start
expr_stmt|;
endif|#
directive|endif
block|}
name|execute_command
argument_list|(
name|command
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
comment|/* Set things up for this function to be compete later, once the      execution has completed, if we are doing an execution command,      otherwise, just go ahead and finish. */
if|if
condition|(
name|target_can_async_p
argument_list|()
operator|&&
name|target_executing
condition|)
block|{
name|arg1
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|->
name|next
operator|=
name|arg2
expr_stmt|;
name|arg2
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|arg1
operator|->
name|data
operator|.
name|longint
operator|=
name|time_at_cmd_start
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|arg2
operator|->
name|data
operator|.
name|longint
operator|=
name|space_at_cmd_start
expr_stmt|;
endif|#
directive|endif
name|add_continuation
argument_list|(
name|command_line_handler_continuation
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* Do any commands attached to breakpoint we stopped at. Only if we      are always running synchronously. Or if we have just executed a      command that doesn't start the target. */
if|if
condition|(
operator|!
name|target_can_async_p
argument_list|()
operator|||
operator|!
name|target_executing
condition|)
block|{
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_time
condition|)
block|{
name|long
name|cmd_time
init|=
name|get_run_time
argument_list|()
operator|-
name|time_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Command execution time: %ld.%06ld\n"
argument_list|,
name|cmd_time
operator|/
literal|1000000
argument_list|,
name|cmd_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|space_now
init|=
name|lim
operator|-
name|lim_at_start
decl_stmt|;
name|long
name|space_diff
init|=
name|space_now
operator|-
name|space_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Space used: %ld (%c%ld for this command)\n"
argument_list|,
name|space_now
argument_list|,
operator|(
name|space_diff
operator|>=
literal|0
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|space_diff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do any commands attached to breakpoint we stopped at. Only if we    are always running synchronously. Or if we have just executed a    command that doesn't start the target. */
end_comment

begin_function
name|void
name|command_line_handler_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
block|{
specifier|extern
name|int
name|display_time
decl_stmt|;
specifier|extern
name|int
name|display_space
decl_stmt|;
name|long
name|time_at_cmd_start
init|=
name|arg
operator|->
name|data
operator|.
name|longint
decl_stmt|;
name|long
name|space_at_cmd_start
init|=
name|arg
operator|->
name|next
operator|->
name|data
operator|.
name|longint
decl_stmt|;
name|bpstat_do_actions
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/*do_cleanups (old_chain); */
comment|/*?????FIXME????? */
if|if
condition|(
name|display_time
condition|)
block|{
name|long
name|cmd_time
init|=
name|get_run_time
argument_list|()
operator|-
name|time_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Command execution time: %ld.%06ld\n"
argument_list|,
name|cmd_time
operator|/
literal|1000000
argument_list|,
name|cmd_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|space_now
init|=
name|lim
operator|-
name|lim_at_start
decl_stmt|;
name|long
name|space_diff
init|=
name|space_now
operator|-
name|space_at_cmd_start
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Space used: %ld (%c%ld for this command)\n"
argument_list|,
name|space_now
argument_list|,
operator|(
name|space_diff
operator|>=
literal|0
condition|?
literal|'+'
else|:
literal|'-'
operator|)
argument_list|,
name|space_diff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Handle a complete line of input. This is called by the callback    mechanism within the readline library.  Deal with incomplete commands    as well, by saving the partial input in a global buffer.  */
end_comment

begin_comment
comment|/* NOTE: 1999-04-30 This is the asynchronous version of the    command_line_input function. command_line_input will become    obsolete once we use the event loop as the default mechanism in    GDB. */
end_comment

begin_function
specifier|static
name|void
name|command_line_handler
parameter_list|(
name|char
modifier|*
name|rl
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|linebuffer
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|linelength
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
specifier|extern
name|int
name|linesize
decl_stmt|;
name|char
modifier|*
name|nline
decl_stmt|;
name|char
name|got_eof
init|=
literal|0
decl_stmt|;
name|int
name|repeat
init|=
operator|(
name|instream
operator|==
name|stdin
operator|)
decl_stmt|;
if|if
condition|(
name|annotation_level
operator|>
literal|1
operator|&&
name|instream
operator|==
name|stdin
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\n\032\032post-"
argument_list|)
expr_stmt|;
name|puts_unfiltered
argument_list|(
name|async_annotation_suffix
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
block|{
name|linelength
operator|=
literal|80
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linelength
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|linebuffer
expr_stmt|;
if|if
condition|(
name|more_to_come
condition|)
block|{
name|strcpy
argument_list|(
name|linebuffer
argument_list|,
name|readline_input_state
operator|.
name|linebuffer
argument_list|)
expr_stmt|;
name|p
operator|=
name|readline_input_state
operator|.
name|linebuffer_ptr
expr_stmt|;
name|xfree
argument_list|(
name|readline_input_state
operator|.
name|linebuffer
argument_list|)
expr_stmt|;
name|more_to_come
operator|=
literal|0
expr_stmt|;
name|pop_prompt
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|handle_stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure that all output has been output.  Some machines may let      you get away with leaving out some of the gdb_flush, but not all.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_file_name
operator|!=
name|NULL
condition|)
block|{
operator|++
name|source_line_number
expr_stmt|;
name|sprintf
argument_list|(
name|source_error
argument_list|,
literal|"%s%s:%d: Error in sourced command file:\n"
argument_list|,
name|source_pre_error
argument_list|,
name|source_file_name
argument_list|,
name|source_line_number
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
name|source_error
expr_stmt|;
block|}
comment|/* If we are in this case, then command_handler will call quit       and exit from gdb. */
if|if
condition|(
operator|!
name|rl
operator|||
name|rl
operator|==
operator|(
name|char
operator|*
operator|)
name|EOF
condition|)
block|{
name|got_eof
operator|=
literal|1
expr_stmt|;
name|command_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|rl
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|p
operator|-
name|linebuffer
operator|)
expr_stmt|;
name|nline
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nline
operator|-
name|linebuffer
expr_stmt|;
name|linebuffer
operator|=
name|nline
expr_stmt|;
block|}
name|p1
operator|=
name|rl
expr_stmt|;
comment|/* Copy line.  Don't copy null at end.  (Leaves line alone      if this was just a newline)  */
while|while
condition|(
operator|*
name|p1
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
name|xfree
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* Allocated in readline.  */
if|if
condition|(
name|p
operator|>
name|linebuffer
operator|&&
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|'\\'
condition|)
block|{
name|p
operator|--
expr_stmt|;
comment|/* Put on top of '\'.  */
name|readline_input_state
operator|.
name|linebuffer
operator|=
name|savestring
argument_list|(
name|linebuffer
argument_list|,
name|strlen
argument_list|(
name|linebuffer
argument_list|)
argument_list|)
expr_stmt|;
name|readline_input_state
operator|.
name|linebuffer_ptr
operator|=
name|p
expr_stmt|;
comment|/* We will not invoke a execute_command if there is more 	 input expected to complete the command. So, we need to 	 print an empty prompt here. */
name|more_to_come
operator|=
literal|1
expr_stmt|;
name|push_prompt
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|SERVER_COMMAND_LENGTH
value|7
name|server_command
operator|=
operator|(
name|p
operator|-
name|linebuffer
operator|>
name|SERVER_COMMAND_LENGTH
operator|)
operator|&&
name|strncmp
argument_list|(
name|linebuffer
argument_list|,
literal|"server "
argument_list|,
name|SERVER_COMMAND_LENGTH
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|server_command
condition|)
block|{
comment|/* Note that we don't set `line'.  Between this and the check in          dont_repeat, this insures that repeating will still do the          right thing.  */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|command_handler
argument_list|(
name|linebuffer
operator|+
name|SERVER_COMMAND_LENGTH
argument_list|)
expr_stmt|;
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do history expansion if that is wished.  */
if|if
condition|(
name|history_expansion_p
operator|&&
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|char
modifier|*
name|history_value
decl_stmt|;
name|int
name|expanded
decl_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Insert null now.  */
name|expanded
operator|=
name|history_expand
argument_list|(
name|linebuffer
argument_list|,
operator|&
name|history_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
condition|)
block|{
comment|/* Print the changes.  */
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
comment|/* If there was an error, call this function again.  */
if|if
condition|(
name|expanded
operator|<
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|>
name|linelength
condition|)
block|{
name|linelength
operator|=
name|strlen
argument_list|(
name|history_value
argument_list|)
operator|+
literal|1
expr_stmt|;
name|linebuffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linebuffer
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|linebuffer
argument_list|,
name|history_value
argument_list|)
expr_stmt|;
name|p
operator|=
name|linebuffer
operator|+
name|strlen
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|history_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we just got an empty line, and that is supposed      to repeat the previous command, return the value in the      global buffer.  */
if|if
condition|(
name|repeat
operator|&&
name|p
operator|==
name|linebuffer
operator|&&
operator|*
name|p
operator|!=
literal|'\\'
condition|)
block|{
name|command_handler
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|p1
operator|=
name|linebuffer
init|;
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
condition|;
name|p1
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|repeat
operator|&&
operator|!
operator|*
name|p1
condition|)
block|{
name|command_handler
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Add line to history if appropriate.  */
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|&&
operator|*
name|linebuffer
condition|)
name|add_history
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
comment|/* Note: lines consisting solely of comments are added to the command      history.  This is useful when you type a command, and then      realize you don't want to execute it quite yet.  You can comment      out the command and then later fetch it from the value history      and remove the '#'.  The kill ring is probably better, but some      people are in the habit of commenting things out.  */
if|if
condition|(
operator|*
name|p1
operator|==
literal|'#'
condition|)
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
comment|/* Found a comment. */
comment|/* Save into global buffer if appropriate.  */
if|if
condition|(
name|repeat
condition|)
block|{
if|if
condition|(
name|linelength
operator|>
name|linesize
condition|)
block|{
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|linelength
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|linelength
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more_to_come
condition|)
block|{
name|command_handler
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|command_handler
argument_list|(
name|linebuffer
argument_list|)
expr_stmt|;
name|display_gdb_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Does reading of input from terminal w/o the editing features    provided by the readline library. */
end_comment

begin_comment
comment|/* NOTE: 1999-04-30 Asynchronous version of gdb_readline. gdb_readline    will become obsolete when the event loop is made the default    execution for gdb. */
end_comment

begin_function
name|void
name|gdb_readline2
parameter_list|(
name|gdb_client_data
name|client_data
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|input_index
init|=
literal|0
decl_stmt|;
name|int
name|result_size
init|=
literal|80
decl_stmt|;
specifier|static
name|int
name|done_once
init|=
literal|0
decl_stmt|;
comment|/* Unbuffer the input stream, so that, later on, the calls to fgetc      fetch only one char at the time from the stream. The fgetc's will      get up to the first newline, but there may be more chars in the      stream after '\n'. If we buffer the input and fgetc drains the      stream, getting stuff beyond the newline as well, a select, done      afterwards will not trigger. */
if|if
condition|(
operator|!
name|done_once
operator|&&
operator|!
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|setbuf
argument_list|(
name|instream
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|done_once
operator|=
literal|1
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
comment|/* We still need the while loop here, even though it would seem      obvious to invoke gdb_readline2 at every character entered.  If      not using the readline library, the terminal is in cooked mode,      which sends the characters all at once. Poll will notice that the      input fd has changed state only after enter is pressed. At this      point we still need to fetch all the chars entered. */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Read from stdin if we are executing a user defined command.          This is the right thing for prompt_for_continue, at least.  */
name|c
operator|=
name|fgetc
argument_list|(
name|instream
condition|?
name|instream
else|:
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|input_index
operator|>
literal|0
condition|)
comment|/* The last line does not end with a newline.  Return it, and 	       if we are called again fgetc will still return EOF and 	       we'll return NULL then.  */
break|break;
name|xfree
argument_list|(
name|result
argument_list|)
expr_stmt|;
call|(
modifier|*
name|input_handler
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
ifndef|#
directive|ifndef
name|CRLF_SOURCE_FILES
break|break;
else|#
directive|else
block|{
if|if
condition|(
name|input_index
operator|>
literal|0
operator|&&
name|result
index|[
name|input_index
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|input_index
operator|--
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
name|result
index|[
name|input_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
call|(
modifier|*
name|input_handler
call|)
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialization of signal handlers and tokens.  There is a function    handle_sig* for each of the signals GDB cares about. Specifically:    SIGINT, SIGFPE, SIGQUIT, SIGTSTP, SIGHUP, SIGWINCH.  These    functions are the actual signal handlers associated to the signals    via calls to signal().  The only job for these functions is to    enqueue the appropriate event/procedure with the event loop.  Such    procedures are the old signal handlers. The event loop will take    care of invoking the queued procedures to perform the usual tasks    associated with the reception of the signal. */
end_comment

begin_comment
comment|/* NOTE: 1999-04-30 This is the asynchronous version of init_signals.    init_signals will become obsolete as we move to have to event loop    as the default for gdb. */
end_comment

begin_function
name|void
name|async_init_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handle_sigint
argument_list|)
expr_stmt|;
name|sigint_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_request_quit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If SIGTRAP was set to SIG_IGN, then the SIG_IGN will get passed      to the inferior and breakpoints will be ignored.  */
ifdef|#
directive|ifdef
name|SIGTRAP
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get      passed to the inferior, which we don't want.  It would be      possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but      on BSD4.3 systems using vfork, that can affect the      GDB process as well as the inferior (the signal handling tables      might be in memory, shared between the two).  Since we establish      a handler for SIGQUIT, when we call exec it will set the signal      to SIG_DFL for us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|handle_sigquit
argument_list|)
expr_stmt|;
name|sigquit_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_do_nothing
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|handle_sighup
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|sighup_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_disconnect
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sighup_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_do_nothing
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|handle_sigfpe
argument_list|)
expr_stmt|;
name|sigfpe_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_float_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|handle_sigwinch
argument_list|)
expr_stmt|;
name|sigwinch_token
operator|=
name|create_async_signal_handler
argument_list|(
name|SIGWINCH_HANDLER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STOP_SIGNAL
name|sigtstp_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_stop_sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mark_async_signal_handler_wrapper
parameter_list|(
name|void
modifier|*
name|token
parameter_list|)
block|{
name|mark_async_signal_handler
argument_list|(
operator|(
expr|struct
name|async_signal_handler
operator|*
operator|)
name|token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the event loop what to do if SIGINT is received.     See event-signal.c. */
end_comment

begin_function
name|void
name|handle_sigint
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_sigint
argument_list|)
expr_stmt|;
comment|/* If immediate_quit is set, we go ahead and process the SIGINT right      away, even if we usually would defer this to the event loop. The      assumption here is that it is safe to process ^C immediately if      immediate_quit is set. If we didn't, SIGINT would be really      processed only the next time through the event loop.  To get to      that point, though, the command that we want to interrupt needs to      finish first, which is unacceptable. */
if|if
condition|(
name|immediate_quit
condition|)
name|async_request_quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* If immediate quit is not set, we process SIGINT the next time        through the loop, which is fine. */
name|mark_async_signal_handler_wrapper
argument_list|(
name|sigint_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the quit. All the checks have been done by the caller. */
end_comment

begin_function
name|void
name|async_request_quit
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
block|{
name|quit_flag
operator|=
literal|1
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the event loop what to do if SIGQUIT is received.     See event-signal.c. */
end_comment

begin_function
specifier|static
name|void
name|handle_sigquit
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|mark_async_signal_handler_wrapper
argument_list|(
name|sigquit_token
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_sigquit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by the event loop in response to a SIGQUIT. */
end_comment

begin_function
specifier|static
name|void
name|async_do_nothing
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
block|{
comment|/* Empty function body. */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGHUP
end_ifdef

begin_comment
comment|/* Tell the event loop what to do if SIGHUP is received.     See event-signal.c. */
end_comment

begin_function
specifier|static
name|void
name|handle_sighup
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|mark_async_signal_handler_wrapper
argument_list|(
name|sighup_token
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_sighup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by the event loop to process a SIGHUP */
end_comment

begin_function
specifier|static
name|void
name|async_disconnect
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
block|{
name|catch_errors
argument_list|(
name|quit_cover
argument_list|,
name|NULL
argument_list|,
literal|"Could not kill the program being debugged"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/*FIXME: ??????????? */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STOP_SIGNAL
end_ifdef

begin_function
name|void
name|handle_stop_sig
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|mark_async_signal_handler_wrapper
argument_list|(
name|sigtstp_token
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_stop_sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|async_stop_sig
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|prompt
init|=
name|get_prompt
argument_list|()
decl_stmt|;
if|#
directive|if
name|STOP_SIGNAL
operator|==
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SIGPROCMASK
block|{
name|sigset_t
name|zero
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|zero
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|zero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|HAVE_SIGSETMASK
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|handle_stop_sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|handle_stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_unfiltered
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Forget about any previous command -- null line now will do nothing.  */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STOP_SIGNAL */
end_comment

begin_comment
comment|/* Tell the event loop what to do if SIGFPE is received.     See event-signal.c. */
end_comment

begin_function
specifier|static
name|void
name|handle_sigfpe
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|mark_async_signal_handler_wrapper
argument_list|(
name|sigfpe_token
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_sigfpe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Event loop will call this functin to process a SIGFPE. */
end_comment

begin_function
specifier|static
name|void
name|async_float_handler
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
block|{
comment|/* This message is based on ANSI C, section 4.7. Note that integer      divide by zero causes this, so "float" is a misnomer. */
name|error
argument_list|(
literal|"Erroneous arithmetic operation."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the event loop what to do if SIGWINCH is received.     See event-signal.c. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH_HANDLER
argument_list|)
end_if

begin_function
specifier|static
name|void
name|handle_sigwinch
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|mark_async_signal_handler_wrapper
argument_list|(
name|sigwinch_token
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_sigwinch
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Called by do_setshow_command.  */
end_comment

begin_function
name|void
name|set_async_editing_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|change_line_handler
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by do_setshow_command.  */
end_comment

begin_function
name|void
name|set_async_annotation_level
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|change_annotation_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by do_setshow_command.  */
end_comment

begin_function
name|void
name|set_async_prompt
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|PROMPT
argument_list|(
literal|0
argument_list|)
operator|=
name|savestring
argument_list|(
name|new_async_prompt
argument_list|,
name|strlen
argument_list|(
name|new_async_prompt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set things up for readline to be invoked via the alternate    interface, i.e. via a callback function (rl_callback_read_char),    and hook up instream to the event loop. */
end_comment

begin_function
name|void
name|gdb_setup_readline
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This function is a noop for the sync case.  The assumption is that      the sync setup is ALL done in gdb_init, and we would only mess it up      here.  The sync stuff should really go away over time. */
if|if
condition|(
name|event_loop_p
condition|)
block|{
name|gdb_stdout
operator|=
name|stdio_fileopen
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gdb_stderr
operator|=
name|stdio_fileopen
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|gdb_stdlog
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* for moment */
name|gdb_stdtarg
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* for moment */
comment|/* If the input stream is connected to a terminal, turn on          editing.  */
if|if
condition|(
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
comment|/* Tell gdb that we will be using the readline library. This 	     could be overwritten by a command in .gdbinit like 'set 	     editing on' or 'off'. */
name|async_command_editing_p
operator|=
literal|1
expr_stmt|;
comment|/* When a character is detected on instream by select or 	     poll, readline will be invoked via this callback 	     function. */
name|call_readline
operator|=
name|rl_callback_read_char_wrapper
expr_stmt|;
block|}
else|else
block|{
name|async_command_editing_p
operator|=
literal|0
expr_stmt|;
name|call_readline
operator|=
name|gdb_readline2
expr_stmt|;
block|}
comment|/* When readline has read an end-of-line character, it passes          the complete line to gdb for processing. command_line_handler          is the function that does this. */
name|input_handler
operator|=
name|command_line_handler
expr_stmt|;
comment|/* Tell readline to use the same input stream that gdb uses. */
name|rl_instream
operator|=
name|instream
expr_stmt|;
comment|/* Get a file descriptor for the input stream, so that we can          register it with the event loop. */
name|input_fd
operator|=
name|fileno
argument_list|(
name|instream
argument_list|)
expr_stmt|;
comment|/* Now we need to create the event sources for the input file          descriptor. */
comment|/* At this point in time, this is the only event source that we          register with the even loop. Another source is going to be          the target program (inferior), but that must be registered          only when it actually exists (I.e. after we say 'run' or          after we connect to a remote target. */
name|add_file_handler
argument_list|(
name|input_fd
argument_list|,
name|stdin_event_handler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable command input through the standard CLI channels.  Used in    the suspend proc for interpreters that use the standard gdb readline    interface, like the cli& the mi.  */
end_comment

begin_function
name|void
name|gdb_disable_readline
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|event_loop_p
condition|)
block|{
comment|/* FIXME - It is too heavyweight to delete and remake these          every time you run an interpreter that needs readline.          It is probably better to have the interpreters cache these,          which in turn means that this needs to be moved into interpreter          specific code. */
if|#
directive|if
literal|0
block|ui_file_delete (gdb_stdout);       ui_file_delete (gdb_stderr);       gdb_stdlog = NULL;       gdb_stdtarg = NULL;
endif|#
directive|endif
name|rl_callback_handler_remove
argument_list|()
expr_stmt|;
name|delete_file_handler
argument_list|(
name|input_fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

