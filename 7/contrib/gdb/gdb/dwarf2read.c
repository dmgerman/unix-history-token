begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF 2 debugging format support for GDB.    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004    Free Software Foundation, Inc.     Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,    Inc.  with support from Florida State University (under contract    with the Ada Joint Program Office), and Silicon Graphics, Inc.    Initial contribution by Brent Benson, Harris Computer Systems, Inc.,    based on Fred Fish's (Cygnus Support) implementation of DWARF 1    support in dwarfread.c     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or (at    your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for DOSish file names */
end_comment

begin_include
include|#
directive|include
file|"macrotab.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"bcache.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2expr.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2loc.h"
end_include

begin_include
include|#
directive|include
file|"cp-support.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_REG_TO_REGNUM
parameter_list|(
name|REG
parameter_list|)
value|(REG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* .debug_info header for a compilation unit    Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_comment
unit|typedef struct comp_unit_header   {     unsigned int length;
comment|/* length of the .debug_info 				   contribution */
end_comment

begin_comment
unit|unsigned short version;
comment|/* version number -- 2 for DWARF 				   version 2 */
end_comment

begin_comment
unit|unsigned int abbrev_offset;
comment|/* offset into .debug_abbrev section */
end_comment

begin_comment
unit|unsigned char addr_size;
comment|/* byte size of an address -- 4 */
end_comment

begin_define
unit|} _COMP_UNIT_HEADER;
define|#
directive|define
name|_ACTUAL_COMP_UNIT_HEADER_SIZE
value|11
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .debug_pubnames header    Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pubnames_header
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* length of the .debug_pubnames 				   contribution  */
name|unsigned
name|char
name|version
decl_stmt|;
comment|/* version number -- 2 for DWARF 				   version 2 */
name|unsigned
name|int
name|info_offset
decl_stmt|;
comment|/* offset into .debug_info section */
name|unsigned
name|int
name|info_size
decl_stmt|;
comment|/* byte size of .debug_info section 				   portion */
block|}
name|_PUBNAMES_HEADER
typedef|;
end_typedef

begin_define
define|#
directive|define
name|_ACTUAL_PUBNAMES_HEADER_SIZE
value|13
end_define

begin_comment
comment|/* .debug_pubnames header    Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|aranges_header
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* byte len of the .debug_aranges 				   contribution */
name|unsigned
name|short
name|version
decl_stmt|;
comment|/* version number -- 2 for DWARF 				   version 2 */
name|unsigned
name|int
name|info_offset
decl_stmt|;
comment|/* offset into .debug_info section */
name|unsigned
name|char
name|addr_size
decl_stmt|;
comment|/* byte size of an address */
name|unsigned
name|char
name|seg_size
decl_stmt|;
comment|/* byte size of segment descriptor */
block|}
name|_ARANGES_HEADER
typedef|;
end_typedef

begin_define
define|#
directive|define
name|_ACTUAL_ARANGES_HEADER_SIZE
value|12
end_define

begin_comment
comment|/* .debug_line statement program prologue    Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|statement_prologue
block|{
name|unsigned
name|int
name|total_length
decl_stmt|;
comment|/* byte length of the statement 				   information */
name|unsigned
name|short
name|version
decl_stmt|;
comment|/* version number -- 2 for DWARF 				   version 2 */
name|unsigned
name|int
name|prologue_length
decl_stmt|;
comment|/* # bytes between prologue& 					   stmt program */
name|unsigned
name|char
name|minimum_instruction_length
decl_stmt|;
comment|/* byte size of 						   smallest instr */
name|unsigned
name|char
name|default_is_stmt
decl_stmt|;
comment|/* initial value of is_stmt 					   register */
name|char
name|line_base
decl_stmt|;
name|unsigned
name|char
name|line_range
decl_stmt|;
name|unsigned
name|char
name|opcode_base
decl_stmt|;
comment|/* number assigned to first special 				   opcode */
name|unsigned
name|char
modifier|*
name|standard_opcode_lengths
decl_stmt|;
block|}
name|_STATEMENT_PROLOGUE
typedef|;
end_typedef

begin_comment
comment|/* offsets and sizes of debugging sections */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_info_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_abbrev_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_line_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_pubnames_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_aranges_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_loc_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_macinfo_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_str_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_ranges_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|dwarf_frame_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|dwarf_eh_frame_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_info_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_abbrev_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_line_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_pubnames_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_aranges_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_loc_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_macinfo_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_str_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|dwarf_ranges_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|dwarf_frame_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|dwarf_eh_frame_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of the debugging sections */
end_comment

begin_define
define|#
directive|define
name|INFO_SECTION
value|".debug_info"
end_define

begin_define
define|#
directive|define
name|ABBREV_SECTION
value|".debug_abbrev"
end_define

begin_define
define|#
directive|define
name|LINE_SECTION
value|".debug_line"
end_define

begin_define
define|#
directive|define
name|PUBNAMES_SECTION
value|".debug_pubnames"
end_define

begin_define
define|#
directive|define
name|ARANGES_SECTION
value|".debug_aranges"
end_define

begin_define
define|#
directive|define
name|LOC_SECTION
value|".debug_loc"
end_define

begin_define
define|#
directive|define
name|MACINFO_SECTION
value|".debug_macinfo"
end_define

begin_define
define|#
directive|define
name|STR_SECTION
value|".debug_str"
end_define

begin_define
define|#
directive|define
name|RANGES_SECTION
value|".debug_ranges"
end_define

begin_define
define|#
directive|define
name|FRAME_SECTION
value|".debug_frame"
end_define

begin_define
define|#
directive|define
name|EH_FRAME_SECTION
value|".eh_frame"
end_define

begin_comment
comment|/* local data types */
end_comment

begin_comment
comment|/* We hold several abbreviation tables in memory at the same time. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ABBREV_HASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|ABBREV_HASH_SIZE
value|121
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The data in a compilation unit header, after target2host    translation, looks like this.  */
end_comment

begin_struct
struct|struct
name|comp_unit_head
block|{
name|unsigned
name|long
name|length
decl_stmt|;
name|short
name|version
decl_stmt|;
name|unsigned
name|int
name|abbrev_offset
decl_stmt|;
name|unsigned
name|char
name|addr_size
decl_stmt|;
name|unsigned
name|char
name|signed_addr_p
decl_stmt|;
name|unsigned
name|int
name|offset_size
decl_stmt|;
comment|/* size of file offsets; either 4 or 8 */
name|unsigned
name|int
name|initial_length_size
decl_stmt|;
comment|/* size of the length field; either                                          4 or 12 */
comment|/* Offset to the first byte of this compilation unit header in the       * .debug_info section, for resolving relative reference dies. */
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Pointer to this compilation unit header in the .debug_info      * section */
name|char
modifier|*
name|cu_head_ptr
decl_stmt|;
comment|/* Pointer to the first die of this compilatio unit.  This will      * be the first byte following the compilation unit header. */
name|char
modifier|*
name|first_die_ptr
decl_stmt|;
comment|/* Pointer to the next compilation unit header in the program. */
name|struct
name|comp_unit_head
modifier|*
name|next
decl_stmt|;
comment|/* DWARF abbreviation table associated with this compilation unit */
name|struct
name|abbrev_info
modifier|*
name|dwarf2_abbrevs
index|[
name|ABBREV_HASH_SIZE
index|]
decl_stmt|;
comment|/* Base address of this compilation unit.  */
name|CORE_ADDR
name|base_address
decl_stmt|;
comment|/* Non-zero if base_address has been set.  */
name|int
name|base_known
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Internal state when decoding a particular compilation unit.  */
end_comment

begin_struct
struct|struct
name|dwarf2_cu
block|{
comment|/* The objfile containing this compilation unit.  */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* The header of the compilation unit.       FIXME drow/2003-11-10: Some of the things from the comp_unit_head      should be moved to the dwarf2_cu structure; for instance the abbrevs      hash table.  */
name|struct
name|comp_unit_head
name|header
decl_stmt|;
name|struct
name|function_range
modifier|*
name|first_fn
decl_stmt|,
modifier|*
name|last_fn
decl_stmt|,
modifier|*
name|cached_fn
decl_stmt|;
comment|/* The language we are debugging.  */
name|enum
name|language
name|language
decl_stmt|;
specifier|const
name|struct
name|language_defn
modifier|*
name|language_defn
decl_stmt|;
comment|/* The generic symbol table building routines have separate lists for      file scope symbols and all all other scopes (local scopes).  So      we need to select the right one to pass to add_symbol_to_list().      We do it by keeping a pointer to the correct list in list_in_scope.       FIXME: The original dwarf code just treated the file scope as the      first local scope, and all other local scopes as nested local      scopes, and worked fine.  Check to see if we really need to      distinguish these in buildsym.c.  */
name|struct
name|pending
modifier|*
modifier|*
name|list_in_scope
decl_stmt|;
comment|/* Maintain an array of referenced fundamental types for the current      compilation unit being read.  For DWARF version 1, we have to construct      the fundamental types on the fly, since no information about the      fundamental types is supplied.  Each such fundamental type is created by      calling a language dependent routine to create the type, and then a      pointer to that type is then placed in the array at the index specified      by it's FT_<TYPENAME> value.  The array has a fixed size set by the      FT_NUM_MEMBERS compile time constant, which is the number of predefined      fundamental types gdb knows how to construct.  */
name|struct
name|type
modifier|*
name|ftypes
index|[
name|FT_NUM_MEMBERS
index|]
decl_stmt|;
comment|/* Fundamental types */
block|}
struct|;
end_struct

begin_comment
comment|/* The line number information for a compilation unit (found in the    .debug_line section) begins with a "statement program header",    which contains the following information.  */
end_comment

begin_struct
struct|struct
name|line_header
block|{
name|unsigned
name|int
name|total_length
decl_stmt|;
name|unsigned
name|short
name|version
decl_stmt|;
name|unsigned
name|int
name|header_length
decl_stmt|;
name|unsigned
name|char
name|minimum_instruction_length
decl_stmt|;
name|unsigned
name|char
name|default_is_stmt
decl_stmt|;
name|int
name|line_base
decl_stmt|;
name|unsigned
name|char
name|line_range
decl_stmt|;
name|unsigned
name|char
name|opcode_base
decl_stmt|;
comment|/* standard_opcode_lengths[i] is the number of operands for the      standard opcode whose value is i.  This means that      standard_opcode_lengths[0] is unused, and the last meaningful      element is standard_opcode_lengths[opcode_base - 1].  */
name|unsigned
name|char
modifier|*
name|standard_opcode_lengths
decl_stmt|;
comment|/* The include_directories table.  NOTE!  These strings are not      allocated with xmalloc; instead, they are pointers into      debug_line_buffer.  If you try to free them, `free' will get      indigestion.  */
name|unsigned
name|int
name|num_include_dirs
decl_stmt|,
name|include_dirs_size
decl_stmt|;
name|char
modifier|*
modifier|*
name|include_dirs
decl_stmt|;
comment|/* The file_names table.  NOTE!  These strings are not allocated      with xmalloc; instead, they are pointers into debug_line_buffer.      Don't try to free them directly.  */
name|unsigned
name|int
name|num_file_names
decl_stmt|,
name|file_names_size
decl_stmt|;
struct|struct
name|file_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|dir_index
decl_stmt|;
name|unsigned
name|int
name|mod_time
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
block|}
modifier|*
name|file_names
struct|;
comment|/* The start and end of the statement program following this      header.  These point into dwarf_line_buffer.  */
name|char
modifier|*
name|statement_program_start
decl_stmt|,
modifier|*
name|statement_program_end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* When we construct a partial symbol table entry we only    need this much information. */
end_comment

begin_struct
struct|struct
name|partial_die_info
block|{
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
name|unsigned
name|char
name|has_children
decl_stmt|;
name|unsigned
name|char
name|is_external
decl_stmt|;
name|unsigned
name|char
name|is_declaration
decl_stmt|;
name|unsigned
name|char
name|has_type
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|abbrev
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|has_pc_info
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|;
name|CORE_ADDR
name|highpc
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|locdesc
decl_stmt|;
name|unsigned
name|int
name|language
decl_stmt|;
name|char
modifier|*
name|sibling
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This data structure holds the information of an abbrev. */
end_comment

begin_struct
struct|struct
name|abbrev_info
block|{
name|unsigned
name|int
name|number
decl_stmt|;
comment|/* number identifying abbrev */
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
comment|/* dwarf tag */
name|int
name|has_children
decl_stmt|;
comment|/* boolean */
name|unsigned
name|int
name|num_attrs
decl_stmt|;
comment|/* number of attributes */
name|struct
name|attr_abbrev
modifier|*
name|attrs
decl_stmt|;
comment|/* an array of attribute descriptions */
name|struct
name|abbrev_info
modifier|*
name|next
decl_stmt|;
comment|/* next in chain */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|attr_abbrev
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This data structure holds a complete die structure. */
end_comment

begin_struct
struct|struct
name|die_info
block|{
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
comment|/* Tag indicating type of die */
name|unsigned
name|int
name|abbrev
decl_stmt|;
comment|/* Abbrev number */
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset in .debug_info section */
name|unsigned
name|int
name|num_attrs
decl_stmt|;
comment|/* Number of attributes */
name|struct
name|attribute
modifier|*
name|attrs
decl_stmt|;
comment|/* An array of attributes */
name|struct
name|die_info
modifier|*
name|next_ref
decl_stmt|;
comment|/* Next die in ref hash table */
comment|/* The dies in a compilation unit form an n-ary tree.  PARENT        points to this die's parent; CHILD points to the first child of        this node; and all the children of a given node are chained        together via their SIBLING fields, terminated by a die whose        tag is zero.  */
name|struct
name|die_info
modifier|*
name|child
decl_stmt|;
comment|/* Its first child, if any.  */
name|struct
name|die_info
modifier|*
name|sibling
decl_stmt|;
comment|/* Its next sibling, if any.  */
name|struct
name|die_info
modifier|*
name|parent
decl_stmt|;
comment|/* Its parent, if any.  */
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Cached type information */
block|}
struct|;
end_struct

begin_comment
comment|/* Attributes have a name and a value */
end_comment

begin_struct
struct|struct
name|attribute
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|unsigned
name|long
name|unsnd
decl_stmt|;
name|long
name|int
name|snd
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|function_range
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
name|int
name|seen_line
decl_stmt|;
name|struct
name|function_range
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get at parts of an attribute structure */
end_comment

begin_define
define|#
directive|define
name|DW_STRING
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.str)
end_define

begin_define
define|#
directive|define
name|DW_UNSND
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.unsnd)
end_define

begin_define
define|#
directive|define
name|DW_BLOCK
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.blk)
end_define

begin_define
define|#
directive|define
name|DW_SND
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.snd)
end_define

begin_define
define|#
directive|define
name|DW_ADDR
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.addr)
end_define

begin_comment
comment|/* Blocks are a bunch of untyped bytes. */
end_comment

begin_struct
struct|struct
name|dwarf_block
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_ALLOC_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|ATTR_ALLOC_CHUNK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A hash table of die offsets for following references.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REF_HASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|REF_HASH_SIZE
value|1021
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|die_info
modifier|*
name|die_ref_table
index|[
name|REF_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack for allocating temporary storage used during symbol reading.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dwarf2_tmp_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate fields for structs, unions and enums in this size.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DW_FIELD_ALLOC_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|DW_FIELD_ALLOC_CHUNK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Actually data from the sections.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_info_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_abbrev_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_line_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_str_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_macinfo_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_ranges_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_loc_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A zeroed version of a partial die for initialization purposes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|partial_die_info
name|zeroed_partial_die
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: decode_locdesc sets these variables to describe the location    to the caller.  These ought to be a structure or something.   If    none of the flags are set, the object lives at the address returned    by decode_locdesc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|isreg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Object lives in register. 				   decode_locdesc's return value is 				   the register number.  */
end_comment

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.    The complete dwarf information for an objfile is kept in the    objfile_obstack, so that absolute die references can be handled.    Most of the information in this structure is related to an entire    object file and could be passed via the sym_private field of the objfile.    It is however conceivable that dwarf2 might not be the only type    of symbols read from an object file.  */
end_comment

begin_struct
struct|struct
name|dwarf2_pinfo
block|{
comment|/* Pointer to start of dwarf info buffer for the objfile.  */
name|char
modifier|*
name|dwarf_info_buffer
decl_stmt|;
comment|/* Offset in dwarf_info_buffer for this compilation unit. */
name|unsigned
name|long
name|dwarf_info_offset
decl_stmt|;
comment|/* Pointer to start of dwarf abbreviation buffer for the objfile.  */
name|char
modifier|*
name|dwarf_abbrev_buffer
decl_stmt|;
comment|/* Size of dwarf abbreviation section for the objfile.  */
name|unsigned
name|int
name|dwarf_abbrev_size
decl_stmt|;
comment|/* Pointer to start of dwarf line buffer for the objfile.  */
name|char
modifier|*
name|dwarf_line_buffer
decl_stmt|;
comment|/* Size of dwarf_line_buffer, in bytes.  */
name|unsigned
name|int
name|dwarf_line_size
decl_stmt|;
comment|/* Pointer to start of dwarf string buffer for the objfile.  */
name|char
modifier|*
name|dwarf_str_buffer
decl_stmt|;
comment|/* Size of dwarf string section for the objfile.  */
name|unsigned
name|int
name|dwarf_str_size
decl_stmt|;
comment|/* Pointer to start of dwarf macro buffer for the objfile.  */
name|char
modifier|*
name|dwarf_macinfo_buffer
decl_stmt|;
comment|/* Size of dwarf macinfo section for the objfile.  */
name|unsigned
name|int
name|dwarf_macinfo_size
decl_stmt|;
comment|/* Pointer to start of dwarf ranges buffer for the objfile.  */
name|char
modifier|*
name|dwarf_ranges_buffer
decl_stmt|;
comment|/* Size of dwarf ranges buffer for the objfile.  */
name|unsigned
name|int
name|dwarf_ranges_size
decl_stmt|;
comment|/* Pointer to start of dwarf locations buffer for the objfile.  */
name|char
modifier|*
name|dwarf_loc_buffer
decl_stmt|;
comment|/* Size of dwarf locations buffer for the objfile.  */
name|unsigned
name|int
name|dwarf_loc_size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PST_PRIVATE
parameter_list|(
name|p
parameter_list|)
value|((struct dwarf2_pinfo *)(p)->read_symtab_private)
end_define

begin_define
define|#
directive|define
name|DWARF_INFO_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_info_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_INFO_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_info_offset)
end_define

begin_define
define|#
directive|define
name|DWARF_ABBREV_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_abbrev_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_ABBREV_SIZE
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_abbrev_size)
end_define

begin_define
define|#
directive|define
name|DWARF_LINE_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_line_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_LINE_SIZE
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_line_size)
end_define

begin_define
define|#
directive|define
name|DWARF_STR_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_str_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_STR_SIZE
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_str_size)
end_define

begin_define
define|#
directive|define
name|DWARF_MACINFO_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_macinfo_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_MACINFO_SIZE
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_macinfo_size)
end_define

begin_define
define|#
directive|define
name|DWARF_RANGES_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_ranges_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_RANGES_SIZE
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_ranges_size)
end_define

begin_define
define|#
directive|define
name|DWARF_LOC_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_loc_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_LOC_SIZE
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_loc_size)
end_define

begin_comment
comment|/* FIXME: We might want to set this from BFD via bfd_arch_bits_per_byte,    but this would require a corresponding change in unpack_field_as_long    and friends.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bits_per_byte
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The routines that read and process dies for a C struct or C++ class    pass lists of data member fields and lists of member function fields    in an instance of a field_info structure, as defined below.  */
end_comment

begin_struct
struct|struct
name|field_info
block|{
comment|/* List of data member and baseclasses fields. */
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|int
name|accessibility
decl_stmt|;
name|int
name|virtuality
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
modifier|*
name|fields
struct|;
comment|/* Number of fields.  */
name|int
name|nfields
decl_stmt|;
comment|/* Number of baseclasses.  */
name|int
name|nbaseclasses
decl_stmt|;
comment|/* Set if the accesibility of one of the fields is not public.  */
name|int
name|non_public_fields
decl_stmt|;
comment|/* Member function fields array, entries are allocated in the order they        are encountered in the object file.  */
struct|struct
name|nextfnfield
block|{
name|struct
name|nextfnfield
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_field
name|fnfield
decl_stmt|;
block|}
modifier|*
name|fnfields
struct|;
comment|/* Member function fieldlist array, contains name of possibly overloaded        member function, number of overloaded member functions and a pointer        to the head of the member function field chain.  */
struct|struct
name|fnfieldlist
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|struct
name|nextfnfield
modifier|*
name|head
decl_stmt|;
block|}
modifier|*
name|fnfieldlists
struct|;
comment|/* Number of entries in the fnfieldlists array.  */
name|int
name|nfnfields
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Various complaints about symbol reading that don't abort the process */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_statement_list_fits_in_line_number_section_complaint
parameter_list|(
name|void
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"statement list doesn't fit in .debug_line section"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_complex_location_expr_complaint
parameter_list|(
name|void
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"location expression too complex"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_const_value_length_mismatch_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|,
name|int
name|arg3
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"const value length mismatch for '%s', got %d, expected %d"
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_macros_too_long_complaint
parameter_list|(
name|void
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"macro info runs off end of `.debug_macinfo' section"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_macro_malformed_definition_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"macro debug info contains a malformed macro definition:\n`%s'"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_invalid_attrib_class_complaint
parameter_list|(
specifier|const
name|char
modifier|*
name|arg1
parameter_list|,
specifier|const
name|char
modifier|*
name|arg2
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"invalid attribute class or form for '%s' in '%s'"
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* local function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|dwarf2_locate_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dwarf2_build_psymtabs_easy (struct objfile *, int);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|dwarf2_build_psymtabs_hard
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|scan_partial_symbols
parameter_list|(
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_partial_symbol
parameter_list|(
name|struct
name|partial_die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pdi_needs_namespace
parameter_list|(
name|enum
name|dwarf_tag
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|add_partial_namespace
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|CORE_ADDR
modifier|*
name|lowpc
parameter_list|,
name|CORE_ADDR
modifier|*
name|highpc
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|add_partial_structure
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|struct_pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|add_partial_enumeration
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|enum_pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|locate_pdi_sibling
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|orig_pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_psymtab_to_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psymtab_to_symtab_1
parameter_list|(
name|struct
name|partial_symtab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|dwarf2_read_section
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_read_abbrevs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_empty_abbrev_table
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf2_lookup_abbrev
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_partial_die
parameter_list|(
name|struct
name|partial_die_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_full_die
parameter_list|(
name|struct
name|die_info
modifier|*
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_attribute
parameter_list|(
name|struct
name|attribute
modifier|*
parameter_list|,
name|struct
name|attr_abbrev
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_attribute_value
parameter_list|(
name|struct
name|attribute
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|read_1_byte
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_1_signed_byte
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|read_2_bytes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|read_4_bytes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|read_8_bytes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|read_address
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONGEST
name|read_initial_length
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|comp_unit_head
modifier|*
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONGEST
name|read_offset
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|comp_unit_head
modifier|*
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_n_bytes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_indirect_string
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|comp_unit_head
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|read_unsigned_leb128
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|read_signed_leb128
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_cu_language
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|attribute
modifier|*
name|dwarf2_attr
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|die_is_declaration
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|die_specification
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_line_header
parameter_list|(
name|struct
name|line_header
modifier|*
name|lh
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|line_header
modifier|*
argument_list|(
name|dwarf_decode_line_header
argument_list|(
argument|unsigned int offset
argument_list|,
argument|bfd *abfd
argument_list|,
argument|struct dwarf2_cu *cu
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dwarf_decode_lines
parameter_list|(
name|struct
name|line_header
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_start_subfile
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_const_value
parameter_list|(
name|struct
name|attribute
modifier|*
parameter_list|,
name|struct
name|symbol
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_const_value_data
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|die_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|die_containing_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type *type_at_offset (unsigned int, struct objfile *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|tag_type_to_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_type_die
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|determine_prefix
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|typename_concat
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_typedef
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_base_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_subrange_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_file_scope
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_func_scope
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_lexical_block_scope
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dwarf2_get_pc_bounds
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_scope_pc_bounds
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_add_field
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_attach_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_add_member_fn
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_attach_fn_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_structure_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_structure_scope
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|determine_class_name
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_common_block
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_namespace
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|namespace_name
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|int
modifier|*
name|is_anonymous
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_enumeration_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_enumeration_scope
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|dwarf_base_type
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|decode_locdesc
parameter_list|(
name|struct
name|dwarf_block
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_array_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_tag_pointer_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_tag_ptr_to_member_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_tag_reference_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_tag_const_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_tag_volatile_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_tag_string_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_subroutine_type
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|read_comp_unit
parameter_list|(
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|read_die_and_children
parameter_list|(
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
name|new_info_ptr
parameter_list|,
name|struct
name|die_info
modifier|*
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|read_die_and_siblings
parameter_list|(
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
name|new_info_ptr
parameter_list|,
name|struct
name|die_info
modifier|*
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_die_list
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_die_list
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_die
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf2_linkage_name
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf2_name
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|dwarf2_extension
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf_form_name
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf_bool_name
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dwarf_type_encoding_name
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char *dwarf_cfi_name (unsigned int);  struct die_info *copy_die (struct die_info *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|sibling_die
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_die
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_die_list
parameter_list|(
name|struct
name|die_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_in_ref_table
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|struct
name|die_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_empty_hash_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|dwarf2_get_ref_die_offset
parameter_list|(
name|struct
name|attribute
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dwarf2_get_attr_constant_value
parameter_list|(
name|struct
name|attribute
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|follow_die_ref
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|dwarf2_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* memory allocation interface */
end_comment

begin_function_decl
specifier|static
name|void
name|dwarf2_free_tmp_obstack
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dwarf_block
modifier|*
name|dwarf_alloc_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf_alloc_abbrev
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|die_info
modifier|*
name|dwarf_alloc_die
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_cu_func_list
parameter_list|(
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_cu_func_list
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf_decode_macros
parameter_list|(
name|struct
name|line_header
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attr_form_is_block
parameter_list|(
name|struct
name|attribute
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2_symbol_mark_computed
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Try to locate the sections we need for DWARF 2 debugging    information and return true if we have enough to do something.  */
end_comment

begin_function
name|int
name|dwarf2_has_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|dwarf_info_section
operator|=
literal|0
expr_stmt|;
name|dwarf_abbrev_section
operator|=
literal|0
expr_stmt|;
name|dwarf_line_section
operator|=
literal|0
expr_stmt|;
name|dwarf_str_section
operator|=
literal|0
expr_stmt|;
name|dwarf_macinfo_section
operator|=
literal|0
expr_stmt|;
name|dwarf_frame_section
operator|=
literal|0
expr_stmt|;
name|dwarf_eh_frame_section
operator|=
literal|0
expr_stmt|;
name|dwarf_ranges_section
operator|=
literal|0
expr_stmt|;
name|dwarf_loc_section
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|dwarf2_locate_sections
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|dwarf_info_section
operator|!=
name|NULL
operator|&&
name|dwarf_abbrev_section
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function is mapped across the sections and remembers the    offset and size of each of the debugging sections we are interested    in.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_locate_sections
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
parameter_list|,
name|asection
modifier|*
name|sectp
parameter_list|,
name|void
modifier|*
name|ignore_ptr
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|INFO_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_info_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_info_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|ABBREV_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_abbrev_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_abbrev_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|LINE_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_line_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_line_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|PUBNAMES_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_pubnames_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_pubnames_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|ARANGES_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_aranges_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_aranges_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|LOC_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_loc_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_loc_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|MACINFO_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_macinfo_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_macinfo_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|STR_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_str_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_str_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|FRAME_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_frame_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_frame_section
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|EH_FRAME_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flagword
name|aflag
init|=
name|bfd_get_section_flags
argument_list|(
name|ignore_abfd
argument_list|,
name|sectp
argument_list|)
decl_stmt|;
if|if
condition|(
name|aflag
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|dwarf_eh_frame_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_eh_frame_section
operator|=
name|sectp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|RANGES_SECTION
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dwarf_ranges_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
name|dwarf_ranges_section
operator|=
name|sectp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a partial symbol table.  */
end_comment

begin_function
name|void
name|dwarf2_build_psymtabs
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|)
block|{
comment|/* We definitely need the .debug_info and .debug_abbrev sections */
name|dwarf_info_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_info_section
argument_list|)
expr_stmt|;
name|dwarf_abbrev_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_abbrev_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_line_section
condition|)
name|dwarf_line_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_line_section
argument_list|)
expr_stmt|;
else|else
name|dwarf_line_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_str_section
condition|)
name|dwarf_str_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_str_section
argument_list|)
expr_stmt|;
else|else
name|dwarf_str_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_macinfo_section
condition|)
name|dwarf_macinfo_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_macinfo_section
argument_list|)
expr_stmt|;
else|else
name|dwarf_macinfo_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_ranges_section
condition|)
name|dwarf_ranges_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_ranges_section
argument_list|)
expr_stmt|;
else|else
name|dwarf_ranges_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dwarf_loc_section
condition|)
name|dwarf_loc_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_loc_section
argument_list|)
expr_stmt|;
else|else
name|dwarf_loc_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mainline
operator|||
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|&&
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
operator|)
condition|)
block|{
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (dwarf_aranges_offset&& dwarf_pubnames_offset)     {
comment|/* Things are significantly easier if we have .debug_aranges and          .debug_pubnames sections */
block|dwarf2_build_psymtabs_easy (objfile, mainline);     }   else
endif|#
directive|endif
comment|/* only test this case for now */
block|{
comment|/* In this case we have to work a bit harder */
name|dwarf2_build_psymtabs_hard
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Build the partial symbol table from the information in the    .debug_pubnames and .debug_aranges sections.  */
end_comment

begin_endif
unit|static void dwarf2_build_psymtabs_easy (struct objfile *objfile, int mainline) {   bfd *abfd = objfile->obfd;   char *aranges_buffer, *pubnames_buffer;   char *aranges_ptr, *pubnames_ptr;   unsigned int entry_length, version, info_offset, info_size;    pubnames_buffer = dwarf2_read_section (objfile, 					 dwarf_pubnames_section);   pubnames_ptr = pubnames_buffer;   while ((pubnames_ptr - pubnames_buffer)< dwarf_pubnames_size)     {       struct comp_unit_head cu_header;       int bytes_read;        entry_length = read_initial_length (abfd, pubnames_ptr,&cu_header,&bytes_read);       pubnames_ptr += bytes_read;       version = read_1_byte (abfd, pubnames_ptr);       pubnames_ptr += 1;       info_offset = read_4_bytes (abfd, pubnames_ptr);       pubnames_ptr += 4;       info_size = read_4_bytes (abfd, pubnames_ptr);       pubnames_ptr += 4;     }    aranges_buffer = dwarf2_read_section (objfile, 					dwarf_aranges_section);  }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read in the comp unit header information from the debug_info at    info_ptr. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_comp_unit_head
parameter_list|(
name|struct
name|comp_unit_head
modifier|*
name|cu_header
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|signed_addr
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|cu_header
operator|->
name|length
operator|=
name|read_initial_length
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu_header
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|cu_header
operator|->
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|cu_header
operator|->
name|abbrev_offset
operator|=
name|read_offset
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu_header
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|cu_header
operator|->
name|addr_size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
name|signed_addr
operator|=
name|bfd_get_sign_extend_vma
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_addr
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_comp_unit_head: dwarf from non elf file"
argument_list|)
expr_stmt|;
name|cu_header
operator|->
name|signed_addr_p
operator|=
name|signed_addr
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Build the partial symbol table by doing a quick pass through the    .debug_info and .debug_abbrev sections.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_build_psymtabs_hard
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|mainline
parameter_list|)
block|{
comment|/* Instead of reading this into a big buffer, we should probably use      mmap()  on architectures that support it. (FIXME) */
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|,
modifier|*
name|abbrev_ptr
decl_stmt|;
name|char
modifier|*
name|beg_of_comp_unit
decl_stmt|;
name|struct
name|partial_die_info
name|comp_unit_die
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|,
name|baseaddr
decl_stmt|;
name|info_ptr
operator|=
name|dwarf_info_buffer
expr_stmt|;
name|abbrev_ptr
operator|=
name|dwarf_abbrev_buffer
expr_stmt|;
comment|/* We use dwarf2_tmp_obstack for objects that don't need to survive      the partial symbol scan, like attribute values.       We could reduce our peak memory consumption during partial symbol      table construction by freeing stuff from this obstack more often      --- say, after processing each compilation unit, or each die ---      but it turns out that this saves almost nothing.  For an      executable with 11Mb of Dwarf 2 data, I found about 64k allocated      on dwarf2_tmp_obstack.  Some investigation showed:       1) 69% of the attributes used forms DW_FORM_addr, DW_FORM_data*,         DW_FORM_flag, DW_FORM_[su]data, and DW_FORM_ref*.  These are         all fixed-length values not requiring dynamic allocation.       2) 30% of the attributes used the form DW_FORM_string.  For         DW_FORM_string, read_attribute simply hands back a pointer to         the null-terminated string in dwarf_info_buffer, so no dynamic         allocation is needed there either.       3) The remaining 1% of the attributes all used DW_FORM_block1.         75% of those were DW_AT_frame_base location lists for         functions; the rest were DW_AT_location attributes, probably         for the global variables.       Anyway, what this all means is that the memory the dwarf2      reader uses as temporary space reading partial symbols is about      0.5% as much as we use for dwarf_*_buffer.  That's noise.  */
name|obstack_init
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|dwarf2_free_tmp_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Since the objects we're extracting from dwarf_info_buffer vary in      length, only the individual functions to extract them (like      read_comp_unit_head and read_partial_die) can really know whether      the buffer is large enough to hold another complete object.       At the moment, they don't actually check that.  If      dwarf_info_buffer holds just one extra byte after the last      compilation unit's dies, then read_comp_unit_head will happily      read off the end of the buffer.  read_partial_die is similarly      casual.  Those functions should be fixed.       For this loop condition, simply checking whether there's any data      left at all should be sufficient.  */
while|while
condition|(
name|info_ptr
operator|<
name|dwarf_info_buffer
operator|+
name|dwarf_info_size
condition|)
block|{
name|struct
name|dwarf2_cu
name|cu
decl_stmt|;
name|beg_of_comp_unit
operator|=
name|info_ptr
expr_stmt|;
name|cu
operator|.
name|objfile
operator|=
name|objfile
expr_stmt|;
name|info_ptr
operator|=
name|read_comp_unit_head
argument_list|(
operator|&
name|cu
operator|.
name|header
argument_list|,
name|info_ptr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cu
operator|.
name|header
operator|.
name|version
operator|!=
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]"
argument_list|,
name|cu
operator|.
name|header
operator|.
name|version
argument_list|,
literal|2
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cu
operator|.
name|header
operator|.
name|abbrev_offset
operator|>=
name|dwarf_abbrev_size
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6) [in module %s]"
argument_list|,
operator|(
name|long
operator|)
name|cu
operator|.
name|header
operator|.
name|abbrev_offset
argument_list|,
call|(
name|long
call|)
argument_list|(
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|beg_of_comp_unit
operator|+
name|cu
operator|.
name|header
operator|.
name|length
operator|+
name|cu
operator|.
name|header
operator|.
name|initial_length_size
operator|>
name|dwarf_info_buffer
operator|+
name|dwarf_info_size
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0) [in module %s]"
argument_list|,
operator|(
name|long
operator|)
name|cu
operator|.
name|header
operator|.
name|length
argument_list|,
call|(
name|long
call|)
argument_list|(
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Complete the cu_header */
name|cu
operator|.
name|header
operator|.
name|offset
operator|=
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|cu
operator|.
name|header
operator|.
name|first_die_ptr
operator|=
name|info_ptr
expr_stmt|;
name|cu
operator|.
name|header
operator|.
name|cu_head_ptr
operator|=
name|beg_of_comp_unit
expr_stmt|;
name|cu
operator|.
name|list_in_scope
operator|=
operator|&
name|file_symbols
expr_stmt|;
comment|/* Read the abbrevs for this compilation unit into a table */
name|dwarf2_read_abbrevs
argument_list|(
name|abfd
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|dwarf2_empty_abbrev_table
argument_list|,
name|cu
operator|.
name|header
operator|.
name|dwarf2_abbrevs
argument_list|)
expr_stmt|;
comment|/* Read the compilation unit die */
name|info_ptr
operator|=
name|read_partial_die
argument_list|(
operator|&
name|comp_unit_die
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
comment|/* Set the language we're debugging */
name|set_cu_language
argument_list|(
name|comp_unit_die
operator|.
name|language
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
comment|/* Allocate a new partial symbol table structure */
name|pst
operator|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|objfile
operator|->
name|section_offsets
argument_list|,
name|comp_unit_die
operator|.
name|name
condition|?
name|comp_unit_die
operator|.
name|name
else|:
literal|""
argument_list|,
name|comp_unit_die
operator|.
name|lowpc
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|pst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_pinfo
argument_list|)
argument_list|)
expr_stmt|;
name|DWARF_INFO_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_info_buffer
expr_stmt|;
name|DWARF_INFO_OFFSET
argument_list|(
name|pst
argument_list|)
operator|=
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|DWARF_ABBREV_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_abbrev_buffer
expr_stmt|;
name|DWARF_ABBREV_SIZE
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_abbrev_size
expr_stmt|;
name|DWARF_LINE_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_line_buffer
expr_stmt|;
name|DWARF_LINE_SIZE
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_line_size
expr_stmt|;
name|DWARF_STR_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_str_buffer
expr_stmt|;
name|DWARF_STR_SIZE
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_str_size
expr_stmt|;
name|DWARF_MACINFO_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_macinfo_buffer
expr_stmt|;
name|DWARF_MACINFO_SIZE
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_macinfo_size
expr_stmt|;
name|DWARF_RANGES_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_ranges_buffer
expr_stmt|;
name|DWARF_RANGES_SIZE
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_ranges_size
expr_stmt|;
name|DWARF_LOC_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_loc_buffer
expr_stmt|;
name|DWARF_LOC_SIZE
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_loc_size
expr_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the function that reads in the rest of the symbol table */
name|pst
operator|->
name|read_symtab
operator|=
name|dwarf2_psymtab_to_symtab
expr_stmt|;
comment|/* Check if comp unit has_children.          If so, read the rest of the partial symbols from this comp unit.          If not, there's no more debug_info for this comp unit. */
if|if
condition|(
name|comp_unit_die
operator|.
name|has_children
condition|)
block|{
name|lowpc
operator|=
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|highpc
operator|=
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|0
operator|)
expr_stmt|;
name|info_ptr
operator|=
name|scan_partial_symbols
argument_list|(
name|info_ptr
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
operator|&
name|cu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we didn't find a lowpc, set it to highpc to avoid 	     complaints from `maint check'.  */
if|if
condition|(
name|lowpc
operator|==
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
condition|)
name|lowpc
operator|=
name|highpc
expr_stmt|;
comment|/* If the compilation unit didn't have an explicit address range, 	     then use the information extracted from its child dies.  */
if|if
condition|(
operator|!
name|comp_unit_die
operator|.
name|has_pc_info
condition|)
block|{
name|comp_unit_die
operator|.
name|lowpc
operator|=
name|lowpc
expr_stmt|;
name|comp_unit_die
operator|.
name|highpc
operator|=
name|highpc
expr_stmt|;
block|}
block|}
name|pst
operator|->
name|textlow
operator|=
name|comp_unit_die
operator|.
name|lowpc
operator|+
name|baseaddr
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|comp_unit_die
operator|.
name|highpc
operator|+
name|baseaddr
expr_stmt|;
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this          name, remove it. (If there is a symtab, more drastic things          also happen.) This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|info_ptr
operator|=
name|beg_of_comp_unit
operator|+
name|cu
operator|.
name|header
operator|.
name|length
operator|+
name|cu
operator|.
name|header
operator|.
name|initial_length_size
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all interesting dies to the end of the compilation unit or    to the end of the current namespace.  NAMESPACE is NULL if we    haven't yet encountered any DW_TAG_namespace entries; otherwise,    it's the name of the current namespace.  In particular, it's the    empty string if we're currently in the global namespace but have    previously encountered a DW_TAG_namespace.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|scan_partial_symbols
parameter_list|(
name|char
modifier|*
name|info_ptr
parameter_list|,
name|CORE_ADDR
modifier|*
name|lowpc
parameter_list|,
name|CORE_ADDR
modifier|*
name|highpc
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|partial_die_info
name|pdi
decl_stmt|;
comment|/* Now, march along the PDI's, descending into ones which have      interesting children but skipping the children of the other ones,      until we reach the end of the compilation unit.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* This flag tells whether or not info_ptr has gotten updated 	 inside the loop.  */
name|int
name|info_ptr_updated
init|=
literal|0
decl_stmt|;
name|info_ptr
operator|=
name|read_partial_die
argument_list|(
operator|&
name|pdi
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Anonymous namespaces have no name but have interesting 	 children, so we need to look at them.  Ditto for anonymous 	 enums.  */
if|if
condition|(
name|pdi
operator|.
name|name
operator|!=
name|NULL
operator|||
name|pdi
operator|.
name|tag
operator|==
name|DW_TAG_namespace
operator|||
name|pdi
operator|.
name|tag
operator|==
name|DW_TAG_enumeration_type
condition|)
block|{
switch|switch
condition|(
name|pdi
operator|.
name|tag
condition|)
block|{
case|case
name|DW_TAG_subprogram
case|:
if|if
condition|(
name|pdi
operator|.
name|has_pc_info
condition|)
block|{
if|if
condition|(
name|pdi
operator|.
name|lowpc
operator|<
operator|*
name|lowpc
condition|)
block|{
operator|*
name|lowpc
operator|=
name|pdi
operator|.
name|lowpc
expr_stmt|;
block|}
if|if
condition|(
name|pdi
operator|.
name|highpc
operator|>
operator|*
name|highpc
condition|)
block|{
operator|*
name|highpc
operator|=
name|pdi
operator|.
name|highpc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pdi
operator|.
name|is_declaration
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_TAG_variable
case|:
case|case
name|DW_TAG_typedef
case|:
case|case
name|DW_TAG_union_type
case|:
if|if
condition|(
operator|!
name|pdi
operator|.
name|is_declaration
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
if|if
condition|(
operator|!
name|pdi
operator|.
name|is_declaration
condition|)
block|{
name|info_ptr
operator|=
name|add_partial_structure
argument_list|(
operator|&
name|pdi
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|info_ptr_updated
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_enumeration_type
case|:
if|if
condition|(
operator|!
name|pdi
operator|.
name|is_declaration
condition|)
block|{
name|info_ptr
operator|=
name|add_partial_enumeration
argument_list|(
operator|&
name|pdi
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|info_ptr_updated
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_base_type
case|:
case|case
name|DW_TAG_subrange_type
case|:
comment|/* File scope base type definitions are added to the partial 	         symbol table.  */
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_namespace
case|:
comment|/* We've hit a DW_TAG_namespace entry, so we know this 		 file has been compiled using a compiler that 		 generates them; update NAMESPACE to reflect that.  */
if|if
condition|(
name|namespace
operator|==
name|NULL
condition|)
name|namespace
operator|=
literal|""
expr_stmt|;
name|info_ptr
operator|=
name|add_partial_namespace
argument_list|(
operator|&
name|pdi
argument_list|,
name|info_ptr
argument_list|,
name|lowpc
argument_list|,
name|highpc
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|info_ptr_updated
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|pdi
operator|.
name|tag
operator|==
literal|0
condition|)
break|break;
comment|/* If the die has a sibling, skip to the sibling, unless another 	 function has already updated info_ptr for us.  */
comment|/* NOTE: carlton/2003-06-16: This is a bit hackish, but whether 	 or not we want to update this depends on enough stuff (not 	 only pdi.tag but also whether or not pdi.name is NULL) that 	 this seems like the easiest way to handle the issue.  */
if|if
condition|(
operator|!
name|info_ptr_updated
condition|)
name|info_ptr
operator|=
name|locate_pdi_sibling
argument_list|(
operator|&
name|pdi
argument_list|,
name|info_ptr
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
return|return
name|info_ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_partial_symbol
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|pdi
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|actual_name
init|=
name|pdi
operator|->
name|name
decl_stmt|;
specifier|const
name|struct
name|partial_symbol
modifier|*
name|psym
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're not in the global namespace and if the namespace name      isn't encoded in a mangled actual_name, add it.  */
if|if
condition|(
name|pdi_needs_namespace
argument_list|(
name|pdi
operator|->
name|tag
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|actual_name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|namespace
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|actual_name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|actual_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|actual_name
argument_list|,
name|pdi
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|pdi
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_subprogram
case|:
if|if
condition|(
name|pdi
operator|->
name|is_external
condition|)
block|{
comment|/*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr, 	     mst_text, objfile); */
name|psym
operator|=
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|pdi
operator|->
name|lowpc
operator|+
name|baseaddr
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr, 	     mst_file_text, objfile); */
name|psym
operator|=
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|pdi
operator|->
name|lowpc
operator|+
name|baseaddr
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_variable
case|:
if|if
condition|(
name|pdi
operator|->
name|is_external
condition|)
block|{
comment|/* Global Variable. 	     Don't enter into the minimal symbol tables as there is 	     a minimal symbol table entry from the ELF symbols already. 	     Enter into partial symbol table if it has a location 	     descriptor or a type. 	     If the location descriptor is missing, new_symbol will create 	     a LOC_UNRESOLVED symbol, the address of the variable will then 	     be determined from the minimal symbol table whenever the variable 	     is referenced. 	     The address for the partial symbol table entry is not 	     used by GDB, but it comes in handy for debugging partial symbol 	     table building.  */
if|if
condition|(
name|pdi
operator|->
name|locdesc
condition|)
name|addr
operator|=
name|decode_locdesc
argument_list|(
name|pdi
operator|->
name|locdesc
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdi
operator|->
name|locdesc
operator|||
name|pdi
operator|->
name|has_type
condition|)
name|psym
operator|=
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|addr
operator|+
name|baseaddr
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Static Variable. Skip symbols without location descriptors.  */
if|if
condition|(
name|pdi
operator|->
name|locdesc
operator|==
name|NULL
condition|)
return|return;
name|addr
operator|=
name|decode_locdesc
argument_list|(
name|pdi
operator|->
name|locdesc
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/*prim_record_minimal_symbol (actual_name, addr + baseaddr, 	     mst_file_data, objfile); */
name|psym
operator|=
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|addr
operator|+
name|baseaddr
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_typedef
case|:
case|case
name|DW_TAG_base_type
case|:
case|case
name|DW_TAG_subrange_type
case|:
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
comment|/* Skip aggregate types without children, these are external          references.  */
comment|/* NOTE: carlton/2003-10-07: See comment in new_symbol about 	 static vs. global.  */
if|if
condition|(
name|pdi
operator|->
name|has_children
operator|==
literal|0
condition|)
return|return;
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|?
operator|&
name|objfile
operator|->
name|global_psymbols
else|:
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|)
block|{
comment|/* For C++, these implicitly act as typedefs as well. */
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_enumerator
case|:
name|add_psymbol_to_list
argument_list|(
name|actual_name
argument_list|,
name|strlen
argument_list|(
name|actual_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_CONST
argument_list|,
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|?
operator|&
name|objfile
operator|->
name|global_psymbols
else|:
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Check to see if we should scan the name for possible namespace      info.  Only do this if this is C++, if we don't have namespace      debugging info in the file, if the psym is of an appropriate type      (otherwise we'll have psym == NULL), and if we actually had a      mangled name to begin with.  */
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_cplus
operator|&&
name|namespace
operator|==
name|NULL
operator|&&
name|psym
operator|!=
name|NULL
operator|&&
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|psym
argument_list|)
operator|!=
name|NULL
condition|)
name|cp_check_possible_namespace_symbols
argument_list|(
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine whether a die of type TAG living in the C++ namespace    NAMESPACE needs to have the name of the namespace prepended to the    name listed in the die.  */
end_comment

begin_function
specifier|static
name|int
name|pdi_needs_namespace
parameter_list|(
name|enum
name|dwarf_tag
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|==
name|NULL
operator|||
name|namespace
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_typedef
case|:
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read a partial die corresponding to a namespace; also, add a symbol    corresponding to that namespace to the symbol table.  NAMESPACE is    the name of the enclosing namespace.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|add_partial_namespace
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|CORE_ADDR
modifier|*
name|lowpc
parameter_list|,
name|CORE_ADDR
modifier|*
name|highpc
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
init|=
name|pdi
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|full_name
decl_stmt|;
comment|/* Calculate the full name of the namespace that we just entered.  */
if|if
condition|(
name|new_name
operator|==
name|NULL
condition|)
name|new_name
operator|=
literal|"(anonymous namespace)"
expr_stmt|;
name|full_name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|namespace
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|new_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|namespace
operator|!=
literal|'\0'
condition|)
name|strcat
argument_list|(
name|full_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
comment|/* FIXME: carlton/2003-10-07: We can't just replace this by a call      to add_partial_symbol, because we don't have a way to pass in the      full name to that function; that might be a flaw in      add_partial_symbol's interface.  */
name|add_psymbol_to_list
argument_list|(
name|full_name
argument_list|,
name|strlen
argument_list|(
name|full_name
argument_list|)
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cu
operator|->
name|language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Now scan partial symbols in that namespace.  */
if|if
condition|(
name|pdi
operator|->
name|has_children
condition|)
name|info_ptr
operator|=
name|scan_partial_symbols
argument_list|(
name|info_ptr
argument_list|,
name|lowpc
argument_list|,
name|highpc
argument_list|,
name|cu
argument_list|,
name|full_name
argument_list|)
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read a partial die corresponding to a class or structure.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|add_partial_structure
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|struct_pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|cu
operator|->
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|actual_class_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_cplus
operator|&&
operator|(
name|namespace
operator|==
name|NULL
operator|||
name|namespace
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|struct_pdi
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|struct_pdi
operator|->
name|has_children
condition|)
block|{
comment|/* See if we can figure out if the class lives in a namespace 	 (or is nested within another class.)  We do this by looking 	 for a member function; its demangled name will contain 	 namespace info, if there is any.  */
comment|/* NOTE: carlton/2003-10-07: Getting the info this way changes 	 what template types look like, because the demangler 	 frequently doesn't give the same name as the debug info.  We 	 could fix this by only using the demangled name to get the 	 prefix (but see comment in read_structure_type).  */
comment|/* FIXME: carlton/2004-01-23: If NAMESPACE equals "", we have 	 the appropriate debug information, so it would be nice to be 	 able to avoid this hack.  But NAMESPACE may not be the 	 namespace where this class was defined: NAMESPACE reflects 	 where STRUCT_PDI occurs in the tree of dies, but because of 	 DW_AT_specification, that may not actually tell us where the 	 class is defined.  (See the comment in read_func_scope for an 	 example of how this could occur.)           Unfortunately, our current partial symtab data structures are          completely unable to deal with DW_AT_specification.  So, for          now, the best thing to do is to get nesting information from          places other than the tree structure of dies if there's any          chance that a DW_AT_specification is involved. :-( */
name|char
modifier|*
name|next_child
init|=
name|info_ptr
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|partial_die_info
name|child_pdi
decl_stmt|;
name|next_child
operator|=
name|read_partial_die
argument_list|(
operator|&
name|child_pdi
argument_list|,
name|abfd
argument_list|,
name|next_child
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child_pdi
operator|.
name|tag
condition|)
break|break;
if|if
condition|(
name|child_pdi
operator|.
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|actual_class_name
operator|=
name|class_name_from_physname
argument_list|(
name|child_pdi
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_class_name
operator|!=
name|NULL
condition|)
name|struct_pdi
operator|->
name|name
operator|=
name|actual_class_name
expr_stmt|;
break|break;
block|}
else|else
block|{
name|next_child
operator|=
name|locate_pdi_sibling
argument_list|(
operator|&
name|child_pdi
argument_list|,
name|next_child
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|add_partial_symbol
argument_list|(
name|struct_pdi
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|actual_class_name
argument_list|)
expr_stmt|;
return|return
name|locate_pdi_sibling
argument_list|(
name|struct_pdi
argument_list|,
name|info_ptr
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a partial die corresponding to an enumeration type.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|add_partial_enumeration
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|enum_pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|partial_die_info
name|pdi
decl_stmt|;
if|if
condition|(
name|enum_pdi
operator|->
name|name
operator|!=
name|NULL
condition|)
name|add_partial_symbol
argument_list|(
name|enum_pdi
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|info_ptr
operator|=
name|read_partial_die
argument_list|(
operator|&
name|pdi
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdi
operator|.
name|tag
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pdi
operator|.
name|tag
operator|!=
name|DW_TAG_enumerator
operator|||
name|pdi
operator|.
name|name
operator|==
name|NULL
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"malformed enumerator DIE ignored"
argument_list|)
expr_stmt|;
else|else
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|cu
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Locate ORIG_PDI's sibling; INFO_PTR should point to the next DIE    after ORIG_PDI.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|locate_pdi_sibling
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|orig_pdi
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
comment|/* Do we know the sibling already?  */
if|if
condition|(
name|orig_pdi
operator|->
name|sibling
condition|)
return|return
name|orig_pdi
operator|->
name|sibling
return|;
comment|/* Are there any children to deal with?  */
if|if
condition|(
operator|!
name|orig_pdi
operator|->
name|has_children
condition|)
return|return
name|info_ptr
return|;
comment|/* Okay, we don't know the sibling, but we have children that we      want to skip.  So read children until we run into one without a      tag; return whatever follows it.  */
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|partial_die_info
name|pdi
decl_stmt|;
name|info_ptr
operator|=
name|read_partial_die
argument_list|(
operator|&
name|pdi
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdi
operator|.
name|tag
operator|==
literal|0
condition|)
return|return
name|info_ptr
return|;
else|else
name|info_ptr
operator|=
name|locate_pdi_sibling
argument_list|(
operator|&
name|pdi
argument_list|,
name|info_ptr
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand this partial symbol table into a full symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_psymtab_to_symtab
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
comment|/* FIXME: This is barely more than a stub.  */
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|warning
argument_list|(
literal|"bug: psymtab for %s is already read in."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|psymtab_to_symtab_1
parameter_list|(
name|struct
name|partial_symtab
modifier|*
name|pst
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|dwarf2_cu
name|cu
decl_stmt|;
name|struct
name|die_info
modifier|*
name|dies
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
comment|/* Set local variables from the partial symbol table info.  */
name|offset
operator|=
name|DWARF_INFO_OFFSET
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_info_buffer
operator|=
name|DWARF_INFO_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_abbrev_buffer
operator|=
name|DWARF_ABBREV_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_abbrev_size
operator|=
name|DWARF_ABBREV_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_line_buffer
operator|=
name|DWARF_LINE_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_line_size
operator|=
name|DWARF_LINE_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_str_buffer
operator|=
name|DWARF_STR_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_str_size
operator|=
name|DWARF_STR_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_macinfo_buffer
operator|=
name|DWARF_MACINFO_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_macinfo_size
operator|=
name|DWARF_MACINFO_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_ranges_buffer
operator|=
name|DWARF_RANGES_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_ranges_size
operator|=
name|DWARF_RANGES_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_loc_buffer
operator|=
name|DWARF_LOC_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_loc_size
operator|=
name|DWARF_LOC_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|info_ptr
operator|=
name|dwarf_info_buffer
operator|+
name|offset
expr_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're in the global namespace.  */
name|processing_current_prefix
operator|=
literal|""
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|dwarf2_free_tmp_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buildsym_init
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cu
operator|.
name|objfile
operator|=
name|objfile
expr_stmt|;
comment|/* read in the comp_unit header  */
name|info_ptr
operator|=
name|read_comp_unit_head
argument_list|(
operator|&
name|cu
operator|.
name|header
argument_list|,
name|info_ptr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* Read the abbrevs for this compilation unit  */
name|dwarf2_read_abbrevs
argument_list|(
name|abfd
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|dwarf2_empty_abbrev_table
argument_list|,
name|cu
operator|.
name|header
operator|.
name|dwarf2_abbrevs
argument_list|)
expr_stmt|;
name|cu
operator|.
name|header
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|cu
operator|.
name|list_in_scope
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|dies
operator|=
name|read_comp_unit
argument_list|(
name|info_ptr
argument_list|,
name|abfd
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
name|make_cleanup_free_die_list
argument_list|(
name|dies
argument_list|)
expr_stmt|;
comment|/* Find the base address of the compilation unit for range lists and      location lists.  It will normally be specified by DW_AT_low_pc.      In DWARF-3 draft 4, the base address could be overridden by      DW_AT_entry_pc.  It's been removed, but GCC still uses this for      compilation units with discontinuous ranges.  */
name|cu
operator|.
name|header
operator|.
name|base_known
operator|=
literal|0
expr_stmt|;
name|cu
operator|.
name|header
operator|.
name|base_address
operator|=
literal|0
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|dies
argument_list|,
name|DW_AT_entry_pc
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|cu
operator|.
name|header
operator|.
name|base_address
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|cu
operator|.
name|header
operator|.
name|base_known
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|dies
argument_list|,
name|DW_AT_low_pc
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|cu
operator|.
name|header
operator|.
name|base_address
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|cu
operator|.
name|header
operator|.
name|base_known
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Do line number decoding in read_file_scope () */
name|process_die
argument_list|(
name|dies
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
comment|/* Some compilers don't define a DW_AT_high_pc attribute for the      compilation unit.  If the DW_AT_high_pc is missing, synthesize      it, by scanning the DIE's below the compilation unit.  */
name|get_scope_pc_bounds
argument_list|(
name|dies
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
operator|&
name|cu
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|end_symtab
argument_list|(
name|highpc
operator|+
name|baseaddr
argument_list|,
name|objfile
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set symtab language to language from DW_AT_language.      If the compilation is from a C file generated by language preprocessors,      do not set the language if it was already deduced by start_subfile.  */
if|if
condition|(
name|symtab
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|cu
operator|.
name|language
operator|==
name|language_c
operator|&&
name|symtab
operator|->
name|language
operator|!=
name|language_c
operator|)
condition|)
block|{
name|symtab
operator|->
name|language
operator|=
name|cu
operator|.
name|language
expr_stmt|;
block|}
name|pst
operator|->
name|symtab
operator|=
name|symtab
expr_stmt|;
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a die and its children.  */
end_comment

begin_function
specifier|static
name|void
name|process_die
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
switch|switch
condition|(
name|die
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
break|break;
case|case
name|DW_TAG_compile_unit
case|:
name|read_file_scope
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_subprogram
case|:
name|read_subroutine_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|read_func_scope
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_inlined_subroutine
case|:
comment|/* FIXME:  These are ignored for now.          They could be used to set breakpoints on all inlined instances          of a function and make GDB `next' properly over inlined functions.  */
break|break;
case|case
name|DW_TAG_lexical_block
case|:
case|case
name|DW_TAG_try_block
case|:
case|case
name|DW_TAG_catch_block
case|:
name|read_lexical_block_scope
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
name|read_structure_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|process_structure_scope
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_enumeration_type
case|:
name|read_enumeration_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|process_enumeration_scope
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME drow/2004-03-14: These initialize die->type, but do not create        a symbol or process any children.  Therefore it doesn't do anything        that won't be done on-demand by read_type_die.  */
case|case
name|DW_TAG_subroutine_type
case|:
name|read_subroutine_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_array_type
case|:
name|read_array_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_pointer_type
case|:
name|read_tag_pointer_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_ptr_to_member_type
case|:
name|read_tag_ptr_to_member_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_reference_type
case|:
name|read_tag_reference_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_string_type
case|:
name|read_tag_string_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
comment|/* END FIXME */
case|case
name|DW_TAG_base_type
case|:
name|read_base_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Add a typedef symbol for the type definition, if it has a 	 DW_AT_name.  */
name|new_symbol
argument_list|(
name|die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_subrange_type
case|:
name|read_subrange_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Add a typedef symbol for the type definition, if it has a          DW_AT_name.  */
name|new_symbol
argument_list|(
name|die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_common_block
case|:
name|read_common_block
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_common_inclusion
case|:
break|break;
case|case
name|DW_TAG_namespace
case|:
name|processing_has_namespace_info
operator|=
literal|1
expr_stmt|;
name|read_namespace
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_imported_declaration
case|:
case|case
name|DW_TAG_imported_module
case|:
comment|/* FIXME: carlton/2002-10-16: Eventually, we should use the 	 information contained in these.  DW_TAG_imported_declaration 	 dies shouldn't have children; DW_TAG_imported_module dies 	 shouldn't in the C++ case, but conceivably could in the 	 Fortran case, so we'll have to replace this gdb_assert if 	 Fortran compilers start generating that info.  */
name|processing_has_namespace_info
operator|=
literal|1
expr_stmt|;
name|gdb_assert
argument_list|(
name|die
operator|->
name|child
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_symbol
argument_list|(
name|die
argument_list|,
name|NULL
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_cu_func_list
parameter_list|(
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|cu
operator|->
name|first_fn
operator|=
name|cu
operator|->
name|last_fn
operator|=
name|cu
operator|->
name|cached_fn
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_file_scope
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|lowpc
init|=
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|CORE_ADDR
name|highpc
init|=
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|0
operator|)
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|"<unknown>"
decl_stmt|;
name|char
modifier|*
name|comp_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|line_header
modifier|*
name|line_header
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|get_scope_pc_bounds
argument_list|(
name|die
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* If we didn't find a lowpc, set it to highpc to avoid complaints      from finish_block.  */
if|if
condition|(
name|lowpc
operator|==
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
condition|)
name|lowpc
operator|=
name|highpc
expr_stmt|;
name|lowpc
operator|+=
name|baseaddr
expr_stmt|;
name|highpc
operator|+=
name|baseaddr
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|name
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_comp_dir
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|comp_dir
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_dir
condition|)
block|{
comment|/* Irix 6.2 native cc prepends<machine>.: to the compilation 	     directory, get rid of it.  */
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|comp_dir
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
operator|!=
name|comp_dir
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|comp_dir
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|lowpc
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|highpc
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_lowpc
operator|=
name|lowpc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|deprecated_entry_file_highpc
operator|=
name|highpc
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_language
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|set_cu_language
argument_list|(
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
comment|/* We assume that we're processing GCC output. */
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME:Do something here.  */
block|if (dip->at_producer != NULL)     {       handle_producer (dip->at_producer);     }
endif|#
directive|endif
comment|/* The compilation unit may be in a different language or objfile,      zero out all remembered fundamental types.  */
name|memset
argument_list|(
name|cu
operator|->
name|ftypes
argument_list|,
literal|0
argument_list|,
name|FT_NUM_MEMBERS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|start_symtab
argument_list|(
name|name
argument_list|,
name|comp_dir
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"DWARF 2"
argument_list|)
expr_stmt|;
name|initialize_cu_func_list
argument_list|(
name|cu
argument_list|)
expr_stmt|;
comment|/* Process all dies in compilation unit.  */
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Decode line number information if present.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_stmt_list
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|unsigned
name|int
name|line_offset
init|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
decl_stmt|;
name|line_header
operator|=
name|dwarf_decode_line_header
argument_list|(
name|line_offset
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_header
condition|)
block|{
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_ftype
operator|*
operator|)
name|free_line_header
argument_list|,
operator|(
name|void
operator|*
operator|)
name|line_header
argument_list|)
expr_stmt|;
name|dwarf_decode_lines
argument_list|(
name|line_header
argument_list|,
name|comp_dir
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Decode macro information, if present.  Dwarf 2 macro information      refers to information in the line number info statement program      header, so we can only read it if we've read the header      successfully.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_macro_info
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|line_header
condition|)
block|{
name|unsigned
name|int
name|macro_offset
init|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
decl_stmt|;
name|dwarf_decode_macros
argument_list|(
name|line_header
argument_list|,
name|macro_offset
argument_list|,
name|comp_dir
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_to_cu_func_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
name|lowpc
parameter_list|,
name|CORE_ADDR
name|highpc
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|function_range
modifier|*
name|thisfn
decl_stmt|;
name|thisfn
operator|=
operator|(
expr|struct
name|function_range
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|function_range
argument_list|)
argument_list|)
expr_stmt|;
name|thisfn
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|thisfn
operator|->
name|lowpc
operator|=
name|lowpc
expr_stmt|;
name|thisfn
operator|->
name|highpc
operator|=
name|highpc
expr_stmt|;
name|thisfn
operator|->
name|seen_line
operator|=
literal|0
expr_stmt|;
name|thisfn
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|last_fn
operator|==
name|NULL
condition|)
name|cu
operator|->
name|first_fn
operator|=
name|thisfn
expr_stmt|;
else|else
name|cu
operator|->
name|last_fn
operator|->
name|next
operator|=
name|thisfn
expr_stmt|;
name|cu
operator|->
name|last_fn
operator|=
name|thisfn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_func_scope
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|;
name|CORE_ADDR
name|highpc
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|previous_prefix
init|=
name|processing_current_prefix
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Ignore functions with missing or empty names and functions with      missing or invalid low and high pc attributes.  */
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|dwarf2_get_pc_bounds
argument_list|(
name|die
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
name|cu
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|)
block|{
name|struct
name|die_info
modifier|*
name|spec_die
init|=
name|die_specification
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
comment|/* NOTE: carlton/2004-01-23: We have to be careful in the          presence of DW_AT_specification.  For example, with GCC 3.4,          given the code             namespace N {              void foo() {                // Definition of N::foo.              }            }           then we'll have a tree of DIEs like this:           1: DW_TAG_compile_unit            2: DW_TAG_namespace        // N              3: DW_TAG_subprogram     // declaration of N::foo            4: DW_TAG_subprogram       // definition of N::foo                 DW_AT_specification   // refers to die #3           Thus, when processing die #4, we have to pretend that we're          in the context of its DW_AT_specification, namely the contex          of die #3.  */
if|if
condition|(
name|spec_die
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|specification_prefix
init|=
name|determine_prefix
argument_list|(
name|spec_die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|processing_current_prefix
operator|=
name|specification_prefix
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|specification_prefix
argument_list|)
expr_stmt|;
block|}
block|}
name|lowpc
operator|+=
name|baseaddr
expr_stmt|;
name|highpc
operator|+=
name|baseaddr
expr_stmt|;
comment|/* Record the function range for dwarf_decode_lines.  */
name|add_to_cu_func_list
argument_list|(
name|name
argument_list|,
name|lowpc
argument_list|,
name|highpc
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|lowpc
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|highpc
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|=
name|lowpc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|=
name|highpc
expr_stmt|;
block|}
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|new_symbol
argument_list|(
name|die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* If there is a location expression for DW_AT_frame_base, record      it.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_frame_base
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
comment|/* FIXME: cagney/2004-01-26: The DW_AT_frame_base's location        expression is being recorded directly in the function's symbol        and not in a separate frame-base object.  I guess this hack is        to avoid adding some sort of frame-base adjunct/annex to the        function's symbol :-(.  The problem with doing this is that it        results in a function symbol with a location expression that        has nothing to do with the location of the function, ouch!  The        relationship should be: a function's symbol has-a frame base; a        frame-base has-a location expression.  */
name|dwarf2_symbol_mark_computed
argument_list|(
name|attr
argument_list|,
name|new
operator|->
name|name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|cu
operator|->
name|list_in_scope
operator|=
operator|&
name|local_symbols
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|lowpc
argument_list|,
name|highpc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* In C++, we can have functions nested inside functions (e.g., when      a function declares a class that has methods).  This means that      when we finish processing a function scope, we may need to go      back to building a containing block's symbol lists.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
name|param_symbols
operator|=
name|new
operator|->
name|params
expr_stmt|;
comment|/* If we've finished processing a top-level function, subsequent      symbols go in the file symbol list.  */
if|if
condition|(
name|outermost_context_p
argument_list|()
condition|)
name|cu
operator|->
name|list_in_scope
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|processing_current_prefix
operator|=
name|previous_prefix
expr_stmt|;
if|if
condition|(
name|back_to
operator|!=
name|NULL
condition|)
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process all the DIES contained within a lexical block scope.  Start    a new scope, process the dies, and then close the scope.  */
end_comment

begin_function
specifier|static
name|void
name|read_lexical_block_scope
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore blocks with missing or invalid low and high pc attributes.  */
comment|/* ??? Perhaps consider discontiguous blocks defined by DW_AT_ranges      as multiple lexical blocks?  Handling children in a sane way would      be nasty.  Might be easier to properly extend generic blocks to       describe ranges.  */
if|if
condition|(
operator|!
name|dwarf2_get_pc_bounds
argument_list|(
name|die
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
name|cu
argument_list|)
condition|)
return|return;
name|lowpc
operator|+=
name|baseaddr
expr_stmt|;
name|highpc
operator|+=
name|baseaddr
expr_stmt|;
name|push_context
argument_list|(
literal|0
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_symbols
operator|!=
name|NULL
condition|)
block|{
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|highpc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get low and high pc attributes from a die.  Return 1 if the attributes    are present and valid, otherwise, return 0.  Return -1 if the range is    discontinuous, i.e. derived from DW_AT_ranges information.  */
end_comment

begin_function
specifier|static
name|int
name|dwarf2_get_pc_bounds
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|CORE_ADDR
modifier|*
name|lowpc
parameter_list|,
name|CORE_ADDR
modifier|*
name|highpc
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|bfd
modifier|*
name|obfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|CORE_ADDR
name|low
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|high
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|high
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|low
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
else|else
comment|/* Found high w/o low attribute.  */
return|return
literal|0
return|;
comment|/* Found consecutive range of addresses.  */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_ranges
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|addr_size
init|=
name|cu_header
operator|->
name|addr_size
decl_stmt|;
name|CORE_ADDR
name|mask
init|=
operator|~
operator|(
operator|~
operator|(
name|CORE_ADDR
operator|)
literal|1
operator|<<
operator|(
name|addr_size
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
comment|/* Value of the DW_AT_ranges attribute is the offset in the 	     .debug_ranges section.  */
name|unsigned
name|int
name|offset
init|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
decl_stmt|;
comment|/* Base address selection entry.  */
name|CORE_ADDR
name|base
decl_stmt|;
name|int
name|found_base
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|CORE_ADDR
name|marker
decl_stmt|;
name|int
name|low_set
decl_stmt|;
name|found_base
operator|=
name|cu_header
operator|->
name|base_known
expr_stmt|;
name|base
operator|=
name|cu_header
operator|->
name|base_address
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|dwarf_ranges_size
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Offset %d out of bounds for DW_AT_ranges attribute"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buffer
operator|=
name|dwarf_ranges_buffer
operator|+
name|offset
expr_stmt|;
comment|/* Read in the largest possible address.  */
name|marker
operator|=
name|read_address
argument_list|(
name|obfd
argument_list|,
name|buffer
argument_list|,
name|cu
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|marker
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
block|{
comment|/* If we found the largest possible address, then 		 read the base address.  */
name|base
operator|=
name|read_address
argument_list|(
name|obfd
argument_list|,
name|buffer
operator|+
name|addr_size
argument_list|,
name|cu
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|buffer
operator|+=
literal|2
operator|*
name|addr_size
expr_stmt|;
name|offset
operator|+=
literal|2
operator|*
name|addr_size
expr_stmt|;
name|found_base
operator|=
literal|1
expr_stmt|;
block|}
name|low_set
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|CORE_ADDR
name|range_beginning
decl_stmt|,
name|range_end
decl_stmt|;
name|range_beginning
operator|=
name|read_address
argument_list|(
name|obfd
argument_list|,
name|buffer
argument_list|,
name|cu
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|addr_size
expr_stmt|;
name|range_end
operator|=
name|read_address
argument_list|(
name|obfd
argument_list|,
name|buffer
argument_list|,
name|cu
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|addr_size
expr_stmt|;
name|offset
operator|+=
literal|2
operator|*
name|addr_size
expr_stmt|;
comment|/* An end of list marker is a pair of zero addresses.  */
if|if
condition|(
name|range_beginning
operator|==
literal|0
operator|&&
name|range_end
operator|==
literal|0
condition|)
comment|/* Found the end of list entry.  */
break|break;
comment|/* Each base address selection entry is a pair of 2 values. 		 The first is the largest possible address, the second is 		 the base address.  Check for a base address here.  */
if|if
condition|(
operator|(
name|range_beginning
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
block|{
comment|/* If we found the largest possible address, then 		     read the base address.  */
name|base
operator|=
name|read_address
argument_list|(
name|obfd
argument_list|,
name|buffer
operator|+
name|addr_size
argument_list|,
name|cu
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|found_base
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|found_base
condition|)
block|{
comment|/* We have no valid base address for the ranges 		     data.  */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Invalid .debug_ranges data (no base address)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|range_beginning
operator|+=
name|base
expr_stmt|;
name|range_end
operator|+=
name|base
expr_stmt|;
comment|/* FIXME: This is recording everything as a low-high 		 segment of consecutive addresses.  We should have a 		 data structure for discontiguous block ranges 		 instead.  */
if|if
condition|(
operator|!
name|low_set
condition|)
block|{
name|low
operator|=
name|range_beginning
expr_stmt|;
name|high
operator|=
name|range_end
expr_stmt|;
name|low_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|range_beginning
operator|<
name|low
condition|)
name|low
operator|=
name|range_beginning
expr_stmt|;
if|if
condition|(
name|range_end
operator|>
name|high
condition|)
name|high
operator|=
name|range_end
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|low_set
condition|)
comment|/* If the first entry is an end-of-list marker, the range 	       describes an empty scope, i.e. no instructions.  */
return|return
literal|0
return|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|high
operator|<
name|low
condition|)
return|return
literal|0
return|;
comment|/* When using the GNU linker, .gnu.linkonce. sections are used to      eliminate duplicate copies of functions and vtables and such.      The linker will arbitrarily choose one and discard the others.      The AT_*_pc values for such functions refer to local labels in      these sections.  If the section from that file was discarded, the      labels are not in the output, so the relocs get a value of 0.      If this is a discarded function, mark the pc bounds as invalid,      so that GDB will ignore it.  */
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|bfd_get_file_flags
argument_list|(
name|obfd
argument_list|)
operator|&
name|HAS_RELOC
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|lowpc
operator|=
name|low
expr_stmt|;
operator|*
name|highpc
operator|=
name|high
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get the low and high pc's represented by the scope DIE, and store    them in *LOWPC and *HIGHPC.  If the correct values can't be    determined, set *LOWPC to -1 and *HIGHPC to 0.  */
end_comment

begin_function
specifier|static
name|void
name|get_scope_pc_bounds
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|CORE_ADDR
modifier|*
name|lowpc
parameter_list|,
name|CORE_ADDR
modifier|*
name|highpc
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|CORE_ADDR
name|best_low
init|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|best_high
init|=
operator|(
name|CORE_ADDR
operator|)
literal|0
decl_stmt|;
name|CORE_ADDR
name|current_low
decl_stmt|,
name|current_high
decl_stmt|;
if|if
condition|(
name|dwarf2_get_pc_bounds
argument_list|(
name|die
argument_list|,
operator|&
name|current_low
argument_list|,
operator|&
name|current_high
argument_list|,
name|cu
argument_list|)
condition|)
block|{
name|best_low
operator|=
name|current_low
expr_stmt|;
name|best_high
operator|=
name|current_high
expr_stmt|;
block|}
else|else
block|{
name|struct
name|die_info
modifier|*
name|child
init|=
name|die
operator|->
name|child
decl_stmt|;
while|while
condition|(
name|child
operator|&&
name|child
operator|->
name|tag
condition|)
block|{
switch|switch
condition|(
name|child
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_subprogram
case|:
if|if
condition|(
name|dwarf2_get_pc_bounds
argument_list|(
name|child
argument_list|,
operator|&
name|current_low
argument_list|,
operator|&
name|current_high
argument_list|,
name|cu
argument_list|)
condition|)
block|{
name|best_low
operator|=
name|min
argument_list|(
name|best_low
argument_list|,
name|current_low
argument_list|)
expr_stmt|;
name|best_high
operator|=
name|max
argument_list|(
name|best_high
argument_list|,
name|current_high
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_namespace
case|:
comment|/* FIXME: carlton/2004-01-16: Should we do this for 	       DW_TAG_class_type/DW_TAG_structure_type, too?  I think 	       that current GCC's always emit the DIEs corresponding 	       to definitions of methods of classes as children of a 	       DW_TAG_compile_unit or DW_TAG_namespace (as opposed to 	       the DIEs giving the declarations, which could be 	       anywhere).  But I don't see any reason why the 	       standards says that they have to be there.  */
name|get_scope_pc_bounds
argument_list|(
name|child
argument_list|,
operator|&
name|current_low
argument_list|,
operator|&
name|current_high
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_low
operator|!=
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|best_low
operator|=
name|min
argument_list|(
name|best_low
argument_list|,
name|current_low
argument_list|)
expr_stmt|;
name|best_high
operator|=
name|max
argument_list|(
name|best_high
argument_list|,
name|current_high
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Ignore. */
break|break;
block|}
name|child
operator|=
name|sibling_die
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|lowpc
operator|=
name|best_low
expr_stmt|;
operator|*
name|highpc
operator|=
name|best_high
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an aggregate field to the field list.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_add_field
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new_field
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|field
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|fieldname
init|=
literal|""
decl_stmt|;
comment|/* Allocate a new field list entry and link it in.  */
name|new_field
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_field
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_field
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new_field
operator|->
name|next
operator|=
name|fip
operator|->
name|fields
expr_stmt|;
name|fip
operator|->
name|fields
operator|=
name|new_field
expr_stmt|;
name|fip
operator|->
name|nfields
operator|++
expr_stmt|;
comment|/* Handle accessibility and virtuality of field.      The default accessibility for members is public, the default      accessibility for inheritance is private.  */
if|if
condition|(
name|die
operator|->
name|tag
operator|!=
name|DW_TAG_inheritance
condition|)
name|new_field
operator|->
name|accessibility
operator|=
name|DW_ACCESS_public
expr_stmt|;
else|else
name|new_field
operator|->
name|accessibility
operator|=
name|DW_ACCESS_private
expr_stmt|;
name|new_field
operator|->
name|virtuality
operator|=
name|DW_VIRTUALITY_none
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|new_field
operator|->
name|accessibility
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_field
operator|->
name|accessibility
operator|!=
name|DW_ACCESS_public
condition|)
name|fip
operator|->
name|non_public_fields
operator|=
literal|1
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|new_field
operator|->
name|virtuality
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|&
name|new_field
operator|->
name|field
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_member
operator|&&
operator|!
name|die_is_declaration
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
condition|)
block|{
comment|/* Data member other than a C++ static data member.  */
comment|/* Get type of field.  */
name|fp
operator|->
name|type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|FIELD_STATIC_KIND
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Get bit size of field (zero if none).  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get bit offset of field.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_data_member_location
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|cu
argument_list|)
operator|*
name|bits_per_byte
expr_stmt|;
block|}
else|else
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_offset
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
comment|/* For big endian bits, the DW_AT_bit_offset gives the 	         additional bit offset from the MSB of the containing 	         anonymous object to the MSB of the field.  We don't 	         have to do anything special since we don't need to 	         know the size of the anonymous object.  */
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|+=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For little endian bits, compute the bit offset to the 	         MSB of the anonymous object, subtract off the number of 	         bits from the MSB of the field to the MSB of the 	         object, and then subtract off the number of bits of 	         the field itself.  The result is the bit offset of 	         the LSB of the field.  */
name|int
name|anonymous_size
decl_stmt|;
name|int
name|bit_offset
init|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
decl_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
comment|/* The size of the anonymous object containing 		     the bit field is explicit, so use the 		     indicated size (in bytes).  */
name|anonymous_size
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The size of the anonymous object containing 		     the bit field must be inferred from the type 		     attribute of the data member containing the 		     bit field.  */
name|anonymous_size
operator|=
name|TYPE_LENGTH
argument_list|(
name|fp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|+=
name|anonymous_size
operator|*
name|bits_per_byte
operator|-
name|bit_offset
operator|-
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get name of field.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
name|fieldname
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|fp
operator|->
name|name
operator|=
name|obsavestring
argument_list|(
name|fieldname
argument_list|,
name|strlen
argument_list|(
name|fieldname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
comment|/* Change accessibility for artificial fields (e.g. virtual table          pointer or virtual base class pointer) to private.  */
if|if
condition|(
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_artificial
argument_list|,
name|cu
argument_list|)
condition|)
block|{
name|new_field
operator|->
name|accessibility
operator|=
name|DW_ACCESS_private
expr_stmt|;
name|fip
operator|->
name|non_public_fields
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_member
operator|||
name|die
operator|->
name|tag
operator|==
name|DW_TAG_variable
condition|)
block|{
comment|/* C++ static member.  */
comment|/* NOTE: carlton/2002-11-05: It should be a DW_TAG_member that 	 is a declaration, but all versions of G++ as of this writing 	 (so through at least 3.2.1) incorrectly generate 	 DW_TAG_variable tags.  */
name|char
modifier|*
name|physname
decl_stmt|;
comment|/* Get name of field.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
name|fieldname
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* Get physical name.  */
name|physname
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|SET_FIELD_PHYSNAME
argument_list|(
operator|*
name|fp
argument_list|,
name|obsavestring
argument_list|(
name|physname
argument_list|,
name|strlen
argument_list|(
name|physname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|FIELD_NAME
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|fieldname
argument_list|,
name|strlen
argument_list|(
name|fieldname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_inheritance
condition|)
block|{
comment|/* C++ base class field.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_data_member_location
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
operator|(
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|cu
argument_list|)
operator|*
name|bits_per_byte
operator|)
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_STATIC_KIND
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|FIELD_NAME
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|type_name_no_tag
argument_list|(
name|fp
operator|->
name|type
argument_list|)
expr_stmt|;
name|fip
operator|->
name|nbaseclasses
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the vector of fields, and attach it to the type.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_attach_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|int
name|nfields
init|=
name|fip
operator|->
name|nfields
decl_stmt|;
comment|/* Record the field count, allocate space for the array of fields,      and create blank accessibility bitfields if necessary.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fip
operator|->
name|non_public_fields
condition|)
block|{
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
comment|/* If the type has baseclasses, allocate and clear a bit vector for      TYPE_FIELD_VIRTUAL_BITS.  */
if|if
condition|(
name|fip
operator|->
name|nbaseclasses
condition|)
block|{
name|int
name|num_bytes
init|=
name|B_BYTES
argument_list|(
name|fip
operator|->
name|nbaseclasses
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|pointer
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|fip
operator|->
name|nbaseclasses
argument_list|)
expr_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|fip
operator|->
name|nbaseclasses
expr_stmt|;
block|}
comment|/* Copy the saved-up fields into the field vector.  Start from the head      of the list, adding to the tail of the field array, so that they end      up in the same order in the array in which they were added to the list.  */
while|while
condition|(
name|nfields
operator|--
operator|>
literal|0
condition|)
block|{
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
name|fip
operator|->
name|fields
operator|->
name|field
expr_stmt|;
switch|switch
condition|(
name|fip
operator|->
name|fields
operator|->
name|accessibility
condition|)
block|{
case|case
name|DW_ACCESS_private
case|:
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_protected
case|:
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_public
case|:
break|break;
default|default:
comment|/* Unknown accessibility.  Complain and treat it as public.  */
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unsupported accessibility %d"
argument_list|,
name|fip
operator|->
name|fields
operator|->
name|accessibility
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|nfields
operator|<
name|fip
operator|->
name|nbaseclasses
condition|)
block|{
switch|switch
condition|(
name|fip
operator|->
name|fields
operator|->
name|virtuality
condition|)
block|{
case|case
name|DW_VIRTUALITY_virtual
case|:
case|case
name|DW_VIRTUALITY_pure_virtual
case|:
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fip
operator|->
name|fields
operator|=
name|fip
operator|->
name|fields
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a member function to the proper fieldlist.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_add_member_fn
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|fnfieldlist
modifier|*
name|flp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|fnp
decl_stmt|;
name|char
modifier|*
name|fieldname
decl_stmt|;
name|char
modifier|*
name|physname
decl_stmt|;
name|struct
name|nextfnfield
modifier|*
name|new_fnfield
decl_stmt|;
comment|/* Get name of member function.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
name|fieldname
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* Get the mangled name.  */
name|physname
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Look up member function name in fieldlist.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fip
operator|->
name|nfnfields
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fip
operator|->
name|fnfieldlists
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|fieldname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Create new list element if necessary.  */
if|if
condition|(
name|i
operator|<
name|fip
operator|->
name|nfnfields
condition|)
name|flp
operator|=
operator|&
name|fip
operator|->
name|fnfieldlists
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|fip
operator|->
name|nfnfields
operator|%
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|fip
operator|->
name|fnfieldlists
operator|=
operator|(
expr|struct
name|fnfieldlist
operator|*
operator|)
name|xrealloc
argument_list|(
name|fip
operator|->
name|fnfieldlists
argument_list|,
operator|(
name|fip
operator|->
name|nfnfields
operator|+
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fip
operator|->
name|nfnfields
operator|==
literal|0
condition|)
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|fip
operator|->
name|fnfieldlists
argument_list|)
expr_stmt|;
block|}
name|flp
operator|=
operator|&
name|fip
operator|->
name|fnfieldlists
index|[
name|fip
operator|->
name|nfnfields
index|]
expr_stmt|;
name|flp
operator|->
name|name
operator|=
name|fieldname
expr_stmt|;
name|flp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|flp
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|fip
operator|->
name|nfnfields
operator|++
expr_stmt|;
block|}
comment|/* Create a new member function field and chain it to the field list      entry. */
name|new_fnfield
operator|=
operator|(
expr|struct
name|nextfnfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfnfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_fnfield
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnfield
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfnfield
argument_list|)
argument_list|)
expr_stmt|;
name|new_fnfield
operator|->
name|next
operator|=
name|flp
operator|->
name|head
expr_stmt|;
name|flp
operator|->
name|head
operator|=
name|new_fnfield
expr_stmt|;
name|flp
operator|->
name|length
operator|++
expr_stmt|;
comment|/* Fill in the member function field info.  */
name|fnp
operator|=
operator|&
name|new_fnfield
operator|->
name|fnfield
expr_stmt|;
name|fnp
operator|->
name|physname
operator|=
name|obsavestring
argument_list|(
name|physname
argument_list|,
name|strlen
argument_list|(
name|physname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|fnp
operator|->
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|int
name|nparams
init|=
name|TYPE_NFIELDS
argument_list|(
name|die
operator|->
name|type
argument_list|)
decl_stmt|;
comment|/* TYPE is the domain of this method, and DIE->TYPE is the type 	   of the method itself (TYPE_CODE_METHOD).  */
name|smash_to_method_type
argument_list|(
name|fnp
operator|->
name|type
argument_list|,
name|type
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|die
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|die
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|die
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_VARARGS
argument_list|(
name|die
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle static member functions.          Dwarf2 has no clean way to discern C++ static and non-static          member functions. G++ helps GDB by marking the first          parameter for non-static member functions (which is the          this pointer) as artificial. We obtain this information          from read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
if|if
condition|(
name|nparams
operator|==
literal|0
operator|||
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|die
operator|->
name|type
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fnp
operator|->
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
block|}
else|else
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"member function type missing for '%s'"
argument_list|,
name|physname
argument_list|)
expr_stmt|;
comment|/* Get fcontext from DW_AT_containing_type if present.  */
if|if
condition|(
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|cu
argument_list|)
operator|!=
name|NULL
condition|)
name|fnp
operator|->
name|fcontext
operator|=
name|die_containing_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* dwarf2 doesn't have stubbed physical names, so the setting of is_const      and is_volatile is irrelevant, as it is needed by gdb_mangle_name only.  */
comment|/* Get accessibility.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
switch|switch
condition|(
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
condition|)
block|{
case|case
name|DW_ACCESS_private
case|:
name|fnp
operator|->
name|is_private
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_protected
case|:
name|fnp
operator|->
name|is_protected
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for artificial methods.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_artificial
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|!=
literal|0
condition|)
name|fnp
operator|->
name|is_artificial
operator|=
literal|1
expr_stmt|;
comment|/* Get index in virtual function table if it is a virtual member function.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_vtable_elem_location
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
comment|/* Support the .debug_loc offsets */
if|if
condition|(
name|attr_form_is_block
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|fnp
operator|->
name|voffset
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|cu
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data4
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data8
condition|)
block|{
name|dwarf2_complex_location_expr_complaint
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dwarf2_invalid_attrib_class_complaint
argument_list|(
literal|"DW_AT_vtable_elem_location"
argument_list|,
name|fieldname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create the vector of member function fields, and attach it to the type.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_attach_fn_fields_to_type
parameter_list|(
name|struct
name|field_info
modifier|*
name|fip
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|fnfieldlist
modifier|*
name|flp
decl_stmt|;
name|int
name|total_length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|fip
operator|->
name|nfnfields
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|flp
operator|=
name|fip
operator|->
name|fnfieldlists
init|;
name|i
operator|<
name|fip
operator|->
name|nfnfields
condition|;
name|i
operator|++
operator|,
name|flp
operator|++
control|)
block|{
name|struct
name|nextfnfield
modifier|*
name|nfp
init|=
name|flp
operator|->
name|head
decl_stmt|;
name|struct
name|fn_fieldlist
modifier|*
name|fn_flp
init|=
operator|&
name|TYPE_FN_FIELDLIST
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|flp
operator|->
name|name
expr_stmt|;
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|flp
operator|->
name|length
expr_stmt|;
name|fn_flp
operator|->
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|flp
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|flp
operator|->
name|length
init|;
operator|(
name|k
operator|--
operator|,
name|nfp
operator|)
condition|;
name|nfp
operator|=
name|nfp
operator|->
name|next
control|)
name|fn_flp
operator|->
name|fn_fields
index|[
name|k
index|]
operator|=
name|nfp
operator|->
name|fnfield
expr_stmt|;
name|total_length
operator|+=
name|flp
operator|->
name|length
expr_stmt|;
block|}
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|fip
operator|->
name|nfnfields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|total_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when we find the DIE that starts a structure or union scope    (definition) to process all dies that define the members of the    structure or union.     NOTE: we need to call struct_type regardless of whether or not the    DIE has an at_name attribute, since it might be an anonymous    structure or union.  This gets the type entered into our set of    user defined types.     However, if the structure is incomplete (an opaque struct/union)    then suppress creating a symbol table entry for it since gdb only    wants to find the one with the complete definition.  Note that if    it is complete, we just call new_symbol, which does it's own    checking about whether the struct/union is anonymous or not (and    suppresses creating a symbol table entry itself).  */
end_comment

begin_function
specifier|static
name|void
name|read_structure_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
specifier|const
name|char
modifier|*
name|previous_prefix
init|=
name|processing_current_prefix
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
return|return;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
block|{
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|)
block|{
name|char
modifier|*
name|new_prefix
init|=
name|determine_class_name
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|new_prefix
argument_list|,
name|strlen
argument_list|(
name|new_prefix
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_prefix
argument_list|)
expr_stmt|;
name|processing_current_prefix
operator|=
name|new_prefix
expr_stmt|;
block|}
else|else
block|{
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_structure_type
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_union_type
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: TYPE_CODE_CLASS is currently defined to TYPE_CODE_STRUCT          in gdbtypes.h.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_CLASS
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We need to add the type field to the die immediately so we don't      infinitely recurse when dealing with pointers to the structure      type within the structure itself. */
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
operator|&&
operator|!
name|die_is_declaration
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
condition|)
block|{
name|struct
name|field_info
name|fi
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field_info
argument_list|)
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_member
operator|||
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_variable
condition|)
block|{
comment|/* NOTE: carlton/2002-11-05: A C++ static data member 		 should be a DW_TAG_member that is a declaration, but 		 all versions of G++ as of this writing (so through at 		 least 3.2.1) incorrectly generate DW_TAG_variable 		 tags for them instead.  */
name|dwarf2_add_field
argument_list|(
operator|&
name|fi
argument_list|,
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
comment|/* C++ member function. */
name|read_type_die
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|dwarf2_add_member_fn
argument_list|(
operator|&
name|fi
argument_list|,
name|child_die
argument_list|,
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_inheritance
condition|)
block|{
comment|/* C++ base class field.  */
name|dwarf2_add_field
argument_list|(
operator|&
name|fi
argument_list|,
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
comment|/* Attach fields and member functions to the type.  */
if|if
condition|(
name|fi
operator|.
name|nfields
condition|)
name|dwarf2_attach_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|nfnfields
condition|)
block|{
name|dwarf2_attach_fn_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Get the type which refers to the base class (possibly this 	     class itself) which contains the vtable pointer for the current 	     class from the DW_AT_containing_type attribute.  */
if|if
condition|(
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|cu
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|die_containing_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|t
condition|)
block|{
specifier|static
specifier|const
name|char
name|vptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'v'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'\0'
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Our own class provides vtbl ptr.  */
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|--
name|i
control|)
block|{
name|char
modifier|*
name|fieldname
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|fieldname
argument_list|,
name|vptr_name
argument_list|,
name|strlen
argument_list|(
name|vptr_name
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|is_cplus_marker
argument_list|(
name|fieldname
index|[
name|strlen
argument_list|(
name|vptr_name
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Complain if virtual function table field not found.  */
if|if
condition|(
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"virtual function table pointer not found when defining class '%s'"
argument_list|,
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No children, must be stub. */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
block|}
name|processing_current_prefix
operator|=
name|previous_prefix
expr_stmt|;
if|if
condition|(
name|back_to
operator|!=
name|NULL
condition|)
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_structure_scope
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|previous_prefix
init|=
name|processing_current_prefix
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
init|=
name|die
operator|->
name|child
decl_stmt|;
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator|!=
name|NULL
condition|)
name|processing_current_prefix
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|die
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its      snapshots) has been known to create a die giving a declaration      for a class that has, as a child, a die giving a definition for a      nested class.  So we have to process our children even if the      current die is a declaration.  Normally, of course, a declaration      won't have any children at all.  */
while|while
condition|(
name|child_die
operator|!=
name|NULL
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_member
operator|||
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_variable
operator|||
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_inheritance
condition|)
block|{
comment|/* Do nothing.  */
block|}
else|else
name|process_die
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
operator|&&
operator|!
name|die_is_declaration
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
condition|)
name|new_symbol
argument_list|(
name|die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|processing_current_prefix
operator|=
name|previous_prefix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a DW_AT_enumeration_type die, set its type.  We do not    complete the type's fields yet, or create any symbols.  */
end_comment

begin_function
specifier|static
name|void
name|read_enumeration_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
return|return;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_has_namespace_info
condition|)
block|{
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|processing_current_prefix
argument_list|,
name|processing_current_prefix
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|""
else|:
literal|"::"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
block|}
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the name of the type represented by DIE, which should be    a named C++ compound type.  Return the name in question; the caller    is responsible for xfree()'ing it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|determine_class_name
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|NULL
decl_stmt|;
name|struct
name|die_info
modifier|*
name|spec_die
init|=
name|die_specification
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_prefix
init|=
name|NULL
decl_stmt|;
comment|/* If this is the definition of a class that is declared by another      die, then processing_current_prefix may not be accurate; see      read_func_scope for a similar example.  */
if|if
condition|(
name|spec_die
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|specification_prefix
init|=
name|determine_prefix
argument_list|(
name|spec_die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|processing_current_prefix
operator|=
name|specification_prefix
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|specification_prefix
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have namespace debug info, guess the name by trying      to demangle the names of members, just like we did in      add_partial_structure.  */
if|if
condition|(
operator|!
name|processing_has_namespace_info
condition|)
block|{
name|struct
name|die_info
modifier|*
name|child
decl_stmt|;
for|for
control|(
name|child
operator|=
name|die
operator|->
name|child
init|;
name|child
operator|!=
name|NULL
operator|&&
name|child
operator|->
name|tag
operator|!=
literal|0
condition|;
name|child
operator|=
name|sibling_die
argument_list|(
name|child
argument_list|)
control|)
block|{
if|if
condition|(
name|child
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|new_prefix
operator|=
name|class_name_from_physname
argument_list|(
name|dwarf2_linkage_name
argument_list|(
name|child
argument_list|,
name|cu
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_prefix
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|new_prefix
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|dwarf2_name
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|new_prefix
operator|=
name|typename_concat
argument_list|(
name|processing_current_prefix
argument_list|,
name|name
condition|?
name|name
else|:
literal|"<<anonymous>>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|back_to
operator|!=
name|NULL
condition|)
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
name|new_prefix
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a die which begins an enumeration, process all    the dies that define the members of the enumeration, and create the    symbol for the enumeration type.     NOTE: We reverse the order of the element list.  */
end_comment

begin_function
specifier|static
name|void
name|process_enumeration_scope
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|field
modifier|*
name|fields
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|num_fields
decl_stmt|;
name|int
name|unsigned_enum
init|=
literal|1
decl_stmt|;
name|num_fields
operator|=
literal|0
expr_stmt|;
name|fields
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|!=
name|DW_TAG_enumerator
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|sym
operator|=
name|new_symbol
argument_list|(
name|child_die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|<
literal|0
condition|)
name|unsigned_enum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|num_fields
operator|%
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|fields
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fields
argument_list|,
operator|(
name|num_fields
operator|+
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FIELD_NAME
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_STATIC_KIND
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|num_fields
operator|++
expr_stmt|;
block|}
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_fields
condition|)
block|{
name|TYPE_NFIELDS
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator|=
name|num_fields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|die
operator|->
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|num_fields
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|die
operator|->
name|type
argument_list|)
argument_list|,
name|fields
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|num_fields
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_enum
condition|)
name|TYPE_FLAGS
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
block|}
name|new_symbol
argument_list|(
name|die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_array_type DIE and put it in    the DIE's type field.  For now, this only handles one dimensional    arrays.  */
end_comment

begin_function
specifier|static
name|void
name|read_array_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|element_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|,
modifier|*
name|index_type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|range_types
init|=
name|NULL
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|int
name|ndim
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
comment|/* Return if we've already decoded this type. */
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|element_type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Irix 6.2 native cc creates array types without children for      arrays with unspecified length.  */
if|if
condition|(
name|die
operator|->
name|child
operator|==
name|NULL
condition|)
block|{
name|index_type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|index_type
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|create_array_type
argument_list|(
name|NULL
argument_list|,
name|element_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_subrange_type
condition|)
block|{
name|read_subrange_type
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_die
operator|->
name|type
operator|!=
name|NULL
condition|)
block|{
comment|/* The range type was succesfully read. Save it for                  the array type creation.  */
if|if
condition|(
operator|(
name|ndim
operator|%
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|range_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|range_types
argument_list|,
operator|(
name|ndim
operator|+
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndim
operator|==
literal|0
condition|)
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|range_types
argument_list|)
expr_stmt|;
block|}
name|range_types
index|[
name|ndim
operator|++
index|]
operator|=
name|child_die
operator|->
name|type
expr_stmt|;
block|}
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
comment|/* Dwarf2 dimensions are output from left to right, create the      necessary array types in backwards order.  */
name|type
operator|=
name|element_type
expr_stmt|;
while|while
condition|(
name|ndim
operator|--
operator|>
literal|0
condition|)
name|type
operator|=
name|create_array_type
argument_list|(
name|NULL
argument_list|,
name|type
argument_list|,
name|range_types
index|[
name|ndim
index|]
argument_list|)
expr_stmt|;
comment|/* Understand Dwarf2 support for vector types (like they occur on      the PowerPC w/ AltiVec).  Gcc just adds another attribute to the      array type.  This is not part of the Dwarf2/3 standard yet, but a      custom vendor extension.  The main difference between a regular      array and the vector variant is that vectors are passed by value      to functions.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_GNU_vector
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_VECTOR
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
comment|/* Install the type in the die. */
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* First cut: install each common block member as a global variable.  */
end_comment

begin_function
specifier|static
name|void
name|read_common_block
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|base
init|=
operator|(
name|CORE_ADDR
operator|)
literal|0
decl_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
comment|/* Support the .debug_loc offsets */
if|if
condition|(
name|attr_form_is_block
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|base
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data4
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data8
condition|)
block|{
name|dwarf2_complex_location_expr_complaint
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dwarf2_invalid_attrib_class_complaint
argument_list|(
literal|"DW_AT_location"
argument_list|,
literal|"common block member"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|sym
operator|=
name|new_symbol
argument_list|(
name|child_die
argument_list|,
name|NULL
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_data_member_location
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|base
operator|+
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a C++ namespace.  */
end_comment

begin_function
specifier|static
name|void
name|read_namespace
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|previous_prefix
init|=
name|processing_current_prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|is_anonymous
decl_stmt|;
name|struct
name|die_info
modifier|*
name|current_die
decl_stmt|;
name|name
operator|=
name|namespace_name
argument_list|(
name|die
argument_list|,
operator|&
name|is_anonymous
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Now build the name of the current namespace.  */
if|if
condition|(
name|previous_prefix
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|processing_current_prefix
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
comment|/* We need temp_name around because processing_current_prefix 	 is a const char *.  */
name|char
modifier|*
name|temp_name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|previous_prefix
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|previous_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|processing_current_prefix
operator|=
name|temp_name
expr_stmt|;
block|}
comment|/* Add a symbol associated to this if we haven't seen the namespace      before.  Also, add a using directive if it's an anonymous      namespace.  */
if|if
condition|(
name|dwarf2_extension
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* FIXME: carlton/2003-06-27: Once GDB is more const-correct, 	 this cast will hopefully become unnecessary.  */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|processing_current_prefix
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|new_symbol
argument_list|(
name|die
argument_list|,
name|type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|is_anonymous
condition|)
name|cp_add_using_directive
argument_list|(
name|processing_current_prefix
argument_list|,
name|strlen
argument_list|(
name|previous_prefix
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|processing_current_prefix
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|struct
name|die_info
modifier|*
name|child_die
init|=
name|die
operator|->
name|child
decl_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
name|processing_current_prefix
operator|=
name|previous_prefix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name of the namespace represented by DIE.  Set    *IS_ANONYMOUS to tell whether or not the namespace is an anonymous    namespace.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|namespace_name
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|int
modifier|*
name|is_anonymous
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|current_die
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
comment|/* Loop through the extensions until we find a name.  */
for|for
control|(
name|current_die
operator|=
name|die
init|;
name|current_die
operator|!=
name|NULL
condition|;
name|current_die
operator|=
name|dwarf2_extension
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
control|)
block|{
name|name
operator|=
name|dwarf2_name
argument_list|(
name|current_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* Is it an anonymous namespace?  */
operator|*
name|is_anonymous
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|is_anonymous
condition|)
name|name
operator|=
literal|"(anonymous namespace)"
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_pointer_type DIE and add to    the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_pointer_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr_byte_size
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr_address_class
decl_stmt|;
name|int
name|byte_size
decl_stmt|,
name|addr_class
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
argument_list|)
expr_stmt|;
name|attr_byte_size
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_byte_size
condition|)
name|byte_size
operator|=
name|DW_UNSND
argument_list|(
name|attr_byte_size
argument_list|)
expr_stmt|;
else|else
name|byte_size
operator|=
name|cu_header
operator|->
name|addr_size
expr_stmt|;
name|attr_address_class
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_address_class
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_address_class
condition|)
name|addr_class
operator|=
name|DW_UNSND
argument_list|(
name|attr_address_class
argument_list|)
expr_stmt|;
else|else
name|addr_class
operator|=
name|DW_ADDR_none
expr_stmt|;
comment|/* If the pointer size or address class is different than the      default, create a type variant marked as such and set the      length accordingly.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|!=
name|byte_size
operator|||
name|addr_class
operator|!=
name|DW_ADDR_none
condition|)
block|{
if|if
condition|(
name|ADDRESS_CLASS_TYPE_FLAGS_P
argument_list|()
condition|)
block|{
name|int
name|type_flags
decl_stmt|;
name|type_flags
operator|=
name|ADDRESS_CLASS_TYPE_FLAGS
argument_list|(
name|byte_size
argument_list|,
name|addr_class
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|(
name|type_flags
operator|&
operator|~
name|TYPE_FLAG_ADDRESS_CLASS_ALL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_type_with_address_space
argument_list|(
name|type
argument_list|,
name|type_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|!=
name|byte_size
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"invalid pointer size %d"
argument_list|,
name|byte_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Should we also complain about unhandled address classes?  */
block|}
block|}
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|byte_size
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_ptr_to_member_type DIE and add to    the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_ptr_to_member_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|to_type
decl_stmt|;
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|to_type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|domain
operator|=
name|die_containing_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|to_type
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_reference_type DIE and add to    the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_reference_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|lookup_reference_type
argument_list|(
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|cu_header
operator|->
name|addr_size
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_tag_const_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|base_type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|make_cv_type
argument_list|(
literal|1
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|base_type
argument_list|)
argument_list|,
name|base_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_tag_volatile_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|base_type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|make_cv_type
argument_list|(
name|TYPE_CONST
argument_list|(
name|base_type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|base_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_string_type DIE and add to    the user defined type vector.  It isn't really a user defined type,    but it behaves like one, with other DIE's using an AT_user_def_type    attribute to reference it.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_string_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|,
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|char_type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_string_length
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|length
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* check for the DW_AT_byte_size attribute */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|length
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|index_type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|index_type
argument_list|,
literal|1
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_fortran
condition|)
block|{
comment|/* Need to create a unique string type for bounds          information */
name|type
operator|=
name|create_string_type
argument_list|(
literal|0
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char_type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_CHAR
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_string_type
argument_list|(
name|char_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle DIES due to C code like:     struct foo    {    int (*funcp)(int a, long l);    int b;    };     ('funcp' generates a DW_TAG_subroutine_type DIE)  */
end_comment

begin_function
specifier|static
name|void
name|read_subroutine_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Type that this function returns */
name|struct
name|type
modifier|*
name|ftype
decl_stmt|;
comment|/* Function that returns above type */
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
comment|/* Decode the type that this subroutine returns */
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* All functions in C++ have prototypes.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_prototyped
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attr
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|||
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|)
name|TYPE_FLAGS
argument_list|(
name|ftype
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|int
name|nparams
init|=
literal|0
decl_stmt|;
name|int
name|iparams
init|=
literal|0
decl_stmt|;
comment|/* Count the number of parameters.          FIXME: GDB currently ignores vararg functions, but knows about          vararg member functions.  */
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_formal_parameter
condition|)
name|nparams
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_unspecified_parameters
condition|)
name|TYPE_FLAGS
argument_list|(
name|ftype
argument_list|)
operator||=
name|TYPE_FLAG_VARARGS
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate storage for parameters and fill them in.  */
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|nparams
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|ftype
argument_list|,
name|nparams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|die
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_formal_parameter
condition|)
block|{
comment|/* Dwarf2 has no clean way to discern C++ static and non-static 	         member functions. G++ helps GDB by marking the first 	         parameter for non-static member functions (which is the 	         this pointer) as artificial. We pass this information 	         to dwarf2_add_member_fn via TYPE_FIELD_ARTIFICIAL.  */
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_artificial
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
else|else
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
name|die_type
argument_list|(
name|child_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|iparams
operator|++
expr_stmt|;
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
name|die
operator|->
name|type
operator|=
name|ftype
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_typedef
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|type
condition|)
block|{
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|name
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_TYPEDEF
argument_list|,
literal|0
argument_list|,
name|TYPE_FLAG_TARGET_STUB
argument_list|,
name|name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find a representation of a given base type and install    it in the TYPE field of the die.  */
end_comment

begin_function
specifier|static
name|void
name|read_base_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|int
name|encoding
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
comment|/* If we've already decoded this die, this is a no-op. */
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_encoding
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|encoding
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|size
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE_INT
decl_stmt|;
name|int
name|type_flags
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|DW_ATE_address
case|:
comment|/* Turn DW_ATE_address into a void * pointer.  */
name|code
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
name|type_flags
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
break|break;
case|case
name|DW_ATE_boolean
case|:
name|code
operator|=
name|TYPE_CODE_BOOL
expr_stmt|;
name|type_flags
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
break|break;
case|case
name|DW_ATE_complex_float
case|:
name|code
operator|=
name|TYPE_CODE_COMPLEX
expr_stmt|;
break|break;
case|case
name|DW_ATE_float
case|:
name|code
operator|=
name|TYPE_CODE_FLT
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed
case|:
case|case
name|DW_ATE_signed_char
case|:
break|break;
case|case
name|DW_ATE_unsigned
case|:
case|case
name|DW_ATE_unsigned_char
case|:
name|type_flags
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unsupported DW_AT_encoding: '%s'"
argument_list|,
name|dwarf_type_encoding_name
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|init_type
argument_list|(
name|code
argument_list|,
name|size
argument_list|,
name|type_flags
argument_list|,
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|==
name|DW_ATE_address
condition|)
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|,
name|cu
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|encoding
operator|==
name|DW_ATE_complex_float
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|32
condition|)
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_EXT_PREC_FLOAT
argument_list|,
name|cu
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|16
condition|)
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|,
name|cu
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_FLOAT
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|dwarf_base_type
argument_list|(
name|encoding
argument_list|,
name|size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the given DW_AT_subrange DIE.  */
end_comment

begin_function
specifier|static
name|void
name|read_subrange_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If we have already decoded this die, then nothing more to do.  */
if|if
condition|(
name|die
operator|->
name|type
condition|)
return|return;
name|base_type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_type
operator|==
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"DW_AT_type missing from DW_TAG_subrange_type"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|base_type
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|base_type
operator|=
name|alloc_type
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_fortran
condition|)
block|{
comment|/* FORTRAN implies a lower bound of 1, if not given.  */
name|low
operator|=
literal|1
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_lower_bound
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|low
operator|=
name|dwarf2_get_attr_constant_value
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_upper_bound
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_block1
condition|)
block|{
comment|/* GCC encodes arrays with unspecified or dynamic length              with a DW_FORM_block1 attribute.              FIXME: GDB does not yet know how to handle dynamic              arrays properly, treat them as arrays with unspecified              length for now.               FIXME: jimb/2003-09-22: GDB does not really know              how to handle arrays of unspecified length              either; we just represent them as zero-length              arrays.  Choose an appropriate upper bound given              the lower bound we've computed above.  */
name|high
operator|=
name|low
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|high
operator|=
name|dwarf2_get_attr_constant_value
argument_list|(
name|attr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|range_type
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|base_type
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|range_type
argument_list|)
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|TYPE_LENGTH
argument_list|(
name|range_type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|range_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a whole compilation unit into a linked list of dies.  */
end_comment

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|read_comp_unit
parameter_list|(
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
comment|/* Reset die reference table; we are      building new ones now.  */
name|dwarf2_empty_hash_tables
argument_list|()
expr_stmt|;
return|return
name|read_die_and_children
argument_list|(
name|info_ptr
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|,
operator|&
name|info_ptr
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a single die and all its descendents.  Set the die's sibling    field to NULL; set other fields in the die correctly, and set all    of the descendents' fields correctly.  Set *NEW_INFO_PTR to the    location of the info_ptr after reading all of those dies.  PARENT    is the parent of the die in question.  */
end_comment

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|read_die_and_children
parameter_list|(
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
name|char
modifier|*
modifier|*
name|new_info_ptr
parameter_list|,
name|struct
name|die_info
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|char
modifier|*
name|cur_ptr
decl_stmt|;
name|int
name|has_children
decl_stmt|;
name|cur_ptr
operator|=
name|read_full_die
argument_list|(
operator|&
name|die
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|,
operator|&
name|has_children
argument_list|)
expr_stmt|;
name|store_in_ref_table
argument_list|(
name|die
operator|->
name|offset
argument_list|,
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_children
condition|)
block|{
name|die
operator|->
name|child
operator|=
name|read_die_and_siblings
argument_list|(
name|cur_ptr
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|,
name|new_info_ptr
argument_list|,
name|die
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|die
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
operator|*
name|new_info_ptr
operator|=
name|cur_ptr
expr_stmt|;
block|}
name|die
operator|->
name|sibling
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
return|return
name|die
return|;
block|}
end_function

begin_comment
comment|/* Read a die, all of its descendents, and all of its siblings; set    all of the fields of all of the dies correctly.  Arguments are as    in read_die_and_children.  */
end_comment

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|read_die_and_siblings
parameter_list|(
name|char
modifier|*
name|info_ptr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
name|char
modifier|*
modifier|*
name|new_info_ptr
parameter_list|,
name|struct
name|die_info
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|first_die
decl_stmt|,
modifier|*
name|last_sibling
decl_stmt|;
name|char
modifier|*
name|cur_ptr
decl_stmt|;
name|cur_ptr
operator|=
name|info_ptr
expr_stmt|;
name|first_die
operator|=
name|last_sibling
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|die_info
modifier|*
name|die
init|=
name|read_die_and_children
argument_list|(
name|cur_ptr
argument_list|,
name|abfd
argument_list|,
name|cu
argument_list|,
operator|&
name|cur_ptr
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|first_die
condition|)
block|{
name|first_die
operator|=
name|die
expr_stmt|;
block|}
else|else
block|{
name|last_sibling
operator|->
name|sibling
operator|=
name|die
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|tag
operator|==
literal|0
condition|)
block|{
operator|*
name|new_info_ptr
operator|=
name|cur_ptr
expr_stmt|;
return|return
name|first_die
return|;
block|}
else|else
block|{
name|last_sibling
operator|=
name|die
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free a linked list of dies.  */
end_comment

begin_function
specifier|static
name|void
name|free_die_list
parameter_list|(
name|struct
name|die_info
modifier|*
name|dies
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|die
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|die
operator|=
name|dies
expr_stmt|;
while|while
condition|(
name|die
condition|)
block|{
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
name|free_die_list
argument_list|(
name|die
operator|->
name|child
argument_list|)
expr_stmt|;
name|next
operator|=
name|die
operator|->
name|sibling
expr_stmt|;
name|xfree
argument_list|(
name|die
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|die
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_die_list_cleanup
parameter_list|(
name|void
modifier|*
name|dies
parameter_list|)
block|{
name|free_die_list
argument_list|(
name|dies
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_die_list
parameter_list|(
name|struct
name|die_info
modifier|*
name|dies
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_die_list_cleanup
argument_list|,
name|dies
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of the section at OFFSET and of size SIZE from the    object file specified by OBJFILE into the objfile_obstack and return it.  */
end_comment

begin_function
name|char
modifier|*
name|dwarf2_read_section
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|asection
modifier|*
name|sectp
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|retbuf
decl_stmt|;
name|bfd_size_type
name|size
init|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|retbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|symfile_relocate_debug_section
argument_list|(
name|abfd
argument_list|,
name|sectp
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retbuf
operator|!=
name|NULL
condition|)
return|return
name|retbuf
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sectp
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
name|error
argument_list|(
literal|"Dwarf Error: Can't read DWARF data from '%s'"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* In DWARF version 2, the description of the debugging information is    stored in a separate .debug_abbrev section.  Before we read any    dies from a section we read in all abbreviations and install them    in a hash table.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_read_abbrevs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|char
modifier|*
name|abbrev_ptr
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|cur_abbrev
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|abbrev_name
decl_stmt|;
name|unsigned
name|int
name|abbrev_form
decl_stmt|,
name|hash_number
decl_stmt|;
comment|/* Initialize dwarf2 abbrevs */
name|memset
argument_list|(
name|cu_header
operator|->
name|dwarf2_abbrevs
argument_list|,
literal|0
argument_list|,
name|ABBREV_HASH_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|=
name|dwarf_abbrev_buffer
operator|+
name|cu_header
operator|->
name|abbrev_offset
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* loop until we reach an abbrev number of 0 */
while|while
condition|(
name|abbrev_number
condition|)
block|{
name|cur_abbrev
operator|=
name|dwarf_alloc_abbrev
argument_list|()
expr_stmt|;
comment|/* read in abbrev header */
name|cur_abbrev
operator|->
name|number
operator|=
name|abbrev_number
expr_stmt|;
name|cur_abbrev
operator|->
name|tag
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|cur_abbrev
operator|->
name|has_children
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* now read in declarations */
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
while|while
condition|(
name|abbrev_name
condition|)
block|{
if|if
condition|(
operator|(
name|cur_abbrev
operator|->
name|num_attrs
operator|%
name|ATTR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|cur_abbrev
operator|->
name|attrs
operator|=
operator|(
expr|struct
name|attr_abbrev
operator|*
operator|)
name|xrealloc
argument_list|(
name|cur_abbrev
operator|->
name|attrs
argument_list|,
operator|(
name|cur_abbrev
operator|->
name|num_attrs
operator|+
name|ATTR_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|attr_abbrev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
index|]
operator|.
name|name
operator|=
name|abbrev_name
expr_stmt|;
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
operator|++
index|]
operator|.
name|form
operator|=
name|abbrev_form
expr_stmt|;
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
name|hash_number
operator|=
name|abbrev_number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|cur_abbrev
operator|->
name|next
operator|=
name|cu_header
operator|->
name|dwarf2_abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
name|cu_header
operator|->
name|dwarf2_abbrevs
index|[
name|hash_number
index|]
operator|=
name|cur_abbrev
expr_stmt|;
comment|/* Get next abbreviation.          Under Irix6 the abbreviations for a compilation unit are not          always properly terminated with an abbrev number of 0.          Exit loop if we encounter an abbreviation which we have          already read (which means we are about to read the abbreviations          for the next compile unit) or if the end of the abbreviation          table is reached.  */
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|abbrev_ptr
operator|-
name|dwarf_abbrev_buffer
argument_list|)
operator|>=
name|dwarf_abbrev_size
condition|)
break|break;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|dwarf2_lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|cu
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Empty the abbrev table for a new compilation unit.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_empty_abbrev_table
parameter_list|(
name|void
modifier|*
name|ptr_to_abbrevs_table
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
name|abbrevs
operator|=
operator|(
expr|struct
name|abbrev_info
operator|*
operator|*
operator|)
name|ptr_to_abbrevs_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ABBREV_HASH_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
name|NULL
expr_stmt|;
name|abbrev
operator|=
name|abbrevs
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
name|next
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|abbrev
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|abbrev
argument_list|)
expr_stmt|;
name|abbrev
operator|=
name|next
expr_stmt|;
block|}
name|abbrevs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lookup an abbrev_info structure in the abbrev hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf2_lookup_abbrev
parameter_list|(
name|unsigned
name|int
name|number
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|unsigned
name|int
name|hash_number
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|hash_number
operator|=
name|number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrev
operator|=
name|cu_header
operator|->
name|dwarf2_abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
if|if
condition|(
name|abbrev
operator|->
name|number
operator|==
name|number
condition|)
return|return
name|abbrev
return|;
else|else
name|abbrev
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Read a minimal amount of information into the minimal die structure.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_partial_die
parameter_list|(
name|struct
name|partial_die_info
modifier|*
name|part_die
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|struct
name|attribute
name|spec_attr
decl_stmt|;
name|int
name|found_spec_attr
init|=
literal|0
decl_stmt|;
name|int
name|has_low_pc_attr
init|=
literal|0
decl_stmt|;
name|int
name|has_high_pc_attr
init|=
literal|0
decl_stmt|;
operator|*
name|part_die
operator|=
name|zeroed_partial_die
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
return|return
name|info_ptr
return|;
name|abbrev
operator|=
name|dwarf2_lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %d [in module %s]"
argument_list|,
name|abbrev_number
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|part_die
operator|->
name|offset
operator|=
name|info_ptr
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|part_die
operator|->
name|tag
operator|=
name|abbrev
operator|->
name|tag
expr_stmt|;
name|part_die
operator|->
name|has_children
operator|=
name|abbrev
operator|->
name|has_children
expr_stmt|;
name|part_die
operator|->
name|abbrev
operator|=
name|abbrev_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* Store the data if it is of an attribute we want to keep in a          partial symbol table.  */
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
comment|/* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
if|if
condition|(
name|part_die
operator|->
name|name
operator|==
name|NULL
condition|)
name|part_die
operator|->
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_MIPS_linkage_name
case|:
name|part_die
operator|->
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|has_low_pc_attr
operator|=
literal|1
expr_stmt|;
name|part_die
operator|->
name|lowpc
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|has_high_pc_attr
operator|=
literal|1
expr_stmt|;
name|part_die
operator|->
name|highpc
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_location
case|:
comment|/* Support the .debug_loc offsets */
if|if
condition|(
name|attr_form_is_block
argument_list|(
operator|&
name|attr
argument_list|)
condition|)
block|{
name|part_die
operator|->
name|locdesc
operator|=
name|DW_BLOCK
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|form
operator|==
name|DW_FORM_data4
operator|||
name|attr
operator|.
name|form
operator|==
name|DW_FORM_data8
condition|)
block|{
name|dwarf2_complex_location_expr_complaint
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dwarf2_invalid_attrib_class_complaint
argument_list|(
literal|"DW_AT_location"
argument_list|,
literal|"partial symbol information"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_AT_language
case|:
name|part_die
operator|->
name|language
operator|=
name|DW_UNSND
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_external
case|:
name|part_die
operator|->
name|is_external
operator|=
name|DW_UNSND
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_declaration
case|:
name|part_die
operator|->
name|is_declaration
operator|=
name|DW_UNSND
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_type
case|:
name|part_die
operator|->
name|has_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_AT_abstract_origin
case|:
case|case
name|DW_AT_specification
case|:
name|found_spec_attr
operator|=
literal|1
expr_stmt|;
name|spec_attr
operator|=
name|attr
expr_stmt|;
break|break;
case|case
name|DW_AT_sibling
case|:
comment|/* Ignore absolute siblings, they might point outside of 	     the current compile unit.  */
if|if
condition|(
name|attr
operator|.
name|form
operator|==
name|DW_FORM_ref_addr
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"ignoring absolute DW_AT_sibling"
argument_list|)
expr_stmt|;
else|else
name|part_die
operator|->
name|sibling
operator|=
name|dwarf_info_buffer
operator|+
name|dwarf2_get_ref_die_offset
argument_list|(
operator|&
name|attr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If we found a reference attribute and the die has no name, try      to find a name in the referred to die.  */
if|if
condition|(
name|found_spec_attr
operator|&&
name|part_die
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|struct
name|partial_die_info
name|spec_die
decl_stmt|;
name|char
modifier|*
name|spec_ptr
decl_stmt|;
name|spec_ptr
operator|=
name|dwarf_info_buffer
operator|+
name|dwarf2_get_ref_die_offset
argument_list|(
operator|&
name|spec_attr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|read_partial_die
argument_list|(
operator|&
name|spec_die
argument_list|,
name|abfd
argument_list|,
name|spec_ptr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_die
operator|.
name|name
condition|)
block|{
name|part_die
operator|->
name|name
operator|=
name|spec_die
operator|.
name|name
expr_stmt|;
comment|/* Copy DW_AT_external attribute if it is set.  */
if|if
condition|(
name|spec_die
operator|.
name|is_external
condition|)
name|part_die
operator|->
name|is_external
operator|=
name|spec_die
operator|.
name|is_external
expr_stmt|;
block|}
block|}
comment|/* When using the GNU linker, .gnu.linkonce. sections are used to      eliminate duplicate copies of functions and vtables and such.      The linker will arbitrarily choose one and discard the others.      The AT_*_pc values for such functions refer to local labels in      these sections.  If the section from that file was discarded, the      labels are not in the output, so the relocs get a value of 0.      If this is a discarded function, mark the pc bounds as invalid,      so that GDB will ignore it.  */
if|if
condition|(
name|has_low_pc_attr
operator|&&
name|has_high_pc_attr
operator|&&
name|part_die
operator|->
name|lowpc
operator|<
name|part_die
operator|->
name|highpc
operator|&&
operator|(
name|part_die
operator|->
name|lowpc
operator|!=
literal|0
operator|||
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|HAS_RELOC
operator|)
operator|)
condition|)
name|part_die
operator|->
name|has_pc_info
operator|=
literal|1
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read the die from the .debug_info section buffer.  Set DIEP to    point to a newly allocated die with its information, except for its    child, sibling, and parent fields.  Set HAS_CHILDREN to tell    whether the die has children or not.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_full_die
parameter_list|(
name|struct
name|die_info
modifier|*
modifier|*
name|diep
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
name|int
modifier|*
name|has_children
parameter_list|)
block|{
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|offset
operator|=
name|info_ptr
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
name|die
operator|=
name|dwarf_alloc_die
argument_list|()
expr_stmt|;
name|die
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
name|die
operator|->
name|abbrev
operator|=
name|abbrev_number
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
operator|*
name|diep
operator|=
name|die
expr_stmt|;
operator|*
name|has_children
operator|=
literal|0
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
name|abbrev
operator|=
name|dwarf2_lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: could not find abbrev number %d [in module %s]"
argument_list|,
name|abbrev_number
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|die
operator|=
name|dwarf_alloc_die
argument_list|()
expr_stmt|;
name|die
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|die
operator|->
name|tag
operator|=
name|abbrev
operator|->
name|tag
expr_stmt|;
name|die
operator|->
name|abbrev
operator|=
name|abbrev_number
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|num_attrs
operator|=
name|abbrev
operator|->
name|num_attrs
expr_stmt|;
name|die
operator|->
name|attrs
operator|=
operator|(
expr|struct
name|attribute
operator|*
operator|)
name|xmalloc
argument_list|(
name|die
operator|->
name|num_attrs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
operator|*
name|diep
operator|=
name|die
expr_stmt|;
operator|*
name|has_children
operator|=
name|abbrev
operator|->
name|has_children
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute value described by an attribute form.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_attribute_value
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|unsigned
name|form
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|attr
operator|->
name|form
operator|=
name|form
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
case|case
name|DW_FORM_ref_addr
case|:
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
operator|=
name|read_address
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data2
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_data4
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_data8
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|DW_STRING
argument_list|(
name|attr
argument_list|)
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
name|DW_STRING
argument_list|(
name|attr
argument_list|)
operator|=
name|read_indirect_string
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu_header
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|DW_SND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_udata
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref2
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref4
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref8
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_udata
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_indirect
case|:
name|form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|info_ptr
operator|=
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|form
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Dwarf Error: Cannot handle %s in DWARF reader [in module %s]"
argument_list|,
name|dwarf_form_name
argument_list|(
name|form
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute described by an abbreviated attribute.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_attribute
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|attr_abbrev
modifier|*
name|abbrev
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|attr
operator|->
name|name
operator|=
name|abbrev
operator|->
name|name
expr_stmt|;
return|return
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|abbrev
operator|->
name|form
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|cu
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* read dwarf information from a buffer */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_1_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_1_signed_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_signed_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_2_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_2_signed_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_4_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_4_signed_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|read_8_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|read_address
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
block|{
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|CORE_ADDR
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cu_header
operator|->
name|signed_addr_p
condition|)
block|{
switch|switch
condition|(
name|cu_header
operator|->
name|addr_size
condition|)
block|{
case|case
literal|2
case|:
name|retval
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|retval
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|retval
operator|=
name|bfd_get_signed_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_address: bad switch, signed [in module %s]"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|cu_header
operator|->
name|addr_size
condition|)
block|{
case|case
literal|2
case|:
name|retval
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|retval
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|retval
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_address: bad switch, unsigned [in module %s]"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|bytes_read
operator|=
name|cu_header
operator|->
name|addr_size
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Read the initial length from a section.  The (draft) DWARF 3    specification allows the initial length to take up either 4 bytes    or 12 bytes.  If the first 4 bytes are 0xffffffff, then the next 8    bytes describe the length and all offsets will be 8 bytes in length    instead of 4.     An older, non-standard 64-bit format is also handled by this    function.  The older format in question stores the initial length    as an 8-byte quantity without an escape value.  Lengths greater    than 2^32 aren't very common which means that the initial 4 bytes    is almost always zero.  Since a length value of zero doesn't make    sense for the 32-bit format, this initial zero can be considered to    be an escape value which indicates the presence of the older 64-bit    format.  As written, the code can't detect (old format) lengths    greater than 4GB.  If it becomes necessary to handle lengths somewhat    larger than 4GB, we could allow other small values (such as the    non-sensical values of 1, 2, and 3) to also be used as escape values    indicating the presence of the old format.     The value returned via bytes_read should be used to increment    the relevant pointer after calling read_initial_length().        As a side effect, this function sets the fields initial_length_size    and offset_size in cu_header to the values appropriate for the    length field.  (The format of the initial length field determines    the width of file offsets to be fetched later with fetch_offset().)        [ Note:  read_initial_length() and read_offset() are based on the      document entitled "DWARF Debugging Information Format", revision      3, draft 8, dated November 19, 2001.  This document was obtained      from:  	http://reality.sgiweb.org/davea/dwarf3-draft8-011125.pdf            This document is only a draft and is subject to change.  (So beware.)       Details regarding the older, non-standard 64-bit format were      determined empirically by examining 64-bit ELF files produced      by the SGI toolchain on an IRIX 6.5 machine.       - Kevin, July 16, 2002    ] */
end_comment

begin_function
specifier|static
name|LONGEST
name|read_initial_length
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|struct
name|comp_unit_head
modifier|*
name|cu_header
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
block|{
name|LONGEST
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0xffffffff
condition|)
block|{
name|retval
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|bytes_read
operator|=
literal|12
expr_stmt|;
if|if
condition|(
name|cu_header
operator|!=
name|NULL
condition|)
block|{
name|cu_header
operator|->
name|initial_length_size
operator|=
literal|12
expr_stmt|;
name|cu_header
operator|->
name|offset_size
operator|=
literal|8
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* Handle (non-standard) 64-bit DWARF2 formats such as that used          by IRIX.  */
name|retval
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bytes_read
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|cu_header
operator|!=
name|NULL
condition|)
block|{
name|cu_header
operator|->
name|initial_length_size
operator|=
literal|8
expr_stmt|;
name|cu_header
operator|->
name|offset_size
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|bytes_read
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|cu_header
operator|!=
name|NULL
condition|)
block|{
name|cu_header
operator|->
name|initial_length_size
operator|=
literal|4
expr_stmt|;
name|cu_header
operator|->
name|offset_size
operator|=
literal|4
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Read an offset from the data stream.  The size of the offset is    given by cu_header->offset_size. */
end_comment

begin_function
specifier|static
name|LONGEST
name|read_offset
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|comp_unit_head
modifier|*
name|cu_header
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
block|{
name|LONGEST
name|retval
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cu_header
operator|->
name|offset_size
condition|)
block|{
case|case
literal|4
case|:
name|retval
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bytes_read
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|retval
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bytes_read
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_offset: bad switch [in module %s]"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_n_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
comment|/* If the size of a host char is 8 bits, we can return a pointer      to the buffer, otherwise we have to copy the data to a buffer      allocated on the temporary obstack.  */
name|gdb_assert
argument_list|(
name|HOST_CHAR_BIT
operator|==
literal|8
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
comment|/* If the size of a host char is 8 bits, we can return a pointer      to the string, otherwise we have to copy the string to a buffer      allocated on the temporary obstack.  */
name|gdb_assert
argument_list|(
name|HOST_CHAR_BIT
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|bytes_read_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_indirect_string
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|comp_unit_head
modifier|*
name|cu_header
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|LONGEST
name|str_offset
init|=
name|read_offset
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|cu_header
argument_list|,
operator|(
name|int
operator|*
operator|)
name|bytes_read_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dwarf_str_buffer
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"DW_FORM_strp used without .debug_str section [in module %s]"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|str_offset
operator|>=
name|dwarf_str_size
condition|)
block|{
name|error
argument_list|(
literal|"DW_FORM_strp pointing outside of .debug_str section [in module %s]"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|gdb_assert
argument_list|(
name|HOST_CHAR_BIT
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_str_buffer
index|[
name|str_offset
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|dwarf_str_buffer
operator|+
name|str_offset
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|read_unsigned_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|unsigned
name|long
name|result
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|byte
operator|&
literal|127
argument_list|)
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|128
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|read_signed_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|long
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|,
name|size
decl_stmt|,
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|32
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
call|(
name|long
call|)
argument_list|(
name|byte
operator|&
literal|127
argument_list|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|128
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|shift
operator|<
name|size
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
block|{
name|result
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_cu_language
parameter_list|(
name|unsigned
name|int
name|lang
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
switch|switch
condition|(
name|lang
condition|)
block|{
case|case
name|DW_LANG_C89
case|:
case|case
name|DW_LANG_C
case|:
name|cu
operator|->
name|language
operator|=
name|language_c
expr_stmt|;
break|break;
case|case
name|DW_LANG_C_plus_plus
case|:
name|cu
operator|->
name|language
operator|=
name|language_cplus
expr_stmt|;
break|break;
case|case
name|DW_LANG_Fortran77
case|:
case|case
name|DW_LANG_Fortran90
case|:
case|case
name|DW_LANG_Fortran95
case|:
name|cu
operator|->
name|language
operator|=
name|language_fortran
expr_stmt|;
break|break;
case|case
name|DW_LANG_Mips_Assembler
case|:
name|cu
operator|->
name|language
operator|=
name|language_asm
expr_stmt|;
break|break;
case|case
name|DW_LANG_Java
case|:
name|cu
operator|->
name|language
operator|=
name|language_java
expr_stmt|;
break|break;
case|case
name|DW_LANG_Ada83
case|:
case|case
name|DW_LANG_Ada95
case|:
case|case
name|DW_LANG_Cobol74
case|:
case|case
name|DW_LANG_Cobol85
case|:
case|case
name|DW_LANG_Pascal83
case|:
case|case
name|DW_LANG_Modula2
case|:
default|default:
name|cu
operator|->
name|language
operator|=
name|language_minimal
expr_stmt|;
break|break;
block|}
name|cu
operator|->
name|language_defn
operator|=
name|language_def
argument_list|(
name|cu
operator|->
name|language
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the named attribute or NULL if not there.  */
end_comment

begin_function
specifier|static
name|struct
name|attribute
modifier|*
name|dwarf2_attr
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|unsigned
name|int
name|name
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|attribute
modifier|*
name|spec
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|die
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|name
condition|)
block|{
return|return
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
return|;
block|}
if|if
condition|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|DW_AT_specification
operator|||
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|DW_AT_abstract_origin
condition|)
name|spec
operator|=
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|spec
condition|)
block|{
name|struct
name|die_info
modifier|*
name|ref_die
init|=
name|follow_die_ref
argument_list|(
name|dwarf2_get_ref_die_offset
argument_list|(
name|spec
argument_list|,
name|cu
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref_die
condition|)
return|return
name|dwarf2_attr
argument_list|(
name|ref_die
argument_list|,
name|name
argument_list|,
name|cu
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|die_is_declaration
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
return|return
operator|(
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_declaration
argument_list|,
name|cu
argument_list|)
operator|&&
operator|!
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_specification
argument_list|,
name|cu
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the die giving the specification for DIE, if there is    one.  */
end_comment

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|die_specification
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|attribute
modifier|*
name|spec_attr
init|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_specification
argument_list|,
name|cu
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec_attr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|follow_die_ref
argument_list|(
name|dwarf2_get_ref_die_offset
argument_list|(
name|spec_attr
argument_list|,
name|cu
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free the line_header structure *LH, and any arrays and strings it    refers to.  */
end_comment

begin_function
specifier|static
name|void
name|free_line_header
parameter_list|(
name|struct
name|line_header
modifier|*
name|lh
parameter_list|)
block|{
if|if
condition|(
name|lh
operator|->
name|standard_opcode_lengths
condition|)
name|xfree
argument_list|(
name|lh
operator|->
name|standard_opcode_lengths
argument_list|)
expr_stmt|;
comment|/* Remember that all the lh->file_names[i].name pointers are      pointers into debug_line_buffer, and don't need to be freed.  */
if|if
condition|(
name|lh
operator|->
name|file_names
condition|)
name|xfree
argument_list|(
name|lh
operator|->
name|file_names
argument_list|)
expr_stmt|;
comment|/* Similarly for the include directory names.  */
if|if
condition|(
name|lh
operator|->
name|include_dirs
condition|)
name|xfree
argument_list|(
name|lh
operator|->
name|include_dirs
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|lh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an entry to LH's include directory table.  */
end_comment

begin_function
specifier|static
name|void
name|add_include_dir
parameter_list|(
name|struct
name|line_header
modifier|*
name|lh
parameter_list|,
name|char
modifier|*
name|include_dir
parameter_list|)
block|{
comment|/* Grow the array if necessary.  */
if|if
condition|(
name|lh
operator|->
name|include_dirs_size
operator|==
literal|0
condition|)
block|{
name|lh
operator|->
name|include_dirs_size
operator|=
literal|1
expr_stmt|;
comment|/* for testing */
name|lh
operator|->
name|include_dirs
operator|=
name|xmalloc
argument_list|(
name|lh
operator|->
name|include_dirs_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lh
operator|->
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lh
operator|->
name|num_include_dirs
operator|>=
name|lh
operator|->
name|include_dirs_size
condition|)
block|{
name|lh
operator|->
name|include_dirs_size
operator|*=
literal|2
expr_stmt|;
name|lh
operator|->
name|include_dirs
operator|=
name|xrealloc
argument_list|(
name|lh
operator|->
name|include_dirs
argument_list|,
operator|(
name|lh
operator|->
name|include_dirs_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lh
operator|->
name|include_dirs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|lh
operator|->
name|include_dirs
index|[
name|lh
operator|->
name|num_include_dirs
operator|++
index|]
operator|=
name|include_dir
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an entry to LH's file name table.  */
end_comment

begin_function
specifier|static
name|void
name|add_file_name
parameter_list|(
name|struct
name|line_header
modifier|*
name|lh
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|dir_index
parameter_list|,
name|unsigned
name|int
name|mod_time
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|struct
name|file_entry
modifier|*
name|fe
decl_stmt|;
comment|/* Grow the array if necessary.  */
if|if
condition|(
name|lh
operator|->
name|file_names_size
operator|==
literal|0
condition|)
block|{
name|lh
operator|->
name|file_names_size
operator|=
literal|1
expr_stmt|;
comment|/* for testing */
name|lh
operator|->
name|file_names
operator|=
name|xmalloc
argument_list|(
name|lh
operator|->
name|file_names_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lh
operator|->
name|file_names
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lh
operator|->
name|num_file_names
operator|>=
name|lh
operator|->
name|file_names_size
condition|)
block|{
name|lh
operator|->
name|file_names_size
operator|*=
literal|2
expr_stmt|;
name|lh
operator|->
name|file_names
operator|=
name|xrealloc
argument_list|(
name|lh
operator|->
name|file_names
argument_list|,
operator|(
name|lh
operator|->
name|file_names_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lh
operator|->
name|file_names
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|fe
operator|=
operator|&
name|lh
operator|->
name|file_names
index|[
name|lh
operator|->
name|num_file_names
operator|++
index|]
expr_stmt|;
name|fe
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|fe
operator|->
name|dir_index
operator|=
name|dir_index
expr_stmt|;
name|fe
operator|->
name|mod_time
operator|=
name|mod_time
expr_stmt|;
name|fe
operator|->
name|length
operator|=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the statement program header starting at OFFSET in    dwarf_line_buffer, according to the endianness of ABFD.  Return a    pointer to a struct line_header, allocated using xmalloc.     NOTE: the strings in the include directory and file name tables of    the returned object point into debug_line_buffer, and must not be    freed.  */
end_comment

begin_function
specifier|static
name|struct
name|line_header
modifier|*
name|dwarf_decode_line_header
parameter_list|(
name|unsigned
name|int
name|offset
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|struct
name|line_header
modifier|*
name|lh
decl_stmt|;
name|char
modifier|*
name|line_ptr
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cur_dir
decl_stmt|,
modifier|*
name|cur_file
decl_stmt|;
if|if
condition|(
name|dwarf_line_buffer
operator|==
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"missing .debug_line section"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Make sure that at least there's room for the total_length field.  That      could be 12 bytes long, but we're just going to fudge that.  */
if|if
condition|(
name|offset
operator|+
literal|4
operator|>=
name|dwarf_line_size
condition|)
block|{
name|dwarf2_statement_list_fits_in_line_number_section_complaint
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lh
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lh
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lh
argument_list|)
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_ftype
operator|*
operator|)
name|free_line_header
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lh
argument_list|)
expr_stmt|;
name|line_ptr
operator|=
name|dwarf_line_buffer
operator|+
name|offset
expr_stmt|;
comment|/* read in the header */
name|lh
operator|->
name|total_length
operator|=
name|read_initial_length
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
name|NULL
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|line_ptr
operator|+
name|lh
operator|->
name|total_length
operator|>
name|dwarf_line_buffer
operator|+
name|dwarf_line_size
condition|)
block|{
name|dwarf2_statement_list_fits_in_line_number_section_complaint
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lh
operator|->
name|statement_program_end
operator|=
name|line_ptr
operator|+
name|lh
operator|->
name|total_length
expr_stmt|;
name|lh
operator|->
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
name|lh
operator|->
name|header_length
operator|=
name|read_offset
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|cu
operator|->
name|header
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|lh
operator|->
name|minimum_instruction_length
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|->
name|default_is_stmt
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|->
name|line_base
operator|=
name|read_1_signed_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|->
name|line_range
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|->
name|opcode_base
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|->
name|standard_opcode_lengths
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|lh
operator|->
name|opcode_base
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|lh
operator|->
name|standard_opcode_lengths
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* This should never be used anyway.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lh
operator|->
name|opcode_base
condition|;
operator|++
name|i
control|)
block|{
name|lh
operator|->
name|standard_opcode_lengths
index|[
name|i
index|]
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Read directory table  */
while|while
condition|(
operator|(
name|cur_dir
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|add_include_dir
argument_list|(
name|lh
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read file name table */
while|while
condition|(
operator|(
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|dir_index
decl_stmt|,
name|mod_time
decl_stmt|,
name|length
decl_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|dir_index
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|mod_time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|length
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|add_file_name
argument_list|(
name|lh
argument_list|,
name|cur_file
argument_list|,
name|dir_index
argument_list|,
name|mod_time
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|lh
operator|->
name|statement_program_start
operator|=
name|line_ptr
expr_stmt|;
if|if
condition|(
name|line_ptr
operator|>
name|dwarf_line_buffer
operator|+
name|dwarf_line_size
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"line number info header doesn't fit in `.debug_line' section"
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
name|lh
return|;
block|}
end_function

begin_comment
comment|/* This function exists to work around a bug in certain compilers    (particularly GCC 2.95), in which the first line number marker of a    function does not show up until after the prologue, right before    the second line number marker.  This function shifts ADDRESS down    to the beginning of the function if necessary, and is called on    addresses passed to record_line.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|check_cu_functions
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|function_range
modifier|*
name|fn
decl_stmt|;
comment|/* Find the function_range containing address.  */
if|if
condition|(
operator|!
name|cu
operator|->
name|first_fn
condition|)
return|return
name|address
return|;
if|if
condition|(
operator|!
name|cu
operator|->
name|cached_fn
condition|)
name|cu
operator|->
name|cached_fn
operator|=
name|cu
operator|->
name|first_fn
expr_stmt|;
name|fn
operator|=
name|cu
operator|->
name|cached_fn
expr_stmt|;
while|while
condition|(
name|fn
condition|)
if|if
condition|(
name|fn
operator|->
name|lowpc
operator|<=
name|address
operator|&&
name|fn
operator|->
name|highpc
operator|>
name|address
condition|)
goto|goto
name|found
goto|;
else|else
name|fn
operator|=
name|fn
operator|->
name|next
expr_stmt|;
name|fn
operator|=
name|cu
operator|->
name|first_fn
expr_stmt|;
while|while
condition|(
name|fn
operator|&&
name|fn
operator|!=
name|cu
operator|->
name|cached_fn
condition|)
if|if
condition|(
name|fn
operator|->
name|lowpc
operator|<=
name|address
operator|&&
name|fn
operator|->
name|highpc
operator|>
name|address
condition|)
goto|goto
name|found
goto|;
else|else
name|fn
operator|=
name|fn
operator|->
name|next
expr_stmt|;
return|return
name|address
return|;
name|found
label|:
if|if
condition|(
name|fn
operator|->
name|seen_line
condition|)
return|return
name|address
return|;
if|if
condition|(
name|address
operator|!=
name|fn
operator|->
name|lowpc
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"misplaced first line number at 0x%lx for '%s'"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fn
operator|->
name|seen_line
operator|=
literal|1
expr_stmt|;
return|return
name|fn
operator|->
name|lowpc
return|;
block|}
end_function

begin_comment
comment|/* Decode the line number information for the compilation unit whose    line number info is at OFFSET in the .debug_line section.    The compilation directory of the file is passed in COMP_DIR.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf_decode_lines
parameter_list|(
name|struct
name|line_header
modifier|*
name|lh
parameter_list|,
name|char
modifier|*
name|comp_dir
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|char
modifier|*
name|line_ptr
decl_stmt|;
name|char
modifier|*
name|line_end
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|char
name|op_code
decl_stmt|,
name|extended_op
decl_stmt|,
name|adj_opcode
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|line_ptr
operator|=
name|lh
operator|->
name|statement_program_start
expr_stmt|;
name|line_end
operator|=
name|lh
operator|->
name|statement_program_end
expr_stmt|;
comment|/* Read the statement sequences until there's nothing left.  */
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
comment|/* state machine registers  */
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|file
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|line
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|column
init|=
literal|0
decl_stmt|;
name|int
name|is_stmt
init|=
name|lh
operator|->
name|default_is_stmt
decl_stmt|;
name|int
name|basic_block
init|=
literal|0
decl_stmt|;
name|int
name|end_sequence
init|=
literal|0
decl_stmt|;
comment|/* Start a subfile for the current file of the state machine.  */
if|if
condition|(
name|lh
operator|->
name|num_file_names
operator|>=
name|file
condition|)
block|{
comment|/* lh->include_dirs and lh->file_names are 0-based, but the 	     directory and file name numbers in the statement program 	     are 1-based.  */
name|struct
name|file_entry
modifier|*
name|fe
init|=
operator|&
name|lh
operator|->
name|file_names
index|[
name|file
operator|-
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
name|fe
operator|->
name|dir_index
condition|)
name|dir
operator|=
name|lh
operator|->
name|include_dirs
index|[
name|fe
operator|->
name|dir_index
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|dir
operator|=
name|comp_dir
expr_stmt|;
name|dwarf2_start_subfile
argument_list|(
name|fe
operator|->
name|name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* Decode the table. */
while|while
condition|(
operator|!
name|end_sequence
condition|)
block|{
name|op_code
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|op_code
operator|>=
name|lh
operator|->
name|opcode_base
condition|)
block|{
comment|/* Special operand.  */
name|adj_opcode
operator|=
name|op_code
operator|-
name|lh
operator|->
name|opcode_base
expr_stmt|;
name|address
operator|+=
operator|(
name|adj_opcode
operator|/
name|lh
operator|->
name|line_range
operator|)
operator|*
name|lh
operator|->
name|minimum_instruction_length
expr_stmt|;
name|line
operator|+=
name|lh
operator|->
name|line_base
operator|+
operator|(
name|adj_opcode
operator|%
name|lh
operator|->
name|line_range
operator|)
expr_stmt|;
comment|/* append row to matrix using current values */
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|line
argument_list|,
name|check_cu_functions
argument_list|(
name|address
argument_list|,
name|cu
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|1
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNS_extended_op
case|:
name|line_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* ignore length */
name|extended_op
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|extended_op
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|end_sequence
operator|=
literal|1
expr_stmt|;
name|record_line
argument_list|(
name|current_subfile
argument_list|,
literal|0
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|address
operator|=
name|read_address
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
name|cu
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|address
operator|+=
name|baseaddr
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
block|{
name|char
modifier|*
name|cur_file
decl_stmt|;
name|unsigned
name|int
name|dir_index
decl_stmt|,
name|mod_time
decl_stmt|,
name|length
decl_stmt|;
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|dir_index
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|mod_time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|length
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|add_file_name
argument_list|(
name|lh
argument_list|,
name|cur_file
argument_list|,
name|dir_index
argument_list|,
name|mod_time
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"mangled .debug_line section"
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|DW_LNS_copy
case|:
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|line
argument_list|,
name|check_cu_functions
argument_list|(
name|address
argument_list|,
name|cu
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|address
operator|+=
name|lh
operator|->
name|minimum_instruction_length
operator|*
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|line
operator|+=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
block|{
comment|/* lh->include_dirs and lh->file_names are 0-based,                    but the directory and file name numbers in the                    statement program are 1-based.  */
name|struct
name|file_entry
modifier|*
name|fe
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|file
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|fe
operator|=
operator|&
name|lh
operator|->
name|file_names
index|[
name|file
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|fe
operator|->
name|dir_index
condition|)
name|dir
operator|=
name|lh
operator|->
name|include_dirs
index|[
name|fe
operator|->
name|dir_index
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|dir
operator|=
name|comp_dir
expr_stmt|;
name|dwarf2_start_subfile
argument_list|(
name|fe
operator|->
name|name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_LNS_set_column
case|:
name|column
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|is_stmt
operator|=
operator|(
operator|!
name|is_stmt
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
name|basic_block
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Add to the address register of the state machine the 	       address increment value corresponding to special opcode 	       255.  Ie, this value is scaled by the minimum instruction 	       length since special opcode 255 would have scaled the 	       the increment.  */
case|case
name|DW_LNS_const_add_pc
case|:
name|address
operator|+=
operator|(
name|lh
operator|->
name|minimum_instruction_length
operator|*
operator|(
operator|(
literal|255
operator|-
name|lh
operator|->
name|opcode_base
operator|)
operator|/
name|lh
operator|->
name|line_range
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|address
operator|+=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
block|{
comment|/* Unknown standard opcode, ignore it.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lh
operator|->
name|standard_opcode_lengths
index|[
name|op_code
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Start a subfile for DWARF.  FILENAME is the name of the file and    DIRNAME the name of the source directory which contains FILENAME    or NULL if not known.    This routine tries to keep line numbers from identical absolute and    relative file names in a common subfile.     Using the `list' example from the GDB testsuite, which resides in    /srcdir and compiling it with Irix6.2 cc in /compdir using a filename    of /srcdir/list0.c yields the following debugging information for list0.c:     DW_AT_name:          /srcdir/list0.c    DW_AT_comp_dir:              /compdir    files.files[0].name: list0.h    files.files[0].dir:  /srcdir    files.files[1].name: list0.c    files.files[1].dir:  /srcdir     The line number information for list0.c has to end up in a single    subfile, so that `break /srcdir/list0.c:1' works as expected.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_start_subfile
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|)
block|{
comment|/* If the filename isn't absolute, try to match an existing subfile      with the full pathname.  */
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|filename
argument_list|)
operator|&&
name|dirname
operator|!=
name|NULL
condition|)
block|{
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|char
modifier|*
name|fullname
init|=
name|concat
argument_list|(
name|dirname
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|subfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|subfile
operator|->
name|name
argument_list|,
name|fullname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_subfile
operator|=
name|subfile
expr_stmt|;
name|xfree
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|xfree
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
name|start_subfile
argument_list|(
name|filename
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|var_decode_location
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
comment|/* NOTE drow/2003-01-30: There used to be a comment and some special      code here to turn a symbol with DW_AT_external and a      SYMBOL_VALUE_ADDRESS of 0 into a LOC_UNRESOLVED symbol.  This was      necessary for platforms (maybe Alpha, certainly PowerPC GNU/Linux      with some versions of binutils) where shared libraries could have      relocations against symbols in their debug information - the      minimal symbol would have the right address, but the debug info      would not.  It's no longer necessary, because we will explicitly      apply relocations when we read in the debug information now.  */
comment|/* A DW_AT_location attribute with no contents indicates that a      variable has been optimized away.  */
if|if
condition|(
name|attr_form_is_block
argument_list|(
name|attr
argument_list|)
operator|&&
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_OPTIMIZED_OUT
expr_stmt|;
return|return;
block|}
comment|/* Handle one degenerate form of location expression specially, to      preserve GDB's previous behavior when section offsets are      specified.  If this is just a DW_OP_addr then mark this symbol      as LOC_STATIC.  */
if|if
condition|(
name|attr_form_is_block
argument_list|(
name|attr
argument_list|)
operator|&&
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|->
name|size
operator|==
literal|1
operator|+
name|cu_header
operator|->
name|addr_size
operator|&&
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|==
name|DW_OP_addr
condition|)
block|{
name|int
name|dummy
decl_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|read_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|->
name|data
operator|+
literal|1
argument_list|,
name|cu
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|fixup_symbol_section
argument_list|(
name|sym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SYMBOL_SECTION
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
return|return;
block|}
comment|/* NOTE drow/2002-01-30: It might be worthwhile to have a static      expression evaluator, and use LOC_COMPUTED only when necessary      (i.e. when the value of a register or memory location is      referenced, or a thread-local block, etc.).  Then again, it might      not be worthwhile.  I'm assuming that it isn't unless performance      or memory numbers show me otherwise.  */
name|dwarf2_symbol_mark_computed
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_COMPUTED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a DWARF information entry, figure out if we need    to make a symbol table entry for it, and if so, create a new entry    and return a pointer to it.    If TYPE is NULL, determine symbol type from the die, otherwise    used the passed type.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
init|=
name|NULL
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr2
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|tag
operator|!=
name|DW_TAG_namespace
condition|)
name|name
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_syms
operator|++
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cache this symbol's name and the name's demangled form (if any).  */
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|cu
operator|->
name|language
expr_stmt|;
name|SYMBOL_SET_NAMES
argument_list|(
name|sym
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Default assumptions.          Use the passed type or decode it from the die.  */
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|die
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_label
case|:
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
operator|+
name|baseaddr
expr_stmt|;
block|}
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
break|break;
case|case
name|DW_TAG_subprogram
case|:
comment|/* SYMBOL_BLOCK_VALUE (sym) will be filled in later by 	     finish_block.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|attr2
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|cu
operator|->
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_variable
case|:
comment|/* Compilation with minimal debug info may result in variables 	     with missing type entries. Change the misleading `void' type 	     to something sensible.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<variable, no debug info>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|dwarf2_const_value
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|attr2
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|cu
operator|->
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|var_decode_location
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|attr2
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|cu
operator|->
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We do not know the address of this symbol. 	         If it is an external symbol and we have type information 	         for it, enter the symbol as a LOC_UNRESOLVED symbol. 	         The address of the variable will then be determined from 	         the minimal symbol table whenever the variable is 	         referenced.  */
name|attr2
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_type
argument_list|,
name|cu
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_UNRESOLVED
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_TAG_formal_parameter
case|:
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|var_decode_location
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|cu
argument_list|)
expr_stmt|;
comment|/* FIXME drow/2003-07-31: Is LOC_COMPUTED_ARG necessary?  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_COMPUTED
condition|)
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_COMPUTED_ARG
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|dwarf2_const_value
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|cu
operator|->
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_unspecified_parameters
case|:
comment|/* From varargs functions; gdb doesn't seem to have any 	     interest in this information, so just ignore it for now. 	     (FIXME?) */
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_DOMAIN
expr_stmt|;
comment|/* Make sure that the symbol includes appropriate enclosing 	     classes/namespaces in its name.  These are calculated in 	     read_structure_type, and the correct name is saved in 	     the type.  */
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: carlton/2003-11-10: Should this use 		     SYMBOL_SET_NAMES instead?  (The same problem also 		     arises a further down in the function.)  */
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|/* NOTE: carlton/2003-11-10: C++ class symbols shouldn't 	       really ever be static objects: otherwise, if you try 	       to, say, break of a class's method and you're in a file 	       which doesn't mention that class, it won't work unless 	       the check for all static symbols in lookup_symbol_aux 	       saves you.  See the OtherFileClass tests in 	       gdb.c++/namespace.exp.  */
name|struct
name|pending
modifier|*
modifier|*
name|list_to_add
decl_stmt|;
name|list_to_add
operator|=
operator|(
name|cu
operator|->
name|list_in_scope
operator|==
operator|&
name|file_symbols
operator|&&
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|?
operator|&
name|global_symbols
else|:
name|cu
operator|->
name|list_in_scope
operator|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_to_add
argument_list|)
expr_stmt|;
comment|/* The semantics of C++ state that "struct foo { ... }" also 	       defines a typedef for "foo". Synthesize a typedef symbol so 	       that "ptype foo" works as expected.  */
if|if
condition|(
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|)
block|{
name|struct
name|symbol
modifier|*
name|typedef_sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|typedef_sym
operator|=
operator|*
name|sym
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|typedef_sym
argument_list|,
name|list_to_add
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_TAG_typedef
case|:
if|if
condition|(
name|processing_has_namespace_info
operator|&&
name|processing_current_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|processing_current_prefix
argument_list|,
literal|"::"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|cu
operator|->
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_base_type
case|:
case|case
name|DW_TAG_subrange_type
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|cu
operator|->
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_enumerator
case|:
if|if
condition|(
name|processing_has_namespace_info
operator|&&
name|processing_current_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|processing_current_prefix
argument_list|,
literal|"::"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|dwarf2_const_value
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* NOTE: carlton/2003-11-10: See comment above in the 	       DW_TAG_class_type, etc. block.  */
name|struct
name|pending
modifier|*
modifier|*
name|list_to_add
decl_stmt|;
name|list_to_add
operator|=
operator|(
name|cu
operator|->
name|list_in_scope
operator|==
operator|&
name|file_symbols
operator|&&
name|cu
operator|->
name|language
operator|==
name|language_cplus
condition|?
operator|&
name|global_symbols
else|:
name|cu
operator|->
name|list_in_scope
operator|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_to_add
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_namespace
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Not a tag we recognize.  Hopefully we aren't processing 	     trash data, but since we must specifically ignore things 	     we don't recognize, there is nothing else we should do at 	     this point. */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unsupported tag: '%s'"
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy constant value from an attribute to a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_const_value
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|cu_header
operator|->
name|addr_size
condition|)
name|dwarf2_const_value_length_mismatch_complaint
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|cu_header
operator|->
name|addr_size
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|cu_header
operator|->
name|addr_size
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2003-05-09: In-lined store_address call with          it's body - store_unsigned_integer.  */
name|store_unsigned_integer
argument_list|(
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
argument_list|,
name|cu_header
operator|->
name|addr_size
argument_list|,
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
case|case
name|DW_FORM_block2
case|:
case|case
name|DW_FORM_block4
case|:
case|case
name|DW_FORM_block
case|:
name|blk
operator|=
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|blk
operator|->
name|size
condition|)
name|dwarf2_const_value_length_mismatch_complaint
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|blk
operator|->
name|size
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
argument_list|,
name|blk
operator|->
name|data
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
break|break;
comment|/* The DW_AT_const_value attributes are supposed to carry the 	 symbol's value "represented as it would be on the target 	 architecture."  By the time we get here, it's already been 	 converted to host endianness, so we just need to sign- or 	 zero-extend it as appropriate.  */
case|case
name|DW_FORM_data1
case|:
name|dwarf2_const_value_data
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_data2
case|:
name|dwarf2_const_value_data
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_data4
case|:
name|dwarf2_const_value_data
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_data8
case|:
name|dwarf2_const_value_data
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
literal|64
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|DW_SND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
break|break;
case|case
name|DW_FORM_udata
case|:
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unsupported const value attribute form: '%s'"
argument_list|,
name|dwarf_form_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given an attr with a DW_FORM_dataN value in host byte order, sign-    or zero-extend it as appropriate for the symbol's type.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_const_value_data
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|LONGEST
name|l
init|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
decl_stmt|;
if|if
condition|(
name|bits
operator|<
sizeof|sizeof
argument_list|(
name|l
argument_list|)
operator|*
literal|8
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|l
operator|&=
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|l
operator|=
operator|(
name|l
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|l
argument_list|)
operator|*
literal|8
operator|-
name|bits
operator|)
operator|)
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|l
argument_list|)
operator|*
literal|8
operator|-
name|bits
operator|)
expr_stmt|;
block|}
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|l
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type of the die in question using its DW_AT_type attribute.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|die_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|type_attr
decl_stmt|;
name|struct
name|die_info
modifier|*
name|type_die
decl_stmt|;
name|unsigned
name|int
name|ref
decl_stmt|;
name|type_attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_attr
condition|)
block|{
comment|/* A missing DW_AT_type represents a void type.  */
return|return
name|dwarf2_fundamental_type
argument_list|(
name|cu
operator|->
name|objfile
argument_list|,
name|FT_VOID
argument_list|,
name|cu
argument_list|)
return|;
block|}
else|else
block|{
name|ref
operator|=
name|dwarf2_get_ref_die_offset
argument_list|(
name|type_attr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|type_die
operator|=
name|follow_die_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: Cannot find referent at offset %d [in module %s]"
argument_list|,
name|ref
argument_list|,
name|cu
operator|->
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|type
operator|=
name|tag_type_to_type
argument_list|(
name|type_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|dump_die
argument_list|(
name|type_die
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Dwarf Error: Problem turning type die at offset into gdb type [in module %s]"
argument_list|,
name|cu
operator|->
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return the containing type of the die in question using its    DW_AT_containing_type attribute.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|die_containing_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|struct
name|attribute
modifier|*
name|type_attr
decl_stmt|;
name|struct
name|die_info
modifier|*
name|type_die
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|ref
decl_stmt|;
name|type_attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_attr
condition|)
block|{
name|ref
operator|=
name|dwarf2_get_ref_die_offset
argument_list|(
name|type_attr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|type_die
operator|=
name|follow_die_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: Cannot find referent at offset %d [in module %s]"
argument_list|,
name|ref
argument_list|,
name|cu
operator|->
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|type
operator|=
name|tag_type_to_type
argument_list|(
name|type_die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|type
condition|)
block|{
if|if
condition|(
name|type_die
condition|)
name|dump_die
argument_list|(
name|type_die
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Dwarf Error: Problem turning containing type into gdb type [in module %s]"
argument_list|,
name|cu
operator|->
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type * type_at_offset (unsigned int offset, struct dwarf2_cu *cu) {   struct die_info *die;   struct type *type;    die = follow_die_ref (offset);   if (!die)     {       error ("Dwarf Error: Cannot find type referent at offset %d.", offset);       return NULL;     }   type = tag_type_to_type (die, cu);   return type; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|type
modifier|*
name|tag_type_to_type
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return
name|die
operator|->
name|type
return|;
block|}
else|else
block|{
name|read_type_die
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|type
condition|)
block|{
name|dump_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Dwarf Error: Cannot find type of die [in module %s]"
argument_list|,
name|cu
operator|->
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|die
operator|->
name|type
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|read_type_die
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|char
modifier|*
name|prefix
init|=
name|determine_prefix
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_prefix
init|=
name|processing_current_prefix
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|processing_current_prefix
operator|=
name|prefix
expr_stmt|;
switch|switch
condition|(
name|die
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
name|read_structure_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_enumeration_type
case|:
name|read_enumeration_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_subprogram
case|:
case|case
name|DW_TAG_subroutine_type
case|:
name|read_subroutine_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_array_type
case|:
name|read_array_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_pointer_type
case|:
name|read_tag_pointer_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_ptr_to_member_type
case|:
name|read_tag_ptr_to_member_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_reference_type
case|:
name|read_tag_reference_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_const_type
case|:
name|read_tag_const_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_volatile_type
case|:
name|read_tag_volatile_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_string_type
case|:
name|read_tag_string_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_typedef
case|:
name|read_typedef
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_subrange_type
case|:
name|read_subrange_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_base_type
case|:
name|read_base_type
argument_list|(
name|die
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unexepected tag in read_type_die: '%s'"
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|processing_current_prefix
operator|=
name|old_prefix
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name of the namespace/class that DIE is defined within,    or "" if we can't tell.  The caller should xfree the result.  */
end_comment

begin_comment
comment|/* NOTE: carlton/2004-01-23: See read_func_scope (and the comment    therein) for an example of how to use this function to deal with    DW_AT_specification.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|determine_prefix
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|cu
operator|->
name|language
operator|!=
name|language_cplus
condition|)
return|return
name|NULL
return|;
name|parent
operator|=
name|die
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
return|return
name|xstrdup
argument_list|(
literal|""
argument_list|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|parent
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_namespace
case|:
block|{
comment|/* FIXME: carlton/2004-03-05: Should I follow extension dies 	     before doing this check?  */
if|if
condition|(
name|parent
operator|->
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_TAG_NAME
argument_list|(
name|parent
operator|->
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
name|xstrdup
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|parent
operator|->
name|type
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|dummy
decl_stmt|;
name|char
modifier|*
name|parent_prefix
init|=
name|determine_prefix
argument_list|(
name|parent
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|char
modifier|*
name|retval
init|=
name|typename_concat
argument_list|(
name|parent_prefix
argument_list|,
name|namespace_name
argument_list|(
name|parent
argument_list|,
operator|&
name|dummy
argument_list|,
name|cu
argument_list|)
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
name|parent_prefix
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
block|{
if|if
condition|(
name|parent
operator|->
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_TAG_NAME
argument_list|(
name|parent
operator|->
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
name|xstrdup
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|parent
operator|->
name|type
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|old_prefix
init|=
name|processing_current_prefix
decl_stmt|;
name|char
modifier|*
name|new_prefix
init|=
name|determine_prefix
argument_list|(
name|parent
argument_list|,
name|cu
argument_list|)
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|processing_current_prefix
operator|=
name|new_prefix
expr_stmt|;
name|retval
operator|=
name|determine_class_name
argument_list|(
name|parent
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|processing_current_prefix
operator|=
name|old_prefix
expr_stmt|;
name|xfree
argument_list|(
name|new_prefix
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
default|default:
return|return
name|determine_prefix
argument_list|(
name|parent
argument_list|,
name|cu
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a newly-allocated string formed by concatenating PREFIX,    "::", and SUFFIX, except that if PREFIX is NULL or the empty    string, just return a copy of SUFFIX.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|typename_concat
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|==
name|NULL
operator|||
name|prefix
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|xstrdup
argument_list|(
name|suffix
argument_list|)
return|;
else|else
block|{
name|char
modifier|*
name|retval
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|retval
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|retval
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|retval
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dwarf_base_type
parameter_list|(
name|int
name|encoding
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
comment|/* FIXME - this should not produce a new (struct type *)      every time.  It should cache base types.  */
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|DW_ATE_address
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|DW_ATE_boolean
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_BOOLEAN
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|DW_ATE_complex_float
case|:
if|if
condition|(
name|size
operator|==
literal|16
condition|)
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_COMPLEX
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_COMPLEX
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_float
case|:
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_FLOAT
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_signed
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_CHAR
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_SHORT
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|4
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_INTEGER
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_signed_char
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_CHAR
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|DW_ATE_unsigned
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_SHORT
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|4
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_unsigned_char
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|type
return|;
default|default:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_INTEGER
argument_list|,
name|cu
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct die_info * copy_die (struct die_info *old_die) {   struct die_info *new_die;   int i, num_attrs;    new_die = (struct die_info *) xmalloc (sizeof (struct die_info));   memset (new_die, 0, sizeof (struct die_info));    new_die->tag = old_die->tag;   new_die->has_children = old_die->has_children;   new_die->abbrev = old_die->abbrev;   new_die->offset = old_die->offset;   new_die->type = NULL;    num_attrs = old_die->num_attrs;   new_die->num_attrs = num_attrs;   new_die->attrs = (struct attribute *)     xmalloc (num_attrs * sizeof (struct attribute));    for (i = 0; i< old_die->num_attrs; ++i)     {       new_die->attrs[i].name = old_die->attrs[i].name;       new_die->attrs[i].form = old_die->attrs[i].form;       new_die->attrs[i].u.addr = old_die->attrs[i].u.addr;     }    new_die->next = NULL;   return new_die; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return sibling of die, NULL if no sibling.  */
end_comment

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|sibling_die
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|)
block|{
return|return
name|die
operator|->
name|sibling
return|;
block|}
end_function

begin_comment
comment|/* Get linkage name of a die, return NULL if not found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf2_linkage_name
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_MIPS_linkage_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
return|return
name|DW_STRING
argument_list|(
name|attr
argument_list|)
return|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
return|return
name|DW_STRING
argument_list|(
name|attr
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Get name of a die, return NULL if not found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf2_name
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
return|return
name|DW_STRING
argument_list|(
name|attr
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the die that this die in an extension of, or NULL if there    is none.  */
end_comment

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|dwarf2_extension
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|die_info
modifier|*
name|extension_die
decl_stmt|;
name|unsigned
name|int
name|ref
decl_stmt|;
name|attr
operator|=
name|dwarf2_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_extension
argument_list|,
name|cu
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ref
operator|=
name|dwarf2_get_ref_die_offset
argument_list|(
name|attr
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|extension_die
operator|=
name|follow_die_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extension_die
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: Cannot find referent at offset %d."
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
return|return
name|extension_die
return|;
block|}
end_function

begin_comment
comment|/* Convert a DIE tag into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|unsigned
name|tag
parameter_list|)
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
return|return
literal|"DW_TAG_padding"
return|;
case|case
name|DW_TAG_array_type
case|:
return|return
literal|"DW_TAG_array_type"
return|;
case|case
name|DW_TAG_class_type
case|:
return|return
literal|"DW_TAG_class_type"
return|;
case|case
name|DW_TAG_entry_point
case|:
return|return
literal|"DW_TAG_entry_point"
return|;
case|case
name|DW_TAG_enumeration_type
case|:
return|return
literal|"DW_TAG_enumeration_type"
return|;
case|case
name|DW_TAG_formal_parameter
case|:
return|return
literal|"DW_TAG_formal_parameter"
return|;
case|case
name|DW_TAG_imported_declaration
case|:
return|return
literal|"DW_TAG_imported_declaration"
return|;
case|case
name|DW_TAG_label
case|:
return|return
literal|"DW_TAG_label"
return|;
case|case
name|DW_TAG_lexical_block
case|:
return|return
literal|"DW_TAG_lexical_block"
return|;
case|case
name|DW_TAG_member
case|:
return|return
literal|"DW_TAG_member"
return|;
case|case
name|DW_TAG_pointer_type
case|:
return|return
literal|"DW_TAG_pointer_type"
return|;
case|case
name|DW_TAG_reference_type
case|:
return|return
literal|"DW_TAG_reference_type"
return|;
case|case
name|DW_TAG_compile_unit
case|:
return|return
literal|"DW_TAG_compile_unit"
return|;
case|case
name|DW_TAG_string_type
case|:
return|return
literal|"DW_TAG_string_type"
return|;
case|case
name|DW_TAG_structure_type
case|:
return|return
literal|"DW_TAG_structure_type"
return|;
case|case
name|DW_TAG_subroutine_type
case|:
return|return
literal|"DW_TAG_subroutine_type"
return|;
case|case
name|DW_TAG_typedef
case|:
return|return
literal|"DW_TAG_typedef"
return|;
case|case
name|DW_TAG_union_type
case|:
return|return
literal|"DW_TAG_union_type"
return|;
case|case
name|DW_TAG_unspecified_parameters
case|:
return|return
literal|"DW_TAG_unspecified_parameters"
return|;
case|case
name|DW_TAG_variant
case|:
return|return
literal|"DW_TAG_variant"
return|;
case|case
name|DW_TAG_common_block
case|:
return|return
literal|"DW_TAG_common_block"
return|;
case|case
name|DW_TAG_common_inclusion
case|:
return|return
literal|"DW_TAG_common_inclusion"
return|;
case|case
name|DW_TAG_inheritance
case|:
return|return
literal|"DW_TAG_inheritance"
return|;
case|case
name|DW_TAG_inlined_subroutine
case|:
return|return
literal|"DW_TAG_inlined_subroutine"
return|;
case|case
name|DW_TAG_module
case|:
return|return
literal|"DW_TAG_module"
return|;
case|case
name|DW_TAG_ptr_to_member_type
case|:
return|return
literal|"DW_TAG_ptr_to_member_type"
return|;
case|case
name|DW_TAG_set_type
case|:
return|return
literal|"DW_TAG_set_type"
return|;
case|case
name|DW_TAG_subrange_type
case|:
return|return
literal|"DW_TAG_subrange_type"
return|;
case|case
name|DW_TAG_with_stmt
case|:
return|return
literal|"DW_TAG_with_stmt"
return|;
case|case
name|DW_TAG_access_declaration
case|:
return|return
literal|"DW_TAG_access_declaration"
return|;
case|case
name|DW_TAG_base_type
case|:
return|return
literal|"DW_TAG_base_type"
return|;
case|case
name|DW_TAG_catch_block
case|:
return|return
literal|"DW_TAG_catch_block"
return|;
case|case
name|DW_TAG_const_type
case|:
return|return
literal|"DW_TAG_const_type"
return|;
case|case
name|DW_TAG_constant
case|:
return|return
literal|"DW_TAG_constant"
return|;
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|"DW_TAG_enumerator"
return|;
case|case
name|DW_TAG_file_type
case|:
return|return
literal|"DW_TAG_file_type"
return|;
case|case
name|DW_TAG_friend
case|:
return|return
literal|"DW_TAG_friend"
return|;
case|case
name|DW_TAG_namelist
case|:
return|return
literal|"DW_TAG_namelist"
return|;
case|case
name|DW_TAG_namelist_item
case|:
return|return
literal|"DW_TAG_namelist_item"
return|;
case|case
name|DW_TAG_packed_type
case|:
return|return
literal|"DW_TAG_packed_type"
return|;
case|case
name|DW_TAG_subprogram
case|:
return|return
literal|"DW_TAG_subprogram"
return|;
case|case
name|DW_TAG_template_type_param
case|:
return|return
literal|"DW_TAG_template_type_param"
return|;
case|case
name|DW_TAG_template_value_param
case|:
return|return
literal|"DW_TAG_template_value_param"
return|;
case|case
name|DW_TAG_thrown_type
case|:
return|return
literal|"DW_TAG_thrown_type"
return|;
case|case
name|DW_TAG_try_block
case|:
return|return
literal|"DW_TAG_try_block"
return|;
case|case
name|DW_TAG_variant_part
case|:
return|return
literal|"DW_TAG_variant_part"
return|;
case|case
name|DW_TAG_variable
case|:
return|return
literal|"DW_TAG_variable"
return|;
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|"DW_TAG_volatile_type"
return|;
case|case
name|DW_TAG_dwarf_procedure
case|:
return|return
literal|"DW_TAG_dwarf_procedure"
return|;
case|case
name|DW_TAG_restrict_type
case|:
return|return
literal|"DW_TAG_restrict_type"
return|;
case|case
name|DW_TAG_interface_type
case|:
return|return
literal|"DW_TAG_interface_type"
return|;
case|case
name|DW_TAG_namespace
case|:
return|return
literal|"DW_TAG_namespace"
return|;
case|case
name|DW_TAG_imported_module
case|:
return|return
literal|"DW_TAG_imported_module"
return|;
case|case
name|DW_TAG_unspecified_type
case|:
return|return
literal|"DW_TAG_unspecified_type"
return|;
case|case
name|DW_TAG_partial_unit
case|:
return|return
literal|"DW_TAG_partial_unit"
return|;
case|case
name|DW_TAG_imported_unit
case|:
return|return
literal|"DW_TAG_imported_unit"
return|;
case|case
name|DW_TAG_MIPS_loop
case|:
return|return
literal|"DW_TAG_MIPS_loop"
return|;
case|case
name|DW_TAG_format_label
case|:
return|return
literal|"DW_TAG_format_label"
return|;
case|case
name|DW_TAG_function_template
case|:
return|return
literal|"DW_TAG_function_template"
return|;
case|case
name|DW_TAG_class_template
case|:
return|return
literal|"DW_TAG_class_template"
return|;
default|default:
return|return
literal|"DW_TAG_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF attribute code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|unsigned
name|attr
parameter_list|)
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|DW_AT_sibling
case|:
return|return
literal|"DW_AT_sibling"
return|;
case|case
name|DW_AT_location
case|:
return|return
literal|"DW_AT_location"
return|;
case|case
name|DW_AT_name
case|:
return|return
literal|"DW_AT_name"
return|;
case|case
name|DW_AT_ordering
case|:
return|return
literal|"DW_AT_ordering"
return|;
case|case
name|DW_AT_subscr_data
case|:
return|return
literal|"DW_AT_subscr_data"
return|;
case|case
name|DW_AT_byte_size
case|:
return|return
literal|"DW_AT_byte_size"
return|;
case|case
name|DW_AT_bit_offset
case|:
return|return
literal|"DW_AT_bit_offset"
return|;
case|case
name|DW_AT_bit_size
case|:
return|return
literal|"DW_AT_bit_size"
return|;
case|case
name|DW_AT_element_list
case|:
return|return
literal|"DW_AT_element_list"
return|;
case|case
name|DW_AT_stmt_list
case|:
return|return
literal|"DW_AT_stmt_list"
return|;
case|case
name|DW_AT_low_pc
case|:
return|return
literal|"DW_AT_low_pc"
return|;
case|case
name|DW_AT_high_pc
case|:
return|return
literal|"DW_AT_high_pc"
return|;
case|case
name|DW_AT_language
case|:
return|return
literal|"DW_AT_language"
return|;
case|case
name|DW_AT_member
case|:
return|return
literal|"DW_AT_member"
return|;
case|case
name|DW_AT_discr
case|:
return|return
literal|"DW_AT_discr"
return|;
case|case
name|DW_AT_discr_value
case|:
return|return
literal|"DW_AT_discr_value"
return|;
case|case
name|DW_AT_visibility
case|:
return|return
literal|"DW_AT_visibility"
return|;
case|case
name|DW_AT_import
case|:
return|return
literal|"DW_AT_import"
return|;
case|case
name|DW_AT_string_length
case|:
return|return
literal|"DW_AT_string_length"
return|;
case|case
name|DW_AT_common_reference
case|:
return|return
literal|"DW_AT_common_reference"
return|;
case|case
name|DW_AT_comp_dir
case|:
return|return
literal|"DW_AT_comp_dir"
return|;
case|case
name|DW_AT_const_value
case|:
return|return
literal|"DW_AT_const_value"
return|;
case|case
name|DW_AT_containing_type
case|:
return|return
literal|"DW_AT_containing_type"
return|;
case|case
name|DW_AT_default_value
case|:
return|return
literal|"DW_AT_default_value"
return|;
case|case
name|DW_AT_inline
case|:
return|return
literal|"DW_AT_inline"
return|;
case|case
name|DW_AT_is_optional
case|:
return|return
literal|"DW_AT_is_optional"
return|;
case|case
name|DW_AT_lower_bound
case|:
return|return
literal|"DW_AT_lower_bound"
return|;
case|case
name|DW_AT_producer
case|:
return|return
literal|"DW_AT_producer"
return|;
case|case
name|DW_AT_prototyped
case|:
return|return
literal|"DW_AT_prototyped"
return|;
case|case
name|DW_AT_return_addr
case|:
return|return
literal|"DW_AT_return_addr"
return|;
case|case
name|DW_AT_start_scope
case|:
return|return
literal|"DW_AT_start_scope"
return|;
case|case
name|DW_AT_stride_size
case|:
return|return
literal|"DW_AT_stride_size"
return|;
case|case
name|DW_AT_upper_bound
case|:
return|return
literal|"DW_AT_upper_bound"
return|;
case|case
name|DW_AT_abstract_origin
case|:
return|return
literal|"DW_AT_abstract_origin"
return|;
case|case
name|DW_AT_accessibility
case|:
return|return
literal|"DW_AT_accessibility"
return|;
case|case
name|DW_AT_address_class
case|:
return|return
literal|"DW_AT_address_class"
return|;
case|case
name|DW_AT_artificial
case|:
return|return
literal|"DW_AT_artificial"
return|;
case|case
name|DW_AT_base_types
case|:
return|return
literal|"DW_AT_base_types"
return|;
case|case
name|DW_AT_calling_convention
case|:
return|return
literal|"DW_AT_calling_convention"
return|;
case|case
name|DW_AT_count
case|:
return|return
literal|"DW_AT_count"
return|;
case|case
name|DW_AT_data_member_location
case|:
return|return
literal|"DW_AT_data_member_location"
return|;
case|case
name|DW_AT_decl_column
case|:
return|return
literal|"DW_AT_decl_column"
return|;
case|case
name|DW_AT_decl_file
case|:
return|return
literal|"DW_AT_decl_file"
return|;
case|case
name|DW_AT_decl_line
case|:
return|return
literal|"DW_AT_decl_line"
return|;
case|case
name|DW_AT_declaration
case|:
return|return
literal|"DW_AT_declaration"
return|;
case|case
name|DW_AT_discr_list
case|:
return|return
literal|"DW_AT_discr_list"
return|;
case|case
name|DW_AT_encoding
case|:
return|return
literal|"DW_AT_encoding"
return|;
case|case
name|DW_AT_external
case|:
return|return
literal|"DW_AT_external"
return|;
case|case
name|DW_AT_frame_base
case|:
return|return
literal|"DW_AT_frame_base"
return|;
case|case
name|DW_AT_friend
case|:
return|return
literal|"DW_AT_friend"
return|;
case|case
name|DW_AT_identifier_case
case|:
return|return
literal|"DW_AT_identifier_case"
return|;
case|case
name|DW_AT_macro_info
case|:
return|return
literal|"DW_AT_macro_info"
return|;
case|case
name|DW_AT_namelist_items
case|:
return|return
literal|"DW_AT_namelist_items"
return|;
case|case
name|DW_AT_priority
case|:
return|return
literal|"DW_AT_priority"
return|;
case|case
name|DW_AT_segment
case|:
return|return
literal|"DW_AT_segment"
return|;
case|case
name|DW_AT_specification
case|:
return|return
literal|"DW_AT_specification"
return|;
case|case
name|DW_AT_static_link
case|:
return|return
literal|"DW_AT_static_link"
return|;
case|case
name|DW_AT_type
case|:
return|return
literal|"DW_AT_type"
return|;
case|case
name|DW_AT_use_location
case|:
return|return
literal|"DW_AT_use_location"
return|;
case|case
name|DW_AT_variable_parameter
case|:
return|return
literal|"DW_AT_variable_parameter"
return|;
case|case
name|DW_AT_virtuality
case|:
return|return
literal|"DW_AT_virtuality"
return|;
case|case
name|DW_AT_vtable_elem_location
case|:
return|return
literal|"DW_AT_vtable_elem_location"
return|;
case|case
name|DW_AT_allocated
case|:
return|return
literal|"DW_AT_allocated"
return|;
case|case
name|DW_AT_associated
case|:
return|return
literal|"DW_AT_associated"
return|;
case|case
name|DW_AT_data_location
case|:
return|return
literal|"DW_AT_data_location"
return|;
case|case
name|DW_AT_stride
case|:
return|return
literal|"DW_AT_stride"
return|;
case|case
name|DW_AT_entry_pc
case|:
return|return
literal|"DW_AT_entry_pc"
return|;
case|case
name|DW_AT_use_UTF8
case|:
return|return
literal|"DW_AT_use_UTF8"
return|;
case|case
name|DW_AT_extension
case|:
return|return
literal|"DW_AT_extension"
return|;
case|case
name|DW_AT_ranges
case|:
return|return
literal|"DW_AT_ranges"
return|;
case|case
name|DW_AT_trampoline
case|:
return|return
literal|"DW_AT_trampoline"
return|;
case|case
name|DW_AT_call_column
case|:
return|return
literal|"DW_AT_call_column"
return|;
case|case
name|DW_AT_call_file
case|:
return|return
literal|"DW_AT_call_file"
return|;
case|case
name|DW_AT_call_line
case|:
return|return
literal|"DW_AT_call_line"
return|;
ifdef|#
directive|ifdef
name|MIPS
case|case
name|DW_AT_MIPS_fde
case|:
return|return
literal|"DW_AT_MIPS_fde"
return|;
case|case
name|DW_AT_MIPS_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_loop_begin"
return|;
case|case
name|DW_AT_MIPS_tail_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_tail_loop_begin"
return|;
case|case
name|DW_AT_MIPS_epilog_begin
case|:
return|return
literal|"DW_AT_MIPS_epilog_begin"
return|;
case|case
name|DW_AT_MIPS_loop_unroll_factor
case|:
return|return
literal|"DW_AT_MIPS_loop_unroll_factor"
return|;
case|case
name|DW_AT_MIPS_software_pipeline_depth
case|:
return|return
literal|"DW_AT_MIPS_software_pipeline_depth"
return|;
endif|#
directive|endif
case|case
name|DW_AT_MIPS_linkage_name
case|:
return|return
literal|"DW_AT_MIPS_linkage_name"
return|;
case|case
name|DW_AT_sf_names
case|:
return|return
literal|"DW_AT_sf_names"
return|;
case|case
name|DW_AT_src_info
case|:
return|return
literal|"DW_AT_src_info"
return|;
case|case
name|DW_AT_mac_info
case|:
return|return
literal|"DW_AT_mac_info"
return|;
case|case
name|DW_AT_src_coords
case|:
return|return
literal|"DW_AT_src_coords"
return|;
case|case
name|DW_AT_body_begin
case|:
return|return
literal|"DW_AT_body_begin"
return|;
case|case
name|DW_AT_body_end
case|:
return|return
literal|"DW_AT_body_end"
return|;
case|case
name|DW_AT_GNU_vector
case|:
return|return
literal|"DW_AT_GNU_vector"
return|;
default|default:
return|return
literal|"DW_AT_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF value form code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_form_name
parameter_list|(
name|unsigned
name|form
parameter_list|)
block|{
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
return|return
literal|"DW_FORM_addr"
return|;
case|case
name|DW_FORM_block2
case|:
return|return
literal|"DW_FORM_block2"
return|;
case|case
name|DW_FORM_block4
case|:
return|return
literal|"DW_FORM_block4"
return|;
case|case
name|DW_FORM_data2
case|:
return|return
literal|"DW_FORM_data2"
return|;
case|case
name|DW_FORM_data4
case|:
return|return
literal|"DW_FORM_data4"
return|;
case|case
name|DW_FORM_data8
case|:
return|return
literal|"DW_FORM_data8"
return|;
case|case
name|DW_FORM_string
case|:
return|return
literal|"DW_FORM_string"
return|;
case|case
name|DW_FORM_block
case|:
return|return
literal|"DW_FORM_block"
return|;
case|case
name|DW_FORM_block1
case|:
return|return
literal|"DW_FORM_block1"
return|;
case|case
name|DW_FORM_data1
case|:
return|return
literal|"DW_FORM_data1"
return|;
case|case
name|DW_FORM_flag
case|:
return|return
literal|"DW_FORM_flag"
return|;
case|case
name|DW_FORM_sdata
case|:
return|return
literal|"DW_FORM_sdata"
return|;
case|case
name|DW_FORM_strp
case|:
return|return
literal|"DW_FORM_strp"
return|;
case|case
name|DW_FORM_udata
case|:
return|return
literal|"DW_FORM_udata"
return|;
case|case
name|DW_FORM_ref_addr
case|:
return|return
literal|"DW_FORM_ref_addr"
return|;
case|case
name|DW_FORM_ref1
case|:
return|return
literal|"DW_FORM_ref1"
return|;
case|case
name|DW_FORM_ref2
case|:
return|return
literal|"DW_FORM_ref2"
return|;
case|case
name|DW_FORM_ref4
case|:
return|return
literal|"DW_FORM_ref4"
return|;
case|case
name|DW_FORM_ref8
case|:
return|return
literal|"DW_FORM_ref8"
return|;
case|case
name|DW_FORM_ref_udata
case|:
return|return
literal|"DW_FORM_ref_udata"
return|;
case|case
name|DW_FORM_indirect
case|:
return|return
literal|"DW_FORM_indirect"
return|;
default|default:
return|return
literal|"DW_FORM_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF stack opcode into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|unsigned
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_addr
case|:
return|return
literal|"DW_OP_addr"
return|;
case|case
name|DW_OP_deref
case|:
return|return
literal|"DW_OP_deref"
return|;
case|case
name|DW_OP_const1u
case|:
return|return
literal|"DW_OP_const1u"
return|;
case|case
name|DW_OP_const1s
case|:
return|return
literal|"DW_OP_const1s"
return|;
case|case
name|DW_OP_const2u
case|:
return|return
literal|"DW_OP_const2u"
return|;
case|case
name|DW_OP_const2s
case|:
return|return
literal|"DW_OP_const2s"
return|;
case|case
name|DW_OP_const4u
case|:
return|return
literal|"DW_OP_const4u"
return|;
case|case
name|DW_OP_const4s
case|:
return|return
literal|"DW_OP_const4s"
return|;
case|case
name|DW_OP_const8u
case|:
return|return
literal|"DW_OP_const8u"
return|;
case|case
name|DW_OP_const8s
case|:
return|return
literal|"DW_OP_const8s"
return|;
case|case
name|DW_OP_constu
case|:
return|return
literal|"DW_OP_constu"
return|;
case|case
name|DW_OP_consts
case|:
return|return
literal|"DW_OP_consts"
return|;
case|case
name|DW_OP_dup
case|:
return|return
literal|"DW_OP_dup"
return|;
case|case
name|DW_OP_drop
case|:
return|return
literal|"DW_OP_drop"
return|;
case|case
name|DW_OP_over
case|:
return|return
literal|"DW_OP_over"
return|;
case|case
name|DW_OP_pick
case|:
return|return
literal|"DW_OP_pick"
return|;
case|case
name|DW_OP_swap
case|:
return|return
literal|"DW_OP_swap"
return|;
case|case
name|DW_OP_rot
case|:
return|return
literal|"DW_OP_rot"
return|;
case|case
name|DW_OP_xderef
case|:
return|return
literal|"DW_OP_xderef"
return|;
case|case
name|DW_OP_abs
case|:
return|return
literal|"DW_OP_abs"
return|;
case|case
name|DW_OP_and
case|:
return|return
literal|"DW_OP_and"
return|;
case|case
name|DW_OP_div
case|:
return|return
literal|"DW_OP_div"
return|;
case|case
name|DW_OP_minus
case|:
return|return
literal|"DW_OP_minus"
return|;
case|case
name|DW_OP_mod
case|:
return|return
literal|"DW_OP_mod"
return|;
case|case
name|DW_OP_mul
case|:
return|return
literal|"DW_OP_mul"
return|;
case|case
name|DW_OP_neg
case|:
return|return
literal|"DW_OP_neg"
return|;
case|case
name|DW_OP_not
case|:
return|return
literal|"DW_OP_not"
return|;
case|case
name|DW_OP_or
case|:
return|return
literal|"DW_OP_or"
return|;
case|case
name|DW_OP_plus
case|:
return|return
literal|"DW_OP_plus"
return|;
case|case
name|DW_OP_plus_uconst
case|:
return|return
literal|"DW_OP_plus_uconst"
return|;
case|case
name|DW_OP_shl
case|:
return|return
literal|"DW_OP_shl"
return|;
case|case
name|DW_OP_shr
case|:
return|return
literal|"DW_OP_shr"
return|;
case|case
name|DW_OP_shra
case|:
return|return
literal|"DW_OP_shra"
return|;
case|case
name|DW_OP_xor
case|:
return|return
literal|"DW_OP_xor"
return|;
case|case
name|DW_OP_bra
case|:
return|return
literal|"DW_OP_bra"
return|;
case|case
name|DW_OP_eq
case|:
return|return
literal|"DW_OP_eq"
return|;
case|case
name|DW_OP_ge
case|:
return|return
literal|"DW_OP_ge"
return|;
case|case
name|DW_OP_gt
case|:
return|return
literal|"DW_OP_gt"
return|;
case|case
name|DW_OP_le
case|:
return|return
literal|"DW_OP_le"
return|;
case|case
name|DW_OP_lt
case|:
return|return
literal|"DW_OP_lt"
return|;
case|case
name|DW_OP_ne
case|:
return|return
literal|"DW_OP_ne"
return|;
case|case
name|DW_OP_skip
case|:
return|return
literal|"DW_OP_skip"
return|;
case|case
name|DW_OP_lit0
case|:
return|return
literal|"DW_OP_lit0"
return|;
case|case
name|DW_OP_lit1
case|:
return|return
literal|"DW_OP_lit1"
return|;
case|case
name|DW_OP_lit2
case|:
return|return
literal|"DW_OP_lit2"
return|;
case|case
name|DW_OP_lit3
case|:
return|return
literal|"DW_OP_lit3"
return|;
case|case
name|DW_OP_lit4
case|:
return|return
literal|"DW_OP_lit4"
return|;
case|case
name|DW_OP_lit5
case|:
return|return
literal|"DW_OP_lit5"
return|;
case|case
name|DW_OP_lit6
case|:
return|return
literal|"DW_OP_lit6"
return|;
case|case
name|DW_OP_lit7
case|:
return|return
literal|"DW_OP_lit7"
return|;
case|case
name|DW_OP_lit8
case|:
return|return
literal|"DW_OP_lit8"
return|;
case|case
name|DW_OP_lit9
case|:
return|return
literal|"DW_OP_lit9"
return|;
case|case
name|DW_OP_lit10
case|:
return|return
literal|"DW_OP_lit10"
return|;
case|case
name|DW_OP_lit11
case|:
return|return
literal|"DW_OP_lit11"
return|;
case|case
name|DW_OP_lit12
case|:
return|return
literal|"DW_OP_lit12"
return|;
case|case
name|DW_OP_lit13
case|:
return|return
literal|"DW_OP_lit13"
return|;
case|case
name|DW_OP_lit14
case|:
return|return
literal|"DW_OP_lit14"
return|;
case|case
name|DW_OP_lit15
case|:
return|return
literal|"DW_OP_lit15"
return|;
case|case
name|DW_OP_lit16
case|:
return|return
literal|"DW_OP_lit16"
return|;
case|case
name|DW_OP_lit17
case|:
return|return
literal|"DW_OP_lit17"
return|;
case|case
name|DW_OP_lit18
case|:
return|return
literal|"DW_OP_lit18"
return|;
case|case
name|DW_OP_lit19
case|:
return|return
literal|"DW_OP_lit19"
return|;
case|case
name|DW_OP_lit20
case|:
return|return
literal|"DW_OP_lit20"
return|;
case|case
name|DW_OP_lit21
case|:
return|return
literal|"DW_OP_lit21"
return|;
case|case
name|DW_OP_lit22
case|:
return|return
literal|"DW_OP_lit22"
return|;
case|case
name|DW_OP_lit23
case|:
return|return
literal|"DW_OP_lit23"
return|;
case|case
name|DW_OP_lit24
case|:
return|return
literal|"DW_OP_lit24"
return|;
case|case
name|DW_OP_lit25
case|:
return|return
literal|"DW_OP_lit25"
return|;
case|case
name|DW_OP_lit26
case|:
return|return
literal|"DW_OP_lit26"
return|;
case|case
name|DW_OP_lit27
case|:
return|return
literal|"DW_OP_lit27"
return|;
case|case
name|DW_OP_lit28
case|:
return|return
literal|"DW_OP_lit28"
return|;
case|case
name|DW_OP_lit29
case|:
return|return
literal|"DW_OP_lit29"
return|;
case|case
name|DW_OP_lit30
case|:
return|return
literal|"DW_OP_lit30"
return|;
case|case
name|DW_OP_lit31
case|:
return|return
literal|"DW_OP_lit31"
return|;
case|case
name|DW_OP_reg0
case|:
return|return
literal|"DW_OP_reg0"
return|;
case|case
name|DW_OP_reg1
case|:
return|return
literal|"DW_OP_reg1"
return|;
case|case
name|DW_OP_reg2
case|:
return|return
literal|"DW_OP_reg2"
return|;
case|case
name|DW_OP_reg3
case|:
return|return
literal|"DW_OP_reg3"
return|;
case|case
name|DW_OP_reg4
case|:
return|return
literal|"DW_OP_reg4"
return|;
case|case
name|DW_OP_reg5
case|:
return|return
literal|"DW_OP_reg5"
return|;
case|case
name|DW_OP_reg6
case|:
return|return
literal|"DW_OP_reg6"
return|;
case|case
name|DW_OP_reg7
case|:
return|return
literal|"DW_OP_reg7"
return|;
case|case
name|DW_OP_reg8
case|:
return|return
literal|"DW_OP_reg8"
return|;
case|case
name|DW_OP_reg9
case|:
return|return
literal|"DW_OP_reg9"
return|;
case|case
name|DW_OP_reg10
case|:
return|return
literal|"DW_OP_reg10"
return|;
case|case
name|DW_OP_reg11
case|:
return|return
literal|"DW_OP_reg11"
return|;
case|case
name|DW_OP_reg12
case|:
return|return
literal|"DW_OP_reg12"
return|;
case|case
name|DW_OP_reg13
case|:
return|return
literal|"DW_OP_reg13"
return|;
case|case
name|DW_OP_reg14
case|:
return|return
literal|"DW_OP_reg14"
return|;
case|case
name|DW_OP_reg15
case|:
return|return
literal|"DW_OP_reg15"
return|;
case|case
name|DW_OP_reg16
case|:
return|return
literal|"DW_OP_reg16"
return|;
case|case
name|DW_OP_reg17
case|:
return|return
literal|"DW_OP_reg17"
return|;
case|case
name|DW_OP_reg18
case|:
return|return
literal|"DW_OP_reg18"
return|;
case|case
name|DW_OP_reg19
case|:
return|return
literal|"DW_OP_reg19"
return|;
case|case
name|DW_OP_reg20
case|:
return|return
literal|"DW_OP_reg20"
return|;
case|case
name|DW_OP_reg21
case|:
return|return
literal|"DW_OP_reg21"
return|;
case|case
name|DW_OP_reg22
case|:
return|return
literal|"DW_OP_reg22"
return|;
case|case
name|DW_OP_reg23
case|:
return|return
literal|"DW_OP_reg23"
return|;
case|case
name|DW_OP_reg24
case|:
return|return
literal|"DW_OP_reg24"
return|;
case|case
name|DW_OP_reg25
case|:
return|return
literal|"DW_OP_reg25"
return|;
case|case
name|DW_OP_reg26
case|:
return|return
literal|"DW_OP_reg26"
return|;
case|case
name|DW_OP_reg27
case|:
return|return
literal|"DW_OP_reg27"
return|;
case|case
name|DW_OP_reg28
case|:
return|return
literal|"DW_OP_reg28"
return|;
case|case
name|DW_OP_reg29
case|:
return|return
literal|"DW_OP_reg29"
return|;
case|case
name|DW_OP_reg30
case|:
return|return
literal|"DW_OP_reg30"
return|;
case|case
name|DW_OP_reg31
case|:
return|return
literal|"DW_OP_reg31"
return|;
case|case
name|DW_OP_breg0
case|:
return|return
literal|"DW_OP_breg0"
return|;
case|case
name|DW_OP_breg1
case|:
return|return
literal|"DW_OP_breg1"
return|;
case|case
name|DW_OP_breg2
case|:
return|return
literal|"DW_OP_breg2"
return|;
case|case
name|DW_OP_breg3
case|:
return|return
literal|"DW_OP_breg3"
return|;
case|case
name|DW_OP_breg4
case|:
return|return
literal|"DW_OP_breg4"
return|;
case|case
name|DW_OP_breg5
case|:
return|return
literal|"DW_OP_breg5"
return|;
case|case
name|DW_OP_breg6
case|:
return|return
literal|"DW_OP_breg6"
return|;
case|case
name|DW_OP_breg7
case|:
return|return
literal|"DW_OP_breg7"
return|;
case|case
name|DW_OP_breg8
case|:
return|return
literal|"DW_OP_breg8"
return|;
case|case
name|DW_OP_breg9
case|:
return|return
literal|"DW_OP_breg9"
return|;
case|case
name|DW_OP_breg10
case|:
return|return
literal|"DW_OP_breg10"
return|;
case|case
name|DW_OP_breg11
case|:
return|return
literal|"DW_OP_breg11"
return|;
case|case
name|DW_OP_breg12
case|:
return|return
literal|"DW_OP_breg12"
return|;
case|case
name|DW_OP_breg13
case|:
return|return
literal|"DW_OP_breg13"
return|;
case|case
name|DW_OP_breg14
case|:
return|return
literal|"DW_OP_breg14"
return|;
case|case
name|DW_OP_breg15
case|:
return|return
literal|"DW_OP_breg15"
return|;
case|case
name|DW_OP_breg16
case|:
return|return
literal|"DW_OP_breg16"
return|;
case|case
name|DW_OP_breg17
case|:
return|return
literal|"DW_OP_breg17"
return|;
case|case
name|DW_OP_breg18
case|:
return|return
literal|"DW_OP_breg18"
return|;
case|case
name|DW_OP_breg19
case|:
return|return
literal|"DW_OP_breg19"
return|;
case|case
name|DW_OP_breg20
case|:
return|return
literal|"DW_OP_breg20"
return|;
case|case
name|DW_OP_breg21
case|:
return|return
literal|"DW_OP_breg21"
return|;
case|case
name|DW_OP_breg22
case|:
return|return
literal|"DW_OP_breg22"
return|;
case|case
name|DW_OP_breg23
case|:
return|return
literal|"DW_OP_breg23"
return|;
case|case
name|DW_OP_breg24
case|:
return|return
literal|"DW_OP_breg24"
return|;
case|case
name|DW_OP_breg25
case|:
return|return
literal|"DW_OP_breg25"
return|;
case|case
name|DW_OP_breg26
case|:
return|return
literal|"DW_OP_breg26"
return|;
case|case
name|DW_OP_breg27
case|:
return|return
literal|"DW_OP_breg27"
return|;
case|case
name|DW_OP_breg28
case|:
return|return
literal|"DW_OP_breg28"
return|;
case|case
name|DW_OP_breg29
case|:
return|return
literal|"DW_OP_breg29"
return|;
case|case
name|DW_OP_breg30
case|:
return|return
literal|"DW_OP_breg30"
return|;
case|case
name|DW_OP_breg31
case|:
return|return
literal|"DW_OP_breg31"
return|;
case|case
name|DW_OP_regx
case|:
return|return
literal|"DW_OP_regx"
return|;
case|case
name|DW_OP_fbreg
case|:
return|return
literal|"DW_OP_fbreg"
return|;
case|case
name|DW_OP_bregx
case|:
return|return
literal|"DW_OP_bregx"
return|;
case|case
name|DW_OP_piece
case|:
return|return
literal|"DW_OP_piece"
return|;
case|case
name|DW_OP_deref_size
case|:
return|return
literal|"DW_OP_deref_size"
return|;
case|case
name|DW_OP_xderef_size
case|:
return|return
literal|"DW_OP_xderef_size"
return|;
case|case
name|DW_OP_nop
case|:
return|return
literal|"DW_OP_nop"
return|;
comment|/* DWARF 3 extensions.  */
case|case
name|DW_OP_push_object_address
case|:
return|return
literal|"DW_OP_push_object_address"
return|;
case|case
name|DW_OP_call2
case|:
return|return
literal|"DW_OP_call2"
return|;
case|case
name|DW_OP_call4
case|:
return|return
literal|"DW_OP_call4"
return|;
case|case
name|DW_OP_call_ref
case|:
return|return
literal|"DW_OP_call_ref"
return|;
comment|/* GNU extensions.  */
case|case
name|DW_OP_GNU_push_tls_address
case|:
return|return
literal|"DW_OP_GNU_push_tls_address"
return|;
default|default:
return|return
literal|"OP_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_bool_name
parameter_list|(
name|unsigned
name|mybool
parameter_list|)
block|{
if|if
condition|(
name|mybool
condition|)
return|return
literal|"TRUE"
return|;
else|else
return|return
literal|"FALSE"
return|;
block|}
end_function

begin_comment
comment|/* Convert a DWARF type code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_type_encoding_name
parameter_list|(
name|unsigned
name|enc
parameter_list|)
block|{
switch|switch
condition|(
name|enc
condition|)
block|{
case|case
name|DW_ATE_address
case|:
return|return
literal|"DW_ATE_address"
return|;
case|case
name|DW_ATE_boolean
case|:
return|return
literal|"DW_ATE_boolean"
return|;
case|case
name|DW_ATE_complex_float
case|:
return|return
literal|"DW_ATE_complex_float"
return|;
case|case
name|DW_ATE_float
case|:
return|return
literal|"DW_ATE_float"
return|;
case|case
name|DW_ATE_signed
case|:
return|return
literal|"DW_ATE_signed"
return|;
case|case
name|DW_ATE_signed_char
case|:
return|return
literal|"DW_ATE_signed_char"
return|;
case|case
name|DW_ATE_unsigned
case|:
return|return
literal|"DW_ATE_unsigned"
return|;
case|case
name|DW_ATE_unsigned_char
case|:
return|return
literal|"DW_ATE_unsigned_char"
return|;
case|case
name|DW_ATE_imaginary_float
case|:
return|return
literal|"DW_ATE_imaginary_float"
return|;
default|default:
return|return
literal|"DW_ATE_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF call frame info operation to its string name. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static char * dwarf_cfi_name (unsigned cfi_opc) {   switch (cfi_opc)     {     case DW_CFA_advance_loc:       return "DW_CFA_advance_loc";     case DW_CFA_offset:       return "DW_CFA_offset";     case DW_CFA_restore:       return "DW_CFA_restore";     case DW_CFA_nop:       return "DW_CFA_nop";     case DW_CFA_set_loc:       return "DW_CFA_set_loc";     case DW_CFA_advance_loc1:       return "DW_CFA_advance_loc1";     case DW_CFA_advance_loc2:       return "DW_CFA_advance_loc2";     case DW_CFA_advance_loc4:       return "DW_CFA_advance_loc4";     case DW_CFA_offset_extended:       return "DW_CFA_offset_extended";     case DW_CFA_restore_extended:       return "DW_CFA_restore_extended";     case DW_CFA_undefined:       return "DW_CFA_undefined";     case DW_CFA_same_value:       return "DW_CFA_same_value";     case DW_CFA_register:       return "DW_CFA_register";     case DW_CFA_remember_state:       return "DW_CFA_remember_state";     case DW_CFA_restore_state:       return "DW_CFA_restore_state";     case DW_CFA_def_cfa:       return "DW_CFA_def_cfa";     case DW_CFA_def_cfa_register:       return "DW_CFA_def_cfa_register";     case DW_CFA_def_cfa_offset:       return "DW_CFA_def_cfa_offset";
comment|/* DWARF 3 */
end_comment

begin_comment
unit|case DW_CFA_def_cfa_expression:       return "DW_CFA_def_cfa_expression";     case DW_CFA_expression:       return "DW_CFA_expression";     case DW_CFA_offset_extended_sf:       return "DW_CFA_offset_extended_sf";     case DW_CFA_def_cfa_sf:       return "DW_CFA_def_cfa_sf";     case DW_CFA_def_cfa_offset_sf:       return "DW_CFA_def_cfa_offset_sf";
comment|/* SGI/MIPS specific */
end_comment

begin_comment
unit|case DW_CFA_MIPS_advance_loc8:       return "DW_CFA_MIPS_advance_loc8";
comment|/* GNU extensions */
end_comment

begin_endif
unit|case DW_CFA_GNU_window_save:       return "DW_CFA_GNU_window_save";     case DW_CFA_GNU_args_size:       return "DW_CFA_GNU_args_size";     case DW_CFA_GNU_negative_offset_extended:       return "DW_CFA_GNU_negative_offset_extended";      default:       return "DW_CFA_<unknown>";     } }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dump_die
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Die: %s (abbrev = %d, offset = %d)\n"
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|tag
argument_list|)
argument_list|,
name|die
operator|->
name|abbrev
argument_list|,
name|die
operator|->
name|offset
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\thas children: %s\n"
argument_list|,
name|dwarf_bool_name
argument_list|(
name|die
operator|->
name|child
operator|!=
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\tattributes:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|die
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\t\t%s (%s) "
argument_list|,
name|dwarf_attr_name
argument_list|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|dwarf_form_name
argument_list|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|form
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|form
condition|)
block|{
case|case
name|DW_FORM_ref_addr
case|:
case|case
name|DW_FORM_addr
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"address: "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|DW_ADDR
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
case|case
name|DW_FORM_block4
case|:
case|case
name|DW_FORM_block
case|:
case|case
name|DW_FORM_block1
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"block: size %d"
argument_list|,
name|DW_BLOCK
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_data8
case|:
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_udata
case|:
case|case
name|DW_FORM_sdata
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"constant: %ld"
argument_list|,
name|DW_UNSND
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
case|case
name|DW_FORM_strp
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"string: \"%s\""
argument_list|,
name|DW_STRING
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
condition|?
name|DW_STRING
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
if|if
condition|(
name|DW_UNSND
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"flag: TRUE"
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"flag: FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_indirect
case|:
comment|/* the reader will have reduced the indirect form to 	     the "base form" so this form should not occur */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"unexpected attribute form: DW_FORM_indirect"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"unsupported attribute form: %d."
argument_list|,
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|form
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_die_list
parameter_list|(
name|struct
name|die_info
modifier|*
name|die
parameter_list|)
block|{
while|while
condition|(
name|die
condition|)
block|{
name|dump_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|child
operator|!=
name|NULL
condition|)
name|dump_die_list
argument_list|(
name|die
operator|->
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|sibling
operator|!=
name|NULL
condition|)
name|dump_die_list
argument_list|(
name|die
operator|->
name|sibling
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_in_ref_table
parameter_list|(
name|unsigned
name|int
name|offset
parameter_list|,
name|struct
name|die_info
modifier|*
name|die
parameter_list|)
block|{
name|int
name|h
decl_stmt|;
name|struct
name|die_info
modifier|*
name|old
decl_stmt|;
name|h
operator|=
operator|(
name|offset
operator|%
name|REF_HASH_SIZE
operator|)
expr_stmt|;
name|old
operator|=
name|die_ref_table
index|[
name|h
index|]
expr_stmt|;
name|die
operator|->
name|next_ref
operator|=
name|old
expr_stmt|;
name|die_ref_table
index|[
name|h
index|]
operator|=
name|die
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_empty_hash_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|die_ref_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|die_ref_table
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|dwarf2_get_ref_die_offset
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|form
condition|)
block|{
case|case
name|DW_FORM_ref_addr
case|:
name|result
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_ref8
case|:
case|case
name|DW_FORM_ref_udata
case|:
name|result
operator|=
name|cu
operator|->
name|header
operator|.
name|offset
operator|+
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unsupported die ref attribute form: '%s'"
argument_list|,
name|dwarf_form_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the constant value held by the given attribute.  Return -1    if the value held by the attribute is not constant.  */
end_comment

begin_function
specifier|static
name|int
name|dwarf2_get_attr_constant_value
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|int
name|default_value
parameter_list|)
block|{
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_sdata
condition|)
return|return
name|DW_SND
argument_list|(
name|attr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_udata
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data1
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data2
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data4
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data8
condition|)
return|return
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
return|;
else|else
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Attribute value is not a constant (%s)"
argument_list|,
name|dwarf_form_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|default_value
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|follow_die_ref
parameter_list|(
name|unsigned
name|int
name|offset
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|int
name|h
decl_stmt|;
name|h
operator|=
operator|(
name|offset
operator|%
name|REF_HASH_SIZE
operator|)
expr_stmt|;
name|die
operator|=
name|die_ref_table
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|die
condition|)
block|{
if|if
condition|(
name|die
operator|->
name|offset
operator|==
name|offset
condition|)
block|{
return|return
name|die
return|;
block|}
name|die
operator|=
name|die
operator|->
name|next_ref
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dwarf2_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
if|if
condition|(
name|typeid
operator|<
literal|0
operator|||
name|typeid
operator|>=
name|FT_NUM_MEMBERS
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: internal error - invalid fundamental type id %d [in module %s]"
argument_list|,
name|typeid
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Look for this particular type in the fundamental type vector.  If      one is not found, create and install one appropriate for the      current language and the current target machine. */
if|if
condition|(
name|cu
operator|->
name|ftypes
index|[
name|typeid
index|]
operator|==
name|NULL
condition|)
block|{
name|cu
operator|->
name|ftypes
index|[
name|typeid
index|]
operator|=
name|cu
operator|->
name|language_defn
operator|->
name|la_fund_type
argument_list|(
name|objfile
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cu
operator|->
name|ftypes
index|[
name|typeid
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Decode simple location descriptions.    Given a pointer to a dwarf block that defines a location, compute    the location and return the value.     NOTE drow/2003-11-18: This function is called in two situations    now: for the address of static or global variables (partial symbols    only) and for offsets into structures which are expected to be    (more or less) constant.  The partial symbol case should go away,    and only the constant case should remain.  That will let this    function complain more accurately.  A few special modes are allowed    without complaint for global variables (for instance, global    register values and thread-local values).     A location description containing no operations indicates that the    object is optimized out.  The return value is 0 for that case.    FIXME drow/2003-11-16: No callers check for this case any more; soon all    callers will only want a very basic result and this can become a    complaint.     When the result is a register number, the global isreg flag is set,    otherwise it is cleared.     Note that stack[0] is unused except as a default error return.    Note that stack overflow is not yet handled.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|decode_locdesc
parameter_list|(
name|struct
name|dwarf_block
modifier|*
name|blk
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|cu
operator|->
name|objfile
decl_stmt|;
name|struct
name|comp_unit_head
modifier|*
name|cu_header
init|=
operator|&
name|cu
operator|->
name|header
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
init|=
name|blk
operator|->
name|size
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|blk
operator|->
name|data
decl_stmt|;
name|CORE_ADDR
name|stack
index|[
literal|64
index|]
decl_stmt|;
name|int
name|stacki
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|,
name|unsnd
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|stacki
operator|=
literal|0
expr_stmt|;
name|stack
index|[
name|stacki
index|]
operator|=
literal|0
expr_stmt|;
name|isreg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|op
operator|=
name|data
index|[
name|i
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|op
operator|-
name|DW_OP_lit0
expr_stmt|;
break|break;
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|isreg
operator|=
literal|1
expr_stmt|;
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|op
operator|-
name|DW_OP_reg0
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|size
condition|)
name|dwarf2_complex_location_expr_complaint
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|isreg
operator|=
literal|1
expr_stmt|;
name|unsnd
operator|=
name|read_unsigned_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|unsnd
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|size
condition|)
name|dwarf2_complex_location_expr_complaint
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_OP_addr
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|,
name|cu
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_1_byte
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_1_signed_byte
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_2_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_2_signed_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_4_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_4_signed_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_unsigned_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_signed_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_dup
case|:
name|stack
index|[
name|stacki
operator|+
literal|1
index|]
operator|=
name|stack
index|[
name|stacki
index|]
expr_stmt|;
name|stacki
operator|++
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|stack
index|[
name|stacki
operator|-
literal|1
index|]
operator|+=
name|stack
index|[
name|stacki
index|]
expr_stmt|;
name|stacki
operator|--
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|stack
index|[
name|stacki
index|]
operator|+=
name|read_unsigned_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_minus
case|:
name|stack
index|[
name|stacki
operator|-
literal|1
index|]
operator|-=
name|stack
index|[
name|stacki
index|]
expr_stmt|;
name|stacki
operator|--
expr_stmt|;
break|break;
case|case
name|DW_OP_deref
case|:
comment|/* If we're not the last op, then we definitely can't encode 	     this using GDB's address_class enum.  This is valid for partial 	     global symbols, although the variable's address will be bogus 	     in the psymtab.  */
if|if
condition|(
name|i
operator|<
name|size
condition|)
name|dwarf2_complex_location_expr_complaint
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_OP_GNU_push_tls_address
case|:
comment|/* The top of the stack has the offset from the beginning 	     of the thread control block at which the variable is located.  */
comment|/* Nothing should follow this operator, so the top of stack would 	     be returned.  */
comment|/* This is valid for partial global symbols, but the variable's 	     address will be bogus in the psymtab.  */
if|if
condition|(
name|i
operator|<
name|size
condition|)
name|dwarf2_complex_location_expr_complaint
argument_list|()
expr_stmt|;
break|break;
default|default:
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"unsupported stack op: '%s'"
argument_list|,
name|dwarf_stack_op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|stack
index|[
name|stacki
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
name|stack
index|[
name|stacki
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* memory allocation interface */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_free_tmp_obstack
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|obstack_free
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dwarf_block
modifier|*
name|dwarf_alloc_block
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|dwarf_block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf_alloc_abbrev
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|abbrev
operator|=
operator|(
expr|struct
name|abbrev_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|abbrev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|abbrev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|dwarf_alloc_die
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|die
operator|=
operator|(
expr|struct
name|die_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|die_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|die
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|die_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|die
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macro support.  */
end_comment

begin_comment
comment|/* Return the full name of file number I in *LH's file name table.    Use COMP_DIR as the name of the current directory of the    compilation.  The result is allocated using xmalloc; the caller is    responsible for freeing it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|file_full_name
parameter_list|(
name|int
name|file
parameter_list|,
name|struct
name|line_header
modifier|*
name|lh
parameter_list|,
specifier|const
name|char
modifier|*
name|comp_dir
parameter_list|)
block|{
name|struct
name|file_entry
modifier|*
name|fe
init|=
operator|&
name|lh
operator|->
name|file_names
index|[
name|file
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|fe
operator|->
name|name
argument_list|)
condition|)
return|return
name|xstrdup
argument_list|(
name|fe
operator|->
name|name
argument_list|)
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|dir_len
decl_stmt|;
name|char
modifier|*
name|full_name
decl_stmt|;
if|if
condition|(
name|fe
operator|->
name|dir_index
condition|)
name|dir
operator|=
name|lh
operator|->
name|include_dirs
index|[
name|fe
operator|->
name|dir_index
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|dir
operator|=
name|comp_dir
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
name|dir_len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|full_name
operator|=
name|xmalloc
argument_list|(
name|dir_len
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|fe
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|full_name
index|[
name|dir_len
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|full_name
operator|+
name|dir_len
operator|+
literal|1
argument_list|,
name|fe
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|full_name
return|;
block|}
else|else
return|return
name|xstrdup
argument_list|(
name|fe
operator|->
name|name
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|macro_source_file
modifier|*
name|macro_start_file
parameter_list|(
name|int
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|struct
name|macro_source_file
modifier|*
name|current_file
parameter_list|,
specifier|const
name|char
modifier|*
name|comp_dir
parameter_list|,
name|struct
name|line_header
modifier|*
name|lh
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
comment|/* The full name of this source file.  */
name|char
modifier|*
name|full_name
init|=
name|file_full_name
argument_list|(
name|file
argument_list|,
name|lh
argument_list|,
name|comp_dir
argument_list|)
decl_stmt|;
comment|/* We don't create a macro table for this compilation unit      at all until we actually get a filename.  */
if|if
condition|(
operator|!
name|pending_macros
condition|)
name|pending_macros
operator|=
name|new_macro_table
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|objfile
operator|->
name|macro_cache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_file
condition|)
comment|/* If we have no current file, then this must be the start_file        directive for the compilation unit's main source file.  */
name|current_file
operator|=
name|macro_set_main
argument_list|(
name|pending_macros
argument_list|,
name|full_name
argument_list|)
expr_stmt|;
else|else
name|current_file
operator|=
name|macro_include
argument_list|(
name|current_file
argument_list|,
name|line
argument_list|,
name|full_name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|full_name
argument_list|)
expr_stmt|;
return|return
name|current_file
return|;
block|}
end_function

begin_comment
comment|/* Copy the LEN characters at BUF to a xmalloc'ed block of memory,    followed by a null byte.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|copy_string
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|consume_improper_spaces
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|body
parameter_list|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"macro definition contains spaces in formal argument list:\n`%s'"
argument_list|,
name|body
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_macro_definition
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|body
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* The body string takes one of two forms.  For object-like macro      definitions, it should be:<macro name> " "<definition>       For function-like macro definitions, it should be:<macro name> "() "<definition>      or<macro name> "("<arg name> ( ","<arg name> ) * ") "<definition>       Spaces may appear only where explicitly indicated, and in the<definition>.       The Dwarf 2 spec says that an object-like macro's name is always      followed by a space, but versions of GCC around March 2002 omit      the space when the macro's definition is the empty string.        The Dwarf 2 spec says that there should be no spaces between the      formal arguments in a function-like macro's formal argument list,      but versions of GCC around March 2002 include spaces after the      commas.  */
comment|/* Find the extent of the macro name.  The macro name is terminated      by either a space or null character (for an object-like macro) or      an opening paren (for a function-like macro).  */
for|for
control|(
name|p
operator|=
name|body
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'('
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* It's an object-like macro.  */
name|int
name|name_len
init|=
name|p
operator|-
name|body
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|copy_string
argument_list|(
name|body
argument_list|,
name|name_len
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|replacement
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|replacement
operator|=
name|body
operator|+
name|name_len
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|dwarf2_macro_malformed_definition_complaint
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|replacement
operator|=
name|body
operator|+
name|name_len
expr_stmt|;
block|}
name|macro_define_object
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
comment|/* It's a function-like macro.  */
name|char
modifier|*
name|name
init|=
name|copy_string
argument_list|(
name|body
argument_list|,
name|p
operator|-
name|body
argument_list|)
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|argv_size
init|=
literal|1
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|xmalloc
argument_list|(
name|argv_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|consume_improper_spaces
argument_list|(
name|p
argument_list|,
name|body
argument_list|)
expr_stmt|;
comment|/* Parse the formal argument list.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
comment|/* Find the extent of the current argument name.  */
specifier|const
name|char
modifier|*
name|arg_start
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|')'
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
name|p
operator|==
name|arg_start
condition|)
name|dwarf2_macro_malformed_definition_complaint
argument_list|(
name|body
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Make sure argv has room for the new argument.  */
if|if
condition|(
name|argc
operator|>=
name|argv_size
condition|)
block|{
name|argv_size
operator|*=
literal|2
expr_stmt|;
name|argv
operator|=
name|xrealloc
argument_list|(
name|argv
argument_list|,
name|argv_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|copy_string
argument_list|(
name|arg_start
argument_list|,
name|p
operator|-
name|arg_start
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|consume_improper_spaces
argument_list|(
name|p
argument_list|,
name|body
argument_list|)
expr_stmt|;
comment|/* Consume the comma, if present.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|consume_improper_spaces
argument_list|(
name|p
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* Perfectly formed definition, no complaints.  */
name|macro_define_function
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* Complain, but do define it.  */
name|dwarf2_macro_malformed_definition_complaint
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|macro_define_function
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Just complain.  */
name|dwarf2_macro_malformed_definition_complaint
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Just complain.  */
name|dwarf2_macro_malformed_definition_complaint
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|dwarf2_macro_malformed_definition_complaint
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf_decode_macros
parameter_list|(
name|struct
name|line_header
modifier|*
name|lh
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|char
modifier|*
name|comp_dir
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
name|char
modifier|*
name|mac_ptr
decl_stmt|,
modifier|*
name|mac_end
decl_stmt|;
name|struct
name|macro_source_file
modifier|*
name|current_file
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dwarf_macinfo_buffer
operator|==
name|NULL
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"missing .debug_macinfo section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mac_ptr
operator|=
name|dwarf_macinfo_buffer
operator|+
name|offset
expr_stmt|;
name|mac_end
operator|=
name|dwarf_macinfo_buffer
operator|+
name|dwarf_macinfo_size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|dwarf_macinfo_record_type
name|macinfo_type
decl_stmt|;
comment|/* Do we at least have room for a macinfo type byte?  */
if|if
condition|(
name|mac_ptr
operator|>=
name|mac_end
condition|)
block|{
name|dwarf2_macros_too_long_complaint
argument_list|()
expr_stmt|;
return|return;
block|}
name|macinfo_type
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|)
expr_stmt|;
name|mac_ptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|macinfo_type
condition|)
block|{
comment|/* A zero macinfo type indicates the end of the macro              information.  */
case|case
literal|0
case|:
return|return;
case|case
name|DW_MACINFO_define
case|:
case|case
name|DW_MACINFO_undef
case|:
block|{
name|int
name|bytes_read
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
name|line
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|mac_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|body
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|mac_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|current_file
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"debug info gives macro %s outside of any file: %s"
argument_list|,
name|macinfo_type
operator|==
name|DW_MACINFO_define
condition|?
literal|"definition"
else|:
name|macinfo_type
operator|==
name|DW_MACINFO_undef
condition|?
literal|"undefinition"
else|:
literal|"something-or-other"
argument_list|,
name|body
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|macinfo_type
operator|==
name|DW_MACINFO_define
condition|)
name|parse_macro_definition
argument_list|(
name|current_file
argument_list|,
name|line
argument_list|,
name|body
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|macinfo_type
operator|==
name|DW_MACINFO_undef
condition|)
name|macro_undef
argument_list|(
name|current_file
argument_list|,
name|line
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_MACINFO_start_file
case|:
block|{
name|int
name|bytes_read
decl_stmt|;
name|int
name|line
decl_stmt|,
name|file
decl_stmt|;
name|line
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|mac_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|file
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|mac_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|current_file
operator|=
name|macro_start_file
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|current_file
argument_list|,
name|comp_dir
argument_list|,
name|lh
argument_list|,
name|cu
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_MACINFO_end_file
case|:
if|if
condition|(
operator|!
name|current_file
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"macro debug info has an unmatched `close_file' directive"
argument_list|)
expr_stmt|;
else|else
block|{
name|current_file
operator|=
name|current_file
operator|->
name|included_by
expr_stmt|;
if|if
condition|(
operator|!
name|current_file
condition|)
block|{
name|enum
name|dwarf_macinfo_record_type
name|next_type
decl_stmt|;
comment|/* GCC circa March 2002 doesn't produce the zero                      type byte marking the end of the compilation                      unit.  Complain if it's not there, but exit no                      matter what.  */
comment|/* Do we at least have room for a macinfo type byte?  */
if|if
condition|(
name|mac_ptr
operator|>=
name|mac_end
condition|)
block|{
name|dwarf2_macros_too_long_complaint
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* We don't increment mac_ptr here, so this is just                      a look-ahead.  */
name|next_type
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_type
operator|!=
literal|0
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"no terminating 0-type entry for macros in `.debug_macinfo' section"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|DW_MACINFO_vendor_ext
case|:
block|{
name|int
name|bytes_read
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|constant
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|mac_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|string
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|mac_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|mac_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* We don't recognize any vendor extensions.  */
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check if the attribute's form is a DW_FORM_block*    if so return true else false. */
end_comment

begin_function
specifier|static
name|int
name|attr_form_is_block
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|)
block|{
return|return
operator|(
name|attr
operator|==
name|NULL
condition|?
literal|0
else|:
name|attr
operator|->
name|form
operator|==
name|DW_FORM_block1
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_block2
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_block4
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_block
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_symbol_mark_computed
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|dwarf2_cu
modifier|*
name|cu
parameter_list|)
block|{
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data4
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data8
condition|)
block|{
name|struct
name|dwarf2_loclist_baton
modifier|*
name|baton
decl_stmt|;
name|baton
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|cu
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_loclist_baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|objfile
operator|=
name|cu
operator|->
name|objfile
expr_stmt|;
comment|/* We don't know how long the location list is, but make sure we 	 don't run off the edge of the section.  */
name|baton
operator|->
name|size
operator|=
name|dwarf_loc_size
operator|-
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|baton
operator|->
name|data
operator|=
name|dwarf_loc_buffer
operator|+
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|baton
operator|->
name|base_address
operator|=
name|cu
operator|->
name|header
operator|.
name|base_address
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|header
operator|.
name|base_known
operator|==
literal|0
condition|)
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"Location list used without specifying the CU base address."
argument_list|)
expr_stmt|;
name|SYMBOL_OPS
argument_list|(
name|sym
argument_list|)
operator|=
operator|&
name|dwarf2_loclist_funcs
expr_stmt|;
name|SYMBOL_LOCATION_BATON
argument_list|(
name|sym
argument_list|)
operator|=
name|baton
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dwarf2_locexpr_baton
modifier|*
name|baton
decl_stmt|;
name|baton
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|cu
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_locexpr_baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|objfile
operator|=
name|cu
operator|->
name|objfile
expr_stmt|;
if|if
condition|(
name|attr_form_is_block
argument_list|(
name|attr
argument_list|)
condition|)
block|{
comment|/* Note that we're just copying the block's data pointer 	     here, not the actual data.  We're still pointing into the 	     dwarf_info_buffer for SYM's objfile; right now we never 	     release that buffer, but when we do clean up properly 	     this may need to change.  */
name|baton
operator|->
name|size
operator|=
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|->
name|size
expr_stmt|;
name|baton
operator|->
name|data
operator|=
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|dwarf2_invalid_attrib_class_complaint
argument_list|(
literal|"location description"
argument_list|,
name|SYMBOL_NATURAL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|SYMBOL_OPS
argument_list|(
name|sym
argument_list|)
operator|=
operator|&
name|dwarf2_locexpr_funcs
expr_stmt|;
name|SYMBOL_LOCATION_BATON
argument_list|(
name|sym
argument_list|)
operator|=
name|baton
expr_stmt|;
block|}
block|}
end_function

end_unit

