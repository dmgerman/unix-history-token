begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Java language support routines for GDB, the GNU debugger.    Copyright 1997, 1998, 1999, 2000, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"jv-lang.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_int_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_byte_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_short_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_long_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_boolean_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_char_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_float_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_double_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_void_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_java_language
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|java_demangled_signature_length
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|java_demangled_signature_copy
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symtab
modifier|*
name|get_java_class_symtab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_java_utf8_name
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|,
name|struct
name|value
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|java_class_is_primitive
parameter_list|(
name|struct
name|value
modifier|*
name|clas
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|java_value_string
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|java_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This objfile contains symtabs that have been dynamically created    to record dynamically loaded Java classes and dynamically    compiled java methods. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objfile
modifier|*
name|dynamics_objfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|java_link_class_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FIXME: carlton/2003-02-04: This is the main or only caller of    allocate_objfile with first argument NULL; as a result, this code    breaks every so often.  Somebody should write a test case that    exercises GDB in various ways (e.g. something involving loading a    dynamic library) after this code has been called.  */
end_comment

begin_function
specifier|static
name|struct
name|objfile
modifier|*
name|get_dynamics_objfile
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dynamics_objfile
operator|==
name|NULL
condition|)
block|{
name|dynamics_objfile
operator|=
name|allocate_objfile
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|dynamics_objfile
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* symtab contains classes read from the inferior. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|class_symtab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|free_class_block
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|get_java_class_symtab
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|class_symtab
operator|==
name|NULL
condition|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|get_dynamics_objfile
argument_list|()
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
name|class_symtab
operator|=
name|allocate_symtab
argument_list|(
literal|"<java-classes>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|class_symtab
operator|->
name|language
operator|=
name|language_java
expr_stmt|;
name|bv
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BLOCKVECTOR
argument_list|(
name|class_symtab
argument_list|)
operator|=
name|bv
expr_stmt|;
comment|/* Allocate dummy STATIC_BLOCK. */
name|bl
operator|=
name|allocate_block
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|BLOCK_DICT
argument_list|(
name|bl
argument_list|)
operator|=
name|dict_create_linear
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
comment|/* Allocate GLOBAL_BLOCK.  */
name|bl
operator|=
name|allocate_block
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|BLOCK_DICT
argument_list|(
name|bl
argument_list|)
operator|=
name|dict_create_hashed_expandable
argument_list|()
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
name|class_symtab
operator|->
name|free_func
operator|=
name|free_class_block
expr_stmt|;
block|}
return|return
name|class_symtab
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_class_symtab_symbol
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|symtab
init|=
name|get_java_class_symtab
argument_list|()
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
decl_stmt|;
name|dict_add_symbol
argument_list|(
name|BLOCK_DICT
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|add_class_symbol
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|add_class_symbol
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dynamics_objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_java
expr_stmt|;
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
comment|/*  SYMBOL_VALUE (sym) = valu; */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_DOMAIN
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Free the dynamic symbols block.  */
end_comment

begin_function
specifier|static
name|void
name|free_class_block
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|bl
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
decl_stmt|;
name|dict_free
argument_list|(
name|BLOCK_DICT
argument_list|(
name|bl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|type
modifier|*
name|java_lookup_class
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|expression_context_block
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
if|#
directive|if
literal|0
block|CORE_ADDR addr;   if (called from parser)     {       call lookup_class (or similar) in inferior;       if not       found: 	return NULL;       addr = found in inferior;     }   else     addr = 0;   struct type *type;   type = alloc_type (objfile);   TYPE_CODE (type) = TYPE_CODE_STRUCT;   INIT_CPLUS_SPECIFIC (type);   TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),&objfile->objfile_obstack);   TYPE_FLAGS (type) |= TYPE_FLAG_STUB;   TYPE ? = addr;   return type;
else|#
directive|else
comment|/* FIXME - should search inferior's symbol table. */
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a nul-terminated string (allocated on OBSTACK) for    a name given by NAME (which has type Utf8Const*). */
end_comment

begin_function
name|char
modifier|*
name|get_java_utf8_name
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|,
name|struct
name|value
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|chrs
decl_stmt|;
name|struct
name|value
modifier|*
name|temp
init|=
name|name
decl_stmt|;
name|int
name|name_length
decl_stmt|;
name|CORE_ADDR
name|data_addr
decl_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"length"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|name_length
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|data_addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|temp
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|temp
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|chrs
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
name|name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chrs
index|[
name|name_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|read_memory
argument_list|(
name|data_addr
argument_list|,
name|chrs
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
return|return
name|chrs
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|java_class_from_object
parameter_list|(
name|struct
name|value
modifier|*
name|obj_val
parameter_list|)
block|{
comment|/* This is all rather inefficient, since the offsets of vtable and      class are fixed.  FIXME */
name|struct
name|value
modifier|*
name|vtable_val
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|obj_val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|obj_val
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|obj_val
operator|=
name|value_at
argument_list|(
name|get_java_object_type
argument_list|()
argument_list|,
name|value_as_address
argument_list|(
name|obj_val
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vtable_val
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|obj_val
argument_list|,
name|NULL
argument_list|,
literal|"vtable"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|vtable_val
argument_list|,
name|NULL
argument_list|,
literal|"class"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check if CLASS_IS_PRIMITIVE(value of clas): */
end_comment

begin_function
specifier|static
name|int
name|java_class_is_primitive
parameter_list|(
name|struct
name|value
modifier|*
name|clas
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|vtable
init|=
name|value_struct_elt
argument_list|(
operator|&
name|clas
argument_list|,
name|NULL
argument_list|,
literal|"vtable"
argument_list|,
name|NULL
argument_list|,
literal|"struct"
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|i
init|=
name|value_as_address
argument_list|(
name|vtable
argument_list|)
decl_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x7fffffff
argument_list|)
operator|==
operator|(
name|int
operator|)
literal|0x7fffffff
return|;
block|}
end_function

begin_comment
comment|/* Read a GCJ Class object, and generated a gdb (TYPE_CODE_STRUCT) type. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|type_from_class
parameter_list|(
name|struct
name|value
modifier|*
name|clas
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|value
modifier|*
name|temp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|value
modifier|*
name|utf8_name
decl_stmt|;
name|char
modifier|*
name|nptr
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|int
name|is_array
init|=
literal|0
decl_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|value_logical_not
argument_list|(
name|clas
argument_list|)
condition|)
return|return
name|NULL
return|;
name|clas
operator|=
name|value_ind
argument_list|(
name|clas
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|clas
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|clas
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|get_java_class_symtab ();   bl = BLOCKVECTOR_BLOCK (BLOCKVECTOR (class_symtab), GLOBAL_BLOCK);   ALL_BLOCK_SYMBOLS (block, iter, sym)     {       if (SYMBOL_VALUE_ADDRESS (sym) == addr) 	return SYMBOL_TYPE (sym);     }
endif|#
directive|endif
name|objfile
operator|=
name|get_dynamics_objfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|java_class_is_primitive
argument_list|(
name|clas
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|sig
decl_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
name|sig
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"method_count"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
return|return
name|java_primitive_type
argument_list|(
name|value_as_long
argument_list|(
name|sig
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get Class name. */
comment|/* if clasloader non-null, prepend loader address. FIXME */
name|temp
operator|=
name|clas
expr_stmt|;
name|utf8_name
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"name"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_java_utf8_name
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|utf8_name
argument_list|)
expr_stmt|;
for|for
control|(
name|nptr
operator|=
name|name
init|;
operator|*
name|nptr
operator|!=
literal|0
condition|;
name|nptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|nptr
operator|==
literal|'/'
condition|)
operator|*
name|nptr
operator|=
literal|'.'
expr_stmt|;
block|}
name|type
operator|=
name|java_lookup_class
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
return|return
name|type
return|;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|signature
init|=
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|java_demangled_signature_length
argument_list|(
name|signature
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|>
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|java_demangled_signature_copy
argument_list|(
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|is_array
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
comment|/* Set array element type. */
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"methods"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
name|add_class_symtab_symbol
argument_list|(
name|add_class_symbol
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|java_link_class_type
argument_list|(
name|type
argument_list|,
name|clas
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fill in class TYPE with data from the CLAS value. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|java_link_class_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|clas
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|unqualified_name
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|ninterfaces
decl_stmt|,
name|nfields
decl_stmt|,
name|nmethods
decl_stmt|;
name|int
name|type_is_object
init|=
literal|0
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|fn_fields
decl_stmt|;
name|struct
name|fn_fieldlist
modifier|*
name|fn_fieldlists
decl_stmt|;
name|struct
name|value
modifier|*
name|fields
decl_stmt|;
name|struct
name|value
modifier|*
name|methods
decl_stmt|;
name|struct
name|value
modifier|*
name|method
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|field
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|get_dynamics_objfile
argument_list|()
decl_stmt|;
name|struct
name|type
modifier|*
name|tsuper
decl_stmt|;
name|unqualified_name
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|unqualified_name
operator|==
name|NULL
condition|)
name|unqualified_name
operator|=
name|name
expr_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"superclass"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"java.lang.Object"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tsuper
operator|=
name|get_java_object_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|tsuper
operator|&&
name|TYPE_CODE
argument_list|(
name|tsuper
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|tsuper
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|tsuper
argument_list|)
expr_stmt|;
name|type_is_object
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|tsuper
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|ninterfaces
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|temp
operator|=
name|clas
expr_stmt|;
name|ninterfaces
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"interface_len"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|tsuper
operator|==
name|NULL
condition|?
literal|0
else|:
literal|1
operator|)
operator|+
name|ninterfaces
expr_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
name|nfields
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"field_count"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
name|nfields
operator|+=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
comment|/* Add one for dummy "class" field. */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsuper
operator|!=
name|NULL
condition|)
block|{
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|tsuper
expr_stmt|;
if|if
condition|(
name|type_is_object
condition|)
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
operator|&&
name|name
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|']'
operator|&&
name|tsuper
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|tsuper
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* size with "length" */
block|}
else|else
block|{
name|temp
operator|=
name|clas
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"size_in_bytes"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|value_as_long
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
name|NULL
expr_stmt|;
name|nfields
operator|--
expr_stmt|;
comment|/* First set up dummy "class" field. */
name|SET_FIELD_PHYSADDR
argument_list|(
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|clas
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|clas
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
literal|"class"
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
expr_stmt|;
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|nfields
condition|;
name|i
operator|++
control|)
block|{
name|int
name|accflags
decl_stmt|;
name|int
name|boffset
decl_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL
condition|)
block|{
name|temp
operator|=
name|clas
expr_stmt|;
name|fields
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"fields"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|field
operator|=
name|value_ind
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Re-use field value for next field. */
name|VALUE_ADDRESS
argument_list|(
name|field
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|temp
operator|=
name|field
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"name"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|get_java_utf8_name
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|field
expr_stmt|;
name|accflags
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"accflags"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|field
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"info"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|boffset
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"boffset"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|accflags
operator|&
literal|0x0001
condition|)
comment|/* public access */
block|{
comment|/* ??? */
block|}
if|if
condition|(
name|accflags
operator|&
literal|0x0002
condition|)
comment|/* private access */
block|{
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accflags
operator|&
literal|0x0004
condition|)
comment|/* protected access */
block|{
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accflags
operator|&
literal|0x0008
condition|)
comment|/* ACC_STATIC */
name|SET_FIELD_PHYSADDR
argument_list|(
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|boffset
argument_list|)
expr_stmt|;
else|else
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
literal|8
operator|*
name|boffset
expr_stmt|;
if|if
condition|(
name|accflags
operator|&
literal|0x8000
condition|)
comment|/* FIELD_UNRESOLVED_FLAG */
block|{
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|get_java_object_type
argument_list|()
expr_stmt|;
comment|/* FIXME */
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|ftype
decl_stmt|;
name|temp
operator|=
name|field
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"type"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|ftype
operator|=
name|lookup_pointer_type
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|ftype
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|clas
expr_stmt|;
name|nmethods
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"method_count"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|nmethods
expr_stmt|;
name|j
operator|=
name|nmethods
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
expr_stmt|;
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dynamics_objfile
operator|->
name|objfile_obstack
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fn_fields
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fn_fieldlists
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|alloca
argument_list|(
name|nmethods
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|methods
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmethods
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|mname
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL
condition|)
block|{
name|temp
operator|=
name|clas
expr_stmt|;
name|methods
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"methods"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|method
operator|=
name|value_ind
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Re-use method value for next method. */
name|VALUE_ADDRESS
argument_list|(
name|method
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|method
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get method name. */
name|temp
operator|=
name|method
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"name"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|mname
operator|=
name|get_java_utf8_name
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mname
argument_list|,
literal|"<init>"
argument_list|)
operator|==
literal|0
condition|)
name|mname
operator|=
name|unqualified_name
expr_stmt|;
comment|/* Check for an existing method with the same name.        * This makes building the fn_fieldslists an O(nmethods**2)        * operation.  That could be using hashing, but I doubt it        * is worth it.  Note that we do maintain the order of methods        * in the inferior's Method table (as long as that is grouped        * by method name), which I think is desirable.  --PB */
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|j
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
block|{
comment|/* No match - new method name. */
name|j
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|++
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|name
operator|=
name|mname
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|fn_fields
operator|=
operator|&
name|fn_fields
index|[
name|i
index|]
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|mname
argument_list|,
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found an existing method with the same name. */
name|int
name|l
decl_stmt|;
if|if
condition|(
name|mname
operator|!=
name|unqualified_name
condition|)
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|mname
operator|=
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|name
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|length
operator|++
expr_stmt|;
name|k
operator|=
name|i
operator|-
name|k
expr_stmt|;
comment|/* Index of new slot. */
comment|/* Shift intervening fn_fields (between k and i) down. */
for|for
control|(
name|l
operator|=
name|i
init|;
name|l
operator|>
name|k
condition|;
name|l
operator|--
control|)
name|fn_fields
index|[
name|l
index|]
operator|=
name|fn_fields
index|[
name|l
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|l
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
init|;
operator|--
name|l
operator|>
name|j
condition|;
control|)
name|fn_fieldlists
index|[
name|l
index|]
operator|.
name|fn_fields
operator|++
expr_stmt|;
break|break;
block|}
name|k
operator|+=
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|length
expr_stmt|;
block|}
name|fn_fields
index|[
name|k
index|]
operator|.
name|physname
operator|=
literal|""
expr_stmt|;
name|fn_fields
index|[
name|k
index|]
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
name|fn_fields
index|[
name|k
index|]
operator|.
name|type
operator|=
name|make_function_type
argument_list|(
name|java_void_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME */
name|TYPE_CODE
argument_list|(
name|fn_fields
index|[
name|k
index|]
operator|.
name|type
argument_list|)
operator|=
name|TYPE_CODE_METHOD
expr_stmt|;
block|}
name|j
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dynamics_objfile
operator|->
name|objfile_obstack
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn_fieldlists
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|java_object_type
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|type
modifier|*
name|get_java_object_type
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|java_object_type
operator|==
name|NULL
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
literal|"java.lang.Object"
argument_list|,
name|NULL
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"cannot find java.lang.Object"
argument_list|)
expr_stmt|;
name|java_object_type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
return|return
name|java_object_type
return|;
block|}
end_function

begin_function
name|int
name|get_java_object_header_size
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|objtype
init|=
name|get_java_object_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|objtype
operator|==
name|NULL
condition|)
return|return
operator|(
literal|2
operator|*
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
operator|)
return|;
else|else
return|return
name|TYPE_LENGTH
argument_list|(
name|objtype
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|is_object_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|struct
name|type
modifier|*
name|ttype
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ttype
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|TYPE_N_BASECLASSES
argument_list|(
name|ttype
argument_list|)
operator|>
literal|0
condition|)
name|ttype
operator|=
name|TYPE_BASECLASS
argument_list|(
name|ttype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"java.lang.Object"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|name
operator|=
name|TYPE_NFIELDS
argument_list|(
name|ttype
argument_list|)
operator|>
literal|0
condition|?
name|TYPE_FIELD_NAME
argument_list|(
name|ttype
argument_list|,
literal|0
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vtable"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|java_object_type
operator|==
name|NULL
condition|)
name|java_object_type
operator|=
name|type
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|java_primitive_type
parameter_list|(
name|int
name|signature
parameter_list|)
block|{
switch|switch
condition|(
name|signature
condition|)
block|{
case|case
literal|'B'
case|:
return|return
name|java_byte_type
return|;
case|case
literal|'S'
case|:
return|return
name|java_short_type
return|;
case|case
literal|'I'
case|:
return|return
name|java_int_type
return|;
case|case
literal|'J'
case|:
return|return
name|java_long_type
return|;
case|case
literal|'Z'
case|:
return|return
name|java_boolean_type
return|;
case|case
literal|'C'
case|:
return|return
name|java_char_type
return|;
case|case
literal|'F'
case|:
return|return
name|java_float_type
return|;
case|case
literal|'D'
case|:
return|return
name|java_double_type
return|;
case|case
literal|'V'
case|:
return|return
name|java_void_type
return|;
block|}
name|error
argument_list|(
literal|"unknown signature '%c' for primitive type"
argument_list|,
operator|(
name|char
operator|)
name|signature
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If name[0 .. namelen-1] is the name of a primitive Java type,    return that type.  Otherwise, return NULL. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|java_primitive_type_from_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"byte"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_byte_type
return|;
if|if
condition|(
name|namelen
operator|==
literal|7
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"boolean"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_boolean_type
return|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"char"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_char_type
return|;
case|case
literal|'d'
case|:
if|if
condition|(
name|namelen
operator|==
literal|6
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"double"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_double_type
return|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|namelen
operator|==
literal|5
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"float"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_float_type
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|namelen
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"int"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_int_type
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"long"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_long_type
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|namelen
operator|==
literal|5
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"short"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_short_type
return|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"void"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_void_type
return|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the length (in bytes) of demangled name of the Java type    signature string SIGNATURE. */
end_comment

begin_function
specifier|static
name|int
name|java_demangled_signature_length
parameter_list|(
name|char
modifier|*
name|signature
parameter_list|)
block|{
name|int
name|array
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|signature
operator|==
literal|'['
condition|;
name|signature
operator|++
control|)
name|array
operator|+=
literal|2
expr_stmt|;
comment|/* Two chars for "[]". */
switch|switch
condition|(
name|signature
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'L'
case|:
comment|/* Subtract 2 for 'L' and ';'. */
return|return
name|strlen
argument_list|(
name|signature
argument_list|)
operator|-
literal|2
operator|+
name|array
return|;
default|default:
return|return
name|strlen
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_primitive_type
argument_list|(
name|signature
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
operator|+
name|array
return|;
block|}
block|}
end_function

begin_comment
comment|/* Demangle the Java type signature SIGNATURE, leaving the result in RESULT. */
end_comment

begin_function
specifier|static
name|void
name|java_demangled_signature_copy
parameter_list|(
name|char
modifier|*
name|result
parameter_list|,
name|char
modifier|*
name|signature
parameter_list|)
block|{
name|int
name|array
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|*
name|signature
operator|==
literal|'['
condition|)
block|{
name|array
operator|++
expr_stmt|;
name|signature
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|signature
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'L'
case|:
comment|/* Subtract 2 for 'L' and ';', but add 1 for final nul. */
name|signature
operator|++
expr_stmt|;
name|ptr
operator|=
name|result
expr_stmt|;
for|for
control|(
init|;
operator|*
name|signature
operator|!=
literal|';'
operator|&&
operator|*
name|signature
operator|!=
literal|'\0'
condition|;
name|signature
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|signature
operator|==
literal|'/'
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
else|else
operator|*
name|ptr
operator|++
operator|=
operator|*
name|signature
expr_stmt|;
block|}
break|break;
default|default:
name|ptr
operator|=
name|TYPE_NAME
argument_list|(
name|java_primitive_type
argument_list|(
name|signature
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|result
operator|+
name|i
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|--
name|array
operator|>=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the demangled name of the Java type signature string SIGNATURE,    as a freshly allocated copy. */
end_comment

begin_function
name|char
modifier|*
name|java_demangle_type_signature
parameter_list|(
name|char
modifier|*
name|signature
parameter_list|)
block|{
name|int
name|length
init|=
name|java_demangled_signature_length
argument_list|(
name|signature
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|java_demangled_signature_copy
argument_list|(
name|result
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|result
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the type of TYPE followed by DIMS pairs of [ ].    If DIMS == 0, TYPE is returned. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|java_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|dims
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
while|while
condition|(
name|dims
operator|--
operator|>
literal|0
condition|)
block|{
name|range_type
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME  This is bogus!  Java arrays are not gdb arrays! */
name|type
operator|=
name|create_array_type
argument_list|(
name|NULL
argument_list|,
name|type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Create a Java string in the inferior from a (Utf8) literal. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|java_value_string
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|error
argument_list|(
literal|"not implemented - java_value_string"
argument_list|)
expr_stmt|;
comment|/* FIXME */
block|}
end_function

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific. */
end_comment

begin_function
specifier|static
name|void
name|java_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|fputc_filtered
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\u%.4x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|evaluate_subexp_java
parameter_list|(
name|struct
name|type
modifier|*
name|expect_type
parameter_list|,
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|enum
name|noside
name|noside
parameter_list|)
block|{
name|int
name|pc
init|=
operator|*
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|exp_opcode
name|op
init|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
decl_stmt|;
name|struct
name|value
modifier|*
name|arg1
decl_stmt|;
name|struct
name|value
modifier|*
name|arg2
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_IND
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|standard
goto|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_java
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_object_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
name|type_from_class
argument_list|(
name|java_class_from_object
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_ind
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|BINOP_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
comment|/* If the user attempts to subscript something that is not an          array or pointer type (like a plain int variable for example),          then report this as an error. */
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|=
name|name
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|i
operator|>
literal|2
operator|&&
name|name
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
name|CORE_ADDR
name|address
decl_stmt|;
name|long
name|length
decl_stmt|,
name|index
decl_stmt|;
name|struct
name|type
modifier|*
name|el_type
decl_stmt|;
name|char
name|buf4
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|value
modifier|*
name|clas
init|=
name|java_class_from_object
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|temp
init|=
name|clas
decl_stmt|;
comment|/* Get CLASS_ELEMENT_TYPE of the array type. */
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"methods"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
expr_stmt|;
name|el_type
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|el_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|el_type
operator|=
name|lookup_pointer_type
argument_list|(
name|el_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|el_type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
name|address
operator|=
name|value_as_address
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|address
operator|+=
name|JAVA_OBJECT_SIZE
expr_stmt|;
name|read_memory
argument_list|(
name|address
argument_list|,
name|buf4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|long
operator|)
name|extract_signed_integer
argument_list|(
name|buf4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|long
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|length
operator|||
name|index
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"array index (%ld) out of bounds (length: %ld)"
argument_list|,
name|index
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|address
operator|=
operator|(
name|address
operator|+
literal|4
operator|)
operator|+
name|index
operator|*
name|TYPE_LENGTH
argument_list|(
name|el_type
argument_list|)
expr_stmt|;
return|return
name|value_at
argument_list|(
name|el_type
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot subscript requested type"
argument_list|)
expr_stmt|;
case|case
name|OP_STRING
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|i
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|java_value_string
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|i
argument_list|)
return|;
case|case
name|STRUCTOP_STRUCT
case|:
name|arg1
operator|=
name|evaluate_subexp_standard
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Convert object field (such as TYPE.class) to reference. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|arg1
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
default|default:
break|break;
block|}
name|standard
label|:
return|return
name|evaluate_subexp_standard
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
name|nosideret
label|:
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|java_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
switch|switch
condition|(
name|typeid
condition|)
block|{
case|case
name|FT_VOID
case|:
return|return
name|java_void_type
return|;
case|case
name|FT_BOOLEAN
case|:
return|return
name|java_boolean_type
return|;
case|case
name|FT_CHAR
case|:
return|return
name|java_char_type
return|;
case|case
name|FT_FLOAT
case|:
return|return
name|java_float_type
return|;
case|case
name|FT_DBL_PREC_FLOAT
case|:
return|return
name|java_double_type
return|;
case|case
name|FT_BYTE
case|:
case|case
name|FT_SIGNED_CHAR
case|:
return|return
name|java_byte_type
return|;
case|case
name|FT_SHORT
case|:
case|case
name|FT_SIGNED_SHORT
case|:
return|return
name|java_short_type
return|;
case|case
name|FT_INTEGER
case|:
case|case
name|FT_SIGNED_INTEGER
case|:
return|return
name|java_int_type
return|;
case|case
name|FT_LONG
case|:
case|case
name|FT_SIGNED_LONG
case|:
return|return
name|java_long_type
return|;
block|}
return|return
name|c_create_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|typeid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|java_demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|mangled
parameter_list|,
name|int
name|options
parameter_list|)
block|{
return|return
name|cplus_demangle
argument_list|(
name|mangled
argument_list|,
name|options
operator||
name|DMGL_JAVA
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|op_print
name|java_op_print_tab
index|[]
init|=
block|{
block|{
literal|","
block|,
name|BINOP_COMMA
block|,
name|PREC_COMMA
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"||"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"&&"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"|"
block|,
name|BINOP_BITWISE_IOR
block|,
name|PREC_BITWISE_IOR
block|,
literal|0
block|}
block|,
block|{
literal|"^"
block|,
name|BINOP_BITWISE_XOR
block|,
name|PREC_BITWISE_XOR
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|BINOP_BITWISE_AND
block|,
name|PREC_BITWISE_AND
block|,
literal|0
block|}
block|,
block|{
literal|"=="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"!="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">>"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"<<"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
block|{">>>", BINOP_ ? ? ?, PREC_SHIFT, 0},
endif|#
directive|endif
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"%"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"!"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"~"
block|,
name|UNOP_COMPLEMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
block|{"instanceof", ? ? ?, ? ? ?, 0},
endif|#
directive|endif
block|{
literal|"++"
block|,
name|UNOP_PREINCREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
name|UNOP_PREDECREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|exp_descriptor
name|exp_descriptor_java
init|=
block|{
name|print_subexp_standard
block|,
name|operator_length_standard
block|,
name|op_name_standard
block|,
name|dump_subexp_body_standard
block|,
name|evaluate_subexp_java
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|java_language_defn
init|=
block|{
literal|"java"
block|,
comment|/* Language name */
name|language_java
block|,
name|c_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_java
block|,
name|java_parse
block|,
name|java_error
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|java_emit_char
block|,
comment|/* Function to print a single character */
name|java_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|java_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|java_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|java_value_print
block|,
comment|/* Print a top-level value */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|java_demangle
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|java_op_print_tab
block|,
comment|/* expression operators for printing */
literal|0
block|,
comment|/* not c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_java_language
parameter_list|(
name|void
parameter_list|)
block|{
name|java_int_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_short_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_long_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_byte_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"byte"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_boolean_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"boolean"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_char_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_float_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_double_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_void_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|java_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup code that should be run on every "run".    We should use make_run_cleanup to have this be called.    But will that mess up values in value histry?  FIXME */
end_comment

begin_function_decl
specifier|extern
name|void
name|java_rerun_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|java_rerun_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|class_symtab
operator|!=
name|NULL
condition|)
block|{
name|free_symtab
argument_list|(
name|class_symtab
argument_list|)
expr_stmt|;
comment|/* ??? */
name|class_symtab
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynamics_objfile
operator|!=
name|NULL
condition|)
block|{
name|free_objfile
argument_list|(
name|dynamics_objfile
argument_list|)
expr_stmt|;
name|dynamics_objfile
operator|=
name|NULL
expr_stmt|;
block|}
name|java_object_type
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

