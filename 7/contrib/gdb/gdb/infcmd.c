begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory-access and commands for "inferior" process, for GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"environ.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* Functions exported for general use, in inferior.h: */
end_comment

begin_function_decl
name|void
name|all_registers_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|registers_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|nexti_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stepi_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|continue_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|interrupt_target_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local functions: */
end_comment

begin_function_decl
specifier|static
name|void
name|nofp_registers_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_return_value
parameter_list|(
name|int
name|struct_return
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_command_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|until_next_command
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|until_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|path_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|path_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unset_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|float_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|detach_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disconnect_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unset_environment_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_environment_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|environment_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|program_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|signal_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jump_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|step_1
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|step_once
parameter_list|(
name|int
name|skip_subroutines
parameter_list|,
name|int
name|single_inst
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|step_1_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|next_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|step_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|run_no_args_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|go_command
parameter_list|(
name|char
modifier|*
name|line_no
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strip_bg_char
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_infcmd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|GO_USAGE
value|"Usage: go<location>\n"
end_define

begin_define
define|#
directive|define
name|ERROR_NO_INFERIOR
define|\
value|if (!target_has_execution) error ("The program is not being run.");
end_define

begin_comment
comment|/* String containing arguments to give to the program, separated by spaces.    Empty string (pointer to '\0') means no args.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inferior_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The inferior arguments as a vector.  If INFERIOR_ARGC is nonzero,    then we must compute INFERIOR_ARGS from this (via the target).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inferior_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|inferior_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name for default use for standard in/out in the inferior.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|inferior_io_terminal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid of our debugged inferior, or 0 if no inferior now.    Since various parts of infrun.c test this to see whether there is a program    being debugged it should be nonzero (currently 3 is used) for remote    debugging.  */
end_comment

begin_decl_stmt
name|ptid_t
name|inferior_ptid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last signal that the inferior received (why it stopped).  */
end_comment

begin_decl_stmt
name|enum
name|target_signal
name|stop_signal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address at which inferior stopped.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|stop_pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing status of breakpoint(s) that we have stopped at.  */
end_comment

begin_decl_stmt
name|bpstat
name|stop_bpstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating that a command has proceeded the inferior past the    current breakpoint.  */
end_comment

begin_decl_stmt
name|int
name|breakpoint_proceeded
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if stopped due to a step command.  */
end_comment

begin_decl_stmt
name|int
name|stop_step
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if stopped due to completion of a stack dummy routine.  */
end_comment

begin_decl_stmt
name|int
name|stop_stack_dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if stopped due to a random (unexpected) signal in inferior    process.  */
end_comment

begin_decl_stmt
name|int
name|stopped_by_random_signal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Range to single step within.    If this is nonzero, respond to a single-step signal    by continuing to step if the pc is in this range.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|step_range_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inclusive */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|step_range_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exclusive */
end_comment

begin_comment
comment|/* Stack frame address as of when stepping command was issued.    This is how we know when we step into a subroutine call,    and how to set the frame for the breakpoint used to step out.  */
end_comment

begin_decl_stmt
name|struct
name|frame_id
name|step_frame_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our notion of the current stack pointer.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|step_sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|step_over_calls_kind
name|step_over_calls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If stepping, nonzero means step count is> 1    so don't print frame next time inferior stops    if it stops due to stepping.  */
end_comment

begin_decl_stmt
name|int
name|step_multi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Environment to use for running inferior,    in format described in environ.h.  */
end_comment

begin_decl_stmt
name|struct
name|environ
modifier|*
name|inferior_environ
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Accessor routines. */
end_comment

begin_function
name|char
modifier|*
name|get_inferior_args
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inferior_argc
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|n
operator|=
name|gdbarch_construct_inferior_arguments
argument_list|(
name|current_gdbarch
argument_list|,
name|inferior_argc
argument_list|,
name|inferior_argv
argument_list|)
expr_stmt|;
name|old
operator|=
name|set_inferior_args
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inferior_args
operator|==
name|NULL
condition|)
name|inferior_args
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
name|inferior_args
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|set_inferior_args
parameter_list|(
name|char
modifier|*
name|newargs
parameter_list|)
block|{
name|char
modifier|*
name|saved_args
init|=
name|inferior_args
decl_stmt|;
name|inferior_args
operator|=
name|newargs
expr_stmt|;
name|inferior_argc
operator|=
literal|0
expr_stmt|;
name|inferior_argv
operator|=
literal|0
expr_stmt|;
return|return
name|saved_args
return|;
block|}
end_function

begin_function
name|void
name|set_inferior_args_vector
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|inferior_argc
operator|=
name|argc
expr_stmt|;
name|inferior_argv
operator|=
name|argv
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Notice when `set args' is run.  */
end_comment

begin_function
specifier|static
name|void
name|notice_args_set
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|inferior_argc
operator|=
literal|0
expr_stmt|;
name|inferior_argv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Notice when `show args' is run.  */
end_comment

begin_function
specifier|static
name|void
name|notice_args_read
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
comment|/* Might compute the value.  */
name|get_inferior_args
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute command-line string given argument vector.  This does the    same shell processing as fork_inferior.  */
end_comment

begin_function
name|char
modifier|*
name|construct_inferior_arguments
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|STARTUP_WITH_SHELL
condition|)
block|{
comment|/* This holds all the characters considered special to the 	 typical Unix shells.  We include `^' because the SunOS 	 /bin/sh treats it as a synonym for `|'.  */
name|char
modifier|*
name|special
init|=
literal|"\"!#$&*()\\|[]{}<>?'\"`~^; \t\n"
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* We over-compute the size.  It shouldn't matter.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|length
operator|+=
literal|2
operator|*
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
operator|+
literal|2
operator|*
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|out
operator|=
name|result
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|*
name|out
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Need to handle empty arguments specially.  */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|out
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|out
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|special
argument_list|,
operator|*
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
operator|*
name|out
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
block|}
block|}
block|}
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* In this case we can't handle arguments that contain spaces, 	 tabs, or newlines -- see breakup_args().  */
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|"can't handle command-line argument containing whitespace"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function detects whether or not a '&' character (indicating    background execution) has been added as *the last* of the arguments ARGS    of a command. If it has, it removes it and returns 1. Otherwise it    does nothing and returns 0. */
end_comment

begin_function
specifier|static
name|int
name|strip_bg_char
parameter_list|(
name|char
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|args
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
operator|(
operator|*
name|args
operator|+
name|strlen
argument_list|(
operator|*
name|args
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|args
argument_list|)
operator|>
literal|1
condition|)
block|{
do|do
name|p
operator|--
expr_stmt|;
do|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
do|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|args
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|tty_command
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|file
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"terminal name for running target process"
argument_list|)
expr_stmt|;
name|inferior_io_terminal
operator|=
name|savestring
argument_list|(
name|file
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
operator|&&
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"The program being debugged has been started already.\n\ Start it from the beginning? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Program not restarted."
argument_list|)
expr_stmt|;
name|target_kill
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_RESTART
argument_list|)
name|SOLIB_RESTART
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
block|}
name|clear_breakpoint_hit_counts
argument_list|()
expr_stmt|;
comment|/* Purge old solib objfiles. */
name|objfile_purge_solibs
argument_list|()
expr_stmt|;
name|do_run_cleanups
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* The comment here used to read, "The exec file is re-read every      time we do a generic_mourn_inferior, so we just have to worry      about the symbol file."  The `generic_mourn_inferior' function      gets called whenever the program exits.  However, suppose the      program exits, and *then* the executable file changes?  We need      to check again here.  Since reopen_exec_file doesn't do anything      if the timestamp hasn't changed, I don't see the harm.  */
name|reopen_exec_file
argument_list|()
expr_stmt|;
name|reread_symbols
argument_list|()
expr_stmt|;
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* We keep symbols from add-symbol-file, on the grounds that the      user might want to add some symbols before running the program      (right?).  But sometimes (dynamic loading where the user manually      introduces the new symbols with add-symbol-file), the code which      the symbols describe does not persist between runs.  Currently      the user has to manually nuke all symbols between runs if they      want them to go away (PR 2207).  This is probably reasonable.  */
if|if
condition|(
operator|!
name|args
condition|)
block|{
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
condition|)
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|async_exec
init|=
name|strip_bg_char
argument_list|(
operator|&
name|args
argument_list|)
decl_stmt|;
comment|/* If we get a request for running in the bg but the target          doesn't support it, error out. */
if|if
condition|(
name|event_loop_p
operator|&&
name|async_exec
operator|&&
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"Asynchronous execution not supported on this target."
argument_list|)
expr_stmt|;
comment|/* If we don't get a request of running in the bg, then we need          to simulate synchronous (fg) execution. */
if|if
condition|(
name|event_loop_p
operator|&&
operator|!
name|async_exec
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Simulate synchronous execution */
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
comment|/* If there were other args, beside '&', process them. */
if|if
condition|(
name|args
condition|)
block|{
name|char
modifier|*
name|old_args
init|=
name|set_inferior_args
argument_list|(
name|xstrdup
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
name|old_args
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_tty
condition|)
block|{
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|,
literal|"Starting program"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"execfile"
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|ui_out_spaces
argument_list|(
name|uiout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We call get_inferior_args() because we might need to compute 	 the value now.  */
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"infargs"
argument_list|,
name|get_inferior_args
argument_list|()
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ui_out_flush
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
block|}
comment|/* We call get_inferior_args() because we might need to compute      the value now.  */
name|target_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|get_inferior_args
argument_list|()
argument_list|,
name|environ_vector
argument_list|(
name|inferior_environ
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_no_args_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|old_args
init|=
name|set_inferior_args
argument_list|(
name|xstrdup
argument_list|(
literal|""
argument_list|)
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
name|old_args
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|continue_command
parameter_list|(
name|char
modifier|*
name|proc_count_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|async_exec
init|=
literal|0
decl_stmt|;
name|ERROR_NO_INFERIOR
expr_stmt|;
comment|/* Find out whether we must run in the background. */
if|if
condition|(
name|proc_count_exp
operator|!=
name|NULL
condition|)
name|async_exec
operator|=
name|strip_bg_char
argument_list|(
operator|&
name|proc_count_exp
argument_list|)
expr_stmt|;
comment|/* If we must run in the background, but the target can't do it,      error out. */
if|if
condition|(
name|event_loop_p
operator|&&
name|async_exec
operator|&&
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"Asynchronous execution not supported on this target."
argument_list|)
expr_stmt|;
comment|/* If we are not asked to run in the bg, then prepare to run in the      foreground, synchronously. */
if|if
condition|(
name|event_loop_p
operator|&&
operator|!
name|async_exec
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Simulate synchronous execution */
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
comment|/* If have argument (besides '&'), set proceed count of breakpoint      we stopped at.  */
if|if
condition|(
name|proc_count_exp
operator|!=
name|NULL
condition|)
block|{
name|bpstat
name|bs
init|=
name|stop_bpstat
decl_stmt|;
name|int
name|num
init|=
name|bpstat_num
argument_list|(
operator|&
name|bs
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|&&
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Not stopped at any breakpoint; argument ignored.\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|num
operator|!=
literal|0
condition|)
block|{
name|set_ignore_count
argument_list|(
name|num
argument_list|,
name|parse_and_eval_long
argument_list|(
name|proc_count_exp
argument_list|)
operator|-
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* set_ignore_count prints a message ending with a period. 	     So print two spaces before "Continuing.".  */
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|num
operator|=
name|bpstat_num
argument_list|(
operator|&
name|bs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Continuing.\n"
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Step until outside of current statement.  */
end_comment

begin_function
specifier|static
name|void
name|step_command
parameter_list|(
name|char
modifier|*
name|count_string
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|step_1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, but skip over subroutine calls as if single instructions.  */
end_comment

begin_function
specifier|static
name|void
name|next_command
parameter_list|(
name|char
modifier|*
name|count_string
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|step_1
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, but step only one instruction.  */
end_comment

begin_function
name|void
name|stepi_command
parameter_list|(
name|char
modifier|*
name|count_string
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|step_1
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nexti_command
parameter_list|(
name|char
modifier|*
name|count_string
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|step_1
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_longjmp_breakpoint_cleanup
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|step_1
parameter_list|(
name|int
name|skip_subroutines
parameter_list|,
name|int
name|single_inst
parameter_list|,
name|char
modifier|*
name|count_string
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
literal|0
decl_stmt|;
name|int
name|async_exec
init|=
literal|0
decl_stmt|;
name|ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
name|count_string
condition|)
name|async_exec
operator|=
name|strip_bg_char
argument_list|(
operator|&
name|count_string
argument_list|)
expr_stmt|;
comment|/* If we get a request for running in the bg but the target      doesn't support it, error out. */
if|if
condition|(
name|event_loop_p
operator|&&
name|async_exec
operator|&&
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"Asynchronous execution not supported on this target."
argument_list|)
expr_stmt|;
comment|/* If we don't get a request of running in the bg, then we need      to simulate synchronous (fg) execution. */
if|if
condition|(
name|event_loop_p
operator|&&
operator|!
name|async_exec
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Simulate synchronous execution */
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
name|count
operator|=
name|count_string
condition|?
name|parse_and_eval_long
argument_list|(
name|count_string
argument_list|)
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|single_inst
operator|||
name|skip_subroutines
condition|)
comment|/* leave si command alone */
block|{
name|enable_longjmp_breakpoint
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|disable_longjmp_breakpoint_cleanup
argument_list|,
literal|0
comment|/*ignore*/
argument_list|)
expr_stmt|;
else|else
name|make_exec_cleanup
argument_list|(
name|disable_longjmp_breakpoint_cleanup
argument_list|,
literal|0
comment|/*ignore*/
argument_list|)
expr_stmt|;
block|}
comment|/* In synchronous case, all is well, just use the regular for loop. */
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|frame
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
comment|/* Avoid coredump here.  Why tho? */
name|error
argument_list|(
literal|"No current frame"
argument_list|)
expr_stmt|;
name|step_frame_id
operator|=
name|get_frame_id
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|step_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|single_inst
condition|)
block|{
name|find_pc_line_pc_range
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|step_range_start
argument_list|,
operator|&
name|step_range_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_range_end
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|step_range_start
argument_list|,
operator|&
name|step_range_end
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot find bounds of current function"
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\ Single stepping until exit from function %s, \n\ which has no line number information.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Say we are stepping, but stop after one insn whatever it does.  */
name|step_range_start
operator|=
name|step_range_end
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|skip_subroutines
condition|)
comment|/* It is stepi. 		   Don't step over function calls, not even to functions lacking 		   line numbers.  */
name|step_over_calls
operator|=
name|STEP_OVER_NONE
expr_stmt|;
block|}
if|if
condition|(
name|skip_subroutines
condition|)
name|step_over_calls
operator|=
name|STEP_OVER_ALL
expr_stmt|;
name|step_multi
operator|=
operator|(
name|count
operator|>
literal|1
operator|)
expr_stmt|;
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stop_step
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|single_inst
operator|||
name|skip_subroutines
condition|)
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* In case of asynchronous target things get complicated, do only      one step for now, before returning control to the event loop. Let      the continuation figure out how many other steps we need to do,      and handle them one at the time, through step_once(). */
else|else
block|{
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
condition|)
name|step_once
argument_list|(
name|skip_subroutines
argument_list|,
name|single_inst
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after we are done with one step operation, to check whether    we need to step again, before we print the prompt and return control    to the user. If count is> 1, we will need to do one more call to    proceed(), via step_once(). Basically it is like step_once and    step_1_continuation are co-recursive. */
end_comment

begin_function
specifier|static
name|void
name|step_1_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|int
name|skip_subroutines
decl_stmt|;
name|int
name|single_inst
decl_stmt|;
name|skip_subroutines
operator|=
name|arg
operator|->
name|data
operator|.
name|integer
expr_stmt|;
name|single_inst
operator|=
name|arg
operator|->
name|next
operator|->
name|data
operator|.
name|integer
expr_stmt|;
name|count
operator|=
name|arg
operator|->
name|next
operator|->
name|next
operator|->
name|data
operator|.
name|integer
expr_stmt|;
if|if
condition|(
name|stop_step
condition|)
name|step_once
argument_list|(
name|skip_subroutines
argument_list|,
name|single_inst
argument_list|,
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|single_inst
operator|||
name|skip_subroutines
condition|)
name|do_exec_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do just one step operation. If count>1 we will have to set up a    continuation to be done after the target stops (after this one    step). This is useful to implement the 'step n' kind of commands, in    case of asynchronous targets. We had to split step_1 into two parts,    one to be done before proceed() and one afterwards. This function is    called in case of step n with n>1, after the first step operation has    been completed.*/
end_comment

begin_function
specifier|static
name|void
name|step_once
parameter_list|(
name|int
name|skip_subroutines
parameter_list|,
name|int
name|single_inst
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|continuation_arg
modifier|*
name|arg1
decl_stmt|;
name|struct
name|continuation_arg
modifier|*
name|arg2
decl_stmt|;
name|struct
name|continuation_arg
modifier|*
name|arg3
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|frame
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
comment|/* Avoid coredump here.  Why tho? */
name|error
argument_list|(
literal|"No current frame"
argument_list|)
expr_stmt|;
name|step_frame_id
operator|=
name|get_frame_id
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|step_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|single_inst
condition|)
block|{
name|find_pc_line_pc_range
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|step_range_start
argument_list|,
operator|&
name|step_range_end
argument_list|)
expr_stmt|;
comment|/* If we have no line info, switch to stepi mode.  */
if|if
condition|(
name|step_range_end
operator|==
literal|0
operator|&&
name|step_stop_if_no_debug
condition|)
block|{
name|step_range_start
operator|=
name|step_range_end
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|step_range_end
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|step_range_start
argument_list|,
operator|&
name|step_range_end
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot find bounds of current function"
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\ Single stepping until exit from function %s, \n\ which has no line number information.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Say we are stepping, but stop after one insn whatever it does.  */
name|step_range_start
operator|=
name|step_range_end
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|skip_subroutines
condition|)
comment|/* It is stepi. 	       Don't step over function calls, not even to functions lacking 	       line numbers.  */
name|step_over_calls
operator|=
name|STEP_OVER_NONE
expr_stmt|;
block|}
if|if
condition|(
name|skip_subroutines
condition|)
name|step_over_calls
operator|=
name|STEP_OVER_ALL
expr_stmt|;
name|step_multi
operator|=
operator|(
name|count
operator|>
literal|1
operator|)
expr_stmt|;
name|arg1
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg3
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|->
name|next
operator|=
name|arg2
expr_stmt|;
name|arg1
operator|->
name|data
operator|.
name|integer
operator|=
name|skip_subroutines
expr_stmt|;
name|arg2
operator|->
name|next
operator|=
name|arg3
expr_stmt|;
name|arg2
operator|->
name|data
operator|.
name|integer
operator|=
name|single_inst
expr_stmt|;
name|arg3
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|arg3
operator|->
name|data
operator|.
name|integer
operator|=
name|count
expr_stmt|;
name|add_intermediate_continuation
argument_list|(
name|step_1_continuation
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Continue program at specified address.  */
end_comment

begin_function
specifier|static
name|void
name|jump_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|fn
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sfn
decl_stmt|;
name|int
name|async_exec
init|=
literal|0
decl_stmt|;
name|ERROR_NO_INFERIOR
expr_stmt|;
comment|/* Find out whether we must run in the background. */
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|async_exec
operator|=
name|strip_bg_char
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If we must run in the background, but the target can't do it,      error out. */
if|if
condition|(
name|event_loop_p
operator|&&
name|async_exec
operator|&&
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"Asynchronous execution not supported on this target."
argument_list|)
expr_stmt|;
comment|/* If we are not asked to run in the bg, then prepare to run in the      foreground, synchronously. */
if|if
condition|(
name|event_loop_p
operator|&&
operator|!
name|async_exec
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Simulate synchronous execution */
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"starting address"
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_spec_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Unreasonable jump request"
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
operator|&&
name|sal
operator|.
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file has been specified."
argument_list|)
expr_stmt|;
name|resolve_sal_pc
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* May error out */
comment|/* See if we are trying to jump to another function. */
name|fn
operator|=
name|get_frame_function
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|sfn
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|!=
name|NULL
operator|&&
name|sfn
operator|!=
name|fn
condition|)
block|{
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Line %d is not in `%s'.  Jump anyway? "
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|sfn
operator|!=
name|NULL
condition|)
block|{
name|fixup_symbol_section
argument_list|(
name|sfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_is_overlay
argument_list|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|sfn
argument_list|)
argument_list|)
operator|&&
operator|!
name|section_is_mapped
argument_list|(
name|SYMBOL_BFD_SECTION
argument_list|(
name|sfn
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"WARNING!!!  Destination is in unmapped overlay!  Jump anyway? "
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
name|addr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Continuing at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
name|addr
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Go to line or address in current procedure */
end_comment

begin_function
specifier|static
name|void
name|go_command
parameter_list|(
name|char
modifier|*
name|line_no
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|line_no
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
operator|!
operator|*
name|line_no
condition|)
name|printf_filtered
argument_list|(
name|GO_USAGE
argument_list|)
expr_stmt|;
else|else
block|{
name|tbreak_command
argument_list|(
name|line_no
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|jump_command
argument_list|(
name|line_no
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Continue program giving it specified signal.  */
end_comment

begin_function
specifier|static
name|void
name|signal_command
parameter_list|(
name|char
modifier|*
name|signum_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Too dangerous.  */
name|ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
operator|!
name|signum_exp
condition|)
name|error_no_arg
argument_list|(
literal|"signal number"
argument_list|)
expr_stmt|;
comment|/* It would be even slicker to make signal names be valid expressions,      (the type could be "enum $signal" or some such), then the user could      assign them to convenience variables.  */
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oursig
operator|==
name|TARGET_SIGNAL_UNKNOWN
condition|)
block|{
comment|/* No, try numeric.  */
name|int
name|num
init|=
name|parse_and_eval_long
argument_list|(
name|signum_exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|oursig
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
else|else
name|oursig
operator|=
name|target_signal_from_command
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|oursig
operator|==
name|TARGET_SIGNAL_0
condition|)
name|printf_filtered
argument_list|(
literal|"Continuing with no signal.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Continuing with signal %s.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|oursig
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* "signal 0" should not get stuck if we are stopped at a breakpoint.      FIXME: Neither should "signal foo" but when I tried passing      (CORE_ADDR)-1 unconditionally I got a testsuite failure which I haven't      tried to track down yet.  */
name|proceed
argument_list|(
name|oursig
operator|==
name|TARGET_SIGNAL_0
condition|?
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
else|:
name|stop_pc
argument_list|,
name|oursig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Proceed until we reach a different source line with pc greater than    our current one or exit the function.  We skip calls in both cases.     Note that eventually this command should probably be changed so    that only source lines are printed out when we hit the breakpoint    we set.  This may involve changes to wait_for_inferior and the    proceed status code.  */
end_comment

begin_function
specifier|static
name|void
name|until_next_command
parameter_list|(
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|frame
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
comment|/* Step until either exited from this function or greater      than the current line (if in symbolic section) or pc (if      not). */
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|func
operator|=
name|find_pc_function
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|func
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Execution is not within a known function."
argument_list|)
expr_stmt|;
name|step_range_start
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
name|step_range_end
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|step_range_start
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|step_range_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
block|}
name|step_over_calls
operator|=
name|STEP_OVER_ALL
expr_stmt|;
name|step_frame_id
operator|=
name|get_frame_id
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|step_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
name|step_multi
operator|=
literal|0
expr_stmt|;
comment|/* Only one call to proceed */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|until_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|async_exec
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"The program is not running."
argument_list|)
expr_stmt|;
comment|/* Find out whether we must run in the background. */
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|async_exec
operator|=
name|strip_bg_char
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If we must run in the background, but the target can't do it,      error out. */
if|if
condition|(
name|event_loop_p
operator|&&
name|async_exec
operator|&&
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"Asynchronous execution not supported on this target."
argument_list|)
expr_stmt|;
comment|/* If we are not asked to run in the bg, then prepare to run in the      foreground, synchronously. */
if|if
condition|(
name|event_loop_p
operator|&&
operator|!
name|async_exec
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Simulate synchronous execution */
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arg
condition|)
name|until_break_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|until_next_command
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|advance_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|async_exec
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"The program is not running."
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|error_no_arg
argument_list|(
literal|"a location"
argument_list|)
expr_stmt|;
comment|/* Find out whether we must run in the background.  */
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|async_exec
operator|=
name|strip_bg_char
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If we must run in the background, but the target can't do it,      error out.  */
if|if
condition|(
name|event_loop_p
operator|&&
name|async_exec
operator|&&
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"Asynchronous execution not supported on this target."
argument_list|)
expr_stmt|;
comment|/* If we are not asked to run in the bg, then prepare to run in the      foreground, synchronously.  */
if|if
condition|(
name|event_loop_p
operator|&&
operator|!
name|async_exec
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Simulate synchronous execution.  */
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
name|until_break_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the result of a function at the end of a 'finish' command.  */
end_comment

begin_function
specifier|static
name|void
name|print_return_value
parameter_list|(
name|int
name|struct_return
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|ui_stream
modifier|*
name|stb
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|struct_return
condition|)
block|{
comment|/* The return value can be found in the inferior's registers.  */
name|value
operator|=
name|register_value_being_returned
argument_list|(
name|value_type
argument_list|,
name|stop_registers
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: cagney/2004-01-17: When both return_value and      extract_returned_value_address are available, should use that to      find the address of and then extract the returned value.  */
comment|/* FIXME: 2003-09-27: When returning from a nested inferior function      call, it's possible (with no help from the architecture vector)      to locate and return/print a "struct return" value.  This is just      a more complicated case of what is already being done in in the      inferior function call code.  In fact, when inferior function      calls are made async, this will likely be made the norm.  */
elseif|else
if|if
condition|(
name|gdbarch_return_value_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
comment|/* We cannot determine the contents of the structure because it is        on the stack, and we don't know where, since we did not        initiate the call, as opposed to the call_function_by_hand        case.  */
block|{
name|gdb_assert
argument_list|(
name|gdbarch_return_value
argument_list|(
name|current_gdbarch
argument_list|,
name|value_type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
name|RETURN_VALUE_STRUCT_CONVENTION
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Value returned has type: "
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"return-type"
argument_list|,
name|TYPE_NAME
argument_list|(
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" Cannot determine contents\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS_P
argument_list|()
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS
argument_list|(
name|stop_registers
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
name|error
argument_list|(
literal|"Function return value unknown."
argument_list|)
expr_stmt|;
name|value
operator|=
name|value_at
argument_list|(
name|value_type
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is "struct return" yet the value is being extracted,              presumably from registers, using EXTRACT_RETURN_VALUE.              This doesn't make sense.  Unfortunately, the legacy              interfaces allowed this behavior.  Sigh!  */
name|value
operator|=
name|allocate_value
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
comment|/* If the function returns void, don't bother fetching the 	     return value.  */
name|EXTRACT_RETURN_VALUE
argument_list|(
name|value_type
argument_list|,
name|stop_registers
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print it.  */
name|stb
operator|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"Value returned is "
argument_list|)
expr_stmt|;
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"gdb-result-var"
argument_list|,
literal|"$%d"
argument_list|,
name|record_latest_value
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|value
argument_list|,
name|stb
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"return-value"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stuff that needs to be done by the finish command after the target    has stopped.  In asynchronous mode, we wait for the target to stop    in the call to poll or select in the event loop, so it is    impossible to do all the stuff as part of the finish_command    function itself.  The only chance we have to complete this command    is in fetch_inferior_event, which is called by the event loop as    soon as it detects that the target has stopped. This function is    called via the cmd_continuation pointer.  */
end_comment

begin_function
specifier|static
name|void
name|finish_command_continuation
parameter_list|(
name|struct
name|continuation_arg
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|function
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|breakpoint
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|arg
operator|->
name|data
operator|.
name|pointer
expr_stmt|;
name|function
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|arg
operator|->
name|next
operator|->
name|data
operator|.
name|pointer
expr_stmt|;
name|cleanups
operator|=
operator|(
expr|struct
name|cleanup
operator|*
operator|)
name|arg
operator|->
name|next
operator|->
name|next
operator|->
name|data
operator|.
name|pointer
expr_stmt|;
if|if
condition|(
name|bpstat_find_breakpoint
argument_list|(
name|stop_bpstat
argument_list|,
name|breakpoint
argument_list|)
operator|!=
name|NULL
operator|&&
name|function
operator|!=
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|int
name|gcc_compiled
decl_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value_type
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"finish_command: function has no target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
block|{
name|do_exec_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
return|return;
block|}
name|CHECK_TYPEDEF
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
name|gcc_compiled
operator|=
name|BLOCK_GCC_COMPILED
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|struct_return
operator|=
name|using_struct_return
argument_list|(
name|value_type
argument_list|,
name|gcc_compiled
argument_list|)
expr_stmt|;
name|print_return_value
argument_list|(
name|struct_return
argument_list|,
name|value_type
argument_list|)
expr_stmt|;
block|}
name|do_exec_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "finish": Set a temporary breakpoint at the place the selected    frame will return to, then continue.  */
end_comment

begin_function
specifier|static
name|void
name|finish_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|struct
name|symbol
modifier|*
name|function
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|breakpoint
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|continuation_arg
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
name|int
name|async_exec
init|=
literal|0
decl_stmt|;
comment|/* Find out whether we must run in the background.  */
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|async_exec
operator|=
name|strip_bg_char
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If we must run in the background, but the target can't do it,      error out.  */
if|if
condition|(
name|event_loop_p
operator|&&
name|async_exec
operator|&&
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"Asynchronous execution not supported on this target."
argument_list|)
expr_stmt|;
comment|/* If we are not asked to run in the bg, then prepare to run in the      foreground, synchronously.  */
if|if
condition|(
name|event_loop_p
operator|&&
operator|!
name|async_exec
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Simulate synchronous execution.  */
name|async_disable_stdin
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"The \"finish\" command does not take any arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"The program is not running."
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecated_selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"\"finish\" not meaningful in the outermost frame."
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|get_frame_id
argument_list|(
name|frame
argument_list|)
argument_list|,
name|bp_finish
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
name|old_chain
operator|=
name|make_cleanup_delete_breakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
else|else
name|old_chain
operator|=
name|make_exec_cleanup_delete_breakpoint
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
comment|/* Find the function we will return from.  */
name|function
operator|=
name|find_pc_function
argument_list|(
name|get_frame_pc
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print info on the selected frame, including level number but not      source.  */
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Run till exit from "
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If running asynchronously and the target support asynchronous      execution, set things up for the rest of the finish command to be      completed later on, when gdb has detected that the target has      stopped, in fetch_inferior_event.  */
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
name|arg1
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg3
operator|=
operator|(
expr|struct
name|continuation_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|->
name|next
operator|=
name|arg2
expr_stmt|;
name|arg2
operator|->
name|next
operator|=
name|arg3
expr_stmt|;
name|arg3
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|arg1
operator|->
name|data
operator|.
name|pointer
operator|=
name|breakpoint
expr_stmt|;
name|arg2
operator|->
name|data
operator|.
name|pointer
operator|=
name|function
expr_stmt|;
name|arg3
operator|->
name|data
operator|.
name|pointer
operator|=
name|old_chain
expr_stmt|;
name|add_continuation
argument_list|(
name|finish_command_continuation
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
name|proceed_to_finish
operator|=
literal|1
expr_stmt|;
comment|/* We want stop_registers, please...  */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do this only if not running asynchronously or if the target      cannot do async execution.  Otherwise, complete this command when      the target actually stops, in fetch_inferior_event.  */
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
block|{
comment|/* Did we stop at our breakpoint?  */
if|if
condition|(
name|bpstat_find_breakpoint
argument_list|(
name|stop_bpstat
argument_list|,
name|breakpoint
argument_list|)
operator|!=
name|NULL
operator|&&
name|function
operator|!=
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|int
name|gcc_compiled
decl_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value_type
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"finish_command: function has no target type"
argument_list|)
expr_stmt|;
comment|/* FIXME: Shouldn't we do the cleanups before returning?  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
return|return;
name|CHECK_TYPEDEF
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
name|gcc_compiled
operator|=
name|BLOCK_GCC_COMPILED
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|struct_return
operator|=
name|using_struct_return
argument_list|(
name|value_type
argument_list|,
name|gcc_compiled
argument_list|)
expr_stmt|;
name|print_return_value
argument_list|(
name|struct_return
argument_list|,
name|value_type
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|program_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|bpstat
name|bs
init|=
name|stop_bpstat
decl_stmt|;
name|int
name|num
init|=
name|bpstat_num
argument_list|(
operator|&
name|bs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"The program being debugged is not being run.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|target_files_info
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Program stopped at %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|stop_pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_step
condition|)
name|printf_filtered
argument_list|(
literal|"It stopped after being stepped.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|!=
literal|0
condition|)
block|{
comment|/* There may be several breakpoints in the same place, so this          isn't as strange as it seems.  */
while|while
condition|(
name|num
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"It stopped at a breakpoint that has "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"since been deleted.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"It stopped at breakpoint %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|num
operator|=
name|bpstat_num
argument_list|(
operator|&
name|bs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"It stopped with signal %s, %s.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_signal
argument_list|)
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Type \"info stack\" or \"info registers\" "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"for more information.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|environment_info
parameter_list|(
name|char
modifier|*
name|var
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|var
condition|)
block|{
name|char
modifier|*
name|val
init|=
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|puts_filtered
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|puts_filtered
argument_list|(
literal|"Environment variable \""
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\" not defined.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|vector
init|=
name|environ_vector
argument_list|(
name|inferior_environ
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|vector
condition|)
block|{
name|puts_filtered
argument_list|(
operator|*
name|vector
operator|++
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_environment_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|val
decl_stmt|,
modifier|*
name|var
decl_stmt|;
name|int
name|nullset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"environment variable and value"
argument_list|)
expr_stmt|;
comment|/* Find seperation between variable name and value */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* We have both a space and an equals.  If the space is before the          equals, walk forward over the spaces til we see a nonspace           (possibly the equals). */
if|if
condition|(
name|p
operator|>
name|val
condition|)
while|while
condition|(
operator|*
name|val
operator|==
literal|' '
condition|)
name|val
operator|++
expr_stmt|;
comment|/* Now if the = is after the char following the spaces,          take the char following the spaces.  */
if|if
condition|(
name|p
operator|>
name|val
condition|)
name|p
operator|=
name|val
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"environment variable to set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|nullset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|arg
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* So that savestring below will work */
block|}
else|else
block|{
comment|/* Not setting variable value to null */
name|val
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|val
operator|==
literal|' '
operator|||
operator|*
name|val
operator|==
literal|'\t'
condition|)
name|val
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|!=
name|arg
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
name|var
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|p
operator|-
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullset
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Setting environment variable "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\"%s\" to null value.\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|set_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|set_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unset_environment_command
parameter_list|(
name|char
modifier|*
name|var
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|var
operator|==
literal|0
condition|)
block|{
comment|/* If there is no argument, delete all environment variables.          Ask for confirmation if reading from the terminal.  */
if|if
condition|(
operator|!
name|from_tty
operator|||
name|query
argument_list|(
literal|"Delete all environment variables? "
argument_list|)
condition|)
block|{
name|free_environ
argument_list|(
name|inferior_environ
argument_list|)
expr_stmt|;
name|inferior_environ
operator|=
name|make_environ
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|unset_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the execution path (PATH variable) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|path_var_name
index|[]
init|=
literal|"PATH"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|path_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|puts_filtered
argument_list|(
literal|"Executable and object file path: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|path_var_name
argument_list|)
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add zero or more directories to the front of the execution path.  */
end_comment

begin_function
specifier|static
name|void
name|path_command
parameter_list|(
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|exec_path
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|env
operator|=
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|path_var_name
argument_list|)
expr_stmt|;
comment|/* Can be null if path is not set */
if|if
condition|(
operator|!
name|env
condition|)
name|env
operator|=
literal|""
expr_stmt|;
name|exec_path
operator|=
name|xstrdup
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|mod_path
argument_list|(
name|dirname
argument_list|,
operator|&
name|exec_path
argument_list|)
expr_stmt|;
name|set_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|path_var_name
argument_list|,
name|exec_path
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|exec_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|path_info
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out the machine register regnum. If regnum is -1, print all    registers (print_all == 1) or all non-float and non-vector    registers (print_all == 0).     For most machines, having all_registers_info() print the    register(s) one per line is good enough.  If a different format is    required, (eg, for MIPS or Pyramid 90x, which both have lots of    regs), or there is an existing convention for showing all the    registers, define the architecture method PRINT_REGISTERS_INFO to    provide that format.  */
end_comment

begin_function
name|void
name|default_print_registers_info
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
name|print_all
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|numregs
init|=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|DEPRECATED_DO_REGISTERS_INFO_P
argument_list|()
condition|)
block|{
name|DEPRECATED_DO_REGISTERS_INFO
argument_list|(
name|regnum
argument_list|,
name|print_all
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numregs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Decide between printing all regs, non-float / vector regs, or          specific reg.  */
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|print_all
condition|)
block|{
if|if
condition|(
operator|!
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|i
argument_list|,
name|all_reggroup
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|i
argument_list|,
name|general_reggroup
argument_list|)
condition|)
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|i
operator|!=
name|regnum
condition|)
continue|continue;
block|}
comment|/* If the register name is empty, it is undefined for this          processor, so don't display anything.  */
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
operator|==
name|NULL
operator|||
operator|*
operator|(
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
continue|continue;
name|fputs_filtered
argument_list|(
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|15
operator|-
name|strlen
argument_list|(
name|REGISTER_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Get the data in raw format.  */
if|if
condition|(
operator|!
name|frame_register_read
argument_list|(
name|frame
argument_list|,
name|i
argument_list|,
name|raw_buffer
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"*value not available*\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* FIXME: cagney/2002-08-03: This code shouldn't be necessary.          The function frame_register_read() should have returned the          pre-cooked register so no conversion is necessary.  */
comment|/* Convert raw data to virtual format if necessary.  */
if|if
condition|(
name|DEPRECATED_REGISTER_CONVERTIBLE_P
argument_list|()
operator|&&
name|DEPRECATED_REGISTER_CONVERTIBLE
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|i
argument_list|,
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|i
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|virtual_buffer
argument_list|,
name|raw_buffer
argument_list|,
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If virtual format is floating, print it that way, and in raw          hex.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|int
name|j
decl_stmt|;
name|val_print
argument_list|(
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|i
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\t(raw 0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|idx
operator|=
name|j
expr_stmt|;
else|else
name|idx
operator|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
operator|-
literal|1
operator|-
name|j
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|raw_buffer
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Print the register in hex.  */
name|val_print
argument_list|(
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|i
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
literal|'x'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
comment|/* If not a vector register, print it also according to its              natural format.  */
if|if
condition|(
name|TYPE_VECTOR
argument_list|(
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|i
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|registers_info
parameter_list|(
name|char
modifier|*
name|addr_exp
parameter_list|,
name|int
name|fpregs
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|numregs
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"The program has no registers now."
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecated_selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr_exp
condition|)
block|{
name|gdbarch_print_registers_info
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdout
argument_list|,
name|deprecated_selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|addr_exp
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Keep skipping leading white space.  */
if|if
condition|(
name|isspace
argument_list|(
operator|(
operator|*
name|addr_exp
operator|)
argument_list|)
condition|)
block|{
name|addr_exp
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Discard any leading ``$''.  Check that there is something          resembling a register following it.  */
if|if
condition|(
name|addr_exp
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
name|addr_exp
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|(
operator|*
name|addr_exp
operator|)
argument_list|)
operator|||
operator|(
operator|*
name|addr_exp
operator|)
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Missing register name"
argument_list|)
expr_stmt|;
comment|/* Find the start/end of this register name/num/group.  */
name|start
operator|=
name|addr_exp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|addr_exp
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
operator|*
name|addr_exp
operator|)
argument_list|)
condition|)
name|addr_exp
operator|++
expr_stmt|;
name|end
operator|=
name|addr_exp
expr_stmt|;
comment|/* Figure out what we've found and display it.  */
comment|/* A register name?  */
block|{
name|int
name|regnum
init|=
name|frame_map_name_to_regnum
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
condition|)
block|{
name|gdbarch_print_registers_info
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdout
argument_list|,
name|deprecated_selected_frame
argument_list|,
name|regnum
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* A register number?  (how portable is this one?).  */
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|int
name|regnum
init|=
name|strtol
argument_list|(
name|start
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|endptr
operator|==
name|end
operator|&&
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
block|{
name|gdbarch_print_registers_info
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdout
argument_list|,
name|deprecated_selected_frame
argument_list|,
name|regnum
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* A register group?  */
block|{
name|struct
name|reggroup
modifier|*
name|group
decl_stmt|;
for|for
control|(
name|group
operator|=
name|reggroup_next
argument_list|(
name|current_gdbarch
argument_list|,
name|NULL
argument_list|)
init|;
name|group
operator|!=
name|NULL
condition|;
name|group
operator|=
name|reggroup_next
argument_list|(
name|current_gdbarch
argument_list|,
name|group
argument_list|)
control|)
block|{
comment|/* Don't bother with a length check.  Should the user 	       enter a short register group name, go with the first 	       group that matches.  */
if|if
condition|(
name|strncmp
argument_list|(
name|start
argument_list|,
name|reggroup_name
argument_list|(
name|group
argument_list|)
argument_list|,
name|end
operator|-
name|start
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|group
operator|!=
name|NULL
condition|)
block|{
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|gdbarch_register_reggroup_p
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|,
name|group
argument_list|)
condition|)
name|gdbarch_print_registers_info
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdout
argument_list|,
name|deprecated_selected_frame
argument_list|,
name|regnum
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|/* Nothing matched.  */
name|error
argument_list|(
literal|"Invalid register `%.*s'"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|all_registers_info
parameter_list|(
name|char
modifier|*
name|addr_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|registers_info
argument_list|(
name|addr_exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nofp_registers_info
parameter_list|(
name|char
modifier|*
name|addr_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|registers_info
argument_list|(
name|addr_exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_vector_info
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"The program has no registers now."
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecated_selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_print_vector_info_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
name|gdbarch_print_vector_info
argument_list|(
name|gdbarch
argument_list|,
name|file
argument_list|,
name|frame
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|regnum
decl_stmt|;
name|int
name|printed_something
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|vector_reggroup
argument_list|)
condition|)
block|{
name|printed_something
operator|=
literal|1
expr_stmt|;
name|gdbarch_print_registers_info
argument_list|(
name|gdbarch
argument_list|,
name|file
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|printed_something
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"No vector information\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vector_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|print_vector_info
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdout
argument_list|,
name|deprecated_selected_frame
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * TODO:  * Should save/restore the tty state since it might be that the  * program to be debugged was started on this tty and it wants  * the tty in some state other than what we want.  If it's running  * on another terminal or without a terminal, then saving and  * restoring the tty state is a harmless no-op.  * This only needs to be done if we are attaching to a process.  */
end_comment

begin_comment
comment|/*    attach_command --    takes a program started up outside of gdb and ``attaches'' to it.    This stops it cold in its tracks and allows us to start debugging it.    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
name|void
name|attach_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|full_exec_path
init|=
name|NULL
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Not for the faint of heart */
if|if
condition|(
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"A program is being debugged already.  Kill it? "
argument_list|)
condition|)
name|target_kill
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Not killed."
argument_list|)
expr_stmt|;
block|}
name|target_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Set up execution context to know that we should return from      wait_for_inferior as soon as the target reports a stop.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* No traps are generated when attaching to inferior under Mach 3      or GNU hurd.  */
ifndef|#
directive|ifndef
name|ATTACH_NO_WAIT
comment|/* Careful here. See comments in inferior.h.  Basically some OSes      don't ignore SIGSTOPs on continue requests anymore.  We need a      way for handle_inferior_event to reset the stop_signal variable      after an attach, and this is what STOP_QUIETLY_NO_SIGSTOP is for.  */
name|stop_soon
operator|=
name|STOP_QUIETLY_NO_SIGSTOP
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|stop_soon
operator|=
name|NO_STOP_QUIETLY
expr_stmt|;
endif|#
directive|endif
comment|/*    * If no exec file is yet known, try to determine it from the    * process itself.    */
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exec_file
condition|)
block|{
name|exec_file
operator|=
name|target_pid_to_exec_file
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
block|{
comment|/* It's possible we don't have a full path, but rather just a 	     filename.  Some targets, such as HP-UX, don't provide the 	     full path, sigh.  	     Attempt to qualify the filename against the source path. 	     (If that fails, we'll just fall back on the original 	     filename.  Not much more we can do...) 	   */
if|if
condition|(
operator|!
name|source_full_path_of
argument_list|(
name|exec_file
argument_list|,
operator|&
name|full_exec_path
argument_list|)
condition|)
name|full_exec_path
operator|=
name|savestring
argument_list|(
name|exec_file
argument_list|,
name|strlen
argument_list|(
name|exec_file
argument_list|)
argument_list|)
expr_stmt|;
name|exec_file_attach
argument_list|(
name|full_exec_path
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|symbol_file_add_main
argument_list|(
name|full_exec_path
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SOLIB_ADD
comment|/* Add shared library symbols from the newly attached process, if any.  */
name|SOLIB_ADD
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|,
operator|&
name|current_target
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
name|re_enable_breakpoints_in_shlibs
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Take any necessary post-attaching actions for this platform.    */
name|target_post_attach
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|attach_hook
condition|)
name|attach_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * detach_command --  * takes a program previously attached to and detaches it.  * The program resumes execution and will no longer stop  * on signals, etc.  We better not have left any breakpoints  * in the program or it'll die when it hits one.  For this  * to work, it may be necessary for the process to have been  * previously attached.  It *might* work if the program was  * started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|detach_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Not for the faint of heart */
name|target_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_RESTART
argument_list|)
name|SOLIB_RESTART
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|detach_hook
condition|)
name|detach_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disconnect from the current target without resuming it (leaving it    waiting for a debugger).     We'd better not have left any breakpoints in the program or the    next debugger will get confused.  Currently only supported for some    remote targets, since the normal attach mechanisms don't work on    stopped processes on some native platforms (e.g. GNU/Linux).  */
end_comment

begin_function
specifier|static
name|void
name|disconnect_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Not for the faint of heart */
name|target_disconnect
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_RESTART
argument_list|)
name|SOLIB_RESTART
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|detach_hook
condition|)
name|detach_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop the execution of the target while running in async mode, in    the backgound. */
end_comment

begin_function
name|void
name|interrupt_target_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
condition|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Not for the faint of heart */
name|target_stop
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_float_info
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"The program has no registers now."
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecated_selected_frame
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No selected frame."
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_print_float_info_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
name|gdbarch_print_float_info
argument_list|(
name|gdbarch
argument_list|,
name|file
argument_list|,
name|frame
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|regnum
decl_stmt|;
name|int
name|printed_something
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|float_reggroup
argument_list|)
condition|)
block|{
name|printed_something
operator|=
literal|1
expr_stmt|;
name|gdbarch_print_registers_info
argument_list|(
name|gdbarch
argument_list|,
name|file
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|printed_something
condition|)
name|fprintf_filtered
argument_list|(
name|file
argument_list|,
literal|"\ No floating-point info available for this processor.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|float_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|print_float_info
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdout
argument_list|,
name|deprecated_selected_frame
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|unset_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_filtered
argument_list|(
literal|"\"unset\" must be followed by the name of "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"an unset subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|unsetlist
argument_list|,
literal|"unset "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_infcmd
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"tty"
argument_list|,
name|class_run
argument_list|,
name|tty_command
argument_list|,
literal|"Set terminal for future runs of program being debugged."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"args"
argument_list|,
name|class_run
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inferior_args
argument_list|,
literal|"Set argument list to give program being debugged when it is started.\n\ Follow this command with any number of args, to be passed to the program."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|notice_args_set
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|notice_args_read
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"environment"
argument_list|,
name|no_class
argument_list|,
name|environment_info
argument_list|,
literal|"The environment to give the program, or one variable's value.\n\ With an argument VAR, prints the value of environment variable VAR to\n\ give the program being debugged.  With no arguments, prints the entire\n\ environment to be given to the program."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|noop_completer
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"unset"
argument_list|,
name|no_class
argument_list|,
name|unset_command
argument_list|,
literal|"Complement to certain \"set\" commands."
argument_list|,
operator|&
name|unsetlist
argument_list|,
literal|"unset "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"environment"
argument_list|,
name|class_run
argument_list|,
name|unset_environment_command
argument_list|,
literal|"Cancel environment variable VAR for the program.\n\ This does not affect the program until the next \"run\" command."
argument_list|,
operator|&
name|unsetlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|noop_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"environment"
argument_list|,
name|class_run
argument_list|,
name|set_environment_command
argument_list|,
literal|"Set environment variable value to give the program.\n\ Arguments are VAR VALUE where VAR is variable name and VALUE is value.\n\ VALUES of environment variables are uninterpreted strings.\n\ This does not affect the program until the next \"run\" command."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|noop_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"path"
argument_list|,
name|class_files
argument_list|,
name|path_command
argument_list|,
literal|"Add directory DIR(s) to beginning of search path for object files.\n\ $cwd in the path means the current working directory.\n\ This path is equivalent to the $PATH shell variable.  It is a list of\n\ directories, separated by colons.  These directories are searched to find\n\ fully linked executable files and separately compiled object files as needed."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"paths"
argument_list|,
name|no_class
argument_list|,
name|path_info
argument_list|,
literal|"Current search path for finding object files.\n\ $cwd in the path means the current working directory.\n\ This path is equivalent to the $PATH shell variable.  It is a list of\n\ directories, separated by colons.  These directories are searched to find\n\ fully linked executable files and separately compiled object files as needed."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|noop_completer
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"attach"
argument_list|,
name|class_run
argument_list|,
name|attach_command
argument_list|,
literal|"Attach to a process or file outside of GDB.\n\ This command attaches to another target, of the same type as your last\n\ \"target\" command (\"info files\" will show your target stack).\n\ The command may take as argument a process id or a device file.\n\ For a process id, you must have permission to send the process a signal,\n\ and it must have the same effective uid as the debugger.\n\ When using \"attach\" with a process id, the debugger finds the\n\ program running in the process, looking first in the current working\n\ directory, or (if not found there) using the source file search path\n\ (see the \"directory\" command).  You can also use the \"file\" command\n\ to specify the program, and to load its symbol table."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"detach"
argument_list|,
name|class_run
argument_list|,
name|detach_command
argument_list|,
literal|"Detach a process or file previously attached.\n\ If a process, it is no longer traced, and it continues its execution.  If\n\ you were debugging a file, the file is closed and gdb no longer accesses it."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"disconnect"
argument_list|,
name|class_run
argument_list|,
name|disconnect_command
argument_list|,
literal|"Disconnect from a target.\n\ The target will wait for another debugger to connect.  Not available for\n\ all targets."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"signal"
argument_list|,
name|class_run
argument_list|,
name|signal_command
argument_list|,
literal|"Continue program giving it signal specified by the argument.\n\ An argument of \"0\" means continue program without giving it a signal."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"stepi"
argument_list|,
name|class_run
argument_list|,
name|stepi_command
argument_list|,
literal|"Step one instruction exactly.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"si"
argument_list|,
literal|"stepi"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"nexti"
argument_list|,
name|class_run
argument_list|,
name|nexti_command
argument_list|,
literal|"Step one instruction, but proceed through subroutine calls.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ni"
argument_list|,
literal|"nexti"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"finish"
argument_list|,
name|class_run
argument_list|,
name|finish_command
argument_list|,
literal|"Execute until selected stack frame returns.\n\ Upon return, the value returned is printed and put in the value history."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"next"
argument_list|,
name|class_run
argument_list|,
name|next_command
argument_list|,
literal|"Step program, proceeding through subroutine calls.\n\ Like the \"step\" command as long as subroutine calls do not happen;\n\ when they do, the call is treated as one instruction.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"n"
argument_list|,
literal|"next"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"S"
argument_list|,
literal|"next"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"step"
argument_list|,
name|class_run
argument_list|,
name|step_command
argument_list|,
literal|"Step program until it reaches a different source line.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"s"
argument_list|,
literal|"step"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"until"
argument_list|,
name|class_run
argument_list|,
name|until_command
argument_list|,
literal|"Execute until the program reaches a source line greater than the current\n\ or a specified location (same args as break command) within the current frame."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"u"
argument_list|,
literal|"until"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"advance"
argument_list|,
name|class_run
argument_list|,
name|advance_command
argument_list|,
literal|"Continue the program up to the given location (same form as args for break command).\n\ Execution will also stop upon exit from the current stack frame."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"jump"
argument_list|,
name|class_run
argument_list|,
name|jump_command
argument_list|,
literal|"Continue program being debugged at specified line or address.\n\ Give as argument either LINENUM or *ADDR, where ADDR is an expression\n\ for an address to start at."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|c
operator|=
name|add_com
argument_list|(
literal|"go"
argument_list|,
name|class_run
argument_list|,
name|go_command
argument_list|,
literal|"Usage: go<location>\n\ Continue program being debugged, stopping at specified line or \n\ address.\n\ Give as argument either LINENUM or *ADDR, where ADDR is an \n\ expression for an address to start at.\n\ This command is a combination of tbreak and jump."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"g"
argument_list|,
literal|"go"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"continue"
argument_list|,
name|class_run
argument_list|,
name|continue_command
argument_list|,
literal|"Continue program being debugged, after signal or breakpoint.\n\ If proceeding from breakpoint, a number N may be used as an argument,\n\ which means to set the ignore count of that breakpoint to N - 1 (so that\n\ the breakpoint won't break until the Nth time it is reached)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"c"
argument_list|,
literal|"cont"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"fg"
argument_list|,
literal|"cont"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"run"
argument_list|,
name|class_run
argument_list|,
name|run_command
argument_list|,
literal|"Start debugged program.  You may specify arguments to give it.\n\ Args may include \"*\", or \"[...]\"; they are expanded using \"sh\".\n\ Input and output redirection with \">\", \"<\", or \">>\" are also allowed.\n\n\ With no arguments, uses arguments last specified (with \"run\" or \"set args\").\n\ To cancel previous arguments and run with no arguments,\n\ use \"set args\" without arguments."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"r"
argument_list|,
literal|"run"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"R"
argument_list|,
name|class_run
argument_list|,
name|run_no_args_command
argument_list|,
literal|"Start debugged program with no arguments."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"interrupt"
argument_list|,
name|class_run
argument_list|,
name|interrupt_target_command
argument_list|,
literal|"Interrupt the execution of the debugged program."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"registers"
argument_list|,
name|nofp_registers_info
argument_list|,
literal|"List of integer registers and their contents, for selected stack frame.\n\ Register name as argument means describe only that register."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"r"
argument_list|,
literal|"registers"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com
argument_list|(
literal|"lr"
argument_list|,
name|class_info
argument_list|,
name|nofp_registers_info
argument_list|,
literal|"List of integer registers and their contents, for selected stack frame.\n\   Register name as argument means describe only that register."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"all-registers"
argument_list|,
name|all_registers_info
argument_list|,
literal|"List of all registers and their contents, for selected stack frame.\n\ Register name as argument means describe only that register."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"program"
argument_list|,
name|program_info
argument_list|,
literal|"Execution status of the program."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"float"
argument_list|,
name|float_info
argument_list|,
literal|"Print the status of the floating point unit\n"
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"vector"
argument_list|,
name|vector_info
argument_list|,
literal|"Print the status of the vector unit\n"
argument_list|)
expr_stmt|;
name|inferior_environ
operator|=
name|make_environ
argument_list|()
expr_stmt|;
name|init_environ
argument_list|(
name|inferior_environ
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

