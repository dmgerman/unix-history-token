begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Kernel Object Display facility for Cisco    Copyright 1999, 2000 Free Software Foundation, Inc.        Written by Tom Tromey<tromey@cygnus.com>.     This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"kod.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define this to turn off communication with target.  */
end_comment

begin_comment
comment|/* #define FAKE_PACKET */
end_comment

begin_comment
comment|/* Size of buffer used for remote communication.  */
end_comment

begin_define
define|#
directive|define
name|PBUFSIZ
value|400
end_define

begin_comment
comment|/* Pointers to gdb callbacks.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|gdb_kod_display
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|gdb_kod_query
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initialize and return library name and version.    The gdb side of KOD, kod.c, passes us two functions: one for    displaying output (presumably to the user) and the other for    querying the target.  */
end_comment

begin_function
name|char
modifier|*
name|cisco_kod_open
parameter_list|(
name|kod_display_callback_ftype
modifier|*
name|display_func
parameter_list|,
name|kod_query_callback_ftype
modifier|*
name|query_func
parameter_list|)
block|{
name|char
name|buffer
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|bufsiz
init|=
name|PBUFSIZ
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|gdb_kod_display
operator|=
name|display_func
expr_stmt|;
name|gdb_kod_query
operator|=
name|query_func
expr_stmt|;
comment|/* Get the OS info, and check the version field.  This is the stub      version, which we use to see whether we will understand what      comes back.  This is lame, but the `qKoL' request doesn't      actually provide enough configurability.            Right now the only defined version number is `0.0.0'.      This stub supports qKoI and the `a' (any) object requests qKaL      and qKaI.  Each `a' object is returned as a 4-byte integer ID.      An info request on an object returns a pair of 4-byte integers;      the first is the object pointer and the second is the thread ID.  */
ifndef|#
directive|ifndef
name|FAKE_PACKET
call|(
modifier|*
name|gdb_kod_query
call|)
argument_list|(
literal|"oI;"
argument_list|,
name|buffer
argument_list|,
operator|&
name|bufsiz
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"Cisco IOS/Classic/13.4 0.0.0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|count
operator|&&
name|buffer
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|' '
condition|)
operator|--
name|count
expr_stmt|;
block|}
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Remote returned malformed packet\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
literal|"0.0.0"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Remote returned unknown stub version: %s\n"
argument_list|,
operator|&
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Return name, version, and description.  I hope we have enough      space.  */
return|return
operator|(
name|xstrdup
argument_list|(
literal|"gdbkodcisco v0.0.0 - Cisco Kernel Object Display"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Close the connection.  */
end_comment

begin_function
name|void
name|cisco_kod_close
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Print a "bad packet" message.  */
end_comment

begin_function
specifier|static
name|void
name|bad_packet
parameter_list|(
name|void
parameter_list|)
block|{
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"Remote target returned malformed packet.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print information about currently known kernel objects.    We currently ignore the argument.  There is only one mode of    querying the Cisco kernel: we ask for a dump of everything, and    it returns it.  */
end_comment

begin_function
name|void
name|cisco_kod_request
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
name|buffer
index|[
name|PBUFSIZ
index|]
decl_stmt|,
name|command
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|sync_ids
init|=
name|NULL
decl_stmt|;
name|int
name|sync_len
init|=
literal|0
decl_stmt|;
name|int
name|sync_next
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|prev_id
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"any"
argument_list|)
condition|)
block|{
comment|/* "Top-level" command.  This is really silly, but it also seems 	 to be how KOD is defined.  */
comment|/* Even sillier is the fact that this first line must start 	 with the word "List".  See kod.tcl.  */
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"List of Cisco Kernel Objects\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"Object\tDescription\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"any\tAny and all objects\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
comment|/* Where we are in the string.  */
name|long
name|count
decl_stmt|;
comment|/* Number of objects in this packet.  */
name|int
name|bufsiz
init|=
name|PBUFSIZ
decl_stmt|;
name|char
modifier|*
name|s_end
decl_stmt|;
name|strcpy
argument_list|(
name|command
argument_list|,
literal|"aL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_id
condition|)
block|{
name|strcat
argument_list|(
name|command
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|command
argument_list|,
name|prev_id
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|command
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FAKE_PACKET
comment|/* We talk to the target by calling through the query function 	 passed to us when we were initialized.  */
call|(
modifier|*
name|gdb_kod_query
call|)
argument_list|(
name|command
argument_list|,
name|buffer
argument_list|,
operator|&
name|bufsiz
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Fake up a multi-part packet.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|command
index|[
literal|3
index|]
argument_list|,
literal|"a500005a"
argument_list|,
literal|8
argument_list|)
condition|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"KAL,01,1,f500005f;f500005f;"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"KAL,02,0,a500005a;a500005a;de02869f;"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Empty response is an error.  */
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"Remote target did not recognize kernel object query command.\n"
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If we don't get a `K' response then the buffer holds the 	 target's error message.  */
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'K'
condition|)
block|{
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Make sure we get the response we expect.  */
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"KAL,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|off
operator|+=
literal|4
expr_stmt|;
comment|/* Parse out the count.  We expect to convert exactly two 	 characters followed by a comma.  */
name|count
operator|=
name|strtol
argument_list|(
operator|&
name|buffer
index|[
name|off
index|]
argument_list|,
operator|&
name|s_end
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_end
operator|-
operator|&
name|buffer
index|[
name|off
index|]
operator|!=
literal|2
operator|||
name|buffer
index|[
name|off
operator|+
literal|2
index|]
operator|!=
literal|','
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|off
operator|+=
literal|3
expr_stmt|;
comment|/* Parse out the `done' flag.  */
if|if
condition|(
operator|(
name|buffer
index|[
name|off
index|]
operator|!=
literal|'0'
operator|&&
name|buffer
index|[
name|off
index|]
operator|!=
literal|'1'
operator|)
operator|||
name|buffer
index|[
name|off
operator|+
literal|1
index|]
operator|!=
literal|','
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|done
operator|=
name|buffer
index|[
name|off
index|]
operator|==
literal|'1'
expr_stmt|;
name|off
operator|+=
literal|2
expr_stmt|;
comment|/* Id of the last item; we might this to construct the next 	 request.  */
name|prev_id
operator|=
operator|&
name|buffer
index|[
name|off
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|prev_id
argument_list|)
operator|<
literal|8
operator|||
name|buffer
index|[
name|off
operator|+
literal|8
index|]
operator|!=
literal|';'
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|buffer
index|[
name|off
operator|+
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|off
operator|+=
literal|9
expr_stmt|;
name|sync_len
operator|+=
name|count
expr_stmt|;
name|sync_ids
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|sync_ids
argument_list|,
name|sync_len
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
operator|&
name|buffer
index|[
name|off
index|]
argument_list|)
operator|<
literal|8
operator|||
name|buffer
index|[
name|off
operator|+
literal|8
index|]
operator|!=
literal|';'
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|buffer
index|[
name|off
operator|+
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sync_ids
index|[
name|sync_next
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
operator|&
name|buffer
index|[
name|off
index|]
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|9
expr_stmt|;
block|}
if|if
condition|(
name|buffer
index|[
name|off
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* We've collected all the sync object IDs.  Now query to get the      specific information, and arrange to print this info.  */
if|if
condition|(
operator|!
name|fail
condition|)
block|{
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"Object ID\tObject Pointer\tThread ID\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sync_next
condition|;
operator|++
name|i
control|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|bufsiz
init|=
name|PBUFSIZ
decl_stmt|;
comment|/* For now assume a query can be accomplished in a single 	     transaction.  This is implied in the protocol document. 	     See comments above, and the KOD protocol document, to 	     understand the parsing of the return value.  */
name|strcpy
argument_list|(
name|command
argument_list|,
literal|"aI,"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|command
argument_list|,
name|sync_ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|command
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FAKE_PACKET
call|(
modifier|*
name|gdb_kod_query
call|)
argument_list|(
name|command
argument_list|,
name|buffer
argument_list|,
operator|&
name|bufsiz
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"KAI,"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|sync_ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|",ffef00a0,cd00123d;"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"Remote target did not recognize KOD command.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"KAI,"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
break|break;
block|}
name|off
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|buffer
index|[
name|off
index|]
argument_list|,
name|sync_ids
index|[
name|i
index|]
argument_list|,
literal|8
argument_list|)
operator|||
name|buffer
index|[
name|off
operator|+
literal|8
index|]
operator|!=
literal|','
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
break|break;
block|}
name|off
operator|+=
literal|9
expr_stmt|;
comment|/* Extract thread id and sync object pointer.  */
if|if
condition|(
name|strlen
argument_list|(
operator|&
name|buffer
index|[
name|off
index|]
argument_list|)
operator|!=
literal|2
operator|*
literal|8
operator|+
literal|2
operator|||
name|buffer
index|[
name|off
operator|+
literal|8
index|]
operator|!=
literal|','
operator|||
name|buffer
index|[
name|off
operator|+
literal|17
index|]
operator|!=
literal|';'
condition|)
block|{
name|bad_packet
argument_list|()
expr_stmt|;
break|break;
block|}
name|buffer
index|[
name|off
operator|+
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buffer
index|[
name|off
operator|+
literal|17
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Display the result.  */
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
name|sync_ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
operator|&
name|buffer
index|[
name|off
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
operator|&
name|buffer
index|[
name|off
operator|+
literal|9
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|gdb_kod_display
call|)
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free memory.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sync_next
condition|;
operator|++
name|i
control|)
name|xfree
argument_list|(
name|sync_ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sync_ids
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

