begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target glue for the ROM68K ROM monitor.    Copyright 1988, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"m68k-tdep.h"
end_include

begin_function_decl
specifier|static
name|void
name|rom68k_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return true if C is a hex digit.    We can't use isxdigit here: that is affected by the current locale;    ROM68K is not.  */
end_comment

begin_function
specifier|static
name|int
name|is_hex_digit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|hex_digit_value
parameter_list|(
name|int
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
return|return
name|a
operator|-
literal|'A'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Invalid hex digit %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true iff C is a whitespace character.    We can't use isspace here: that is affected by the current locale;    ROM68K is not.  */
end_comment

begin_function
specifier|static
name|int
name|is_whitespace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\f'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a string of hex digits starting at HEX, supply them as the    value of register REGNO, skip any whitespace, and return a pointer    to the next character.     There is a function in monitor.c, monitor_supply_register, which is    supposed to do this job.  However, there is some rather odd stuff    in there (whitespace characters don't terminate numbers, for    example) that is incorrect for ROM68k.  It's basically impossible    to safely tweak monitor_supply_register --- it's used by a zillion    other monitors; who knows what behaviors they're depending on.  So    instead, we'll just use our own function, which can behave exactly    the way we want it to.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rom68k_supply_one_register
parameter_list|(
name|int
name|regno
parameter_list|,
name|unsigned
name|char
modifier|*
name|hex
parameter_list|)
block|{
name|ULONGEST
name|value
decl_stmt|;
name|unsigned
name|char
name|regbuf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|hex
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|is_hex_digit
argument_list|(
operator|*
name|hex
argument_list|)
condition|)
name|value
operator|=
operator|(
name|value
operator|*
literal|16
operator|)
operator|+
name|hex_digit_value
argument_list|(
operator|*
name|hex
operator|++
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* Skip any whitespace.  */
while|while
condition|(
name|is_whitespace
argument_list|(
operator|*
name|hex
argument_list|)
condition|)
name|hex
operator|++
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|regbuf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regbuf
argument_list|)
expr_stmt|;
return|return
name|hex
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rom68k_supply_register
parameter_list|(
name|char
modifier|*
name|regname
parameter_list|,
name|int
name|regnamelen
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|vallen
parameter_list|)
block|{
name|int
name|numregs
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|numregs
operator|=
literal|1
expr_stmt|;
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|regnamelen
operator|==
literal|2
condition|)
switch|switch
condition|(
name|regname
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'S'
case|:
if|if
condition|(
name|regname
index|[
literal|1
index|]
operator|==
literal|'R'
condition|)
name|regno
operator|=
name|PS_REGNUM
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|regname
index|[
literal|1
index|]
operator|==
literal|'C'
condition|)
name|regno
operator|=
name|PC_REGNUM
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|regname
index|[
literal|1
index|]
operator|!=
literal|'R'
condition|)
break|break;
name|regno
operator|=
name|M68K_D0_REGNUM
expr_stmt|;
name|numregs
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|regname
index|[
literal|1
index|]
operator|!=
literal|'R'
condition|)
break|break;
name|regno
operator|=
name|M68K_A0_REGNUM
expr_stmt|;
name|numregs
operator|=
literal|7
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|regnamelen
operator|==
literal|3
condition|)
switch|switch
condition|(
name|regname
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'I'
case|:
if|if
condition|(
name|regname
index|[
literal|1
index|]
operator|==
literal|'S'
operator|&&
name|regname
index|[
literal|2
index|]
operator|==
literal|'P'
condition|)
name|regno
operator|=
name|SP_REGNUM
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
while|while
condition|(
name|numregs
operator|--
operator|>
literal|0
condition|)
name|val
operator|=
name|rom68k_supply_one_register
argument_list|(
name|regno
operator|++
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This array of registers need to match the indexes used by GDB.    This exists because the various ROM monitors use different strings    than does GDB, and don't necessarily support all the registers    either. So, typing "info reg sp" becomes a "r30".  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rom68k_regname
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|regnames
index|[]
init|=
block|{
literal|"D0"
block|,
literal|"D1"
block|,
literal|"D2"
block|,
literal|"D3"
block|,
literal|"D4"
block|,
literal|"D5"
block|,
literal|"D6"
block|,
literal|"D7"
block|,
literal|"A0"
block|,
literal|"A1"
block|,
literal|"A2"
block|,
literal|"A3"
block|,
literal|"A4"
block|,
literal|"A5"
block|,
literal|"A6"
block|,
literal|"ISP"
block|,
literal|"SR"
block|,
literal|"PC"
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|regnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|regnames
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|NUM_REGS
operator|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|regnames
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Define the monitor command strings. Since these are passed directly    through to a printf style function, we may include formatting    strings. We also need a CR or LF on the end.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|rom68k_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rom68k_inits
index|[]
init|=
block|{
literal|".\r\r"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exits pm/pr& download cmds */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
name|rom68k_cmds
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_rom68k_cmds
parameter_list|(
name|void
parameter_list|)
block|{
name|rom68k_cmds
operator|.
name|flags
operator|=
name|MO_PRINT_PROGRAM_OUTPUT
expr_stmt|;
name|rom68k_cmds
operator|.
name|init
operator|=
name|rom68k_inits
expr_stmt|;
comment|/* monitor init string */
name|rom68k_cmds
operator|.
name|cont
operator|=
literal|"go\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|step
operator|=
literal|"st\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|stop
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|set_break
operator|=
literal|"db %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|clr_break
operator|=
literal|"cb %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|clr_all_break
operator|=
literal|"cb *\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|fill
operator|=
literal|"fm %x %x %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|setmem
operator|.
name|cmdb
operator|=
literal|"pm %x %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|setmem
operator|.
name|cmdw
operator|=
literal|"pm.w %x %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|setmem
operator|.
name|cmdl
operator|=
literal|"pm.l %x %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|setmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|setmem
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|setmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|setmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|getmem
operator|.
name|cmdb
operator|=
literal|"dm %x %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|getmem
operator|.
name|cmdw
operator|=
literal|"dm.w %x %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|getmem
operator|.
name|cmdl
operator|=
literal|"dm.l %x %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|getmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|getmem
operator|.
name|resp_delim
operator|=
literal|"  "
expr_stmt|;
name|rom68k_cmds
operator|.
name|getmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|getmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|setreg
operator|.
name|cmd
operator|=
literal|"pr %s %x\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|setreg
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|setreg
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|setreg
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|getreg
operator|.
name|cmd
operator|=
literal|"pr %s\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|getreg
operator|.
name|resp_delim
operator|=
literal|":  "
expr_stmt|;
name|rom68k_cmds
operator|.
name|getreg
operator|.
name|term
operator|=
literal|"= "
expr_stmt|;
name|rom68k_cmds
operator|.
name|getreg
operator|.
name|term_cmd
operator|=
literal|".\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|dump_registers
operator|=
literal|"dr\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|register_pattern
operator|=
literal|"\\(\\w+\\)=\\([0-9a-fA-F]+\\( +[0-9a-fA-F]+\\b\\)*\\)"
expr_stmt|;
name|rom68k_cmds
operator|.
name|supply_register
operator|=
name|rom68k_supply_register
expr_stmt|;
name|rom68k_cmds
operator|.
name|load_routine
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|load
operator|=
literal|"dc\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|loadresp
operator|=
literal|"Waiting for S-records from host... "
expr_stmt|;
name|rom68k_cmds
operator|.
name|prompt
operator|=
literal|"ROM68K :-> "
expr_stmt|;
name|rom68k_cmds
operator|.
name|line_term
operator|=
literal|"\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|cmd_end
operator|=
literal|".\r"
expr_stmt|;
name|rom68k_cmds
operator|.
name|target
operator|=
operator|&
name|rom68k_ops
expr_stmt|;
name|rom68k_cmds
operator|.
name|stopbits
operator|=
name|SERIAL_1_STOPBITS
expr_stmt|;
name|rom68k_cmds
operator|.
name|regnames
operator|=
name|NULL
expr_stmt|;
name|rom68k_cmds
operator|.
name|regname
operator|=
name|rom68k_regname
expr_stmt|;
name|rom68k_cmds
operator|.
name|magic
operator|=
name|MONITOR_OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init_rom68k_cmds */
end_comment

begin_function
specifier|static
name|void
name|rom68k_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|monitor_open
argument_list|(
name|args
argument_list|,
operator|&
name|rom68k_cmds
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_rom68k
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_rom68k
parameter_list|(
name|void
parameter_list|)
block|{
name|init_rom68k_cmds
argument_list|()
expr_stmt|;
name|init_monitor_ops
argument_list|(
operator|&
name|rom68k_ops
argument_list|)
expr_stmt|;
name|rom68k_ops
operator|.
name|to_shortname
operator|=
literal|"rom68k"
expr_stmt|;
name|rom68k_ops
operator|.
name|to_longname
operator|=
literal|"Rom68k debug monitor for the IDP Eval board"
expr_stmt|;
name|rom68k_ops
operator|.
name|to_doc
operator|=
literal|"Debug on a Motorola IDP eval board running the ROM68K monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|rom68k_ops
operator|.
name|to_open
operator|=
name|rom68k_open
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|rom68k_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

