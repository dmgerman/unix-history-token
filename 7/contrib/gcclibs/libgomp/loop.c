begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file handles the LOOP (FOR/DO) construct.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* Initialize the given work share construct from the given arguments.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|gomp_loop_init
parameter_list|(
name|struct
name|gomp_work_share
modifier|*
name|ws
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|enum
name|gomp_schedule_type
name|sched
parameter_list|,
name|long
name|chunk_size
parameter_list|)
block|{
name|ws
operator|->
name|sched
operator|=
name|sched
expr_stmt|;
name|ws
operator|->
name|chunk_size
operator|=
name|chunk_size
expr_stmt|;
comment|/* Canonicalize loops that have zero iterations to ->next == ->end.  */
name|ws
operator|->
name|end
operator|=
operator|(
operator|(
name|incr
operator|>
literal|0
operator|&&
name|start
operator|>
name|end
operator|)
operator|||
operator|(
name|incr
operator|<
literal|0
operator|&&
name|start
operator|<
name|end
operator|)
operator|)
condition|?
name|start
else|:
name|end
expr_stmt|;
name|ws
operator|->
name|incr
operator|=
name|incr
expr_stmt|;
name|ws
operator|->
name|next
operator|=
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The *_start routines are called when first encountering a loop construct    that is not bound directly to a parallel construct.  The first thread     that arrives will create the work-share construct; subsequent threads    will see the construct exists and allocate work from it.     START, END, INCR are the bounds of the loop; due to the restrictions of    OpenMP, these values must be the same in every thread.  This is not     verified (nor is it entirely verifiable, since START is not necessarily    retained intact in the work-share data structure).  CHUNK_SIZE is the    scheduling parameter; again this must be identical in all threads.     Returns true if there's any work for this thread to perform.  If so,    *ISTART and *IEND are filled with the bounds of the iteration block    allocated to this thread.  Returns false if all work was assigned to    other threads prior to this thread's arrival.  */
end_comment

begin_function
specifier|static
name|bool
name|gomp_loop_static_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
if|if
condition|(
name|gomp_work_share_start
argument_list|(
name|false
argument_list|)
condition|)
name|gomp_loop_init
argument_list|(
name|thr
operator|->
name|ts
operator|.
name|work_share
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_STATIC
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|!
name|gomp_iter_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_dynamic_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|gomp_work_share_start
argument_list|(
name|false
argument_list|)
condition|)
name|gomp_loop_init
argument_list|(
name|thr
operator|->
name|ts
operator|.
name|work_share
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_DYNAMIC
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_dynamic_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|gomp_iter_dynamic_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_guided_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|gomp_work_share_start
argument_list|(
name|false
argument_list|)
condition|)
name|gomp_loop_init
argument_list|(
name|thr
operator|->
name|ts
operator|.
name|work_share
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_GUIDED
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_guided_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|gomp_iter_guided_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_runtime_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
switch|switch
condition|(
name|gomp_run_sched_var
condition|)
block|{
case|case
name|GFS_STATIC
case|:
return|return
name|gomp_loop_static_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|gomp_run_sched_chunk
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_DYNAMIC
case|:
return|return
name|gomp_loop_dynamic_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|gomp_run_sched_chunk
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_GUIDED
case|:
return|return
name|gomp_loop_guided_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|gomp_run_sched_chunk
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The *_ordered_*_start routines are similar.  The only difference is that    this work-share construct is initialized to expect an ORDERED section.  */
end_comment

begin_function
specifier|static
name|bool
name|gomp_loop_ordered_static_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
if|if
condition|(
name|gomp_work_share_start
argument_list|(
name|true
argument_list|)
condition|)
block|{
name|gomp_loop_init
argument_list|(
name|thr
operator|->
name|ts
operator|.
name|work_share
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_STATIC
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|gomp_ordered_static_init
argument_list|()
expr_stmt|;
block|}
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|!
name|gomp_iter_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_ordered_dynamic_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|gomp_work_share_start
argument_list|(
name|true
argument_list|)
condition|)
name|gomp_loop_init
argument_list|(
name|thr
operator|->
name|ts
operator|.
name|work_share
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_DYNAMIC
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_dynamic_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|gomp_ordered_first
argument_list|()
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_ordered_guided_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|gomp_work_share_start
argument_list|(
name|true
argument_list|)
condition|)
name|gomp_loop_init
argument_list|(
name|thr
operator|->
name|ts
operator|.
name|work_share
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_GUIDED
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_guided_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|gomp_ordered_first
argument_list|()
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_runtime_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
switch|switch
condition|(
name|gomp_run_sched_var
condition|)
block|{
case|case
name|GFS_STATIC
case|:
return|return
name|gomp_loop_ordered_static_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|gomp_run_sched_chunk
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_DYNAMIC
case|:
return|return
name|gomp_loop_ordered_dynamic_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|gomp_run_sched_chunk
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_GUIDED
case|:
return|return
name|gomp_loop_ordered_guided_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|gomp_run_sched_chunk
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The *_next routines are called when the thread completes processing of     the iteration block currently assigned to it.  If the work-share     construct is bound directly to a parallel construct, then the iteration    bounds may have been set up before the parallel.  In which case, this    may be the first iteration for the thread.     Returns true if there is work remaining to be performed; *ISTART and    *IEND are filled with a new iteration block.  Returns false if all work    has been assigned.  */
end_comment

begin_function
specifier|static
name|bool
name|gomp_loop_static_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
operator|!
name|gomp_iter_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_dynamic_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
name|ret
operator|=
name|gomp_iter_dynamic_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_dynamic_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_guided_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
name|ret
operator|=
name|gomp_iter_guided_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_guided_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_runtime_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|sched
condition|)
block|{
case|case
name|GFS_STATIC
case|:
return|return
name|gomp_loop_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_DYNAMIC
case|:
return|return
name|gomp_loop_dynamic_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_GUIDED
case|:
return|return
name|gomp_loop_guided_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The *_ordered_*_next routines are called when the thread completes    processing of the iteration block currently assigned to it.     Returns true if there is work remaining to be performed; *ISTART and    *IEND are filled with a new iteration block.  Returns false if all work    has been assigned.  */
end_comment

begin_function
specifier|static
name|bool
name|gomp_loop_ordered_static_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|int
name|test
decl_stmt|;
name|gomp_ordered_sync
argument_list|()
expr_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
name|test
operator|=
name|gomp_iter_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|>=
literal|0
condition|)
name|gomp_ordered_static_next
argument_list|()
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|test
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_ordered_dynamic_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|gomp_ordered_sync
argument_list|()
expr_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_dynamic_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|gomp_ordered_next
argument_list|()
expr_stmt|;
else|else
name|gomp_ordered_last
argument_list|()
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gomp_loop_ordered_guided_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|gomp_ordered_sync
argument_list|()
expr_stmt|;
name|gomp_mutex_lock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gomp_iter_guided_next_locked
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|gomp_ordered_next
argument_list|()
expr_stmt|;
else|else
name|gomp_ordered_last
argument_list|()
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
operator|&
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_runtime_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
name|struct
name|gomp_thread
modifier|*
name|thr
init|=
name|gomp_thread
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|thr
operator|->
name|ts
operator|.
name|work_share
operator|->
name|sched
condition|)
block|{
case|case
name|GFS_STATIC
case|:
return|return
name|gomp_loop_ordered_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_DYNAMIC
case|:
return|return
name|gomp_loop_ordered_dynamic_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
case|case
name|GFS_GUIDED
case|:
return|return
name|gomp_loop_ordered_guided_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The GOMP_parallel_loop_* routines pre-initialize a work-share construct    to avoid one synchronization once we get into the loop.  */
end_comment

begin_function
specifier|static
name|void
name|gomp_parallel_loop_start
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|num_threads
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|enum
name|gomp_schedule_type
name|sched
parameter_list|,
name|long
name|chunk_size
parameter_list|)
block|{
name|struct
name|gomp_work_share
modifier|*
name|ws
decl_stmt|;
name|num_threads
operator|=
name|gomp_resolve_num_threads
argument_list|(
name|num_threads
argument_list|)
expr_stmt|;
name|ws
operator|=
name|gomp_new_work_share
argument_list|(
name|false
argument_list|,
name|num_threads
argument_list|)
expr_stmt|;
name|gomp_loop_init
argument_list|(
name|ws
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|sched
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|gomp_team_start
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|num_threads
argument_list|,
name|ws
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_parallel_loop_static_start
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|num_threads
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|)
block|{
name|gomp_parallel_loop_start
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|num_threads
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_STATIC
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_parallel_loop_dynamic_start
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|num_threads
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|)
block|{
name|gomp_parallel_loop_start
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|num_threads
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_DYNAMIC
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_parallel_loop_guided_start
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|num_threads
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|)
block|{
name|gomp_parallel_loop_start
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|num_threads
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|GFS_GUIDED
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_parallel_loop_runtime_start
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|num_threads
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|)
block|{
name|gomp_parallel_loop_start
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|num_threads
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|gomp_run_sched_var
argument_list|,
name|gomp_run_sched_chunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The GOMP_loop_end* routines are called after the thread is told that    all loop iterations are complete.  This first version synchronizes    all threads; the nowait version does not.  */
end_comment

begin_function
name|void
name|GOMP_loop_end
parameter_list|(
name|void
parameter_list|)
block|{
name|gomp_work_share_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_loop_end_nowait
parameter_list|(
name|void
parameter_list|)
block|{
name|gomp_work_share_end_nowait
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We use static functions above so that we're sure that the "runtime"    function can defer to the proper routine without interposition.  We    export the static function with a strong alias when possible, or with    a wrapper function otherwise.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTRIBUTE_ALIAS
end_ifdef

begin_extern
extern|extern __typeof(gomp_loop_static_start
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_static_start
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_static_start"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_dynamic_start
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_dynamic_start
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_dynamic_start"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_guided_start
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_guided_start
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_guided_start"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_ordered_static_start
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_ordered_static_start
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_ordered_static_start"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_ordered_dynamic_start
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_ordered_dynamic_start
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_ordered_dynamic_start"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_ordered_guided_start
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_ordered_guided_start
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_ordered_guided_start"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_static_next
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_static_next
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_static_next"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_dynamic_next
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_dynamic_next
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_dynamic_next"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_guided_next
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_guided_next
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_guided_next"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_ordered_static_next
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_ordered_static_next
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_ordered_static_next"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_ordered_dynamic_next
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_ordered_dynamic_next
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_ordered_dynamic_next"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern __typeof(gomp_loop_ordered_guided_next
end_extern

begin_decl_stmt
unit|)
name|GOMP_loop_ordered_guided_next
name|__attribute__
argument_list|(
operator|(
name|alias
argument_list|(
literal|"gomp_loop_ordered_guided_next"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function
name|bool
name|GOMP_loop_static_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_static_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|chunk_size
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_dynamic_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_dynamic_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|chunk_size
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_guided_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_guided_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|chunk_size
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_static_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_ordered_static_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|chunk_size
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_dynamic_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_ordered_dynamic_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|chunk_size
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_guided_start
parameter_list|(
name|long
name|start
parameter_list|,
name|long
name|end
parameter_list|,
name|long
name|incr
parameter_list|,
name|long
name|chunk_size
parameter_list|,
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_ordered_guided_start
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|incr
argument_list|,
name|chunk_size
argument_list|,
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_static_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_dynamic_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_dynamic_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_guided_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_guided_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_static_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_ordered_static_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_dynamic_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_ordered_dynamic_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|GOMP_loop_ordered_guided_next
parameter_list|(
name|long
modifier|*
name|istart
parameter_list|,
name|long
modifier|*
name|iend
parameter_list|)
block|{
return|return
name|gomp_loop_ordered_guided_next
argument_list|(
name|istart
argument_list|,
name|iend
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

