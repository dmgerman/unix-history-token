begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>.     This file is part of the GNU OpenMP Library (libgomp).     Libgomp is free software; you can redistribute it and/or modify it    under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for    more details.     You should have received a copy of the GNU Lesser General Public License     along with libgomp; see the file COPYING.LIB.  If not, write to the    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files, some    of which are compiled with GCC, to produce an executable, this library    does not by itself cause the resulting executable to be covered by the    GNU General Public License.  This exception does not however invalidate    any other reasons why the executable file might be covered by the GNU    General Public License.  */
end_comment

begin_comment
comment|/* This file handles the CRITICAL construct.  */
end_comment

begin_include
include|#
directive|include
file|"libgomp.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_decl_stmt
specifier|static
name|gomp_mutex_t
name|default_lock
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|GOMP_critical_start
parameter_list|(
name|void
parameter_list|)
block|{
name|gomp_mutex_lock
argument_list|(
operator|&
name|default_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_critical_end
parameter_list|(
name|void
parameter_list|)
block|{
name|gomp_mutex_unlock
argument_list|(
operator|&
name|default_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SYNC_BUILTINS
end_ifndef

begin_decl_stmt
specifier|static
name|gomp_mutex_t
name|create_lock_lock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|GOMP_critical_name_start
parameter_list|(
name|void
modifier|*
modifier|*
name|pptr
parameter_list|)
block|{
name|gomp_mutex_t
modifier|*
name|plock
decl_stmt|;
comment|/* If a mutex fits within the space for a pointer, and is zero initialized,      then use the pointer space directly.  */
if|if
condition|(
name|GOMP_MUTEX_INIT_0
operator|&&
sizeof|sizeof
argument_list|(
name|gomp_mutex_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|&&
name|__alignof
argument_list|(
name|gomp_mutex_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
name|plock
operator|=
operator|(
name|gomp_mutex_t
operator|*
operator|)
name|pptr
expr_stmt|;
comment|/* Otherwise we have to be prepared to malloc storage.  */
else|else
block|{
name|plock
operator|=
operator|*
name|pptr
expr_stmt|;
if|if
condition|(
name|plock
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYNC_BUILTINS
name|gomp_mutex_t
modifier|*
name|nlock
init|=
name|gomp_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gomp_mutex_t
argument_list|)
argument_list|)
decl_stmt|;
name|gomp_mutex_init
argument_list|(
name|nlock
argument_list|)
expr_stmt|;
name|plock
operator|=
name|__sync_val_compare_and_swap
argument_list|(
name|pptr
argument_list|,
name|NULL
argument_list|,
name|nlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|plock
operator|!=
name|NULL
condition|)
block|{
name|gomp_mutex_destroy
argument_list|(
name|nlock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nlock
argument_list|)
expr_stmt|;
block|}
else|else
name|plock
operator|=
name|nlock
expr_stmt|;
else|#
directive|else
name|gomp_mutex_lock
argument_list|(
operator|&
name|create_lock_lock
argument_list|)
expr_stmt|;
name|plock
operator|=
operator|*
name|pptr
expr_stmt|;
if|if
condition|(
name|plock
operator|==
name|NULL
condition|)
block|{
name|plock
operator|=
name|gomp_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gomp_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
name|gomp_mutex_init
argument_list|(
name|plock
argument_list|)
expr_stmt|;
name|__sync_synchronize
argument_list|()
expr_stmt|;
operator|*
name|pptr
operator|=
name|plock
expr_stmt|;
block|}
name|gomp_mutex_unlock
argument_list|(
operator|&
name|create_lock_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|gomp_mutex_lock
argument_list|(
name|plock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_critical_name_end
parameter_list|(
name|void
modifier|*
modifier|*
name|pptr
parameter_list|)
block|{
name|gomp_mutex_t
modifier|*
name|plock
decl_stmt|;
comment|/* If a mutex fits within the space for a pointer, and is zero initialized,      then use the pointer space directly.  */
if|if
condition|(
name|GOMP_MUTEX_INIT_0
operator|&&
sizeof|sizeof
argument_list|(
name|gomp_mutex_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|&&
name|__alignof
argument_list|(
name|gomp_mutex_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
name|plock
operator|=
operator|(
name|gomp_mutex_t
operator|*
operator|)
name|pptr
expr_stmt|;
else|else
name|plock
operator|=
operator|*
name|pptr
expr_stmt|;
name|gomp_mutex_unlock
argument_list|(
name|plock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This mutex is used when atomic operations don't exist for the target    in the mode requested.  The result is not globally atomic, but works so    long as all parallel references are within #pragma omp atomic directives.    According to responses received from omp@openmp.org, appears to be within    spec.  Which makes sense, since that's how several other compilers     handle this situation as well.  */
end_comment

begin_decl_stmt
specifier|static
name|gomp_mutex_t
name|atomic_lock
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|GOMP_atomic_start
parameter_list|(
name|void
parameter_list|)
block|{
name|gomp_mutex_lock
argument_list|(
operator|&
name|atomic_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GOMP_atomic_end
parameter_list|(
name|void
parameter_list|)
block|{
name|gomp_mutex_unlock
argument_list|(
operator|&
name|atomic_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|GOMP_MUTEX_INIT_0
end_if

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|constructor
operator|)
argument_list|)
name|initialize_critical
argument_list|(
name|void
argument_list|)
block|{
name|gomp_mutex_init
argument_list|(
operator|&
name|default_lock
argument_list|)
expr_stmt|;
name|gomp_mutex_init
argument_list|(
operator|&
name|atomic_lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_SYNC_BUILTINS
name|gomp_mutex_init
argument_list|(
operator|&
name|create_lock_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

