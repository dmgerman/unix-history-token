begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Create and destroy argument vectors (argv's)    Copyright (C) 1992, 2001 Free Software Foundation, Inc.    Written by Fred Fish @ Cygnus Support  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*  Create and destroy argument vectors.  An argument vector is simply an     array of string pointers, terminated by a NULL pointer. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_comment
comment|/*  Routines imported from standard C runtime libraries. */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EOS
end_ifndef

begin_define
define|#
directive|define
name|EOS
value|'\0'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INITIAL_MAXARGC
value|8
end_define

begin_comment
comment|/* Number of args + NULL in initial argv */
end_comment

begin_comment
comment|/*  @deftypefn Extension char** dupargv (char **@var{vector})  Duplicate an argument vector.  Simply scans through @var{vector}, duplicating each argument until the terminating @code{NULL} is found. Returns a pointer to the argument vector if successful.  Returns @code{NULL} if there is insufficient memory to complete building the argument vector.  @end deftypefn  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|dupargv
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|copy
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* the vector */
for|for
control|(
name|argc
operator|=
literal|0
init|;
name|argv
index|[
name|argc
index|]
operator|!=
name|NULL
condition|;
name|argc
operator|++
control|)
empty_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* the strings */
for|for
control|(
name|argc
operator|=
literal|0
init|;
name|argv
index|[
name|argc
index|]
operator|!=
name|NULL
condition|;
name|argc
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|)
decl_stmt|;
name|copy
index|[
name|argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
index|[
name|argc
index|]
operator|==
name|NULL
condition|)
block|{
name|freeargv
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|copy
index|[
name|argc
index|]
argument_list|,
name|argv
index|[
name|argc
index|]
argument_list|)
expr_stmt|;
block|}
name|copy
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/*  @deftypefn Extension void freeargv (char **@var{vector})  Free an argument vector that was built using @code{buildargv}.  Simply scans through @var{vector}, freeing the memory for each argument until the terminating @code{NULL} is found, and then frees @var{vector} itself.  @end deftypefn  */
end_comment

begin_function
name|void
name|freeargv
parameter_list|(
name|char
modifier|*
modifier|*
name|vector
parameter_list|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|vector
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|scan
operator|=
name|vector
init|;
operator|*
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|++
control|)
block|{
name|free
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  @deftypefn Extension char** buildargv (char *@var{sp})  Given a pointer to a string, parse the string extracting fields separated by whitespace and optionally enclosed within either single or double quotes (which are stripped off), and build a vector of pointers to copies of the string for each field.  The input string remains unchanged.  The last element of the vector is followed by a @code{NULL} element.  All of the memory for the pointer array and copies of the string is obtained from @code{malloc}.  All of the memory can be returned to the system with the single function call @code{freeargv}, which takes the returned result of @code{buildargv}, as it's argument.  Returns a pointer to the argument vector if successful.  Returns @code{NULL} if @var{sp} is @code{NULL} or if there is insufficient memory to complete building the argument vector.  If the input is a null string (as opposed to a @code{NULL} pointer), then buildarg returns an argument vector that has one arg, a null string.  @end deftypefn  The memory for the argv array is dynamically expanded as necessary.  In order to provide a working buffer for extracting arguments into, with appropriate stripping of quotes and translation of backslash sequences, we allocate a working buffer at least as long as the input string.  This ensures that we always have enough space in which to work, since the extracted arg is never larger than the input string.  The argument vector is always kept terminated with a @code{NULL} arg pointer, so it can be passed to @code{freeargv} at any time, or returned, as appropriate.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|buildargv
parameter_list|(
specifier|const
name|char
modifier|*
name|input
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|copybuf
decl_stmt|;
name|int
name|squote
init|=
literal|0
decl_stmt|;
name|int
name|dquote
init|=
literal|0
decl_stmt|;
name|int
name|bsquote
init|=
literal|0
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|maxargc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|nargv
decl_stmt|;
if|if
condition|(
name|input
operator|!=
name|NULL
condition|)
block|{
name|copybuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Is a do{}while to always execute the loop once.  Always return an 	 argv, even for null strings.  See NOTES above, test case below. */
do|do
block|{
comment|/* Pick off argv[argc] */
while|while
condition|(
name|ISBLANK
argument_list|(
operator|*
name|input
argument_list|)
condition|)
block|{
name|input
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|maxargc
operator|==
literal|0
operator|)
operator|||
operator|(
name|argc
operator|>=
operator|(
name|maxargc
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* argv needs initialization, or expansion */
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|maxargc
operator|=
name|INITIAL_MAXARGC
expr_stmt|;
name|nargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|maxargc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxargc
operator|*=
literal|2
expr_stmt|;
name|nargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|argv
argument_list|,
name|maxargc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nargv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|argv
operator|!=
name|NULL
condition|)
block|{
name|freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
name|argv
operator|=
name|nargv
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Begin scanning arg */
name|arg
operator|=
name|copybuf
expr_stmt|;
while|while
condition|(
operator|*
name|input
operator|!=
name|EOS
condition|)
block|{
if|if
condition|(
name|ISSPACE
argument_list|(
operator|*
name|input
argument_list|)
operator|&&
operator|!
name|squote
operator|&&
operator|!
name|dquote
operator|&&
operator|!
name|bsquote
condition|)
block|{
break|break;
block|}
else|else
block|{
if|if
condition|(
name|bsquote
condition|)
block|{
name|bsquote
operator|=
literal|0
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input
operator|==
literal|'\\'
condition|)
block|{
name|bsquote
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|squote
condition|)
block|{
if|if
condition|(
operator|*
name|input
operator|==
literal|'\''
condition|)
block|{
name|squote
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dquote
condition|)
block|{
if|if
condition|(
operator|*
name|input
operator|==
literal|'"'
condition|)
block|{
name|dquote
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|input
operator|==
literal|'\''
condition|)
block|{
name|squote
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input
operator|==
literal|'"'
condition|)
block|{
name|dquote
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
block|}
name|input
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|arg
operator|=
name|EOS
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|strdup
argument_list|(
name|copybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|argc
index|]
operator|==
name|NULL
condition|)
block|{
name|freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|argc
operator|++
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|input
argument_list|)
condition|)
block|{
name|input
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|input
operator|!=
name|EOS
condition|)
do|;
block|}
return|return
operator|(
name|argv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  @deftypefn Extension void expandargv (int *@var{argcp}, char ***@var{argvp})  The @var{argcp} and @code{argvp} arguments are pointers to the usual @code{argc} and @code{argv} arguments to @code{main}.  This function looks for arguments that begin with the character @samp{@@}.  Any such arguments are interpreted as ``response files''.  The contents of the response file are interpreted as additional command line options.  In particular, the file is separated into whitespace-separated strings; each such string is taken as a command-line option.  The new options are inserted in place of the option naming the response file, and @code{*argcp} and @code{*argvp} will be updated.  If the value of @code{*argvp} is modified by this function, then the new value has been dynamically allocated and can be deallocated by the caller with @code{freeargv}.  However, most callers will simply call @code{expandargv} near the beginning of @code{main} and allow the operating system to free the memory when the program exits.  @end deftypefn  */
end_comment

begin_function
name|void
name|expandargv
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
comment|/* The argument we are currently processing.  */
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if ***argvp has been dynamically allocated.  */
name|int
name|argv_dynamic
init|=
literal|0
decl_stmt|;
comment|/* Loop over the arguments, handling response files.  We always skip      ARGVP[0], as that is the name of the program being run.  */
while|while
condition|(
operator|++
name|i
operator|<
operator|*
name|argcp
condition|)
block|{
comment|/* The name of the response file.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The response file.  */
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* An upper bound on the number of characters in the response 	 file.  */
name|long
name|pos
decl_stmt|;
comment|/* The number of characters in the response file, when actually 	 read.  */
name|size_t
name|len
decl_stmt|;
comment|/* A dynamically allocated buffer used to hold options read from a 	 response file.  */
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Dynamically allocated storage for the options read from the 	 response file.  */
name|char
modifier|*
modifier|*
name|file_argv
decl_stmt|;
comment|/* The number of options read from the response file, if any.  */
name|size_t
name|file_argc
decl_stmt|;
comment|/* We are only interested in options of the form "@file".  */
name|filename
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
continue|continue;
comment|/* Read the contents of the file.  */
name|f
operator|=
name|fopen
argument_list|(
operator|++
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
continue|continue;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|pos
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|pos
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|pos
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
operator|(
name|size_t
operator|)
name|pos
comment|/* On Windows, fread may return a value smaller than POS, 	     due to CR/LF->CR translation when reading text files. 	     That does not in-and-of itself indicate failure.  */
operator|&&
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* Add a NUL terminator.  */
name|buffer
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Parse the string.  */
name|file_argv
operator|=
name|buildargv
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* If *ARGVP is not already dynamically allocated, copy it.  */
if|if
condition|(
operator|!
name|argv_dynamic
condition|)
block|{
operator|*
name|argvp
operator|=
name|dupargv
argument_list|(
operator|*
name|argvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argvp
condition|)
block|{
name|fputs
argument_list|(
literal|"\nout of memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Count the number of arguments.  */
name|file_argc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|file_argv
index|[
name|file_argc
index|]
operator|&&
operator|*
name|file_argv
index|[
name|file_argc
index|]
condition|)
operator|++
name|file_argc
expr_stmt|;
comment|/* Now, insert FILE_ARGV into ARGV.  The "+1" below handles the 	 NULL terminator at the end of ARGV.  */
operator|*
name|argvp
operator|=
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|argvp
argument_list|,
operator|(
operator|*
name|argcp
operator|+
name|file_argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memmove
argument_list|(
operator|*
name|argvp
operator|+
name|i
operator|+
name|file_argc
argument_list|,
operator|*
name|argvp
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
operator|*
name|argcp
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|argvp
operator|+
name|i
argument_list|,
name|file_argv
argument_list|,
name|file_argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The original option has been replaced by all the new 	 options.  */
operator|*
name|argcp
operator|+=
name|file_argc
operator|-
literal|1
expr_stmt|;
comment|/* Free up memory allocated to process the response file.  We do 	 not use freeargv because the individual options in FILE_ARGV 	 are now in the main ARGV.  */
name|free
argument_list|(
name|file_argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Rescan all of the arguments just read to support response 	 files that include other response files.  */
operator|--
name|i
expr_stmt|;
name|error
label|:
comment|/* We're all done with the file now.  */
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_comment
comment|/* Simple little test driver. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tests
index|[]
init|=
block|{
literal|"a simple command line"
block|,
literal|"arg 'foo' is single quoted"
block|,
literal|"arg \"bar\" is double quoted"
block|,
literal|"arg \"foo bar\" has embedded whitespace"
block|,
literal|"arg 'Jack said \\'hi\\'' has single quotes"
block|,
literal|"arg 'Jack said \\\"hi\\\"' has double quotes"
block|,
literal|"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9"
block|,
comment|/* This should be expanded into only one argument.  */
literal|"trailing-whitespace "
block|,
literal|""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|test
decl_stmt|;
name|char
modifier|*
modifier|*
name|targs
decl_stmt|;
for|for
control|(
name|test
operator|=
name|tests
init|;
operator|*
name|test
operator|!=
name|NULL
condition|;
name|test
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"buildargv(\"%s\")\n"
argument_list|,
operator|*
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
operator|*
name|test
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed!\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|targs
operator|=
name|argv
init|;
operator|*
name|targs
operator|!=
name|NULL
condition|;
name|targs
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t\"%s\"\n"
argument_list|,
operator|*
name|targs
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAIN */
end_comment

end_unit

