begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Like vsprintf but provides a pointer to malloc'd storage, which must    be freed by the caller.    Copyright (C) 1994, 2003 Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ansidecl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|va_copy
argument_list|)
operator|&&
name|defined
argument_list|(
name|__va_copy
argument_list|)
end_if

begin_define
define|#
directive|define
name|va_copy
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|__va_copy((d),(s))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|unsigned
name|long
name|strtoul
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|PTR
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_decl_stmt
name|int
name|global_total_width
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  @deftypefn Extension int vasprintf (char **@var{resptr}, const char *@var{format}, va_list @var{args})  Like @code{vsprintf}, but instead of passing a pointer to a buffer, you pass a pointer to a pointer.  This function will compute the size of the buffer needed, allocate memory with @code{malloc}, and store a pointer to the allocated memory in @code{*@var{resptr}}.  The value returned is the same as @code{vsprintf} would return.  If memory could not be allocated, minus one is returned and @code{NULL} is stored in @code{*@var{resptr}}.  @end deftypefn  */
end_comment

begin_function_decl
specifier|static
name|int
name|int_vasprintf
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|int_vasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|format
decl_stmt|;
comment|/* Add one to make sure that it is never zero, which might cause malloc      to return NULL.  */
name|int
name|total_width
init|=
name|strlen
argument_list|(
name|format
argument_list|)
operator|+
literal|1
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|va_copy
name|va_copy
argument_list|(
name|ap
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|ap
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|va_list
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'%'
condition|)
block|{
while|while
condition|(
name|strchr
argument_list|(
literal|"-+ #0"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
operator|++
name|p
expr_stmt|;
name|total_width
operator|+=
name|abs
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|total_width
operator|+=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
operator|++
name|p
expr_stmt|;
name|total_width
operator|+=
name|abs
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|total_width
operator|+=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|strchr
argument_list|(
literal|"hlL"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Should be big enough for any format specifier except %s and floats.  */
name|total_width
operator|+=
literal|30
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'c'
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
comment|/* Since an ieee double can have an exponent of 307, we'll 		 make the buffer wide enough to cover the gross case. */
name|total_width
operator|+=
literal|307
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|total_width
operator|+=
name|strlen
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'n'
case|:
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|va_copy
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TEST
name|global_total_width
operator|=
name|total_width
expr_stmt|;
endif|#
directive|endif
operator|*
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|total_width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|!=
name|NULL
condition|)
return|return
name|vsprintf
argument_list|(
operator|*
name|result
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|int
name|vasprintf
argument_list|(
name|char
operator|*
operator|*
name|result
argument_list|,
specifier|const
name|char
operator|*
name|format
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|_BSD_VA_LIST_
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|_BSD_VA_LIST_
name|args
argument_list|)
else|#
directive|else
name|va_list
name|args
decl_stmt|)
endif|#
directive|endif
block|{
return|return
name|int_vasprintf
argument_list|(
name|result
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
specifier|static
name|void
name|ATTRIBUTE_PRINTF_1
name|checkit
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|result
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|result
argument_list|)
operator|<
operator|(
name|size_t
operator|)
name|global_total_width
condition|)
name|printf
argument_list|(
literal|"PASS: "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"FAIL: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %s\n"
argument_list|,
name|global_total_width
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|checkit
argument_list|(
literal|"%d"
argument_list|,
literal|0x12345678
argument_list|)
expr_stmt|;
name|checkit
argument_list|(
literal|"%200d"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|checkit
argument_list|(
literal|"%.300d"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|checkit
argument_list|(
literal|"%100.150d"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|checkit
argument_list|(
literal|"%s"
argument_list|,
literal|"jjjjjjjjjiiiiiiiiiiiiiiioooooooooooooooooppppppppppppaa\n\ 777777777777777777333333333333366666666666622222222222777777777777733333"
argument_list|)
expr_stmt|;
name|checkit
argument_list|(
literal|"%f%s%d%s"
argument_list|,
literal|1.0
argument_list|,
literal|"foo"
argument_list|,
literal|77
argument_list|,
literal|"asdjffffffffffffffiiiiiiiiiiixxxxx"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

