begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Map logical line numbers to (source file, line number) pairs.    Copyright (C) 2001, 2003, 2004    Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"line-map.h"
end_include

begin_function_decl
specifier|static
name|void
name|trace_include
parameter_list|(
specifier|const
name|struct
name|line_maps
modifier|*
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialize a line map set.  */
end_comment

begin_function
name|void
name|linemap_init
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|)
block|{
name|set
operator|->
name|maps
operator|=
name|NULL
expr_stmt|;
name|set
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|last_listed
operator|=
operator|-
literal|1
expr_stmt|;
name|set
operator|->
name|trace_includes
operator|=
name|false
expr_stmt|;
name|set
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|highest_location
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|highest_line
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|max_column_hint
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for and warn about line_maps entered but not exited.  */
end_comment

begin_function
name|void
name|linemap_check_files_exited
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
comment|/* Depending upon whether we are handling preprocessed input or      not, this can be a user error or an ICE.  */
for|for
control|(
name|map
operator|=
operator|&
name|set
operator|->
name|maps
index|[
name|set
operator|->
name|used
operator|-
literal|1
index|]
init|;
operator|!
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
condition|;
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line-map.c: file \"%s\" entered but not left\n"
argument_list|,
name|map
operator|->
name|to_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a line map set.  */
end_comment

begin_function
name|void
name|linemap_free
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|set
operator|->
name|maps
condition|)
block|{
name|linemap_check_files_exited
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|maps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a mapping of logical source line to physical source file and    line number.     The text pointed to by TO_FILE must have a lifetime    at least as long as the final call to lookup_line ().  An empty    TO_FILE means standard input.  If reason is LC_LEAVE, and    TO_FILE is NULL, then TO_FILE, TO_LINE and SYSP are given their    natural values considering the file we are returning to.     FROM_LINE should be monotonic increasing across calls to this    function.  A call to this function can relocate the previous set of    A call to this function can relocate the previous set of    maps, so any stored line_map pointers should not be used.  */
end_comment

begin_function
specifier|const
name|struct
name|line_map
modifier|*
name|linemap_add
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
name|enum
name|lc_reason
name|reason
parameter_list|,
name|unsigned
name|int
name|sysp
parameter_list|,
specifier|const
name|char
modifier|*
name|to_file
parameter_list|,
name|unsigned
name|int
name|to_line
parameter_list|)
block|{
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
name|source_location
name|start_location
init|=
name|set
operator|->
name|highest_location
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|set
operator|->
name|used
operator|&&
name|start_location
operator|<
name|set
operator|->
name|maps
index|[
name|set
operator|->
name|used
operator|-
literal|1
index|]
operator|.
name|start_location
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|used
operator|==
name|set
operator|->
name|allocated
condition|)
block|{
name|set
operator|->
name|allocated
operator|=
literal|2
operator|*
name|set
operator|->
name|allocated
operator|+
literal|256
expr_stmt|;
name|set
operator|->
name|maps
operator|=
name|XRESIZEVEC
argument_list|(
expr|struct
name|line_map
argument_list|,
name|set
operator|->
name|maps
argument_list|,
name|set
operator|->
name|allocated
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
operator|&
name|set
operator|->
name|maps
index|[
name|set
operator|->
name|used
index|]
expr_stmt|;
if|if
condition|(
name|to_file
operator|&&
operator|*
name|to_file
operator|==
literal|'\0'
condition|)
name|to_file
operator|=
literal|"<stdin>"
expr_stmt|;
comment|/* If we don't keep our line maps consistent, we can easily      segfault.  Don't rely on the client to do it for us.  */
if|if
condition|(
name|set
operator|->
name|depth
operator|==
literal|0
condition|)
name|reason
operator|=
name|LC_ENTER
expr_stmt|;
elseif|else
if|if
condition|(
name|reason
operator|==
name|LC_LEAVE
condition|)
block|{
name|struct
name|line_map
modifier|*
name|from
decl_stmt|;
name|bool
name|error
decl_stmt|;
if|if
condition|(
name|MAIN_FILE_P
argument_list|(
name|map
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|to_file
operator|==
name|NULL
condition|)
block|{
name|set
operator|->
name|depth
operator|--
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|error
operator|=
name|true
expr_stmt|;
name|reason
operator|=
name|LC_RENAME
expr_stmt|;
name|from
operator|=
name|map
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|to_file
operator|&&
name|strcmp
argument_list|(
name|from
operator|->
name|to_file
argument_list|,
name|to_file
argument_list|)
expr_stmt|;
block|}
comment|/* Depending upon whether we are handling preprocessed input or 	 not, this can be a user error or an ICE.  */
if|if
condition|(
name|error
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line-map.c: file \"%s\" left but not entered\n"
argument_list|,
name|to_file
argument_list|)
expr_stmt|;
comment|/* A TO_FILE of NULL is special - we use the natural values.  */
if|if
condition|(
name|error
operator|||
name|to_file
operator|==
name|NULL
condition|)
block|{
name|to_file
operator|=
name|from
operator|->
name|to_file
expr_stmt|;
name|to_line
operator|=
name|SOURCE_LINE
argument_list|(
name|from
argument_list|,
name|from
index|[
literal|1
index|]
operator|.
name|start_location
argument_list|)
expr_stmt|;
name|sysp
operator|=
name|from
operator|->
name|sysp
expr_stmt|;
block|}
block|}
name|map
operator|->
name|reason
operator|=
name|reason
expr_stmt|;
name|map
operator|->
name|sysp
operator|=
name|sysp
expr_stmt|;
name|map
operator|->
name|start_location
operator|=
name|start_location
expr_stmt|;
name|map
operator|->
name|to_file
operator|=
name|to_file
expr_stmt|;
name|map
operator|->
name|to_line
operator|=
name|to_line
expr_stmt|;
name|set
operator|->
name|cache
operator|=
name|set
operator|->
name|used
operator|++
expr_stmt|;
name|map
operator|->
name|column_bits
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|highest_location
operator|=
name|start_location
expr_stmt|;
name|set
operator|->
name|highest_line
operator|=
name|start_location
expr_stmt|;
name|set
operator|->
name|max_column_hint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|LC_ENTER
condition|)
block|{
name|map
operator|->
name|included_from
operator|=
name|set
operator|->
name|depth
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
call|(
name|int
call|)
argument_list|(
name|set
operator|->
name|used
operator|-
literal|2
argument_list|)
expr_stmt|;
name|set
operator|->
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|trace_includes
condition|)
name|trace_include
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|LC_RENAME
condition|)
name|map
operator|->
name|included_from
operator|=
name|map
index|[
operator|-
literal|1
index|]
operator|.
name|included_from
expr_stmt|;
elseif|else
if|if
condition|(
name|reason
operator|==
name|LC_LEAVE
condition|)
block|{
name|set
operator|->
name|depth
operator|--
expr_stmt|;
name|map
operator|->
name|included_from
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
operator|-
literal|1
argument_list|)
operator|->
name|included_from
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function

begin_function
name|source_location
name|linemap_line_start
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
name|unsigned
name|int
name|to_line
parameter_list|,
name|unsigned
name|int
name|max_column_hint
parameter_list|)
block|{
name|struct
name|line_map
modifier|*
name|map
init|=
operator|&
name|set
operator|->
name|maps
index|[
name|set
operator|->
name|used
operator|-
literal|1
index|]
decl_stmt|;
name|source_location
name|highest
init|=
name|set
operator|->
name|highest_location
decl_stmt|;
name|source_location
name|r
decl_stmt|;
name|unsigned
name|int
name|last_line
init|=
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|set
operator|->
name|highest_line
argument_list|)
decl_stmt|;
name|int
name|line_delta
init|=
name|to_line
operator|-
name|last_line
decl_stmt|;
name|bool
name|add_map
init|=
name|false
decl_stmt|;
if|if
condition|(
name|line_delta
operator|<
literal|0
operator|||
operator|(
name|line_delta
operator|>
literal|10
operator|&&
name|line_delta
operator|*
name|map
operator|->
name|column_bits
operator|>
literal|1000
operator|)
operator|||
operator|(
name|max_column_hint
operator|>=
operator|(
literal|1U
operator|<<
name|map
operator|->
name|column_bits
operator|)
operator|)
operator|||
operator|(
name|max_column_hint
operator|<=
literal|80
operator|&&
name|map
operator|->
name|column_bits
operator|>=
literal|10
operator|)
condition|)
block|{
name|add_map
operator|=
name|true
expr_stmt|;
block|}
else|else
name|max_column_hint
operator|=
name|set
operator|->
name|max_column_hint
expr_stmt|;
if|if
condition|(
name|add_map
condition|)
block|{
name|int
name|column_bits
decl_stmt|;
if|if
condition|(
name|max_column_hint
operator|>
literal|100000
operator|||
name|highest
operator|>
literal|0xC0000000
condition|)
block|{
comment|/* If the column number is ridiculous or we've allocated a huge 	     number of source_locations, give up on column numbers. */
name|max_column_hint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|highest
operator|>
literal|0xF0000000
condition|)
return|return
literal|0
return|;
name|column_bits
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|column_bits
operator|=
literal|7
expr_stmt|;
while|while
condition|(
name|max_column_hint
operator|>=
operator|(
literal|1U
operator|<<
name|column_bits
operator|)
condition|)
name|column_bits
operator|++
expr_stmt|;
name|max_column_hint
operator|=
literal|1U
operator|<<
name|column_bits
expr_stmt|;
block|}
comment|/* Allocate the new line_map.  However, if the current map only has a 	 single line we can sometimes just increase its column_bits instead. */
if|if
condition|(
name|line_delta
operator|<
literal|0
operator|||
name|last_line
operator|!=
name|map
operator|->
name|to_line
operator|||
name|SOURCE_COLUMN
argument_list|(
name|map
argument_list|,
name|highest
argument_list|)
operator|>=
operator|(
literal|1U
operator|<<
name|column_bits
operator|)
condition|)
name|map
operator|=
operator|(
expr|struct
name|line_map
operator|*
operator|)
name|linemap_add
argument_list|(
name|set
argument_list|,
name|LC_RENAME
argument_list|,
name|map
operator|->
name|sysp
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|to_line
argument_list|)
expr_stmt|;
name|map
operator|->
name|column_bits
operator|=
name|column_bits
expr_stmt|;
name|r
operator|=
name|map
operator|->
name|start_location
operator|+
operator|(
operator|(
name|to_line
operator|-
name|map
operator|->
name|to_line
operator|)
operator|<<
name|column_bits
operator|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|highest
operator|-
name|SOURCE_COLUMN
argument_list|(
name|map
argument_list|,
name|highest
argument_list|)
operator|+
operator|(
name|line_delta
operator|<<
name|map
operator|->
name|column_bits
operator|)
expr_stmt|;
name|set
operator|->
name|highest_line
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|set
operator|->
name|highest_location
condition|)
name|set
operator|->
name|highest_location
operator|=
name|r
expr_stmt|;
name|set
operator|->
name|max_column_hint
operator|=
name|max_column_hint
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|source_location
name|linemap_position_for_column
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
name|unsigned
name|int
name|to_column
parameter_list|)
block|{
name|source_location
name|r
init|=
name|set
operator|->
name|highest_line
decl_stmt|;
if|if
condition|(
name|to_column
operator|>=
name|set
operator|->
name|max_column_hint
condition|)
block|{
if|if
condition|(
name|r
operator|>=
literal|0xC000000
operator|||
name|to_column
operator|>
literal|100000
condition|)
block|{
comment|/* Running low on source_locations - disable column numbers.  */
return|return
name|r
return|;
block|}
else|else
block|{
name|struct
name|line_map
modifier|*
name|map
init|=
operator|&
name|set
operator|->
name|maps
index|[
name|set
operator|->
name|used
operator|-
literal|1
index|]
decl_stmt|;
name|r
operator|=
name|linemap_line_start
argument_list|(
name|set
argument_list|,
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|r
argument_list|)
argument_list|,
name|to_column
operator|+
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|=
name|r
operator|+
name|to_column
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|set
operator|->
name|highest_location
condition|)
name|set
operator|->
name|highest_location
operator|=
name|r
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Given a logical line, returns the map from which the corresponding    (source file, line) pair can be deduced.  Since the set is built    chronologically, the logical lines are monotonic increasing, and so    the list is sorted and we can use a binary search.  */
end_comment

begin_function
specifier|const
name|struct
name|line_map
modifier|*
name|linemap_lookup
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
name|source_location
name|line
parameter_list|)
block|{
name|unsigned
name|int
name|md
decl_stmt|,
name|mn
decl_stmt|,
name|mx
decl_stmt|;
specifier|const
name|struct
name|line_map
modifier|*
name|cached
decl_stmt|;
name|mn
operator|=
name|set
operator|->
name|cache
expr_stmt|;
name|mx
operator|=
name|set
operator|->
name|used
expr_stmt|;
name|cached
operator|=
operator|&
name|set
operator|->
name|maps
index|[
name|mn
index|]
expr_stmt|;
comment|/* We should get a segfault if no line_maps have been added yet.  */
if|if
condition|(
name|line
operator|>=
name|cached
operator|->
name|start_location
condition|)
block|{
if|if
condition|(
name|mn
operator|+
literal|1
operator|==
name|mx
operator|||
name|line
operator|<
name|cached
index|[
literal|1
index|]
operator|.
name|start_location
condition|)
return|return
name|cached
return|;
block|}
else|else
block|{
name|mx
operator|=
name|mn
expr_stmt|;
name|mn
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|mx
operator|-
name|mn
operator|>
literal|1
condition|)
block|{
name|md
operator|=
operator|(
name|mn
operator|+
name|mx
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|maps
index|[
name|md
index|]
operator|.
name|start_location
operator|>
name|line
condition|)
name|mx
operator|=
name|md
expr_stmt|;
else|else
name|mn
operator|=
name|md
expr_stmt|;
block|}
name|set
operator|->
name|cache
operator|=
name|mn
expr_stmt|;
return|return
operator|&
name|set
operator|->
name|maps
index|[
name|mn
index|]
return|;
block|}
end_function

begin_comment
comment|/* Print the file names and line numbers of the #include commands    which led to the map MAP, if any, to stderr.  Nothing is output if    the most recently listed stack is the same as the current one.  */
end_comment

begin_function
name|void
name|linemap_print_containing_files
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
name|map
parameter_list|)
block|{
if|if
condition|(
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
operator|||
name|set
operator|->
name|last_listed
operator|==
name|map
operator|->
name|included_from
condition|)
return|return;
name|set
operator|->
name|last_listed
operator|=
name|map
operator|->
name|included_from
expr_stmt|;
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"In file included from %s:%u"
argument_list|)
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|LAST_SOURCE_LINE
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Translators note: this message is used in conjunction 	 with "In file included from %s:%ld" and some other 	 tricks.  We want something like this:  	 | In file included from sys/select.h:123, 	 |                  from sys/types.h:234, 	 |                  from userfile.c:31: 	 | bits/select.h:45:<error message here>  	 with all the "from"s lined up. 	 The trailing comma is at the beginning of this message, 	 and the trailing colon is not translated.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|",\n                 from %s:%u"
argument_list|)
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|LAST_SOURCE_LINE
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an include trace, for e.g. the -H option of the preprocessor.  */
end_comment

begin_function
specifier|static
name|void
name|trace_include
parameter_list|(
specifier|const
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
name|map
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
name|set
operator|->
name|depth
decl_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|map
operator|->
name|to_file
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

