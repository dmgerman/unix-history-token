begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dependency generator for Makefile fragments.    Copyright (C) 2000, 2001, 2003, 2007 Free Software Foundation, Inc.    Contributed by Zack Weinberg, Mar 2000  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_comment
comment|/* Keep this structure local to this file, so clients don't find it    easy to start making assumptions.  */
end_comment

begin_struct
struct|struct
name|deps
block|{
specifier|const
name|char
modifier|*
modifier|*
name|targetv
decl_stmt|;
name|unsigned
name|int
name|ntargets
decl_stmt|;
comment|/* number of slots actually occupied */
name|unsigned
name|int
name|targets_size
decl_stmt|;
comment|/* amt of allocated space - in words */
specifier|const
name|char
modifier|*
modifier|*
name|depv
decl_stmt|;
name|unsigned
name|int
name|ndeps
decl_stmt|;
name|unsigned
name|int
name|deps_size
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|vpathv
decl_stmt|;
name|size_t
modifier|*
name|vpathlv
decl_stmt|;
name|unsigned
name|int
name|nvpaths
decl_stmt|;
name|unsigned
name|int
name|vpaths_size
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|munge
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Given a filename, quote characters in that filename which are    significant to Make.  Note that it's not possible to quote all such    characters - e.g. \n, %, *, ?, [, \ (in some contexts), and ~ are    not properly handled.  It isn't possible to get this right in any    current version of Make.  (??? Still true?  Old comment referred to    3.76.1.)  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|munge
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
for|for
control|(
name|p
operator|=
name|filename
operator|,
name|len
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|len
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* GNU make uses a weird quoting scheme for white space. 	     A space or tab preceded by 2N+1 backslashes represents 	     N backslashes followed by space; a space or tab 	     preceded by 2N backslashes represents N backslashes at 	     the end of a file name; and backslashes in other 	     contexts should not be doubled.  */
for|for
control|(
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|filename
operator|<=
name|q
operator|&&
operator|*
name|q
operator|==
literal|'\\'
condition|;
name|q
operator|--
control|)
name|len
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* '$' is quoted by doubling it.  */
name|len
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now we know how big to make the buffer.  */
name|buffer
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|filename
operator|,
name|dst
operator|=
name|buffer
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|dst
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
for|for
control|(
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|filename
operator|<=
name|q
operator|&&
operator|*
name|q
operator|==
literal|'\\'
condition|;
name|q
operator|--
control|)
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'$'
expr_stmt|;
break|break;
default|default:
comment|/* nothing */
empty_stmt|;
block|}
operator|*
name|dst
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* If T begins with any of the partial pathnames listed in d->vpathv,    then advance T to point beyond that pathname.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|apply_vpath
parameter_list|(
name|struct
name|deps
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|vpathv
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|nvpaths
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|d
operator|->
name|vpathv
index|[
name|i
index|]
argument_list|,
name|t
argument_list|,
name|d
operator|->
name|vpathlv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|t
operator|+
name|d
operator|->
name|vpathlv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|not_this_one
goto|;
comment|/* Do not simplify $(vpath)/../whatever.  ??? Might not 		 be necessary. */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
condition|)
goto|goto
name|not_this_one
goto|;
comment|/* found a match */
name|t
operator|=
name|t
operator|+
name|d
operator|->
name|vpathlv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|not_this_one
label|:
empty_stmt|;
block|}
block|}
comment|/* Remove leading ./ in any case.  */
while|while
condition|(
name|t
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|t
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|t
operator|+=
literal|2
expr_stmt|;
comment|/* If we removed a leading ./, then also remove any /s after the 	 first.  */
while|while
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
condition|)
operator|++
name|t
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Public routines.  */
end_comment

begin_function
name|struct
name|deps
modifier|*
name|deps_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|XCNEW
argument_list|(
expr|struct
name|deps
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|deps_free
parameter_list|(
name|struct
name|deps
modifier|*
name|d
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|targetv
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ntargets
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|d
operator|->
name|targetv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|targetv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|depv
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|depv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|vpathv
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|nvpaths
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|d
operator|->
name|vpathv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|vpathv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|vpathlv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds a target T.  We make a copy, so it need not be a permanent    string.  QUOTE is true if the string should be quoted.  */
end_comment

begin_function
name|void
name|deps_add_target
parameter_list|(
name|struct
name|deps
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|t
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ntargets
operator|==
name|d
operator|->
name|targets_size
condition|)
block|{
name|d
operator|->
name|targets_size
operator|=
name|d
operator|->
name|targets_size
operator|*
literal|2
operator|+
literal|4
expr_stmt|;
name|d
operator|->
name|targetv
operator|=
name|XRESIZEVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|d
operator|->
name|targetv
argument_list|,
name|d
operator|->
name|targets_size
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|apply_vpath
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
name|t
operator|=
name|munge
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Also makes permanent copy.  */
else|else
name|t
operator|=
name|xstrdup
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|->
name|targetv
index|[
name|d
operator|->
name|ntargets
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets the default target if none has been given already.  An empty    string as the default target in interpreted as stdin.  The string    is quoted for MAKE.  */
end_comment

begin_function
name|void
name|deps_add_default_target
parameter_list|(
name|struct
name|deps
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|tgt
parameter_list|)
block|{
comment|/* Only if we have no targets.  */
if|if
condition|(
name|d
operator|->
name|ntargets
condition|)
return|return;
if|if
condition|(
name|tgt
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|deps_add_target
argument_list|(
name|d
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|TARGET_OBJECT_SUFFIX
define|#
directive|define
name|TARGET_OBJECT_SUFFIX
value|".o"
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|start
init|=
name|lbasename
argument_list|(
name|tgt
argument_list|)
decl_stmt|;
name|char
modifier|*
name|o
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|start
argument_list|)
operator|+
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|strcpy
argument_list|(
name|o
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|strrchr
argument_list|(
name|o
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|suffix
condition|)
name|suffix
operator|=
name|o
operator|+
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|suffix
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|)
expr_stmt|;
name|deps_add_target
argument_list|(
name|d
argument_list|,
name|o
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|deps_add_dep
parameter_list|(
name|struct
name|deps
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|=
name|munge
argument_list|(
name|apply_vpath
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Also makes permanent copy.  */
if|if
condition|(
name|d
operator|->
name|ndeps
operator|==
name|d
operator|->
name|deps_size
condition|)
block|{
name|d
operator|->
name|deps_size
operator|=
name|d
operator|->
name|deps_size
operator|*
literal|2
operator|+
literal|8
expr_stmt|;
name|d
operator|->
name|depv
operator|=
name|XRESIZEVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|d
operator|->
name|depv
argument_list|,
name|d
operator|->
name|deps_size
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|depv
index|[
name|d
operator|->
name|ndeps
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deps_add_vpath
parameter_list|(
name|struct
name|deps
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|vpath
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|elem
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|size_t
name|len
decl_stmt|;
for|for
control|(
name|elem
operator|=
name|vpath
init|;
operator|*
name|elem
condition|;
name|elem
operator|=
name|p
control|)
block|{
for|for
control|(
name|p
operator|=
name|elem
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|p
operator|-
name|elem
expr_stmt|;
name|copy
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|elem
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copy
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|nvpaths
operator|==
name|d
operator|->
name|vpaths_size
condition|)
block|{
name|d
operator|->
name|vpaths_size
operator|=
name|d
operator|->
name|vpaths_size
operator|*
literal|2
operator|+
literal|8
expr_stmt|;
name|d
operator|->
name|vpathv
operator|=
name|XRESIZEVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|d
operator|->
name|vpathv
argument_list|,
name|d
operator|->
name|vpaths_size
argument_list|)
expr_stmt|;
name|d
operator|->
name|vpathlv
operator|=
name|XRESIZEVEC
argument_list|(
name|size_t
argument_list|,
name|d
operator|->
name|vpathlv
argument_list|,
name|d
operator|->
name|vpaths_size
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|vpathv
index|[
name|d
operator|->
name|nvpaths
index|]
operator|=
name|copy
expr_stmt|;
name|d
operator|->
name|vpathlv
index|[
name|d
operator|->
name|nvpaths
index|]
operator|=
name|len
expr_stmt|;
name|d
operator|->
name|nvpaths
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|deps_write
parameter_list|(
specifier|const
name|struct
name|deps
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|unsigned
name|int
name|colmax
parameter_list|)
block|{
name|unsigned
name|int
name|size
decl_stmt|,
name|i
decl_stmt|,
name|column
decl_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|colmax
operator|&&
name|colmax
operator|<
literal|34
condition|)
name|colmax
operator|=
literal|34
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ntargets
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|targetv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|colmax
operator|&&
name|column
operator|>
name|colmax
condition|)
block|{
name|fputs
argument_list|(
literal|" \\\n "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|=
literal|1
operator|+
name|size
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
name|d
operator|->
name|targetv
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|':'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|colmax
operator|&&
name|column
operator|>
name|colmax
condition|)
block|{
name|fputs
argument_list|(
literal|" \\\n "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|=
literal|1
operator|+
name|size
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deps_phony_targets
parameter_list|(
specifier|const
name|struct
name|deps
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|d
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|':'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out a deps buffer to a file, in a form that can be read back    with deps_restore.  Returns nonzero on error, in which case the    error number will be in errno.  */
end_comment

begin_function
name|int
name|deps_save
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* The cppreader structure contains makefile dependences.  Write out this      structure.  */
comment|/* The number of dependences.  */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|deps
operator|->
name|ndeps
argument_list|,
sizeof|sizeof
argument_list|(
name|deps
operator|->
name|ndeps
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The length of each dependence followed by the string.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|deps
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|num_to_write
init|=
name|strlen
argument_list|(
name|deps
operator|->
name|depv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|num_to_write
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fwrite
argument_list|(
name|deps
operator|->
name|depv
index|[
name|i
index|]
argument_list|,
name|num_to_write
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read back dependency information written with deps_save into    the deps buffer.  The third argument may be NULL, in which case    the dependency information is just skipped, or it may be a filename,    in which case that filename is skipped.  */
end_comment

begin_function
name|int
name|deps_restore
parameter_list|(
name|struct
name|deps
modifier|*
name|deps
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|self
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|size_t
name|num_to_read
decl_stmt|;
name|size_t
name|buf_size
init|=
literal|512
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|buf_size
argument_list|)
decl_stmt|;
comment|/* Number of dependences.  */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|count
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|count
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The length of each dependence string, followed by the string.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read in # bytes in string.  */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|num_to_read
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|buf_size
operator|<
name|num_to_read
operator|+
literal|1
condition|)
block|{
name|buf_size
operator|=
name|num_to_read
operator|+
literal|1
operator|+
literal|127
expr_stmt|;
name|buf
operator|=
name|XRESIZEVEC
argument_list|(
name|char
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|num_to_read
argument_list|,
name|fd
argument_list|)
operator|!=
name|num_to_read
condition|)
return|return
operator|-
literal|1
return|;
name|buf
index|[
name|num_to_read
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Generate makefile dependencies from .pch if -nopch-deps.  */
if|if
condition|(
name|self
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|buf
argument_list|,
name|self
argument_list|)
operator|!=
literal|0
condition|)
name|deps_add_dep
argument_list|(
name|deps
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

