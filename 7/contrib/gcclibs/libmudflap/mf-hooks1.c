begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Mudflap: narrow-pointer bounds-checking by tree rewriting.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Frank Ch. Eigler<fche@redhat.com>    and Graydon Hoare<graydon@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SOCKLEN_T
end_ifndef

begin_define
define|#
directive|define
name|socklen_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These attempt to coax various unix flavours to declare all our    needed tidbits in the system headers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some BSDs break<sys/socket.h> if this is defined. */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_define
define|#
directive|define
name|_XOPEN_SOURCE
end_define

begin_define
define|#
directive|define
name|_BSD_TYPES
end_define

begin_define
define|#
directive|define
name|__EXTENSIONS__
end_define

begin_define
define|#
directive|define
name|_ALL_SOURCE
end_define

begin_define
define|#
directive|define
name|_LARGE_FILE_API
end_define

begin_define
define|#
directive|define
name|_XOPEN_SOURCE_EXTENDED
value|1
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mf-runtime.h"
end_include

begin_include
include|#
directive|include
file|"mf-impl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MUDFLAP
end_ifdef

begin_error
error|#
directive|error
literal|"Do not compile this file with -fmudflap!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Memory allocation related hook functions.  Some of these are    intercepted via linker wrapping or symbol interposition.  Others    use plain macros in mf-runtime.h.  */
end_comment

begin_if
if|#
directive|if
name|PIC
end_if

begin_comment
comment|/* A special bootstrap variant. */
end_comment

begin_function
name|void
modifier|*
name|__mf_0fn_malloc
parameter_list|(
name|size_t
name|c
parameter_list|)
block|{
enum|enum
name|foo
block|{
name|BS
init|=
literal|4096
block|,
name|NB
init|=
literal|10
block|}
enum|;
specifier|static
name|char
name|bufs
index|[
name|NB
index|]
index|[
name|BS
index|]
decl_stmt|;
specifier|static
name|unsigned
name|bufs_used
index|[
name|NB
index|]
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bufs_used
index|[
name|i
index|]
operator|&&
name|c
operator|<
name|BS
condition|)
block|{
name|bufs_used
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|bufs
index|[
name|i
index|]
index|[
literal|0
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_macro
name|WRAPPER
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t c
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|size_with_crumple_zones
decl_stmt|;
name|DECLARE
argument_list|(
argument|void *
argument_list|,
argument|malloc
argument_list|,
argument|size_t c
argument_list|)
empty_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
name|BEGIN_PROTECT
argument_list|(
name|malloc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|size_with_crumple_zones
operator|=
name|CLAMPADD
argument_list|(
name|c
argument_list|,
name|CLAMPADD
argument_list|(
name|__mf_opts
operator|.
name|crumple_zone
argument_list|,
name|__mf_opts
operator|.
name|crumple_zone
argument_list|)
argument_list|)
expr_stmt|;
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
name|size_with_crumple_zones
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|+=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
name|__mf_register
argument_list|(
name|result
argument_list|,
name|c
argument_list|,
name|__MF_TYPE_HEAP
argument_list|,
literal|"malloc region"
argument_list|)
expr_stmt|;
comment|/* XXX: register __MF_TYPE_NOACCESS for crumple zones.  */
block|}
return|return
name|result
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|PIC
end_ifdef

begin_comment
comment|/* A special bootstrap variant. */
end_comment

begin_function
name|void
modifier|*
name|__mf_0fn_calloc
parameter_list|(
name|size_t
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
name|__mf_0fn_malloc
argument_list|(
name|c
operator|*
name|n
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_macro
name|WRAPPER
argument_list|(
argument|void *
argument_list|,
argument|calloc
argument_list|,
argument|size_t c
argument_list|,
argument|size_t n
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|size_with_crumple_zones
decl_stmt|;
name|DECLARE
argument_list|(
name|void
operator|*
argument_list|,
name|calloc
argument_list|,
name|size_t
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|DECLARE
argument_list|(
name|void
operator|*
argument_list|,
name|malloc
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|DECLARE
argument_list|(
name|void
operator|*
argument_list|,
name|memset
argument_list|,
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|BEGIN_PROTECT
argument_list|(
name|calloc
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|size_with_crumple_zones
operator|=
name|CLAMPADD
argument_list|(
operator|(
name|c
operator|*
name|n
operator|)
argument_list|,
comment|/* XXX: CLAMPMUL */
name|CLAMPADD
argument_list|(
name|__mf_opts
operator|.
name|crumple_zone
argument_list|,
name|__mf_opts
operator|.
name|crumple_zone
argument_list|)
argument_list|)
expr_stmt|;
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
name|size_with_crumple_zones
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|result
argument_list|)
condition|)
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|size_with_crumple_zones
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|+=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
name|__mf_register
argument_list|(
name|result
argument_list|,
name|c
operator|*
name|n
comment|/* XXX: clamp */
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|,
literal|"calloc region"
argument_list|)
expr_stmt|;
comment|/* XXX: register __MF_TYPE_NOACCESS for crumple zones.  */
block|}
return|return
name|result
return|;
block|}
end_block

begin_if
if|#
directive|if
name|PIC
end_if

begin_comment
comment|/* A special bootstrap variant. */
end_comment

begin_function
name|void
modifier|*
name|__mf_0fn_realloc
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|c
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_macro
name|WRAPPER
argument_list|(
argument|void *
argument_list|,
argument|realloc
argument_list|,
argument|void *buf
argument_list|,
argument|size_t c
argument_list|)
end_macro

begin_block
block|{
name|DECLARE
argument_list|(
name|void
operator|*
argument_list|,
name|realloc
argument_list|,
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|size_t
name|size_with_crumple_zones
decl_stmt|;
name|char
modifier|*
name|base
init|=
name|buf
decl_stmt|;
name|unsigned
name|saved_wipe_heap
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|BEGIN_PROTECT
argument_list|(
name|realloc
argument_list|,
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|buf
argument_list|)
condition|)
name|base
operator|-=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
name|size_with_crumple_zones
operator|=
name|CLAMPADD
argument_list|(
name|c
argument_list|,
name|CLAMPADD
argument_list|(
name|__mf_opts
operator|.
name|crumple_zone
argument_list|,
name|__mf_opts
operator|.
name|crumple_zone
argument_list|)
argument_list|)
expr_stmt|;
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|CALL_REAL
argument_list|(
name|realloc
argument_list|,
name|base
argument_list|,
name|size_with_crumple_zones
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
comment|/* Ensure heap wiping doesn't occur during this peculiar      unregister/reregister pair.  */
name|LOCKTH
argument_list|()
expr_stmt|;
name|__mf_set_state
argument_list|(
name|reentrant
argument_list|)
expr_stmt|;
name|saved_wipe_heap
operator|=
name|__mf_opts
operator|.
name|wipe_heap
expr_stmt|;
name|__mf_opts
operator|.
name|wipe_heap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|buf
argument_list|)
condition|)
name|__mfu_unregister
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|)
expr_stmt|;
comment|/* NB: underlying region may have been __MF_TYPE_HEAP. */
if|if
condition|(
name|LIKELY
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|result
operator|+=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
name|__mfu_register
argument_list|(
name|result
argument_list|,
name|c
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|,
literal|"realloc region"
argument_list|)
expr_stmt|;
comment|/* XXX: register __MF_TYPE_NOACCESS for crumple zones.  */
block|}
comment|/* Restore previous setting.  */
name|__mf_opts
operator|.
name|wipe_heap
operator|=
name|saved_wipe_heap
expr_stmt|;
name|__mf_set_state
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_if
if|#
directive|if
name|PIC
end_if

begin_comment
comment|/* A special bootstrap variant. */
end_comment

begin_function
name|void
name|__mf_0fn_free
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|)
block|{
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_macro
name|WRAPPER
argument_list|(
argument|void
argument_list|,
argument|free
argument_list|,
argument|void *buf
argument_list|)
end_macro

begin_block
block|{
comment|/* Use a circular queue to delay some number (__mf_opts.free_queue_length) of free()s.  */
specifier|static
name|void
modifier|*
name|free_queue
index|[
name|__MF_FREEQ_MAX
index|]
decl_stmt|;
specifier|static
name|unsigned
name|free_ptr
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|freeq_initialized
init|=
literal|0
decl_stmt|;
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|BEGIN_PROTECT
argument_list|(
name|free
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|buf
operator|==
name|NULL
argument_list|)
condition|)
return|return;
name|LOCKTH
argument_list|()
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|freeq_initialized
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|free_queue
argument_list|,
literal|0
argument_list|,
name|__MF_FREEQ_MAX
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|freeq_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|UNLOCKTH
argument_list|()
expr_stmt|;
name|__mf_unregister
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|)
expr_stmt|;
comment|/* NB: underlying region may have been __MF_TYPE_HEAP. */
if|if
condition|(
name|UNLIKELY
argument_list|(
name|__mf_opts
operator|.
name|free_queue_length
operator|>
literal|0
argument_list|)
condition|)
block|{
name|char
modifier|*
name|freeme
init|=
name|NULL
decl_stmt|;
name|LOCKTH
argument_list|()
expr_stmt|;
if|if
condition|(
name|free_queue
index|[
name|free_ptr
index|]
operator|!=
name|NULL
condition|)
block|{
name|freeme
operator|=
name|free_queue
index|[
name|free_ptr
index|]
expr_stmt|;
name|freeme
operator|-=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
block|}
name|free_queue
index|[
name|free_ptr
index|]
operator|=
name|buf
expr_stmt|;
name|free_ptr
operator|=
operator|(
name|free_ptr
operator|==
operator|(
name|__mf_opts
operator|.
name|free_queue_length
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|free_ptr
operator|+
literal|1
operator|)
expr_stmt|;
name|UNLOCKTH
argument_list|()
expr_stmt|;
if|if
condition|(
name|freeme
condition|)
block|{
if|if
condition|(
name|__mf_opts
operator|.
name|trace_mf_calls
condition|)
block|{
name|VERBOSE_TRACE
argument_list|(
literal|"freeing deferred pointer %p (crumple %u)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|freeme
argument_list|,
name|__mf_opts
operator|.
name|crumple_zone
argument_list|)
expr_stmt|;
block|}
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|freeme
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* back pointer up a bit to the beginning of crumple zone */
name|char
modifier|*
name|base
init|=
operator|(
name|char
operator|*
operator|)
name|buf
decl_stmt|;
name|base
operator|-=
name|__mf_opts
operator|.
name|crumple_zone
expr_stmt|;
if|if
condition|(
name|__mf_opts
operator|.
name|trace_mf_calls
condition|)
block|{
name|VERBOSE_TRACE
argument_list|(
literal|"freeing pointer %p = %p - %u\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|base
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|__mf_opts
operator|.
name|crumple_zone
argument_list|)
expr_stmt|;
block|}
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* We can only wrap mmap if the target supports it.  Likewise for munmap.    We assume we have both if we have mmap.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP
end_ifdef

begin_if
if|#
directive|if
name|PIC
end_if

begin_comment
comment|/* A special bootstrap variant. */
end_comment

begin_function
name|void
modifier|*
name|__mf_0fn_mmap
parameter_list|(
name|void
modifier|*
name|start
parameter_list|,
name|size_t
name|l
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|fd
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|mmap
end_undef

begin_macro
name|WRAPPER
argument_list|(
argument|void *
argument_list|,
argument|mmap
argument_list|,
argument|void  *start
argument_list|,
argument|size_t length
argument_list|,
argument|int prot
argument_list|,
argument|int flags
argument_list|,
argument|int fd
argument_list|,
argument|off_t offset
argument_list|)
end_macro

begin_block
block|{
name|DECLARE
argument_list|(
name|void
operator|*
argument_list|,
name|mmap
argument_list|,
name|void
operator|*
argument_list|,
name|size_t
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|off_t
argument_list|)
expr_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
name|BEGIN_PROTECT
argument_list|(
name|mmap
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
name|CALL_REAL
argument_list|(
name|mmap
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/*   VERBOSE_TRACE ("mmap (%08lx, %08lx, ...) => %08lx\n", 		 (uintptr_t) start, (uintptr_t) length, 		 (uintptr_t) result);   */
if|if
condition|(
name|result
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Register each page as a heap object.  Why not register it all 	 as a single segment?  That's so that a later munmap() call 	 can unmap individual pages.  XXX: would __MF_TYPE_GUESS make 	 this more automatic?  */
name|size_t
name|ps
init|=
name|getpagesize
argument_list|()
decl_stmt|;
name|uintptr_t
name|base
init|=
operator|(
name|uintptr_t
operator|)
name|result
decl_stmt|;
name|uintptr_t
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|length
condition|;
name|offset
operator|+=
name|ps
control|)
block|{
comment|/* XXX: We could map PROT_NONE to __MF_TYPE_NOACCESS. */
comment|/* XXX: Unaccessed HEAP pages are reported as leaks.  Is this 	     appropriate for unaccessed mmap pages? */
name|__mf_register
argument_list|(
operator|(
name|void
operator|*
operator|)
name|CLAMPADD
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|,
name|ps
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|,
literal|"mmap page"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block

begin_if
if|#
directive|if
name|PIC
end_if

begin_comment
comment|/* A special bootstrap variant. */
end_comment

begin_function
name|int
name|__mf_0fn_munmap
parameter_list|(
name|void
modifier|*
name|start
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|munmap
end_undef

begin_macro
name|WRAPPER
argument_list|(
argument|int
argument_list|,
argument|munmap
argument_list|,
argument|void *start
argument_list|,
argument|size_t length
argument_list|)
end_macro

begin_block
block|{
name|DECLARE
argument_list|(
name|int
argument_list|,
name|munmap
argument_list|,
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|int
name|result
decl_stmt|;
name|BEGIN_PROTECT
argument_list|(
name|munmap
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|CALL_REAL
argument_list|(
name|munmap
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/*   VERBOSE_TRACE ("munmap (%08lx, %08lx, ...) => %08lx\n", 		 (uintptr_t) start, (uintptr_t) length, 		 (uintptr_t) result);   */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|/* Unregister each page as a heap object.  */
name|size_t
name|ps
init|=
name|getpagesize
argument_list|()
decl_stmt|;
name|uintptr_t
name|base
init|=
operator|(
name|uintptr_t
operator|)
name|start
operator|&
operator|(
operator|~
operator|(
name|ps
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
comment|/* page align */
name|uintptr_t
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|length
condition|;
name|offset
operator|+=
name|ps
control|)
name|__mf_unregister
argument_list|(
operator|(
name|void
operator|*
operator|)
name|CLAMPADD
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|,
name|ps
argument_list|,
name|__MF_TYPE_HEAP_I
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MMAP */
end_comment

begin_comment
comment|/* This wrapper is a little different, as it's called indirectly from    __mf_fini also to clean up pending allocations.  */
end_comment

begin_function
name|void
modifier|*
name|__mf_wrap_alloca_indirect
parameter_list|(
name|size_t
name|c
parameter_list|)
block|{
name|DECLARE
argument_list|(
name|void
operator|*
argument_list|,
name|malloc
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|DECLARE
argument_list|(
name|void
argument_list|,
name|free
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
comment|/* This struct, a linked list, tracks alloca'd objects.  The newest      object is at the head of the list.  If we detect that we've      popped a few levels of stack, then the listed objects are freed      as needed.  NB: The tracking struct is allocated with      real_malloc; the user data with wrap_malloc.   */
struct|struct
name|alloca_tracking
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|void
modifier|*
name|stack
decl_stmt|;
name|struct
name|alloca_tracking
modifier|*
name|next
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|alloca_tracking
modifier|*
name|alloca_history
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|stack
init|=
name|__builtin_frame_address
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
name|struct
name|alloca_tracking
modifier|*
name|track
decl_stmt|;
name|TRACE
argument_list|(
literal|"%s\n"
argument_list|,
name|__PRETTY_FUNCTION__
argument_list|)
expr_stmt|;
name|VERBOSE_TRACE
argument_list|(
literal|"alloca stack level %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stack
argument_list|)
expr_stmt|;
comment|/* XXX: thread locking! */
comment|/* Free any previously alloca'd blocks that belong to deeper-nested functions,      which must therefore have exited by now.  */
define|#
directive|define
name|DEEPER_THAN
value|<
comment|/* XXX: for x86; steal find_stack_direction() from libiberty/alloca.c */
while|while
condition|(
name|alloca_history
operator|&&
operator|(
operator|(
name|uintptr_t
operator|)
name|alloca_history
operator|->
name|stack
name|DEEPER_THAN
argument_list|(
argument|uintptr_t
argument_list|)
name|stack
operator|)
condition|)
block|{
name|struct
name|alloca_tracking
modifier|*
name|next
init|=
name|alloca_history
operator|->
name|next
decl_stmt|;
name|__mf_unregister
argument_list|(
name|alloca_history
operator|->
name|ptr
argument_list|,
literal|0
argument_list|,
name|__MF_TYPE_HEAP
argument_list|)
expr_stmt|;
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|alloca_history
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|alloca_history
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|alloca_history
operator|=
name|next
expr_stmt|;
block|}
comment|/* Allocate new block.  */
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|c
operator|>
literal|0
argument_list|)
condition|)
comment|/* alloca(0) causes no allocation.  */
block|{
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|track
operator|=
operator|(
expr|struct
name|alloca_tracking
operator|*
operator|)
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloca_tracking
argument_list|)
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|LIKELY
argument_list|(
name|track
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|result
operator|=
name|CALL_REAL
argument_list|(
name|malloc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|result
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|BEGIN_MALLOC_PROTECT
argument_list|()
expr_stmt|;
name|CALL_REAL
argument_list|(
name|free
argument_list|,
name|track
argument_list|)
expr_stmt|;
name|END_MALLOC_PROTECT
argument_list|()
expr_stmt|;
comment|/* Too bad.  XXX: What about errno?  */
block|}
else|else
block|{
name|__mf_register
argument_list|(
name|result
argument_list|,
name|c
argument_list|,
name|__MF_TYPE_HEAP
argument_list|,
literal|"alloca region"
argument_list|)
expr_stmt|;
name|track
operator|->
name|ptr
operator|=
name|result
expr_stmt|;
name|track
operator|->
name|stack
operator|=
name|stack
expr_stmt|;
name|track
operator|->
name|next
operator|=
name|alloca_history
expr_stmt|;
name|alloca_history
operator|=
name|track
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|alloca
end_undef

begin_macro
name|WRAPPER
argument_list|(
argument|void *
argument_list|,
argument|alloca
argument_list|,
argument|size_t c
argument_list|)
end_macro

begin_block
block|{
return|return
name|__mf_wrap_alloca_indirect
argument_list|(
name|c
argument_list|)
return|;
block|}
end_block

end_unit

