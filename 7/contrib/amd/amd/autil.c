begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2006 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/amd/autil.c  *  */
end_comment

begin_comment
comment|/*  * utilities specified to amd, taken out of the older amd/util.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_decl_stmt
name|int
name|NumChildren
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of children of primary amd */
end_comment

begin_decl_stmt
specifier|static
name|char
name|invalid_keys
index|[]
init|=
literal|"\"'!;@ \t\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************  *** MACROS                                                               ***  ****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
end_ifdef

begin_define
define|#
directive|define
name|PARENT_USLEEP_TIME
value|100000
end_define

begin_comment
comment|/* 0.1 seconds */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TRANSPORT_TYPE_TLI */
end_comment

begin_comment
comment|/****************************************************************************  *** FORWARD DEFINITIONS                                                  ***  ****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|domain_strip
parameter_list|(
name|char
modifier|*
name|otherdom
parameter_list|,
name|char
modifier|*
name|localdom
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dofork
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************  *** FUNCTIONS                                                             ***  ****************************************************************************/
end_comment

begin_comment
comment|/*  * Copy s into p, reallocating p if necessary  */
end_comment

begin_function
name|char
modifier|*
name|strealloc
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
decl_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|voidp
operator|)
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xstrlcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEM
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MALLINFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_MALLOC_VERIFY
argument_list|)
name|malloc_verify
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not defined(HAVE_MALLINFO)&& defined(HAVE_MALLOC_VERIFY) */
endif|#
directive|endif
comment|/* DEBUG_MEM */
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Strip off the trailing part of a domain  * to produce a short-form domain relative  * to the local host domain.  * Note that this has no effect if the domain  * names do not have the same number of  * components.  If that restriction proves  * to be a problem then the loop needs recoding  * to skip from right to left and do partial  * matches along the way -- ie more expensive.  */
end_comment

begin_function
specifier|static
name|void
name|domain_strip
parameter_list|(
name|char
modifier|*
name|otherdom
parameter_list|,
name|char
modifier|*
name|localdom
parameter_list|)
block|{
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|(
name|p1
operator|=
name|strchr
argument_list|(
name|otherdom
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|(
name|p2
operator|=
name|strchr
argument_list|(
name|localdom
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
name|STREQ
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
name|p2
operator|+
literal|1
argument_list|)
condition|)
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Normalize a host name: replace cnames with real names, and decide if to  * strip domain name or not.  */
end_comment

begin_function
name|void
name|host_normalize
parameter_list|(
name|char
modifier|*
modifier|*
name|chp
parameter_list|)
block|{
comment|/*    * Normalize hosts is used to resolve host name aliases    * and replace them with the standard-form name.    * Invoked with "-n" command line option.    */
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_NORMALIZE_HOSTNAMES
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
operator|*
name|chp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|&&
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET
condition|)
block|{
name|dlog
argument_list|(
literal|"Hostname %s normalized to %s"
argument_list|,
operator|*
name|chp
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
operator|*
name|chp
operator|=
name|strealloc
argument_list|(
operator|*
name|chp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_DOMAIN_STRIP
condition|)
block|{
name|domain_strip
argument_list|(
operator|*
name|chp
argument_list|,
name|hostd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Keys are not allowed to contain " ' ! or ; to avoid  * problems with macro expansions.  */
end_comment

begin_function
name|int
name|valid_key
parameter_list|(
name|char
modifier|*
name|key
parameter_list|)
block|{
while|while
condition|(
operator|*
name|key
condition|)
if|if
condition|(
name|strchr
argument_list|(
name|invalid_keys
argument_list|,
operator|*
name|key
operator|++
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|forcibly_timeout_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/*    * Arrange to timeout this node    */
if|if
condition|(
name|mf
operator|&&
operator|(
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
operator|||
operator|(
name|mf
operator|->
name|mf_flags
operator|&
operator|(
name|MFF_MOUNTING
operator||
name|MFF_UNMOUNTING
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"node %s is currently being unmounted, ignoring timeout request"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
else|else
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"ignoring timeout request for active node %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"\"%s\" forcibly timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_flags
operator|&=
operator|~
name|AMF_NOTIMEOUT
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Force mtime update of parent dir, to prevent DNLC/dcache from caching      * the old entry, which could result in ESTALE errors, bad symlinks, and      * more.      */
name|clocktime
argument_list|(
operator|&
name|mp
operator|->
name|am_parent
operator|->
name|am_fattr
operator|.
name|na_mtime
argument_list|)
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mf_mounted
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|,
name|bool_t
name|call_free_opts
parameter_list|)
block|{
name|int
name|quoted
decl_stmt|;
name|int
name|wasmounted
init|=
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
decl_stmt|;
if|if
condition|(
operator|!
name|wasmounted
condition|)
block|{
comment|/*      * If this is a freshly mounted      * filesystem then update the      * mntfs structure...      */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MOUNTED
expr_stmt|;
name|mf
operator|->
name|mf_error
operator|=
literal|0
expr_stmt|;
comment|/*      * Do mounted callback      */
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|->
name|mounted
condition|)
name|mf
operator|->
name|mf_ops
operator|->
name|mounted
argument_list|(
name|mf
argument_list|)
expr_stmt|;
comment|/*      * Be careful when calling free_ops and XFREE here.  Some pseudo file      * systems like nfsx call this function (mf_mounted), even though it      * would be called by the lower-level amd file system functions.  nfsx      * needs to call this function because of the other actions it takes.      * So we pass a boolean from the caller (yes, not so clean workaround)      * to determine if we should free or not.  If we're not freeing (often      * because we're called from a callback function), then just to be sure,      * we'll zero out the am_opts structure and set the pointer to NULL.      * The parent mntfs node owns this memory and is going to free it with a      * call to mf_mounted(mntfs,TRUE) (see comment in the am_mounted code).      */
if|if
condition|(
name|call_free_opts
condition|)
block|{
name|free_opts
argument_list|(
name|mf
operator|->
name|mf_fo
argument_list|)
expr_stmt|;
comment|/* this free is needed to prevent leaks */
name|XFREE
argument_list|(
name|mf
operator|->
name|mf_fo
argument_list|)
expr_stmt|;
comment|/* (also this one) */
block|}
else|else
block|{
name|memset
argument_list|(
name|mf
operator|->
name|mf_fo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_opts
argument_list|)
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_fo
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RESTART
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_RESTART
expr_stmt|;
name|dlog
argument_list|(
literal|"Restarted filesystem %s, flags 0x%x"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|mf
operator|->
name|mf_flags
argument_list|)
expr_stmt|;
block|}
comment|/*    * Log message    */
name|quoted
operator|=
name|strchr
argument_list|(
name|mf
operator|->
name|mf_info
argument_list|,
literal|' '
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"%s%s%s %s fstype %s on %s"
argument_list|,
name|quoted
condition|?
literal|"\""
else|:
literal|""
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|,
name|quoted
condition|?
literal|"\""
else|:
literal|""
argument_list|,
name|wasmounted
condition|?
literal|"referenced"
else|:
literal|"mounted"
argument_list|,
name|mf
operator|->
name|mf_ops
operator|->
name|fs_type
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|am_mounted
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|notimeout
init|=
literal|0
decl_stmt|;
comment|/* assume normal timeouts initially */
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/*    * This is the parent mntfs which does the mf->mf_fo (am_opts type), and    * we're passing TRUE here to tell mf_mounted to actually free the    * am_opts.  See a related comment in mf_mounted().    */
name|mf_mounted
argument_list|(
name|mf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
name|autofs_mounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
comment|/*    * Patch up path for direct mounts    */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_fsflags
operator|&
name|FS_DIRECT
condition|)
name|mp
operator|->
name|am_path
operator|=
name|str3cat
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_path
argument_list|,
literal|"/"
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/*    * Check whether this mount should be cached permanently or not,    * and handle user-requested timeouts.    */
comment|/* first check if file system was set to never timeout */
if|if
condition|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_NOTIMEOUT
condition|)
name|notimeout
operator|=
literal|1
expr_stmt|;
comment|/* next, alter that decision by map flags */
if|if
condition|(
name|mf
operator|->
name|mf_mopts
condition|)
block|{
name|mntent_t
name|mnt
decl_stmt|;
name|mnt
operator|.
name|mnt_opts
operator|=
name|mf
operator|->
name|mf_mopts
expr_stmt|;
comment|/* umount option: user wants to unmount this entry */
if|if
condition|(
name|amu_hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"unmount"
argument_list|)
operator|||
name|amu_hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"umount"
argument_list|)
condition|)
name|notimeout
operator|=
literal|0
expr_stmt|;
comment|/* noumount option: user does NOT want to unmount this entry */
if|if
condition|(
name|amu_hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"nounmount"
argument_list|)
operator|||
name|amu_hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"noumount"
argument_list|)
condition|)
name|notimeout
operator|=
literal|1
expr_stmt|;
comment|/* utimeout=N option: user wants to unmount this option AND set timeout */
if|if
condition|(
operator|(
name|mp
operator|->
name|am_timeo
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"utimeout"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|mp
operator|->
name|am_timeo
operator|=
name|gopt
operator|.
name|am_timeo
expr_stmt|;
comment|/* otherwise use default timeout */
else|else
name|notimeout
operator|=
literal|0
expr_stmt|;
comment|/* special case: don't try to unmount "/" (it can never succeed) */
if|if
condition|(
name|mf
operator|->
name|mf_mount
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|mf
operator|->
name|mf_mount
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|notimeout
operator|=
literal|1
expr_stmt|;
block|}
comment|/* finally set actual flags */
if|if
condition|(
name|notimeout
condition|)
block|{
name|mp
operator|->
name|am_flags
operator||=
name|AMF_NOTIMEOUT
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"%s set to never timeout"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|am_flags
operator|&=
operator|~
name|AMF_NOTIMEOUT
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"%s set to timeout in %d seconds"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_timeo
argument_list|)
expr_stmt|;
block|}
comment|/*    * If this node is a symlink then    * compute the length of the returned string.    */
if|if
condition|(
name|mp
operator|->
name|am_fattr
operator|.
name|na_type
operator|==
name|NFLNK
condition|)
name|mp
operator|->
name|am_fattr
operator|.
name|na_size
operator|=
name|strlen
argument_list|(
name|mp
operator|->
name|am_link
condition|?
name|mp
operator|->
name|am_link
else|:
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
comment|/*    * Record mount time, and update am_stats at the same time.    */
name|mp
operator|->
name|am_stats
operator|.
name|s_mtime
operator|=
name|clocktime
argument_list|(
operator|&
name|mp
operator|->
name|am_fattr
operator|.
name|na_mtime
argument_list|)
expr_stmt|;
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/*    * Update mtime of parent node (copying "struct nfstime" in '=' below)    */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
condition|)
name|mp
operator|->
name|am_parent
operator|->
name|am_fattr
operator|.
name|na_mtime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|na_mtime
expr_stmt|;
comment|/*    * This is ugly, but essentially unavoidable    * Sublinks must be treated separately as type==link    * when the base type is different.    */
if|if
condition|(
name|mp
operator|->
name|am_link
operator|&&
name|mf
operator|->
name|mf_ops
operator|!=
operator|&
name|amfs_link_ops
condition|)
name|amfs_link_ops
operator|.
name|mount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
comment|/*    * Now, if we can, do a reply to our client here    * to speed things up.    */
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
name|autofs_mount_succeeded
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|nfs_quick_reply
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Update stats    */
name|amd_stats
operator|.
name|d_mok
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replace mount point with a reference to an error filesystem.  * The mount point (struct mntfs) is NOT discarded,  * the caller must do it if it wants to _before_ calling this function.  */
end_comment

begin_function
name|void
name|assign_error_mntfs
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dlog
argument_list|(
literal|"assign_error_mntfs"
argument_list|)
expr_stmt|;
comment|/*    * Save the old error code    */
name|error
operator|=
name|mp
operator|->
name|am_error
expr_stmt|;
if|if
condition|(
name|error
operator|<=
literal|0
condition|)
name|error
operator|=
name|mp
operator|->
name|am_mnt
operator|->
name|mf_error
expr_stmt|;
comment|/*    * Allocate a new error reference    */
name|mp
operator|->
name|am_mnt
operator|=
name|new_mntfs
argument_list|()
expr_stmt|;
comment|/*    * Put back the error code    */
name|mp
operator|->
name|am_mnt
operator|->
name|mf_error
operator|=
name|error
expr_stmt|;
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
comment|/*    * Zero the error in the mount point    */
name|mp
operator|->
name|am_error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build a new map cache for this node, or re-use  * an existing cache for the same map.  */
end_comment

begin_function
name|void
name|amfs_mkcacheref
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|char
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|opt_cache
condition|)
name|cache
operator|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_cache
expr_stmt|;
else|else
name|cache
operator|=
literal|"none"
expr_stmt|;
name|mf
operator|->
name|mf_private
operator|=
operator|(
name|opaque_t
operator|)
name|mapc_find
argument_list|(
name|mf
operator|->
name|mf_info
argument_list|,
name|cache
argument_list|,
operator|(
name|mf
operator|->
name|mf_fo
condition|?
name|mf
operator|->
name|mf_fo
operator|->
name|opt_maptype
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_prfree
operator|=
name|mapc_free
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Locate next node in sibling list which is mounted  * and is not an error node.  */
end_comment

begin_function
name|am_node
modifier|*
name|next_nonerror_node
parameter_list|(
name|am_node
modifier|*
name|xp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
decl_stmt|;
comment|/*    * Bug report (7/12/89) from Rein Tollevik<rein@ifi.uio.no>    * Fixes a race condition when mounting direct automounts.    * Also fixes a problem when doing a readdir on a directory    * containing hung automounts.    */
while|while
condition|(
name|xp
operator|&&
operator|(
operator|!
operator|(
name|mf
operator|=
name|xp
operator|->
name|am_mnt
operator|)
operator|||
comment|/* No mounted filesystem */
name|mf
operator|->
name|mf_error
operator|!=
literal|0
operator|||
comment|/* There was a mntfs error */
name|xp
operator|->
name|am_error
operator|!=
literal|0
operator|||
comment|/* There was a mount error */
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|||
comment|/* The fs is not mounted */
operator|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|)
comment|/* The fs may be down */
condition|)
name|xp
operator|=
name|xp
operator|->
name|am_osib
expr_stmt|;
return|return
name|xp
return|;
block|}
end_function

begin_comment
comment|/*  * Mount an automounter directory.  * The automounter is connected into the system  * as a user-level NFS server.  amfs_mount constructs  * the necessary NFS parameters to be given to the  * kernel so that it will talk back to us.  *  * NOTE: automounter mounts in themselves are using NFS Version 2 (UDP).  *  * NEW: on certain systems, mounting can be done using the  * kernel-level automount (autofs) support. In that case,  * we don't need NFS at all here.  */
end_comment

begin_function
name|int
name|amfs_mount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|char
name|fs_hostname
index|[
name|MAXHOSTNAMELEN
operator|+
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|retry
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|genflags
decl_stmt|;
name|int
name|on_autofs
init|=
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|mf
operator|->
name|mf_mount
decl_stmt|;
name|mntent_t
name|mnt
decl_stmt|;
name|MTYPE_TYPE
name|type
decl_stmt|;
name|int
name|forced_unmount
init|=
literal|0
decl_stmt|;
comment|/* are we using forced unmounts? */
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|mnt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mnt
argument_list|)
argument_list|)
expr_stmt|;
name|mnt
operator|.
name|mnt_dir
operator|=
name|dir
expr_stmt|;
name|mnt
operator|.
name|mnt_fsname
operator|=
name|pid_fsname
expr_stmt|;
name|mnt
operator|.
name|mnt_opts
operator|=
name|opts
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
block|{
name|type
operator|=
name|MOUNT_TYPE_AUTOFS
expr_stmt|;
comment|/*      * Make sure that amd's top-level autofs mounts are hidden by default      * from df.      * XXX: It works ok on Linux, might not work on other systems.      */
name|mnt
operator|.
name|mnt_type
operator|=
literal|"autofs"
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
block|{
name|type
operator|=
name|MOUNT_TYPE_NFS
expr_stmt|;
comment|/*      * Make sure that amd's top-level NFS mounts are hidden by default      * from df.      * If they don't appear to support the either the "ignore" mnttab      * option entry, or the "auto" one, set the mount type to "nfs".      */
name|mnt
operator|.
name|mnt_type
operator|=
name|HIDE_MOUNT_TYPE
expr_stmt|;
block|}
name|retry
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|<=
literal|0
condition|)
name|retry
operator|=
literal|2
expr_stmt|;
comment|/* XXX: default to 2 retries */
comment|/*    * SET MOUNT ARGS    */
comment|/*    * Make a ``hostname'' string for the kernel    */
name|xsnprintf
argument_list|(
name|fs_hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_hostname
argument_list|)
argument_list|,
literal|"pid%ld@%s:%s"
argument_list|,
name|get_server_pid
argument_list|()
argument_list|,
name|am_get_hostname
argument_list|()
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/*    * Most kernels have a name length restriction (64 bytes)...    */
if|if
condition|(
name|strlen
argument_list|(
name|fs_hostname
argument_list|)
operator|>=
name|MAXHOSTNAMELEN
condition|)
name|xstrlcpy
argument_list|(
name|fs_hostname
operator|+
name|MAXHOSTNAMELEN
operator|-
literal|3
argument_list|,
literal|".."
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_hostname
argument_list|)
operator|-
name|MAXHOSTNAMELEN
operator|+
literal|3
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOSTNAMESZ
comment|/*    * ... and some of these restrictions are 32 bytes (HOSTNAMESZ)    * If you need to get the definition for HOSTNAMESZ found, you may    * add the proper header file to the conf/nfs_prot/nfs_prot_*.h file.    */
if|if
condition|(
name|strlen
argument_list|(
name|fs_hostname
argument_list|)
operator|>=
name|HOSTNAMESZ
condition|)
name|xstrlcpy
argument_list|(
name|fs_hostname
operator|+
name|HOSTNAMESZ
operator|-
literal|3
argument_list|,
literal|".."
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_hostname
argument_list|)
operator|-
name|HOSTNAMESZ
operator|+
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HOSTNAMESZ */
comment|/*    * Finally we can compute the mount genflags set above,    * and add any automounter specific flags.    */
name|genflags
operator|=
name|compute_mount_flags
argument_list|(
operator|&
name|mnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|on_autofs
condition|)
name|genflags
operator||=
name|autofs_compute_mount_flags
argument_list|(
operator|&
name|mnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|genflags
operator||=
name|compute_automounter_mount_flags
argument_list|(
operator|&
name|mnt
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
operator|)
condition|)
block|{
name|nfs_args_t
name|nfs_args
decl_stmt|;
name|am_nfs_fh
modifier|*
name|fhp
decl_stmt|;
name|am_nfs_handle_t
name|anh
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_TRANSPORT_TYPE_TLI
name|u_short
name|port
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*      * get fhandle of remote path for automount point      */
name|fhp
operator|=
name|get_root_nfs_fh
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fhp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Can't find root file handle for %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
ifndef|#
directive|ifndef
name|HAVE_TRANSPORT_TYPE_TLI
comment|/*      * Create sockaddr to point to the local machine.      */
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as per POSIX, sin_len need not be set (used internally by kernel) */
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|myipaddr
expr_stmt|;
name|port
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"no port number specified for %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/* setup the many fields and flags within nfs_args */
name|memmove
argument_list|(
operator|&
name|anh
operator|.
name|v2
argument_list|,
name|fhp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fhp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|compute_nfs_args
argument_list|(
operator|&
name|nfs_args
argument_list|,
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
name|nfsncp
argument_list|,
name|NULL
argument_list|,
comment|/* remote host IP addr is set below */
name|NFS_VERSION
argument_list|,
comment|/* version 2 */
literal|"udp"
argument_list|,
operator|&
name|anh
argument_list|,
name|fs_hostname
argument_list|,
name|pid_fsname
argument_list|)
expr_stmt|;
comment|/*      * IMPORTANT: set the correct IP address AFTERWARDS.  It cannot      * be done using the normal mechanism of compute_nfs_args(), because      * that one will allocate a new address and use NFS_SA_DREF() to copy      * parts to it, while assuming that the ip_addr passed is always      * a "struct sockaddr_in".  That assumption is incorrect on TLI systems,      * because they define a special macro HOST_SELF which is DIFFERENT      * than localhost (127.0.0.1)!      */
name|nfs_args
operator|.
name|addr
operator|=
operator|&
name|nfsxprt
operator|->
name|xp_ltaddr
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|compute_nfs_args
argument_list|(
operator|&
name|nfs_args
argument_list|,
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
name|NULL
argument_list|,
operator|&
name|sin
argument_list|,
name|NFS_VERSION
argument_list|,
comment|/* version 2 */
literal|"udp"
argument_list|,
operator|&
name|anh
argument_list|,
name|fs_hostname
argument_list|,
name|pid_fsname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*************************************************************************      * NOTE: while compute_nfs_args() works ok for regular NFS mounts	     *      * the toplvl one is not quite regular, and so some options must be      *      * corrected by hand more carefully, *after* compute_nfs_args() runs.    *      *************************************************************************/
name|compute_automounter_nfs_args
argument_list|(
operator|&
name|nfs_args
argument_list|,
operator|&
name|mnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|amuDebug
argument_list|(
name|D_TRACE
argument_list|)
condition|)
block|{
name|print_nfs_args
argument_list|(
operator|&
name|nfs_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"Generic mount flags 0x%x"
argument_list|,
name|genflags
argument_list|)
expr_stmt|;
block|}
comment|/* This is it!  Here we try to mount amd on its mount points */
name|error
operator|=
name|mount_fs
argument_list|(
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_args
argument_list|,
name|retry
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mnttab_file_name
argument_list|,
name|on_autofs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|free_knetconfig
argument_list|(
name|nfs_args
operator|.
name|knconf
argument_list|)
expr_stmt|;
comment|/*      * local automounter mounts do not allocate a special address, so      * no need to XFREE(nfs_args.addr) under TLI.      */
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
block|}
else|else
block|{
comment|/* This is it!  Here we try to mount amd on its mount points */
name|error
operator|=
name|mount_fs
argument_list|(
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|am_autofs_fh
argument_list|,
name|retry
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mnttab_file_name
argument_list|,
name|on_autofs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|||
name|forced_unmount
condition|)
return|return
name|error
return|;
comment|/*    * If user wants forced/lazy unmount semantics, then try it iff the    * current mount failed with EIO or ESTALE.    */
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_FORCED_UNMOUNTS
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ESTALE
case|:
case|case
name|EIO
case|:
name|forced_unmount
operator|=
name|errno
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"Mount %s failed (%m); force unmount."
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|UMOUNT_FS
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|mnttab_file_name
argument_list|,
name|AMU_UMOUNT_FORCE
operator||
name|AMU_UMOUNT_DETACH
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"Forced umount %s failed: %m."
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|errno
operator|=
name|forced_unmount
expr_stmt|;
block|}
else|else
goto|goto
name|again
goto|;
default|default:
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|am_unmounted
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
if|if
condition|(
operator|!
name|foreground
condition|)
comment|/* firewall - should never happen */
return|return;
comment|/*    * Do unmounted callback    */
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|->
name|umounted
condition|)
name|mf
operator|->
name|mf_ops
operator|->
name|umounted
argument_list|(
name|mf
argument_list|)
expr_stmt|;
comment|/*    * This is ugly, but essentially unavoidable.    * Sublinks must be treated separately as type==link    * when the base type is different.    */
if|if
condition|(
name|mp
operator|->
name|am_link
operator|&&
name|mf
operator|->
name|mf_ops
operator|!=
operator|&
name|amfs_link_ops
condition|)
name|amfs_link_ops
operator|.
name|umount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
name|autofs_release_fh
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
name|autofs_umount_succeeded
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
comment|/*    * Clean up any directories that were made    *    * If we remove the mount point of a pending mount, any queued access    * to it will fail. So don't do it in that case.    * Also don't do it if the refcount is> 1.    */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MKMNT
operator|&&
name|mf
operator|->
name|mf_refc
operator|==
literal|1
operator|&&
operator|!
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_REMOUNT
operator|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"removing mountpoint directory '%s'"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|rmdirs
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MKMNT
expr_stmt|;
block|}
comment|/*    * If this is a pseudo-directory then adjust the link count    * in the parent    */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_fattr
operator|.
name|na_type
operator|==
name|NFDIR
condition|)
operator|--
name|mp
operator|->
name|am_parent
operator|->
name|am_fattr
operator|.
name|na_nlink
expr_stmt|;
comment|/*    * Update mtime of parent node    */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
condition|)
name|clocktime
argument_list|(
operator|&
name|mp
operator|->
name|am_parent
operator|->
name|am_fattr
operator|.
name|na_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_REMOUNT
operator|)
condition|)
block|{
name|char
modifier|*
name|fname
init|=
name|strdup
argument_list|(
name|mp
operator|->
name|am_name
argument_list|)
decl_stmt|;
name|am_node
modifier|*
name|mp_parent
init|=
name|mp
operator|->
name|am_parent
decl_stmt|;
name|mntfs
modifier|*
name|mf_parent
init|=
name|mp_parent
operator|->
name|am_mnt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|free_map
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"am_unmounted: remounting %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|mp
operator|=
name|mf_parent
operator|->
name|mf_ops
operator|->
name|lookup_child
argument_list|(
name|mp_parent
argument_list|,
name|fname
argument_list|,
operator|&
name|error
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|&&
name|error
operator|<
literal|0
condition|)
name|mp
operator|=
name|mf_parent
operator|->
name|mf_ops
operator|->
name|mount_child
argument_list|(
name|mp
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"am_unmounted: could not remount %s: %m"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/*      * We have a race here.      * If this node has a pending mount and amd is going down (unmounting      * everything in the process), then we could potentially free it here      * while a struct continuation still has a reference to it. So when      * amfs_cont is called, it blows up.      * We avoid the race by refusing to free any nodes that have      * pending mounts (defined as having a non-NULL am_mfarray).      */
if|if
condition|(
operator|!
name|mp
operator|->
name|am_mfarray
condition|)
name|free_map
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fork the automounter  *  * TODO: Need a better strategy for handling errors  */
end_comment

begin_function
specifier|static
name|int
name|dofork
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|top
label|:
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
comment|/* fork error, retry in 1 second */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child process (foreground==false) */
name|am_set_mypid
argument_list|()
expr_stmt|;
name|foreground
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* parent process, has one more child */
name|NumChildren
operator|++
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_function
name|int
name|background
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pid
init|=
name|dofork
argument_list|()
decl_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"backgrounded"
argument_list|)
expr_stmt|;
name|foreground
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|dlog
argument_list|(
literal|"forked process %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

end_unit

