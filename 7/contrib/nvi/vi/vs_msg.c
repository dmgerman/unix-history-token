begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)vs_msg.c	10.77 (Berkeley) 10/13/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|SCROLL_W
block|,
comment|/* User wait. */
name|SCROLL_W_EX
block|,
comment|/* User wait, or enter : to continue. */
name|SCROLL_W_QUIT
comment|/* User wait, or enter q to quit. */
comment|/* 					 * SCROLL_W_QUIT has another semantic 					 * -- only wait if the screen is full 					 */
block|}
name|sw_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|vs_divider
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vs_msgsave
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|mtype_t
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vs_output
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|mtype_t
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vs_scroll
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|*
operator|,
name|sw_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vs_wait
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|*
operator|,
name|sw_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * vs_busy --  *	Display, update or clear a busy message.  *  * This routine is the default editor interface for vi busy messages.  It  * implements a standard strategy of stealing lines from the bottom of the  * vi text screen.  Screens using an alternate method of displaying busy  * messages, e.g. X11 clock icons, should set their scr_busy function to the  * correct function before calling the main editor routine.  *  * PUBLIC: void vs_busy __P((SCR *, const char *, busy_t));  */
end_comment

begin_function
name|void
name|vs_busy
parameter_list|(
name|sp
parameter_list|,
name|msg
parameter_list|,
name|btype
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|busy_t
name|btype
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
specifier|static
specifier|const
name|char
name|flagc
index|[]
init|=
literal|"|/-\\"
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|notused
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Ex doesn't display busy messages. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EXWROTE
argument_list|)
condition|)
return|return;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Most of this routine is to deal with the screen sharing real estate 	 * between the normal edit messages and the busy messages.  Logically, 	 * all that's needed is something that puts up a message, periodically 	 * updates it, and then goes away. 	 */
switch|switch
condition|(
name|btype
condition|)
block|{
case|case
name|BUSY_ON
case|:
operator|++
name|vip
operator|->
name|busy_ref
expr_stmt|;
if|if
condition|(
name|vip
operator|->
name|totalcount
operator|!=
literal|0
operator|||
name|vip
operator|->
name|busy_ref
operator|!=
literal|1
condition|)
break|break;
comment|/* Initialize state for updates. */
name|vip
operator|->
name|busy_ch
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|vip
operator|->
name|busy_tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Save the current cursor. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|vip
operator|->
name|busy_oldy
argument_list|,
operator|&
name|vip
operator|->
name|busy_oldx
argument_list|)
expr_stmt|;
comment|/* Display the busy message. */
name|p
operator|=
name|msg_cat
argument_list|(
name|sp
argument_list|,
name|msg
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|notused
argument_list|,
operator|&
name|vip
operator|->
name|busy_fx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vip
operator|->
name|busy_fx
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUSY_OFF
case|:
if|if
condition|(
name|vip
operator|->
name|busy_ref
operator|==
literal|0
condition|)
break|break;
operator|--
name|vip
operator|->
name|busy_ref
expr_stmt|;
comment|/* 		 * If the line isn't in use for another purpose, clear it. 		 * Always return to the original position. 		 */
if|if
condition|(
name|vip
operator|->
name|totalcount
operator|==
literal|0
operator|&&
name|vip
operator|->
name|busy_ref
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|vip
operator|->
name|busy_oldy
argument_list|,
name|vip
operator|->
name|busy_oldx
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUSY_UPDATE
case|:
if|if
condition|(
name|vip
operator|->
name|totalcount
operator|!=
literal|0
operator|||
name|vip
operator|->
name|busy_ref
operator|==
literal|0
condition|)
break|break;
comment|/* Update no more than every 1/8 of a second. */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|vip
operator|->
name|busy_tv
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
operator|(
name|tv
operator|.
name|tv_usec
operator|-
name|vip
operator|->
name|busy_tv
operator|.
name|tv_usec
operator|)
operator|)
operator|<
literal|125000
condition|)
return|return;
name|vip
operator|->
name|busy_tv
operator|=
name|tv
expr_stmt|;
comment|/* Display the update. */
if|if
condition|(
name|vip
operator|->
name|busy_ch
operator|==
sizeof|sizeof
argument_list|(
name|flagc
argument_list|)
operator|-
literal|1
condition|)
name|vip
operator|->
name|busy_ch
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vip
operator|->
name|busy_fx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|flagc
operator|+
name|vip
operator|->
name|busy_ch
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vip
operator|->
name|busy_fx
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * vs_home --  *	Home the cursor to the bottom row, left-most column.  *  * PUBLIC: void vs_home __P((SCR *));  */
end_comment

begin_function
name|void
name|vs_home
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vs_update --  *	Update a command.  *  * PUBLIC: void vs_update __P((SCR *, const char *, const char *));  */
end_comment

begin_function
name|void
name|vs_update
parameter_list|(
name|sp
parameter_list|,
name|m1
parameter_list|,
name|m2
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|mlen
decl_stmt|,
name|oldx
decl_stmt|,
name|oldy
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
comment|/* 	 * This routine displays a message on the bottom line of the screen, 	 * without updating any of the command structures that would keep it 	 * there for any period of time, i.e. it is overwritten immediately. 	 * 	 * It's used by the ex read and ! commands when the user's command is 	 * expanded, and by the ex substitution confirmation prompt. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ex_printf
argument_list|(
name|sp
argument_list|,
literal|"%s\n"
argument_list|,
name|m1
operator|==
name|NULL
condition|?
literal|""
else|:
name|m1
argument_list|,
name|m2
operator|==
name|NULL
condition|?
literal|""
else|:
name|m2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_fflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save the cursor position, the substitute-with-confirmation code 	 * will have already set it correctly. 	 */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|oldy
argument_list|,
operator|&
name|oldx
argument_list|)
expr_stmt|;
comment|/* Clear the bottom line. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * Don't let long file names screw up the screen. 	 */
if|if
condition|(
name|m1
operator|!=
name|NULL
condition|)
block|{
name|mlen
operator|=
name|len
operator|=
name|strlen
argument_list|(
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|sp
operator|->
name|cols
operator|-
literal|2
condition|)
name|mlen
operator|=
name|len
operator|=
name|sp
operator|->
name|cols
operator|-
literal|2
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|m1
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
block|}
else|else
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m2
operator|!=
name|NULL
condition|)
block|{
name|mlen
operator|=
name|strlen
argument_list|(
name|m2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|mlen
operator|>
name|sp
operator|->
name|cols
operator|-
literal|2
condition|)
name|mlen
operator|=
operator|(
name|sp
operator|->
name|cols
operator|-
literal|2
operator|)
operator|-
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|m2
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * vs_msg --  *	Display ex output or error messages for the screen.  *  * This routine is the default editor interface for all ex output, and all ex  * and vi error/informational messages.  It implements the standard strategy  * of stealing lines from the bottom of the vi text screen.  Screens using an  * alternate method of displaying messages, e.g. dialog boxes, should set their  * scr_msg function to the correct function before calling the editor.  *  * PUBLIC: void vs_msg __P((SCR *, mtype_t, char *, size_t));  */
end_comment

begin_function
name|void
name|vs_msg
parameter_list|(
name|sp
parameter_list|,
name|mtype
parameter_list|,
name|line
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|mtype_t
name|mtype
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|size_t
name|maxcols
decl_stmt|,
name|oldx
decl_stmt|,
name|oldy
decl_stmt|,
name|padding
decl_stmt|;
specifier|const
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Ring the bell if it's scheduled. 	 * 	 * XXX 	 * Shouldn't we save this, too? 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_BELLSCHED
argument_list|)
condition|)
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|gp
argument_list|,
name|G_BELLSCHED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
name|F_SET
argument_list|(
name|gp
argument_list|,
name|G_BELLSCHED
argument_list|)
expr_stmt|;
comment|/* 	 * If vi is using the error line for text input, there's no screen 	 * real-estate for the error message.  Nothing to do without some 	 * information as to how important the error message is. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_TINPUT_INFO
argument_list|)
condition|)
return|return;
comment|/* 	 * Ex or ex controlled screen output. 	 * 	 * If output happens during startup, e.g., a .exrc file, we may be 	 * in ex mode but haven't initialized the screen.  Initialize here, 	 * and in this case, stay in ex mode. 	 * 	 * If the SC_SCR_EXWROTE bit is set, then we're switching back and 	 * forth between ex and vi, but the screen is trashed and we have 	 * to respect that.  Switch to ex mode long enough to put out the 	 * message. 	 * 	 * If the SC_EX_WAIT_NO bit is set, turn it off -- we're writing to 	 * the screen, so previous opinions are ignored. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
operator||
name|SC_SCR_EXWROTE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EX
argument_list|)
condition|)
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|gp
operator|->
name|scr_screen
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|ex_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return;
if|if
condition|(
name|mtype
operator|==
name|M_ERR
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_INVERSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|M_ERR
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_INVERSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_EX_WAIT_NO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EX
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sp
operator|->
name|gp
operator|->
name|scr_screen
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the vi screen isn't ready, save the message. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|vs_msgsave
argument_list|(
name|sp
argument_list|,
name|mtype
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Save the cursor position. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|oldy
argument_list|,
operator|&
name|oldx
argument_list|)
expr_stmt|;
comment|/* If it's an ex output message, just write it out. */
if|if
condition|(
name|mtype
operator|==
name|M_NONE
condition|)
block|{
name|vs_output
argument_list|(
name|sp
argument_list|,
name|mtype
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* 	 * If it's a vi message, strip the trailing<newline> so we can 	 * try and paste messages together. 	 */
if|if
condition|(
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|--
name|len
expr_stmt|;
comment|/* 	 * If a message won't fit on a single line, try to split on a<blank>. 	 * If a subsequent message fits on the same line, write a separator 	 * and output it.  Otherwise, put out a newline. 	 * 	 * Need up to two padding characters normally; a semi-colon and a 	 * separating space.  If only a single line on the screen, add some 	 * more for the trailing continuation message. 	 * 	 * XXX 	 * Assume that periods and semi-colons take up a single column on the 	 * screen. 	 * 	 * XXX 	 * There are almost certainly pathological cases that will break this 	 * code. 	 */
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|msg_cmsg
argument_list|(
name|sp
argument_list|,
name|CMSG_CONT_S
argument_list|,
operator|&
name|padding
argument_list|)
expr_stmt|;
else|else
name|padding
operator|=
literal|0
expr_stmt|;
name|padding
operator|+=
literal|2
expr_stmt|;
name|maxcols
operator|=
name|sp
operator|->
name|cols
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vip
operator|->
name|lcontinue
operator|!=
literal|0
condition|)
if|if
condition|(
name|len
operator|+
name|vip
operator|->
name|lcontinue
operator|+
name|padding
operator|>
name|maxcols
condition|)
name|vs_output
argument_list|(
name|sp
argument_list|,
name|vip
operator|->
name|mtype
argument_list|,
literal|".\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|vs_output
argument_list|(
name|sp
argument_list|,
name|vip
operator|->
name|mtype
argument_list|,
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vs_output
argument_list|(
name|sp
argument_list|,
name|M_NONE
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vip
operator|->
name|mtype
operator|=
name|mtype
expr_stmt|;
for|for
control|(
name|s
operator|=
name|line
init|;
condition|;
name|s
operator|=
name|t
control|)
block|{
for|for
control|(
init|;
name|len
operator|>
literal|0
operator|&&
name|isblank
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|--
name|len
operator|,
operator|++
name|s
control|)
empty_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|+
name|vip
operator|->
name|lcontinue
operator|>
name|maxcols
condition|)
block|{
for|for
control|(
name|e
operator|=
name|s
operator|+
operator|(
name|maxcols
operator|-
name|vip
operator|->
name|lcontinue
operator|)
init|;
name|e
operator|>
name|s
operator|&&
operator|!
name|isblank
argument_list|(
operator|*
name|e
argument_list|)
condition|;
operator|--
name|e
control|)
empty_stmt|;
if|if
condition|(
name|e
operator|==
name|s
condition|)
name|e
operator|=
name|t
operator|=
name|s
operator|+
operator|(
name|maxcols
operator|-
name|vip
operator|->
name|lcontinue
operator|)
expr_stmt|;
else|else
for|for
control|(
name|t
operator|=
name|e
init|;
name|isblank
argument_list|(
name|e
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
operator|--
name|e
control|)
empty_stmt|;
block|}
else|else
name|e
operator|=
name|t
operator|=
name|s
operator|+
name|len
expr_stmt|;
comment|/* 		 * If the message ends in a period, discard it, we want to 		 * gang messages where possible. 		 */
name|len
operator|-=
name|t
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|(
name|e
operator|-
name|s
operator|)
operator|>
literal|1
operator|&&
name|s
index|[
operator|(
name|e
operator|-
name|s
operator|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
operator|--
name|e
expr_stmt|;
name|vs_output
argument_list|(
name|sp
argument_list|,
name|mtype
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|vs_output
argument_list|(
name|sp
argument_list|,
name|M_NONE
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
break|break;
block|}
name|ret
label|:
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vs_output --  *	Output the text to the screen.  */
end_comment

begin_function
specifier|static
name|void
name|vs_output
parameter_list|(
name|sp
parameter_list|,
name|mtype
parameter_list|,
name|line
parameter_list|,
name|llen
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|mtype_t
name|mtype
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|llen
decl_stmt|;
block|{
name|CHAR_T
modifier|*
name|kp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|size_t
name|chlen
decl_stmt|,
name|notused
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|len
decl_stmt|,
name|rlen
decl_stmt|,
name|tlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ecbp
decl_stmt|,
name|cbuf
index|[
literal|128
index|]
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|line
operator|,
name|rlen
operator|=
name|llen
init|;
name|llen
operator|>
literal|0
condition|;
control|)
block|{
comment|/* Get the next physical line. */
if|if
condition|(
operator|(
name|p
operator|=
name|memchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|,
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|len
operator|=
name|llen
expr_stmt|;
else|else
name|len
operator|=
name|p
operator|-
name|line
expr_stmt|;
comment|/* 		 * The max is sp->cols characters, and we may have already 		 * written part of the line. 		 */
if|if
condition|(
name|len
operator|+
name|vip
operator|->
name|lcontinue
operator|>
name|sp
operator|->
name|cols
condition|)
name|len
operator|=
name|sp
operator|->
name|cols
operator|-
name|vip
operator|->
name|lcontinue
expr_stmt|;
comment|/* 		 * If the first line output, do nothing.  If the second line 		 * output, draw the divider line.  If drew a full screen, we 		 * remove the divider line.  If it's a continuation line, move 		 * to the continuation point, else, move the screen up. 		 */
if|if
condition|(
name|vip
operator|->
name|lcontinue
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|vip
operator|->
name|totalcount
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vs_divider
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_DIVIDER
argument_list|)
expr_stmt|;
operator|++
name|vip
operator|->
name|totalcount
expr_stmt|;
operator|++
name|vip
operator|->
name|linecount
expr_stmt|;
block|}
if|if
condition|(
name|vip
operator|->
name|totalcount
operator|==
name|sp
operator|->
name|t_maxrows
operator|&&
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_DIVIDER
argument_list|)
condition|)
block|{
operator|--
name|vip
operator|->
name|totalcount
expr_stmt|;
operator|--
name|vip
operator|->
name|linecount
expr_stmt|;
name|F_CLR
argument_list|(
name|vip
argument_list|,
name|VIP_DIVIDER
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vip
operator|->
name|totalcount
operator|!=
literal|0
condition|)
name|vs_scroll
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|SCROLL_W_QUIT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|vip
operator|->
name|totalcount
expr_stmt|;
operator|++
name|vip
operator|->
name|linecount
expr_stmt|;
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
break|break;
block|}
else|else
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vip
operator|->
name|lcontinue
argument_list|)
expr_stmt|;
comment|/* Error messages are in inverse video. */
if|if
condition|(
name|mtype
operator|==
name|M_ERR
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_INVERSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Display the line, doing character translation. */
define|#
directive|define
name|FLUSH
value|{								\ 	*cbp = '\0';							\ 	(void)gp->scr_addstr(sp, cbuf, cbp - cbuf);			\ 	cbp = cbuf;							\ }
name|ecbp
operator|=
operator|(
name|cbp
operator|=
name|cbuf
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
name|line
operator|,
name|tlen
operator|=
name|len
init|;
name|tlen
operator|--
condition|;
operator|++
name|t
control|)
block|{
name|ch
operator|=
operator|*
name|t
expr_stmt|;
comment|/* 			 * Replace tabs with spaces, there are places in 			 * ex that do column calculations without looking 			 * at<tabs> -- and all routines that care about 			 *<tabs> do their own expansions.  This catches 			 *<tabs> in things like tag search strings. 			 */
if|if
condition|(
name|ch
operator|==
literal|'\t'
condition|)
name|ch
operator|=
literal|' '
expr_stmt|;
name|chlen
operator|=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|+
name|chlen
operator|>=
name|ecbp
condition|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|kp
operator|=
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
init|;
name|chlen
operator|--
condition|;
control|)
operator|*
name|cbp
operator|++
operator|=
operator|*
name|kp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|>
name|cbuf
condition|)
name|FLUSH
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|M_ERR
condition|)
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_INVERSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear the rest of the line. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* If we loop, it's a new line. */
name|vip
operator|->
name|lcontinue
operator|=
literal|0
expr_stmt|;
comment|/* Reset for the next line. */
name|line
operator|+=
name|len
expr_stmt|;
name|llen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|++
name|line
expr_stmt|;
operator|--
name|llen
expr_stmt|;
block|}
block|}
comment|/* Set up next continuation line. */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|notused
argument_list|,
operator|&
name|vip
operator|->
name|lcontinue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vs_ex_resolve --  *	Deal with ex message output.  *  * This routine is called when exiting a colon command to resolve any ex  * output that may have occurred.  *  * PUBLIC: int vs_ex_resolve __P((SCR *, int *));  */
end_comment

begin_function
name|int
name|vs_ex_resolve
parameter_list|(
name|sp
parameter_list|,
name|continuep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
modifier|*
name|continuep
decl_stmt|;
block|{
name|EVENT
name|ev
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|sw_t
name|wtype
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|*
name|continuep
operator|=
literal|0
expr_stmt|;
comment|/* If we ran any ex command, we can't trust the cursor position. */
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* Terminate any partially written message. */
if|if
condition|(
name|vip
operator|->
name|lcontinue
operator|!=
literal|0
condition|)
block|{
name|vs_output
argument_list|(
name|sp
argument_list|,
name|vip
operator|->
name|mtype
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vip
operator|->
name|lcontinue
operator|=
literal|0
expr_stmt|;
name|vip
operator|->
name|mtype
operator|=
name|M_NONE
expr_stmt|;
block|}
comment|/* 	 * If we switched out of the vi screen into ex, switch back while we 	 * figure out what to do with the screen and potentially get another 	 * command to execute. 	 * 	 * If we didn't switch into ex, we're not required to wait, and less 	 * than 2 lines of output, we can continue without waiting for the 	 * wait. 	 * 	 * Note, all other code paths require waiting, so we leave the report 	 * of modified lines until later, so that we won't wait for no other 	 * reason than a threshold number of lines were modified.  This means 	 * we display cumulative line modification reports for groups of ex 	 * commands.  That seems right to me (well, at least not wrong). 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|gp
operator|->
name|scr_screen
argument_list|(
name|sp
argument_list|,
name|SC_VI
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_WAIT_YES
argument_list|)
operator|&&
name|vip
operator|->
name|totalcount
operator|<
literal|2
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_EX_WAIT_NO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Clear the required wait flag, it's no longer needed. */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_EX_WAIT_YES
argument_list|)
expr_stmt|;
comment|/* 	 * Wait, unless explicitly told not to wait or the user interrupted 	 * the command.  If the user is leaving the screen, for any reason, 	 * they can't continue with further ex commands. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX_WAIT_NO
argument_list|)
operator|&&
operator|!
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|wtype
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EXIT
operator||
name|SC_EXIT_FORCE
operator||
name|SC_FSWITCH
operator||
name|SC_SSWITCH
argument_list|)
condition|?
name|SCROLL_W
else|:
name|SCROLL_W_EX
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
condition|)
name|vs_wait
argument_list|(
name|sp
argument_list|,
name|continuep
argument_list|,
name|wtype
argument_list|)
expr_stmt|;
else|else
name|vs_scroll
argument_list|(
name|sp
argument_list|,
name|continuep
argument_list|,
name|wtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|continuep
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If ex wrote on the screen, refresh the screen image. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
argument_list|)
condition|)
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_N_EX_PAINT
argument_list|)
expr_stmt|;
comment|/* 	 * If we're not the bottom of the split screen stack, the screen 	 * image itself is wrong, so redraw everything. 	 */
if|if
condition|(
name|sp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|gp
operator|->
name|dq
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REDRAW
argument_list|)
expr_stmt|;
comment|/* If ex changed the underlying file, the map itself is wrong. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vip
argument_list|,
name|VIP_N_EX_REDRAW
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_REFORMAT
argument_list|)
expr_stmt|;
comment|/* Ex may have switched out of the alternate screen, return. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_ALTERNATE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Whew.  We're finally back home, after what feels like years. 	 * Kiss the ground. 	 */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EXWROTE
operator||
name|SC_EX_WAIT_NO
argument_list|)
expr_stmt|;
comment|/* 	 * We may need to repaint some of the screen, e.g.: 	 * 	 *	:set 	 *	:!ls 	 * 	 * gives us a combination of some lines that are "wrong", and a need 	 * for a full refresh. 	 */
if|if
condition|(
name|vip
operator|->
name|totalcount
operator|>
literal|1
condition|)
block|{
comment|/* Set up the redraw of the overwritten lines. */
name|ev
operator|.
name|e_event
operator|=
name|E_REPAINT
expr_stmt|;
name|ev
operator|.
name|e_flno
operator|=
name|vip
operator|->
name|totalcount
operator|>=
name|sp
operator|->
name|rows
condition|?
literal|1
else|:
name|sp
operator|->
name|rows
operator|-
name|vip
operator|->
name|totalcount
expr_stmt|;
name|ev
operator|.
name|e_tlno
operator|=
name|sp
operator|->
name|rows
expr_stmt|;
comment|/* Reset the count of overwriting lines. */
name|vip
operator|->
name|linecount
operator|=
name|vip
operator|->
name|lcontinue
operator|=
name|vip
operator|->
name|totalcount
operator|=
literal|0
expr_stmt|;
comment|/* Redraw. */
operator|(
name|void
operator|)
name|vs_repaint
argument_list|(
name|sp
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Reset the count of overwriting lines. */
name|vip
operator|->
name|linecount
operator|=
name|vip
operator|->
name|lcontinue
operator|=
name|vip
operator|->
name|totalcount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vs_resolve --  *	Deal with message output.  *  * PUBLIC: int vs_resolve __P((SCR *, SCR *, int));  */
end_comment

begin_function
name|int
name|vs_resolve
parameter_list|(
name|sp
parameter_list|,
name|csp
parameter_list|,
name|forcewait
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|,
decl|*
name|csp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|forcewait
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|EVENT
name|ev
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|MSGS
modifier|*
name|mp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|int
name|redraw
decl_stmt|;
comment|/* 	 * Vs_resolve is called from the main vi loop and the refresh function 	 * to periodically ensure that the user has seen any messages that have 	 * been displayed and that any status lines are correct.  The sp screen 	 * is the screen we're checking, usually the current screen.  When it's 	 * not, csp is the current screen, used for final cursor positioning. 	 */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|csp
operator|==
name|NULL
condition|)
name|csp
operator|=
name|sp
expr_stmt|;
comment|/* Save the cursor position. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_cursor
argument_list|(
name|csp
argument_list|,
operator|&
name|oldy
argument_list|,
operator|&
name|oldx
argument_list|)
expr_stmt|;
comment|/* Ring the bell if it's scheduled. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_BELLSCHED
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|gp
argument_list|,
name|G_BELLSCHED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* Display new file status line. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_STATUS
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_STATUS
argument_list|)
expr_stmt|;
name|msgq_status
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|MSTAT_TRUNCATE
argument_list|)
expr_stmt|;
block|}
comment|/* Report on line modifications. */
name|mod_rpt
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Flush any saved messages.  If the screen isn't ready, refresh 	 * it.  (A side-effect of screen refresh is that we can display 	 * messages.)  Once this is done, don't trust the cursor.  That 	 * extra refresh screwed the pooch. 	 */
if|if
condition|(
name|gp
operator|->
name|msgq
operator|.
name|lh_first
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
operator|&&
name|vs_refresh
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|mp
operator|=
name|gp
operator|->
name|msgq
operator|.
name|lh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|gp
operator|->
name|scr_msg
argument_list|(
name|sp
argument_list|,
name|mp
operator|->
name|mtype
argument_list|,
name|mp
operator|->
name|buf
argument_list|,
name|mp
operator|->
name|len
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|mp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_CUR_INVALID
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|vip
operator|->
name|totalcount
condition|)
block|{
case|case
literal|0
case|:
name|redraw
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 		 * If we're switching screens, we have to wait for messages, 		 * regardless.  If we don't wait, skip updating the modeline. 		 */
if|if
condition|(
name|forcewait
condition|)
name|vs_scroll
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|SCROLL_W
argument_list|)
expr_stmt|;
else|else
name|F_SET
argument_list|(
name|vip
argument_list|,
name|VIP_S_MODELINE
argument_list|)
expr_stmt|;
name|redraw
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 		 * If>1 message line in use, prompt the user to continue and 		 * repaint overwritten lines. 		 */
name|vs_scroll
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|SCROLL_W
argument_list|)
expr_stmt|;
name|ev
operator|.
name|e_event
operator|=
name|E_REPAINT
expr_stmt|;
name|ev
operator|.
name|e_flno
operator|=
name|vip
operator|->
name|totalcount
operator|>=
name|sp
operator|->
name|rows
condition|?
literal|1
else|:
name|sp
operator|->
name|rows
operator|-
name|vip
operator|->
name|totalcount
expr_stmt|;
name|ev
operator|.
name|e_tlno
operator|=
name|sp
operator|->
name|rows
expr_stmt|;
name|redraw
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Reset the count of overwriting lines. */
name|vip
operator|->
name|linecount
operator|=
name|vip
operator|->
name|lcontinue
operator|=
name|vip
operator|->
name|totalcount
operator|=
literal|0
expr_stmt|;
comment|/* Redraw. */
if|if
condition|(
name|redraw
condition|)
operator|(
name|void
operator|)
name|vs_repaint
argument_list|(
name|sp
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
comment|/* Restore the cursor position. */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|csp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * vs_scroll --  *	Scroll the screen for output.  */
end_comment

begin_function
specifier|static
name|void
name|vs_scroll
parameter_list|(
name|sp
parameter_list|,
name|continuep
parameter_list|,
name|wtype
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
modifier|*
name|continuep
decl_stmt|;
name|sw_t
name|wtype
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* 		 * Scroll the screen.  Instead of scrolling the entire screen, 		 * delete the line above the first line output so preserve the 		 * maximum amount of the screen. 		 */
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|vip
operator|->
name|totalcount
operator|<
name|sp
operator|->
name|rows
condition|?
name|LASTLINE
argument_list|(
name|sp
argument_list|)
operator|-
name|vip
operator|->
name|totalcount
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_deleteln
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* If there are screens below us, push them back into place. */
if|if
condition|(
name|sp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|gp
operator|->
name|dq
condition|)
block|{
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_insertln
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wtype
operator|==
name|SCROLL_W_QUIT
operator|&&
name|vip
operator|->
name|linecount
operator|<
name|sp
operator|->
name|t_maxrows
condition|)
return|return;
name|vs_wait
argument_list|(
name|sp
argument_list|,
name|continuep
argument_list|,
name|wtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vs_wait --  *	Prompt the user to continue.  */
end_comment

begin_function
specifier|static
name|void
name|vs_wait
parameter_list|(
name|sp
parameter_list|,
name|continuep
parameter_list|,
name|wtype
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
modifier|*
name|continuep
decl_stmt|;
name|sw_t
name|wtype
decl_stmt|;
block|{
name|EVENT
name|ev
decl_stmt|;
name|VI_PRIVATE
modifier|*
name|vip
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|vip
operator|=
name|VIP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_move
argument_list|(
name|sp
argument_list|,
name|LASTLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ONELINE
argument_list|(
name|sp
argument_list|)
condition|)
name|p
operator|=
name|msg_cmsg
argument_list|(
name|sp
argument_list|,
name|CMSG_CONT_S
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|wtype
condition|)
block|{
case|case
name|SCROLL_W_QUIT
case|:
name|p
operator|=
name|msg_cmsg
argument_list|(
name|sp
argument_list|,
name|CMSG_CONT_Q
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCROLL_W_EX
case|:
name|p
operator|=
name|msg_cmsg
argument_list|(
name|sp
argument_list|,
name|CMSG_CONT_EX
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCROLL_W
case|:
name|p
operator|=
name|msg_cmsg
argument_list|(
name|sp
argument_list|,
name|CMSG_CONT
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|vip
operator|->
name|totalcount
expr_stmt|;
name|vip
operator|->
name|linecount
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_clrtoeol
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_refresh
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get a single character from the terminal. */
if|if
condition|(
name|continuep
operator|!=
name|NULL
condition|)
operator|*
name|continuep
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|v_event_get
argument_list|(
name|sp
argument_list|,
operator|&
name|ev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ev
operator|.
name|e_event
operator|==
name|E_CHARACTER
condition|)
break|break;
if|if
condition|(
name|ev
operator|.
name|e_event
operator|==
name|E_INTERRUPT
condition|)
block|{
name|ev
operator|.
name|e_c
operator|=
name|CH_QUIT
expr_stmt|;
name|F_SET
argument_list|(
name|gp
argument_list|,
name|G_INTERRUPTED
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|wtype
condition|)
block|{
case|case
name|SCROLL_W_QUIT
case|:
if|if
condition|(
name|ev
operator|.
name|e_c
operator|==
name|CH_QUIT
condition|)
name|F_SET
argument_list|(
name|gp
argument_list|,
name|G_INTERRUPTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCROLL_W_EX
case|:
if|if
condition|(
name|ev
operator|.
name|e_c
operator|==
literal|':'
operator|&&
name|continuep
operator|!=
name|NULL
condition|)
operator|*
name|continuep
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCROLL_W
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * vs_divider --  *	Draw a dividing line between the screen and the output.  */
end_comment

begin_function
specifier|static
name|void
name|vs_divider
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
define|#
directive|define
name|DIVIDESTR
value|"+=+=+=+=+=+=+=+"
name|len
operator|=
sizeof|sizeof
argument_list|(
name|DIVIDESTR
argument_list|)
operator|-
literal|1
operator|>
name|sp
operator|->
name|cols
condition|?
name|sp
operator|->
name|cols
else|:
sizeof|sizeof
argument_list|(
name|DIVIDESTR
argument_list|)
operator|-
literal|1
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_INVERSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_addstr
argument_list|(
name|sp
argument_list|,
name|DIVIDESTR
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gp
operator|->
name|scr_attr
argument_list|(
name|sp
argument_list|,
name|SA_INVERSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vs_msgsave --  *	Save a message for later display.  */
end_comment

begin_function
specifier|static
name|void
name|vs_msgsave
parameter_list|(
name|sp
parameter_list|,
name|mt
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|mtype_t
name|mt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|MSGS
modifier|*
name|mp_c
decl_stmt|,
modifier|*
name|mp_n
decl_stmt|;
comment|/* 	 * We have to handle messages before we have any place to put them. 	 * If there's no screen support yet, allocate a msg structure, copy 	 * in the message, and queue it on the global structure.  If we can't 	 * allocate memory here, we're genuinely screwed, dump the message 	 * to stderr in the (probably) vain hope that someone will see it. 	 */
name|CALLOC_GOTO
argument_list|(
name|sp
argument_list|,
name|mp_n
argument_list|,
name|MSGS
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|MSGS
argument_list|)
argument_list|)
expr_stmt|;
name|MALLOC_GOTO
argument_list|(
name|sp
argument_list|,
name|mp_n
operator|->
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|mp_n
operator|->
name|buf
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mp_n
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|mp_n
operator|->
name|mtype
operator|=
name|mt
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
operator|(
name|mp_c
operator|=
name|gp
operator|->
name|msgq
operator|.
name|lh_first
operator|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|gp
operator|->
name|msgq
argument_list|,
name|mp_n
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|mp_c
operator|->
name|q
operator|.
name|le_next
operator|!=
name|NULL
condition|;
name|mp_c
operator|=
name|mp_c
operator|->
name|q
operator|.
name|le_next
control|)
empty_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|mp_c
argument_list|,
name|mp_n
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
return|return;
name|alloc_err
label|:
if|if
condition|(
name|mp_n
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mp_n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

