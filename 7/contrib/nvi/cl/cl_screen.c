begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  *  * See the LICENSE file for redistribution information.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cl_screen.c	10.49 (Berkeley) 9/24/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|cl_ex_end
name|__P
argument_list|(
operator|(
name|GS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cl_ex_init
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cl_freecap
name|__P
argument_list|(
operator|(
name|CL_PRIVATE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cl_vi_end
name|__P
argument_list|(
operator|(
name|GS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cl_vi_init
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cl_putenv
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * cl_screen --  *	Switch screen types.  *  * PUBLIC: int cl_screen __P((SCR *, u_int32_t));  */
end_comment

begin_function
name|int
name|cl_screen
parameter_list|(
name|sp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* See if the current information is incorrect. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_SRESTART
argument_list|)
condition|)
block|{
if|if
condition|(
name|cl_quit
argument_list|(
name|gp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_CLR
argument_list|(
name|gp
argument_list|,
name|G_SRESTART
argument_list|)
expr_stmt|;
block|}
comment|/* See if we're already in the right mode. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SC_EX
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EX
argument_list|)
operator|||
name|LF_ISSET
argument_list|(
name|SC_VI
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Fake leaving ex mode. 	 * 	 * We don't actually exit ex or vi mode unless forced (e.g. by a window 	 * size change).  This is because many curses implementations can't be 	 * called twice in a single program.  Plus, it's faster.  If the editor 	 * "leaves" vi to enter ex, when it exits ex we'll just fall back into 	 * vi. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EX
argument_list|)
condition|)
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_SCR_EX
argument_list|)
expr_stmt|;
comment|/* 	 * Fake leaving vi mode. 	 * 	 * Clear out the rest of the screen if we're in the middle of a split 	 * screen.  Move to the last line in the current screen -- this makes 	 * terminal scrolling happen naturally.  Note: *don't* move past the 	 * end of the screen, as there are ex commands (e.g., :read ! cat file) 	 * that don't want to.  Don't clear the info line, its contents may be 	 * valid, e.g. :file|append. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SC_SCR_VI
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|gp
operator|->
name|dq
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|RLNO
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|rows
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|move
argument_list|(
name|RLNO
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|rows
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
comment|/* Enter the requested mode. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SC_EX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cl_ex_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|clp
argument_list|,
name|CL_IN_EX
operator||
name|CL_SCR_EX_INIT
argument_list|)
expr_stmt|;
comment|/* 		 * If doing an ex screen for ex mode, move to the last line 		 * on the screen. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|SC_EX
argument_list|)
operator|&&
name|clp
operator|->
name|cup
operator|!=
name|NULL
condition|)
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|clp
operator|->
name|cup
argument_list|,
literal|0
argument_list|,
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_LINES
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|cl_putchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cl_vi_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_CLR
argument_list|(
name|clp
argument_list|,
name|CL_IN_EX
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|clp
argument_list|,
name|CL_SCR_VI_INIT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_quit --  *	Shutdown the screens.  *  * PUBLIC: int cl_quit __P((GS *));  */
end_comment

begin_function
name|int
name|cl_quit
parameter_list|(
name|gp
parameter_list|)
name|GS
modifier|*
name|gp
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
name|clp
operator|=
name|GCLP
argument_list|(
name|gp
argument_list|)
expr_stmt|;
comment|/* 	 * If we weren't really running, ignore it.  This happens if the 	 * screen changes size before we've called curses. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_SCR_EX_INIT
operator||
name|CL_SCR_VI_INIT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Clean up the terminal mappings. */
if|if
condition|(
name|cl_term_end
argument_list|(
name|gp
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
comment|/* Really leave vi mode. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_SCR_VI_INIT
argument_list|)
operator|&&
name|cl_vi_end
argument_list|(
name|gp
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
comment|/* Really leave ex mode. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_SCR_EX_INIT
argument_list|)
operator|&&
name|cl_ex_end
argument_list|(
name|gp
argument_list|)
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If we were running ex when we quit, or we're using an implementation 	 * of curses where endwin() doesn't get this right, restore the original 	 * terminal modes. 	 * 	 * XXX 	 * We always do this because it's too hard to figure out what curses 	 * implementations get it wrong.  It may discard type-ahead characters 	 * from the tty queue. 	 */
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSADRAIN
operator||
name|TCSASOFT
argument_list|,
operator|&
name|clp
operator|->
name|orig
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|clp
argument_list|,
name|CL_SCR_EX_INIT
operator||
name|CL_SCR_VI_INIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_vi_init --  *	Initialize the curses vi screen.  */
end_comment

begin_function
specifier|static
name|int
name|cl_vi_init
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|char
modifier|*
name|o_cols
decl_stmt|,
modifier|*
name|o_lines
decl_stmt|,
modifier|*
name|o_term
decl_stmt|,
modifier|*
name|ttype
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* If already initialized, just set the terminal modes. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_SCR_VI_INIT
argument_list|)
condition|)
goto|goto
name|fast
goto|;
comment|/* Curses vi always reads from (and writes to) a terminal. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
operator|||
operator|!
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"016|Vi's standard input and output must be a terminal"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We'll need a terminal type. */
if|if
condition|(
name|opts_empty
argument_list|(
name|sp
argument_list|,
name|O_TERM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ttype
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_TERM
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * Changing the row/column and terminal values is done by putting them 	 * into the environment, which is then read by curses.  What this loses 	 * in ugliness, it makes up for in stupidity.  We can't simply put the 	 * values into the environment ourselves, because in the presence of a 	 * kernel mechanism for returning the window size, entering values into 	 * the environment will screw up future screen resizing events, e.g. if 	 * the user enters a :shell command and then resizes their window.  So, 	 * if they weren't already in the environment, we make sure to delete 	 * them immediately after setting them. 	 * 	 * XXX 	 * Putting the TERM variable into the environment is necessary, even 	 * though we're using newterm() here.  We may be using initscr() as 	 * the underlying function. 	 */
name|o_term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
name|cl_putenv
argument_list|(
literal|"TERM"
argument_list|,
name|ttype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|o_lines
operator|=
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
expr_stmt|;
name|cl_putenv
argument_list|(
literal|"LINES"
argument_list|,
name|NULL
argument_list|,
operator|(
name|u_long
operator|)
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_LINES
argument_list|)
argument_list|)
expr_stmt|;
name|o_cols
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
expr_stmt|;
name|cl_putenv
argument_list|(
literal|"COLUMNS"
argument_list|,
name|NULL
argument_list|,
operator|(
name|u_long
operator|)
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_COLUMNS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We don't care about the SCREEN reference returned by newterm, we 	 * never have more than one SCREEN at a time. 	 * 	 * XXX 	 * The SunOS initscr() can't be called twice.  Don't even think about 	 * using it.  It fails in subtle ways (e.g. select(2) on fileno(stdin) 	 * stops working).  (The SVID notes that applications should only call 	 * initscr() once.) 	 * 	 * XXX 	 * The HP/UX newterm doesn't support the NULL first argument, so we 	 * have to specify the terminal type. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newterm
argument_list|(
name|ttype
argument_list|,
name|stdout
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|ttype
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: unknown terminal type"
argument_list|,
name|ttype
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|o_term
operator|==
name|NULL
condition|)
name|unsetenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_lines
operator|==
name|NULL
condition|)
name|unsetenv
argument_list|(
literal|"LINES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_cols
operator|==
name|NULL
condition|)
name|unsetenv
argument_list|(
literal|"COLUMNS"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * Someone got let out alone without adult supervision -- the SunOS 	 * newterm resets the signal handlers.  There's a race, but it's not 	 * worth closing. 	 */
operator|(
name|void
operator|)
name|sig_init
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * We use raw mode.  What we want is 8-bit clean, however, signals 	 * and flow control should continue to work.  Admittedly, it sounds 	 * like cbreak, but it isn't.  Using cbreak() can get you additional 	 * things like IEXTEN, which turns on flags like DISCARD and LNEXT. 	 * 	 * !!! 	 * If raw isn't turning off echo and newlines, something's wrong. 	 * However, it shouldn't hurt. 	 */
name|noecho
argument_list|()
expr_stmt|;
comment|/* No character echo. */
name|nonl
argument_list|()
expr_stmt|;
comment|/* No CR/NL translation. */
name|raw
argument_list|()
expr_stmt|;
comment|/* 8-bit clean. */
name|idlok
argument_list|(
name|stdscr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Use hardware insert/delete line. */
comment|/* Put the cursor keys into application mode. */
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * The screen TI sequence just got sent.  See the comment in 	 * cl_funcs.c:cl_attr(). 	 */
name|clp
operator|->
name|ti_te
operator|=
name|TI_SENT
expr_stmt|;
comment|/* 	 * XXX 	 * Historic implementations of curses handled SIGTSTP signals 	 * in one of three ways.  They either: 	 * 	 *	1: Set their own handler, regardless. 	 *	2: Did not set a handler if a handler was already installed. 	 *	3: Set their own handler, but then called any previously set 	 *	   handler after completing their own cleanup. 	 * 	 * We don't try and figure out which behavior is in place, we force 	 * it to SIG_DFL after initializing the curses interface, which means 	 * that curses isn't going to take the signal.  Since curses isn't 	 * reentrant (i.e., the whole curses SIGTSTP interface is a fantasy), 	 * we're doing The Right Thing. 	 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* 	 * If flow control was on, turn it back on.  Turn signals on.  ISIG 	 * turns on VINTR, VQUIT, VDSUSP and VSUSP.   The main curses code 	 * already installed a handler for VINTR.  We're going to disable the 	 * other three. 	 * 	 * XXX 	 * We want to use ^Y as a vi scrolling command.  If the user has the 	 * DSUSP character set to ^Y (common practice) clean it up.  As it's 	 * equally possible that the user has VDSUSP set to 'a', we disable 	 * it regardless.  It doesn't make much sense to suspend vi at read, 	 * so I don't think anyone will care.  Alternatively, we could look 	 * it up in the table of legal command characters and turn it off if 	 * it matches one.  VDSUSP wasn't in POSIX 1003.1-1990, so we test for 	 * it. 	 * 	 * XXX 	 * We don't check to see if the user had signals enabled originally. 	 * If they didn't, it's unclear what we're supposed to do here, but 	 * it's also pretty unlikely. 	 */
if|if
condition|(
name|tcgetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|clp
operator|->
name|vi_enter
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"tcgetattr"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|clp
operator|->
name|orig
operator|.
name|c_iflag
operator|&
name|IXON
condition|)
name|clp
operator|->
name|vi_enter
operator|.
name|c_iflag
operator||=
name|IXON
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|orig
operator|.
name|c_iflag
operator|&
name|IXOFF
condition|)
name|clp
operator|->
name|vi_enter
operator|.
name|c_iflag
operator||=
name|IXOFF
expr_stmt|;
name|clp
operator|->
name|vi_enter
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
ifdef|#
directive|ifdef
name|VDSUSP
name|clp
operator|->
name|vi_enter
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
endif|#
directive|endif
name|clp
operator|->
name|vi_enter
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
name|clp
operator|->
name|vi_enter
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
comment|/* 	 * XXX 	 * OSF/1 doesn't turn off the<discard>,<literal-next> or<status> 	 * characters when curses switches into raw mode.  It should be OK 	 * to do it explicitly for everyone. 	 */
ifdef|#
directive|ifdef
name|VDISCARD
name|clp
operator|->
name|vi_enter
operator|.
name|c_cc
index|[
name|VDISCARD
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VLNEXT
name|clp
operator|->
name|vi_enter
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSTATUS
name|clp
operator|->
name|vi_enter
operator|.
name|c_cc
index|[
name|VSTATUS
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize terminal based information. */
if|if
condition|(
name|cl_term_init
argument_list|(
name|sp
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|fast
label|:
comment|/* Set the terminal modes. */
if|if
condition|(
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSASOFT
operator||
name|TCSADRAIN
argument_list|,
operator|&
name|clp
operator|->
name|vi_enter
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|fast
goto|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"tcsetattr"
argument_list|)
expr_stmt|;
name|err
label|:
operator|(
name|void
operator|)
name|cl_vi_end
argument_list|(
name|sp
operator|->
name|gp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_vi_end --  *	Shutdown the vi screen.  */
end_comment

begin_function
specifier|static
name|int
name|cl_vi_end
parameter_list|(
name|gp
parameter_list|)
name|GS
modifier|*
name|gp
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|GCLP
argument_list|(
name|gp
argument_list|)
expr_stmt|;
comment|/* Restore the cursor keys to normal mode. */
operator|(
name|void
operator|)
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * If we were running vi when we quit, scroll the screen up a single 	 * line so we don't lose any information. 	 * 	 * Move to the bottom of the window (some endwin implementations don't 	 * do this for you). 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_IN_EX
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|deleteln
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
block|}
name|cl_freecap
argument_list|(
name|clp
argument_list|)
expr_stmt|;
comment|/* End curses window. */
operator|(
name|void
operator|)
name|endwin
argument_list|()
expr_stmt|;
comment|/* 	 * XXX 	 * The screen TE sequence just got sent.  See the comment in 	 * cl_funcs.c:cl_attr(). 	 */
name|clp
operator|->
name|ti_te
operator|=
name|TE_SENT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_ex_init --  *	Initialize the ex screen.  */
end_comment

begin_function
specifier|static
name|int
name|cl_ex_init
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|CLP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* If already initialized, just set the terminal modes. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_SCR_EX_INIT
argument_list|)
condition|)
goto|goto
name|fast
goto|;
comment|/* If not reading from a file, we're done. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|clp
argument_list|,
name|CL_STDIN_TTY
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Get the ex termcap/terminfo strings. */
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"cup"
argument_list|,
operator|&
name|clp
operator|->
name|cup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"smso"
argument_list|,
operator|&
name|clp
operator|->
name|smso
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"rmso"
argument_list|,
operator|&
name|clp
operator|->
name|rmso
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"el"
argument_list|,
operator|&
name|clp
operator|->
name|el
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cl_getcap
argument_list|(
name|sp
argument_list|,
literal|"cuu1"
argument_list|,
operator|&
name|clp
operator|->
name|cuu1
argument_list|)
expr_stmt|;
comment|/* Enter_standout_mode and exit_standout_mode are paired. */
if|if
condition|(
name|clp
operator|->
name|smso
operator|==
name|NULL
operator|||
name|clp
operator|->
name|rmso
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|clp
operator|->
name|smso
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|clp
operator|->
name|smso
argument_list|)
expr_stmt|;
name|clp
operator|->
name|smso
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|clp
operator|->
name|rmso
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|clp
operator|->
name|rmso
argument_list|)
expr_stmt|;
name|clp
operator|->
name|rmso
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Turn on canonical mode, with normal input and output processing. 	 * Start with the original terminal settings as the user probably 	 * had them (including any local extensions) set correctly for the 	 * current terminal. 	 * 	 * !!! 	 * We can't get everything that we need portably; for example, ONLCR, 	 * mapping<newline> to<carriage-return> on output isn't required 	 * by POSIX 1003.1b-1993.  If this turns out to be a problem, then 	 * we'll either have to play some games on the mapping, or we'll have 	 * to make all ex printf's output \r\n instead of \n. 	 */
name|clp
operator|->
name|ex_enter
operator|=
name|clp
operator|->
name|orig
expr_stmt|;
name|clp
operator|->
name|ex_enter
operator|.
name|c_lflag
operator||=
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
expr_stmt|;
ifdef|#
directive|ifdef
name|ECHOCTL
name|clp
operator|->
name|ex_enter
operator|.
name|c_lflag
operator||=
name|ECHOCTL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ECHOKE
name|clp
operator|->
name|ex_enter
operator|.
name|c_lflag
operator||=
name|ECHOKE
expr_stmt|;
endif|#
directive|endif
name|clp
operator|->
name|ex_enter
operator|.
name|c_iflag
operator||=
name|ICRNL
expr_stmt|;
name|clp
operator|->
name|ex_enter
operator|.
name|c_oflag
operator||=
name|OPOST
expr_stmt|;
ifdef|#
directive|ifdef
name|ONLCR
name|clp
operator|->
name|ex_enter
operator|.
name|c_oflag
operator||=
name|ONLCR
expr_stmt|;
endif|#
directive|endif
name|fast
label|:
if|if
condition|(
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSADRAIN
operator||
name|TCSASOFT
argument_list|,
operator|&
name|clp
operator|->
name|ex_enter
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|fast
goto|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"tcsetattr"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_ex_end --  *	Shutdown the ex screen.  */
end_comment

begin_function
specifier|static
name|int
name|cl_ex_end
parameter_list|(
name|gp
parameter_list|)
name|GS
modifier|*
name|gp
decl_stmt|;
block|{
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|GCLP
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|cl_freecap
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cl_getcap --  *	Retrieve termcap/terminfo strings.  *  * PUBLIC: int cl_getcap __P((SCR *, char *, char **));  */
end_comment

begin_function
name|int
name|cl_getcap
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|elementp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
modifier|*
name|elementp
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tigetstr
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|t
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|&&
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
operator|*
name|elementp
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|*
name|elementp
argument_list|,
name|t
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * cl_freecap --  *	Free any allocated termcap/terminfo strings.  */
end_comment

begin_function
specifier|static
name|void
name|cl_freecap
parameter_list|(
name|clp
parameter_list|)
name|CL_PRIVATE
modifier|*
name|clp
decl_stmt|;
block|{
if|if
condition|(
name|clp
operator|->
name|el
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|clp
operator|->
name|el
argument_list|)
expr_stmt|;
name|clp
operator|->
name|el
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|clp
operator|->
name|cup
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|clp
operator|->
name|cup
argument_list|)
expr_stmt|;
name|clp
operator|->
name|cup
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|clp
operator|->
name|cuu1
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|clp
operator|->
name|cuu1
argument_list|)
expr_stmt|;
name|clp
operator|->
name|cuu1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|clp
operator|->
name|rmso
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|clp
operator|->
name|rmso
argument_list|)
expr_stmt|;
name|clp
operator|->
name|rmso
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|clp
operator|->
name|smso
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|clp
operator|->
name|smso
argument_list|)
expr_stmt|;
name|clp
operator|->
name|smso
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * cl_putenv --  *	Put a value into the environment.  */
end_comment

begin_function
specifier|static
name|int
name|cl_putenv
parameter_list|(
name|name
parameter_list|,
name|str
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_decl_stmt
name|u_long
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%lu"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|setenv
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|setenv
argument_list|(
name|name
argument_list|,
name|str
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

