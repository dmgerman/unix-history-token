begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (C) 2004-2006  * 	Hartmut Brandt.  * 	All rights reserved.  *   * Author: Harti Brandt<harti@freebsd.org>  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Begemot: gensnmpdef.c 383 2006-05-30 07:40:49Z brandt_h $  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<smi.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|usgtxt
index|[]
init|=
literal|"Usage: gensnmpdef [-hEe] [-c<cut>] MIB [MIB ...]\n"
literal|"Options:\n"
literal|"  -c	specify the number of initial sub-oids to cut from the oids\n"
literal|"  -E	extract named enum types. Print a typedef for all enums defined\n"
literal|"	in syntax clauses of normal objects. Suppress normal output.\n"
literal|"  -e	extract unnamed enum types. Print a typedef for all enums defined\n"
literal|"	as textual conventions. Suppress normal output.\n"
literal|"  -h	print this help\n"
literal|"MIBs are searched according to the libsmi(3) search rules and can\n"
literal|"be specified either by path or module name\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SmiNode
modifier|*
name|last_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cut
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tdef
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|tdef
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|tdef
argument_list|)
name|tdefs
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|tdef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|do_typedef
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|print_node
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|save_node
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|last_node
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pindent
parameter_list|(
name|u_int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|>=
name|cut
condition|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
operator|(
name|level
operator|-
name|cut
operator|)
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_name
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|n
operator|->
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|printf
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|close_node
parameter_list|(
name|u_int
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|>=
name|cut
condition|)
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|level
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|open_node
parameter_list|(
specifier|const
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|,
name|SmiNode
modifier|*
modifier|*
name|last
parameter_list|)
block|{
name|SmiNode
modifier|*
name|n1
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|last
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|*
name|last
operator|)
operator|->
name|oidlen
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|n
operator|->
name|oidlen
condition|)
block|{
name|level
operator|=
name|close_node
argument_list|(
operator|(
operator|*
name|last
operator|)
operator|->
name|oidlen
operator|-
name|n
operator|->
name|oidlen
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|last
operator|)
operator|->
name|oid
index|[
name|i
index|]
operator|!=
name|n
operator|->
name|oid
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
operator|(
operator|*
name|last
operator|)
operator|->
name|oidlen
operator|-
literal|1
condition|)
name|level
operator|=
name|close_node
argument_list|(
operator|(
operator|*
name|last
operator|)
operator|->
name|oidlen
operator|-
literal|1
operator|-
name|i
argument_list|,
name|level
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|level
operator|<
name|n
operator|->
name|oidlen
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|level
operator|>=
name|cut
condition|)
block|{
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%u"
argument_list|,
name|n
operator|->
name|oid
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|n1
operator|=
name|smiGetNodeByOID
argument_list|(
name|level
operator|+
literal|1
argument_list|,
name|n
operator|->
name|oid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|level
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|level
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|type_names
index|[]
init|=
block|{
index|[
name|SMI_BASETYPE_UNKNOWN
index|]
operator|=
literal|"UNKNOWN_TYPE"
block|,
index|[
name|SMI_BASETYPE_INTEGER32
index|]
operator|=
literal|"INTEGER"
block|,
index|[
name|SMI_BASETYPE_OCTETSTRING
index|]
operator|=
literal|"OCTETSTRING"
block|,
index|[
name|SMI_BASETYPE_OBJECTIDENTIFIER
index|]
operator|=
literal|"OID"
block|,
index|[
name|SMI_BASETYPE_UNSIGNED32
index|]
operator|=
literal|"UNSIGNED32"
block|,
index|[
name|SMI_BASETYPE_INTEGER64
index|]
operator|=
literal|"INTEGER64"
block|,
index|[
name|SMI_BASETYPE_UNSIGNED64
index|]
operator|=
literal|"UNSIGNED64"
block|,
index|[
name|SMI_BASETYPE_FLOAT32
index|]
operator|=
literal|"FLOAT32"
block|,
index|[
name|SMI_BASETYPE_FLOAT64
index|]
operator|=
literal|"FLOAT64"
block|,
index|[
name|SMI_BASETYPE_FLOAT128
index|]
operator|=
literal|"FLOAT128"
block|,
index|[
name|SMI_BASETYPE_ENUM
index|]
operator|=
literal|"ENUM"
block|,
index|[
name|SMI_BASETYPE_BITS
index|]
operator|=
literal|"BITS"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|type_map
index|[]
init|=
block|{
literal|"Gauge32"
block|,
literal|"GAUGE"
block|,
literal|"Gauge"
block|,
literal|"GAUGE"
block|,
literal|"TimeTicks"
block|,
literal|"TIMETICKS"
block|,
literal|"Counter32"
block|,
literal|"COUNTER"
block|,
literal|"Counter"
block|,
literal|"COUNTER"
block|,
literal|"Counter64"
block|,
literal|"COUNTER64"
block|,
literal|"Integer32"
block|,
literal|"INTEGER32"
block|,
literal|"IpAddress"
block|,
literal|"IPADDRESS"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_enum
parameter_list|(
name|SmiType
modifier|*
name|t
parameter_list|)
block|{
name|SmiNamedNumber
modifier|*
name|nnum
decl_stmt|;
name|printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
for|for
control|(
name|nnum
operator|=
name|smiGetFirstNamedNumber
argument_list|(
name|t
argument_list|)
init|;
name|nnum
operator|!=
name|NULL
condition|;
name|nnum
operator|=
name|smiGetNextNamedNumber
argument_list|(
name|nnum
argument_list|)
control|)
name|printf
argument_list|(
literal|" %ld %s"
argument_list|,
name|nnum
operator|->
name|value
operator|.
name|value
operator|.
name|integer32
argument_list|,
name|nnum
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_type
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|)
block|{
name|SmiType
modifier|*
name|type
decl_stmt|;
name|u_int
name|m
decl_stmt|;
name|type
operator|=
name|smiGetNodeType
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|type_map
index|[
name|m
index|]
operator|!=
name|NULL
condition|;
name|m
operator|+=
literal|2
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|type_map
index|[
name|m
index|]
argument_list|,
name|type
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|type_map
index|[
name|m
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|type_names
index|[
name|type
operator|->
name|basetype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|basetype
operator|==
name|SMI_BASETYPE_ENUM
operator|||
name|type
operator|->
name|basetype
operator|==
name|SMI_BASETYPE_BITS
condition|)
name|print_enum
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|->
name|basetype
operator|==
name|SMI_BASETYPE_OCTETSTRING
operator|&&
name|type
operator|->
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" | %s"
argument_list|,
name|type
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_access
parameter_list|(
name|SmiAccess
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|SMI_ACCESS_READ_ONLY
condition|)
name|printf
argument_list|(
literal|" GET"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|==
name|SMI_ACCESS_READ_WRITE
condition|)
name|printf
argument_list|(
literal|" GET SET"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_scalar
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
block|{
name|SmiNode
modifier|*
name|p
decl_stmt|;
name|assert
argument_list|(
name|n
operator|->
name|nodekind
operator|==
name|SMI_NODEKIND_SCALAR
argument_list|)
expr_stmt|;
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%u "
argument_list|,
name|n
operator|->
name|oid
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* generate the operation from the parent node name */
name|p
operator|=
name|smiGetParentNode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" op_%s"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_access
argument_list|(
name|n
operator|->
name|access
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_notification
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|nodekind
operator|==
name|SMI_NODEKIND_NOTIFICATION
argument_list|)
expr_stmt|;
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%u "
argument_list|,
name|n
operator|->
name|oid
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" OID"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" op_%s)\n"
argument_list|,
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_col
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|nodekind
operator|==
name|SMI_NODEKIND_COLUMN
argument_list|)
expr_stmt|;
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%u "
argument_list|,
name|n
operator|->
name|oid
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|print_access
argument_list|(
name|n
operator|->
name|access
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_index
parameter_list|(
name|SmiNode
modifier|*
name|row
parameter_list|)
block|{
name|SmiElement
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|smiGetFirstElement
argument_list|(
name|row
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|smiGetElementNode
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|smiGetNextElement
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_table
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
block|{
name|SmiNode
modifier|*
name|row
decl_stmt|,
modifier|*
name|col
decl_stmt|,
modifier|*
name|rel
decl_stmt|;
name|assert
argument_list|(
name|n
operator|->
name|nodekind
operator|==
name|SMI_NODEKIND_TABLE
argument_list|)
expr_stmt|;
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%u "
argument_list|,
name|n
operator|->
name|oid
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|row
operator|=
name|smiGetFirstChildNode
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|->
name|nodekind
operator|!=
name|SMI_NODEKIND_ROW
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: kind %u, not row"
argument_list|,
name|__func__
argument_list|,
name|row
operator|->
name|nodekind
argument_list|)
expr_stmt|;
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|pindent
argument_list|(
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%u "
argument_list|,
name|row
operator|->
name|oid
index|[
name|level
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" :"
argument_list|)
expr_stmt|;
comment|/* index */
name|rel
operator|=
name|smiGetRelatedNode
argument_list|(
name|row
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|row
operator|->
name|indexkind
condition|)
block|{
case|case
name|SMI_INDEX_INDEX
case|:
name|print_index
argument_list|(
name|row
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMI_INDEX_AUGMENT
case|:
if|if
condition|(
name|rel
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: cannot find augemented table"
argument_list|,
name|row
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_index
argument_list|(
name|rel
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: cannot handle index kind %u"
argument_list|,
name|row
operator|->
name|name
argument_list|,
name|row
operator|->
name|indexkind
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" op_%s"
argument_list|,
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|col
operator|=
name|smiGetFirstChildNode
argument_list|(
name|row
argument_list|)
expr_stmt|;
while|while
condition|(
name|col
operator|!=
name|NULL
condition|)
block|{
name|print_col
argument_list|(
name|col
argument_list|,
name|level
operator|+
literal|2
argument_list|)
expr_stmt|;
name|col
operator|=
name|smiGetNextChildNode
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
name|pindent
argument_list|(
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_it
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|nodekind
condition|)
block|{
case|case
name|SMI_NODEKIND_NODE
case|:
name|print_node
argument_list|(
name|n
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMI_NODEKIND_SCALAR
case|:
name|print_scalar
argument_list|(
name|n
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMI_NODEKIND_TABLE
case|:
name|print_table
argument_list|(
name|n
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMI_NODEKIND_COMPLIANCE
case|:
case|case
name|SMI_NODEKIND_GROUP
case|:
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMI_NODEKIND_NOTIFICATION
case|:
name|print_notification
argument_list|(
name|n
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot handle %u nodes"
argument_list|,
name|n
operator|->
name|nodekind
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_node
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|,
name|u_int
name|level
parameter_list|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|nodekind
operator|==
name|SMI_NODEKIND_NODE
argument_list|)
expr_stmt|;
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%u "
argument_list|,
name|n
operator|->
name|oid
index|[
name|level
index|]
argument_list|)
expr_stmt|;
name|print_name
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|n
operator|=
name|smiGetFirstChildNode
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|print_it
argument_list|(
name|n
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|smiGetNextChildNode
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|pindent
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_typdef
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tdef
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tdef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tdef
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|tdefs
argument_list|,
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tdefs_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tdef
modifier|*
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|tdefs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|tdefs
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_enum_typedef
parameter_list|(
name|SmiType
modifier|*
name|t
parameter_list|)
block|{
name|SmiNamedNumber
modifier|*
name|nnum
decl_stmt|;
for|for
control|(
name|nnum
operator|=
name|smiGetFirstNamedNumber
argument_list|(
name|t
argument_list|)
init|;
name|nnum
operator|!=
name|NULL
condition|;
name|nnum
operator|=
name|smiGetNextNamedNumber
argument_list|(
name|nnum
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"\t%ld %s\n"
argument_list|,
name|nnum
operator|->
name|value
operator|.
name|value
operator|.
name|integer32
argument_list|,
name|nnum
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_stype
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|)
block|{
name|SmiType
modifier|*
name|type
decl_stmt|;
name|struct
name|tdef
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|type
operator|=
name|smiGetNodeType
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|type
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|basetype
operator|==
name|SMI_BASETYPE_ENUM
condition|)
block|{
if|if
condition|(
name|do_typedef
operator|==
literal|'e'
operator|&&
name|type
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&tdefs
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|type
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
name|save_typdef
argument_list|(
name|type
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"typedef %s ENUM (\n"
argument_list|,
name|type
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_typedef
operator|==
literal|'E'
operator|&&
name|type
operator|->
name|name
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"typedef %sType ENUM (\n"
argument_list|,
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
return|return;
name|print_enum_typedef
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|->
name|basetype
operator|==
name|SMI_BASETYPE_BITS
condition|)
block|{
if|if
condition|(
name|do_typedef
operator|==
literal|'e'
operator|&&
name|type
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&tdefs
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|type
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
name|save_typdef
argument_list|(
name|type
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"typedef %s BITS (\n"
argument_list|,
name|type
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_typedef
operator|==
literal|'E'
operator|&&
name|type
operator|->
name|name
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"typedef %sType BITS (\n"
argument_list|,
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
return|return;
name|print_enum_typedef
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_typdefs
parameter_list|(
name|SmiNode
modifier|*
name|n
parameter_list|)
block|{
name|SmiNode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|smiGetFirstChildNode
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|n
operator|->
name|nodekind
condition|)
block|{
case|case
name|SMI_NODEKIND_SCALAR
case|:
case|case
name|SMI_NODEKIND_COLUMN
case|:
name|print_stype
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMI_NODEKIND_COMPLIANCE
case|:
case|case
name|SMI_NODEKIND_GROUP
case|:
name|save_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|n
operator|=
name|smiGetNextChildNode
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|save_node
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|SmiModule
modifier|*
modifier|*
name|mods
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|SmiNode
modifier|*
name|n
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|u_int
name|level
decl_stmt|;
name|long
name|u
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|smiInit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:Eeh"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'c'
case|:
name|errno
operator|=
literal|0
expr_stmt|;
name|u
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"argument to -c"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: not a number"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|<
literal|0
operator|||
name|u
operator|>
literal|5
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: out of range"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|cut
operator|=
operator|(
name|u_int
operator|)
name|u
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|do_typedef
operator|=
literal|'E'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|do_typedef
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usgtxt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|flags
operator|=
name|smiGetFlags
argument_list|()
expr_stmt|;
name|flags
operator||=
name|SMI_FLAG_ERRORS
expr_stmt|;
name|smiSetFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|mods
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mods
index|[
literal|0
index|]
argument_list|)
operator|*
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mods
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
literal|0
init|;
name|opt
operator|<
name|argc
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|smiLoadModule
argument_list|(
name|argv
index|[
name|opt
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: cannot load"
argument_list|,
name|argv
index|[
name|opt
index|]
argument_list|)
expr_stmt|;
name|mods
index|[
name|opt
index|]
operator|=
name|smiGetModule
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|level
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|opt
operator|=
literal|0
init|;
name|opt
operator|<
name|argc
condition|;
name|opt
operator|++
control|)
block|{
name|n
operator|=
name|smiGetFirstNode
argument_list|(
name|mods
index|[
name|opt
index|]
argument_list|,
name|SMI_NODEKIND_ANY
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|do_typedef
operator|==
literal|0
condition|)
block|{
name|level
operator|=
name|open_node
argument_list|(
name|n
argument_list|,
name|level
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|print_it
argument_list|(
name|n
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|last
operator|=
name|n
expr_stmt|;
block|}
else|else
name|print_typdefs
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_node
operator|==
name|NULL
operator|||
operator|(
name|n
operator|=
name|smiGetNextNode
argument_list|(
name|last_node
argument_list|,
name|SMI_NODEKIND_ANY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|last
operator|!=
name|NULL
operator|&&
name|do_typedef
operator|==
literal|0
condition|)
name|level
operator|=
name|close_node
argument_list|(
name|last
operator|->
name|oidlen
operator|-
literal|1
argument_list|,
name|level
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_typedef
operator|!=
literal|0
condition|)
name|tdefs_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

