begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF 2 support.    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004 Free Software Foundation, Inc.     Adapted from gdb/dwarf2read.c by Gavin Koch of Cygnus Solutions    (gavin@cygnus.com).     From the dwarf2read.c header:    Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,    Inc.  with support from Florida State University (under contract    with the Ada Joint Program Office), and Silicon Graphics, Inc.    Initial contribution by Brent Benson, Harris Computer Systems, Inc.,    based on Fred Fish's (Cygnus Support) implementation of DWARF 1    support in dwarfread.c     This file is part of BFD.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or (at    your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* The data in the .debug_line statement prologue looks like this.  */
end_comment

begin_struct
struct|struct
name|line_head
block|{
name|bfd_vma
name|total_length
decl_stmt|;
name|unsigned
name|short
name|version
decl_stmt|;
name|bfd_vma
name|prologue_length
decl_stmt|;
name|unsigned
name|char
name|minimum_instruction_length
decl_stmt|;
name|unsigned
name|char
name|default_is_stmt
decl_stmt|;
name|int
name|line_base
decl_stmt|;
name|unsigned
name|char
name|line_range
decl_stmt|;
name|unsigned
name|char
name|opcode_base
decl_stmt|;
name|unsigned
name|char
modifier|*
name|standard_opcode_lengths
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Attributes have a name and a value.  */
end_comment

begin_struct
struct|struct
name|attribute
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|bfd_uint64_t
name|val
decl_stmt|;
name|bfd_int64_t
name|sval
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Blocks are a bunch of untyped bytes.  */
end_comment

begin_struct
struct|struct
name|dwarf_block
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dwarf2_debug
block|{
comment|/* A list of all previously read comp_units.  */
name|struct
name|comp_unit
modifier|*
name|all_comp_units
decl_stmt|;
comment|/* The next unread compilation unit within the .debug_info section.      Zero indicates that the .debug_info section has not been loaded      into a buffer yet.  */
name|char
modifier|*
name|info_ptr
decl_stmt|;
comment|/* Pointer to the end of the .debug_info section memory buffer.  */
name|char
modifier|*
name|info_ptr_end
decl_stmt|;
comment|/* Pointer to the section and address of the beginning of the      section.  */
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
modifier|*
name|sec_info_ptr
decl_stmt|;
comment|/* Pointer to the symbol table.  */
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
comment|/* Pointer to the .debug_abbrev section loaded into memory.  */
name|char
modifier|*
name|dwarf_abbrev_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_abbrev section.  */
name|unsigned
name|long
name|dwarf_abbrev_size
decl_stmt|;
comment|/* Buffer for decode_line_info.  */
name|char
modifier|*
name|dwarf_line_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_line section.  */
name|unsigned
name|long
name|dwarf_line_size
decl_stmt|;
comment|/* Pointer to the .debug_str section loaded into memory.  */
name|char
modifier|*
name|dwarf_str_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_str section.  */
name|unsigned
name|long
name|dwarf_str_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arange
block|{
name|struct
name|arange
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A minimal decoding of DWARF2 compilation units.  We only decode    what's needed to get to the line number information.  */
end_comment

begin_struct
struct|struct
name|comp_unit
block|{
comment|/* Chain the previously read compilation units.  */
name|struct
name|comp_unit
modifier|*
name|next_unit
decl_stmt|;
comment|/* Keep the bdf convenient (for memory allocation).  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* The lowest and higest addresses contained in this compilation      unit as specified in the compilation unit header.  */
name|struct
name|arange
name|arange
decl_stmt|;
comment|/* The DW_AT_name attribute (for error messages).  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The abbrev hash table.  */
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
comment|/* Note that an error was found by comp_unit_find_nearest_line.  */
name|int
name|error
decl_stmt|;
comment|/* The DW_AT_comp_dir attribute.  */
name|char
modifier|*
name|comp_dir
decl_stmt|;
comment|/* TRUE if there is a line number table associated with this comp. unit.  */
name|int
name|stmtlist
decl_stmt|;
comment|/* The offset into .debug_line of the line number table.  */
name|unsigned
name|long
name|line_offset
decl_stmt|;
comment|/* Pointer to the first child die for the comp unit.  */
name|char
modifier|*
name|first_child_die_ptr
decl_stmt|;
comment|/* The end of the comp unit.  */
name|char
modifier|*
name|end_ptr
decl_stmt|;
comment|/* The decoded line number, NULL if not yet decoded.  */
name|struct
name|line_info_table
modifier|*
name|line_table
decl_stmt|;
comment|/* A list of the functions found in this comp. unit.  */
name|struct
name|funcinfo
modifier|*
name|function_table
decl_stmt|;
comment|/* Pointer to dwarf2_debug structure.  */
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
comment|/* Address size for this unit - from unit header.  */
name|unsigned
name|char
name|addr_size
decl_stmt|;
comment|/* Offset size for this unit - from unit header.  */
name|unsigned
name|char
name|offset_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This data structure holds the information of an abbrev.  */
end_comment

begin_struct
struct|struct
name|abbrev_info
block|{
name|unsigned
name|int
name|number
decl_stmt|;
comment|/* Number identifying abbrev.  */
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
comment|/* DWARF tag.  */
name|int
name|has_children
decl_stmt|;
comment|/* Boolean.  */
name|unsigned
name|int
name|num_attrs
decl_stmt|;
comment|/* Number of attributes.  */
name|struct
name|attr_abbrev
modifier|*
name|attrs
decl_stmt|;
comment|/* An array of attribute descriptions.  */
name|struct
name|abbrev_info
modifier|*
name|next
decl_stmt|;
comment|/* Next in chain.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|attr_abbrev
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|ABBREV_HASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|ABBREV_HASH_SIZE
value|121
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_ALLOC_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|ATTR_ALLOC_CHUNK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERBATIM    The following function up to the END VERBATIM mark are    copied directly from dwarf2read.c.  */
end_comment

begin_comment
comment|/* Read dwarf information from a buffer.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_1_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_1_signed_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_signed_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_2_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_4_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_uint64_t
name|read_8_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_n_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If the size of a host char is 8 bits, we can return a pointer      to the buffer, otherwise we have to copy the data to a buffer      allocated on the temporary obstack.  */
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
comment|/* Return a pointer to the embedded string.  */
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|bytes_read_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_indirect_string
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|bfd_uint64_t
name|offset
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
init|=
name|unit
operator|->
name|stash
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|offset_size
operator|==
literal|4
condition|)
name|offset
operator|=
name|read_4_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|read_8_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|unit
operator|->
name|offset_size
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_str_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_str"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_str section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stash
operator|->
name|dwarf_str_size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|dwarf_str_buffer
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|dwarf_str_buffer
argument_list|,
literal|0
argument_list|,
name|msec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|stash
operator|->
name|dwarf_str_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: DW_FORM_strp offset (%lu) greater than or equal to .debug_str size (%lu)."
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
name|stash
operator|->
name|dwarf_str_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf
operator|=
name|stash
operator|->
name|dwarf_str_buffer
operator|+
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_unsigned_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|unsigned
name|int
name|result
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_signed_leb128
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
operator|(
name|shift
operator|<
literal|32
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
name|result
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* END VERBATIM */
end_comment

begin_function
specifier|static
name|bfd_uint64_t
name|read_address
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
switch|switch
condition|(
name|unit
operator|->
name|addr_size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|bfd_get_64
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bfd_get_32
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bfd_get_16
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lookup an abbrev_info structure in the abbrev hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
name|lookup_abbrev
parameter_list|(
name|unsigned
name|int
name|number
parameter_list|,
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
parameter_list|)
block|{
name|unsigned
name|int
name|hash_number
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|hash_number
operator|=
name|number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrev
operator|=
name|abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
if|if
condition|(
name|abbrev
operator|->
name|number
operator|==
name|number
condition|)
return|return
name|abbrev
return|;
else|else
name|abbrev
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* In DWARF version 2, the description of the debugging information is    stored in a separate .debug_abbrev section.  Before we read any    dies from a section we read in all abbreviations and install them    in a hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
modifier|*
name|read_abbrevs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_uint64_t
name|offset
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
name|char
modifier|*
name|abbrev_ptr
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|cur_abbrev
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|abbrev_name
decl_stmt|;
name|unsigned
name|int
name|abbrev_form
decl_stmt|,
name|hash_number
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_abbrev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_abbrev section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stash
operator|->
name|dwarf_abbrev_size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|dwarf_abbrev_buffer
operator|=
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|NULL
argument_list|,
name|stash
operator|->
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|stash
operator|->
name|dwarf_abbrev_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Abbrev offset (%lu) greater than or equal to .debug_abbrev size (%lu)."
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
name|stash
operator|->
name|dwarf_abbrev_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
operator|*
argument_list|)
operator|*
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrevs
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|=
name|stash
operator|->
name|dwarf_abbrev_buffer
operator|+
name|offset
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Loop until we reach an abbrev number of 0.  */
while|while
condition|(
name|abbrev_number
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
argument_list|)
expr_stmt|;
name|cur_abbrev
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
comment|/* Read in abbrev header.  */
name|cur_abbrev
operator|->
name|number
operator|=
name|abbrev_number
expr_stmt|;
name|cur_abbrev
operator|->
name|tag
operator|=
operator|(
expr|enum
name|dwarf_tag
operator|)
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|cur_abbrev
operator|->
name|has_children
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* Now read in declarations.  */
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
while|while
condition|(
name|abbrev_name
condition|)
block|{
if|if
condition|(
operator|(
name|cur_abbrev
operator|->
name|num_attrs
operator|%
name|ATTR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|cur_abbrev
operator|->
name|num_attrs
operator|+
name|ATTR_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|attr_abbrev
argument_list|)
expr_stmt|;
name|cur_abbrev
operator|->
name|attrs
operator|=
name|bfd_realloc
argument_list|(
name|cur_abbrev
operator|->
name|attrs
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_abbrev
operator|->
name|attrs
condition|)
return|return
literal|0
return|;
block|}
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
index|]
operator|.
name|name
operator|=
operator|(
expr|enum
name|dwarf_attribute
operator|)
name|abbrev_name
expr_stmt|;
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
operator|++
index|]
operator|.
name|form
operator|=
operator|(
expr|enum
name|dwarf_form
operator|)
name|abbrev_form
expr_stmt|;
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
name|hash_number
operator|=
name|abbrev_number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|cur_abbrev
operator|->
name|next
operator|=
name|abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
name|abbrevs
index|[
name|hash_number
index|]
operator|=
name|cur_abbrev
expr_stmt|;
comment|/* Get next abbreviation. 	 Under Irix6 the abbreviations for a compilation unit are not 	 always properly terminated with an abbrev number of 0. 	 Exit loop if we encounter an abbreviation which we have 	 already read (which means we are about to read the abbreviations 	 for the next compile unit) or if the end of the abbreviation 	 table is reached.  */
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|abbrev_ptr
operator|-
name|stash
operator|->
name|dwarf_abbrev_buffer
argument_list|)
operator|>=
name|stash
operator|->
name|dwarf_abbrev_size
condition|)
break|break;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|abbrevs
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
return|return
name|abbrevs
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute value described by an attribute form.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_attribute_value
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|unsigned
name|form
parameter_list|,
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|attr
operator|->
name|form
operator|=
operator|(
expr|enum
name|dwarf_form
operator|)
name|form
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
comment|/* FIXME: DWARF3 draft says DW_FORM_ref_addr is offset_size.  */
case|case
name|DW_FORM_ref_addr
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_address
argument_list|(
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|unit
operator|->
name|addr_size
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data2
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_data4
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_data8
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|attr
operator|->
name|u
operator|.
name|str
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
name|attr
operator|->
name|u
operator|.
name|str
operator|=
name|read_indirect_string
argument_list|(
name|unit
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|attr
operator|->
name|u
operator|.
name|sval
operator|=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_udata
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref2
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref4
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref8
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_udata
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_indirect
case|:
name|form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|info_ptr
operator|=
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|form
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Invalid or unhandled FORM value: %u."
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute described by an abbreviated attribute.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_attribute
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|attr_abbrev
modifier|*
name|abbrev
parameter_list|,
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|char
modifier|*
name|info_ptr
parameter_list|)
block|{
name|attr
operator|->
name|name
operator|=
name|abbrev
operator|->
name|name
expr_stmt|;
name|info_ptr
operator|=
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|abbrev
operator|->
name|form
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Source line information table routines.  */
end_comment

begin_define
define|#
directive|define
name|FILE_ALLOC_CHUNK
value|5
end_define

begin_define
define|#
directive|define
name|DIR_ALLOC_CHUNK
value|5
end_define

begin_struct
struct|struct
name|line_info
block|{
name|struct
name|line_info
modifier|*
name|prev_line
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|int
name|end_sequence
decl_stmt|;
comment|/* End of (sequential) code sequence.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fileinfo
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|dir
decl_stmt|;
name|unsigned
name|int
name|time
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|line_info_table
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|num_files
decl_stmt|;
name|unsigned
name|int
name|num_dirs
decl_stmt|;
name|char
modifier|*
name|comp_dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
name|struct
name|fileinfo
modifier|*
name|files
decl_stmt|;
name|struct
name|line_info
modifier|*
name|last_line
decl_stmt|;
comment|/* largest VMA */
name|struct
name|line_info
modifier|*
name|lcl_head
decl_stmt|;
comment|/* local head; used in 'add_line_info' */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|funcinfo
block|{
name|struct
name|funcinfo
modifier|*
name|prev_func
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Adds a new entry to the line_info list in the line_info_table, ensuring    that the list is sorted.  Note that the line_info list is sorted from    highest to lowest VMA (with possible duplicates); that is,    line_info->prev_line always accesses an equal or smaller VMA.  */
end_comment

begin_function
specifier|static
name|void
name|add_line_info
parameter_list|(
name|struct
name|line_info_table
modifier|*
name|table
parameter_list|,
name|bfd_vma
name|address
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|unsigned
name|int
name|column
parameter_list|,
name|int
name|end_sequence
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|line_info
argument_list|)
decl_stmt|;
name|struct
name|line_info
modifier|*
name|info
init|=
name|bfd_alloc
argument_list|(
name|table
operator|->
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
comment|/* Find the correct location for 'info'.  Normally we will receive      new line_info data 1) in order and 2) with increasing VMAs.      However some compilers break the rules (cf. decode_line_info) and      so we include some heuristics for quickly finding the correct      location for 'info'. In particular, these heuristics optimize for      the common case in which the VMA sequence that we receive is a      list of locally sorted VMAs such as        p...z a...j  (where a< j< p< z)       Note: table->lcl_head is used to head an *actual* or *possible*      sequence within the list (such as a...j) that is not directly      headed by table->last_line       Note: we may receive duplicate entries from 'decode_line_info'.  */
while|while
condition|(
literal|1
condition|)
if|if
condition|(
operator|!
name|table
operator|->
name|last_line
operator|||
name|address
operator|>=
name|table
operator|->
name|last_line
operator|->
name|address
condition|)
block|{
comment|/* Normal case: add 'info' to the beginning of the list */
name|info
operator|->
name|prev_line
operator|=
name|table
operator|->
name|last_line
expr_stmt|;
name|table
operator|->
name|last_line
operator|=
name|info
expr_stmt|;
comment|/* lcl_head: initialize to head a *possible* sequence at the end.  */
if|if
condition|(
operator|!
name|table
operator|->
name|lcl_head
condition|)
name|table
operator|->
name|lcl_head
operator|=
name|info
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|&&
name|table
operator|->
name|lcl_head
operator|->
name|address
operator|>
name|address
condition|)
block|{
comment|/* Abnormal but easy: lcl_head is 1) at the *end* of the line 	   list and 2) the head of 'info'.  */
name|info
operator|->
name|prev_line
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|=
name|info
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|&&
name|table
operator|->
name|lcl_head
operator|->
name|address
operator|>
name|address
operator|&&
name|address
operator|>=
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|->
name|address
condition|)
block|{
comment|/* Abnormal but easy: lcl_head is 1) in the *middle* of the line 	   list and 2) the head of 'info'.  */
name|info
operator|->
name|prev_line
operator|=
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
expr_stmt|;
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|=
name|info
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid 	   heads for 'info'.  Reset 'lcl_head' and repeat.  */
name|struct
name|line_info
modifier|*
name|li2
init|=
name|table
operator|->
name|last_line
decl_stmt|;
comment|/* always non-NULL */
name|struct
name|line_info
modifier|*
name|li1
init|=
name|li2
operator|->
name|prev_line
decl_stmt|;
while|while
condition|(
name|li1
condition|)
block|{
if|if
condition|(
name|li2
operator|->
name|address
operator|>
name|address
operator|&&
name|address
operator|>=
name|li1
operator|->
name|address
condition|)
break|break;
name|li2
operator|=
name|li1
expr_stmt|;
comment|/* always non-NULL */
name|li1
operator|=
name|li1
operator|->
name|prev_line
expr_stmt|;
block|}
name|table
operator|->
name|lcl_head
operator|=
name|li2
expr_stmt|;
block|}
comment|/* Set member data of 'info'.  */
name|info
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|info
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|info
operator|->
name|column
operator|=
name|column
expr_stmt|;
name|info
operator|->
name|end_sequence
operator|=
name|end_sequence
expr_stmt|;
if|if
condition|(
name|filename
operator|&&
name|filename
index|[
literal|0
index|]
condition|)
block|{
name|info
operator|->
name|filename
operator|=
name|bfd_alloc
argument_list|(
name|table
operator|->
name|abfd
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|filename
condition|)
name|strcpy
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|info
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract a fully qualified filename from a line info table.    The returned string has been malloc'ed and it is the caller's    responsibility to free it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|concat_filename
parameter_list|(
name|struct
name|line_info_table
modifier|*
name|table
parameter_list|,
name|unsigned
name|int
name|file
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|file
operator|-
literal|1
operator|>=
name|table
operator|->
name|num_files
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: mangled line number section (bad file number)."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
literal|"<unknown>"
argument_list|)
return|;
block|}
name|filename
operator|=
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|char
modifier|*
name|dirname
init|=
operator|(
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
condition|?
name|table
operator|->
name|dirs
index|[
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
operator|-
literal|1
index|]
else|:
name|table
operator|->
name|comp_dir
operator|)
decl_stmt|;
comment|/* Not all tools set DW_AT_comp_dir, so dirname may be unknown. 	 The best we can do is return the filename part.  */
if|if
condition|(
name|dirname
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
block|}
return|return
name|strdup
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arange_add
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_vma
name|low_pc
parameter_list|,
name|bfd_vma
name|high_pc
parameter_list|)
block|{
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
comment|/* First see if we can cheaply extend an existing range.  */
name|arange
operator|=
operator|&
name|unit
operator|->
name|arange
expr_stmt|;
do|do
block|{
if|if
condition|(
name|low_pc
operator|==
name|arange
operator|->
name|high
condition|)
block|{
name|arange
operator|->
name|high
operator|=
name|high_pc
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|high_pc
operator|==
name|arange
operator|->
name|low
condition|)
block|{
name|arange
operator|->
name|low
operator|=
name|low_pc
expr_stmt|;
return|return;
block|}
name|arange
operator|=
name|arange
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|arange
condition|)
do|;
if|if
condition|(
name|unit
operator|->
name|arange
operator|.
name|high
operator|==
literal|0
condition|)
block|{
comment|/* This is the first address range: store it in unit->arange.  */
name|unit
operator|->
name|arange
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|unit
operator|->
name|arange
operator|.
name|low
operator|=
name|low_pc
expr_stmt|;
name|unit
operator|->
name|arange
operator|.
name|high
operator|=
name|high_pc
expr_stmt|;
return|return;
block|}
comment|/* Need to allocate a new arange and insert it into the arange list.  */
name|arange
operator|=
name|bfd_zalloc
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arange
argument_list|)
argument_list|)
expr_stmt|;
name|arange
operator|->
name|low
operator|=
name|low_pc
expr_stmt|;
name|arange
operator|->
name|high
operator|=
name|high_pc
expr_stmt|;
name|arange
operator|->
name|next
operator|=
name|unit
operator|->
name|arange
operator|.
name|next
expr_stmt|;
name|unit
operator|->
name|arange
operator|.
name|next
operator|=
name|arange
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the line number information for UNIT.  */
end_comment

begin_function
specifier|static
name|struct
name|line_info_table
modifier|*
name|decode_line_info
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|struct
name|line_info_table
modifier|*
name|table
decl_stmt|;
name|char
modifier|*
name|line_ptr
decl_stmt|;
name|char
modifier|*
name|line_end
decl_stmt|;
name|struct
name|line_head
name|lh
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|bytes_read
decl_stmt|,
name|offset_size
decl_stmt|;
name|char
modifier|*
name|cur_file
decl_stmt|,
modifier|*
name|cur_dir
decl_stmt|;
name|unsigned
name|char
name|op_code
decl_stmt|,
name|extended_op
decl_stmt|,
name|adj_opcode
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_line_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_line"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_line section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stash
operator|->
name|dwarf_line_size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|dwarf_line_buffer
operator|=
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|NULL
argument_list|,
name|stash
operator|->
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_line_buffer
condition|)
return|return
literal|0
return|;
block|}
comment|/* It is possible to get a bad value for the line_offset.  Validate      it here so that we won't get a segfault below.  */
if|if
condition|(
name|unit
operator|->
name|line_offset
operator|>=
name|stash
operator|->
name|dwarf_line_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Line offset (%lu) greater than or equal to .debug_line size (%lu)."
argument_list|)
argument_list|,
name|unit
operator|->
name|line_offset
argument_list|,
name|stash
operator|->
name|dwarf_line_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|line_info_table
argument_list|)
expr_stmt|;
name|table
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|table
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|table
operator|->
name|comp_dir
operator|=
name|unit
operator|->
name|comp_dir
expr_stmt|;
name|table
operator|->
name|num_files
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|num_dirs
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|dirs
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|last_line
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|lcl_head
operator|=
name|NULL
expr_stmt|;
name|line_ptr
operator|=
name|stash
operator|->
name|dwarf_line_buffer
operator|+
name|unit
operator|->
name|line_offset
expr_stmt|;
comment|/* Read in the prologue.  */
name|lh
operator|.
name|total_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|4
expr_stmt|;
name|offset_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|lh
operator|.
name|total_length
operator|==
literal|0xffffffff
condition|)
block|{
name|lh
operator|.
name|total_length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lh
operator|.
name|total_length
operator|==
literal|0
operator|&&
name|unit
operator|->
name|addr_size
operator|==
literal|8
condition|)
block|{
comment|/* Handle (non-standard) 64-bit DWARF2 formats.  */
name|lh
operator|.
name|total_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|4
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
block|}
name|line_end
operator|=
name|line_ptr
operator|+
name|lh
operator|.
name|total_length
expr_stmt|;
name|lh
operator|.
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|offset_size
operator|==
literal|4
condition|)
name|lh
operator|.
name|prologue_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
else|else
name|lh
operator|.
name|prologue_length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|offset_size
expr_stmt|;
name|lh
operator|.
name|minimum_instruction_length
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|default_is_stmt
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_base
operator|=
name|read_1_signed_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_range
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|opcode_base
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|amt
operator|=
name|lh
operator|.
name|opcode_base
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lh
operator|.
name|opcode_base
condition|;
operator|++
name|i
control|)
block|{
name|lh
operator|.
name|standard_opcode_lengths
index|[
name|i
index|]
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Read directory table.  */
while|while
condition|(
operator|(
name|cur_dir
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_dirs
operator|%
name|DIR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|table
operator|->
name|num_dirs
operator|+
name|DIR_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|table
operator|->
name|dirs
operator|=
name|bfd_realloc
argument_list|(
name|table
operator|->
name|dirs
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|dirs
condition|)
return|return
literal|0
return|;
block|}
name|table
operator|->
name|dirs
index|[
name|table
operator|->
name|num_dirs
operator|++
index|]
operator|=
name|cur_dir
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read file name table.  */
while|while
condition|(
operator|(
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|table
operator|->
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|bfd_realloc
argument_list|(
name|table
operator|->
name|files
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|files
condition|)
return|return
literal|0
return|;
block|}
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|num_files
operator|++
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read the statement sequences until there's nothing left.  */
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
comment|/* State machine registers.  */
name|bfd_vma
name|address
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|table
operator|->
name|num_files
condition|?
name|concat_filename
argument_list|(
name|table
argument_list|,
literal|1
argument_list|)
else|:
name|NULL
decl_stmt|;
name|unsigned
name|int
name|line
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|column
init|=
literal|0
decl_stmt|;
name|int
name|is_stmt
init|=
name|lh
operator|.
name|default_is_stmt
decl_stmt|;
name|int
name|basic_block
init|=
literal|0
decl_stmt|;
name|int
name|end_sequence
init|=
literal|0
decl_stmt|;
comment|/* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some 	 compilers generate address sequences that are wildly out of 	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler 	 for ia64-Linux).  Thus, to determine the low and high 	 address, we must compare on every DW_LNS_copy, etc.  */
name|bfd_vma
name|low_pc
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|high_pc
init|=
literal|0
decl_stmt|;
comment|/* Decode the table.  */
while|while
condition|(
operator|!
name|end_sequence
condition|)
block|{
name|op_code
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|op_code
operator|>=
name|lh
operator|.
name|opcode_base
condition|)
block|{
comment|/* Special operand.  */
name|adj_opcode
operator|=
name|op_code
operator|-
name|lh
operator|.
name|opcode_base
expr_stmt|;
name|address
operator|+=
operator|(
name|adj_opcode
operator|/
name|lh
operator|.
name|line_range
operator|)
operator|*
name|lh
operator|.
name|minimum_instruction_length
expr_stmt|;
name|line
operator|+=
name|lh
operator|.
name|line_base
operator|+
operator|(
name|adj_opcode
operator|%
name|lh
operator|.
name|line_range
operator|)
expr_stmt|;
comment|/* Append row to matrix using current values.  */
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|low_pc
operator|==
literal|0
operator|||
name|address
operator|<
name|low_pc
condition|)
name|low_pc
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|>
name|high_pc
condition|)
name|high_pc
operator|=
name|address
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNS_extended_op
case|:
comment|/* Ignore length.  */
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|extended_op
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|extended_op
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|end_sequence
operator|=
literal|1
expr_stmt|;
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|end_sequence
argument_list|)
expr_stmt|;
if|if
condition|(
name|low_pc
operator|==
literal|0
operator|||
name|address
operator|<
name|low_pc
condition|)
name|low_pc
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|>
name|high_pc
condition|)
name|high_pc
operator|=
name|address
expr_stmt|;
name|arange_add
argument_list|(
name|unit
argument_list|,
name|low_pc
argument_list|,
name|high_pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|address
operator|=
name|read_address
argument_list|(
name|unit
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|unit
operator|->
name|addr_size
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|amt
operator|=
name|table
operator|->
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|bfd_realloc
argument_list|(
name|table
operator|->
name|files
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|files
condition|)
return|return
literal|0
return|;
block|}
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|num_files
operator|++
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: mangled line number section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|DW_LNS_copy
case|:
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|low_pc
operator|==
literal|0
operator|||
name|address
operator|<
name|low_pc
condition|)
name|low_pc
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|>
name|high_pc
condition|)
name|high_pc
operator|=
name|address
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|address
operator|+=
name|lh
operator|.
name|minimum_instruction_length
operator|*
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|line
operator|+=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
block|{
name|unsigned
name|int
name|file
decl_stmt|;
comment|/* The file and directory tables are 0 		   based, the references are 1 based.  */
name|file
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|concat_filename
argument_list|(
name|table
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DW_LNS_set_column
case|:
name|column
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|is_stmt
operator|=
operator|(
operator|!
name|is_stmt
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
name|basic_block
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_LNS_const_add_pc
case|:
name|address
operator|+=
name|lh
operator|.
name|minimum_instruction_length
operator|*
operator|(
operator|(
literal|255
operator|-
name|lh
operator|.
name|opcode_base
operator|)
operator|/
name|lh
operator|.
name|line_range
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|address
operator|+=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
block|{
name|int
name|i
decl_stmt|;
comment|/* Unknown standard opcode, ignore it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lh
operator|.
name|standard_opcode_lengths
index|[
name|op_code
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* If ADDR is within TABLE set the output parameters and return TRUE,    otherwise return FALSE.  The output parameters, FILENAME_PTR and    LINENUMBER_PTR, are pointers to the objects to be filled in.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lookup_address_in_line_info_table
parameter_list|(
name|struct
name|line_info_table
modifier|*
name|table
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|struct
name|funcinfo
modifier|*
name|function
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|)
block|{
comment|/* Note: table->last_line should be a descendingly sorted list. */
name|struct
name|line_info
modifier|*
name|next_line
init|=
name|table
operator|->
name|last_line
decl_stmt|;
name|struct
name|line_info
modifier|*
name|each_line
init|=
name|NULL
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|next_line
condition|)
return|return
name|FALSE
return|;
name|each_line
operator|=
name|next_line
operator|->
name|prev_line
expr_stmt|;
comment|/* Check for large addresses */
if|if
condition|(
name|addr
operator|>
name|next_line
operator|->
name|address
condition|)
name|each_line
operator|=
name|NULL
expr_stmt|;
comment|/* ensure we skip over the normal case */
comment|/* Normal case: search the list; save  */
while|while
condition|(
name|each_line
operator|&&
name|next_line
condition|)
block|{
comment|/* If we have an address match, save this info.  This allows us 	 to return as good as results as possible for strange debugging 	 info.  */
name|bfd_boolean
name|addr_match
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|each_line
operator|->
name|address
operator|<=
name|addr
operator|&&
name|addr
operator|<=
name|next_line
operator|->
name|address
condition|)
block|{
name|addr_match
operator|=
name|TRUE
expr_stmt|;
comment|/* If this line appears to span functions, and addr is in the 	     later function, return the first line of that function instead 	     of the last line of the earlier one.  This check is for GCC 	     2.95, which emits the first line number for a function late.  */
if|if
condition|(
name|function
operator|!=
name|NULL
operator|&&
name|each_line
operator|->
name|address
operator|<
name|function
operator|->
name|low
operator|&&
name|next_line
operator|->
name|address
operator|>
name|function
operator|->
name|low
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|next_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|next_line
operator|->
name|line
expr_stmt|;
block|}
else|else
block|{
operator|*
name|filename_ptr
operator|=
name|each_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|each_line
operator|->
name|line
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addr_match
operator|&&
operator|!
name|each_line
operator|->
name|end_sequence
condition|)
return|return
name|TRUE
return|;
comment|/* we have definitely found what we want */
name|next_line
operator|=
name|each_line
expr_stmt|;
name|each_line
operator|=
name|each_line
operator|->
name|prev_line
expr_stmt|;
block|}
comment|/* At this point each_line is NULL but next_line is not.  If we found      a candidate end-of-sequence point in the loop above, we can return      that (compatibility with a bug in the Intel compiler); otherwise,      assuming that we found the containing function for this address in      this compilation unit, return the first line we have a number for      (compatibility with GCC 2.95).  */
if|if
condition|(
operator|*
name|filename_ptr
operator|==
name|NULL
operator|&&
name|function
operator|!=
name|NULL
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|next_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|next_line
operator|->
name|line
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Function table functions.  */
end_comment

begin_comment
comment|/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return TRUE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lookup_address_in_function_table
parameter_list|(
name|struct
name|funcinfo
modifier|*
name|table
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|struct
name|funcinfo
modifier|*
modifier|*
name|function_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|)
block|{
name|struct
name|funcinfo
modifier|*
name|each_func
decl_stmt|;
for|for
control|(
name|each_func
operator|=
name|table
init|;
name|each_func
condition|;
name|each_func
operator|=
name|each_func
operator|->
name|prev_func
control|)
block|{
if|if
condition|(
name|addr
operator|>=
name|each_func
operator|->
name|low
operator|&&
name|addr
operator|<
name|each_func
operator|->
name|high
condition|)
block|{
operator|*
name|functionname_ptr
operator|=
name|each_func
operator|->
name|name
expr_stmt|;
operator|*
name|function_ptr
operator|=
name|each_func
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* DWARF2 Compilation unit functions.  */
end_comment

begin_comment
comment|/* Scan over each die in a comp. unit looking for functions to add    to the function table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|scan_unit_for_functions
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|char
modifier|*
name|info_ptr
init|=
name|unit
operator|->
name|first_child_die_ptr
decl_stmt|;
name|int
name|nesting_level
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|nesting_level
condition|)
block|{
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|func
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
name|nesting_level
operator|--
expr_stmt|;
continue|continue;
block|}
name|abbrev
operator|=
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|unit
operator|->
name|abbrevs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %u."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|abbrev
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|funcinfo
argument_list|)
decl_stmt|;
name|func
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|func
operator|->
name|prev_func
operator|=
name|unit
operator|->
name|function_table
expr_stmt|;
name|unit
operator|->
name|function_table
operator|=
name|func
expr_stmt|;
block|}
else|else
name|func
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
comment|/* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
if|if
condition|(
name|func
operator|->
name|name
operator|==
name|NULL
condition|)
name|func
operator|->
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_MIPS_linkage_name
case|:
name|func
operator|->
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|func
operator|->
name|low
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|func
operator|->
name|high
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|abbrev
operator|->
name|has_children
condition|)
name|nesting_level
operator|++
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Parse a DWARF2 compilation unit starting at INFO_PTR.  This    includes the compilation unit header that proceeds the DIE's, but    does not include the length field that precedes each compilation    unit header.  END_PTR points one past the end of this comp unit.    OFFSET_SIZE is the size of DWARF2 offsets (either 4 or 8 bytes).     This routine does not read the whole compilation unit; only enough    to get to the line number information for the compilation unit.  */
end_comment

begin_function
specifier|static
name|struct
name|comp_unit
modifier|*
name|parse_comp_unit
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|,
name|bfd_vma
name|unit_length
parameter_list|,
name|unsigned
name|int
name|offset_size
parameter_list|)
block|{
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|unsigned
name|int
name|version
decl_stmt|;
name|bfd_uint64_t
name|abbrev_offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|addr_size
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|char
modifier|*
name|info_ptr
init|=
name|stash
operator|->
name|info_ptr
decl_stmt|;
name|char
modifier|*
name|end_ptr
init|=
name|info_ptr
operator|+
name|unit_length
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|offset_size
operator|==
literal|4
operator|||
name|offset_size
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_size
operator|==
literal|4
condition|)
name|abbrev_offset
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
else|else
name|abbrev_offset
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|offset_size
expr_stmt|;
name|addr_size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|2
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: found dwarf version '%u', this reader only handles version 2 information."
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addr_size
operator|>
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: found address size '%u', this reader can not handle sizes greater than '%u'."
argument_list|)
argument_list|,
name|addr_size
argument_list|,
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addr_size
operator|!=
literal|2
operator|&&
name|addr_size
operator|!=
literal|4
operator|&&
name|addr_size
operator|!=
literal|8
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Dwarf Error: found address size '%u', this reader can only handle address sizes '2', '4' and '8'."
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Read the abbrevs for this compilation unit into a table.  */
name|abbrevs
operator|=
name|read_abbrevs
argument_list|(
name|abfd
argument_list|,
name|abbrev_offset
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrevs
condition|)
return|return
literal|0
return|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Bad abbrev number: %u."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|abbrev
operator|=
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|abbrevs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %u."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|comp_unit
argument_list|)
expr_stmt|;
name|unit
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|unit
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|unit
operator|->
name|addr_size
operator|=
name|addr_size
expr_stmt|;
name|unit
operator|->
name|offset_size
operator|=
name|offset_size
expr_stmt|;
name|unit
operator|->
name|abbrevs
operator|=
name|abbrevs
expr_stmt|;
name|unit
operator|->
name|end_ptr
operator|=
name|end_ptr
expr_stmt|;
name|unit
operator|->
name|stash
operator|=
name|stash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Store the data if it is of an attribute we want to keep in a 	 partial symbol table.  */
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_stmt_list
case|:
name|unit
operator|->
name|stmtlist
operator|=
literal|1
expr_stmt|;
name|unit
operator|->
name|line_offset
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_name
case|:
name|unit
operator|->
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|unit
operator|->
name|arange
operator|.
name|low
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|unit
operator|->
name|arange
operator|.
name|high
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_comp_dir
case|:
block|{
name|char
modifier|*
name|comp_dir
init|=
name|attr
operator|.
name|u
operator|.
name|str
decl_stmt|;
if|if
condition|(
name|comp_dir
condition|)
block|{
comment|/* Irix 6.2 native cc prepends<machine>.: to the compilation 		   directory, get rid of it.  */
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|comp_dir
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
operator|!=
name|comp_dir
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|comp_dir
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|unit
operator|->
name|comp_dir
operator|=
name|comp_dir
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
name|unit
operator|->
name|first_child_die_ptr
operator|=
name|info_ptr
expr_stmt|;
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if UNIT contains the address given by ADDR.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|comp_unit_contains_address
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|error
condition|)
return|return
name|FALSE
return|;
name|arange
operator|=
operator|&
name|unit
operator|->
name|arange
expr_stmt|;
do|do
block|{
if|if
condition|(
name|addr
operator|>=
name|arange
operator|->
name|low
operator|&&
name|addr
operator|<
name|arange
operator|->
name|high
condition|)
return|return
name|TRUE
return|;
name|arange
operator|=
name|arange
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|arange
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* If UNIT contains ADDR, set the output parameters to the values for    the line containing ADDR.  The output parameters, FILENAME_PTR,    FUNCTIONNAME_PTR, and LINENUMBER_PTR, are pointers to the objects    to be filled in.     Return TRUE if UNIT contains ADDR, and no errors were encountered;    FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|comp_unit_find_nearest_line
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|bfd_boolean
name|line_p
decl_stmt|;
name|bfd_boolean
name|func_p
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|function
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|error
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
if|if
condition|(
operator|!
name|unit
operator|->
name|stmtlist
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|unit
operator|->
name|line_table
operator|=
name|decode_line_info
argument_list|(
name|unit
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|unit
operator|->
name|first_child_die_ptr
operator|<
name|unit
operator|->
name|end_ptr
operator|&&
operator|!
name|scan_unit_for_functions
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|function
operator|=
name|NULL
expr_stmt|;
name|func_p
operator|=
name|lookup_address_in_function_table
argument_list|(
name|unit
operator|->
name|function_table
argument_list|,
name|addr
argument_list|,
operator|&
name|function
argument_list|,
name|functionname_ptr
argument_list|)
expr_stmt|;
name|line_p
operator|=
name|lookup_address_in_line_info_table
argument_list|(
name|unit
operator|->
name|line_table
argument_list|,
name|addr
argument_list|,
name|function
argument_list|,
name|filename_ptr
argument_list|,
name|linenumber_ptr
argument_list|)
expr_stmt|;
return|return
name|line_p
operator|||
name|func_p
return|;
block|}
end_function

begin_comment
comment|/* Locate a section in a BFD containing debugging info.  The search starts    from the section after AFTER_SEC, or from the first section in the BFD if    AFTER_SEC is NULL.  The search works by examining the names of the    sections.  There are two permissiable names.  The first is .debug_info.    This is the standard DWARF2 name.  The second is a prefix .gnu.linkonce.wi.    This is a variation on the .debug_info section which has a checksum    describing the contents appended onto the name.  This allows the linker to    identify and discard duplicate debugging sections for different    compilation units.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_DEBUG_INFO
value|".debug_info"
end_define

begin_define
define|#
directive|define
name|GNU_LINKONCE_INFO
value|".gnu.linkonce.wi."
end_define

begin_function
specifier|static
name|asection
modifier|*
name|find_debug_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|after_sec
parameter_list|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|after_sec
condition|)
name|msec
operator|=
name|after_sec
operator|->
name|next
expr_stmt|;
else|else
name|msec
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|msec
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|msec
operator|->
name|name
argument_list|,
name|DWARF2_DEBUG_INFO
argument_list|)
operator|==
literal|0
condition|)
return|return
name|msec
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|msec
operator|->
name|name
argument_list|,
name|GNU_LINKONCE_INFO
argument_list|,
name|strlen
argument_list|(
name|GNU_LINKONCE_INFO
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|msec
return|;
name|msec
operator|=
name|msec
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The DWARF2 version of find_nearest line.  Return TRUE if the line    is found without error.  ADDR_SIZE is the number of bytes in the    initial .debug_info length field and in the abbreviation offset.    You may use zero to indicate that the default value should be    used.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_dwarf2_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|unsigned
name|int
name|addr_size
parameter_list|,
name|void
modifier|*
modifier|*
name|pinfo
parameter_list|)
block|{
comment|/* Read each compilation unit from the section .debug_info, and check      to see if it contains the address we are searching for.  If yes,      lookup the address, and return the line number info.  If no, go      on to the next compilation unit.       We keep a list of all the previously read compilation units, and      a pointer to the next un-read compilation unit.  Check the      previously read units before reading more.  */
name|struct
name|dwarf2_debug
modifier|*
name|stash
init|=
operator|*
name|pinfo
decl_stmt|;
comment|/* What address are we looking for?  */
name|bfd_vma
name|addr
init|=
name|offset
operator|+
name|section
operator|->
name|vma
decl_stmt|;
name|struct
name|comp_unit
modifier|*
name|each
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
literal|0
expr_stmt|;
comment|/* The DWARF2 spec says that the initial length field, and the      offset of the abbreviation table, should both be 4-byte values.      However, some compilers do things differently.  */
if|if
condition|(
name|addr_size
operator|==
literal|0
condition|)
name|addr_size
operator|=
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|addr_size
operator|==
literal|4
operator|||
name|addr_size
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
block|{
name|bfd_size_type
name|total_size
decl_stmt|;
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_debug
argument_list|)
decl_stmt|;
name|stash
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
return|return
name|FALSE
return|;
operator|*
name|pinfo
operator|=
name|stash
expr_stmt|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
comment|/* No dwarf2 info.  Note that at this point the stash 	   has been allocated, but contains zeros, this lets 	   future calls to this function fail quicker.  */
return|return
name|FALSE
return|;
comment|/* There can be more than one DWARF2 info section in a BFD these days. 	 Read them all in and produce one large stash.  We do this in two 	 passes - in the first pass we just accumulate the section sizes. 	 In the second pass we read in the section's contents.  The allows 	 us to avoid reallocing the data as we add sections to the stash.  */
for|for
control|(
name|total_size
operator|=
literal|0
init|;
name|msec
condition|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|)
control|)
name|total_size
operator|+=
name|msec
operator|->
name|_raw_size
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stash
operator|->
name|info_ptr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|stash
operator|->
name|info_ptr_end
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
for|for
control|(
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
init|;
name|msec
condition|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|)
control|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|start
decl_stmt|;
name|size
operator|=
name|msec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
continue|continue;
name|start
operator|=
name|stash
operator|->
name|info_ptr_end
operator|-
name|stash
operator|->
name|info_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
name|start
argument_list|,
name|symbols
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|stash
operator|->
name|info_ptr_end
operator|=
name|stash
operator|->
name|info_ptr
operator|+
name|start
operator|+
name|size
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|stash
operator|->
name|info_ptr_end
operator|==
name|stash
operator|->
name|info_ptr
operator|+
name|total_size
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec_info_ptr
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
name|stash
operator|->
name|syms
operator|=
name|symbols
expr_stmt|;
block|}
comment|/* A null info_ptr indicates that there is no dwarf2 info      (or that an error occured while setting up the stash).  */
if|if
condition|(
operator|!
name|stash
operator|->
name|info_ptr
condition|)
return|return
name|FALSE
return|;
comment|/* Check the previously read comp. units first.  */
for|for
control|(
name|each
operator|=
name|stash
operator|->
name|all_comp_units
init|;
name|each
condition|;
name|each
operator|=
name|each
operator|->
name|next_unit
control|)
if|if
condition|(
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
return|;
comment|/* Read each remaining comp. units checking each as they are read.  */
while|while
condition|(
name|stash
operator|->
name|info_ptr
operator|<
name|stash
operator|->
name|info_ptr_end
condition|)
block|{
name|bfd_vma
name|length
decl_stmt|;
name|bfd_boolean
name|found
decl_stmt|;
name|unsigned
name|int
name|offset_size
init|=
name|addr_size
decl_stmt|;
name|length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* A 0xffffff length is the DWARF3 way of indicating we use 	 64-bit offsets, instead of 32-bit offsets.  */
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|offset_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
literal|12
expr_stmt|;
block|}
comment|/* A zero length is the IRIX way of indicating 64-bit offsets, 	 mostly because the 64-bit length will generally fit in 32 	 bits, and the endianness helps.  */
elseif|else
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|offset_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* In the absence of the hints above, we assume addr_size-sized 	 offsets, for backward-compatibility with pre-DWARF3 64-bit 	 platforms.  */
elseif|else
if|if
condition|(
name|addr_size
operator|==
literal|8
condition|)
block|{
name|length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|info_ptr
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
literal|8
expr_stmt|;
block|}
else|else
name|stash
operator|->
name|info_ptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|each
operator|=
name|parse_comp_unit
argument_list|(
name|abfd
argument_list|,
name|stash
argument_list|,
name|length
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
name|length
expr_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|stash
operator|->
name|info_ptr
operator|-
name|stash
operator|->
name|sec_info_ptr
argument_list|)
operator|==
name|stash
operator|->
name|sec
operator|->
name|_raw_size
condition|)
block|{
name|stash
operator|->
name|sec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|stash
operator|->
name|sec
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec_info_ptr
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
block|}
if|if
condition|(
name|each
condition|)
block|{
name|each
operator|->
name|next_unit
operator|=
name|stash
operator|->
name|all_comp_units
expr_stmt|;
name|stash
operator|->
name|all_comp_units
operator|=
name|each
expr_stmt|;
comment|/* DW_AT_low_pc and DW_AT_high_pc are optional for 		 compilation units.  If we don't have them (i.e., 		 unit->high == 0), we need to consult the line info 		 table to see if a compilation unit contains the given 		 address.  */
if|if
condition|(
name|each
operator|->
name|arange
operator|.
name|high
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
return|;
block|}
else|else
block|{
name|found
operator|=
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|TRUE
return|;
block|}
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

end_unit

