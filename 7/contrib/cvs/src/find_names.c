begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1986-2005 The Free Software Foundation, Inc.  *  * Portions Copyright (C) 1998-2005 Derek Price, Ximbiot<http://ximbiot.com>,  *                                  and others.  *  * Portions Copyright (C) 1992, Brian Berliner and Jeff Polk  * Portions Copyright (C) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Find Names  *   * Finds all the pertinent file names, both from the administration and from the  * repository  *   * Find Dirs  *   * Finds all pertinent sub-directories of the checked out instantiation and the  * repository (and optionally the attic)  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|find_dirs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|List
operator|*
name|list
operator|,
name|int
name|checkadm
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_rcs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|List
operator|*
name|list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_subdir_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|register_subdir_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * add the key from entry on entries list to the files list  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|add_entries_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_entries_proc
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Node
modifier|*
name|fnode
decl_stmt|;
name|List
modifier|*
name|filelist
init|=
name|closure
decl_stmt|;
name|Entnode
modifier|*
name|entnode
init|=
name|node
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|entnode
operator|->
name|type
operator|!=
name|ENT_FILE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fnode
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|fnode
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|fnode
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|filelist
argument_list|,
name|fnode
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|fnode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find files in the repository and/or working directory.  On error,    may either print a nonfatal error and return NULL, or just give    a fatal error.  On success, return non-NULL (even if it is an empty    list).  */
end_comment

begin_function
name|List
modifier|*
name|Find_Names
parameter_list|(
name|repository
parameter_list|,
name|which
parameter_list|,
name|aflag
parameter_list|,
name|optentries
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|List
modifier|*
modifier|*
name|optentries
decl_stmt|;
block|{
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|files
decl_stmt|;
comment|/* make a list for the files */
name|files
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* look at entries (if necessary) */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
block|{
comment|/* parse the entries file (if it exists) */
name|entries
operator|=
name|Entries_Open
argument_list|(
name|aflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|!=
name|NULL
condition|)
block|{
comment|/* walk the entries file adding elements to the files list */
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|entries
argument_list|,
name|add_entries_proc
argument_list|,
name|files
argument_list|)
expr_stmt|;
comment|/* if our caller wanted the entries list, return it; else free it */
if|if
condition|(
name|optentries
operator|!=
name|NULL
condition|)
operator|*
name|optentries
operator|=
name|entries
expr_stmt|;
else|else
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|which
operator|&
name|W_REPOS
operator|)
operator|&&
name|repository
operator|&&
operator|!
name|isreadable
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
condition|)
block|{
comment|/* search the repository */
if|if
condition|(
name|find_rcs
argument_list|(
name|repository
argument_list|,
name|files
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* search the attic too */
if|if
condition|(
name|which
operator|&
name|W_ATTIC
condition|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dir
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_rcs
argument_list|(
name|dir
argument_list|,
name|files
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
comment|/* For now keep this a fatal error, seems less useful 		   for access control than the case above.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* sort the list into alphabetical order and return it */
name|sortlist
argument_list|(
name|files
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|files
operator|)
return|;
name|error_exit
label|:
name|dellist
argument_list|(
operator|&
name|files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Add an entry from the subdirs list to the directories list.  This  * is called via walklist.  */
end_comment

begin_function
specifier|static
name|int
name|add_subdir_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|List
modifier|*
name|dirlist
init|=
name|closure
decl_stmt|;
name|Entnode
modifier|*
name|entnode
init|=
name|p
operator|->
name|data
decl_stmt|;
name|Node
modifier|*
name|dnode
decl_stmt|;
if|if
condition|(
name|entnode
operator|->
name|type
operator|!=
name|ENT_SUBDIR
condition|)
return|return
literal|0
return|;
name|dnode
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|dnode
operator|->
name|type
operator|=
name|DIRS
expr_stmt|;
name|dnode
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|entnode
operator|->
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|dirlist
argument_list|,
name|dnode
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|dnode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Register a subdirectory.  This is called via walklist.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|register_subdir_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|List
modifier|*
name|entries
init|=
operator|(
name|List
operator|*
operator|)
name|closure
decl_stmt|;
name|Subdir_Register
argument_list|(
name|entries
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * create a list of directories to traverse from the current directory  */
end_comment

begin_function
name|List
modifier|*
name|Find_Directories
parameter_list|(
name|repository
parameter_list|,
name|which
parameter_list|,
name|entries
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|int
name|which
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|List
modifier|*
name|dirlist
decl_stmt|;
comment|/* make a list for the directories */
name|dirlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* find the local ones */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
block|{
name|List
modifier|*
name|tmpentries
decl_stmt|;
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
comment|/* Look through the Entries file.  */
if|if
condition|(
name|entries
operator|!=
name|NULL
condition|)
name|tmpentries
operator|=
name|entries
expr_stmt|;
elseif|else
if|if
condition|(
name|isfile
argument_list|(
name|CVSADM_ENT
argument_list|)
condition|)
name|tmpentries
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|tmpentries
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tmpentries
operator|!=
name|NULL
condition|)
name|sdtp
operator|=
name|tmpentries
operator|->
name|list
operator|->
name|data
expr_stmt|;
comment|/* If we do have an entries list, then if sdtp is NULL, or if            sdtp->subdirs is nonzero, all subdirectory information is            recorded in the entries list.  */
if|if
condition|(
name|tmpentries
operator|!=
name|NULL
operator|&&
operator|(
name|sdtp
operator|==
name|NULL
operator|||
name|sdtp
operator|->
name|subdirs
operator|)
condition|)
name|walklist
argument_list|(
name|tmpentries
argument_list|,
name|add_subdir_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dirlist
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This is an old working directory, in which subdirectory                information is not recorded in the Entries file.  Find                the subdirectories the hard way, and, if possible, add                it to the Entries file for next time.  */
comment|/* FIXME-maybe: find_dirs is bogus for this usage because 	       it skips CVSATTIC and CVSLCK directories--those names 	       should be special only in the repository.  However, in 	       the interests of not perturbing this code, we probably 	       should leave well enough alone unless we want to write 	       a sanity.sh test case (which would operate by manually 	       hacking on the CVS/Entries file).  */
if|if
condition|(
name|find_dirs
argument_list|(
literal|"."
argument_list|,
name|dirlist
argument_list|,
literal|1
argument_list|,
name|tmpentries
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open current directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpentries
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|list_isempty
argument_list|(
name|dirlist
argument_list|)
condition|)
name|walklist
argument_list|(
name|dirlist
argument_list|,
name|register_subdir_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tmpentries
argument_list|)
expr_stmt|;
else|else
name|Subdirs_Known
argument_list|(
name|tmpentries
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entries
operator|==
name|NULL
operator|&&
name|tmpentries
operator|!=
name|NULL
condition|)
name|Entries_Close
argument_list|(
name|tmpentries
argument_list|)
expr_stmt|;
block|}
comment|/* look for sub-dirs in the repository */
if|if
condition|(
operator|(
name|which
operator|&
name|W_REPOS
operator|)
operator|&&
name|repository
condition|)
block|{
comment|/* search the repository */
if|if
condition|(
name|find_dirs
argument_list|(
name|repository
argument_list|,
name|dirlist
argument_list|,
literal|0
argument_list|,
name|entries
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* We don't need to look in the attic because directories 	   never go in the attic.  In the future, there hopefully will 	   be a better mechanism for detecting whether a directory in 	   the repository is alive or dead; it may or may not involve 	   moving directories to the attic.  */
block|}
comment|/* sort the list into alphabetical order and return it */
name|sortlist
argument_list|(
name|dirlist
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirlist
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds all the ,v files in the argument directory, and adds them to the  * files list.  Returns 0 for success and non-zero if the argument directory  * cannot be opened, in which case errno is set to indicate the error.  * In the error case LIST is left in some reasonable state (unchanged, or  * containing the files which were found before the error occurred).  */
end_comment

begin_function
specifier|static
name|int
name|find_rcs
parameter_list|(
name|dir
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* set up to read the dir */
if|if
condition|(
operator|(
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* read the dir, grabbing the ,v files */
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|CVS_READDIR
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_FNMATCH
argument_list|(
name|RCSPAT
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|comma
decl_stmt|;
name|comma
operator|=
name|strrchr
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* strip the ,v */
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds all the subdirectories of the argument dir and adds them to  * the specified list.  Sub-directories without a CVS administration  * directory are optionally ignored.  If ENTRIES is not NULL, all  * files on the list are ignored.  Returns 0 for success or 1 on  * error, in which case errno is set to indicate the error.  */
end_comment

begin_function
specifier|static
name|int
name|find_dirs
parameter_list|(
name|dir
parameter_list|,
name|list
parameter_list|,
name|checkadm
parameter_list|,
name|entries
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
name|int
name|checkadm
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|size_t
name|tmp_size
init|=
literal|0
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|int
name|skip_emptydir
init|=
literal|0
decl_stmt|;
comment|/* First figure out whether we need to skip directories named        Emptydir.  Except in the CVSNULLREPOS case, Emptydir is just        a normal directory name.  */
if|if
condition|(
name|isabsolute
argument_list|(
name|dir
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|dir
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIRSEP
argument_list|(
name|dir
index|[
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
index|]
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|dir
operator|+
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
literal|1
argument_list|,
name|CVSROOTADM
argument_list|)
operator|==
literal|0
condition|)
name|skip_emptydir
operator|=
literal|1
expr_stmt|;
comment|/* set up to read the dir */
if|if
condition|(
operator|(
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* read the dir, grabbing sub-dirs */
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|CVS_READDIR
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSATTIC
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSLCK
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSREP
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|do_it_again
goto|;
comment|/* findnode() is going to be significantly faster than stat() 	   because it involves no system calls.  That is why we bother 	   with the entries argument, and why we check this first.  */
if|if
condition|(
name|entries
operator|!=
name|NULL
operator|&&
name|findnode
argument_list|(
name|entries
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|do_it_again
goto|;
if|if
condition|(
name|skip_emptydir
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSNULLREPOS
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|do_it_again
goto|;
ifdef|#
directive|ifdef
name|DT_DIR
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_DIR
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_LNK
condition|)
goto|goto
name|do_it_again
goto|;
endif|#
directive|endif
comment|/* don't bother stating ,v files */
if|if
condition|(
name|CVS_FNMATCH
argument_list|(
name|RCSPAT
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|do_it_again
goto|;
name|expand_string
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_size
argument_list|,
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
goto|goto
name|do_it_again
goto|;
ifdef|#
directive|ifdef
name|DT_DIR
block|}
endif|#
directive|endif
comment|/* check for administration directories (if needed) */
if|if
condition|(
name|checkadm
condition|)
block|{
comment|/* blow off symbolic links to dirs in local dir */
ifdef|#
directive|ifdef
name|DT_DIR
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_DIR
condition|)
block|{
comment|/* we're either unknown or a symlink at this point */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|DT_LNK
condition|)
goto|goto
name|do_it_again
goto|;
endif|#
directive|endif
comment|/* Note that we only get here if we already set tmp 		   above.  */
if|if
condition|(
name|islink
argument_list|(
name|tmp
argument_list|)
condition|)
goto|goto
name|do_it_again
goto|;
ifdef|#
directive|ifdef
name|DT_DIR
block|}
endif|#
directive|endif
comment|/* check for new style */
name|expand_string
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_size
argument_list|,
operator|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|dir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
goto|goto
name|do_it_again
goto|;
block|}
comment|/* put it in the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|DIRS
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|do_it_again
label|:
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

