begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: name6.c,v 1.25 2000/06/26 16:44:40 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1985, 1988, 1993  * -  * Copyright (c) 1985, 1988, 1993  *    The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_comment
comment|/*  *	Atsushi Onoe<onoe@sm.sony.co.jp>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<nsswitch.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"netdb_private.h"
end_include

begin_include
include|#
directive|include
file|"res_private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAXALIASES
end_ifndef

begin_define
define|#
directive|define
name|MAXALIASES
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXADDRS
end_ifndef

begin_define
define|#
directive|define
name|MAXADDRS
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXDNAME
end_ifndef

begin_define
define|#
directive|define
name|MAXDNAME
value|1025
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|ADDRLEN
parameter_list|(
name|af
parameter_list|)
value|((af) == AF_INET6 ? sizeof(struct in6_addr) : \ 					    sizeof(struct in_addr))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ADDRLEN
parameter_list|(
name|af
parameter_list|)
value|sizeof(struct in_addr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAPADDR
parameter_list|(
name|ab
parameter_list|,
name|ina
parameter_list|)
define|\
value|do {									\ 	memcpy(&(ab)->map_inaddr, ina, sizeof(struct in_addr));		\ 	memset((ab)->map_zero, 0, sizeof((ab)->map_zero));		\ 	memset((ab)->map_one, 0xff, sizeof((ab)->map_one));		\ } while (0)
end_define

begin_define
define|#
directive|define
name|MAPADDRENABLED
parameter_list|(
name|flags
parameter_list|)
define|\
value|(((flags)& AI_V4MAPPED) || \ 	 (((flags)& AI_V4MAPPED_CFG)))
end_define

begin_union
union|union
name|inx_addr
block|{
name|struct
name|in_addr
name|in_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addr
name|in6_addr
decl_stmt|;
endif|#
directive|endif
struct|struct
block|{
name|u_char
name|mau_zero
index|[
literal|10
index|]
decl_stmt|;
name|u_char
name|mau_one
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|in_addr
name|mau_inaddr
decl_stmt|;
block|}
name|map_addr_un
struct|;
define|#
directive|define
name|map_zero
value|map_addr_un.mau_zero
define|#
directive|define
name|map_one
value|map_addr_un.mau_one
define|#
directive|define
name|map_inaddr
value|map_addr_un.mau_inaddr
block|}
union|;
end_union

begin_struct
struct|struct
name|policyqueue
block|{
name|TAILQ_ENTRY
argument_list|(
argument|policyqueue
argument_list|)
name|pc_entry
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addrpolicy
name|pc_policy
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|policyhead
argument_list|,
name|policyqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AIO_SRCFLAG_DEPRECATED
value|0x1
end_define

begin_struct
struct|struct
name|hp_order
block|{
union|union
block|{
name|struct
name|sockaddr_storage
name|aiou_ss
decl_stmt|;
name|struct
name|sockaddr
name|aiou_sa
decl_stmt|;
block|}
name|aio_src_un
union|;
define|#
directive|define
name|aio_srcsa
value|aio_src_un.aiou_sa
name|u_int32_t
name|aio_srcflag
decl_stmt|;
name|int
name|aio_srcscope
decl_stmt|;
name|int
name|aio_dstscope
decl_stmt|;
name|struct
name|policyqueue
modifier|*
name|aio_srcpolicy
decl_stmt|;
name|struct
name|policyqueue
modifier|*
name|aio_dstpolicy
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr_storage
name|aiou_ss
decl_stmt|;
name|struct
name|sockaddr
name|aiou_sa
decl_stmt|;
block|}
name|aio_un
union|;
define|#
directive|define
name|aio_sa
value|aio_un.aiou_sa
name|int
name|aio_matchlen
decl_stmt|;
name|char
modifier|*
name|aio_h_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpcopy
parameter_list|(
name|struct
name|hostent
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpaddr
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmerge
parameter_list|(
name|struct
name|hostent
modifier|*
parameter_list|,
name|struct
name|hostent
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmapv6
parameter_list|(
name|struct
name|hostent
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpsort
parameter_list|(
name|struct
name|hostent
modifier|*
parameter_list|,
name|res_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpreorder
parameter_list|(
name|struct
name|hostent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|policyqueue
modifier|*
name|match_addrselectpolicy
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_source
parameter_list|(
name|struct
name|hp_order
modifier|*
parameter_list|,
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matchlen
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_dst
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gai_addr2scopetype
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Functions defined in RFC2553  *	getipnodebyname, getipnodebyaddr, freehostent  */
end_comment

begin_function
name|struct
name|hostent
modifier|*
name|getipnodebyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
decl_stmt|;
name|res_state
name|statp
decl_stmt|;
name|u_long
name|options
decl_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|AI_ADDRCONFIG
condition|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* 		 * TODO: 		 * Note that implementation dependent test for address 		 * configuration should be done everytime called 		 * (or apropriate interval), 		 * because addresses will be dynamically assigned or deleted. 		 */
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* special case for literal address */
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|af
operator|!=
name|AF_INET6
condition|)
block|{
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|errp
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inet_aton
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|af
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|MAPADDRENABLED
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|MAPADDR
argument_list|(
operator|&
name|addrbuf
argument_list|,
operator|&
name|addrbuf
operator|.
name|in_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|errp
argument_list|)
return|;
block|}
name|statp
operator|=
name|__res_state
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|statp
operator|->
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_ninit
argument_list|(
name|statp
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|errp
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|options
operator|=
name|statp
operator|->
name|options
expr_stmt|;
name|statp
operator|->
name|options
operator|&=
operator|~
name|RES_USE_INET6
expr_stmt|;
name|hp
operator|=
name|gethostbyname2
argument_list|(
name|name
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
operator|(
operator|(
name|flags
operator|&
name|AI_ALL
operator|)
operator|||
name|hp
operator|==
name|NULL
operator|)
operator|&&
name|MAPADDRENABLED
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp2
init|=
name|gethostbyname2
argument_list|(
name|name
argument_list|,
name|AF_INET
argument_list|)
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
if|if
condition|(
name|hp2
operator|==
name|NULL
condition|)
operator|*
name|errp
operator|=
name|statp
operator|->
name|res_h_errno
expr_stmt|;
else|else
name|hp
operator|=
name|_hpmapv6
argument_list|(
name|hp2
argument_list|,
name|errp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hp2
operator|&&
name|strcmp
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
name|hp2
operator|->
name|h_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hpb
init|=
name|hp
decl_stmt|;
name|hp
operator|=
name|_hpmerge
argument_list|(
name|hpb
argument_list|,
name|hp2
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|freehostent
argument_list|(
name|hpb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
operator|*
name|errp
operator|=
name|statp
operator|->
name|res_h_errno
expr_stmt|;
name|statp
operator|->
name|options
operator|=
name|options
expr_stmt|;
return|return
name|_hpreorder
argument_list|(
name|_hpsort
argument_list|(
name|hp
argument_list|,
name|statp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|hostent
modifier|*
name|getipnodebyaddr
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|af
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|res_state
name|statp
decl_stmt|;
name|u_long
name|options
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addr
name|addrbuf
decl_stmt|;
else|#
directive|else
name|struct
name|in_addr
name|addrbuf
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|src
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|addrbuf
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|src
operator|=
operator|&
name|addrbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|src
operator|)
operator|->
name|s_addr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|src
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|/
literal|2
operator|-
literal|1
operator|)
condition|)
block|{
comment|/*XXX*/
name|memcpy
argument_list|(
operator|&
name|addrbuf
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|src
operator|=
operator|&
name|addrbuf
expr_stmt|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
operator|||
name|IN6_IS_ADDR_V4COMPAT
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
condition|)
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|src
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
expr_stmt|;
name|af
operator|=
name|AF_INET
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|statp
operator|=
name|__res_state
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|statp
operator|->
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_ninit
argument_list|(
name|statp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|statp
argument_list|,
name|NETDB_INTERNAL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|options
operator|=
name|statp
operator|->
name|options
expr_stmt|;
name|statp
operator|->
name|options
operator|&=
operator|~
name|RES_USE_INET6
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
name|src
argument_list|,
name|len
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
operator|*
name|errp
operator|=
name|statp
operator|->
name|res_h_errno
expr_stmt|;
name|statp
operator|->
name|options
operator|=
name|options
expr_stmt|;
return|return
operator|(
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|freehostent
parameter_list|(
name|struct
name|hostent
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Private utility functions  */
end_comment

begin_comment
comment|/*  * _hpcopy: allocate and copy hostent structure  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpcopy
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|nhp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|size
decl_stmt|,
name|addrsize
decl_stmt|;
name|int
name|nalias
init|=
literal|0
decl_stmt|,
name|naddr
init|=
literal|0
decl_stmt|;
name|int
name|al_off
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|hp
return|;
comment|/* count size to be allocated */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_name
operator|!=
name|NULL
condition|)
name|size
operator|+=
name|strlen
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_aliases
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
name|size
operator|+=
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nalias
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* adjust alignment */
name|size
operator|=
name|ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|al_off
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nalias
operator|+
literal|1
operator|)
expr_stmt|;
name|addrsize
operator|=
name|ALIGN
argument_list|(
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_addr_list
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|pp
operator|++
operator|!=
name|NULL
condition|)
name|naddr
operator|++
expr_stmt|;
block|}
name|size
operator|+=
name|addrsize
operator|*
name|naddr
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|naddr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy */
if|if
condition|(
operator|(
name|nhp
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_name
operator|!=
name|NULL
condition|)
block|{
name|nhp
operator|->
name|h_name
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|nhp
operator|->
name|h_name
operator|=
name|NULL
expr_stmt|;
name|nhp
operator|->
name|h_aliases
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|nhp
operator|+
name|al_off
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_aliases
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
name|nhp
operator|->
name|h_aliases
index|[
name|i
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|nhp
operator|->
name|h_aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
operator|->
name|h_aliases
index|[
name|nalias
operator|+
literal|1
index|]
expr_stmt|;
name|nhp
operator|->
name|h_addrtype
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|nhp
operator|->
name|h_length
operator|=
name|hp
operator|->
name|h_length
expr_stmt|;
name|nhp
operator|->
name|h_addr_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_addr_list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
operator|->
name|h_addr_list
index|[
name|naddr
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
name|nhp
operator|->
name|h_addr_list
index|[
name|i
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|pp
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|addrsize
expr_stmt|;
block|}
block|}
name|nhp
operator|->
name|h_addr_list
index|[
name|naddr
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|nhp
return|;
block|}
end_function

begin_comment
comment|/*  * _hpaddr: construct hostent structure with one address  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpaddr
parameter_list|(
name|int
name|af
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|addrs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|addrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * _hpmerge: merge 2 hostent structure, arguments will be freed  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmerge
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp1
parameter_list|,
name|struct
name|hostent
modifier|*
name|hp2
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|naddr
decl_stmt|,
name|nalias
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|aliases
index|[
name|MAXALIASES
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|addrs
index|[
name|MAXADDRS
operator|+
literal|1
index|]
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
index|[
name|MAXADDRS
index|]
decl_stmt|;
if|if
condition|(
name|hp1
operator|==
name|NULL
condition|)
return|return
name|_hpcopy
argument_list|(
name|hp2
argument_list|,
name|errp
argument_list|)
return|;
if|if
condition|(
name|hp2
operator|==
name|NULL
condition|)
return|return
name|_hpcopy
argument_list|(
name|hp1
argument_list|,
name|errp
argument_list|)
return|;
define|#
directive|define
name|HP
parameter_list|(
name|i
parameter_list|)
value|(i == 1 ? hp1 : hp2)
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
operator|(
name|hp1
operator|->
name|h_name
operator|!=
name|NULL
condition|?
name|hp1
operator|->
name|h_name
else|:
name|hp2
operator|->
name|h_name
operator|)
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|nalias
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_aliases
operator|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
init|;
name|nalias
operator|<
name|MAXALIASES
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
comment|/* check duplicates */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nalias
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|pp
argument_list|,
name|aliases
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nalias
condition|)
name|aliases
index|[
name|nalias
operator|++
index|]
operator|=
operator|*
name|pp
expr_stmt|;
block|}
block|}
name|aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp1
operator|->
name|h_length
operator|!=
name|hp2
operator|->
name|h_length
condition|)
block|{
name|hp
operator|->
name|h_addrtype
operator|=
name|AF_INET6
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|->
name|h_addrtype
operator|=
name|hp1
operator|->
name|h_addrtype
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|hp1
operator|->
name|h_length
expr_stmt|;
block|}
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|naddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_addr_list
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_length
operator|==
name|hp
operator|->
name|h_length
condition|)
block|{
while|while
condition|(
name|naddr
operator|<
name|MAXADDRS
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|)
name|addrs
index|[
name|naddr
operator|++
index|]
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* copy IPv4 addr as mapped IPv6 addr */
while|while
condition|(
name|naddr
operator|<
name|MAXADDRS
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|)
block|{
name|MAPADDR
argument_list|(
operator|&
name|addrbuf
index|[
name|naddr
index|]
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
name|addrs
index|[
name|naddr
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addrbuf
index|[
name|naddr
index|]
expr_stmt|;
name|naddr
operator|++
expr_stmt|;
block|}
block|}
block|}
name|addrs
index|[
name|naddr
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * _hpmapv6: convert IPv4 hostent into IPv4-mapped IPv6 addresses  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmapv6
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
name|hp6
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET6
condition|)
return|return
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
return|;
name|memset
argument_list|(
operator|&
name|hp6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
name|hp6
operator|.
name|h_addrtype
operator|=
name|AF_INET6
expr_stmt|;
name|hp6
operator|.
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
return|return
name|_hpmerge
argument_list|(
operator|&
name|hp6
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * _hpsort: sort address by sortlist  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpsort
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|res_state
name|statp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|u_char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
name|t
decl_stmt|;
name|char
name|order
index|[
name|MAXADDRS
index|]
decl_stmt|;
name|int
name|nsort
init|=
name|statp
operator|->
name|nsort
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
operator|||
name|hp
operator|->
name|h_addr_list
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|nsort
operator|==
literal|0
condition|)
return|return
name|hp
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ap
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsort
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|statp
operator|->
name|_u
operator|.
name|_ext
operator|.
name|ext
operator|->
name|sort_list
index|[
name|j
index|]
operator|.
name|af
operator|!=
name|hp
operator|->
name|h_addrtype
condition|)
continue|continue;
name|sp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|statp
operator|->
name|_u
operator|.
name|_ext
operator|.
name|ext
operator|->
name|sort_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|statp
operator|->
name|_u
operator|.
name|_ext
operator|.
name|ext
operator|->
name|sort_list
index|[
name|j
index|]
operator|.
name|mask
expr_stmt|;
else|#
directive|else
name|sp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|statp
operator|->
name|sort_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|statp
operator|->
name|sort_list
index|[
name|j
index|]
operator|.
name|mask
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hp
operator|->
name|h_length
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ap
index|[
name|n
index|]
operator|&
name|mp
index|[
name|n
index|]
operator|)
operator|!=
name|sp
index|[
name|n
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|hp
operator|->
name|h_length
condition|)
break|break;
block|}
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
name|n
operator|=
name|i
expr_stmt|;
name|pp
operator|=
operator|(
name|u_char
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|order
index|[
name|i
index|]
operator|>
name|order
index|[
name|j
index|]
condition|)
block|{
name|ap
operator|=
name|pp
index|[
name|i
index|]
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|=
name|pp
index|[
name|j
index|]
expr_stmt|;
name|pp
index|[
name|j
index|]
operator|=
name|ap
expr_stmt|;
name|t
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|j
index|]
expr_stmt|;
name|order
index|[
name|j
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * _hpreorder: sort address by default address selection  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpreorder
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
block|{
name|struct
name|hp_order
modifier|*
name|aio
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|policyhead
name|policyhead
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|hp
return|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
name|free_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
comment|/* count the number of addrinfo elements for sorting. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|n
index|]
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
empty_stmt|;
comment|/* 	 * If the number is small enough, we can skip the reordering process. 	 */
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return
name|hp
return|;
comment|/* allocate a temporary array for sort and initialization of it. */
if|if
condition|(
operator|(
name|aio
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
operator|*
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|hp
return|;
comment|/* give up reordering */
name|memset
argument_list|(
name|aio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* retrieve address selection policy from the kernel */
name|TAILQ_INIT
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
condition|)
block|{
comment|/* no policy is installed into kernel, we don't sort. */
name|free
argument_list|(
name|aio
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|=
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
expr_stmt|;
name|aio
index|[
name|i
index|]
operator|.
name|aio_h_addr
operator|=
name|ap
expr_stmt|;
name|sa
operator|=
operator|&
name|aio
index|[
name|i
index|]
operator|.
name|aio_sa
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
name|sa
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ap
argument_list|)
condition|)
block|{
name|sa
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|,
operator|&
name|ap
index|[
literal|12
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|->
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|sa
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
name|aio
index|[
name|i
index|]
operator|.
name|aio_dstscope
operator|=
name|gai_addr2scopetype
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|aio
index|[
name|i
index|]
operator|.
name|aio_dstpolicy
operator|=
name|match_addrselectpolicy
argument_list|(
name|sa
argument_list|,
operator|&
name|policyhead
argument_list|)
expr_stmt|;
name|set_source
argument_list|(
operator|&
name|aio
index|[
name|i
index|]
argument_list|,
operator|&
name|policyhead
argument_list|)
expr_stmt|;
block|}
comment|/* perform sorting. */
name|qsort
argument_list|(
name|aio
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
argument_list|,
name|comp_dst
argument_list|)
expr_stmt|;
comment|/* reorder the h_addr_list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|=
name|aio
index|[
name|i
index|]
operator|.
name|aio_h_addr
expr_stmt|;
comment|/* cleanup and return */
name|free
argument_list|(
name|aio
argument_list|)
expr_stmt|;
name|free_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
name|head
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|int
name|mib
index|[]
init|=
block|{
name|CTL_NET
block|,
name|PF_INET6
block|,
name|IPPROTO_IPV6
block|,
name|IPV6CTL_ADDRCTLPOLICY
block|}
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|in6_addrpolicy
modifier|*
name|pol
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ep
operator|=
operator|(
expr|struct
name|in6_addrpolicy
operator|*
operator|)
operator|(
name|buf
operator|+
name|l
operator|)
expr_stmt|;
for|for
control|(
name|pol
operator|=
operator|(
expr|struct
name|in6_addrpolicy
operator|*
operator|)
name|buf
init|;
name|pol
operator|+
literal|1
operator|<=
name|ep
condition|;
name|pol
operator|++
control|)
block|{
name|struct
name|policyqueue
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free_addrselectpolicy
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* make the list empty */
break|break;
block|}
name|new
operator|->
name|pc_policy
operator|=
operator|*
name|pol
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|new
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|free_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|policyqueue
modifier|*
name|ent
decl_stmt|,
modifier|*
name|nent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|ent
condition|;
name|ent
operator|=
name|nent
control|)
block|{
name|nent
operator|=
name|TAILQ_NEXT
argument_list|(
name|ent
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|ent
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|policyqueue
modifier|*
name|match_addrselectpolicy
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|policyhead
modifier|*
name|head
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|policyqueue
modifier|*
name|ent
decl_stmt|,
modifier|*
name|bestent
init|=
name|NULL
decl_stmt|;
name|struct
name|in6_addrpolicy
modifier|*
name|pol
decl_stmt|;
name|int
name|matchlen
decl_stmt|,
name|bestmatchlen
init|=
operator|-
literal|1
decl_stmt|;
name|u_char
modifier|*
name|mp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|m
decl_stmt|;
name|struct
name|sockaddr_in6
name|key
decl_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET6
case|:
name|key
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
comment|/* convert the address into IPv4-mapped IPv6 address. */
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|key
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|10
index|]
operator|=
literal|0xff
expr_stmt|;
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|11
index|]
operator|=
literal|0xff
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|12
index|]
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|ent
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|ent
condition|;
name|ent
operator|=
name|TAILQ_NEXT
argument_list|(
name|ent
argument_list|,
name|pc_entry
argument_list|)
control|)
block|{
name|pol
operator|=
operator|&
name|ent
operator|->
name|pc_policy
expr_stmt|;
name|matchlen
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pol
operator|->
name|addrmask
operator|.
name|sin6_addr
expr_stmt|;
name|ep
operator|=
name|mp
operator|+
literal|16
expr_stmt|;
comment|/* XXX: scope field? */
name|k
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|key
operator|.
name|sin6_addr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pol
operator|->
name|addr
operator|.
name|sin6_addr
expr_stmt|;
for|for
control|(
init|;
name|mp
operator|<
name|ep
operator|&&
operator|*
name|mp
condition|;
name|mp
operator|++
operator|,
name|k
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|k
operator|&
name|m
operator|)
operator|!=
operator|*
name|p
condition|)
goto|goto
name|next
goto|;
comment|/* not match */
if|if
condition|(
name|m
operator|==
literal|0xff
condition|)
comment|/* short cut for a typical case */
name|matchlen
operator|+=
literal|8
expr_stmt|;
else|else
block|{
while|while
condition|(
name|m
operator|>=
literal|0x80
condition|)
block|{
name|matchlen
operator|++
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* matched.  check if this is better than the current best. */
if|if
condition|(
name|matchlen
operator|>
name|bestmatchlen
condition|)
block|{
name|bestent
operator|=
name|ent
expr_stmt|;
name|bestmatchlen
operator|=
name|matchlen
expr_stmt|;
block|}
name|next
label|:
continue|continue;
block|}
return|return
operator|(
name|bestent
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|set_source
parameter_list|(
name|struct
name|hp_order
modifier|*
name|aio
parameter_list|,
name|struct
name|policyhead
modifier|*
name|ph
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
init|=
name|aio
operator|->
name|aio_un
operator|.
name|aiou_ss
decl_stmt|;
name|socklen_t
name|srclen
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* set unspec ("no source is available"), just in case */
name|aio
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|aio
operator|->
name|aio_srcscope
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* ignore unsupported AFs explicitly */
return|return;
block|}
comment|/* open a socket to get the source address for the given dst */
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|ss
operator|.
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* give up */
if|if
condition|(
name|_connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|ss
operator|.
name|ss_len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|srclen
operator|=
name|ss
operator|.
name|ss_len
expr_stmt|;
if|if
condition|(
name|_getsockname
argument_list|(
name|s
argument_list|,
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
operator|&
name|srclen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|aio
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|aio
operator|->
name|aio_srcscope
operator|=
name|gai_addr2scopetype
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|)
expr_stmt|;
name|aio
operator|->
name|aio_srcpolicy
operator|=
name|match_addrselectpolicy
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|aio
operator|->
name|aio_matchlen
operator|=
name|matchlen
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ss
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_ifreq
name|ifr6
decl_stmt|;
name|u_int32_t
name|flags6
decl_stmt|;
comment|/* XXX: interface name should not be hardcoded */
name|strncpy
argument_list|(
name|ifr6
operator|.
name|ifr_name
argument_list|,
literal|"lo0"
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ifr6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifr6
operator|.
name|ifr_addr
argument_list|,
operator|&
name|ss
argument_list|,
name|ss
operator|.
name|ss_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|_ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFAFLAG_IN6
argument_list|,
operator|&
name|ifr6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags6
operator|=
name|ifr6
operator|.
name|ifr_ifru
operator|.
name|ifru_flags6
expr_stmt|;
if|if
condition|(
operator|(
name|flags6
operator|&
name|IN6_IFF_DEPRECATED
operator|)
condition|)
name|aio
operator|->
name|aio_srcflag
operator||=
name|AIO_SRCFLAG_DEPRECATED
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|cleanup
label|:
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|matchlen
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|match
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|lim
decl_stmt|,
name|r
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
switch|switch
condition|(
name|src
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|src
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|lim
operator|=
name|s
operator|+
name|addrlen
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|lim
operator|=
name|s
operator|+
name|addrlen
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|s
operator|<
name|lim
condition|)
if|if
condition|(
operator|(
name|r
operator|=
operator|(
operator|*
name|d
operator|++
operator|^
operator|*
name|s
operator|++
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|r
operator|<
name|addrlen
operator|*
literal|8
condition|)
block|{
name|match
operator|++
expr_stmt|;
name|r
operator|<<=
literal|1
expr_stmt|;
block|}
break|break;
block|}
else|else
name|match
operator|+=
literal|8
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|comp_dst
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|struct
name|hp_order
modifier|*
name|dst1
init|=
name|arg1
decl_stmt|,
modifier|*
name|dst2
init|=
name|arg2
decl_stmt|;
comment|/* 	 * Rule 1: Avoid unusable destinations. 	 * XXX: we currently do not consider if an appropriate route exists. 	 */
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|==
name|AF_UNSPEC
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|==
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Rule 2: Prefer matching scope. */
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|==
name|dst1
operator|->
name|aio_srcscope
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|!=
name|dst2
operator|->
name|aio_srcscope
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|!=
name|dst1
operator|->
name|aio_srcscope
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|==
name|dst2
operator|->
name|aio_srcscope
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Rule 3: Avoid deprecated addresses. */
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dst1
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
operator|&&
operator|(
name|dst2
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dst1
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
operator|&&
operator|!
operator|(
name|dst2
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Rule 4: Prefer home addresses. */
comment|/* XXX: not implemented yet */
comment|/* Rule 5: Prefer matching label. */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|dst1
operator|->
name|aio_srcpolicy
operator|&&
name|dst1
operator|->
name|aio_dstpolicy
operator|&&
name|dst1
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|==
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|&&
operator|(
name|dst2
operator|->
name|aio_srcpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|!=
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_srcpolicy
operator|&&
name|dst2
operator|->
name|aio_dstpolicy
operator|&&
name|dst2
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|==
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|&&
operator|(
name|dst1
operator|->
name|aio_srcpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|!=
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Rule 6: Prefer higher precedence. */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|dst1
operator|->
name|aio_dstpolicy
operator|&&
operator|(
name|dst2
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|>
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_dstpolicy
operator|&&
operator|(
name|dst1
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|>
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Rule 7: Prefer native transport. */
comment|/* XXX: not implemented yet */
comment|/* Rule 8: Prefer smaller scope. */
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|>=
literal|0
operator|&&
name|dst1
operator|->
name|aio_dstscope
operator|<
name|dst2
operator|->
name|aio_dstscope
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_dstscope
operator|>=
literal|0
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|<
name|dst1
operator|->
name|aio_dstscope
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Rule 9: Use longest matching prefix. 	 * We compare the match length in a same AF only. 	 */
if|if
condition|(
name|dst1
operator|->
name|aio_sa
operator|.
name|sa_family
operator|==
name|dst2
operator|->
name|aio_sa
operator|.
name|sa_family
condition|)
block|{
if|if
condition|(
name|dst1
operator|->
name|aio_matchlen
operator|>
name|dst2
operator|->
name|aio_matchlen
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_matchlen
operator|<
name|dst2
operator|->
name|aio_matchlen
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Rule 10: Otherwise, leave the order unchanged. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy from scope.c.  * XXX: we should standardize the functions and link them as standard  * library.  */
end_comment

begin_function
specifier|static
name|int
name|gai_addr2scopetype
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr_in
modifier|*
name|sa4
decl_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sa6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* just use the scope field of the multicast address */
return|return
operator|(
name|sa6
operator|->
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
return|;
block|}
comment|/* 		 * Unicast addresses: map scope type to corresponding scope 		 * value defined for multcast addresses. 		 * XXX: hardcoded scope type values are bad... 		 */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* node local scope */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* link-local scope */
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|5
operator|)
return|;
comment|/* site-local scope */
return|return
operator|(
literal|14
operator|)
return|;
comment|/* global scope */
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
comment|/* 		 * IPv4 pseudo scoping according to RFC 3484. 		 */
name|sa4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
comment|/* IPv4 autoconfiguration addresses have link-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|169
operator|&&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|==
literal|254
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* Private addresses have site-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|10
operator|||
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|172
operator|&&
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|16
operator|)
operator|||
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|192
operator|&&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|==
literal|168
operator|)
condition|)
return|return
operator|(
literal|14
operator|)
return|;
comment|/* XXX: It should be 5 unless NAT */
comment|/* Loopback addresses have link-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|127
condition|)
return|return
operator|(
literal|2
operator|)
return|;
return|return
operator|(
literal|14
operator|)
return|;
break|break;
default|default:
name|errno
operator|=
name|EAFNOSUPPORT
expr_stmt|;
comment|/* is this a good error? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

end_unit

