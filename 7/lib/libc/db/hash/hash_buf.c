begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Margo Seltzer.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)hash_buf.c	8.5 (Berkeley) 7/15/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PACKAGE: hash  *  * DESCRIPTION:  *	Contains buffer management  *  * ROUTINES:  * External  *	__buf_init  *	__get_buf  *	__buf_free  *	__reclaim_buf  * Internal  *	newbuf  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"page.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_function_decl
specifier|static
name|BUFHEAD
modifier|*
name|newbuf
parameter_list|(
name|HTAB
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|BUFHEAD
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Unlink B from its place in the lru */
end_comment

begin_define
define|#
directive|define
name|BUF_REMOVE
parameter_list|(
name|B
parameter_list|)
value|{ \ 	(B)->prev->next = (B)->next; \ 	(B)->next->prev = (B)->prev; \ }
end_define

begin_comment
comment|/* Insert B after P */
end_comment

begin_define
define|#
directive|define
name|BUF_INSERT
parameter_list|(
name|B
parameter_list|,
name|P
parameter_list|)
value|{ \ 	(B)->next = (P)->next; \ 	(B)->prev = (P); \ 	(P)->next = (B); \ 	(B)->next->prev = (B); \ }
end_define

begin_define
define|#
directive|define
name|MRU
value|hashp->bufhead.next
end_define

begin_define
define|#
directive|define
name|LRU
value|hashp->bufhead.prev
end_define

begin_define
define|#
directive|define
name|MRU_INSERT
parameter_list|(
name|B
parameter_list|)
value|BUF_INSERT((B),&hashp->bufhead)
end_define

begin_define
define|#
directive|define
name|LRU_INSERT
parameter_list|(
name|B
parameter_list|)
value|BUF_INSERT((B), LRU)
end_define

begin_comment
comment|/*  * We are looking for a buffer with address "addr".  If prev_bp is NULL, then  * address is a bucket index.  If prev_bp is not NULL, then it points to the  * page previous to an overflow page that we are trying to find.  *  * CAVEAT:  The buffer header accessed via prev_bp's ovfl field may no longer  * be valid.  Therefore, you must always verify that its address matches the  * address you are seeking.  */
end_comment

begin_function
specifier|extern
name|BUFHEAD
modifier|*
name|__get_buf
parameter_list|(
name|hashp
parameter_list|,
name|addr
parameter_list|,
name|prev_bp
parameter_list|,
name|newpage
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|BUFHEAD
modifier|*
name|prev_bp
decl_stmt|;
name|int
name|newpage
decl_stmt|;
comment|/* If prev_bp set, indicates a new overflow page. */
block|{
name|BUFHEAD
modifier|*
name|bp
decl_stmt|;
name|u_int32_t
name|is_disk_mask
decl_stmt|;
name|int
name|is_disk
decl_stmt|,
name|segment_ndx
decl_stmt|;
name|SEGMENT
name|segp
decl_stmt|;
name|is_disk
operator|=
literal|0
expr_stmt|;
name|is_disk_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prev_bp
condition|)
block|{
name|bp
operator|=
name|prev_bp
operator|->
name|ovfl
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|||
operator|(
name|bp
operator|->
name|addr
operator|!=
name|addr
operator|)
condition|)
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|newpage
condition|)
name|is_disk
operator|=
name|BUF_DISK
expr_stmt|;
block|}
else|else
block|{
comment|/* Grab buffer out of directory */
name|segment_ndx
operator|=
name|addr
operator|&
operator|(
name|hashp
operator|->
name|SGSIZE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* valid segment ensured by __call_hash() */
name|segp
operator|=
name|hashp
operator|->
name|dir
index|[
name|addr
operator|>>
name|hashp
operator|->
name|SSHIFT
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|segp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
name|PTROF
argument_list|(
name|segp
index|[
name|segment_ndx
index|]
argument_list|)
expr_stmt|;
name|is_disk_mask
operator|=
name|ISDISK
argument_list|(
name|segp
index|[
name|segment_ndx
index|]
argument_list|)
expr_stmt|;
name|is_disk
operator|=
name|is_disk_mask
operator|||
operator|!
name|hashp
operator|->
name|new_file
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bp
condition|)
block|{
name|bp
operator|=
name|newbuf
argument_list|(
name|hashp
argument_list|,
name|addr
argument_list|,
name|prev_bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|||
name|__get_page
argument_list|(
name|hashp
argument_list|,
name|bp
operator|->
name|page
argument_list|,
name|addr
argument_list|,
operator|!
name|prev_bp
argument_list|,
name|is_disk
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|prev_bp
condition|)
name|segp
index|[
name|segment_ndx
index|]
operator|=
operator|(
name|BUFHEAD
operator|*
operator|)
operator|(
operator|(
name|ptrdiff_t
operator|)
name|bp
operator||
name|is_disk_mask
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BUF_REMOVE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|MRU_INSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need a buffer for this page. Either allocate one, or evict a resident  * one (if we have as many buffers as we're allowed) and put this one in.  *  * If newbuf finds an error (returning NULL), it also sets errno.  */
end_comment

begin_function
specifier|static
name|BUFHEAD
modifier|*
name|newbuf
parameter_list|(
name|hashp
parameter_list|,
name|addr
parameter_list|,
name|prev_bp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|BUFHEAD
modifier|*
name|prev_bp
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|bp
decl_stmt|;
comment|/* The buffer we're going to use */
name|BUFHEAD
modifier|*
name|xbp
decl_stmt|;
comment|/* Temp pointer */
name|BUFHEAD
modifier|*
name|next_xbp
decl_stmt|;
name|SEGMENT
name|segp
decl_stmt|;
name|int
name|segment_ndx
decl_stmt|;
name|u_int16_t
name|oaddr
decl_stmt|,
modifier|*
name|shortp
decl_stmt|;
name|oaddr
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|LRU
expr_stmt|;
comment|/* 	 * If LRU buffer is pinned, the buffer pool is too small. We need to 	 * allocate more buffers. 	 */
if|if
condition|(
name|hashp
operator|->
name|nbufs
operator|||
operator|(
name|bp
operator|->
name|flags
operator|&
name|BUF_PIN
operator|)
condition|)
block|{
comment|/* Allocate a new one */
if|if
condition|(
operator|(
name|bp
operator|=
operator|(
name|BUFHEAD
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BUFHEAD
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|PURIFY
name|memset
argument_list|(
name|bp
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|BUFHEAD
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|bp
operator|->
name|page
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|hashp
operator|->
name|BSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PURIFY
name|memset
argument_list|(
name|bp
operator|->
name|page
argument_list|,
literal|0xff
argument_list|,
name|hashp
operator|->
name|BSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hashp
operator|->
name|nbufs
condition|)
name|hashp
operator|->
name|nbufs
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* Kick someone out */
name|BUF_REMOVE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * If this is an overflow page with addr 0, it's already been 		 * flushed back in an overflow chain and initialized. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|addr
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bp
operator|->
name|flags
operator|&
name|BUF_BUCKET
operator|)
condition|)
block|{
comment|/* 			 * Set oaddr before __put_page so that you get it 			 * before bytes are swapped. 			 */
name|shortp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bp
operator|->
name|page
expr_stmt|;
if|if
condition|(
name|shortp
index|[
literal|0
index|]
condition|)
name|oaddr
operator|=
name|shortp
index|[
name|shortp
index|[
literal|0
index|]
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|flags
operator|&
name|BUF_MOD
operator|)
operator|&&
name|__put_page
argument_list|(
name|hashp
argument_list|,
name|bp
operator|->
name|page
argument_list|,
name|bp
operator|->
name|addr
argument_list|,
operator|(
name|int
operator|)
name|IS_BUCKET
argument_list|(
name|bp
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 			 * Update the pointer to this page (i.e. invalidate it). 			 * 			 * If this is a new file (i.e. we created it at open 			 * time), make sure that we mark pages which have been 			 * written to disk so we retrieve them from disk later, 			 * rather than allocating new pages. 			 */
if|if
condition|(
name|IS_BUCKET
argument_list|(
name|bp
operator|->
name|flags
argument_list|)
condition|)
block|{
name|segment_ndx
operator|=
name|bp
operator|->
name|addr
operator|&
operator|(
name|hashp
operator|->
name|SGSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|segp
operator|=
name|hashp
operator|->
name|dir
index|[
name|bp
operator|->
name|addr
operator|>>
name|hashp
operator|->
name|SSHIFT
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|segp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hashp
operator|->
name|new_file
operator|&&
operator|(
operator|(
name|bp
operator|->
name|flags
operator|&
name|BUF_MOD
operator|)
operator|||
name|ISDISK
argument_list|(
name|segp
index|[
name|segment_ndx
index|]
argument_list|)
operator|)
condition|)
name|segp
index|[
name|segment_ndx
index|]
operator|=
operator|(
name|BUFHEAD
operator|*
operator|)
name|BUF_DISK
expr_stmt|;
else|else
name|segp
index|[
name|segment_ndx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 			 * Since overflow pages can only be access by means of 			 * their bucket, free overflow pages associated with 			 * this bucket. 			 */
for|for
control|(
name|xbp
operator|=
name|bp
init|;
name|xbp
operator|->
name|ovfl
condition|;
control|)
block|{
name|next_xbp
operator|=
name|xbp
operator|->
name|ovfl
expr_stmt|;
name|xbp
operator|->
name|ovfl
operator|=
literal|0
expr_stmt|;
name|xbp
operator|=
name|next_xbp
expr_stmt|;
comment|/* Check that ovfl pointer is up date. */
if|if
condition|(
name|IS_BUCKET
argument_list|(
name|xbp
operator|->
name|flags
argument_list|)
operator|||
operator|(
name|oaddr
operator|!=
name|xbp
operator|->
name|addr
operator|)
condition|)
break|break;
name|shortp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|xbp
operator|->
name|page
expr_stmt|;
if|if
condition|(
name|shortp
index|[
literal|0
index|]
condition|)
comment|/* set before __put_page */
name|oaddr
operator|=
name|shortp
index|[
name|shortp
index|[
literal|0
index|]
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|xbp
operator|->
name|flags
operator|&
name|BUF_MOD
operator|)
operator|&&
name|__put_page
argument_list|(
name|hashp
argument_list|,
name|xbp
operator|->
name|page
argument_list|,
name|xbp
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|xbp
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|xbp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|BUF_REMOVE
argument_list|(
name|xbp
argument_list|)
expr_stmt|;
name|LRU_INSERT
argument_list|(
name|xbp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now assign this buffer */
name|bp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG1
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NEWBUF1: %d->ovfl was %d is now %d\n"
argument_list|,
name|bp
operator|->
name|addr
argument_list|,
operator|(
name|bp
operator|->
name|ovfl
condition|?
name|bp
operator|->
name|ovfl
operator|->
name|addr
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|ovfl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_bp
condition|)
block|{
comment|/* 		 * If prev_bp is set, this is an overflow page, hook it in to 		 * the buffer overflow links. 		 */
ifdef|#
directive|ifdef
name|DEBUG1
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NEWBUF2: %d->ovfl was %d is now %d\n"
argument_list|,
name|prev_bp
operator|->
name|addr
argument_list|,
operator|(
name|prev_bp
operator|->
name|ovfl
condition|?
name|bp
operator|->
name|ovfl
operator|->
name|addr
else|:
literal|0
operator|)
argument_list|,
operator|(
name|bp
condition|?
name|bp
operator|->
name|addr
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prev_bp
operator|->
name|ovfl
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|flags
operator|=
name|BUF_BUCKET
expr_stmt|;
name|MRU_INSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|__buf_init
parameter_list|(
name|hashp
parameter_list|,
name|nbytes
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|bfp
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|bfp
operator|=
operator|&
operator|(
name|hashp
operator|->
name|bufhead
operator|)
expr_stmt|;
name|npages
operator|=
operator|(
name|nbytes
operator|+
name|hashp
operator|->
name|BSIZE
operator|-
literal|1
operator|)
operator|>>
name|hashp
operator|->
name|BSHIFT
expr_stmt|;
name|npages
operator|=
name|MAX
argument_list|(
name|npages
argument_list|,
name|MIN_BUFFERS
argument_list|)
expr_stmt|;
name|hashp
operator|->
name|nbufs
operator|=
name|npages
expr_stmt|;
name|bfp
operator|->
name|next
operator|=
name|bfp
expr_stmt|;
name|bfp
operator|->
name|prev
operator|=
name|bfp
expr_stmt|;
comment|/* 	 * This space is calloc'd so these are already null. 	 * 	 * bfp->ovfl = NULL; 	 * bfp->flags = 0; 	 * bfp->page = NULL; 	 * bfp->addr = 0; 	 */
block|}
end_function

begin_function
specifier|extern
name|int
name|__buf_free
parameter_list|(
name|hashp
parameter_list|,
name|do_free
parameter_list|,
name|to_disk
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|int
name|do_free
decl_stmt|,
name|to_disk
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|bp
decl_stmt|;
comment|/* Need to make sure that buffer manager has been initialized */
if|if
condition|(
operator|!
name|LRU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|bp
operator|=
name|LRU
init|;
name|bp
operator|!=
operator|&
name|hashp
operator|->
name|bufhead
condition|;
control|)
block|{
comment|/* Check that the buffer is valid */
if|if
condition|(
name|bp
operator|->
name|addr
operator|||
name|IS_BUCKET
argument_list|(
name|bp
operator|->
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|to_disk
operator|&&
operator|(
name|bp
operator|->
name|flags
operator|&
name|BUF_MOD
operator|)
operator|&&
name|__put_page
argument_list|(
name|hashp
argument_list|,
name|bp
operator|->
name|page
argument_list|,
name|bp
operator|->
name|addr
argument_list|,
name|IS_BUCKET
argument_list|(
name|bp
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Check if we are freeing stuff */
if|if
condition|(
name|do_free
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|page
condition|)
name|free
argument_list|(
name|bp
operator|->
name|page
argument_list|)
expr_stmt|;
name|BUF_REMOVE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|LRU
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|bp
operator|->
name|prev
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|__reclaim_buf
parameter_list|(
name|hashp
parameter_list|,
name|bp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bp
decl_stmt|;
block|{
name|bp
operator|->
name|ovfl
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|BUF_REMOVE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LRU_INSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

