begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995-1998 John Birrell<jb@cimlogic.com.au>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"pthread_private.h"
end_include

begin_comment
comment|/* #define DEBUG_THREAD_KERN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_THREAD_KERN
end_ifdef

begin_define
define|#
directive|define
name|DBG_MSG
value|stdout_debug
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG_MSG
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Static function prototype definitions: */
end_comment

begin_function_decl
specifier|static
name|void
name|thread_kern_poll
parameter_list|(
name|int
name|wait_reqd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dequeue_signals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|thread_run_switch_hook
parameter_list|(
name|pthread_t
name|thread_out
parameter_list|,
name|pthread_t
name|thread_in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Static variables: */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_tick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|called_from_handler
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is called when a signal handler finishes and wants to  * return to a previous frame.  */
end_comment

begin_function
name|void
name|_thread_kern_sched_frame
parameter_list|(
name|struct
name|pthread_signal_frame
modifier|*
name|psf
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
comment|/* 	 * Flag the pthread kernel as executing scheduler code 	 * to avoid a signal from interrupting this execution and 	 * corrupting the (soon-to-be) current frame. 	 */
name|_thread_kern_in_sched
operator|=
literal|1
expr_stmt|;
comment|/* Restore the signal frame: */
name|_thread_sigframe_restore
argument_list|(
name|curthread
argument_list|,
name|psf
argument_list|)
expr_stmt|;
comment|/* The signal mask was restored; check for any pending signals: */
name|curthread
operator|->
name|check_pending
operator|=
literal|1
expr_stmt|;
comment|/* Switch to the thread scheduler: */
name|___longjmp
argument_list|(
name|_thread_kern_sched_jb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thread_kern_sched
parameter_list|(
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
comment|/* 	 * Flag the pthread kernel as executing scheduler code 	 * to avoid a scheduler signal from interrupting this 	 * execution and calling the scheduler again. 	 */
name|_thread_kern_in_sched
operator|=
literal|1
expr_stmt|;
comment|/* Check if this function was called from the signal handler: */
if|if
condition|(
name|ucp
operator|!=
name|NULL
condition|)
block|{
name|called_from_handler
operator|=
literal|1
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Entering scheduler due to signal\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Save the state of the current thread: */
if|if
condition|(
name|_setjmp
argument_list|(
name|curthread
operator|->
name|ctx
operator|.
name|jb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DBG_MSG
argument_list|(
literal|"Returned from ___longjmp, thread %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* 		 * This point is reached when a longjmp() is called 		 * to restore the state of a thread. 		 * 		 * This is the normal way out of the scheduler. 		 */
name|_thread_kern_in_sched
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|sig_defer_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_AT_CANCEL_POINT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_CANCEL_ASYNCHRONOUS
operator|)
operator|!=
literal|0
operator|)
condition|)
comment|/* 				 * Cancellations override signals. 				 * 				 * Stick a cancellation point at the 				 * start of each async-cancellable 				 * thread's resumption. 				 * 				 * We allow threads woken at cancel 				 * points to do their own checks. 				 */
name|pthread_testcancel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|_sched_switch_hook
operator|!=
name|NULL
condition|)
block|{
comment|/* Run the installed switch hook: */
name|thread_run_switch_hook
argument_list|(
name|_last_user_thread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ucp
operator|==
name|NULL
condition|)
return|return;
else|else
block|{
comment|/* 			 * Set the process signal mask in the context; it 			 * could have changed by the handler. 			 */
name|ucp
operator|->
name|uc_sigmask
operator|=
name|_process_sigmask
expr_stmt|;
comment|/* Resume the interrupted thread: */
name|__sys_sigreturn
argument_list|(
name|ucp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Switch to the thread scheduler: */
name|___longjmp
argument_list|(
name|_thread_kern_sched_jb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thread_kern_sched_sig
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|curthread
operator|->
name|check_pending
operator|=
literal|1
expr_stmt|;
name|_thread_kern_sched
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thread_kern_scheduler
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|pthread_t
name|pthread
decl_stmt|,
name|pthread_h
decl_stmt|;
name|unsigned
name|int
name|current_tick
decl_stmt|;
name|int
name|add_to_prioq
decl_stmt|;
comment|/* If the currently running thread is a user thread, save it: */
if|if
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_PRIVATE
operator|)
operator|==
literal|0
condition|)
name|_last_user_thread
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|called_from_handler
operator|!=
literal|0
condition|)
block|{
name|called_from_handler
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We were called from a signal handler; restore the process 		 * signal mask. 		 */
if|if
condition|(
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|_process_sigmask
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Unable to restore process mask after signal"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enter a scheduling loop that finds the next thread that is 	 * ready to run. This loop completes when there are no more threads 	 * in the global list or when a thread has its state restored by 	 * either a sigreturn (if the state was saved as a sigcontext) or a 	 * longjmp (if the state was saved by a setjmp). 	 */
while|while
condition|(
operator|!
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|_thread_list
argument_list|)
operator|)
condition|)
block|{
comment|/* Get the current time of day: */
name|GET_CURRENT_TOD
argument_list|(
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|current_tick
operator|=
name|_sched_ticks
expr_stmt|;
comment|/* 		 * Protect the scheduling queues from access by the signal 		 * handler. 		 */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
name|add_to_prioq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
operator|&
name|_thread_kern_thread
condition|)
block|{
comment|/* 			 * This thread no longer needs to yield the CPU. 			 */
name|curthread
operator|->
name|yield_on_sig_undefer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
comment|/* 				 * Save the current time as the time that the 				 * thread became inactive: 				 */
name|curthread
operator|->
name|last_inactive
operator|=
operator|(
name|long
operator|)
name|current_tick
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|last_inactive
operator|<
name|curthread
operator|->
name|last_active
condition|)
block|{
comment|/* Account for a rollover: */
name|curthread
operator|->
name|last_inactive
operator|=
operator|+
name|UINT_MAX
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* 			 * Place the currently running thread into the 			 * appropriate queue(s). 			 */
switch|switch
condition|(
name|curthread
operator|->
name|state
condition|)
block|{
case|case
name|PS_DEAD
case|:
case|case
name|PS_STATE_MAX
case|:
comment|/* to silence -Wall */
case|case
name|PS_SUSPENDED
case|:
comment|/* 				 * Dead and suspended threads are not placed 				 * in any queue: 				 */
break|break;
case|case
name|PS_RUNNING
case|:
comment|/* 				 * Runnable threads can't be placed in the 				 * priority queue until after waiting threads 				 * are polled (to preserve round-robin 				 * scheduling). 				 */
name|add_to_prioq
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 			 * States which do not depend on file descriptor I/O 			 * operations or timeouts: 			 */
case|case
name|PS_DEADLOCK
case|:
case|case
name|PS_FDLR_WAIT
case|:
case|case
name|PS_FDLW_WAIT
case|:
case|case
name|PS_FILE_WAIT
case|:
case|case
name|PS_JOIN
case|:
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_SIGSUSPEND
case|:
case|case
name|PS_SIGTHREAD
case|:
case|case
name|PS_SIGWAIT
case|:
case|case
name|PS_WAIT_WAIT
case|:
comment|/* No timeouts for these states: */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Restart the time slice: */
name|curthread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Insert into the waiting queue: */
name|PTHREAD_WAITQ_INSERT
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
break|break;
comment|/* States which can timeout: */
case|case
name|PS_COND_WAIT
case|:
case|case
name|PS_SLEEP_WAIT
case|:
comment|/* Restart the time slice: */
name|curthread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Insert into the waiting queue: */
name|PTHREAD_WAITQ_INSERT
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
break|break;
comment|/* States that require periodic work: */
case|case
name|PS_SPINBLOCK
case|:
comment|/* No timeouts for this state: */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Increment spinblock count: */
name|_spinblock_count
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PS_FDR_WAIT
case|:
case|case
name|PS_FDW_WAIT
case|:
case|case
name|PS_POLL_WAIT
case|:
case|case
name|PS_SELECT_WAIT
case|:
comment|/* Restart the time slice: */
name|curthread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Insert into the waiting queue: */
name|PTHREAD_WAITQ_INSERT
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Insert into the work queue: */
name|PTHREAD_WORKQ_INSERT
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Are there pending signals for this thread? 			 * 			 * This check has to be performed after the thread 			 * has been placed in the queue(s) appropriate for 			 * its state.  The process of adding pending signals 			 * can change a threads state, which in turn will 			 * attempt to add or remove the thread from any 			 * scheduling queue to which it belongs. 			 */
if|if
condition|(
name|curthread
operator|->
name|check_pending
operator|!=
literal|0
condition|)
block|{
name|curthread
operator|->
name|check_pending
operator|=
literal|0
expr_stmt|;
name|_thread_sig_check_pending
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Avoid polling file descriptors if there are none 		 * waiting: 		 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|_workq
argument_list|)
operator|!=
literal|0
condition|)
block|{ 		}
comment|/* 		 * Poll file descriptors only if a new scheduling signal 		 * has occurred or if we have no more runnable threads. 		 */
elseif|else
if|if
condition|(
operator|(
operator|(
name|current_tick
operator|=
name|_sched_ticks
operator|)
operator|!=
name|last_tick
operator|)
operator|||
operator|(
operator|(
name|curthread
operator|->
name|state
operator|!=
name|PS_RUNNING
operator|)
operator|&&
operator|(
name|PTHREAD_PRIOQ_FIRST
argument_list|()
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
comment|/* Unprotect the scheduling queues: */
name|_queue_signals
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Poll file descriptors to update the state of threads 			 * waiting on file I/O where data may be available: 			 */
name|thread_kern_poll
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Protect the scheduling queues: */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
block|}
name|last_tick
operator|=
name|current_tick
expr_stmt|;
comment|/* 		 * Wake up threads that have timedout.  This has to be 		 * done after polling in case a thread does a poll or 		 * select with zero time. 		 */
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|pthread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_waitingq
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|<
name|ts
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
name|ts
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|<=
name|ts
operator|.
name|tv_nsec
operator|)
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|pthread
operator|->
name|state
condition|)
block|{
case|case
name|PS_POLL_WAIT
case|:
case|case
name|PS_SELECT_WAIT
case|:
comment|/* Return zero file descriptors ready: */
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* 				 * Remove this thread from the waiting queue 				 * (and work queue if necessary) and place it 				 * in the ready queue. 				 */
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
if|if
condition|(
name|pthread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_IN_WORKQ
condition|)
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* 			 * Flag the timeout in the thread structure: 			 */
name|pthread
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
block|}
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
comment|/* 		 * Check to see if the current thread needs to be added 		 * to the priority queue: 		 */
if|if
condition|(
name|add_to_prioq
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Save the current time as the time that the 			 * thread became inactive: 			 */
name|current_tick
operator|=
name|_sched_ticks
expr_stmt|;
name|curthread
operator|->
name|last_inactive
operator|=
operator|(
name|long
operator|)
name|current_tick
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|last_inactive
operator|<
name|curthread
operator|->
name|last_active
condition|)
block|{
comment|/* Account for a rollover: */
name|curthread
operator|->
name|last_inactive
operator|=
operator|+
name|UINT_MAX
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|curthread
operator|->
name|slice_usec
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|curthread
operator|->
name|attr
operator|.
name|sched_policy
operator|!=
name|SCHED_FIFO
operator|)
condition|)
block|{
comment|/* 				 * Accumulate the number of microseconds for 				 * which the current thread has run: 				 */
name|curthread
operator|->
name|slice_usec
operator|+=
operator|(
name|curthread
operator|->
name|last_inactive
operator|-
name|curthread
operator|->
name|last_active
operator|)
operator|*
operator|(
name|long
operator|)
name|_clock_res_usec
expr_stmt|;
comment|/* Check for time quantum exceeded: */
if|if
condition|(
name|curthread
operator|->
name|slice_usec
operator|>
name|TIMESLICE_USEC
condition|)
name|curthread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|curthread
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * The thread exceeded its time 				 * quantum or it yielded the CPU; 				 * place it at the tail of the 				 * queue for its priority. 				 */
name|PTHREAD_PRIOQ_INSERT_TAIL
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The thread hasn't exceeded its 				 * interval.  Place it at the head 				 * of the queue for its priority. 				 */
name|PTHREAD_PRIOQ_INSERT_HEAD
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Get the highest priority thread in the ready queue. 		 */
name|pthread_h
operator|=
name|PTHREAD_PRIOQ_FIRST
argument_list|()
expr_stmt|;
comment|/* Check if there are no threads ready to run: */
if|if
condition|(
name|pthread_h
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Lock the pthread kernel by changing the pointer to 			 * the running thread to point to the global kernel 			 * thread structure: 			 */
name|_set_curthread
argument_list|(
operator|&
name|_thread_kern_thread
argument_list|)
expr_stmt|;
name|curthread
operator|=
operator|&
name|_thread_kern_thread
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"No runnable threads, using kernel thread %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unprotect the scheduling queues: */
name|_queue_signals
operator|=
literal|0
expr_stmt|;
comment|/* 			 * There are no threads ready to run, so wait until 			 * something happens that changes this condition: 			 */
name|thread_kern_poll
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * This process' usage will likely be very small 			 * while waiting in a poll.  Since the scheduling 			 * clock is based on the profiling timer, it is 			 * unlikely that the profiling timer will fire 			 * and update the time of day.  To account for this, 			 * get the time of day after polling with a timeout. 			 */
name|gettimeofday
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|&
name|_sched_tod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check once more for a runnable thread: */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
name|pthread_h
operator|=
name|PTHREAD_PRIOQ_FIRST
argument_list|()
expr_stmt|;
name|_queue_signals
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pthread_h
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove the thread from the ready queue: */
name|PTHREAD_PRIOQ_REMOVE
argument_list|(
name|pthread_h
argument_list|)
expr_stmt|;
comment|/* Unprotect the scheduling queues: */
name|_queue_signals
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Check for signals queued while the scheduling 			 * queues were protected: 			 */
while|while
condition|(
name|_sigq_check_reqd
operator|!=
literal|0
condition|)
block|{
comment|/* Clear before handling queued signals: */
name|_sigq_check_reqd
operator|=
literal|0
expr_stmt|;
comment|/* Protect the scheduling queues again: */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
name|dequeue_signals
argument_list|()
expr_stmt|;
comment|/* 				 * Check for a higher priority thread that 				 * became runnable due to signal handling. 				 */
if|if
condition|(
operator|(
operator|(
name|pthread
operator|=
name|PTHREAD_PRIOQ_FIRST
argument_list|()
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|active_priority
operator|>
name|pthread_h
operator|->
name|active_priority
operator|)
condition|)
block|{
comment|/* Remove the thread from the ready queue: */
name|PTHREAD_PRIOQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
comment|/* 					 * Insert the lower priority thread 					 * at the head of its priority list: 					 */
name|PTHREAD_PRIOQ_INSERT_HEAD
argument_list|(
name|pthread_h
argument_list|)
expr_stmt|;
comment|/* There's a new thread in town: */
name|pthread_h
operator|=
name|pthread
expr_stmt|;
block|}
comment|/* Unprotect the scheduling queues: */
name|_queue_signals
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make the selected thread the current thread: */
name|_set_curthread
argument_list|(
name|pthread_h
argument_list|)
expr_stmt|;
name|curthread
operator|=
name|pthread_h
expr_stmt|;
comment|/* 			 * Save the current time as the time that the thread 			 * became active: 			 */
name|current_tick
operator|=
name|_sched_ticks
expr_stmt|;
name|curthread
operator|->
name|last_active
operator|=
operator|(
name|long
operator|)
name|current_tick
expr_stmt|;
comment|/* 			 * Check if this thread is running for the first time 			 * or running again after using its full time slice 			 * allocation: 			 */
if|if
condition|(
name|curthread
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Reset the accumulated time slice period: */
name|curthread
operator|->
name|slice_usec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * If we had a context switch, run any 			 * installed switch hooks. 			 */
if|if
condition|(
operator|(
name|_sched_switch_hook
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|_last_user_thread
operator|!=
name|curthread
operator|)
condition|)
block|{
name|thread_run_switch_hook
argument_list|(
name|_last_user_thread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Continue the thread at its current frame: 			 */
if|#
directive|if
name|NOT_YET
name|_setcontext
argument_list|(
operator|&
name|curthread
operator|->
name|ctx
operator|.
name|uc
argument_list|)
expr_stmt|;
else|#
directive|else
name|___longjmp
argument_list|(
name|curthread
operator|->
name|ctx
operator|.
name|jb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This point should not be reached. */
name|PANIC
argument_list|(
literal|"Thread has returned from sigreturn or longjmp"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There are no more threads, so exit this process: */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thread_kern_sched_state
parameter_list|(
name|enum
name|pthread_state
name|state
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
comment|/* 	 * Flag the pthread kernel as executing scheduler code 	 * to avoid a scheduler signal from interrupting this 	 * execution and calling the scheduler again. 	 */
name|_thread_kern_in_sched
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Prevent the signal handler from fiddling with this thread 	 * before its state is set and is placed into the proper queue. 	 */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
comment|/* Change the state of the current thread: */
name|curthread
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|curthread
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|curthread
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
comment|/* Schedule the next thread that is ready: */
name|_thread_kern_sched
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thread_kern_sched_state_unlock
parameter_list|(
name|enum
name|pthread_state
name|state
parameter_list|,
name|spinlock_t
modifier|*
name|lock
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
comment|/* 	 * Flag the pthread kernel as executing scheduler code 	 * to avoid a scheduler signal from interrupting this 	 * execution and calling the scheduler again. 	 */
name|_thread_kern_in_sched
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Prevent the signal handler from fiddling with this thread 	 * before its state is set and it is placed into the proper 	 * queue(s). 	 */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
comment|/* Change the state of the current thread: */
name|curthread
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|curthread
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|curthread
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|_SPINUNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* Schedule the next thread that is ready: */
name|_thread_kern_sched
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_kern_poll
parameter_list|(
name|int
name|wait_reqd
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|int
name|kern_pipe_added
init|=
literal|0
decl_stmt|;
name|int
name|nfds
init|=
literal|0
decl_stmt|;
name|int
name|timeout_ms
init|=
literal|0
decl_stmt|;
name|struct
name|pthread
modifier|*
name|pthread
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* Check if the caller wants to wait: */
if|if
condition|(
name|wait_reqd
operator|==
literal|0
condition|)
block|{
name|timeout_ms
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the current time of day: */
name|GET_CURRENT_TOD
argument_list|(
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|_queue_signals
operator|=
literal|1
expr_stmt|;
name|pthread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_waitingq
argument_list|)
expr_stmt|;
name|_queue_signals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pthread
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 			 * Either there are no threads in the waiting queue, 			 * or there are no threads that can timeout. 			 */
name|timeout_ms
operator|=
name|INFTIM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|-
name|ts
operator|.
name|tv_sec
operator|>
literal|60000
condition|)
comment|/* Limit maximum timeout to prevent rollover. */
name|timeout_ms
operator|=
literal|60000
expr_stmt|;
else|else
block|{
comment|/* 			 * Calculate the time left for the next thread to 			 * timeout: 			 */
name|timeout_ms
operator|=
operator|(
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|-
name|ts
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
operator|)
operator|+
operator|(
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|-
name|ts
operator|.
name|tv_nsec
operator|)
operator|/
literal|1000000
operator|)
expr_stmt|;
comment|/* 			 * Don't allow negative timeouts: 			 */
if|if
condition|(
name|timeout_ms
operator|<
literal|0
condition|)
name|timeout_ms
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Protect the scheduling queues: */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check to see if the signal queue needs to be walked to look 	 * for threads awoken by a signal while in the scheduler. 	 */
if|if
condition|(
name|_sigq_check_reqd
operator|!=
literal|0
condition|)
block|{
comment|/* Reset flag before handling queued signals: */
name|_sigq_check_reqd
operator|=
literal|0
expr_stmt|;
name|dequeue_signals
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Check for a thread that became runnable due to a signal: 	 */
if|if
condition|(
name|PTHREAD_PRIOQ_FIRST
argument_list|()
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Since there is at least one runnable thread, 		 * disable the wait. 		 */
name|timeout_ms
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Form the poll table: 	 */
name|nfds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|timeout_ms
operator|!=
literal|0
condition|)
block|{
comment|/* Add the kernel pipe to the poll table: */
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|fd
operator|=
name|_thread_kern_pipe
index|[
literal|0
index|]
expr_stmt|;
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|events
operator|=
name|POLLRDNORM
expr_stmt|;
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|nfds
operator|++
expr_stmt|;
name|kern_pipe_added
operator|=
literal|1
expr_stmt|;
block|}
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pthread
argument_list|,
argument|&_workq
argument_list|,
argument|qe
argument_list|)
block|{
switch|switch
condition|(
name|pthread
operator|->
name|state
condition|)
block|{
case|case
name|PS_SPINBLOCK
case|:
comment|/* 			 * If the lock is available, let the thread run. 			 */
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|spinlock
operator|->
name|access_lock
operator|==
literal|0
condition|)
block|{
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
comment|/* One less thread in a spinblock state: */
name|_spinblock_count
operator|--
expr_stmt|;
comment|/* 				 * Since there is at least one runnable 				 * thread, disable the wait. 				 */
name|timeout_ms
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|/* File descriptor read wait: */
case|case
name|PS_FDR_WAIT
case|:
comment|/* Limit number of polled files to table size: */
if|if
condition|(
name|nfds
operator|<
name|_thread_dtablesize
condition|)
block|{
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|events
operator|=
name|POLLRDNORM
expr_stmt|;
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|fd
operator|=
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
expr_stmt|;
name|nfds
operator|++
expr_stmt|;
block|}
break|break;
comment|/* File descriptor write wait: */
case|case
name|PS_FDW_WAIT
case|:
comment|/* Limit number of polled files to table size: */
if|if
condition|(
name|nfds
operator|<
name|_thread_dtablesize
condition|)
block|{
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|events
operator|=
name|POLLWRNORM
expr_stmt|;
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|fd
operator|=
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
expr_stmt|;
name|nfds
operator|++
expr_stmt|;
block|}
break|break;
comment|/* File descriptor poll or select wait: */
case|case
name|PS_POLL_WAIT
case|:
case|case
name|PS_SELECT_WAIT
case|:
comment|/* Limit number of polled files to table size: */
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
operator|+
name|nfds
operator|<
name|_thread_dtablesize
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
condition|;
name|i
operator|++
control|)
block|{
name|_thread_pfd_table
index|[
name|nfds
operator|+
name|i
index|]
operator|.
name|fd
operator|=
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|fds
index|[
name|i
index|]
operator|.
name|fd
expr_stmt|;
name|_thread_pfd_table
index|[
name|nfds
operator|+
name|i
index|]
operator|.
name|events
operator|=
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|fds
index|[
name|i
index|]
operator|.
name|events
expr_stmt|;
block|}
name|nfds
operator|+=
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
expr_stmt|;
block|}
break|break;
comment|/* Other states do not depend on file I/O. */
default|default:
break|break;
block|}
block|}
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
comment|/* 	 * Wait for a file descriptor to be ready for read, write, or 	 * an exception, or a timeout to occur: 	 */
name|count
operator|=
name|__sys_poll
argument_list|(
name|_thread_pfd_table
argument_list|,
name|nfds
argument_list|,
name|timeout_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|kern_pipe_added
operator|!=
literal|0
condition|)
comment|/* 		 * Remove the pthread kernel pipe file descriptor 		 * from the pollfd table: 		 */
name|nfds
operator|=
literal|1
expr_stmt|;
else|else
name|nfds
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check if it is possible that there are bytes in the kernel 	 * read pipe waiting to be read: 	 */
if|if
condition|(
name|count
operator|<
literal|0
operator|||
operator|(
operator|(
name|kern_pipe_added
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|_thread_pfd_table
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLRDNORM
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If the kernel read pipe was included in the 		 * count: 		 */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* Decrement the count of file descriptors: */
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|_sigq_check_reqd
operator|!=
literal|0
condition|)
block|{
comment|/* Reset flag before handling signals: */
name|_sigq_check_reqd
operator|=
literal|0
expr_stmt|;
name|dequeue_signals
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Check if any file descriptors are ready: 	 */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Enter a loop to look for threads waiting on file 		 * descriptors that are flagged as available by the 		 * _poll syscall: 		 */
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pthread
argument_list|,
argument|&_workq
argument_list|,
argument|qe
argument_list|)
block|{
switch|switch
condition|(
name|pthread
operator|->
name|state
condition|)
block|{
case|case
name|PS_SPINBLOCK
case|:
comment|/* 				 * If the lock is available, let the thread run. 				 */
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|spinlock
operator|->
name|access_lock
operator|==
literal|0
condition|)
block|{
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
comment|/* 					 * One less thread in a spinblock state: 					 */
name|_spinblock_count
operator|--
expr_stmt|;
block|}
break|break;
comment|/* File descriptor read wait: */
case|case
name|PS_FDR_WAIT
case|:
if|if
condition|(
operator|(
name|nfds
operator|<
name|_thread_dtablesize
operator|)
operator|&&
operator|(
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLRDNORM
operator||
name|POLLERR
operator||
name|POLLHUP
operator||
name|POLLNVAL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
block|}
name|nfds
operator|++
expr_stmt|;
break|break;
comment|/* File descriptor write wait: */
case|case
name|PS_FDW_WAIT
case|:
if|if
condition|(
operator|(
name|nfds
operator|<
name|_thread_dtablesize
operator|)
operator|&&
operator|(
name|_thread_pfd_table
index|[
name|nfds
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLWRNORM
operator||
name|POLLERR
operator||
name|POLLHUP
operator||
name|POLLNVAL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
block|}
name|nfds
operator|++
expr_stmt|;
break|break;
comment|/* File descriptor poll or select wait: */
case|case
name|PS_POLL_WAIT
case|:
case|case
name|PS_SELECT_WAIT
case|:
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
operator|+
name|nfds
operator|<
name|_thread_dtablesize
condition|)
block|{
comment|/* 					 * Enter a loop looking for I/O 					 * readiness: 					 */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_thread_pfd_table
index|[
name|nfds
operator|+
name|i
index|]
operator|.
name|revents
operator|!=
literal|0
condition|)
block|{
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|fds
index|[
name|i
index|]
operator|.
name|revents
operator|=
name|_thread_pfd_table
index|[
name|nfds
operator|+
name|i
index|]
operator|.
name|revents
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
comment|/* Increment before destroying: */
name|nfds
operator|+=
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
expr_stmt|;
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
block|{
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
operator|=
name|found
expr_stmt|;
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|nfds
operator|+=
name|pthread
operator|->
name|data
operator|.
name|poll_data
operator|->
name|nfds
expr_stmt|;
break|break;
comment|/* Other states do not depend on file I/O. */
default|default:
break|break;
block|}
block|}
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_spinblock_count
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Enter a loop to look for threads waiting on a spinlock 		 * that is now available. 		 */
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pthread
argument_list|,
argument|&_workq
argument_list|,
argument|qe
argument_list|)
block|{
if|if
condition|(
name|pthread
operator|->
name|state
operator|==
name|PS_SPINBLOCK
condition|)
block|{
comment|/* 				 * If the lock is available, let the thread run. 				 */
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|spinlock
operator|->
name|access_lock
operator|==
literal|0
condition|)
block|{
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|PTHREAD_WAITQ_SETACTIVE
argument_list|()
expr_stmt|;
comment|/* 					 * One less thread in a spinblock state: 					 */
name|_spinblock_count
operator|--
expr_stmt|;
block|}
block|}
block|}
name|PTHREAD_WAITQ_CLEARACTIVE
argument_list|()
expr_stmt|;
block|}
comment|/* Unprotect the scheduling queues: */
name|_queue_signals
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|_sigq_check_reqd
operator|!=
literal|0
condition|)
block|{
comment|/* Handle queued signals: */
name|_sigq_check_reqd
operator|=
literal|0
expr_stmt|;
comment|/* Protect the scheduling queues: */
name|_queue_signals
operator|=
literal|1
expr_stmt|;
name|dequeue_signals
argument_list|()
expr_stmt|;
comment|/* Unprotect the scheduling queues: */
name|_queue_signals
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_thread_kern_set_timeout
parameter_list|(
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|struct
name|timespec
name|current_time
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* Reset the timeout flag for the running thread: */
name|curthread
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Check if the thread is to wait forever: */
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Set the wakeup time to something that can be recognised as 		 * different to an actual time of day: 		 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Check if no waiting is required: */
elseif|else
if|if
condition|(
name|timeout
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|timeout
operator|->
name|tv_nsec
operator|==
literal|0
condition|)
block|{
comment|/* Set the wake up time to 'immediately': */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the current time: */
name|GET_CURRENT_TOD
argument_list|(
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|current_time
argument_list|)
expr_stmt|;
comment|/* Calculate the time for the current thread to wake up: */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
name|current_time
operator|.
name|tv_sec
operator|+
name|timeout
operator|->
name|tv_sec
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
name|current_time
operator|.
name|tv_nsec
operator|+
name|timeout
operator|->
name|tv_nsec
expr_stmt|;
comment|/* Check if the nanosecond field needs to wrap: */
if|if
condition|(
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|>=
literal|1000000000
condition|)
block|{
comment|/* Wrap the nanosecond field: */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|+=
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|-=
literal|1000000000
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|_thread_kern_sig_defer
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
comment|/* Allow signal deferral to be recursive. */
name|curthread
operator|->
name|sig_defer_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thread_kern_sig_undefer
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
comment|/* 	 * Perform checks to yield only if we are about to undefer 	 * signals. 	 */
if|if
condition|(
name|curthread
operator|->
name|sig_defer_count
operator|>
literal|1
condition|)
block|{
comment|/* Decrement the signal deferral count. */
name|curthread
operator|->
name|sig_defer_count
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curthread
operator|->
name|sig_defer_count
operator|==
literal|1
condition|)
block|{
comment|/* Reenable signals: */
name|curthread
operator|->
name|sig_defer_count
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Check if there are queued signals: 		 */
if|if
condition|(
name|_sigq_check_reqd
operator|!=
literal|0
condition|)
name|_thread_kern_sched
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Check for asynchronous cancellation before delivering any 		 * pending signals: 		 */
if|if
condition|(
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_AT_CANCEL_POINT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_CANCEL_ASYNCHRONOUS
operator|)
operator|!=
literal|0
operator|)
condition|)
name|pthread_testcancel
argument_list|()
expr_stmt|;
comment|/* 		 * If there are pending signals or this thread has 		 * to yield the CPU, call the kernel scheduler: 		 * 		 * XXX - Come back and revisit the pending signal problem 		 */
if|if
condition|(
operator|(
name|curthread
operator|->
name|yield_on_sig_undefer
operator|!=
literal|0
operator|)
operator|||
name|SIGNOTEMPTY
argument_list|(
name|curthread
operator|->
name|sigpend
argument_list|)
condition|)
block|{
name|curthread
operator|->
name|yield_on_sig_undefer
operator|=
literal|0
expr_stmt|;
name|_thread_kern_sched
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dequeue_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|bufr
index|[
literal|128
index|]
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* 	 * Enter a loop to clear the pthread kernel pipe: 	 */
while|while
condition|(
operator|(
operator|(
name|num
operator|=
name|__sys_read
argument_list|(
name|_thread_kern_pipe
index|[
literal|0
index|]
argument_list|,
name|bufr
argument_list|,
sizeof|sizeof
argument_list|(
name|bufr
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|num
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|)
condition|)
block|{ 	}
if|if
condition|(
operator|(
name|num
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EAGAIN
operator|)
condition|)
block|{
comment|/* 		 * The only error we should expect is if there is 		 * no data to read. 		 */
name|PANIC
argument_list|(
literal|"Unable to read from thread kernel pipe"
argument_list|)
expr_stmt|;
block|}
comment|/* Handle any pending signals: */
name|_thread_sig_handle_pending
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|thread_run_switch_hook
parameter_list|(
name|pthread_t
name|thread_out
parameter_list|,
name|pthread_t
name|thread_in
parameter_list|)
block|{
name|pthread_t
name|tid_out
init|=
name|thread_out
decl_stmt|;
name|pthread_t
name|tid_in
init|=
name|thread_in
decl_stmt|;
if|if
condition|(
operator|(
name|tid_out
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tid_out
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_PRIVATE
operator|)
operator|!=
literal|0
condition|)
name|tid_out
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|tid_in
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tid_in
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_PRIVATE
operator|)
operator|!=
literal|0
condition|)
name|tid_in
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|_sched_switch_hook
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tid_out
operator|!=
name|tid_in
operator|)
condition|)
block|{
comment|/* Run the scheduler switch hook: */
name|_sched_switch_hook
argument_list|(
name|tid_out
argument_list|,
name|tid_in
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|pthread
modifier|*
name|_get_curthread
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|_thread_initial
operator|==
name|NULL
condition|)
name|_thread_init
argument_list|()
expr_stmt|;
return|return
operator|(
name|_thread_run
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_set_curthread
parameter_list|(
name|struct
name|pthread
modifier|*
name|newthread
parameter_list|)
block|{
name|_thread_run
operator|=
name|newthread
expr_stmt|;
block|}
end_function

end_unit

