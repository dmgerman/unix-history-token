begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 - 2002 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *   * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: getifaddrs.c,v 1.9 2002/09/05 03:36:23 assar Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"roken.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__osf__
end_ifdef

begin_comment
comment|/* hate */
end_comment

begin_struct_decl
struct_decl|struct
name|rtentry
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|mbuf
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NET_IF_H
end_ifdef

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_SOCKIO_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN6_VAR_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINET_IN6_VAR_H */
end_comment

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AF_NETLINK
end_ifdef

begin_comment
comment|/*  * The linux - AF_NETLINK version of getifaddrs - from Usagi.  * Linux does not return v6 addresses from SIOCGIFCONF.  */
end_comment

begin_comment
comment|/* $USAGI: ifaddrs.c,v 1.18 2002/03/06 01:50:46 yoshfuji Exp $ */
end_comment

begin_comment
comment|/**************************************************************************  * ifaddrs.c  * Copyright (C)2000 Hideaki YOSHIFUJI, All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<asm/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/netlink.h>
end_include

begin_include
include|#
directive|include
file|<linux/rtnetlink.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netpacket/packet.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_comment
comment|/* the L2 protocols */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_define
define|#
directive|define
name|__set_errno
parameter_list|(
name|e
parameter_list|)
value|(errno = (e))
end_define

begin_define
define|#
directive|define
name|__close
parameter_list|(
name|fd
parameter_list|)
value|(close(fd))
end_define

begin_undef
undef|#
directive|undef
name|ifa_broadaddr
end_undef

begin_define
define|#
directive|define
name|ifa_broadaddr
value|ifa_dstaddr
end_define

begin_define
define|#
directive|define
name|IFA_NETMASK
end_define

begin_comment
comment|/* ====================================================================== */
end_comment

begin_struct
struct|struct
name|nlmsg_list
block|{
name|struct
name|nlmsg_list
modifier|*
name|nlm_next
decl_stmt|;
name|struct
name|nlmsghdr
modifier|*
name|nlh
decl_stmt|;
name|int
name|size
decl_stmt|;
name|time_t
name|seq
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rtmaddr_ifamap
block|{
name|void
modifier|*
name|address
decl_stmt|;
name|void
modifier|*
name|local
decl_stmt|;
ifdef|#
directive|ifdef
name|IFA_NETMASK
name|void
modifier|*
name|netmask
decl_stmt|;
endif|#
directive|endif
name|void
modifier|*
name|broadcast
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IFADDRS_IFA_ANYCAST
name|void
modifier|*
name|anycast
decl_stmt|;
endif|#
directive|endif
name|int
name|address_len
decl_stmt|;
name|int
name|local_len
decl_stmt|;
ifdef|#
directive|ifdef
name|IFA_NETMASK
name|int
name|netmask_len
decl_stmt|;
endif|#
directive|endif
name|int
name|broadcast_len
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IFADDRS_IFA_ANYCAST
name|int
name|anycast_len
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* ====================================================================== */
end_comment

begin_function
specifier|static
name|size_t
name|ifa_sa_len
parameter_list|(
name|sa_family_t
name|family
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_PACKET
case|:
name|size
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_ll
operator|*
operator|)
name|NULL
operator|)
operator|->
name|sll_addr
argument_list|)
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ll
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ll
argument_list|)
expr_stmt|;
break|break;
default|default:
name|size
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
operator|)
operator|->
name|sa_data
argument_list|)
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ifa_make_sockaddr
parameter_list|(
name|sa_family_t
name|family
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint32_t
name|scope
parameter_list|,
name|uint32_t
name|scopeid
parameter_list|)
block|{
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|p
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
name|p
argument_list|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_scope_id
operator|=
name|scopeid
expr_stmt|;
block|}
break|break;
case|case
name|AF_PACKET
case|:
name|memcpy
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_ll
operator|*
operator|)
name|sa
operator|)
operator|->
name|sll_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_ll
operator|*
operator|)
name|sa
operator|)
operator|->
name|sll_halen
operator|=
name|len
expr_stmt|;
break|break;
default|default:
name|memcpy
argument_list|(
name|sa
operator|->
name|sa_data
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*XXX*/
break|break;
block|}
name|sa
operator|->
name|sa_family
operator|=
name|family
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOCKADDR_SA_LEN
name|sa
operator|->
name|sa_len
operator|=
name|ifa_sa_len
argument_list|(
name|family
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IFA_NETMASK
end_ifndef

begin_function
specifier|static
name|struct
name|sockaddr
modifier|*
name|ifa_make_sockaddr_mask
parameter_list|(
name|sa_family_t
name|family
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint32_t
name|prefixlen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|,
name|c
decl_stmt|;
name|uint32_t
name|max_prefixlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|memset
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|max_prefixlen
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|memset
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: fill scope-id? */
block|if (IN6_IS_ADDR_LINKLOCAL(p) || 	IN6_IS_ADDR_MC_LINKLOCAL(p)){       ((struct sockaddr_in6*)sa)->sin6_scope_id = scopeid;     }
endif|#
directive|endif
name|max_prefixlen
operator|=
literal|128
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
name|sa
operator|->
name|sa_family
operator|=
name|family
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOCKADDR_SA_LEN
name|sa
operator|->
name|sa_len
operator|=
name|ifa_sa_len
argument_list|(
name|family
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|prefixlen
operator|>
name|max_prefixlen
condition|)
name|prefixlen
operator|=
name|max_prefixlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|prefixlen
operator|/
literal|8
operator|)
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
name|c
operator|=
literal|0xff
expr_stmt|;
name|c
operator|<<=
operator|(
literal|8
operator|-
operator|(
name|prefixlen
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
return|return
name|sa
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ====================================================================== */
end_comment

begin_function
specifier|static
name|int
name|nl_sendreq
parameter_list|(
name|int
name|sd
parameter_list|,
name|int
name|request
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|seq
parameter_list|)
block|{
name|char
name|reqbuf
index|[
name|NLMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlmsghdr
argument_list|)
argument_list|)
operator|+
name|NLMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtgenmsg
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|struct
name|sockaddr_nl
name|nladdr
decl_stmt|;
name|struct
name|nlmsghdr
modifier|*
name|req_hdr
decl_stmt|;
name|struct
name|rtgenmsg
modifier|*
name|req_msg
decl_stmt|;
name|time_t
name|t
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
condition|)
operator|*
name|seq
operator|=
name|t
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reqbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reqbuf
argument_list|)
argument_list|)
expr_stmt|;
name|req_hdr
operator|=
operator|(
expr|struct
name|nlmsghdr
operator|*
operator|)
name|reqbuf
expr_stmt|;
name|req_msg
operator|=
operator|(
expr|struct
name|rtgenmsg
operator|*
operator|)
name|NLMSG_DATA
argument_list|(
name|req_hdr
argument_list|)
expr_stmt|;
name|req_hdr
operator|->
name|nlmsg_len
operator|=
name|NLMSG_LENGTH
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req_msg
argument_list|)
argument_list|)
expr_stmt|;
name|req_hdr
operator|->
name|nlmsg_type
operator|=
name|request
expr_stmt|;
name|req_hdr
operator|->
name|nlmsg_flags
operator|=
name|flags
operator||
name|NLM_F_REQUEST
expr_stmt|;
name|req_hdr
operator|->
name|nlmsg_pid
operator|=
literal|0
expr_stmt|;
name|req_hdr
operator|->
name|nlmsg_seq
operator|=
name|t
expr_stmt|;
name|req_msg
operator|->
name|rtgen_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|memset
argument_list|(
operator|&
name|nladdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nladdr
argument_list|)
argument_list|)
expr_stmt|;
name|nladdr
operator|.
name|nl_family
operator|=
name|AF_NETLINK
expr_stmt|;
return|return
operator|(
name|sendto
argument_list|(
name|sd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|req_hdr
argument_list|,
name|req_hdr
operator|->
name|nlmsg_len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nladdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nladdr
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nl_recvmsg
parameter_list|(
name|int
name|sd
parameter_list|,
name|int
name|request
parameter_list|,
name|int
name|seq
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
init|=
block|{
name|buf
block|,
name|buflen
block|}
decl_stmt|;
name|struct
name|sockaddr_nl
name|nladdr
decl_stmt|;
name|int
name|read_len
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|msg
operator|.
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|nladdr
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|nladdr
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|read_len
operator|=
name|recvmsg
argument_list|(
name|sd
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|read_len
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
operator|)
operator|||
operator|(
name|msg
operator|.
name|msg_flags
operator|&
name|MSG_TRUNC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|flags
condition|)
operator|*
name|flags
operator|=
name|msg
operator|.
name|msg_flags
expr_stmt|;
break|break;
block|}
return|return
name|read_len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nl_getmsg
parameter_list|(
name|int
name|sd
parameter_list|,
name|int
name|request
parameter_list|,
name|int
name|seq
parameter_list|,
name|struct
name|nlmsghdr
modifier|*
modifier|*
name|nlhp
parameter_list|,
name|int
modifier|*
name|done
parameter_list|)
block|{
name|struct
name|nlmsghdr
modifier|*
name|nh
decl_stmt|;
name|size_t
name|bufsize
init|=
literal|65536
decl_stmt|,
name|lastbufsize
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|,
name|read_size
decl_stmt|;
name|int
name|msg_flags
decl_stmt|;
name|pid_t
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|void
modifier|*
name|newbuff
init|=
name|realloc
argument_list|(
name|buff
argument_list|,
name|bufsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|newbuff
operator|==
name|NULL
operator|||
name|bufsize
operator|<
name|lastbufsize
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|buff
operator|=
name|newbuff
expr_stmt|;
name|result
operator|=
name|read_size
operator|=
name|nl_recvmsg
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|seq
argument_list|,
name|buff
argument_list|,
name|bufsize
argument_list|,
operator|&
name|msg_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_size
operator|<
literal|0
operator|||
operator|(
name|msg_flags
operator|&
name|MSG_TRUNC
operator|)
condition|)
block|{
name|lastbufsize
operator|=
name|bufsize
expr_stmt|;
name|bufsize
operator|*=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|read_size
operator|==
literal|0
condition|)
break|break;
name|nh
operator|=
operator|(
expr|struct
name|nlmsghdr
operator|*
operator|)
name|buff
expr_stmt|;
for|for
control|(
name|nh
operator|=
operator|(
expr|struct
name|nlmsghdr
operator|*
operator|)
name|buff
init|;
name|NLMSG_OK
argument_list|(
name|nh
argument_list|,
name|read_size
argument_list|)
condition|;
name|nh
operator|=
operator|(
expr|struct
name|nlmsghdr
operator|*
operator|)
name|NLMSG_NEXT
argument_list|(
name|nh
argument_list|,
name|read_size
argument_list|)
control|)
block|{
if|if
condition|(
name|nh
operator|->
name|nlmsg_pid
operator|!=
name|pid
operator|||
name|nh
operator|->
name|nlmsg_seq
operator|!=
name|seq
condition|)
continue|continue;
if|if
condition|(
name|nh
operator|->
name|nlmsg_type
operator|==
name|NLMSG_DONE
condition|)
block|{
operator|(
operator|*
name|done
operator|)
operator|++
expr_stmt|;
break|break;
comment|/* ok */
block|}
if|if
condition|(
name|nh
operator|->
name|nlmsg_type
operator|==
name|NLMSG_ERROR
condition|)
block|{
name|struct
name|nlmsgerr
modifier|*
name|nlerr
init|=
operator|(
expr|struct
name|nlmsgerr
operator|*
operator|)
name|NLMSG_DATA
argument_list|(
name|nh
argument_list|)
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nh
operator|->
name|nlmsg_len
operator|<
name|NLMSG_LENGTH
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlmsgerr
argument_list|)
argument_list|)
condition|)
name|__set_errno
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
else|else
name|__set_errno
argument_list|(
operator|-
name|nlerr
operator|->
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
if|if
condition|(
name|buff
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
operator|*
name|nlhp
operator|=
operator|(
expr|struct
name|nlmsghdr
operator|*
operator|)
name|buff
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nl_getlist
parameter_list|(
name|int
name|sd
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|request
parameter_list|,
name|struct
name|nlmsg_list
modifier|*
modifier|*
name|nlm_list
parameter_list|,
name|struct
name|nlmsg_list
modifier|*
modifier|*
name|nlm_end
parameter_list|)
block|{
name|struct
name|nlmsghdr
modifier|*
name|nlh
init|=
name|NULL
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|nl_sendreq
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|NLM_F_ROOT
operator||
name|NLM_F_MATCH
argument_list|,
operator|&
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
if|if
condition|(
name|seq
operator|==
literal|0
condition|)
name|seq
operator|=
operator|(
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|status
operator|=
name|nl_getmsg
argument_list|(
name|sd
argument_list|,
name|request
argument_list|,
name|seq
argument_list|,
operator|&
name|nlh
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
if|if
condition|(
name|nlh
condition|)
block|{
name|struct
name|nlmsg_list
modifier|*
name|nlm_next
init|=
operator|(
expr|struct
name|nlmsg_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlmsg_list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlm_next
operator|==
name|NULL
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|nlh
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nlm_next
operator|->
name|nlm_next
operator|=
name|NULL
expr_stmt|;
name|nlm_next
operator|->
name|nlh
operator|=
operator|(
expr|struct
name|nlmsghdr
operator|*
operator|)
name|nlh
expr_stmt|;
name|nlm_next
operator|->
name|size
operator|=
name|status
expr_stmt|;
name|nlm_next
operator|->
name|seq
operator|=
name|seq
expr_stmt|;
if|if
condition|(
operator|*
name|nlm_list
operator|==
name|NULL
condition|)
block|{
operator|*
name|nlm_list
operator|=
name|nlm_next
expr_stmt|;
operator|*
name|nlm_end
operator|=
name|nlm_next
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|nlm_end
operator|)
operator|->
name|nlm_next
operator|=
name|nlm_next
expr_stmt|;
operator|*
name|nlm_end
operator|=
name|nlm_next
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|status
operator|>=
literal|0
condition|?
name|seq
else|:
name|status
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|free_nlmsglist
parameter_list|(
name|struct
name|nlmsg_list
modifier|*
name|nlm0
parameter_list|)
block|{
name|struct
name|nlmsg_list
modifier|*
name|nlm
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
if|if
condition|(
operator|!
name|nlm0
condition|)
return|return;
name|saved_errno
operator|=
name|errno
expr_stmt|;
for|for
control|(
name|nlm
operator|=
name|nlm0
init|;
name|nlm
condition|;
name|nlm
operator|=
name|nlm
operator|->
name|nlm_next
control|)
block|{
if|if
condition|(
name|nlm
operator|->
name|nlh
condition|)
name|free
argument_list|(
name|nlm
operator|->
name|nlh
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nlm0
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_data
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|ifdata
parameter_list|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifdata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ifdata
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|nl_close
parameter_list|(
name|int
name|sd
parameter_list|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|sd
operator|>=
literal|0
condition|)
name|__close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|nl_open
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sockaddr_nl
name|nladdr
decl_stmt|;
name|int
name|sd
decl_stmt|;
name|sd
operator|=
name|socket
argument_list|(
name|PF_NETLINK
argument_list|,
name|SOCK_RAW
argument_list|,
name|NETLINK_ROUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
operator|&
name|nladdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nladdr
argument_list|)
argument_list|)
expr_stmt|;
name|nladdr
operator|.
name|nl_family
operator|=
name|AF_NETLINK
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nladdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nladdr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nl_close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/* ====================================================================== */
end_comment

begin_function
name|int
name|getifaddrs
parameter_list|(
name|struct
name|ifaddrs
modifier|*
modifier|*
name|ifap
parameter_list|)
block|{
name|int
name|sd
decl_stmt|;
name|struct
name|nlmsg_list
modifier|*
name|nlmsg_list
decl_stmt|,
modifier|*
name|nlmsg_end
decl_stmt|,
modifier|*
name|nlm
decl_stmt|;
comment|/* - - - - - - - - - - - - - - - */
name|int
name|icnt
decl_stmt|;
name|size_t
name|dlen
decl_stmt|,
name|xlen
decl_stmt|,
name|nlen
decl_stmt|;
name|uint32_t
name|max_ifindex
init|=
literal|0
decl_stmt|;
name|pid_t
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|int
name|seq
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|build
decl_stmt|;
comment|/* 0 or 1 */
comment|/* ---------------------------------- */
comment|/* initialize */
name|icnt
operator|=
name|dlen
operator|=
name|xlen
operator|=
name|nlen
operator|=
literal|0
expr_stmt|;
name|nlmsg_list
operator|=
name|nlmsg_end
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ifap
condition|)
operator|*
name|ifap
operator|=
name|NULL
expr_stmt|;
comment|/* ---------------------------------- */
comment|/* open socket and bind */
name|sd
operator|=
name|nl_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|sd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* ---------------------------------- */
comment|/* gather info */
if|if
condition|(
operator|(
name|seq
operator|=
name|nl_getlist
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|,
name|RTM_GETLINK
argument_list|,
operator|&
name|nlmsg_list
argument_list|,
operator|&
name|nlmsg_end
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_nlmsglist
argument_list|(
name|nlmsg_list
argument_list|)
expr_stmt|;
name|nl_close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|seq
operator|=
name|nl_getlist
argument_list|(
name|sd
argument_list|,
name|seq
operator|+
literal|1
argument_list|,
name|RTM_GETADDR
argument_list|,
operator|&
name|nlmsg_list
argument_list|,
operator|&
name|nlmsg_end
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_nlmsglist
argument_list|(
name|nlmsg_list
argument_list|)
expr_stmt|;
name|nl_close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* ---------------------------------- */
comment|/* Estimate size of result buffer and fill it */
for|for
control|(
name|build
operator|=
literal|0
init|;
name|build
operator|<=
literal|1
condition|;
name|build
operator|++
control|)
block|{
name|struct
name|ifaddrs
modifier|*
name|ifl
init|=
name|NULL
decl_stmt|,
modifier|*
name|ifa
init|=
name|NULL
decl_stmt|;
name|struct
name|nlmsghdr
modifier|*
name|nlh
decl_stmt|,
modifier|*
name|nlh0
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|,
modifier|*
name|xdata
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|ifdata
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ifname
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|iflist
init|=
name|NULL
decl_stmt|;
name|uint16_t
modifier|*
name|ifflist
init|=
name|NULL
decl_stmt|;
name|struct
name|rtmaddr_ifamap
name|ifamap
decl_stmt|;
if|if
condition|(
name|build
condition|)
block|{
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|NLMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifaddrs
index|[
name|icnt
index|]
argument_list|)
argument_list|)
operator|+
name|dlen
operator|+
name|xlen
operator|+
name|nlen
argument_list|)
expr_stmt|;
name|ifa
operator|=
operator|(
expr|struct
name|ifaddrs
operator|*
operator|)
name|data
expr_stmt|;
name|ifdata
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|NLMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
index|[
name|max_ifindex
operator|+
literal|1
index|]
argument_list|)
argument_list|)
operator|+
name|NLMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|uint16_t
index|[
name|max_ifindex
operator|+
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifap
operator|!=
name|NULL
condition|)
operator|*
name|ifap
operator|=
operator|(
name|ifdata
operator|!=
name|NULL
operator|)
condition|?
name|ifa
else|:
name|NULL
expr_stmt|;
else|else
block|{
name|free_data
argument_list|(
name|data
argument_list|,
name|ifdata
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|ifdata
operator|==
name|NULL
condition|)
block|{
name|free_data
argument_list|(
name|data
argument_list|,
name|ifdata
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|ifl
operator|=
name|NULL
expr_stmt|;
name|data
operator|+=
name|NLMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifaddrs
argument_list|)
argument_list|)
operator|*
name|icnt
expr_stmt|;
name|xdata
operator|=
name|data
operator|+
name|dlen
expr_stmt|;
name|ifname
operator|=
name|xdata
operator|+
name|xlen
expr_stmt|;
name|iflist
operator|=
name|ifdata
expr_stmt|;
name|ifflist
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|iflist
operator|)
operator|+
name|NLMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
index|[
name|max_ifindex
operator|+
literal|1
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
for|for
control|(
name|nlm
operator|=
name|nlmsg_list
init|;
name|nlm
condition|;
name|nlm
operator|=
name|nlm
operator|->
name|nlm_next
control|)
block|{
name|int
name|nlmlen
init|=
name|nlm
operator|->
name|size
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|nlh0
operator|=
name|nlm
operator|->
name|nlh
operator|)
condition|)
continue|continue;
for|for
control|(
name|nlh
operator|=
name|nlh0
init|;
name|NLMSG_OK
argument_list|(
name|nlh
argument_list|,
name|nlmlen
argument_list|)
condition|;
name|nlh
operator|=
name|NLMSG_NEXT
argument_list|(
name|nlh
argument_list|,
name|nlmlen
argument_list|)
control|)
block|{
name|struct
name|ifinfomsg
modifier|*
name|ifim
init|=
name|NULL
decl_stmt|;
name|struct
name|ifaddrmsg
modifier|*
name|ifam
init|=
name|NULL
decl_stmt|;
name|struct
name|rtattr
modifier|*
name|rta
decl_stmt|;
name|size_t
name|nlm_struct_size
init|=
literal|0
decl_stmt|;
name|sa_family_t
name|nlm_family
init|=
literal|0
decl_stmt|;
name|uint32_t
name|nlm_scope
init|=
literal|0
decl_stmt|,
name|nlm_index
init|=
literal|0
decl_stmt|;
name|size_t
name|sockaddr_size
init|=
literal|0
decl_stmt|;
name|uint32_t
name|nlm_prefixlen
init|=
literal|0
decl_stmt|;
name|size_t
name|rtasize
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifamap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifamap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check if the message is what we want */
if|if
condition|(
name|nlh
operator|->
name|nlmsg_pid
operator|!=
name|pid
operator|||
name|nlh
operator|->
name|nlmsg_seq
operator|!=
name|nlm
operator|->
name|seq
condition|)
continue|continue;
if|if
condition|(
name|nlh
operator|->
name|nlmsg_type
operator|==
name|NLMSG_DONE
condition|)
block|{
break|break;
comment|/* ok */
block|}
switch|switch
condition|(
name|nlh
operator|->
name|nlmsg_type
condition|)
block|{
case|case
name|RTM_NEWLINK
case|:
name|ifim
operator|=
operator|(
expr|struct
name|ifinfomsg
operator|*
operator|)
name|NLMSG_DATA
argument_list|(
name|nlh
argument_list|)
expr_stmt|;
name|nlm_struct_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifim
argument_list|)
expr_stmt|;
name|nlm_family
operator|=
name|ifim
operator|->
name|ifi_family
expr_stmt|;
name|nlm_scope
operator|=
literal|0
expr_stmt|;
name|nlm_index
operator|=
name|ifim
operator|->
name|ifi_index
expr_stmt|;
name|nlm_prefixlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|build
condition|)
name|ifflist
index|[
name|nlm_index
index|]
operator|=
name|ifa
operator|->
name|ifa_flags
operator|=
name|ifim
operator|->
name|ifi_flags
expr_stmt|;
break|break;
case|case
name|RTM_NEWADDR
case|:
name|ifam
operator|=
operator|(
expr|struct
name|ifaddrmsg
operator|*
operator|)
name|NLMSG_DATA
argument_list|(
name|nlh
argument_list|)
expr_stmt|;
name|nlm_struct_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifam
argument_list|)
expr_stmt|;
name|nlm_family
operator|=
name|ifam
operator|->
name|ifa_family
expr_stmt|;
name|nlm_scope
operator|=
name|ifam
operator|->
name|ifa_scope
expr_stmt|;
name|nlm_index
operator|=
name|ifam
operator|->
name|ifa_index
expr_stmt|;
name|nlm_prefixlen
operator|=
name|ifam
operator|->
name|ifa_prefixlen
expr_stmt|;
if|if
condition|(
name|build
condition|)
name|ifa
operator|->
name|ifa_flags
operator|=
name|ifflist
index|[
name|nlm_index
index|]
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
operator|!
name|build
condition|)
block|{
if|if
condition|(
name|max_ifindex
operator|<
name|nlm_index
condition|)
name|max_ifindex
operator|=
name|nlm_index
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifl
operator|!=
name|NULL
condition|)
name|ifl
operator|->
name|ifa_next
operator|=
name|ifa
expr_stmt|;
block|}
name|rtasize
operator|=
name|NLMSG_PAYLOAD
argument_list|(
name|nlh
argument_list|,
name|nlmlen
argument_list|)
operator|-
name|NLMSG_ALIGN
argument_list|(
name|nlm_struct_size
argument_list|)
expr_stmt|;
for|for
control|(
name|rta
operator|=
operator|(
expr|struct
name|rtattr
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|NLMSG_DATA
argument_list|(
name|nlh
argument_list|)
operator|)
operator|+
name|NLMSG_ALIGN
argument_list|(
name|nlm_struct_size
argument_list|)
operator|)
init|;
name|RTA_OK
argument_list|(
name|rta
argument_list|,
name|rtasize
argument_list|)
condition|;
name|rta
operator|=
name|RTA_NEXT
argument_list|(
name|rta
argument_list|,
name|rtasize
argument_list|)
control|)
block|{
name|struct
name|sockaddr
modifier|*
modifier|*
name|sap
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|rtadata
init|=
name|RTA_DATA
argument_list|(
name|rta
argument_list|)
decl_stmt|;
name|size_t
name|rtapayload
init|=
name|RTA_PAYLOAD
argument_list|(
name|rta
argument_list|)
decl_stmt|;
name|socklen_t
name|sa_len
decl_stmt|;
switch|switch
condition|(
name|nlh
operator|->
name|nlmsg_type
condition|)
block|{
case|case
name|RTM_NEWLINK
case|:
switch|switch
condition|(
name|rta
operator|->
name|rta_type
condition|)
block|{
case|case
name|IFLA_ADDRESS
case|:
case|case
name|IFLA_BROADCAST
case|:
if|if
condition|(
name|build
condition|)
block|{
name|sap
operator|=
operator|(
name|rta
operator|->
name|rta_type
operator|==
name|IFLA_ADDRESS
operator|)
condition|?
operator|&
name|ifa
operator|->
name|ifa_addr
else|:
operator|&
name|ifa
operator|->
name|ifa_broadaddr
expr_stmt|;
operator|*
name|sap
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|data
expr_stmt|;
block|}
name|sa_len
operator|=
name|ifa_sa_len
argument_list|(
name|AF_PACKET
argument_list|,
name|rtapayload
argument_list|)
expr_stmt|;
if|if
condition|(
name|rta
operator|->
name|rta_type
operator|==
name|IFLA_ADDRESS
condition|)
name|sockaddr_size
operator|=
name|NLMSG_ALIGN
argument_list|(
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|build
condition|)
block|{
name|dlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|*
name|sap
argument_list|,
literal|0
argument_list|,
name|sa_len
argument_list|)
expr_stmt|;
name|ifa_make_sockaddr
argument_list|(
name|AF_PACKET
argument_list|,
operator|*
name|sap
argument_list|,
name|rtadata
argument_list|,
name|rtapayload
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_ll
operator|*
operator|)
operator|*
name|sap
operator|)
operator|->
name|sll_ifindex
operator|=
name|nlm_index
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_ll
operator|*
operator|)
operator|*
name|sap
operator|)
operator|->
name|sll_hatype
operator|=
name|ifim
operator|->
name|ifi_type
expr_stmt|;
name|data
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|sa_len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IFLA_IFNAME
case|:
comment|/* Name of Interface */
if|if
condition|(
operator|!
name|build
condition|)
name|nlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|rtapayload
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|ifa
operator|->
name|ifa_name
operator|=
name|ifname
expr_stmt|;
if|if
condition|(
name|iflist
index|[
name|nlm_index
index|]
operator|==
name|NULL
condition|)
name|iflist
index|[
name|nlm_index
index|]
operator|=
name|ifa
operator|->
name|ifa_name
expr_stmt|;
name|strncpy
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|,
name|rtadata
argument_list|,
name|rtapayload
argument_list|)
expr_stmt|;
name|ifa
operator|->
name|ifa_name
index|[
name|rtapayload
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ifname
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|rtapayload
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IFLA_STATS
case|:
comment|/* Statistics of Interface */
if|if
condition|(
operator|!
name|build
condition|)
name|xlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|rtapayload
argument_list|)
expr_stmt|;
else|else
block|{
name|ifa
operator|->
name|ifa_data
operator|=
name|xdata
expr_stmt|;
name|memcpy
argument_list|(
name|ifa
operator|->
name|ifa_data
argument_list|,
name|rtadata
argument_list|,
name|rtapayload
argument_list|)
expr_stmt|;
name|xdata
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|rtapayload
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IFLA_UNSPEC
case|:
break|break;
case|case
name|IFLA_MTU
case|:
break|break;
case|case
name|IFLA_LINK
case|:
break|break;
case|case
name|IFLA_QDISC
case|:
break|break;
default|default:
block|}
break|break;
case|case
name|RTM_NEWADDR
case|:
if|if
condition|(
name|nlm_family
operator|==
name|AF_PACKET
condition|)
break|break;
switch|switch
condition|(
name|rta
operator|->
name|rta_type
condition|)
block|{
case|case
name|IFA_ADDRESS
case|:
name|ifamap
operator|.
name|address
operator|=
name|rtadata
expr_stmt|;
name|ifamap
operator|.
name|address_len
operator|=
name|rtapayload
expr_stmt|;
break|break;
case|case
name|IFA_LOCAL
case|:
name|ifamap
operator|.
name|local
operator|=
name|rtadata
expr_stmt|;
name|ifamap
operator|.
name|local_len
operator|=
name|rtapayload
expr_stmt|;
break|break;
case|case
name|IFA_BROADCAST
case|:
name|ifamap
operator|.
name|broadcast
operator|=
name|rtadata
expr_stmt|;
name|ifamap
operator|.
name|broadcast_len
operator|=
name|rtapayload
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_IFADDRS_IFA_ANYCAST
case|case
name|IFA_ANYCAST
case|:
name|ifamap
operator|.
name|anycast
operator|=
name|rtadata
expr_stmt|;
name|ifamap
operator|.
name|anycast_len
operator|=
name|rtapayload
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IFA_LABEL
case|:
if|if
condition|(
operator|!
name|build
condition|)
name|nlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|rtapayload
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|ifa
operator|->
name|ifa_name
operator|=
name|ifname
expr_stmt|;
if|if
condition|(
name|iflist
index|[
name|nlm_index
index|]
operator|==
name|NULL
condition|)
name|iflist
index|[
name|nlm_index
index|]
operator|=
name|ifname
expr_stmt|;
name|strncpy
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|,
name|rtadata
argument_list|,
name|rtapayload
argument_list|)
expr_stmt|;
name|ifa
operator|->
name|ifa_name
index|[
name|rtapayload
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ifname
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|rtapayload
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IFA_UNSPEC
case|:
break|break;
case|case
name|IFA_CACHEINFO
case|:
break|break;
default|default:
block|}
block|}
block|}
if|if
condition|(
name|nlh
operator|->
name|nlmsg_type
operator|==
name|RTM_NEWADDR
operator|&&
name|nlm_family
operator|!=
name|AF_PACKET
condition|)
block|{
if|if
condition|(
operator|!
name|ifamap
operator|.
name|local
condition|)
block|{
name|ifamap
operator|.
name|local
operator|=
name|ifamap
operator|.
name|address
expr_stmt|;
name|ifamap
operator|.
name|local_len
operator|=
name|ifamap
operator|.
name|address_len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ifamap
operator|.
name|address
condition|)
block|{
name|ifamap
operator|.
name|address
operator|=
name|ifamap
operator|.
name|local
expr_stmt|;
name|ifamap
operator|.
name|address_len
operator|=
name|ifamap
operator|.
name|local_len
expr_stmt|;
block|}
if|if
condition|(
name|ifamap
operator|.
name|address_len
operator|!=
name|ifamap
operator|.
name|local_len
operator|||
operator|(
name|ifamap
operator|.
name|address
operator|!=
name|NULL
operator|&&
name|memcmp
argument_list|(
name|ifamap
operator|.
name|address
argument_list|,
name|ifamap
operator|.
name|local
argument_list|,
name|ifamap
operator|.
name|address_len
argument_list|)
operator|)
condition|)
block|{
comment|/* p2p; address is peer and local is ours */
name|ifamap
operator|.
name|broadcast
operator|=
name|ifamap
operator|.
name|address
expr_stmt|;
name|ifamap
operator|.
name|broadcast_len
operator|=
name|ifamap
operator|.
name|address_len
expr_stmt|;
name|ifamap
operator|.
name|address
operator|=
name|ifamap
operator|.
name|local
expr_stmt|;
name|ifamap
operator|.
name|address_len
operator|=
name|ifamap
operator|.
name|local_len
expr_stmt|;
block|}
if|if
condition|(
name|ifamap
operator|.
name|address
condition|)
block|{
ifndef|#
directive|ifndef
name|IFA_NETMASK
name|sockaddr_size
operator|=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|address_len
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|build
condition|)
name|dlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|address_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ifa
operator|->
name|ifa_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|data
expr_stmt|;
name|ifa_make_sockaddr
argument_list|(
name|nlm_family
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|ifamap
operator|.
name|address
argument_list|,
name|ifamap
operator|.
name|address_len
argument_list|,
name|nlm_scope
argument_list|,
name|nlm_index
argument_list|)
expr_stmt|;
name|data
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|address_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|IFA_NETMASK
if|if
condition|(
name|ifamap
operator|.
name|netmask
condition|)
block|{
if|if
condition|(
operator|!
name|build
condition|)
name|dlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|netmask_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ifa
operator|->
name|ifa_netmask
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|data
expr_stmt|;
name|ifa_make_sockaddr
argument_list|(
name|nlm_family
argument_list|,
name|ifa
operator|->
name|ifa_netmask
argument_list|,
name|ifamap
operator|.
name|netmask
argument_list|,
name|ifamap
operator|.
name|netmask_len
argument_list|,
name|nlm_scope
argument_list|,
name|nlm_index
argument_list|)
expr_stmt|;
name|data
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|netmask_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ifamap
operator|.
name|broadcast
condition|)
block|{
if|if
condition|(
operator|!
name|build
condition|)
name|dlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|broadcast_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ifa
operator|->
name|ifa_broadaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|data
expr_stmt|;
name|ifa_make_sockaddr
argument_list|(
name|nlm_family
argument_list|,
name|ifa
operator|->
name|ifa_broadaddr
argument_list|,
name|ifamap
operator|.
name|broadcast
argument_list|,
name|ifamap
operator|.
name|broadcast_len
argument_list|,
name|nlm_scope
argument_list|,
name|nlm_index
argument_list|)
expr_stmt|;
name|data
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|broadcast_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_IFADDRS_IFA_ANYCAST
if|if
condition|(
name|ifamap
operator|.
name|anycast
condition|)
block|{
if|if
condition|(
operator|!
name|build
condition|)
name|dlen
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|anycast_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ifa
operator|->
name|ifa_anycast
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|data
expr_stmt|;
name|ifa_make_sockaddr
argument_list|(
name|nlm_family
argument_list|,
name|ifa
operator|->
name|ifa_anyaddr
argument_list|,
name|ifamap
operator|.
name|anycast
argument_list|,
name|ifamap
operator|.
name|anycast_len
argument_list|,
name|nlm_scope
argument_list|,
name|nlm_index
argument_list|)
expr_stmt|;
name|data
operator|+=
name|NLMSG_ALIGN
argument_list|(
name|ifa_sa_len
argument_list|(
name|nlm_family
argument_list|,
name|ifamap
operator|.
name|anycast_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|build
condition|)
block|{
ifndef|#
directive|ifndef
name|IFA_NETMASK
name|dlen
operator|+=
name|sockaddr_size
expr_stmt|;
endif|#
directive|endif
name|icnt
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_name
operator|==
name|NULL
condition|)
name|ifa
operator|->
name|ifa_name
operator|=
name|iflist
index|[
name|nlm_index
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|IFA_NETMASK
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_UNSPEC
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_PACKET
condition|)
block|{
name|ifa
operator|->
name|ifa_netmask
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|data
expr_stmt|;
name|ifa_make_sockaddr_mask
argument_list|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
argument_list|,
name|ifa
operator|->
name|ifa_netmask
argument_list|,
name|nlm_prefixlen
argument_list|)
expr_stmt|;
block|}
name|data
operator|+=
name|sockaddr_size
expr_stmt|;
endif|#
directive|endif
name|ifl
operator|=
name|ifa
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|build
condition|)
block|{
if|if
condition|(
name|icnt
operator|==
literal|0
operator|&&
operator|(
name|dlen
operator|+
name|nlen
operator|+
name|xlen
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|ifap
operator|!=
name|NULL
condition|)
operator|*
name|ifap
operator|=
name|NULL
expr_stmt|;
break|break;
comment|/* cannot found any addresses */
block|}
block|}
else|else
name|free_data
argument_list|(
name|NULL
argument_list|,
name|ifdata
argument_list|)
expr_stmt|;
block|}
comment|/* ---------------------------------- */
comment|/* Finalize */
name|free_nlmsglist
argument_list|(
name|nlmsg_list
argument_list|)
expr_stmt|;
name|nl_close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
name|void
name|freeifaddrs
parameter_list|(
name|struct
name|ifaddrs
modifier|*
name|ifa
parameter_list|)
block|{
name|free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !AF_NETLINK */
end_comment

begin_comment
comment|/*  * The generic SIOCGIFCONF version.  */
end_comment

begin_function
specifier|static
name|int
name|getifaddrs2
parameter_list|(
name|struct
name|ifaddrs
modifier|*
modifier|*
name|ifap
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|siocgifconf
parameter_list|,
name|int
name|siocgifflags
parameter_list|,
name|size_t
name|ifreq_sz
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|size_t
name|buf_size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|ifconf
name|ifconf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|struct
name|sockaddr
name|sa_zero
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|ifaddrs
modifier|*
name|start
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|end
init|=
operator|&
name|start
decl_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa_zero
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_zero
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|buf_size
operator|=
literal|8192
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
name|ifconf
operator|.
name|ifc_len
operator|=
name|buf_size
expr_stmt|;
name|ifconf
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
comment|/* 	 * Solaris returns EINVAL when the buffer is too small. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|siocgifconf
argument_list|,
operator|&
name|ifconf
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
comment|/* 	 * Can the difference between a full and a overfull buf 	 * be determined? 	 */
if|if
condition|(
name|ifconf
operator|.
name|ifc_len
operator|<
name|buf_size
condition|)
break|break;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf_size
operator|*=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|ifconf
operator|.
name|ifc_buf
init|;
name|p
operator|<
name|ifconf
operator|.
name|ifc_buf
operator|+
name|ifconf
operator|.
name|ifc_len
condition|;
name|p
operator|+=
name|sz
control|)
block|{
name|struct
name|ifreq
name|ifreq
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|size_t
name|salen
decl_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|p
expr_stmt|;
name|sa
operator|=
operator|&
name|ifr
operator|->
name|ifr_addr
expr_stmt|;
name|sz
operator|=
name|ifreq_sz
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
name|salen
operator|=
name|sa
operator|->
name|sa_len
expr_stmt|;
name|sz
operator|=
name|max
argument_list|(
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|+
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SA_LEN
name|salen
operator|=
name|SA_LEN
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sz
operator|=
name|max
argument_list|(
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|+
name|SA_LEN
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|ifreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ifreq
operator|.
name|ifr_name
argument_list|,
name|ifr
operator|->
name|ifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|siocgifflags
argument_list|,
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
operator|*
name|end
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_name
operator|=
name|strdup
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_flags
operator|=
name|ifreq
operator|.
name|ifr_flags
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_addr
operator|=
name|malloc
argument_list|(
name|salen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_addr
argument_list|,
name|sa
argument_list|,
name|salen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_netmask
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* fix these when we actually need them */
block|if(ifreq.ifr_flags& IFF_BROADCAST) { 	    (*end)->ifa_broadaddr = malloc(sizeof(ifr->ifr_broadaddr)); 	    memcpy((*end)->ifa_broadaddr,&ifr->ifr_broadaddr,  		   sizeof(ifr->ifr_broadaddr)); 	} else if(ifreq.ifr_flags& IFF_POINTOPOINT) { 	    (*end)->ifa_dstaddr = malloc(sizeof(ifr->ifr_dstaddr)); 	    memcpy((*end)->ifa_dstaddr,&ifr->ifr_dstaddr,  		   sizeof(ifr->ifr_dstaddr)); 	} else 	    (*end)->ifa_dstaddr = NULL;
else|#
directive|else
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_dstaddr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_data
operator|=
name|NULL
expr_stmt|;
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_next
expr_stmt|;
block|}
operator|*
name|ifap
operator|=
name|start
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error_out
label|:
name|freeifaddrs
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ret
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IPV6
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFFLAGS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|getlifaddrs2
parameter_list|(
name|struct
name|ifaddrs
modifier|*
modifier|*
name|ifap
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|siocgifconf
parameter_list|,
name|int
name|siocgifflags
parameter_list|,
name|size_t
name|ifreq_sz
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|size_t
name|buf_size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|lifconf
name|ifconf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|struct
name|sockaddr
name|sa_zero
decl_stmt|;
name|struct
name|lifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|ifaddrs
modifier|*
name|start
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|end
init|=
operator|&
name|start
decl_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa_zero
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_zero
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|buf_size
operator|=
literal|8192
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
name|ifconf
operator|.
name|lifc_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ifconf
operator|.
name|lifc_flags
operator|=
literal|0
expr_stmt|;
name|ifconf
operator|.
name|lifc_len
operator|=
name|buf_size
expr_stmt|;
name|ifconf
operator|.
name|lifc_buf
operator|=
name|buf
expr_stmt|;
comment|/* 	 * Solaris returns EINVAL when the buffer is too small. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|siocgifconf
argument_list|,
operator|&
name|ifconf
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
comment|/* 	 * Can the difference between a full and a overfull buf 	 * be determined? 	 */
if|if
condition|(
name|ifconf
operator|.
name|lifc_len
operator|<
name|buf_size
condition|)
break|break;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf_size
operator|*=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|ifconf
operator|.
name|lifc_buf
init|;
name|p
operator|<
name|ifconf
operator|.
name|lifc_buf
operator|+
name|ifconf
operator|.
name|lifc_len
condition|;
name|p
operator|+=
name|sz
control|)
block|{
name|struct
name|lifreq
name|ifreq
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|sa
decl_stmt|;
name|size_t
name|salen
decl_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|lifreq
operator|*
operator|)
name|p
expr_stmt|;
name|sa
operator|=
operator|&
name|ifr
operator|->
name|lifr_addr
expr_stmt|;
name|sz
operator|=
name|ifreq_sz
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
name|salen
operator|=
name|sa
operator|->
name|sa_len
expr_stmt|;
name|sz
operator|=
name|max
argument_list|(
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|+
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SA_LEN
name|salen
operator|=
name|SA_LEN
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sz
operator|=
name|max
argument_list|(
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|+
name|SA_LEN
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|ifreq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ifreq
operator|.
name|lifr_name
argument_list|,
name|ifr
operator|->
name|lifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|lifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|siocgifflags
argument_list|,
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
operator|*
name|end
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|end
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_name
operator|=
name|strdup
argument_list|(
name|ifr
operator|->
name|lifr_name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_flags
operator|=
name|ifreq
operator|.
name|lifr_flags
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_addr
operator|=
name|malloc
argument_list|(
name|salen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_addr
argument_list|,
name|sa
argument_list|,
name|salen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_netmask
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* fix these when we actually need them */
block|if(ifreq.ifr_flags& IFF_BROADCAST) { 	    (*end)->ifa_broadaddr = malloc(sizeof(ifr->ifr_broadaddr)); 	    memcpy((*end)->ifa_broadaddr,&ifr->ifr_broadaddr,  		   sizeof(ifr->ifr_broadaddr)); 	} else if(ifreq.ifr_flags& IFF_POINTOPOINT) { 	    (*end)->ifa_dstaddr = malloc(sizeof(ifr->ifr_dstaddr)); 	    memcpy((*end)->ifa_dstaddr,&ifr->ifr_dstaddr,  		   sizeof(ifr->ifr_dstaddr)); 	} else 	    (*end)->ifa_dstaddr = NULL;
else|#
directive|else
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_dstaddr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_data
operator|=
name|NULL
expr_stmt|;
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|ifa_next
expr_stmt|;
block|}
operator|*
name|ifap
operator|=
name|start
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error_out
label|:
name|freeifaddrs
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ret
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(HAVE_IPV6)&& defined(SIOCGLIFCONF)&& defined(SIOCGLIFFLAGS) */
end_comment

begin_function
name|int
name|getifaddrs
parameter_list|(
name|struct
name|ifaddrs
modifier|*
modifier|*
name|ifap
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|errno
operator|=
name|ENXIO
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AF_INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGIF6CONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGIF6FLAGS
argument_list|)
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|getifaddrs2
argument_list|(
name|ifap
argument_list|,
name|AF_INET6
argument_list|,
name|SIOCGIF6CONF
argument_list|,
name|SIOCGIF6FLAGS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_ifreq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IPV6
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGLIFFLAGS
argument_list|)
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|getlifaddrs2
argument_list|(
name|ifap
argument_list|,
name|AF_INET6
argument_list|,
name|SIOCGLIFCONF
argument_list|,
name|SIOCGLIFFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lifreq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_IPV6
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGIFCONF
argument_list|)
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|getifaddrs2
argument_list|(
name|ifap
argument_list|,
name|AF_INET6
argument_list|,
name|SIOCGIFCONF
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|AF_INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGIFCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCGIFFLAGS
argument_list|)
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|getifaddrs2
argument_list|(
name|ifap
argument_list|,
name|AF_INET
argument_list|,
name|SIOCGIFCONF
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|freeifaddrs
parameter_list|(
name|struct
name|ifaddrs
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ifaddrs
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ifp
init|;
name|p
condition|;
control|)
block|{
name|free
argument_list|(
name|p
operator|->
name|ifa_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifa_addr
condition|)
name|free
argument_list|(
name|p
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifa_dstaddr
condition|)
name|free
argument_list|(
name|p
operator|->
name|ifa_dstaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifa_netmask
condition|)
name|free
argument_list|(
name|p
operator|->
name|ifa_netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifa_data
condition|)
name|free
argument_list|(
name|p
operator|->
name|ifa_data
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|ifa_next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !AF_NETLINK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|void
name|print_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"  %s=%d/"
argument_list|,
name|s
argument_list|,
name|sa
operator|->
name|sa_family
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sa
operator|->
name|sa_len
operator|-
operator|(
operator|(
name|long
operator|)
name|sa
operator|->
name|sa_data
operator|-
operator|(
name|long
operator|)
operator|&
name|sa
operator|->
name|sa_family
operator|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sa
operator|->
name|sa_data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sa_data
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sa
operator|->
name|sa_data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_ifaddrs
parameter_list|(
name|struct
name|ifaddrs
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|ifaddrs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|x
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|ifa_next
control|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
operator|->
name|ifa_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  flags=%x\n"
argument_list|,
name|p
operator|->
name|ifa_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifa_addr
condition|)
name|print_addr
argument_list|(
literal|"addr"
argument_list|,
name|p
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifa_dstaddr
condition|)
name|print_addr
argument_list|(
literal|"dstaddr"
argument_list|,
name|p
operator|->
name|ifa_dstaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifa_netmask
condition|)
name|print_addr
argument_list|(
literal|"netmask"
argument_list|,
name|p
operator|->
name|ifa_netmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %p\n"
argument_list|,
name|p
operator|->
name|ifa_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|()
block|{
name|struct
name|ifaddrs
modifier|*
name|a
init|=
name|NULL
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|getifaddrs2
argument_list|(
operator|&
name|a
argument_list|,
name|AF_INET
argument_list|,
name|SIOCGIFCONF
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
name|print_ifaddrs
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"---\n"
argument_list|)
expr_stmt|;
name|getifaddrs
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|print_ifaddrs
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

