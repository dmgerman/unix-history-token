begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2017  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines to manipulate the "line buffer".  * The line buffer holds a line of output as it is being built  * in preparation for output to the screen.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"charset.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer which holds the current output line */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|attr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extension of linebuf to hold attributes */
end_comment

begin_decl_stmt
name|public
name|int
name|size_linebuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of line buffer (and attr buffer) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current left-shift of output line buffer */
end_comment

begin_decl_stmt
name|public
name|int
name|hshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Desired left-shift of output line buffer */
end_comment

begin_decl_stmt
name|public
name|int
name|tabstops
index|[
name|TABSTOP_MAX
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Custom tabstops */
end_comment

begin_decl_stmt
name|public
name|int
name|ntabstops
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of tabstops */
end_comment

begin_decl_stmt
name|public
name|int
name|tabdefault
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default repeated tabstops */
end_comment

begin_decl_stmt
name|public
name|POSITION
name|highest_hilite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pos of last hilite in file found so far */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into linebuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Printable length, accounting for 				   backspaces, etc. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|overstrike
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next char should overstrike previous char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_overstrike
init|=
name|AT_NORMAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_null_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There is no current line */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lmargin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Left margin */
end_comment

begin_decl_stmt
specifier|static
name|LWCHAR
name|pendc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|POSITION
name|pendpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|end_ansi_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mid_ansi_chars
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|attr_swidth
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|attr_ewidth
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_append
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ctldisp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|twiddle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|binattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|status_col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|auto_wrap
decl_stmt|,
name|ignaw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bo_s_width
decl_stmt|,
name|bo_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ul_s_width
decl_stmt|,
name|ul_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bl_s_width
decl_stmt|,
name|bl_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_s_width
decl_stmt|,
name|so_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|utf_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|start_attnpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|end_attnpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mbc_buf
index|[
name|MAX_UTF_CHAR_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mbc_buf_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mbc_buf_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|POSITION
name|mbc_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize from environment variables.  */
end_comment

begin_function
name|public
name|void
name|init_line
parameter_list|()
block|{
name|end_ansi_chars
operator|=
name|lgetenv
argument_list|(
literal|"LESSANSIENDCHARS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_ansi_chars
operator|==
name|NULL
operator|||
operator|*
name|end_ansi_chars
operator|==
literal|'\0'
condition|)
name|end_ansi_chars
operator|=
literal|"m"
expr_stmt|;
name|mid_ansi_chars
operator|=
name|lgetenv
argument_list|(
literal|"LESSANSIMIDCHARS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid_ansi_chars
operator|==
name|NULL
operator|||
operator|*
name|mid_ansi_chars
operator|==
literal|'\0'
condition|)
name|mid_ansi_chars
operator|=
literal|"0123456789:;[?!\"'#%()*+ "
expr_stmt|;
name|linebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|LINEBUF_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|LINEBUF_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|size_linebuf
operator|=
name|LINEBUF_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Expand the line buffer.  */
end_comment

begin_function
specifier|static
name|int
name|expand_linebuf
parameter_list|()
block|{
comment|/* Double the size of the line buffer. */
name|int
name|new_size
init|=
name|size_linebuf
operator|*
literal|2
decl_stmt|;
comment|/* Just realloc to expand the buffer, if we can. */
if|#
directive|if
name|HAVE_REALLOC
name|char
modifier|*
name|new_buf
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|linebuf
argument_list|,
name|new_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_attr
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|attr
argument_list|,
name|new_size
argument_list|)
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|new_buf
init|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|new_size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_attr
init|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|new_size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|new_buf
operator|==
name|NULL
operator|||
name|new_attr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|new_attr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|new_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|new_buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|#
directive|if
name|HAVE_REALLOC
comment|/* 	 * We realloc'd the buffers; they already have the old contents. 	 */
if|#
directive|if
literal|0
block|memset(new_buf + size_linebuf, 0, new_size - size_linebuf); 	memset(new_attr + size_linebuf, 0, new_size - size_linebuf);
endif|#
directive|endif
else|#
directive|else
comment|/* 	 * We just calloc'd the buffers; copy the old contents. 	 */
name|memcpy
argument_list|(
name|new_buf
argument_list|,
name|linebuf
argument_list|,
name|size_linebuf
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_attr
argument_list|,
name|attr
argument_list|,
name|size_linebuf
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linebuf
operator|=
name|new_buf
expr_stmt|;
name|attr
operator|=
name|new_attr
expr_stmt|;
name|size_linebuf
operator|=
name|new_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Is a character ASCII?  */
end_comment

begin_function
name|public
name|int
name|is_ascii_char
parameter_list|(
name|ch
parameter_list|)
name|LWCHAR
name|ch
decl_stmt|;
block|{
return|return
operator|(
name|ch
operator|<=
literal|0x7F
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rewind the line buffer.  */
end_comment

begin_function
name|public
name|void
name|prewind
parameter_list|()
block|{
name|curr
operator|=
literal|0
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|cshift
operator|=
literal|0
expr_stmt|;
name|overstrike
operator|=
literal|0
expr_stmt|;
name|last_overstrike
operator|=
name|AT_NORMAL
expr_stmt|;
name|mbc_buf_len
operator|=
literal|0
expr_stmt|;
name|is_null_line
operator|=
literal|0
expr_stmt|;
name|pendc
operator|=
literal|'\0'
expr_stmt|;
name|lmargin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status_col
condition|)
name|lmargin
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert the line number (of the given position) into the line buffer.  */
end_comment

begin_function
name|public
name|void
name|plinenum
parameter_list|(
name|pos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
block|{
name|LINENUM
name|linenum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|linenums
operator|==
name|OPT_ONPLUS
condition|)
block|{
comment|/* 		 * Get the line number and put it in the current line. 		 * {{ Note: since find_linenum calls forw_raw_line, 		 *    it may seek in the input file, requiring the caller  		 *    of plinenum to re-seek if necessary. }} 		 * {{ Since forw_raw_line modifies linebuf, we must 		 *    do this first, before storing anything in linebuf. }} 		 */
name|linenum
operator|=
name|find_linenum
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Display a status column if the -J option is set. 	 */
if|if
condition|(
name|status_col
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|start_attnpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>=
name|start_attnpos
operator|&&
name|pos
operator|<
name|end_attnpos
condition|)
name|attr
index|[
name|curr
index|]
operator|=
name|AT_NORMAL
operator||
name|AT_HILITE
expr_stmt|;
else|else
name|attr
index|[
name|curr
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
name|curr
operator|++
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
comment|/* 	 * Display the line number at the start of each line 	 * if the -N option is set. 	 */
if|if
condition|(
name|linenums
operator|==
name|OPT_ONPLUS
condition|)
block|{
name|char
name|buf
index|[
name|INT_STRLEN_BOUND
argument_list|(
name|pos
argument_list|)
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|linenumtoa
argument_list|(
name|linenum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|MIN_LINENUM_WIDTH
condition|)
name|n
operator|=
name|MIN_LINENUM_WIDTH
expr_stmt|;
name|sprintf
argument_list|(
name|linebuf
operator|+
name|curr
argument_list|,
literal|"%*s "
argument_list|,
name|n
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
comment|/* One space after the line number. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|attr
index|[
name|curr
operator|+
name|i
index|]
operator|=
name|AT_BOLD
expr_stmt|;
name|curr
operator|+=
name|n
expr_stmt|;
name|column
operator|+=
name|n
expr_stmt|;
name|lmargin
operator|+=
name|n
expr_stmt|;
block|}
comment|/* 	 * Append enough spaces to bring us to the lmargin. 	 */
while|while
condition|(
name|column
operator|<
name|lmargin
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
literal|' '
expr_stmt|;
name|attr
index|[
name|curr
operator|++
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Shift the input line left.  * This means discarding N printable chars at the start of the buffer.  */
end_comment

begin_function
specifier|static
name|void
name|pshift
parameter_list|(
name|shift
parameter_list|)
name|int
name|shift
decl_stmt|;
block|{
name|LWCHAR
name|prev_ch
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|shifted
init|=
literal|0
decl_stmt|;
name|int
name|to
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|prev_attr
decl_stmt|;
name|int
name|next_attr
decl_stmt|;
if|if
condition|(
name|shift
operator|>
name|column
operator|-
name|lmargin
condition|)
name|shift
operator|=
name|column
operator|-
name|lmargin
expr_stmt|;
if|if
condition|(
name|shift
operator|>
name|curr
operator|-
name|lmargin
condition|)
name|shift
operator|=
name|curr
operator|-
name|lmargin
expr_stmt|;
name|to
operator|=
name|from
operator|=
name|lmargin
expr_stmt|;
comment|/* 	 * We keep on going when shifted == shift 	 * to get all combining chars. 	 */
while|while
condition|(
name|shifted
operator|<=
name|shift
operator|&&
name|from
operator|<
name|curr
condition|)
block|{
name|c
operator|=
name|linebuf
index|[
name|from
index|]
expr_stmt|;
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ONPLUS
operator|&&
name|IS_CSI_START
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Keep cumulative effect.  */
name|linebuf
index|[
name|to
index|]
operator|=
name|c
expr_stmt|;
name|attr
index|[
name|to
operator|++
index|]
operator|=
name|attr
index|[
name|from
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|curr
operator|&&
name|linebuf
index|[
name|from
index|]
condition|)
block|{
name|linebuf
index|[
name|to
index|]
operator|=
name|linebuf
index|[
name|from
index|]
expr_stmt|;
name|attr
index|[
name|to
operator|++
index|]
operator|=
name|attr
index|[
name|from
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|is_ansi_middle
argument_list|(
name|linebuf
index|[
name|from
operator|++
index|]
argument_list|)
condition|)
break|break;
block|}
continue|continue;
block|}
name|width
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ASCII_OCTET
argument_list|(
name|c
argument_list|)
operator|&&
name|utf_mode
condition|)
block|{
comment|/* Assumes well-formedness validation already done.  */
name|LWCHAR
name|ch
decl_stmt|;
name|len
operator|=
name|utf_len
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|+
name|len
operator|>
name|curr
condition|)
break|break;
name|ch
operator|=
name|get_wchar
argument_list|(
name|linebuf
operator|+
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_composing_char
argument_list|(
name|ch
argument_list|)
operator|&&
operator|!
name|is_combining_char
argument_list|(
name|prev_ch
argument_list|,
name|ch
argument_list|)
condition|)
name|width
operator|=
name|is_wide_char
argument_list|(
name|ch
argument_list|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|prev_ch
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
comment|/* XXX - Incorrect if several '\b' in a row.  */
name|width
operator|=
operator|(
name|utf_mode
operator|&&
name|is_wide_char
argument_list|(
name|prev_ch
argument_list|)
operator|)
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
name|width
operator|=
literal|1
expr_stmt|;
name|prev_ch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|==
literal|2
operator|&&
name|shift
operator|-
name|shifted
operator|==
literal|1
condition|)
block|{
comment|/* Should never happen when called by pshift_all().  */
name|attr
index|[
name|to
index|]
operator|=
name|attr
index|[
name|from
index|]
expr_stmt|;
comment|/* 			 * Assume a wide_char will never be the first half of a 			 * combining_char pair, so reset prev_ch in case we're 			 * followed by a '\b'. 			 */
name|prev_ch
operator|=
name|linebuf
index|[
name|to
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
name|shifted
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Adjust width for magic cookies. */
name|prev_attr
operator|=
operator|(
name|to
operator|>
literal|0
operator|)
condition|?
name|attr
index|[
name|to
operator|-
literal|1
index|]
else|:
name|AT_NORMAL
expr_stmt|;
name|next_attr
operator|=
operator|(
name|from
operator|+
name|len
operator|<
name|curr
operator|)
condition|?
name|attr
index|[
name|from
operator|+
name|len
index|]
else|:
name|prev_attr
expr_stmt|;
if|if
condition|(
operator|!
name|is_at_equiv
argument_list|(
name|attr
index|[
name|from
index|]
argument_list|,
name|prev_attr
argument_list|)
operator|&&
operator|!
name|is_at_equiv
argument_list|(
name|attr
index|[
name|from
index|]
argument_list|,
name|next_attr
argument_list|)
condition|)
block|{
name|width
operator|+=
name|attr_swidth
argument_list|(
name|attr
index|[
name|from
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|+
name|len
operator|<
name|curr
condition|)
name|width
operator|+=
name|attr_ewidth
argument_list|(
name|attr
index|[
name|from
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_at_equiv
argument_list|(
name|prev_attr
argument_list|,
name|next_attr
argument_list|)
condition|)
block|{
name|width
operator|+=
name|attr_ewidth
argument_list|(
name|prev_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|+
name|len
operator|<
name|curr
condition|)
name|width
operator|+=
name|attr_swidth
argument_list|(
name|next_attr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shift
operator|-
name|shifted
operator|<
name|width
condition|)
break|break;
name|from
operator|+=
name|len
expr_stmt|;
name|shifted
operator|+=
name|width
expr_stmt|;
if|if
condition|(
name|shifted
operator|<
literal|0
condition|)
name|shifted
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|from
operator|<
name|curr
condition|)
block|{
name|linebuf
index|[
name|to
index|]
operator|=
name|linebuf
index|[
name|from
index|]
expr_stmt|;
name|attr
index|[
name|to
operator|++
index|]
operator|=
name|attr
index|[
name|from
operator|++
index|]
expr_stmt|;
block|}
name|curr
operator|=
name|to
expr_stmt|;
name|column
operator|-=
name|shifted
expr_stmt|;
name|cshift
operator|+=
name|shifted
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|public
name|void
name|pshift_all
parameter_list|()
block|{
name|pshift
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the printing width of the start (enter) sequence  * for a given character attribute.  */
end_comment

begin_function
specifier|static
name|int
name|attr_swidth
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
name|int
name|w
init|=
literal|0
decl_stmt|;
name|a
operator|=
name|apply_at_specials
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_UNDERLINE
condition|)
name|w
operator|+=
name|ul_s_width
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_BOLD
condition|)
name|w
operator|+=
name|bo_s_width
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_BLINK
condition|)
name|w
operator|+=
name|bl_s_width
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_STANDOUT
condition|)
name|w
operator|+=
name|so_s_width
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * Return the printing width of the end (exit) sequence  * for a given character attribute.  */
end_comment

begin_function
specifier|static
name|int
name|attr_ewidth
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
name|int
name|w
init|=
literal|0
decl_stmt|;
name|a
operator|=
name|apply_at_specials
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_UNDERLINE
condition|)
name|w
operator|+=
name|ul_e_width
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_BOLD
condition|)
name|w
operator|+=
name|bo_e_width
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_BLINK
condition|)
name|w
operator|+=
name|bl_e_width
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|AT_STANDOUT
condition|)
name|w
operator|+=
name|so_e_width
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * Return the printing width of a given character and attribute,  * if the character were added to the current position in the line buffer.  * Adding a character with a given attribute may cause an enter or exit  * attribute sequence to be inserted, so this must be taken into account.  */
end_comment

begin_function
specifier|static
name|int
name|pwidth
parameter_list|(
name|ch
parameter_list|,
name|a
parameter_list|,
name|prev_ch
parameter_list|)
name|LWCHAR
name|ch
decl_stmt|;
name|int
name|a
decl_stmt|;
name|LWCHAR
name|prev_ch
decl_stmt|;
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\b'
condition|)
comment|/* 		 * Backspace moves backwards one or two positions. 		 * XXX - Incorrect if several '\b' in a row. 		 */
return|return
operator|(
name|utf_mode
operator|&&
name|is_wide_char
argument_list|(
name|prev_ch
argument_list|)
operator|)
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|utf_mode
operator|||
name|is_ascii_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|control_char
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
comment|/* 			 * Control characters do unpredictable things, 			 * so we don't even try to guess; say it doesn't move. 			 * This can only happen if the -r flag is in effect. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is_composing_char
argument_list|(
name|ch
argument_list|)
operator|||
name|is_combining_char
argument_list|(
name|prev_ch
argument_list|,
name|ch
argument_list|)
condition|)
block|{
comment|/* 			 * Composing and combining chars take up no space. 			 * 			 * Some terminals, upon failure to compose a 			 * composing character with the character(s) that 			 * precede(s) it will actually take up one column 			 * for the composing character; there isn't much 			 * we could do short of testing the (complex) 			 * composition process ourselves and printing 			 * a binary representation when it fails. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Other characters take one or two columns, 	 * plus the width of any attribute enter/exit sequence. 	 */
name|w
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_wide_char
argument_list|(
name|ch
argument_list|)
condition|)
name|w
operator|++
expr_stmt|;
if|if
condition|(
name|curr
operator|>
literal|0
operator|&&
operator|!
name|is_at_equiv
argument_list|(
name|attr
index|[
name|curr
operator|-
literal|1
index|]
argument_list|,
name|a
argument_list|)
condition|)
name|w
operator|+=
name|attr_ewidth
argument_list|(
name|attr
index|[
name|curr
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|apply_at_specials
argument_list|(
name|a
argument_list|)
operator|!=
name|AT_NORMAL
operator|)
operator|&&
operator|(
name|curr
operator|==
literal|0
operator|||
operator|!
name|is_at_equiv
argument_list|(
name|attr
index|[
name|curr
operator|-
literal|1
index|]
argument_list|,
name|a
argument_list|)
operator|)
condition|)
name|w
operator|+=
name|attr_swidth
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete to the previous base character in the line buffer.  * Return 1 if one is found.  */
end_comment

begin_function
specifier|static
name|int
name|backc
parameter_list|()
block|{
name|LWCHAR
name|prev_ch
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|linebuf
operator|+
name|curr
decl_stmt|;
name|LWCHAR
name|ch
init|=
name|step_char
argument_list|(
operator|&
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|linebuf
operator|+
name|lmargin
argument_list|)
decl_stmt|;
name|int
name|width
decl_stmt|;
comment|/* This assumes that there is no '\b' in linebuf.  */
while|while
condition|(
name|curr
operator|>
name|lmargin
operator|&&
name|column
operator|>
name|lmargin
operator|&&
operator|(
operator|!
operator|(
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|&
operator|(
name|AT_ANSI
operator||
name|AT_BINARY
operator|)
operator|)
operator|)
condition|)
block|{
name|curr
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|linebuf
argument_list|)
expr_stmt|;
name|prev_ch
operator|=
name|step_char
argument_list|(
operator|&
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|linebuf
operator|+
name|lmargin
argument_list|)
expr_stmt|;
name|width
operator|=
name|pwidth
argument_list|(
name|ch
argument_list|,
name|attr
index|[
name|curr
index|]
argument_list|,
name|prev_ch
argument_list|)
expr_stmt|;
name|column
operator|-=
name|width
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
condition|)
return|return
literal|1
return|;
name|ch
operator|=
name|prev_ch
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Are we currently within a recognized ANSI escape sequence?  */
end_comment

begin_function
specifier|static
name|int
name|in_ansi_esc_seq
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Search backwards for either an ESC (which means we ARE in a seq); 	 * or an end char (which means we're NOT in a seq). 	 */
for|for
control|(
name|p
operator|=
operator|&
name|linebuf
index|[
name|curr
index|]
init|;
name|p
operator|>
name|linebuf
condition|;
control|)
block|{
name|LWCHAR
name|ch
init|=
name|step_char
argument_list|(
operator|&
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|linebuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_CSI_START
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|is_ansi_middle
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is a character the end of an ANSI escape sequence?  */
end_comment

begin_function
name|public
name|int
name|is_ansi_end
parameter_list|(
name|ch
parameter_list|)
name|LWCHAR
name|ch
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|is_ascii_char
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|strchr
argument_list|(
name|end_ansi_chars
argument_list|,
operator|(
name|char
operator|)
name|ch
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|public
name|int
name|is_ansi_middle
parameter_list|(
name|ch
parameter_list|)
name|LWCHAR
name|ch
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|is_ascii_char
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|is_ansi_end
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|strchr
argument_list|(
name|mid_ansi_chars
argument_list|,
operator|(
name|char
operator|)
name|ch
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append a character and attribute to the line buffer.  */
end_comment

begin_define
define|#
directive|define
name|STORE_CHAR
parameter_list|(
name|ch
parameter_list|,
name|a
parameter_list|,
name|rep
parameter_list|,
name|pos
parameter_list|)
define|\
value|do { \ 		if (store_char((ch),(a),(rep),(pos))) return (1); \ 	} while (0)
end_define

begin_function
specifier|static
name|int
name|store_char
parameter_list|(
name|ch
parameter_list|,
name|a
parameter_list|,
name|rep
parameter_list|,
name|pos
parameter_list|)
name|LWCHAR
name|ch
decl_stmt|;
name|int
name|a
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
name|int
name|w
decl_stmt|;
name|int
name|replen
decl_stmt|;
name|char
name|cs
decl_stmt|;
name|w
operator|=
operator|(
name|a
operator|&
operator|(
name|AT_UNDERLINE
operator||
name|AT_BOLD
operator|)
operator|)
expr_stmt|;
comment|/* Pre-use w.  */
if|if
condition|(
name|w
operator|!=
name|AT_NORMAL
condition|)
name|last_overstrike
operator|=
name|w
expr_stmt|;
if|#
directive|if
name|HILITE_SEARCH
block|{
name|int
name|matches
decl_stmt|;
if|if
condition|(
name|is_hilited
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|matches
argument_list|)
condition|)
block|{
comment|/* 			 * This character should be highlighted. 			 * Override the attribute passed in. 			 */
if|if
condition|(
name|a
operator|!=
name|AT_ANSI
condition|)
block|{
if|if
condition|(
name|highest_hilite
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>
name|highest_hilite
condition|)
name|highest_hilite
operator|=
name|pos
expr_stmt|;
name|a
operator||=
name|AT_HILITE
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ONPLUS
operator|&&
name|in_ansi_esc_seq
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|is_ansi_end
argument_list|(
name|ch
argument_list|)
operator|&&
operator|!
name|is_ansi_middle
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* Remove whole unrecognized sequence.  */
name|char
modifier|*
name|p
init|=
operator|&
name|linebuf
index|[
name|curr
index|]
decl_stmt|;
name|LWCHAR
name|bch
decl_stmt|;
do|do
block|{
name|bch
operator|=
name|step_char
argument_list|(
operator|&
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|>
name|linebuf
operator|&&
operator|!
name|IS_CSI_START
argument_list|(
name|bch
argument_list|)
condition|)
do|;
name|curr
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|linebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|a
operator|=
name|AT_ANSI
expr_stmt|;
comment|/* Will force re-AT_'ing around it.  */
name|w
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ONPLUS
operator|&&
name|IS_CSI_START
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|a
operator|=
name|AT_ANSI
expr_stmt|;
comment|/* Will force re-AT_'ing around it.  */
name|w
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
operator|&
name|linebuf
index|[
name|curr
index|]
decl_stmt|;
name|LWCHAR
name|prev_ch
init|=
name|step_char
argument_list|(
operator|&
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|linebuf
argument_list|)
decl_stmt|;
name|w
operator|=
name|pwidth
argument_list|(
name|ch
argument_list|,
name|a
argument_list|,
name|prev_ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctldisp
operator|!=
name|OPT_ON
operator|&&
name|column
operator|+
name|w
operator|+
name|attr_ewidth
argument_list|(
name|a
argument_list|)
operator|>
name|sc_width
condition|)
comment|/* 		 * Won't fit on screen. 		 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
block|{
name|cs
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|rep
operator|=
operator|&
name|cs
expr_stmt|;
name|replen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|replen
operator|=
name|utf_len
argument_list|(
name|rep
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curr
operator|+
name|replen
operator|>=
name|size_linebuf
operator|-
literal|6
condition|)
block|{
comment|/* 		 * Won't fit in line buffer. 		 * Try to expand it. 		 */
if|if
condition|(
name|expand_linebuf
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|replen
operator|--
operator|>
literal|0
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
operator|*
name|rep
operator|++
expr_stmt|;
name|attr
index|[
name|curr
index|]
operator|=
name|a
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
name|column
operator|+=
name|w
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append a tab to the line buffer.  * Store spaces to represent the tab.  */
end_comment

begin_define
define|#
directive|define
name|STORE_TAB
parameter_list|(
name|a
parameter_list|,
name|pos
parameter_list|)
define|\
value|do { if (store_tab((a),(pos))) return (1); } while (0)
end_define

begin_function
specifier|static
name|int
name|store_tab
parameter_list|(
name|attr
parameter_list|,
name|pos
parameter_list|)
name|int
name|attr
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
name|int
name|to_tab
init|=
name|column
operator|+
name|cshift
operator|-
name|lmargin
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ntabstops
operator|<
literal|2
operator|||
name|to_tab
operator|>=
name|tabstops
index|[
name|ntabstops
operator|-
literal|1
index|]
condition|)
name|to_tab
operator|=
name|tabdefault
operator|-
operator|(
operator|(
name|to_tab
operator|-
name|tabstops
index|[
name|ntabstops
operator|-
literal|1
index|]
operator|)
operator|%
name|tabdefault
operator|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|ntabstops
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|to_tab
operator|>=
name|tabstops
index|[
name|i
index|]
condition|)
break|break;
name|to_tab
operator|=
name|tabstops
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|to_tab
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|+
name|to_tab
operator|-
literal|1
operator|+
name|pwidth
argument_list|(
literal|' '
argument_list|,
name|attr
argument_list|,
literal|0
argument_list|)
operator|+
name|attr_ewidth
argument_list|(
name|attr
argument_list|)
operator|>
name|sc_width
condition|)
return|return
literal|1
return|;
do|do
block|{
name|STORE_CHAR
argument_list|(
literal|' '
argument_list|,
name|attr
argument_list|,
literal|" "
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|to_tab
operator|>
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|STORE_PRCHAR
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
define|\
value|do { if (store_prchar((c), (pos))) return 1; } while (0)
end_define

begin_function
specifier|static
name|int
name|store_prchar
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
name|LWCHAR
name|c
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* 	 * Convert to printable representation. 	 */
name|s
operator|=
name|prchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we can get the entire representation 	 * of the character on this line. 	 */
if|if
condition|(
name|column
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
operator|+
name|pwidth
argument_list|(
literal|' '
argument_list|,
name|binattr
argument_list|,
literal|0
argument_list|)
operator|+
name|attr_ewidth
argument_list|(
name|binattr
argument_list|)
operator|>
name|sc_width
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
name|STORE_CHAR
argument_list|(
operator|*
name|s
argument_list|,
name|AT_BINARY
argument_list|,
name|NULL
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flush_mbc_buf
parameter_list|(
name|pos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mbc_buf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|store_prchar
argument_list|(
name|mbc_buf
index|[
name|i
index|]
argument_list|,
name|pos
argument_list|)
condition|)
return|return
name|mbc_buf_index
operator|-
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Append a character to the line buffer.  * Expand tabs into spaces, handle underlining, boldfacing, etc.  * Returns 0 if ok, 1 if couldn't fit in buffer.  */
end_comment

begin_function
name|public
name|int
name|pappend
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
name|unsigned
name|char
name|c
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|pendc
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
name|pendc
operator|==
literal|'\r'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|do_append
argument_list|(
name|pendc
argument_list|,
name|NULL
argument_list|,
name|pendpos
argument_list|)
condition|)
comment|/* 			 * Oops.  We've probably lost the char which 			 * was in pendc, since caller won't back up. 			 */
return|return
operator|(
literal|1
operator|)
return|;
name|pendc
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
block|{
if|if
condition|(
name|mbc_buf_len
operator|>
literal|0
condition|)
comment|/* utf_mode must be on. */
block|{
comment|/* Flush incomplete (truncated) sequence. */
name|r
operator|=
name|flush_mbc_buf
argument_list|(
name|mbc_pos
argument_list|)
expr_stmt|;
name|mbc_buf_index
operator|=
name|r
operator|+
literal|1
expr_stmt|;
name|mbc_buf_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|mbc_buf_index
operator|)
return|;
block|}
comment|/* 		 * Don't put the CR into the buffer until we see  		 * the next char.  If the next char is a newline, 		 * discard the CR. 		 */
name|pendc
operator|=
name|c
expr_stmt|;
name|pendpos
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|utf_mode
condition|)
block|{
name|r
operator|=
name|do_append
argument_list|(
name|c
argument_list|,
name|NULL
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Perform strict validation in all possible cases. */
if|if
condition|(
name|mbc_buf_len
operator|==
literal|0
condition|)
block|{
name|retry
label|:
name|mbc_buf_index
operator|=
literal|1
expr_stmt|;
operator|*
name|mbc_buf
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|IS_ASCII_OCTET
argument_list|(
name|c
argument_list|)
condition|)
name|r
operator|=
name|do_append
argument_list|(
name|c
argument_list|,
name|NULL
argument_list|,
name|pos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_UTF8_LEAD
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mbc_buf_len
operator|=
name|utf_len
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|mbc_pos
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
comment|/* UTF8_INVALID or stray UTF8_TRAIL */
name|r
operator|=
name|flush_mbc_buf
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_UTF8_TRAIL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mbc_buf
index|[
name|mbc_buf_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|mbc_buf_index
operator|<
name|mbc_buf_len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|is_utf8_well_formed
argument_list|(
name|mbc_buf
argument_list|,
name|mbc_buf_index
argument_list|)
condition|)
name|r
operator|=
name|do_append
argument_list|(
name|get_wchar
argument_list|(
name|mbc_buf
argument_list|)
argument_list|,
name|mbc_buf
argument_list|,
name|mbc_pos
argument_list|)
expr_stmt|;
else|else
comment|/* Complete, but not shortest form, sequence. */
name|mbc_buf_index
operator|=
name|r
operator|=
name|flush_mbc_buf
argument_list|(
name|mbc_pos
argument_list|)
expr_stmt|;
name|mbc_buf_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Flush incomplete (truncated) sequence.  */
name|r
operator|=
name|flush_mbc_buf
argument_list|(
name|mbc_pos
argument_list|)
expr_stmt|;
name|mbc_buf_index
operator|=
name|r
operator|+
literal|1
expr_stmt|;
name|mbc_buf_len
operator|=
literal|0
expr_stmt|;
comment|/* Handle new char.  */
if|if
condition|(
operator|!
name|r
condition|)
goto|goto
name|retry
goto|;
block|}
block|}
comment|/* 	 * If we need to shift the line, do it. 	 * But wait until we get to at least the middle of the screen, 	 * so shifting it doesn't affect the chars we're currently 	 * pappending.  (Bold& underline can get messed up otherwise.) 	 */
if|if
condition|(
name|cshift
operator|<
name|hshift
operator|&&
name|column
operator|>
name|sc_width
operator|/
literal|2
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pshift
argument_list|(
name|hshift
operator|-
name|cshift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
condition|)
block|{
comment|/* How many chars should caller back up? */
name|r
operator|=
operator|(
operator|!
name|utf_mode
operator|)
condition|?
literal|1
else|:
name|mbc_buf_index
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_append
parameter_list|(
name|ch
parameter_list|,
name|rep
parameter_list|,
name|pos
parameter_list|)
name|LWCHAR
name|ch
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
name|int
name|a
decl_stmt|;
name|LWCHAR
name|prev_ch
decl_stmt|;
name|a
operator|=
name|AT_NORMAL
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\b'
condition|)
block|{
if|if
condition|(
name|bs_mode
operator|==
name|BS_CONTROL
condition|)
goto|goto
name|do_control_char
goto|;
comment|/* 		 * A better test is needed here so we don't 		 * backspace over part of the printed 		 * representation of a binary character. 		 */
if|if
condition|(
name|curr
operator|<=
name|lmargin
operator|||
name|column
operator|<=
name|lmargin
operator|||
operator|(
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|&
operator|(
name|AT_ANSI
operator||
name|AT_BINARY
operator|)
operator|)
condition|)
name|STORE_PRCHAR
argument_list|(
literal|'\b'
argument_list|,
name|pos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bs_mode
operator|==
name|BS_NORMAL
condition|)
name|STORE_CHAR
argument_list|(
name|ch
argument_list|,
name|AT_NORMAL
argument_list|,
name|NULL
argument_list|,
name|pos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
name|overstrike
operator|=
name|backc
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|overstrike
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Overstrike the character at the current position 		 * in the line buffer.  This will cause either  		 * underline (if a "_" is overstruck),  		 * bold (if an identical character is overstruck), 		 * or just deletion of the character in the buffer. 		 */
name|overstrike
operator|=
name|utf_mode
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|utf_mode
condition|)
block|{
comment|/* To be correct, this must be a base character.  */
name|prev_ch
operator|=
name|get_wchar
argument_list|(
name|linebuf
operator|+
name|curr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev_ch
operator|=
operator|(
name|unsigned
name|char
operator|)
name|linebuf
index|[
name|curr
index|]
expr_stmt|;
block|}
name|a
operator|=
name|attr
index|[
name|curr
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|prev_ch
condition|)
block|{
comment|/* 			 * Overstriking a char with itself means make it bold. 			 * But overstriking an underscore with itself is 			 * ambiguous.  It could mean make it bold, or 			 * it could mean make it underlined. 			 * Use the previous overstrike to resolve it. 			 */
if|if
condition|(
name|ch
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|&
operator|(
name|AT_BOLD
operator||
name|AT_UNDERLINE
operator|)
operator|)
operator|!=
name|AT_NORMAL
condition|)
name|a
operator||=
operator|(
name|AT_BOLD
operator||
name|AT_UNDERLINE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_overstrike
operator|!=
name|AT_NORMAL
condition|)
name|a
operator||=
name|last_overstrike
expr_stmt|;
else|else
name|a
operator||=
name|AT_BOLD
expr_stmt|;
block|}
else|else
name|a
operator||=
name|AT_BOLD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'_'
condition|)
block|{
name|a
operator||=
name|AT_UNDERLINE
expr_stmt|;
name|ch
operator|=
name|prev_ch
expr_stmt|;
name|rep
operator|=
name|linebuf
operator|+
name|curr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_ch
operator|==
literal|'_'
condition|)
block|{
name|a
operator||=
name|AT_UNDERLINE
expr_stmt|;
block|}
comment|/* Else we replace prev_ch, but we keep its attributes.  */
block|}
elseif|else
if|if
condition|(
name|overstrike
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|is_composing_char
argument_list|(
name|ch
argument_list|)
operator|||
name|is_combining_char
argument_list|(
name|get_wchar
argument_list|(
name|linebuf
operator|+
name|curr
argument_list|)
argument_list|,
name|ch
argument_list|)
condition|)
comment|/* Continuation of the same overstrike.  */
name|a
operator|=
name|last_overstrike
expr_stmt|;
else|else
name|overstrike
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		 * Expand a tab into spaces. 		 */
switch|switch
condition|(
name|bs_mode
condition|)
block|{
case|case
name|BS_CONTROL
case|:
goto|goto
name|do_control_char
goto|;
case|case
name|BS_NORMAL
case|:
case|case
name|BS_SPECIAL
case|:
name|STORE_TAB
argument_list|(
name|a
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|utf_mode
operator|||
name|is_ascii_char
argument_list|(
name|ch
argument_list|)
operator|)
operator|&&
name|control_char
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
name|do_control_char
label|:
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ON
operator|||
operator|(
name|ctldisp
operator|==
name|OPT_ONPLUS
operator|&&
name|IS_CSI_START
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Output as a normal character. 			 */
name|STORE_CHAR
argument_list|(
name|ch
argument_list|,
name|AT_NORMAL
argument_list|,
name|rep
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STORE_PRCHAR
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|utf_mode
operator|&&
name|ctldisp
operator|!=
name|OPT_ON
operator|&&
name|is_ubin_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|prutfchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
operator|+
name|pwidth
argument_list|(
literal|' '
argument_list|,
name|binattr
argument_list|,
literal|0
argument_list|)
operator|+
name|attr_ewidth
argument_list|(
name|binattr
argument_list|)
operator|>
name|sc_width
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
name|STORE_CHAR
argument_list|(
operator|*
name|s
argument_list|,
name|AT_BINARY
argument_list|,
name|NULL
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STORE_CHAR
argument_list|(
name|ch
argument_list|,
name|a
argument_list|,
name|rep
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|public
name|int
name|pflushmbc
parameter_list|()
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mbc_buf_len
operator|>
literal|0
condition|)
block|{
comment|/* Flush incomplete (truncated) sequence.  */
name|r
operator|=
name|flush_mbc_buf
argument_list|(
name|mbc_pos
argument_list|)
expr_stmt|;
name|mbc_buf_len
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Terminate the line in the line buffer.  */
end_comment

begin_function
name|public
name|void
name|pdone
parameter_list|(
name|endline
parameter_list|,
name|forw
parameter_list|)
name|int
name|endline
decl_stmt|;
name|int
name|forw
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|pflushmbc
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendc
operator|&&
operator|(
name|pendc
operator|!=
literal|'\r'
operator|||
operator|!
name|endline
operator|)
condition|)
comment|/* 		 * If we had a pending character, put it in the buffer. 		 * But discard a pending CR if we are at end of line 		 * (that is, discard the CR in a CR/LF sequence). 		 */
operator|(
name|void
operator|)
name|do_append
argument_list|(
name|pendc
argument_list|,
name|NULL
argument_list|,
name|pendpos
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we've shifted the line, if we need to. 	 */
if|if
condition|(
name|cshift
operator|<
name|hshift
condition|)
name|pshift
argument_list|(
name|hshift
operator|-
name|cshift
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ONPLUS
operator|&&
name|is_ansi_end
argument_list|(
literal|'m'
argument_list|)
condition|)
block|{
comment|/* Switch to normal attribute at end of line. */
name|char
modifier|*
name|p
init|=
literal|"\033[m"
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|attr
index|[
name|curr
operator|++
index|]
operator|=
name|AT_ANSI
expr_stmt|;
block|}
block|}
comment|/* 	 * Add a newline if necessary, 	 * and append a '\0' to the end of the line. 	 * We output a newline if we're not at the right edge of the screen, 	 * or if the terminal doesn't auto wrap, 	 * or if this is really the end of the line AND the terminal ignores 	 * a newline at the right edge. 	 * (In the last case we don't want to output a newline if the terminal  	 * doesn't ignore it since that would produce an extra blank line. 	 * But we do want to output a newline if the terminal ignores it in case 	 * the next line is blank.  In that case the single newline output for 	 * that blank line would be ignored!) 	 */
if|if
condition|(
name|column
operator|<
name|sc_width
operator|||
operator|!
name|auto_wrap
operator|||
operator|(
name|endline
operator|&&
name|ignaw
operator|)
operator|||
name|ctldisp
operator|==
name|OPT_ON
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
literal|'\n'
expr_stmt|;
name|attr
index|[
name|curr
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignaw
operator|&&
name|column
operator|>=
name|sc_width
operator|&&
name|forw
condition|)
block|{
comment|/* 		 * Terminals with "ignaw" don't wrap until they *really* need 		 * to, i.e. when the character *after* the last one to fit on a 		 * line is output. But they are too hard to deal with when they 		 * get in the state where a full screen width of characters 		 * have been output but the cursor is sitting on the right edge 		 * instead of at the start of the next line. 		 * So we nudge them into wrapping by outputting a space  		 * character plus a backspace.  But do this only if moving  		 * forward; if we're moving backward and drawing this line at 		 * the top of the screen, the space would overwrite the first 		 * char on the next line.  We don't need to do this "nudge"  		 * at the top of the screen anyway. 		 */
name|linebuf
index|[
name|curr
index|]
operator|=
literal|' '
expr_stmt|;
name|attr
index|[
name|curr
operator|++
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
name|linebuf
index|[
name|curr
index|]
operator|=
literal|'\b'
expr_stmt|;
name|attr
index|[
name|curr
operator|++
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
block|}
name|linebuf
index|[
name|curr
index|]
operator|=
literal|'\0'
expr_stmt|;
name|attr
index|[
name|curr
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|public
name|void
name|set_status_col
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|linebuf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|attr
index|[
literal|0
index|]
operator|=
name|AT_NORMAL
operator||
name|AT_HILITE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a character from the current line.  * Return the character as the function return value,  * and the character attribute in *ap.  */
end_comment

begin_function
name|public
name|int
name|gline
parameter_list|(
name|i
parameter_list|,
name|ap
parameter_list|)
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|is_null_line
condition|)
block|{
comment|/* 		 * If there is no current line, we pretend the line is 		 * either "~" or "", depending on the "twiddle" flag. 		 */
if|if
condition|(
name|twiddle
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|=
name|AT_BOLD
expr_stmt|;
return|return
literal|'~'
return|;
block|}
operator|--
name|i
expr_stmt|;
block|}
comment|/* Make sure we're back to AT_NORMAL before the '\n'.  */
operator|*
name|ap
operator|=
name|AT_NORMAL
expr_stmt|;
return|return
name|i
condition|?
literal|'\0'
else|:
literal|'\n'
return|;
block|}
operator|*
name|ap
operator|=
name|attr
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|linebuf
index|[
name|i
index|]
operator|&
literal|0xFF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Indicate that there is no current line.  */
end_comment

begin_function
name|public
name|void
name|null_line
parameter_list|()
block|{
name|is_null_line
operator|=
literal|1
expr_stmt|;
name|cshift
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Analogous to forw_line(), but deals with "raw lines":  * lines which are not split for screen width.  * {{ This is supposed to be more efficient than forw_line(). }}  */
end_comment

begin_function
name|public
name|POSITION
name|forw_raw_line
parameter_list|(
name|curr_pos
parameter_list|,
name|linep
parameter_list|,
name|line_lenp
parameter_list|)
name|POSITION
name|curr_pos
decl_stmt|;
name|char
modifier|*
modifier|*
name|linep
decl_stmt|;
name|int
modifier|*
name|line_lenp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|c
decl_stmt|;
name|POSITION
name|new_pos
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|ch_seek
argument_list|(
name|curr_pos
argument_list|)
operator|||
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|==
name|EOI
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOI
operator|||
name|ABORT_SIGS
argument_list|()
condition|)
block|{
name|new_pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|>=
name|size_linebuf
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|expand_linebuf
argument_list|()
condition|)
block|{
comment|/* 				 * Overflowed the input buffer. 				 * Pretend the line ended here. 				 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|linebuf
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
block|}
name|linebuf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|line_lenp
operator|!=
name|NULL
condition|)
operator|*
name|line_lenp
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Analogous to back_line(), but deals with "raw lines".  * {{ This is supposed to be more efficient than back_line(). }}  */
end_comment

begin_function
name|public
name|POSITION
name|back_raw_line
parameter_list|(
name|curr_pos
parameter_list|,
name|linep
parameter_list|,
name|line_lenp
parameter_list|)
name|POSITION
name|curr_pos
decl_stmt|;
name|char
modifier|*
modifier|*
name|linep
decl_stmt|;
name|int
modifier|*
name|line_lenp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|c
decl_stmt|;
name|POSITION
name|new_pos
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|curr_pos
operator|<=
name|ch_zero
argument_list|()
operator|||
name|ch_seek
argument_list|(
name|curr_pos
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|n
operator|=
name|size_linebuf
expr_stmt|;
name|linebuf
index|[
operator|--
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ch_back_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|ABORT_SIGS
argument_list|()
condition|)
block|{
comment|/* 			 * This is the newline ending the previous line. 			 * We have hit the beginning of the line. 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
block|{
comment|/* 			 * We have hit the beginning of the file. 			 * This must be the first line in the file. 			 * This must, of course, be the beginning of the line. 			 */
name|new_pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|int
name|old_size_linebuf
init|=
name|size_linebuf
decl_stmt|;
name|char
modifier|*
name|fm
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
if|if
condition|(
name|expand_linebuf
argument_list|()
condition|)
block|{
comment|/* 				 * Overflowed the input buffer. 				 * Pretend the line ended here. 				 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * Shift the data to the end of the new linebuf. 			 */
for|for
control|(
name|fm
operator|=
name|linebuf
operator|+
name|old_size_linebuf
operator|-
literal|1
operator|,
name|to
operator|=
name|linebuf
operator|+
name|size_linebuf
operator|-
literal|1
init|;
name|fm
operator|>=
name|linebuf
condition|;
name|fm
operator|--
operator|,
name|to
operator|--
control|)
operator|*
name|to
operator|=
operator|*
name|fm
expr_stmt|;
name|n
operator|=
name|size_linebuf
operator|-
name|old_size_linebuf
expr_stmt|;
block|}
name|linebuf
index|[
operator|--
name|n
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
operator|&
name|linebuf
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|line_lenp
operator|!=
name|NULL
condition|)
operator|*
name|line_lenp
operator|=
name|size_linebuf
operator|-
literal|1
operator|-
name|n
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the shift necessary to show the end of the longest displayed line.  */
end_comment

begin_function
name|public
name|int
name|rrshift
parameter_list|()
block|{
name|POSITION
name|pos
decl_stmt|;
name|int
name|save_width
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|longest
init|=
literal|0
decl_stmt|;
name|save_width
operator|=
name|sc_width
expr_stmt|;
name|sc_width
operator|=
name|INT_MAX
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|sc_height
operator|&&
name|pos
operator|!=
name|NULL_POSITION
condition|;
name|line
operator|++
control|)
block|{
name|pos
operator|=
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|>
name|longest
condition|)
name|longest
operator|=
name|column
expr_stmt|;
block|}
name|sc_width
operator|=
name|save_width
expr_stmt|;
if|if
condition|(
name|longest
operator|<
name|sc_width
condition|)
return|return
literal|0
return|;
return|return
name|longest
operator|-
name|sc_width
return|;
block|}
end_function

end_unit

