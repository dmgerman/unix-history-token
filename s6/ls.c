begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * ls - list file or directory  *  * Modified by Bill Joy UCB May/August 1977  *  * This version of ls is designed for graphic terminals and to  * list directories with lots of files in them compactly.  * It supports three variants for listings:  *  *	1) Columnar output.  *	2) Stream output.  *	3) Old one per line format.  *  * Columnar output is the default.  * If, however, the standard output is not a teletype, the default  * is one-per-line.  *  * With columnar output, the items are sorted down the columns.  * We use columns only for a directory we are interpreting.  * Thus, in particular, we do not use columns for  *  *	ls /usr/bin/p*  *  * This version of ls also prints non-printing characters as '?' if  * the standard output is a teletype.  *  * Flags relating to these and other new features are:  *  *	-m	force stream output.  *  *	-1	force one entry per line, e.g. to a teletype  *  *	-q	force non-printings to be '?'s, e.g. to a file  *  *	-c	force columnar output, e.g. into a file  *  *	-n	like -l, but user/group id's in decimal rather than  *		looking in /etc/passwd to save time  */
end_comment

begin_struct
struct|struct
block|{
name|int
name|fdes
decl_stmt|;
name|int
name|nleft
decl_stmt|;
name|char
modifier|*
name|nextc
decl_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
block|}
name|inf
struct|,
name|obuf
struct|;
end_struct

begin_struct
struct|struct
name|ibuf
block|{
name|int
name|idev
decl_stmt|;
name|int
name|inum
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|char
name|inl
decl_stmt|;
name|char
name|iuid
decl_stmt|;
name|char
name|igid
decl_stmt|;
name|char
name|isize0
decl_stmt|;
name|int
name|isize
decl_stmt|;
name|int
name|iaddr
index|[
literal|8
index|]
decl_stmt|;
name|char
modifier|*
name|iatime
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|imtime
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lbuf
block|{
name|char
name|lname
index|[
literal|15
index|]
decl_stmt|;
name|int
name|lnum
decl_stmt|;
name|int
name|lflags
decl_stmt|;
name|char
name|lnl
decl_stmt|;
name|char
name|luid
decl_stmt|;
name|char
name|lgid
decl_stmt|;
name|char
name|lsize0
decl_stmt|;
name|int
name|lsize
decl_stmt|;
name|char
modifier|*
name|lmtime
index|[
literal|2
index|]
decl_stmt|;
name|int
name|lquot
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lbufx
block|{
name|char
modifier|*
name|namep
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|aflg
decl_stmt|,
name|dflg
decl_stmt|,
name|lflg
decl_stmt|,
name|sflg
decl_stmt|,
name|tflg
decl_stmt|,
name|uflg
decl_stmt|,
name|iflg
decl_stmt|,
name|fflg
decl_stmt|,
name|nflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflg
decl_stmt|,
name|qflg
decl_stmt|,
name|across
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nopad
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|rflg
literal|1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|uidfil
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|lastuid
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|tbuf
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tblocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|statreq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|lastp
modifier|&
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|rlastp
modifier|&
name|end
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|char
operator|*
name|dotp
literal|"."
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|IFMT
value|060000
end_define

begin_define
define|#
directive|define
name|DIR
value|0100000
end_define

begin_define
define|#
directive|define
name|CHR
value|020000
end_define

begin_define
define|#
directive|define
name|BLK
value|040000
end_define

begin_define
define|#
directive|define
name|ISARG
value|01000
end_define

begin_define
define|#
directive|define
name|LARGE
value|010000
end_define

begin_define
define|#
directive|define
name|STXT
value|010000
end_define

begin_define
define|#
directive|define
name|SUID
value|04000
end_define

begin_define
define|#
directive|define
name|SGID
value|02000
end_define

begin_define
define|#
directive|define
name|ROWN
value|0400
end_define

begin_define
define|#
directive|define
name|WOWN
value|0200
end_define

begin_define
define|#
directive|define
name|XOWN
value|0100
end_define

begin_define
define|#
directive|define
name|RGRP
value|040
end_define

begin_define
define|#
directive|define
name|WGRP
value|020
end_define

begin_define
define|#
directive|define
name|XGRP
value|010
end_define

begin_define
define|#
directive|define
name|ROTH
value|04
end_define

begin_define
define|#
directive|define
name|WOTH
value|02
end_define

begin_define
define|#
directive|define
name|XOTH
value|01
end_define

begin_define
define|#
directive|define
name|RSTXT
value|01000
end_define

begin_expr_stmt
name|int
name|colwidth
literal|15
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|outcol
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|slastp
decl_stmt|;
name|struct
name|lbuf
name|lb
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|compar
parameter_list|()
function_decl|;
name|obuf
operator|.
name|fdes
operator|=
literal|1
expr_stmt|;
name|qflg
operator|=
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|obuf
operator|.
name|buff
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* 	 * If the standard output is not a teletype, 	 * then we default to one-per-line format 	 * otherwise decide between stream and 	 * columnar based on our name. 	 */
if|if
condition|(
name|qflg
condition|)
block|{
name|cflg
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
literal|0
index|]
init|;
name|cp
index|[
literal|0
index|]
operator|&&
name|cp
index|[
literal|1
index|]
condition|;
name|cp
operator|++
control|)
continue|continue;
comment|/* 		 * Name ends in l => stream 		 */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
name|nopad
operator|=
literal|1
operator|,
name|cflg
operator|=
literal|0
expr_stmt|;
comment|/* 		 * ... if doesn't end in l or s ==> columns sorted across 		 */
elseif|else
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'s'
condition|)
name|across
operator|=
literal|1
expr_stmt|;
block|}
name|time
argument_list|(
name|lb
operator|.
name|lmtime
argument_list|)
expr_stmt|;
name|year
operator|=
name|lb
operator|.
name|lmtime
index|[
literal|0
index|]
operator|-
literal|245
expr_stmt|;
comment|/* 6 months ago */
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
comment|/* 		 * c - force columnar output 		 */
case|case
literal|'c'
case|:
name|cflg
operator|=
literal|1
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* 		 * m - force stream output 		 */
case|case
literal|'m'
case|:
name|cflg
operator|=
literal|0
expr_stmt|;
name|nopad
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * x - force sort across 		 */
case|case
literal|'x'
case|:
name|across
operator|=
literal|1
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
name|cflg
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * q - force ?'s in output 		 */
case|case
literal|'q'
case|:
name|qflg
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * 1 - force 1/line in output 		 */
case|case
literal|'1'
case|:
name|cflg
operator|=
literal|0
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* STANDARD FLAGS */
case|case
literal|'a'
case|:
name|aflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|colwidth
operator|=
operator|+
literal|5
expr_stmt|;
name|sflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|dflg
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * n - don't look in password file 		 */
case|case
literal|'n'
case|:
name|nflg
operator|++
expr_stmt|;
case|case
literal|'l'
case|:
name|lflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|tflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|uflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|colwidth
operator|=
operator|+
literal|5
expr_stmt|;
name|iflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|fflg
operator|++
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|fflg
condition|)
block|{
name|aflg
operator|++
expr_stmt|;
name|lflg
operator|=
literal|0
expr_stmt|;
name|sflg
operator|=
literal|0
expr_stmt|;
name|tflg
operator|=
literal|0
expr_stmt|;
name|statreq
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lflg
condition|)
block|{
name|cflg
operator|=
literal|0
expr_stmt|;
name|t
operator|=
literal|"/etc/passwd"
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
name|colwidth
operator|=
literal|70
expr_stmt|;
name|uidfil
operator|=
name|open
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argc
operator|++
expr_stmt|;
name|argv
operator|=
operator|&
name|dotp
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|gstat
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|ep
operator|->
name|namep
operator|=
operator|*
name|argv
expr_stmt|;
name|ep
operator|->
name|lflags
operator|=
operator||
name|ISARG
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|&
name|end
argument_list|,
name|lastp
operator|-
operator|&
name|end
argument_list|,
sizeof|sizeof
expr|*
name|lastp
argument_list|,
name|compar
argument_list|)
expr_stmt|;
name|slastp
operator|=
name|lastp
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|&
name|end
init|;
name|ep
operator|<
name|slastp
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|lflags
operator|&
name|DIR
operator|&&
name|dflg
operator|==
literal|0
operator|||
name|fflg
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|ep
operator|->
name|namep
argument_list|)
expr_stmt|;
block|}
name|lastp
operator|=
name|slastp
expr_stmt|;
name|readdir
argument_list|(
name|ep
operator|->
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflg
operator|==
literal|0
condition|)
name|qsort
argument_list|(
name|slastp
argument_list|,
name|lastp
operator|-
name|slastp
argument_list|,
sizeof|sizeof
expr|*
name|lastp
argument_list|,
name|compar
argument_list|)
expr_stmt|;
if|if
condition|(
name|statreq
condition|)
block|{
name|printf
argument_list|(
literal|"total %s"
argument_list|,
name|locv
argument_list|(
literal|0
argument_list|,
name|tblocks
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pem
argument_list|(
name|slastp
argument_list|,
name|lastp
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
else|else
name|pentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outcol
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
operator|&
name|obuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|pem
argument_list|(
name|slp
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|lbuf
operator|*
name|slp
operator|,
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ncols
decl_stmt|,
name|nrows
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ep
decl_stmt|;
name|ncols
operator|=
literal|80
operator|/
name|colwidth
expr_stmt|;
if|if
condition|(
name|ncols
operator|==
literal|1
operator|||
name|cflg
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|slp
init|;
name|ep
operator|<
name|lp
condition|;
name|ep
operator|++
control|)
name|pentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|across
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|slp
init|;
name|ep
operator|<
name|lp
condition|;
name|ep
operator|++
control|)
name|pentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|statreq
condition|)
name|slp
operator|--
expr_stmt|;
name|nrows
operator|=
operator|(
name|lp
operator|-
name|slp
operator|-
literal|1
operator|)
operator|/
name|ncols
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
name|row
operator|++
control|)
block|{
name|col
operator|=
name|row
operator|==
literal|0
operator|&&
name|statreq
expr_stmt|;
for|for
control|(
init|;
name|col
operator|<
name|ncols
condition|;
name|col
operator|++
control|)
block|{
name|ep
operator|=
name|slp
operator|+
operator|(
name|nrows
operator|*
name|col
operator|)
operator|+
name|row
expr_stmt|;
if|if
condition|(
name|ep
operator|<
name|lp
condition|)
name|pentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outcol
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|outcol
operator|=
operator|(
name|outcol
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|outcol
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|qflg
operator|&&
operator|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>=
literal|0177
operator|)
condition|)
name|c
operator|=
literal|'?'
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|newline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outcol
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|column
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outcol
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|nopad
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
if|if
condition|(
name|outcol
operator|+
name|colwidth
operator|+
literal|2
operator|>
literal|80
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
literal|' '
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cflg
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|outcol
operator|/
name|colwidth
operator|+
literal|2
operator|)
operator|*
name|colwidth
operator|>
literal|80
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
return|return;
block|}
do|do
block|{
name|outcol
operator|++
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|outcol
operator|%
name|colwidth
condition|)
do|;
block|}
end_block

begin_macro
name|pentry
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
struct|struct
block|{
name|char
name|dminor
decl_stmt|,
name|dmajor
decl_stmt|;
block|}
struct|;
specifier|register
name|t
expr_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lnum
operator|==
operator|-
literal|1
condition|)
return|return;
name|column
argument_list|()
expr_stmt|;
if|if
condition|(
name|iflg
condition|)
if|if
condition|(
name|nopad
operator|&&
operator|!
name|lflg
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|p
operator|->
name|lnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4d "
argument_list|,
name|p
operator|->
name|lnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflg
condition|)
block|{
name|pmode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3d "
argument_list|,
name|p
operator|->
name|lnl
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|lgid
operator|<<
literal|8
operator||
operator|(
name|p
operator|->
name|luid
operator|&
literal|0377
operator|)
expr_stmt|;
if|if
condition|(
name|nflg
operator|==
literal|0
operator|&&
name|getname
argument_list|(
name|t
argument_list|,
name|tbuf
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%-8.8s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%3du%3dg"
argument_list|,
operator|(
name|t
operator|&
literal|0377
operator|)
argument_list|,
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0377
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lflags
operator|&
operator|(
name|BLK
operator||
name|CHR
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|lflags
operator|&
name|CHR
operator|&&
name|p
operator|->
name|lsize
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"%4d/%4d"
argument_list|,
name|p
operator|->
name|lquot
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|lquot
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4d,%4d"
argument_list|,
name|p
operator|->
name|lsize
operator|.
name|dmajor
operator|&
literal|0477
argument_list|,
name|p
operator|->
name|lsize
operator|.
name|dminor
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%9s"
argument_list|,
name|locv
argument_list|(
name|p
operator|->
name|lsize0
operator|&
literal|0377
argument_list|,
name|p
operator|->
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflg
condition|)
block|{
name|t
operator|=
name|nblock
argument_list|(
name|p
operator|->
name|lsize0
operator|&
literal|0377
argument_list|,
name|p
operator|->
name|lsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nopad
operator|&&
operator|!
name|lflg
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|locv
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4s "
argument_list|,
name|locv
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lflg
condition|)
block|{
if|if
condition|(
operator|!
name|sflg
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
name|p
operator|->
name|lmtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lmtime
index|[
literal|0
index|]
operator|<
name|year
condition|)
name|printf
argument_list|(
literal|"%-7.7s %-4.4s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12.12s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|lflags
operator|&
name|ISARG
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%.14s"
argument_list|,
name|p
operator|->
name|lname
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getname
argument_list|(
argument|uid
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|uid
operator|==
name|lastuid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|inf
operator|.
name|fdes
operator|=
name|uidfil
expr_stmt|;
name|seek
argument_list|(
name|inf
operator|.
name|fdes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inf
operator|.
name|nleft
operator|=
literal|0
expr_stmt|;
name|lastuid
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
operator|&
name|inf
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|c
operator|=
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|2
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|3
condition|)
name|m
operator|=
name|m
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|m
operator|<<
literal|8
operator||
name|n
operator|)
operator|!=
name|uid
condition|)
do|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lastuid
operator|=
name|uid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nblock
argument_list|(
argument|size0
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|size0
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|ldiv
argument_list|(
name|size0
operator|&
literal|0377
argument_list|,
name|size
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&
literal|0777
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|8
condition|)
name|n
operator|=
operator|+
operator|(
name|n
operator|+
literal|255
operator|)
operator|/
literal|256
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|m0
index|[]
block|{
literal|3
operator|,
name|DIR
operator|,
literal|'d'
operator|,
name|BLK
operator|,
literal|'b'
operator|,
name|CHR
operator|,
literal|'c'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m1
index|[]
block|{
literal|1
operator|,
name|ROWN
operator|,
literal|'r'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m2
index|[]
block|{
literal|1
operator|,
name|WOWN
operator|,
literal|'w'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m3
index|[]
block|{
literal|2
operator|,
name|SUID
operator|,
literal|'s'
operator|,
name|XOWN
operator|,
literal|'x'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m4
index|[]
block|{
literal|1
operator|,
name|ROTH
operator|,
literal|'r'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m5
index|[]
block|{
literal|1
operator|,
name|WOTH
operator|,
literal|'w'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|m6
index|[]
block|{
literal|2
operator|,
name|STXT
operator|,
literal|'t'
operator|,
name|XOTH
operator|,
literal|'x'
operator|,
literal|'-'
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
modifier|*
name|m
index|[]
block|{
name|m0
operator|,
name|m1
operator|,
name|m2
operator|,
name|m3
operator|,
name|m4
operator|,
name|m5
operator|,
name|m6
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|pmode
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ptr
expr_stmt|;
name|flags
operator|=
name|p
operator|->
name|lflags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHR
operator|&&
name|p
operator|->
name|lsize
operator|==
operator|-
literal|1
condition|)
name|putchar
argument_list|(
literal|'q'
argument_list|)
expr_stmt|;
else|else
name|select
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|m
index|[
literal|1
index|]
init|;
name|mp
operator|<
operator|&
name|m
index|[
literal|7
index|]
condition|;
control|)
name|select
argument_list|(
operator|*
name|mp
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|select
argument_list|(
argument|pairp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|pairp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|pairp
expr_stmt|;
name|n
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|(
name|flags
operator|&
operator|*
name|ap
operator|++
operator|)
operator|==
literal|0
condition|)
name|ap
operator|++
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|makename
argument_list|(
argument|dir
argument_list|,
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|dfile
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|dp
operator|=
name|dfile
expr_stmt|;
name|fp
operator|=
name|dir
expr_stmt|;
while|while
condition|(
operator|*
name|fp
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|fp
operator|=
name|file
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dfile
operator|)
return|;
block|}
end_block

begin_macro
name|readdir
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
struct|struct
block|{
name|int
name|dinode
decl_stmt|;
name|char
name|dname
index|[
literal|14
index|]
decl_stmt|;
block|}
name|dentry
struct|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|fopen
argument_list|(
name|dir
argument_list|,
operator|&
name|inf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|newline
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s unreadable\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|tblocks
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
operator|&
name|dentry
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|getc
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dentry
operator|.
name|dinode
operator|==
literal|0
operator|||
name|aflg
operator|==
literal|0
operator|&&
name|dentry
operator|.
name|dname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
if|if
condition|(
name|dentry
operator|.
name|dinode
operator|==
operator|-
literal|1
condition|)
break|break;
name|ep
operator|=
name|gstat
argument_list|(
name|makename
argument_list|(
name|dir
argument_list|,
name|dentry
operator|.
name|dname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|lnum
operator|!=
operator|-
literal|1
condition|)
name|ep
operator|->
name|lnum
operator|=
name|dentry
operator|.
name|dinode
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|14
condition|;
name|j
operator|++
control|)
name|ep
operator|->
name|lname
index|[
name|j
index|]
operator|=
name|dentry
operator|.
name|dname
index|[
name|j
index|]
expr_stmt|;
block|}
name|close
argument_list|(
name|inf
operator|.
name|fdes
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gstat
argument_list|(
argument|file
argument_list|,
argument|argfl
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ibuf
name|statb
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|rep
decl_stmt|;
if|if
condition|(
name|lastp
operator|+
literal|1
operator|>=
name|rlastp
condition|)
block|{
name|sbrk
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|rlastp
operator|.
name|idev
operator|=
operator|+
literal|512
expr_stmt|;
block|}
name|rep
operator|=
name|lastp
expr_stmt|;
name|lastp
operator|++
expr_stmt|;
name|rep
operator|->
name|lflags
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|lnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argfl
operator|||
name|statreq
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|newline
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s not found\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|statb
operator|.
name|inum
operator|=
operator|-
literal|1
expr_stmt|;
name|statb
operator|.
name|isize0
operator|=
literal|0
expr_stmt|;
name|statb
operator|.
name|isize
operator|=
literal|0
expr_stmt|;
name|statb
operator|.
name|iflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argfl
condition|)
block|{
name|lastp
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|rep
operator|->
name|lnum
operator|=
name|statb
operator|.
name|inum
expr_stmt|;
name|statb
operator|.
name|iflags
operator|=
operator|&
operator|~
name|DIR
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|iflags
operator|&
name|IFMT
operator|)
operator|==
literal|060000
condition|)
block|{
name|statb
operator|.
name|iflags
operator|=
operator|&
operator|~
literal|020000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|statb
operator|.
name|iflags
operator|&
name|IFMT
operator|)
operator|==
literal|040000
condition|)
block|{
name|statb
operator|.
name|iflags
operator|=
operator|&
operator|~
name|IFMT
expr_stmt|;
name|statb
operator|.
name|iflags
operator|=
operator||
name|DIR
expr_stmt|;
block|}
name|statb
operator|.
name|iflags
operator|=
operator|&
operator|~
name|LARGE
expr_stmt|;
if|if
condition|(
name|statb
operator|.
name|iflags
operator|&
name|RSTXT
condition|)
name|statb
operator|.
name|iflags
operator|=
operator||
name|STXT
expr_stmt|;
name|statb
operator|.
name|iflags
operator|=
operator|&
operator|~
name|RSTXT
expr_stmt|;
name|rep
operator|->
name|lflags
operator|=
name|statb
operator|.
name|iflags
expr_stmt|;
name|rep
operator|->
name|luid
operator|=
name|statb
operator|.
name|iuid
expr_stmt|;
name|rep
operator|->
name|lgid
operator|=
name|statb
operator|.
name|igid
expr_stmt|;
name|rep
operator|->
name|lnl
operator|=
name|statb
operator|.
name|inl
expr_stmt|;
name|rep
operator|->
name|lsize0
operator|=
name|statb
operator|.
name|isize0
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|isize
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|lflags
operator|&
operator|(
name|BLK
operator||
name|CHR
operator|)
operator|&&
name|lflg
condition|)
block|{
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|iaddr
index|[
literal|0
index|]
expr_stmt|;
name|rep
operator|->
name|lquot
index|[
literal|0
index|]
operator|=
name|statb
operator|.
name|iaddr
index|[
literal|1
index|]
expr_stmt|;
name|rep
operator|->
name|lquot
index|[
literal|1
index|]
operator|=
name|statb
operator|.
name|iaddr
index|[
literal|2
index|]
expr_stmt|;
block|}
name|rep
operator|->
name|lmtime
index|[
literal|0
index|]
operator|=
name|statb
operator|.
name|imtime
index|[
literal|0
index|]
expr_stmt|;
name|rep
operator|->
name|lmtime
index|[
literal|1
index|]
operator|=
name|statb
operator|.
name|imtime
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|uflg
condition|)
block|{
name|rep
operator|->
name|lmtime
index|[
literal|0
index|]
operator|=
name|statb
operator|.
name|iatime
index|[
literal|0
index|]
expr_stmt|;
name|rep
operator|->
name|lmtime
index|[
literal|1
index|]
operator|=
name|statb
operator|.
name|iatime
index|[
literal|1
index|]
expr_stmt|;
block|}
name|tblocks
operator|=
operator|+
name|nblock
argument_list|(
name|statb
operator|.
name|isize0
argument_list|,
name|statb
operator|.
name|isize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rep
operator|)
return|;
block|}
end_block

begin_macro
name|compar
argument_list|(
argument|ap1
argument_list|,
argument|ap2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|ap1
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lbuf
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|charp
decl_stmt|;
block|}
struct|;
name|p1
operator|=
name|ap1
expr_stmt|;
name|p2
operator|=
name|ap2
expr_stmt|;
if|if
condition|(
name|dflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p1
operator|->
name|lflags
operator|&
operator|(
name|DIR
operator||
name|ISARG
operator|)
operator|)
operator|==
operator|(
name|DIR
operator||
name|ISARG
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p2
operator|->
name|lflags
operator|&
operator|(
name|DIR
operator||
name|ISARG
operator|)
operator|)
operator|!=
operator|(
name|DIR
operator||
name|ISARG
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p2
operator|->
name|lflags
operator|&
operator|(
name|DIR
operator||
name|ISARG
operator|)
operator|)
operator|==
operator|(
name|DIR
operator||
name|ISARG
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tflg
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|lmtime
index|[
literal|0
index|]
operator|>
name|p1
operator|->
name|lmtime
index|[
literal|0
index|]
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|->
name|lmtime
index|[
literal|0
index|]
operator|<
name|p1
operator|->
name|lmtime
index|[
literal|0
index|]
condition|)
name|i
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|->
name|lmtime
index|[
literal|1
index|]
operator|>
name|p1
operator|->
name|lmtime
index|[
literal|1
index|]
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|p2
operator|->
name|lmtime
index|[
literal|1
index|]
operator|<
name|p1
operator|->
name|lmtime
index|[
literal|1
index|]
condition|)
name|i
operator|--
expr_stmt|;
return|return
operator|(
name|i
operator|*
name|rflg
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|lflags
operator|&
name|ISARG
condition|)
name|p1
operator|=
name|p1
operator|->
name|namep
expr_stmt|;
else|else
name|p1
operator|=
name|p1
operator|->
name|lname
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|lflags
operator|&
name|ISARG
condition|)
name|p2
operator|=
name|p2
operator|->
name|namep
expr_stmt|;
else|else
name|p2
operator|=
name|p2
operator|->
name|lname
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
if|if
condition|(
operator|(
name|j
operator|=
operator|*
name|p1
operator|.
name|charp
operator|++
operator|-
operator|*
name|p2
operator|.
name|charp
operator|++
operator|)
operator|||
name|p1
operator|.
name|charp
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|rflg
operator|*
name|j
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

