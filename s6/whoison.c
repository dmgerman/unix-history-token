begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * whoison - who is on the system  *  * Author: Bill Joy UCB May/July 1977  *  * Inspired by a shell script written by Howard Katseff  * and the who program and the program ttyfree by Chuck Haley.  *  * Whoison summarizes one or more of the following  *  *	Users who aren't students in a class  *	Distribution of class users by class  *	Used, free, and unavail terminals grouped by  *	    Evans, Cory, Phones, 11/10, and Private  *  * Options are:  *  *	p	print people  *	u	print used  *	f	print free  *	n	print unavail  *	d	print class distribution  *	s	print summary  *  * Option "-" is equivalent to "-pufnd"  * Default is "-pds".  */
end_comment

begin_struct
struct|struct
name|alias
block|{
name|char
modifier|*
name|aname
decl_stmt|;
name|char
name|auid
decl_stmt|,
name|agid
decl_stmt|;
block|}
name|aliases
index|[
literal|50
index|]
struct|;
end_struct

begin_struct
struct|struct
name|dist
block|{
name|char
modifier|*
name|dname
decl_stmt|;
name|struct
name|dist2
modifier|*
name|link
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|}
name|distrib
index|[
literal|50
index|]
struct|;
end_struct

begin_struct
struct|struct
name|dist2
block|{
name|char
modifier|*
name|patt
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|USED
value|0
end_define

begin_define
define|#
directive|define
name|FREE
value|1
end_define

begin_define
define|#
directive|define
name|UNAVAIL
value|2
end_define

begin_decl_stmt
name|int
name|total
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ttyw
block|{
name|char
modifier|*
name|tname
decl_stmt|;
name|int
name|tcnts
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|ttys
decl_stmt|;
block|}
name|ttywhere
index|[
literal|50
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|NTTY
value|128
end_define

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|obuf
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|utmp
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|char
name|tty
decl_stmt|;
name|char
name|fill
decl_stmt|;
name|long
name|timeon
decl_stmt|;
name|char
name|uid
decl_stmt|;
name|char
name|gid
decl_stmt|;
block|}
name|utmpbuf
index|[
name|NTTY
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|status
index|[
name|NTTY
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|P
value|1
end_define

begin_comment
comment|/* people */
end_comment

begin_define
define|#
directive|define
name|U
value|2
end_define

begin_comment
comment|/* used */
end_comment

begin_define
define|#
directive|define
name|F
value|4
end_define

begin_comment
comment|/* free */
end_comment

begin_define
define|#
directive|define
name|N
value|8
end_define

begin_comment
comment|/* not available */
end_comment

begin_define
define|#
directive|define
name|D
value|16
end_define

begin_comment
comment|/* distribution */
end_comment

begin_define
define|#
directive|define
name|S
value|32
end_define

begin_comment
comment|/* summary */
end_comment

begin_expr_stmt
name|int
name|flags
name|P
operator||
name|D
operator||
name|S
operator||
name|F
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|usagestr
index|[]
literal|"usage: %s [ -pufnds ]\n"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|char
name|utmp
index|[]
literal|"/etc/utmp"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
operator|*
name|winfo
literal|"/etc/winfo"
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
name|qucmp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|xargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|xargv
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|argp
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|utmp
modifier|*
name|up
decl_stmt|;
name|char
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|;
name|int
name|ibuf
index|[
literal|259
index|]
decl_stmt|;
name|argc
operator|--
expr_stmt|;
name|progname
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|progname
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
name|winfo
operator|=
literal|"winfo"
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|argp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|++
operator|!=
literal|'-'
condition|)
break|break;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|==
literal|0
condition|)
name|flags
operator|=
name|P
operator||
name|U
operator||
name|F
operator||
name|N
operator||
name|D
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|argp
condition|)
switch|switch
condition|(
operator|*
name|argp
operator|++
condition|)
block|{
case|case
literal|'p'
case|:
name|flags
operator|=
operator||
name|P
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|flags
operator|=
operator||
name|U
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|flags
operator|=
operator||
name|F
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|flags
operator|=
operator||
name|N
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|flags
operator|=
operator||
name|D
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|flags
operator|=
operator||
name|S
expr_stmt|;
continue|continue;
default|default:
name|usage
label|:
name|printf
argument_list|(
name|usagestr
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|xargc
operator|=
name|argc
expr_stmt|;
if|if
condition|(
name|xargc
operator|>
literal|0
condition|)
name|flags
operator|=
operator||
name|P
expr_stmt|;
name|xargv
operator|=
name|argv
expr_stmt|;
name|obuf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|initdata
argument_list|()
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"/etc/utmp: Cannot open\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|read
argument_list|(
literal|0
argument_list|,
name|utmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|utmpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|up
operator|=
operator|&
name|utmpbuf
init|;
name|up
operator|<
operator|&
name|utmpbuf
index|[
name|NTTY
index|]
condition|;
name|i
operator|++
operator|,
name|up
operator|++
control|)
name|up
operator|->
name|tty
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|utmpbuf
argument_list|,
name|NTTY
argument_list|,
sizeof|sizeof
name|utmpbuf
index|[
literal|0
index|]
argument_list|,
name|qucmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/etc/ttys"
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"/etc/ttys: Cannot open\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ibuf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|d
operator|=
name|getc
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|status
index|[
name|d
index|]
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ibuf
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
block|}
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|up
operator|=
operator|&
name|utmpbuf
init|;
name|up
operator|<
operator|&
name|utmpbuf
index|[
name|NTTY
index|]
condition|;
name|up
operator|++
control|)
name|process
argument_list|(
name|up
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&&
operator|(
name|flags
operator|&
name|P
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|D
condition|)
if|if
condition|(
operator|(
name|flags
operator|&
name|U
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|S
operator|)
condition|)
if|if
condition|(
name|pdist
argument_list|(
literal|""
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|pwhere
argument_list|(
name|USED
argument_list|,
literal|"used"
argument_list|,
name|flags
operator|&
name|U
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|D
condition|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|U
operator|)
operator|&&
operator|(
name|flags
operator|&
name|S
operator|)
condition|)
if|if
condition|(
name|pdist
argument_list|(
literal|" ("
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|")\r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|U
operator|)
operator|||
operator|(
name|flags
operator|&
name|S
operator|)
operator|&&
operator|(
name|flags
operator|&
name|D
operator|)
operator|&&
operator|(
name|flags
operator|&
name|F
operator|)
condition|)
if|if
condition|(
name|count
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|pwhere
argument_list|(
name|FREE
argument_list|,
literal|"free"
argument_list|,
name|flags
operator|&
name|F
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|U
operator||
name|F
operator|)
operator|&&
operator|(
name|flags
operator|&
name|N
operator|)
condition|)
if|if
condition|(
name|count
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|N
condition|)
name|pwhere
argument_list|(
name|UNAVAIL
argument_list|,
literal|"unavail"
argument_list|,
name|flags
operator|&
name|N
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a utmp entry, accounting for  * this teletype in the statistics and printing  * an entry for this tty via puser if this tty  * is in use. Status negative indicates  * that this tty has already been processed out  * of order.  */
end_comment

begin_expr_stmt
name|process
argument_list|(
name|up
argument_list|)
specifier|register
expr|struct
name|utmp
operator|*
name|up
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|status
index|[
name|up
operator|->
name|tty
index|]
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|status
index|[
name|up
operator|->
name|tty
index|]
operator|==
literal|0
condition|)
block|{
name|account
argument_list|(
name|up
operator|->
name|tty
argument_list|,
name|UNAVAIL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|up
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|account
argument_list|(
name|up
operator|->
name|tty
argument_list|,
name|USED
argument_list|)
expr_stmt|;
name|puser
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return;
block|}
name|account
argument_list|(
name|up
operator|->
name|tty
argument_list|,
name|FREE
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|whereat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * account for the argument tty to be in the  * given state.  We use the ttywhere information  * to locate the place for this tty's statistics.  * It is an error for a tty to be in any state but  * unavail if it is not in any of the tty lists  * (this likely corresponds to a need to update  * the data in winfo).  */
end_comment

begin_macro
name|account
argument_list|(
argument|tty
argument_list|,
argument|state
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tty
decl_stmt|,
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ttyw
modifier|*
name|tp
decl_stmt|;
name|status
index|[
name|tty
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|ttywhere
init|;
name|tp
operator|->
name|tname
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|any
argument_list|(
name|tty
argument_list|,
name|tp
operator|->
name|ttys
argument_list|)
condition|)
block|{
name|tp
operator|->
name|tcnts
index|[
name|state
index|]
operator|++
expr_stmt|;
name|total
index|[
name|state
index|]
operator|++
expr_stmt|;
name|whereat
operator|=
name|tp
operator|->
name|tname
expr_stmt|;
return|return;
block|}
name|whereat
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|UNAVAIL
condition|)
return|return;
name|printf
argument_list|(
literal|"tty%c is %s???, \r"
argument_list|,
name|tty
argument_list|,
name|state
operator|==
name|USED
condition|?
literal|"used"
else|:
literal|"free"
argument_list|)
expr_stmt|;
name|total
index|[
name|state
index|]
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print out a user if he is not a student.  * We call rest on such users to do "and ...".  */
end_comment

begin_macro
name|puser
argument_list|(
argument|up
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|utmp
modifier|*
name|up
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|dist
modifier|*
name|dp
decl_stmt|;
name|cp
operator|=
name|up
operator|->
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|<=
literal|' '
operator|||
operator|*
name|cp
operator|>=
literal|0177
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|xargc
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xargc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|clmatch
argument_list|(
name|xargv
index|[
name|i
index|]
argument_list|,
name|up
argument_list|)
operator|||
name|clmatch
argument_list|(
name|xargv
index|[
name|i
index|]
argument_list|,
name|whereat
argument_list|)
operator|||
name|xargv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|xargv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|up
operator|->
name|tty
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|xargc
condition|)
return|return;
block|}
else|else
block|{
for|for
control|(
name|dp
operator|=
name|distrib
init|;
name|dp
operator|->
name|dname
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|clmatch
argument_list|(
name|dp
argument_list|,
name|up
argument_list|)
condition|)
block|{
name|dodist
argument_list|(
name|up
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|count
condition|)
if|if
condition|(
name|flags
operator|&
name|P
condition|)
name|printf
argument_list|(
literal|", \r"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|P
condition|)
name|printf
argument_list|(
literal|"%0.8s on %c"
argument_list|,
name|up
operator|->
name|name
argument_list|,
name|ttyof
argument_list|(
name|up
operator|->
name|tty
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|fill
condition|)
name|pas
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|dodist
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|rest
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find the rest of the instances of e.g. "root"  * to do like "root on 5 and 8"  */
end_comment

begin_expr_stmt
name|rest
argument_list|(
name|up
argument_list|)
specifier|register
expr|struct
name|utmp
operator|*
name|up
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|utmp
modifier|*
name|aup
decl_stmt|;
for|for
control|(
name|aup
operator|=
name|up
operator|+
literal|1
init|;
name|aup
operator|<
operator|&
name|utmpbuf
index|[
name|NTTY
index|]
condition|;
name|aup
operator|++
control|)
if|if
condition|(
name|same
argument_list|(
name|up
operator|->
name|name
argument_list|,
name|aup
operator|->
name|name
argument_list|)
condition|)
block|{
name|dodist
argument_list|(
name|aup
argument_list|)
expr_stmt|;
name|aup
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|P
condition|)
name|printf
argument_list|(
literal|" and %c"
argument_list|,
name|ttyof
argument_list|(
name|aup
operator|->
name|tty
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aup
operator|->
name|fill
condition|)
name|pas
argument_list|(
name|aup
argument_list|)
expr_stmt|;
name|account
argument_list|(
name|aup
operator|->
name|tty
argument_list|,
name|USED
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ttyof
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|t
operator|<
literal|' '
condition|?
literal|'^'
operator||
operator|(
operator|(
name|t
operator|+
literal|'a'
operator|-
literal|1
operator|)
operator|<<
literal|8
operator|)
else|:
name|t
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * print "(as name)" when root is su'd to  * someone else.  */
end_comment

begin_expr_stmt
name|pas
argument_list|(
name|up
argument_list|)
specifier|register
expr|struct
name|utmp
operator|*
name|up
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|alias
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|aliases
init|;
name|ap
operator|->
name|aname
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|ap
operator|->
name|auid
operator|==
name|up
operator|->
name|uid
operator|&&
name|ap
operator|->
name|agid
operator|==
name|up
operator|->
name|gid
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|P
condition|)
name|printf
argument_list|(
literal|" (as %s)"
argument_list|,
name|ap
operator|->
name|aname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|P
condition|)
name|printf
argument_list|(
literal|" (as ???)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * dodist distributes up into the correct  * "class" for the class summary.  */
end_comment

begin_macro
name|dodist
argument_list|(
argument|up
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|utmp
modifier|*
name|up
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dist
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|distrib
init|;
name|dp
operator|->
name|dname
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|clmatch
argument_list|(
name|dp
argument_list|,
name|up
argument_list|)
condition|)
block|{
name|dp
operator|->
name|cnt
operator|++
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|clmatch
argument_list|(
name|dp
argument_list|,
name|up
argument_list|)
specifier|register
expr|struct
name|dist
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|utmp
modifier|*
name|up
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|clname
index|[
literal|9
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|dist2
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|clname
index|[
name|i
index|]
operator|=
name|up
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
name|clname
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
operator|&&
name|clname
index|[
name|i
index|]
operator|==
literal|' '
condition|;
name|i
operator|--
control|)
name|clname
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|>
operator|&
name|clname
condition|)
comment|/* kludge to recognize members of argv */
return|return
operator|(
name|amatch
argument_list|(
name|clname
argument_list|,
name|dp
argument_list|)
operator|)
return|;
for|for
control|(
name|lp
operator|=
name|dp
operator|->
name|link
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
if|if
condition|(
name|amatch
argument_list|(
name|clname
argument_list|,
name|lp
operator|->
name|patt
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|amatch
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
specifier|register
name|char
operator|*
name|cp
operator|,
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|pp
condition|)
switch|switch
condition|(
operator|*
name|pp
condition|)
block|{
case|case
literal|'?'
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|++
expr_stmt|;
name|pp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
name|pp
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|amatch
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
operator|*
name|pp
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|*
name|cp
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * pdist prints the classwise distribution  */
end_comment

begin_macro
name|pdist
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dist
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|distrib
init|;
name|dp
operator|->
name|dname
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|cnt
condition|)
block|{
if|if
condition|(
name|l
condition|)
block|{
name|printf
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|", \r"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %s"
argument_list|,
name|dp
operator|->
name|cnt
argument_list|,
name|dp
operator|->
name|dname
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * pwhere breaks down the teletypes in state  * (which is called sname) by location.  * nothing is printed if there are no such,  * otherwise we terminate with \n.  */
end_comment

begin_macro
name|pwhere
argument_list|(
argument|state
argument_list|,
argument|sname
argument_list|,
argument|allinfo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|state
decl_stmt|,
name|allinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ttyw
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|S
operator|)
operator|==
literal|0
operator|&&
name|allinfo
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|", \r"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%d %s\r"
argument_list|,
name|total
index|[
name|state
index|]
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|allinfo
operator|==
literal|0
condition|)
return|return;
name|sname
operator|=
literal|" ("
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|ttywhere
init|;
name|tp
operator|->
name|tname
condition|;
name|tp
operator|++
control|)
if|if
condition|(
name|tp
operator|->
name|tcnts
index|[
name|state
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d %s"
argument_list|,
name|sname
argument_list|,
name|tp
operator|->
name|tcnts
index|[
name|state
index|]
argument_list|,
name|tp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|sname
operator|=
literal|", \r"
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sname
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|printf
argument_list|(
literal|")\r"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * SUBROUTINES  */
end_comment

begin_comment
comment|/*  * pref tells whether cp is a prefix of dp  */
end_comment

begin_expr_stmt
name|pref
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
specifier|register
name|char
operator|*
name|cp
operator|,
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
operator|*
name|dp
condition|)
name|cp
operator|++
operator|,
name|dp
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|cp
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|same
argument_list|(
argument|cp
argument_list|,
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|ucmp
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|qucmp
argument_list|(
argument|cp
argument_list|,
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|utmp
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ucmp
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|cp
operator|->
name|tty
operator|-
name|dp
operator|->
name|tty
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ucmp
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
specifier|register
name|char
operator|*
name|cp
operator|,
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|++
operator|==
operator|*
name|dp
operator|++
condition|)
if|if
condition|(
operator|--
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|--
name|cp
operator|,
operator|--
name|dp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|dp
operator|==
literal|' '
operator|||
operator|*
name|dp
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|*
name|cp
operator|-
operator|*
name|dp
operator|)
return|;
block|}
end_block

begin_macro
name|ucmpA
argument_list|(
argument|cp0
argument_list|,
argument|dp0
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|utmp
modifier|*
name|cp0
decl_stmt|,
modifier|*
name|dp0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cp
operator|=
operator|&
name|cp0
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|dp0
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|++
operator|==
operator|*
name|dp
operator|++
condition|)
if|if
condition|(
operator|--
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|cp0
operator|->
name|tty
operator|-
name|dp0
operator|->
name|tty
operator|)
return|;
operator|--
name|cp
operator|,
operator|--
name|dp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|dp
operator|==
literal|' '
operator|||
operator|*
name|dp
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|cp0
operator|->
name|tty
operator|-
name|dp0
operator|->
name|tty
operator|)
return|;
return|return
operator|(
operator|*
name|cp
operator|-
operator|*
name|dp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * is c any of the characters in s ?  */
end_comment

begin_macro
name|any
argument_list|(
argument|c
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|s
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The following definitions of putchar and item and the sav buffer  * implement breakover formatting of the output.  * Each carriage return character in the putchar stream '\r'  * indicates that an item has come to an end and that a reasonable  * place for a breakover is occuring.  *  * If this item will fit on the current line it is placed there  * after output of the saved trailing blanks of the previous item.  * If it will not fit there then the trailing blanks of the previous  * line and the leading blanks of this line are discarded and the  * item is placed on the next line.  *  * In any case a newline character causes the item buffer to be emptied.  */
end_comment

begin_decl_stmt
name|char
name|sav
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|savp
name|sav
decl_stmt|;
end_decl_stmt

begin_macro
name|putchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
operator|*
name|savp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|item
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|item
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|outcol
decl_stmt|,
name|oweblanks
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
operator|*
name|savp
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|sav
expr_stmt|;
if|if
condition|(
name|outcol
operator|!=
literal|0
operator|&&
name|outcol
operator|+
name|oweblanks
operator|+
operator|(
name|savp
operator|-
name|sav
operator|)
operator|>=
literal|79
condition|)
block|{
name|outcol
operator|=
literal|0
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outcol
operator|==
literal|0
condition|)
block|{
name|oweblanks
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|oweblanks
operator|>
literal|0
condition|;
name|oweblanks
operator|--
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
while|while
condition|(
name|savp
operator|>=
name|cp
operator|&&
operator|*
name|savp
operator|==
literal|' '
condition|)
name|oweblanks
operator|++
operator|,
name|savp
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\n'
condition|)
name|outcol
operator|=
literal|0
expr_stmt|;
else|else
name|outcol
operator|++
expr_stmt|;
block|}
name|savp
operator|=
name|sav
expr_stmt|;
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|lastc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ibuf
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
specifier|inline
literal|1
expr_stmt|;
end_expr_stmt

begin_macro
name|initdata
argument_list|()
end_macro

begin_block
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fopen
argument_list|(
name|winfo
argument_list|,
name|ibuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|winfo
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|inittty
argument_list|()
expr_stmt|;
name|initdist
argument_list|()
expr_stmt|;
name|initalias
argument_list|()
expr_stmt|;
name|eof
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|inittty
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ttyw
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|ttywhere
index|[
literal|0
index|]
init|;
name|tp
operator|->
name|tname
operator|=
name|field
argument_list|()
condition|;
name|tp
operator|++
control|)
block|{
name|tp
operator|->
name|ttys
operator|=
name|tail
argument_list|()
expr_stmt|;
name|eol
argument_list|()
expr_stmt|;
block|}
name|eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|initdist
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|dist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|dist2
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|dp
operator|=
operator|&
name|distrib
index|[
literal|0
index|]
init|;
name|dp
operator|->
name|dname
operator|=
name|field
argument_list|()
condition|;
name|dp
operator|++
control|)
block|{
while|while
condition|(
name|lastc
operator|!=
literal|'\n'
operator|&&
name|lastc
operator|!=
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|tail
argument_list|()
expr_stmt|;
name|lp
operator|=
name|dp
operator|->
name|link
expr_stmt|;
name|dp
operator|->
name|link
operator|=
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|lp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|link
operator|->
name|patt
operator|=
name|cp
expr_stmt|;
name|dp
operator|->
name|link
operator|->
name|next
operator|=
name|lp
expr_stmt|;
block|}
name|eol
argument_list|()
expr_stmt|;
block|}
name|eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|initalias
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|alias
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
operator|&
name|aliases
index|[
literal|0
index|]
init|;
name|ap
operator|->
name|aname
operator|=
name|field
argument_list|()
condition|;
name|ap
operator|++
control|)
block|{
name|ap
operator|->
name|auid
operator|=
name|number
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ap
operator|->
name|agid
operator|=
name|number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|eol
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|inpanic
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s: %s, line %d\n"
argument_list|,
name|winfo
argument_list|,
name|cp
argument_list|,
specifier|inline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eol
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|lastc
operator|!=
literal|'\n'
condition|)
name|inpanic
argument_list|(
literal|"Too many fields in line"
argument_list|)
expr_stmt|;
specifier|inline
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|eof
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|getc
argument_list|(
name|ibuf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|inpanic
argument_list|(
literal|"Too much data in file"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|field
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|field1
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|tail
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|field1
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|number
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|field1
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|inpanic
argument_list|(
literal|"Number expected"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|)
name|i
operator|=
operator|*
literal|10
operator|,
name|i
operator|=
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|inpanic
argument_list|(
literal|"Badly formed number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|field1
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
name|c
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
operator|-
literal|1
case|:
case|case
literal|'\n'
case|:
name|lastc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|buf
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|inpanic
argument_list|(
literal|"Missing ':'"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'|'
case|:
case|case
literal|':'
case|:
name|lastc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|bp
operator|==
name|buf
condition|)
name|inpanic
argument_list|(
literal|"Empty field"
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|savestr
argument_list|(
name|buf
argument_list|)
operator|)
return|;
default|default:
if|if
condition|(
name|bp
operator|>=
operator|&
name|buf
index|[
literal|99
index|]
condition|)
name|inpanic
argument_list|(
literal|"Field too long"
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|savestr
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|strcpy
argument_list|(
name|alloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|cp
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|strcpy
argument_list|(
argument|oto
argument_list|,
argument|from
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
name|to
operator|=
name|oto
expr_stmt|;
while|while
condition|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
condition|)
continue|continue;
return|return
operator|(
name|oto
operator|)
return|;
block|}
end_block

end_unit

