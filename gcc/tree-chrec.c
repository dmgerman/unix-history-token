begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Chains of recurrences.    Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Sebastian Pop<pop@cri.ensmp.fr>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file implements operations on chains of recurrences.  Chains    of recurrences are used for modeling evolution functions of scalar    variables. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Extended folder for chrecs.  */
end_comment

begin_comment
comment|/* Determines whether CST is not a constant evolution.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_not_constant_evolution
parameter_list|(
name|tree
name|cst
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fold CODE for a polynomial function and a constant.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|chrec_fold_poly_cst
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|poly
parameter_list|,
name|tree
name|cst
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|poly
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|cst
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|poly
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|is_not_constant_evolution
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type
operator|==
name|chrec_type
argument_list|(
name|poly
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly
argument_list|)
argument_list|,
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly
argument_list|)
argument_list|,
name|cst
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly
argument_list|)
argument_list|)
return|;
case|case
name|MINUS_EXPR
case|:
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly
argument_list|)
argument_list|,
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly
argument_list|)
argument_list|,
name|cst
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly
argument_list|)
argument_list|)
return|;
case|case
name|MULT_EXPR
case|:
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly
argument_list|)
argument_list|,
name|cst
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly
argument_list|)
argument_list|,
name|cst
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|chrec_dont_know
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fold the addition of two polynomial functions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|chrec_fold_plus_poly_poly
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|poly0
parameter_list|,
name|tree
name|poly1
parameter_list|)
block|{
name|tree
name|left
decl_stmt|,
name|right
decl_stmt|;
name|gcc_assert
argument_list|(
name|poly0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|poly1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|poly0
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|poly1
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|chrec_type
argument_list|(
name|poly0
argument_list|)
operator|==
name|chrec_type
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type
operator|==
name|chrec_type
argument_list|(
name|poly0
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     {a, +, b}_1 + {c, +, d}_2  ->  {{a, +, b}_1 + c, +, d}_2,     {a, +, b}_2 + {c, +, d}_1  ->  {{c, +, d}_1 + a, +, b}_2,     {a, +, b}_x + {c, +, d}_x  ->  {a+c, +, b+d}_x.  */
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
operator|<
name|CHREC_VARIABLE
argument_list|(
name|poly1
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly1
argument_list|)
argument_list|,
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|poly0
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly1
argument_list|)
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly1
argument_list|)
argument_list|,
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|poly0
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly1
argument_list|)
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|,
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstm1
argument_list|)
else|:
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
operator|>
name|CHREC_VARIABLE
argument_list|(
name|poly1
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|poly1
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|poly1
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
name|left
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|left
operator|=
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chrec_zerop
argument_list|(
name|right
argument_list|)
condition|)
return|return
name|left
return|;
else|else
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fold the multiplication of two polynomial functions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|chrec_fold_multiply_poly_poly
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|poly0
parameter_list|,
name|tree
name|poly1
parameter_list|)
block|{
name|tree
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|var
decl_stmt|;
name|gcc_assert
argument_list|(
name|poly0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|poly1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|poly0
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|poly1
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|chrec_type
argument_list|(
name|poly0
argument_list|)
operator|==
name|chrec_type
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type
operator|==
name|chrec_type
argument_list|(
name|poly0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* {a, +, b}_1 * {c, +, d}_2  ->  {c*{a, +, b}_1, +, d}_2,      {a, +, b}_2 * {c, +, d}_1  ->  {a*{c, +, d}_1, +, b}_2,      {a, +, b}_x * {c, +, d}_x  ->  {a*c, +, a*d + b*c + b*d, +, 2*b*d}_x.  */
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
operator|<
name|CHREC_VARIABLE
argument_list|(
name|poly1
argument_list|)
condition|)
comment|/* poly0 is a constant wrt. poly1.  */
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly1
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly1
argument_list|)
argument_list|,
name|poly0
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|poly1
argument_list|)
operator|<
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
condition|)
comment|/* poly1 is a constant wrt. poly0.  */
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|poly1
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|)
return|;
comment|/* poly0 and poly1 are two polynomials in the same variable,      {a, +, b}_x * {c, +, d}_x  ->  {a*c, +, a*d + b*c + b*d, +, 2*b*d}_x.  */
comment|/* "a*c".  */
name|t0
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "a*d + b*c + b*d".  */
name|t1
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_LEFT
argument_list|(
name|poly1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|t1
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "2*b*d".  */
name|t2
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly0
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|poly1
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst2
argument_list|)
else|:
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|2
argument_list|)
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|var
operator|=
name|CHREC_VARIABLE
argument_list|(
name|poly0
argument_list|)
expr_stmt|;
return|return
name|build_polynomial_chrec
argument_list|(
name|var
argument_list|,
name|t0
argument_list|,
name|build_polynomial_chrec
argument_list|(
name|var
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* When the operands are automatically_generated_chrec_p, the fold has    to respect the semantics of the operands.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|chrec_fold_automatically_generated_operands
parameter_list|(
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
operator|||
name|op1
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|op0
operator|==
name|chrec_known
operator|||
name|op1
operator|==
name|chrec_known
condition|)
return|return
name|chrec_known
return|;
if|if
condition|(
name|op0
operator|==
name|chrec_not_analyzed_yet
operator|||
name|op1
operator|==
name|chrec_not_analyzed_yet
condition|)
return|return
name|chrec_not_analyzed_yet
return|;
comment|/* The default case produces a safe result.  */
return|return
name|chrec_dont_know
return|;
block|}
end_function

begin_comment
comment|/* Fold the addition of two chrecs.  */
end_comment

begin_function
specifier|static
name|tree
name|chrec_fold_plus_1
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|op0
argument_list|)
operator|||
name|automatically_generated_chrec_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|chrec_fold_automatically_generated_operands
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
return|return
name|chrec_fold_plus_poly_poly
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
default|default:
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|op0
argument_list|)
argument_list|)
return|;
block|}
default|default:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|CHREC_LEFT
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|CHREC_LEFT
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|op1
argument_list|)
argument_list|,
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstm1
argument_list|)
else|:
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|tree_contains_chrecs
argument_list|(
name|op0
argument_list|,
operator|&
name|size
argument_list|)
operator|||
name|tree_contains_chrecs
argument_list|(
name|op1
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|&&
name|size
operator|<
name|PARAM_VALUE
argument_list|(
name|PARAM_SCEV_MAX_EXPR_SIZE
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|size
operator|<
name|PARAM_VALUE
argument_list|(
name|PARAM_SCEV_MAX_EXPR_SIZE
argument_list|)
condition|)
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|op0
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|chrec_dont_know
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fold the addition of two chrecs.  */
end_comment

begin_function
name|tree
name|chrec_fold_plus
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|op0
argument_list|)
operator|||
name|automatically_generated_chrec_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|chrec_fold_automatically_generated_operands
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
return|return
name|chrec_fold_plus_1
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold the subtraction of two chrecs.  */
end_comment

begin_function
name|tree
name|chrec_fold_minus
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|op0
argument_list|)
operator|||
name|automatically_generated_chrec_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|chrec_fold_automatically_generated_operands
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
return|return
name|chrec_fold_plus_1
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fold the multiplication of two chrecs.  */
end_comment

begin_function
name|tree
name|chrec_fold_multiply
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|op0
argument_list|)
operator|||
name|automatically_generated_chrec_p
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|chrec_fold_automatically_generated_operands
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
return|return
name|chrec_fold_multiply_poly_poly
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
default|default:
if|if
condition|(
name|integer_onep
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
return|;
block|}
default|default:
if|if
condition|(
name|integer_onep
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|,
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|)
return|;
default|default:
if|if
condition|(
name|integer_onep
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operations.  */
end_comment

begin_comment
comment|/* Evaluate the binomial coefficient.  Return NULL_TREE if the intermediate    calculation overflows, otherwise return C(n,k) with type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|tree_fold_binomial
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|n
parameter_list|,
name|unsigned
name|int
name|k
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|lidx
decl_stmt|,
name|lnum
decl_stmt|,
name|ldenom
decl_stmt|,
name|lres
decl_stmt|,
name|ldum
decl_stmt|;
name|HOST_WIDE_INT
name|hidx
decl_stmt|,
name|hnum
decl_stmt|,
name|hdenom
decl_stmt|,
name|hres
decl_stmt|,
name|hdum
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|res
decl_stmt|;
comment|/* Handle the most frequent cases.  */
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
return|;
comment|/* Check that k<= n.  */
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|n
argument_list|)
operator|<
name|k
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Numerator = n.  */
name|lnum
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|hnum
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Denominator = 2.  */
name|ldenom
operator|=
literal|2
expr_stmt|;
name|hdenom
operator|=
literal|0
expr_stmt|;
comment|/* Index = Numerator-1.  */
if|if
condition|(
name|lnum
operator|==
literal|0
condition|)
block|{
name|hidx
operator|=
name|hnum
operator|-
literal|1
expr_stmt|;
name|lidx
operator|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|hidx
operator|=
name|hnum
expr_stmt|;
name|lidx
operator|=
name|lnum
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Numerator = Numerator*Index = n*(n-1).  */
if|if
condition|(
name|mul_double
argument_list|(
name|lnum
argument_list|,
name|hnum
argument_list|,
name|lidx
argument_list|,
name|hidx
argument_list|,
operator|&
name|lnum
argument_list|,
operator|&
name|hnum
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
block|{
comment|/* Index--.  */
if|if
condition|(
name|lidx
operator|==
literal|0
condition|)
block|{
name|hidx
operator|--
expr_stmt|;
name|lidx
operator|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
expr_stmt|;
block|}
else|else
name|lidx
operator|--
expr_stmt|;
comment|/* Numerator *= Index.  */
if|if
condition|(
name|mul_double
argument_list|(
name|lnum
argument_list|,
name|hnum
argument_list|,
name|lidx
argument_list|,
name|hidx
argument_list|,
operator|&
name|lnum
argument_list|,
operator|&
name|hnum
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Denominator *= i.  */
name|mul_double
argument_list|(
name|ldenom
argument_list|,
name|hdenom
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|ldenom
argument_list|,
operator|&
name|hdenom
argument_list|)
expr_stmt|;
block|}
comment|/* Result = Numerator / Denominator.  */
name|div_and_round_double
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
literal|1
argument_list|,
name|lnum
argument_list|,
name|hnum
argument_list|,
name|ldenom
argument_list|,
name|hdenom
argument_list|,
operator|&
name|lres
argument_list|,
operator|&
name|hres
argument_list|,
operator|&
name|ldum
argument_list|,
operator|&
name|hdum
argument_list|)
expr_stmt|;
name|res
operator|=
name|build_int_cst_wide
argument_list|(
name|type
argument_list|,
name|lres
argument_list|,
name|hres
argument_list|)
expr_stmt|;
return|return
name|int_fits_type_p
argument_list|(
name|res
argument_list|,
name|type
argument_list|)
condition|?
name|res
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Helper function.  Use the Newton's interpolating formula for    evaluating the value of the evolution function.  */
end_comment

begin_function
specifier|static
name|tree
name|chrec_evaluate
parameter_list|(
name|unsigned
name|var
parameter_list|,
name|tree
name|chrec
parameter_list|,
name|tree
name|n
parameter_list|,
name|unsigned
name|int
name|k
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|binomial_n_k
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|&&
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|>
name|var
condition|)
name|chrec
operator|=
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|&&
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|==
name|var
condition|)
block|{
name|arg0
operator|=
name|chrec_evaluate
argument_list|(
name|var
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|n
argument_list|,
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|binomial_n_k
operator|=
name|tree_fold_binomial
argument_list|(
name|type
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binomial_n_k
condition|)
return|return
name|chrec_dont_know
return|;
name|arg1
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|binomial_n_k
argument_list|)
expr_stmt|;
return|return
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
name|binomial_n_k
operator|=
name|tree_fold_binomial
argument_list|(
name|type
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binomial_n_k
condition|)
return|return
name|chrec_dont_know
return|;
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|chrec
argument_list|,
name|binomial_n_k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluates "CHREC (X)" when the varying variable is VAR.      Example:  Given the following parameters,         var = 1    chrec = {3, +, 4}_1    x = 10        The result is given by the Newton's interpolating formula:     3 * \binom{10}{0} + 4 * \binom{10}{1}. */
end_comment

begin_function
name|tree
name|chrec_apply
parameter_list|(
name|unsigned
name|var
parameter_list|,
name|tree
name|chrec
parameter_list|,
name|tree
name|x
parameter_list|)
block|{
name|tree
name|type
init|=
name|chrec_type
argument_list|(
name|chrec
argument_list|)
decl_stmt|;
name|tree
name|res
init|=
name|chrec_dont_know
decl_stmt|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
operator|||
name|automatically_generated_chrec_p
argument_list|(
name|x
argument_list|)
comment|/* When the symbols are defined in an outer loop, it is possible 	 to symbolically compute the apply, since the symbols are 	 constants with respect to the varying loop.  */
operator|||
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|chrec
argument_list|,
name|var
argument_list|)
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(chrec_apply \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|x
operator|=
name|build_real_from_int_cst
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|evolution_function_is_affine_p
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
comment|/* "{a, +, b} (x)"  ->  "a + b*x".  */
name|x
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|x
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|res
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
name|res
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
condition|)
name|res
operator|=
name|chrec
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
comment|/* testsuite/.../ssa-chrec-38.c.  */
name|res
operator|=
name|chrec_evaluate
argument_list|(
name|var
argument_list|,
name|chrec
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (varying_loop = %d\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (chrec = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (x = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (res = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Replaces the initial condition in CHREC with INIT_COND.  */
end_comment

begin_function
name|tree
name|chrec_replace_initial_condition
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|tree
name|init_cond
parameter_list|)
block|{
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|chrec
return|;
name|gcc_assert
argument_list|(
name|chrec_type
argument_list|(
name|chrec
argument_list|)
operator|==
name|chrec_type
argument_list|(
name|init_cond
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|chrec_replace_initial_condition
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|init_cond
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|init_cond
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the initial condition of a given CHREC.  */
end_comment

begin_function
name|tree
name|initial_condition
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|chrec
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
return|return
name|initial_condition
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
return|;
else|else
return|return
name|chrec
return|;
block|}
end_function

begin_comment
comment|/* Returns a univariate function that represents the evolution in    LOOP_NUM.  Mask the evolution of any other loop.  */
end_comment

begin_function
name|tree
name|hide_evolution_in_other_loops_than_loop
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|unsigned
name|loop_num
parameter_list|)
block|{
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|chrec
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|==
name|loop_num
condition|)
return|return
name|build_polynomial_chrec
argument_list|(
name|loop_num
argument_list|,
name|hide_evolution_in_other_loops_than_loop
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|loop_num
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|<
name|loop_num
condition|)
comment|/* There is no evolution in this loop.  */
return|return
name|initial_condition
argument_list|(
name|chrec
argument_list|)
return|;
else|else
return|return
name|hide_evolution_in_other_loops_than_loop
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|loop_num
argument_list|)
return|;
default|default:
return|return
name|chrec
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the evolution part of CHREC in LOOP_NUM when RIGHT is    true, otherwise returns the initial condition in LOOP_NUM.  */
end_comment

begin_function
specifier|static
name|tree
name|chrec_component_in_loop_num
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|unsigned
name|loop_num
parameter_list|,
name|bool
name|right
parameter_list|)
block|{
name|tree
name|component
decl_stmt|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|chrec
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|==
name|loop_num
condition|)
block|{
if|if
condition|(
name|right
condition|)
name|component
operator|=
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
else|else
name|component
operator|=
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
operator|||
name|CHREC_VARIABLE
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|!=
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|component
return|;
else|else
return|return
name|build_polynomial_chrec
argument_list|(
name|loop_num
argument_list|,
name|chrec_component_in_loop_num
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|loop_num
argument_list|,
name|right
argument_list|)
argument_list|,
name|component
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|<
name|loop_num
condition|)
comment|/* There is no evolution part in this loop.  */
return|return
name|NULL_TREE
return|;
else|else
return|return
name|chrec_component_in_loop_num
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|loop_num
argument_list|,
name|right
argument_list|)
return|;
default|default:
if|if
condition|(
name|right
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|chrec
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the evolution part in LOOP_NUM.  Example: the call    evolution_part_in_loop_num ({{0, +, 1}_1, +, 2}_1, 1) returns     {1, +, 2}_1  */
end_comment

begin_function
name|tree
name|evolution_part_in_loop_num
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|unsigned
name|loop_num
parameter_list|)
block|{
return|return
name|chrec_component_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|loop_num
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the initial condition in LOOP_NUM.  Example: the call    initial_condition_in_loop_num ({{0, +, 1}_1, +, 2}_2, 2) returns     {0, +, 1}_1  */
end_comment

begin_function
name|tree
name|initial_condition_in_loop_num
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|unsigned
name|loop_num
parameter_list|)
block|{
return|return
name|chrec_component_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|loop_num
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set or reset the evolution of CHREC to NEW_EVOL in loop LOOP_NUM.    This function is essentially used for setting the evolution to    chrec_dont_know, for example after having determined that it is    impossible to say how many times a loop will execute.  */
end_comment

begin_function
name|tree
name|reset_evolution_in_loop
parameter_list|(
name|unsigned
name|loop_num
parameter_list|,
name|tree
name|chrec
parameter_list|,
name|tree
name|new_evol
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|chrec_type
argument_list|(
name|chrec
argument_list|)
operator|==
name|chrec_type
argument_list|(
name|new_evol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|&&
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|>
name|loop_num
condition|)
block|{
name|tree
name|left
init|=
name|reset_evolution_in_loop
argument_list|(
name|loop_num
argument_list|,
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|new_evol
argument_list|)
decl_stmt|;
name|tree
name|right
init|=
name|reset_evolution_in_loop
argument_list|(
name|loop_num
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|new_evol
argument_list|)
decl_stmt|;
return|return
name|build3
argument_list|(
name|POLYNOMIAL_CHREC
argument_list|,
name|TREE_TYPE
argument_list|(
name|left
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|&&
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|==
name|loop_num
condition|)
name|chrec
operator|=
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
return|return
name|build_polynomial_chrec
argument_list|(
name|loop_num
argument_list|,
name|chrec
argument_list|,
name|new_evol
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merges two evolution functions that were found by following two    alternate paths of a conditional expression.  */
end_comment

begin_function
name|tree
name|chrec_merge
parameter_list|(
name|tree
name|chrec1
parameter_list|,
name|tree
name|chrec2
parameter_list|)
block|{
if|if
condition|(
name|chrec1
operator|==
name|chrec_dont_know
operator|||
name|chrec2
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|chrec1
operator|==
name|chrec_known
operator|||
name|chrec2
operator|==
name|chrec_known
condition|)
return|return
name|chrec_known
return|;
if|if
condition|(
name|chrec1
operator|==
name|chrec_not_analyzed_yet
condition|)
return|return
name|chrec2
return|;
if|if
condition|(
name|chrec2
operator|==
name|chrec_not_analyzed_yet
condition|)
return|return
name|chrec1
return|;
if|if
condition|(
name|eq_evolutions_p
argument_list|(
name|chrec1
argument_list|,
name|chrec2
argument_list|)
condition|)
return|return
name|chrec1
return|;
return|return
name|chrec_dont_know
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Observers.  */
end_comment

begin_comment
comment|/* Helper function for is_multivariate_chrec.  */
end_comment

begin_function
specifier|static
name|bool
name|is_multivariate_chrec_rec
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|unsigned
name|int
name|rec_var
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
block|{
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|rec_var
condition|)
return|return
name|true
return|;
else|else
return|return
operator|(
name|is_multivariate_chrec_rec
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|rec_var
argument_list|)
operator|||
name|is_multivariate_chrec_rec
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|rec_var
argument_list|)
operator|)
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the given chrec is multivariate or not.  */
end_comment

begin_function
name|bool
name|is_multivariate_chrec
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
return|return
operator|(
name|is_multivariate_chrec_rec
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|||
name|is_multivariate_chrec_rec
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determines whether the chrec contains symbolic names or not.  */
end_comment

begin_function
name|bool
name|chrec_contains_symbols
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|FIELD_DECL
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|chrec_contains_symbols
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|2
case|:
if|if
condition|(
name|chrec_contains_symbols
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|1
case|:
if|if
condition|(
name|chrec_contains_symbols
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determines whether the chrec contains undetermined coefficients.  */
end_comment

begin_function
name|bool
name|chrec_contains_undetermined
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|chrec_dont_know
operator|||
name|chrec
operator|==
name|chrec_not_analyzed_yet
operator|||
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|2
case|:
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|1
case|:
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determines whether the tree EXPR contains chrecs, and increment    SIZE if it is not a NULL pointer by an estimation of the depth of    the tree.  */
end_comment

begin_function
name|bool
name|tree_contains_chrecs
parameter_list|(
name|tree
name|expr
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|size
condition|)
operator|(
operator|*
name|size
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|tree_is_chrec
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|tree_contains_chrecs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|2
case|:
if|if
condition|(
name|tree_contains_chrecs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|1
case|:
if|if
condition|(
name|tree_contains_chrecs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Recursive helper function.  */
end_comment

begin_function
specifier|static
name|bool
name|evolution_function_is_invariant_rec_p
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|int
name|loopnum
parameter_list|)
block|{
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|expr_invariant_in_loop_p
argument_list|(
name|current_loops
operator|->
name|parray
index|[
name|loopnum
index|]
argument_list|,
name|chrec
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
block|{
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|loopnum
operator|||
operator|!
name|evolution_function_is_invariant_rec_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|loopnum
argument_list|)
operator|||
operator|!
name|evolution_function_is_invariant_rec_p
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|loopnum
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|evolution_function_is_invariant_rec_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loopnum
argument_list|)
condition|)
return|return
name|false
return|;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|evolution_function_is_invariant_rec_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loopnum
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if CHREC is invariant in loop LOOPNUM, false otherwise. */
end_comment

begin_function
name|bool
name|evolution_function_is_invariant_p
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|int
name|loopnum
parameter_list|)
block|{
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|current_loops
operator|!=
name|NULL
condition|)
return|return
name|evolution_function_is_invariant_rec_p
argument_list|(
name|chrec
argument_list|,
name|loopnum
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the given tree is an affine multivariate    evolution.  */
end_comment

begin_function
name|bool
name|evolution_function_is_affine_multivariate_p
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|&&
name|CHREC_VARIABLE
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|!=
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|&&
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|evolution_function_is_constant_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
operator|&&
name|CHREC_VARIABLE
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
operator|!=
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|&&
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine whether the given tree is a function in zero or one     variables.  */
end_comment

begin_function
name|bool
name|evolution_function_is_univariate_p
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|CHREC_VARIABLE
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|evolution_function_is_univariate_p
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|CHREC_VARIABLE
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|evolution_function_is_univariate_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the number of variables of CHREC.  Example: the call    nb_vars_in_chrec ({{0, +, 1}_5, +, 2}_6) returns 2.  */
end_comment

begin_function
name|unsigned
name|nb_vars_in_chrec
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
return|return
literal|1
operator|+
name|nb_vars_in_chrec
argument_list|(
name|initial_condition_in_loop_num
argument_list|(
name|chrec
argument_list|,
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if TYPE is a type in that we cannot directly perform    arithmetics, even though it is a scalar type.  */
end_comment

begin_function
specifier|static
name|bool
name|avoid_arithmetics_in_type_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* Ada frontend uses subtypes -- an arithmetic cannot be directly performed      in the subtype, but a base type must be used, and the result then can      be casted to the subtype.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function_decl
specifier|static
name|tree
name|chrec_convert_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Converts BASE and STEP of affine scev to TYPE.  LOOP is the loop whose iv    the scev corresponds to.  AT_STMT is the statement at that the scev is    evaluated.  USE_OVERFLOW_SEMANTICS is true if this function should assume that    the rules for overflow of the given language apply (e.g., that signed    arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary    tests, but also to enforce that the result follows them.  Returns true if the    conversion succeeded, false otherwise.  */
end_comment

begin_function
name|bool
name|convert_affine_scev
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|base
parameter_list|,
name|tree
modifier|*
name|step
parameter_list|,
name|tree
name|at_stmt
parameter_list|,
name|bool
name|use_overflow_semantics
parameter_list|)
block|{
name|tree
name|ct
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|step
argument_list|)
decl_stmt|;
name|bool
name|enforce_overflow_semantics
decl_stmt|;
name|bool
name|must_check_src_overflow
decl_stmt|,
name|must_check_rslt_overflow
decl_stmt|;
name|tree
name|new_base
decl_stmt|,
name|new_step
decl_stmt|;
comment|/* If we cannot perform arithmetic in TYPE, avoid creating an scev.  */
if|if
condition|(
name|avoid_arithmetics_in_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* In general,      (TYPE) (BASE + STEP * i) = (TYPE) BASE + (TYPE -- sign extend) STEP * i,      but we must check some assumptions.            1) If [BASE, +, STEP] wraps, the equation is not valid when precision         of CT is smaller than the precision of TYPE.  For example, when we 	cast unsigned char [254, +, 1] to unsigned, the values on left side 	are 254, 255, 0, 1, ..., but those on the right side are 	254, 255, 256, 257, ...      2) In case that we must also preserve the fact that signed ivs do not         overflow, we must additionally check that the new iv does not wrap. 	For example, unsigned char [125, +, 1] casted to signed char could 	become a wrapping variable with values 125, 126, 127, -128, -127, ..., 	which would confuse optimizers that assume that this does not 	happen.  */
name|must_check_src_overflow
operator|=
name|TYPE_PRECISION
argument_list|(
name|ct
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|enforce_overflow_semantics
operator|=
operator|(
name|use_overflow_semantics
operator|&&
name|nowrap_type_p
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|enforce_overflow_semantics
condition|)
block|{
comment|/* We can avoid checking whether the result overflows in the following 	 cases:  	 -- must_check_src_overflow is true, and the range of TYPE is superset 	    of the range of CT -- i.e., in all cases except if CT signed and 	    TYPE unsigned.          -- both CT and TYPE have the same precision and signedness, and we 	    verify instead that the source does not overflow (this may be 	    easier than verifying it for the result, as we may use the 	    information about the semantics of overflow in CT).  */
if|if
condition|(
name|must_check_src_overflow
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|ct
argument_list|)
condition|)
name|must_check_rslt_overflow
operator|=
name|true
expr_stmt|;
else|else
name|must_check_rslt_overflow
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|ct
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|ct
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|must_check_rslt_overflow
operator|=
name|false
expr_stmt|;
name|must_check_src_overflow
operator|=
name|true
expr_stmt|;
block|}
else|else
name|must_check_rslt_overflow
operator|=
name|true
expr_stmt|;
block|}
else|else
name|must_check_rslt_overflow
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|must_check_src_overflow
operator|&&
name|scev_probably_wraps_p
argument_list|(
operator|*
name|base
argument_list|,
operator|*
name|step
argument_list|,
name|at_stmt
argument_list|,
name|loop
argument_list|,
name|use_overflow_semantics
argument_list|)
condition|)
return|return
name|false
return|;
name|new_base
operator|=
name|chrec_convert_1
argument_list|(
name|type
argument_list|,
operator|*
name|base
argument_list|,
name|at_stmt
argument_list|,
name|use_overflow_semantics
argument_list|)
expr_stmt|;
comment|/* The step must be sign extended, regardless of the signedness      of CT and TYPE.  This only needs to be handled specially when      CT is unsigned -- to avoid e.g. unsigned char [100, +, 255]      (with values 100, 99, 98, ...) from becoming signed or unsigned      [100, +, 255] with values 100, 355, ...; the sign-extension is       performed by default when CT is signed.  */
name|new_step
operator|=
operator|*
name|step
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|ct
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|ct
argument_list|)
condition|)
name|new_step
operator|=
name|chrec_convert_1
argument_list|(
name|signed_type_for
argument_list|(
name|ct
argument_list|)
argument_list|,
name|new_step
argument_list|,
name|at_stmt
argument_list|,
name|use_overflow_semantics
argument_list|)
expr_stmt|;
name|new_step
operator|=
name|chrec_convert_1
argument_list|(
name|type
argument_list|,
name|new_step
argument_list|,
name|at_stmt
argument_list|,
name|use_overflow_semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|new_base
argument_list|)
operator|||
name|automatically_generated_chrec_p
argument_list|(
name|new_step
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|must_check_rslt_overflow
comment|/* Note that in this case we cannot use the fact that signed variables 	 do not overflow, as this is what we are verifying for the new iv.  */
operator|&&
name|scev_probably_wraps_p
argument_list|(
name|new_base
argument_list|,
name|new_step
argument_list|,
name|at_stmt
argument_list|,
name|loop
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|base
operator|=
name|new_base
expr_stmt|;
operator|*
name|step
operator|=
name|new_step
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert CHREC to TYPE.  When the analyzer knows the context in    which the CHREC is built, it sets AT_STMT to the statement that    contains the definition of the analyzed variable, otherwise the    conversion is less accurate: the information is used for    determining a more accurate estimation of the number of iterations.    By default AT_STMT could be safely set to NULL_TREE.     The following rule is always true: TREE_TYPE (chrec) ==    TREE_TYPE (CHREC_LEFT (chrec)) == TREE_TYPE (CHREC_RIGHT (chrec)).    An example of what could happen when adding two chrecs and the type    of the CHREC_RIGHT is different than CHREC_LEFT is:        {(uint) 0, +, (uchar) 10} +    {(uint) 0, +, (uchar) 250}        that would produce a wrong result if CHREC_RIGHT is not (uint):        {(uint) 0, +, (uchar) 4}     instead of     {(uint) 0, +, (uint) 260} */
end_comment

begin_function
name|tree
name|chrec_convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|chrec
parameter_list|,
name|tree
name|at_stmt
parameter_list|)
block|{
return|return
name|chrec_convert_1
argument_list|(
name|type
argument_list|,
name|chrec
argument_list|,
name|at_stmt
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert CHREC to TYPE.  When the analyzer knows the context in    which the CHREC is built, it sets AT_STMT to the statement that    contains the definition of the analyzed variable, otherwise the    conversion is less accurate: the information is used for    determining a more accurate estimation of the number of iterations.    By default AT_STMT could be safely set to NULL_TREE.      USE_OVERFLOW_SEMANTICS is true if this function should assume that    the rules for overflow of the given language apply (e.g., that signed    arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary    tests, but also to enforce that the result follows them.  */
end_comment

begin_function
specifier|static
name|tree
name|chrec_convert_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|chrec
parameter_list|,
name|tree
name|at_stmt
parameter_list|,
name|bool
name|use_overflow_semantics
parameter_list|)
block|{
name|tree
name|ct
decl_stmt|,
name|res
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|step
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|chrec
return|;
name|ct
operator|=
name|chrec_type
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
name|type
condition|)
return|return
name|chrec
return|;
if|if
condition|(
operator|!
name|evolution_function_is_affine_p
argument_list|(
name|chrec
argument_list|)
condition|)
goto|goto
name|keep_cast
goto|;
name|loop
operator|=
name|current_loops
operator|->
name|parray
index|[
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
index|]
expr_stmt|;
name|base
operator|=
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
name|step
operator|=
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_affine_scev
argument_list|(
name|loop
argument_list|,
name|type
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|step
argument_list|,
name|at_stmt
argument_list|,
name|use_overflow_semantics
argument_list|)
condition|)
return|return
name|build_polynomial_chrec
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|base
argument_list|,
name|step
argument_list|)
return|;
comment|/* If we cannot propagate the cast inside the chrec, just keep the cast.  */
name|keep_cast
label|:
name|res
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|chrec
argument_list|)
expr_stmt|;
comment|/* Don't propagate overflows.  */
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|res
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|res
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* But reject constants that don't fit in their type after conversion.      This can happen if TYPE_MIN_VALUE or TYPE_MAX_VALUE are not the      natural values associated with TYPE_PRECISION and TYPE_UNSIGNED,      and can cause problems later when computing niters of loops.  Note      that we don't do the check before converting because we don't want      to reject conversions of negative chrecs to unsigned types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|res
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|res
argument_list|,
name|type
argument_list|)
condition|)
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Convert CHREC to TYPE, without regard to signed overflows.  Returns the new    chrec if something else than what chrec_convert would do happens, NULL_TREE    otherwise.  */
end_comment

begin_function
name|tree
name|chrec_convert_aggressive
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|chrec
parameter_list|)
block|{
name|tree
name|inner_type
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|,
name|lc
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
condition|)
return|return
name|NULL_TREE
return|;
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we cannot perform arithmetic in TYPE, avoid creating an scev.  */
if|if
condition|(
name|avoid_arithmetics_in_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|left
operator|=
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
name|right
operator|=
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
name|lc
operator|=
name|chrec_convert_aggressive
argument_list|(
name|type
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lc
condition|)
name|lc
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|left
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|chrec_convert_aggressive
argument_list|(
name|type
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|rc
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|right
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|lc
argument_list|,
name|rc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true when CHREC0 == CHREC1.  */
end_comment

begin_function
name|bool
name|eq_evolutions_p
parameter_list|(
name|tree
name|chrec0
parameter_list|,
name|tree
name|chrec1
parameter_list|)
block|{
if|if
condition|(
name|chrec0
operator|==
name|NULL_TREE
operator|||
name|chrec1
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|chrec0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|chrec1
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|chrec0
operator|==
name|chrec1
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec0
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|operand_equal_p
argument_list|(
name|chrec0
argument_list|,
name|chrec1
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|POLYNOMIAL_CHREC
case|:
return|return
operator|(
name|CHREC_VARIABLE
argument_list|(
name|chrec0
argument_list|)
operator|==
name|CHREC_VARIABLE
argument_list|(
name|chrec1
argument_list|)
operator|&&
name|eq_evolutions_p
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec0
argument_list|)
argument_list|,
name|CHREC_LEFT
argument_list|(
name|chrec1
argument_list|)
argument_list|)
operator|&&
name|eq_evolutions_p
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec0
argument_list|)
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec1
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns EV_GROWS if CHREC grows (assuming that it does not overflow),    EV_DECREASES if it decreases, and EV_UNKNOWN if we cannot determine    which of these cases happens.  */
end_comment

begin_function
name|enum
name|ev_direction
name|scev_direction
parameter_list|(
name|tree
name|chrec
parameter_list|)
block|{
name|tree
name|step
decl_stmt|;
if|if
condition|(
operator|!
name|evolution_function_is_affine_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|EV_DIR_UNKNOWN
return|;
name|step
operator|=
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|EV_DIR_UNKNOWN
return|;
if|if
condition|(
name|tree_int_cst_sign_bit
argument_list|(
name|step
argument_list|)
condition|)
return|return
name|EV_DIR_DECREASES
return|;
else|else
return|return
name|EV_DIR_GROWS
return|;
block|}
end_function

end_unit

