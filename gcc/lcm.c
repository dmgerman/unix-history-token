begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic partial redundancy elimination with lazy code motion support.    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* These routines are meant to be used by various optimization    passes which can be modeled as lazy code motion problems.    Including, but not limited to:  	* Traditional partial redundancy elimination.  	* Placement of caller/caller register save/restores.  	* Load/store motion.  	* Copy motion.  	* Conversion of flat register files to a stacked register 	model.  	* Dead load/store elimination.    These routines accept as input:  	* Basic block information (number of blocks, lists of 	predecessors and successors).  Note the granularity 	does not need to be basic block, they could be statements 	or functions.  	* Bitmaps of local properties (computed, transparent and 	anticipatable expressions).    The output of these routines is bitmap of redundant computations   and a bitmap of optimal placement points.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_comment
comment|/* We want target macros for the mode switching code to be able to refer    to instruction attribute values.  */
end_comment

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Edge based LCM routines.  */
end_comment

begin_function_decl
specifier|static
name|void
name|compute_antinout_edge
parameter_list|(
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_earliest
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_laterin
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_insert_delete
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Edge based LCM routines on a reverse flowgraph.  */
end_comment

begin_function_decl
specifier|static
name|void
name|compute_farthest
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_nearerout
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_rev_insert_delete
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Edge based lcm routines.  */
end_comment

begin_comment
comment|/* Compute expression anticipatability at entrance and exit of each block.    This is done based on the flow graph, and not on the pred-succ lists.    Other than that, its pretty much identical to compute_antinout.  */
end_comment

begin_function
specifier|static
name|void
name|compute_antinout_edge
parameter_list|(
name|sbitmap
modifier|*
name|antloc
parameter_list|,
name|sbitmap
modifier|*
name|transp
parameter_list|,
name|sbitmap
modifier|*
name|antin
parameter_list|,
name|sbitmap
modifier|*
name|antout
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|qin
decl_stmt|,
modifier|*
name|qout
decl_stmt|,
modifier|*
name|qend
decl_stmt|;
name|unsigned
name|int
name|qlen
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|qin
operator|=
name|qout
operator|=
name|worklist
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* We want a maximal solution, so make an optimistic initialization of      ANTIN.  */
name|sbitmap_vector_ones
argument_list|(
name|antin
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* Put every block on the worklist; this is necessary because of the      optimistic initialization of ANTIN above.  */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
operator|*
name|qin
operator|++
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
block|}
name|qin
operator|=
name|worklist
expr_stmt|;
name|qend
operator|=
operator|&
name|worklist
index|[
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
index|]
expr_stmt|;
name|qlen
operator|=
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
expr_stmt|;
comment|/* Mark blocks which are predecessors of the exit block so that we      can easily identify them below.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
name|e
operator|->
name|src
operator|->
name|aux
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|qlen
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|bb
operator|=
operator|*
name|qout
operator|++
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
if|if
condition|(
name|qout
operator|>=
name|qend
condition|)
name|qout
operator|=
name|worklist
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|aux
operator|==
name|EXIT_BLOCK_PTR
condition|)
comment|/* Do not clear the aux field for blocks which are predecessors of 	   the EXIT block.  That way we never add then to the worklist 	   again.  */
name|sbitmap_zero
argument_list|(
name|antout
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Clear the aux field of this block so that it can be added to 	     the worklist again if necessary.  */
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|sbitmap_intersection_of_succs
argument_list|(
name|antout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|antin
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbitmap_a_or_b_and_c_cg
argument_list|(
name|antin
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|antout
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
condition|)
comment|/* If the in state of this block changed, then we need 	   to add the predecessors of this block to the worklist 	   if they are not already on the worklist.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
operator|!
name|e
operator|->
name|src
operator|->
name|aux
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
operator|*
name|qin
operator|++
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|e
operator|->
name|src
operator|->
name|aux
operator|=
name|e
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
if|if
condition|(
name|qin
operator|>=
name|qend
condition|)
name|qin
operator|=
name|worklist
expr_stmt|;
block|}
block|}
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the earliest vector for edge based lcm.  */
end_comment

begin_function
specifier|static
name|void
name|compute_earliest
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|int
name|n_exprs
parameter_list|,
name|sbitmap
modifier|*
name|antin
parameter_list|,
name|sbitmap
modifier|*
name|antout
parameter_list|,
name|sbitmap
modifier|*
name|avout
parameter_list|,
name|sbitmap
modifier|*
name|kill
parameter_list|,
name|sbitmap
modifier|*
name|earliest
parameter_list|)
block|{
name|sbitmap
name|difference
decl_stmt|,
name|temp_bitmap
decl_stmt|;
name|int
name|x
decl_stmt|,
name|num_edges
decl_stmt|;
name|basic_block
name|pred
decl_stmt|,
name|succ
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|difference
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_edges
condition|;
name|x
operator|++
control|)
block|{
name|pred
operator|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|succ
operator|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|sbitmap_copy
argument_list|(
name|earliest
index|[
name|x
index|]
argument_list|,
name|antin
index|[
name|succ
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|succ
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|sbitmap_zero
argument_list|(
name|earliest
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|sbitmap_difference
argument_list|(
name|difference
argument_list|,
name|antin
index|[
name|succ
operator|->
name|index
index|]
argument_list|,
name|avout
index|[
name|pred
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|antout
index|[
name|pred
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b_or_c
argument_list|(
name|earliest
index|[
name|x
index|]
argument_list|,
name|difference
argument_list|,
name|kill
index|[
name|pred
operator|->
name|index
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sbitmap_free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|difference
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* later(p,s) is dependent on the calculation of laterin(p).    laterin(p) is dependent on the calculation of later(p2,p).       laterin(ENTRY) is defined as all 0's      later(ENTRY, succs(ENTRY)) are defined using laterin(ENTRY)      laterin(succs(ENTRY)) is defined by later(ENTRY, succs(ENTRY)).     If we progress in this manner, starting with all basic blocks    in the work list, anytime we change later(bb), we need to add    succs(bb) to the worklist if they are not already on the worklist.     Boundary conditions:       We prime the worklist all the normal basic blocks.   The ENTRY block can      never be added to the worklist since it is never the successor of any      block.  We explicitly prevent the EXIT block from being added to the      worklist.       We optimistically initialize LATER.  That is the only time this routine      will compute LATER for an edge out of the entry block since the entry      block is never on the worklist.  Thus, LATERIN is neither used nor      computed for the ENTRY block.       Since the EXIT block is never added to the worklist, we will neither      use nor compute LATERIN for the exit block.  Edges which reach the      EXIT block are handled in the normal fashion inside the loop.  However,      the insertion/deletion computation needs LATERIN(EXIT), so we have      to compute it.  */
end_comment

begin_function
specifier|static
name|void
name|compute_laterin
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|sbitmap
modifier|*
name|earliest
parameter_list|,
name|sbitmap
modifier|*
name|antloc
parameter_list|,
name|sbitmap
modifier|*
name|later
parameter_list|,
name|sbitmap
modifier|*
name|laterin
parameter_list|)
block|{
name|int
name|num_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|qin
decl_stmt|,
modifier|*
name|qout
decl_stmt|,
modifier|*
name|qend
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|int
name|qlen
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|qin
operator|=
name|qout
operator|=
name|worklist
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Initialize a mapping from each edge to its index.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|i
argument_list|)
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
name|i
expr_stmt|;
comment|/* We want a maximal solution, so initially consider LATER true for      all edges.  This allows propagation through a loop since the incoming      loop edge will have LATER set, so if all the other incoming edges      to the loop are set, then LATERIN will be set for the head of the      loop.       If the optimistic setting of LATER on that edge was incorrect (for      example the expression is ANTLOC in a block within the loop) then      this algorithm will detect it when we process the block at the head      of the optimistic edge.  That will requeue the affected blocks.  */
name|sbitmap_vector_ones
argument_list|(
name|later
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
comment|/* Note that even though we want an optimistic setting of LATER, we      do not want to be overly optimistic.  Consider an outgoing edge from      the entry block.  That edge should always have a LATER value the      same as EARLIEST for that edge.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
name|sbitmap_copy
argument_list|(
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|earliest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Add all the blocks to the worklist.  This prevents an early exit from      the loop given our optimistic initialization of LATER above.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
operator|*
name|qin
operator|++
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
block|}
comment|/* Note that we do not use the last allocated element for our queue,      as EXIT_BLOCK is never inserted into it. */
name|qin
operator|=
name|worklist
expr_stmt|;
name|qend
operator|=
operator|&
name|worklist
index|[
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
index|]
expr_stmt|;
name|qlen
operator|=
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
expr_stmt|;
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|qlen
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|bb
operator|=
operator|*
name|qout
operator|++
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
if|if
condition|(
name|qout
operator|>=
name|qend
condition|)
name|qout
operator|=
name|worklist
expr_stmt|;
comment|/* Compute the intersection of LATERIN for each incoming edge to B.  */
name|sbitmap_ones
argument_list|(
name|laterin
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|sbitmap_a_and_b
argument_list|(
name|laterin
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|laterin
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Calculate LATER for all outgoing edges.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|sbitmap_union_of_diff_cg
argument_list|(
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|earliest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|laterin
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|,
name|antloc
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
comment|/* If LATER for an outgoing edge was changed, then we need 	       to add the target of the outgoing edge to the worklist.  */
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|->
name|aux
operator|==
literal|0
condition|)
block|{
operator|*
name|qin
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|e
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
if|if
condition|(
name|qin
operator|>=
name|qend
condition|)
name|qin
operator|=
name|worklist
expr_stmt|;
block|}
block|}
comment|/* Computation of insertion and deletion points requires computing LATERIN      for the EXIT block.  We allocated an extra entry in the LATERIN array      for just this purpose.  */
name|sbitmap_ones
argument_list|(
name|laterin
index|[
name|last_basic_block
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
name|sbitmap_a_and_b
argument_list|(
name|laterin
index|[
name|last_basic_block
index|]
argument_list|,
name|laterin
index|[
name|last_basic_block
index|]
argument_list|,
name|later
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the insertion and deletion points for edge based LCM.  */
end_comment

begin_function
specifier|static
name|void
name|compute_insert_delete
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|sbitmap
modifier|*
name|antloc
parameter_list|,
name|sbitmap
modifier|*
name|later
parameter_list|,
name|sbitmap
modifier|*
name|laterin
parameter_list|,
name|sbitmap
modifier|*
name|insert
parameter_list|,
name|sbitmap
modifier|*
name|delete
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|sbitmap_difference
argument_list|(
name|delete
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|laterin
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|later
index|[
name|x
index|]
argument_list|,
name|laterin
index|[
name|last_basic_block
index|]
argument_list|)
expr_stmt|;
else|else
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|later
index|[
name|x
index|]
argument_list|,
name|laterin
index|[
name|b
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given local properties TRANSP, ANTLOC, AVOUT, KILL return the insert and    delete vectors for edge based LCM.  Returns an edgelist which is used to    map the insert vector to what edge an expression should be inserted on.  */
end_comment

begin_function
name|struct
name|edge_list
modifier|*
name|pre_edge_lcm
parameter_list|(
name|int
name|n_exprs
parameter_list|,
name|sbitmap
modifier|*
name|transp
parameter_list|,
name|sbitmap
modifier|*
name|avloc
parameter_list|,
name|sbitmap
modifier|*
name|antloc
parameter_list|,
name|sbitmap
modifier|*
name|kill
parameter_list|,
name|sbitmap
modifier|*
modifier|*
name|insert
parameter_list|,
name|sbitmap
modifier|*
modifier|*
name|delete
parameter_list|)
block|{
name|sbitmap
modifier|*
name|antin
decl_stmt|,
modifier|*
name|antout
decl_stmt|,
modifier|*
name|earliest
decl_stmt|;
name|sbitmap
modifier|*
name|avin
decl_stmt|,
modifier|*
name|avout
decl_stmt|;
name|sbitmap
modifier|*
name|later
decl_stmt|,
modifier|*
name|laterin
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|int
name|num_edges
decl_stmt|;
name|edge_list
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Edge List:\n"
argument_list|)
expr_stmt|;
name|verify_edge_list
argument_list|(
name|dump_file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|print_edge_list
argument_list|(
name|dump_file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"transp"
argument_list|,
literal|""
argument_list|,
name|transp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"antloc"
argument_list|,
literal|""
argument_list|,
name|antloc
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"avloc"
argument_list|,
literal|""
argument_list|,
name|avloc
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"kill"
argument_list|,
literal|""
argument_list|,
name|kill
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Compute global availability.  */
name|avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|avloc
argument_list|,
name|kill
argument_list|,
name|avout
argument_list|,
name|avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|avin
argument_list|)
expr_stmt|;
comment|/* Compute global anticipatability.  */
name|antin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|antout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_antinout_edge
argument_list|(
name|antloc
argument_list|,
name|transp
argument_list|,
name|antin
argument_list|,
name|antout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"antin"
argument_list|,
literal|""
argument_list|,
name|antin
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"antout"
argument_list|,
literal|""
argument_list|,
name|antout
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Compute earliestness.  */
name|earliest
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_earliest
argument_list|(
name|edge_list
argument_list|,
name|n_exprs
argument_list|,
name|antin
argument_list|,
name|antout
argument_list|,
name|avout
argument_list|,
name|kill
argument_list|,
name|earliest
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"earliest"
argument_list|,
literal|""
argument_list|,
name|earliest
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|antout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|antin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|avout
argument_list|)
expr_stmt|;
name|later
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* Allocate an extra element for the exit block in the laterin vector.  */
name|laterin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
operator|+
literal|1
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_laterin
argument_list|(
name|edge_list
argument_list|,
name|earliest
argument_list|,
name|antloc
argument_list|,
name|later
argument_list|,
name|laterin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"laterin"
argument_list|,
literal|""
argument_list|,
name|laterin
argument_list|,
name|last_basic_block
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"later"
argument_list|,
literal|""
argument_list|,
name|later
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|earliest
argument_list|)
expr_stmt|;
operator|*
name|insert
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
operator|*
name|delete
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_insert_delete
argument_list|(
name|edge_list
argument_list|,
name|antloc
argument_list|,
name|later
argument_list|,
name|laterin
argument_list|,
operator|*
name|insert
argument_list|,
operator|*
name|delete
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|laterin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|later
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"pre_insert_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|insert
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"pre_delete_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|delete
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|edge_list
return|;
block|}
end_function

begin_comment
comment|/* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.    Return the number of passes we performed to iterate to a solution.  */
end_comment

begin_function
name|void
name|compute_available
parameter_list|(
name|sbitmap
modifier|*
name|avloc
parameter_list|,
name|sbitmap
modifier|*
name|kill
parameter_list|,
name|sbitmap
modifier|*
name|avout
parameter_list|,
name|sbitmap
modifier|*
name|avin
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|qin
decl_stmt|,
modifier|*
name|qout
decl_stmt|,
modifier|*
name|qend
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|int
name|qlen
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|qin
operator|=
name|qout
operator|=
name|worklist
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
comment|/* We want a maximal solution.  */
name|sbitmap_vector_ones
argument_list|(
name|avout
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* Put every block on the worklist; this is necessary because of the      optimistic initialization of AVOUT above.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
operator|*
name|qin
operator|++
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
block|}
name|qin
operator|=
name|worklist
expr_stmt|;
name|qend
operator|=
operator|&
name|worklist
index|[
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
index|]
expr_stmt|;
name|qlen
operator|=
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
expr_stmt|;
comment|/* Mark blocks which are successors of the entry block so that we      can easily identify them below.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|qlen
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|bb
operator|=
operator|*
name|qout
operator|++
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
if|if
condition|(
name|qout
operator|>=
name|qend
condition|)
name|qout
operator|=
name|worklist
expr_stmt|;
comment|/* If one of the predecessor blocks is the ENTRY block, then the 	 intersection of avouts is the null set.  We can identify such blocks 	 by the special value in the AUX field in the block structure.  */
if|if
condition|(
name|bb
operator|->
name|aux
operator|==
name|ENTRY_BLOCK_PTR
condition|)
comment|/* Do not clear the aux field for blocks which are successors of the 	   ENTRY block.  That way we never add then to the worklist again.  */
name|sbitmap_zero
argument_list|(
name|avin
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Clear the aux field of this block so that it can be added to 	     the worklist again if necessary.  */
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|sbitmap_intersection_of_preds
argument_list|(
name|avin
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|avout
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbitmap_union_of_diff_cg
argument_list|(
name|avout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|avloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|avin
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
condition|)
comment|/* If the out state of this block changed, then we need 	   to add the successors of this block to the worklist 	   if they are not already on the worklist.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|aux
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
operator|*
name|qin
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|e
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
if|if
condition|(
name|qin
operator|>=
name|qend
condition|)
name|qin
operator|=
name|worklist
expr_stmt|;
block|}
block|}
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the farthest vector for edge based lcm.  */
end_comment

begin_function
specifier|static
name|void
name|compute_farthest
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|int
name|n_exprs
parameter_list|,
name|sbitmap
modifier|*
name|st_avout
parameter_list|,
name|sbitmap
modifier|*
name|st_avin
parameter_list|,
name|sbitmap
modifier|*
name|st_antin
parameter_list|,
name|sbitmap
modifier|*
name|kill
parameter_list|,
name|sbitmap
modifier|*
name|farthest
parameter_list|)
block|{
name|sbitmap
name|difference
decl_stmt|,
name|temp_bitmap
decl_stmt|;
name|int
name|x
decl_stmt|,
name|num_edges
decl_stmt|;
name|basic_block
name|pred
decl_stmt|,
name|succ
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|difference
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_edges
condition|;
name|x
operator|++
control|)
block|{
name|pred
operator|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|succ
operator|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|succ
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|sbitmap_copy
argument_list|(
name|farthest
index|[
name|x
index|]
argument_list|,
name|st_avout
index|[
name|pred
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pred
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|sbitmap_zero
argument_list|(
name|farthest
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|sbitmap_difference
argument_list|(
name|difference
argument_list|,
name|st_avout
index|[
name|pred
operator|->
name|index
index|]
argument_list|,
name|st_antin
index|[
name|succ
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|temp_bitmap
argument_list|,
name|st_avin
index|[
name|succ
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b_or_c
argument_list|(
name|farthest
index|[
name|x
index|]
argument_list|,
name|difference
argument_list|,
name|kill
index|[
name|succ
operator|->
name|index
index|]
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sbitmap_free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|difference
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute nearer and nearerout vectors for edge based lcm.     This is the mirror of compute_laterin, additional comments on the    implementation can be found before compute_laterin.  */
end_comment

begin_function
specifier|static
name|void
name|compute_nearerout
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|sbitmap
modifier|*
name|farthest
parameter_list|,
name|sbitmap
modifier|*
name|st_avloc
parameter_list|,
name|sbitmap
modifier|*
name|nearer
parameter_list|,
name|sbitmap
modifier|*
name|nearerout
parameter_list|)
block|{
name|int
name|num_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|tos
decl_stmt|,
name|bb
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
comment|/* Allocate a worklist array/queue.  Entries are only added to the      list if they were not already on the list.  So the size is      bounded by the number of basic blocks.  */
name|tos
operator|=
name|worklist
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize NEARER for each edge and build a mapping from an edge to      its index.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|i
argument_list|)
operator|->
name|aux
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
name|i
expr_stmt|;
comment|/* We want a maximal solution.  */
name|sbitmap_vector_ones
argument_list|(
name|nearer
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
comment|/* Note that even though we want an optimistic setting of NEARER, we      do not want to be overly optimistic.  Consider an incoming edge to      the exit block.  That edge should always have a NEARER value the      same as FARTHEST for that edge.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
name|sbitmap_copy
argument_list|(
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|farthest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Add all the blocks to the worklist.  This prevents an early exit      from the loop given our optimistic initialization of NEARER.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
operator|*
name|tos
operator|++
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
block|}
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|tos
operator|!=
name|worklist
condition|)
block|{
comment|/* Take the first entry off the worklist.  */
name|bb
operator|=
operator|*
operator|--
name|tos
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
comment|/* Compute the intersection of NEARER for each outgoing edge from B.  */
name|sbitmap_ones
argument_list|(
name|nearerout
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|sbitmap_a_and_b
argument_list|(
name|nearerout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|nearerout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
comment|/* Calculate NEARER for all incoming edges.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|sbitmap_union_of_diff_cg
argument_list|(
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|farthest
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|,
name|nearerout
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|,
name|st_avloc
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|)
comment|/* If NEARER for an incoming edge was changed, then we need 	       to add the source of the incoming edge to the worklist.  */
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|e
operator|->
name|src
operator|->
name|aux
operator|==
literal|0
condition|)
block|{
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|e
operator|->
name|src
operator|->
name|aux
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|/* Computation of insertion and deletion points requires computing NEAREROUT      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array      for just this purpose.  */
name|sbitmap_ones
argument_list|(
name|nearerout
index|[
name|last_basic_block
index|]
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
name|sbitmap_a_and_b
argument_list|(
name|nearerout
index|[
name|last_basic_block
index|]
argument_list|,
name|nearerout
index|[
name|last_basic_block
index|]
argument_list|,
name|nearer
index|[
operator|(
name|size_t
operator|)
name|e
operator|->
name|aux
index|]
argument_list|)
expr_stmt|;
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the insertion and deletion points for edge based LCM.  */
end_comment

begin_function
specifier|static
name|void
name|compute_rev_insert_delete
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|sbitmap
modifier|*
name|st_avloc
parameter_list|,
name|sbitmap
modifier|*
name|nearer
parameter_list|,
name|sbitmap
modifier|*
name|nearerout
parameter_list|,
name|sbitmap
modifier|*
name|insert
parameter_list|,
name|sbitmap
modifier|*
name|delete
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|sbitmap_difference
argument_list|(
name|delete
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|st_avloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|nearerout
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|basic_block
name|b
init|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|nearer
index|[
name|x
index|]
argument_list|,
name|nearerout
index|[
name|last_basic_block
index|]
argument_list|)
expr_stmt|;
else|else
name|sbitmap_difference
argument_list|(
name|insert
index|[
name|x
index|]
argument_list|,
name|nearer
index|[
name|x
index|]
argument_list|,
name|nearerout
index|[
name|b
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given local properties TRANSP, ST_AVLOC, ST_ANTLOC, KILL return the    insert and delete vectors for edge based reverse LCM.  Returns an    edgelist which is used to map the insert vector to what edge    an expression should be inserted on.  */
end_comment

begin_function
name|struct
name|edge_list
modifier|*
name|pre_edge_rev_lcm
parameter_list|(
name|int
name|n_exprs
parameter_list|,
name|sbitmap
modifier|*
name|transp
parameter_list|,
name|sbitmap
modifier|*
name|st_avloc
parameter_list|,
name|sbitmap
modifier|*
name|st_antloc
parameter_list|,
name|sbitmap
modifier|*
name|kill
parameter_list|,
name|sbitmap
modifier|*
modifier|*
name|insert
parameter_list|,
name|sbitmap
modifier|*
modifier|*
name|delete
parameter_list|)
block|{
name|sbitmap
modifier|*
name|st_antin
decl_stmt|,
modifier|*
name|st_antout
decl_stmt|;
name|sbitmap
modifier|*
name|st_avout
decl_stmt|,
modifier|*
name|st_avin
decl_stmt|,
modifier|*
name|farthest
decl_stmt|;
name|sbitmap
modifier|*
name|nearer
decl_stmt|,
modifier|*
name|nearerout
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|int
name|num_edges
decl_stmt|;
name|edge_list
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|st_antin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|st_antout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|st_antin
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|st_antout
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|compute_antinout_edge
argument_list|(
name|st_antloc
argument_list|,
name|transp
argument_list|,
name|st_antin
argument_list|,
name|st_antout
argument_list|)
expr_stmt|;
comment|/* Compute global anticipatability.  */
name|st_avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|st_avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|st_avloc
argument_list|,
name|kill
argument_list|,
name|st_avout
argument_list|,
name|st_avin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Edge List:\n"
argument_list|)
expr_stmt|;
name|verify_edge_list
argument_list|(
name|dump_file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|print_edge_list
argument_list|(
name|dump_file
argument_list|,
name|edge_list
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"transp"
argument_list|,
literal|""
argument_list|,
name|transp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"st_avloc"
argument_list|,
literal|""
argument_list|,
name|st_avloc
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"st_antloc"
argument_list|,
literal|""
argument_list|,
name|st_antloc
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"st_antin"
argument_list|,
literal|""
argument_list|,
name|st_antin
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"st_antout"
argument_list|,
literal|""
argument_list|,
name|st_antout
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"st_kill"
argument_list|,
literal|""
argument_list|,
name|kill
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"st_avout"
argument_list|,
literal|""
argument_list|,
name|st_avout
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"st_avin"
argument_list|,
literal|""
argument_list|,
name|st_avin
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Compute farthestness.  */
name|farthest
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_farthest
argument_list|(
name|edge_list
argument_list|,
name|n_exprs
argument_list|,
name|st_avout
argument_list|,
name|st_avin
argument_list|,
name|st_antin
argument_list|,
name|kill
argument_list|,
name|farthest
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"farthest"
argument_list|,
literal|""
argument_list|,
name|farthest
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|st_antin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|st_antout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|st_avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|st_avout
argument_list|)
expr_stmt|;
name|nearer
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* Allocate an extra element for the entry block.  */
name|nearerout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
operator|+
literal|1
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_nearerout
argument_list|(
name|edge_list
argument_list|,
name|farthest
argument_list|,
name|st_avloc
argument_list|,
name|nearer
argument_list|,
name|nearerout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"nearerout"
argument_list|,
literal|""
argument_list|,
name|nearerout
argument_list|,
name|last_basic_block
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"nearer"
argument_list|,
literal|""
argument_list|,
name|nearer
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sbitmap_vector_free
argument_list|(
name|farthest
argument_list|)
expr_stmt|;
operator|*
name|insert
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
operator|*
name|delete
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_rev_insert_delete
argument_list|(
name|edge_list
argument_list|,
name|st_avloc
argument_list|,
name|nearer
argument_list|,
name|nearerout
argument_list|,
operator|*
name|insert
argument_list|,
operator|*
name|delete
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nearerout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nearer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LCM_DEBUG_INFO
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"pre_insert_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|insert
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|dump_file
argument_list|,
literal|"pre_delete_map"
argument_list|,
literal|""
argument_list|,
operator|*
name|delete
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|edge_list
return|;
block|}
end_function

end_unit

