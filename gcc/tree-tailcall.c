begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tail call optimization on trees.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* The file implements the tail recursion elimination.  It is also used to    analyze the tail calls in general, passing the results to the rtl level    where they are used for sibcall optimization.     In addition to the standard tail recursion elimination, we handle the most    trivial cases of making the call tail recursive by creating accumulators.    For example the following function     int sum (int n)    {      if (n> 0)        return n + sum (n - 1);      else        return 0;    }     is transformed into     int sum (int n)    {      int acc = 0;       while (n> 0)        acc += n--;       return acc;    }     To do this, we maintain two accumulators (a_acc and m_acc) that indicate     when we reach the return x statement, we should return a_acc + x * m_acc    instead.  They are initially initialized to 0 and 1, respectively,    so the semantics of the function is obviously preserved.  If we are    guaranteed that the value of the accumulator never change, we    omit the accumulator.     There are three cases how the function may exit.  The first one is    handled in adjust_return_value, the other two in adjust_accumulator_values    (the second case is actually a special case of the third one and we    present it separately just for clarity):     1) Just return x, where x is not in any of the remaining special shapes.       We rewrite this to a gimple equivalent of return m_acc * x + a_acc.           2) return f (...), where f is the current function, is rewritten in a       classical tail-recursion elimination way, into assignment of arguments       and jump to the start of the function.  Values of the accumulators       are unchanged. 	           3) return a + m * f(...), where a and m do not depend on call to f.       To preserve the semantics described before we want this to be rewritten       in such a way that we finally return        a_acc + (a + m * f(...)) * m_acc = (a_acc + a * m_acc) + (m * m_acc) * f(...).        I.e. we increase a_acc by a * m_acc, multiply m_acc by m and       eliminate the tail call to f.  Special cases when the value is just       added or just multiplied are obtained by setting a = 0 or m = 1.     TODO -- it is possible to do similar tricks for other operations.  */
end_comment

begin_comment
comment|/* A structure that describes the tailcall.  */
end_comment

begin_struct
struct|struct
name|tailcall
block|{
comment|/* The block in that the call occur.  */
name|basic_block
name|call_block
decl_stmt|;
comment|/* The iterator pointing to the call statement.  */
name|block_stmt_iterator
name|call_bsi
decl_stmt|;
comment|/* True if it is a call to the current function.  */
name|bool
name|tail_recursion
decl_stmt|;
comment|/* The return value of the caller is mult * f + add, where f is the return      value of the call.  */
name|tree
name|mult
decl_stmt|,
name|add
decl_stmt|;
comment|/* Next tailcall in the chain.  */
name|struct
name|tailcall
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The variables holding the value of multiplicative and additive    accumulator.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|m_acc
decl_stmt|,
name|a_acc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|suitable_for_tail_opt_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|optimize_tail_call
parameter_list|(
name|struct
name|tailcall
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_tail_call
parameter_list|(
name|struct
name|tailcall
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_tail_calls
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|tailcall
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Returns false when the function is not suitable for tail call optimization    from some reason (e.g. if it takes variable number of arguments).  */
end_comment

begin_function
specifier|static
name|bool
name|suitable_for_tail_opt_p
parameter_list|(
name|void
parameter_list|)
block|{
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
if|if
condition|(
name|current_function_stdarg
condition|)
return|return
name|false
return|;
comment|/* No local variable nor structure field should be call-clobbered.  We      ignore any kind of memory tag, as these are not real variables.  */
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
operator|!
name|is_global_var
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|STRUCT_FIELD_TAG
operator|)
operator|&&
name|is_call_clobbered
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns false when the function is not suitable for tail call optimization    from some reason (e.g. if it takes variable number of arguments).    This test must pass in addition to suitable_for_tail_opt_p in order to make    tail call discovery happen.  */
end_comment

begin_function
specifier|static
name|bool
name|suitable_for_tail_call_opt_p
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|param
decl_stmt|;
comment|/* alloca (until we have stack slot life analysis) inhibits      sibling call optimizations, but not tail recursion.  */
if|if
condition|(
name|current_function_calls_alloca
condition|)
return|return
name|false
return|;
comment|/* If we are using sjlj exceptions, we may need to add a call to      _Unwind_SjLj_Unregister at exit of the function.  Which means      that we cannot do any sibcall transformations.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
operator|&&
name|current_function_has_exception_handlers
argument_list|()
condition|)
return|return
name|false
return|;
comment|/* Any function that calls setjmp might have longjmp called from      any called function.  ??? We really should represent this      properly in the CFG so that this needn't be special cased.  */
if|if
condition|(
name|current_function_calls_setjmp
condition|)
return|return
name|false
return|;
comment|/* ??? It is OK if the argument of a function is taken in some cases,      but not in all cases.  See PR15387 and PR19616.  Revisit for 4.1.  */
for|for
control|(
name|param
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|param
condition|;
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
control|)
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|param
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Checks whether the expression EXPR in stmt AT is independent of the    statement pointed to by BSI (in a sense that we already know EXPR's value    at BSI).  We use the fact that we are only called from the chain of    basic blocks that have only single successor.  Returns the expression    containing the value of EXPR at BSI.  */
end_comment

begin_function
specifier|static
name|tree
name|independent_of_stmt_p
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|at
parameter_list|,
name|block_stmt_iterator
name|bsi
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|call_bb
decl_stmt|,
name|at_bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Mark the blocks in the chain leading to the end.  */
name|at_bb
operator|=
name|bb_for_stmt
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|call_bb
operator|=
name|bb_for_stmt
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|call_bb
init|;
name|bb
operator|!=
name|at_bb
condition|;
name|bb
operator|=
name|single_succ
argument_list|(
name|bb
argument_list|)
control|)
name|bb
operator|->
name|aux
operator|=
operator|&
name|bb
operator|->
name|aux
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
operator|&
name|bb
operator|->
name|aux
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|at
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|at
argument_list|)
expr_stmt|;
comment|/* The default definition or defined before the chain.  */
if|if
condition|(
operator|!
name|bb
operator|||
operator|!
name|bb
operator|->
name|aux
condition|)
break|break;
if|if
condition|(
name|bb
operator|==
name|call_bb
condition|)
block|{
for|for
control|(
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
if|if
condition|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|==
name|at
condition|)
break|break;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|at
argument_list|)
operator|!=
name|PHI_NODE
condition|)
block|{
name|expr
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|aux
condition|)
break|break;
name|gcc_assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|expr
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|at
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
comment|/* The value is a constant.  */
break|break;
block|}
block|}
comment|/* Unmark the blocks.  */
for|for
control|(
name|bb
operator|=
name|call_bb
init|;
name|bb
operator|!=
name|at_bb
condition|;
name|bb
operator|=
name|single_succ
argument_list|(
name|bb
argument_list|)
control|)
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Simulates the effect of an assignment of ASS in STMT on the return value    of the tail recursive CALL passed in ASS_VAR.  M and A are the    multiplicative and the additive factor for the real return value.  */
end_comment

begin_function
specifier|static
name|bool
name|process_assignment
parameter_list|(
name|tree
name|ass
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
name|call
parameter_list|,
name|tree
modifier|*
name|m
parameter_list|,
name|tree
modifier|*
name|a
parameter_list|,
name|tree
modifier|*
name|ass_var
parameter_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|non_ass_var
decl_stmt|;
name|tree
name|dest
init|=
name|TREE_OPERAND
argument_list|(
name|ass
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|TREE_OPERAND
argument_list|(
name|ass
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|tree
name|src_var
init|=
name|src
decl_stmt|;
comment|/* See if this is a simple copy operation of an SSA name to the function      result.  In that case we may have a simple tail call.  Ignore type      conversions that can never produce extra code between the function      call and the function return.  */
name|STRIP_NOPS
argument_list|(
name|src_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src_var
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|src_var
operator|!=
operator|*
name|ass_var
condition|)
return|return
name|false
return|;
operator|*
name|ass_var
operator|=
name|dest
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|tcc_binary
condition|)
return|return
name|false
return|;
comment|/* Accumulator optimizations will reverse the order of operations.      We can only do that for floating-point types if we're assuming      that addition and multiplication are associative.  */
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We only handle the code like       x = call ();      y = m * x;      z = y + a;      return z;       TODO -- Extend it for cases where the linear transformation of the output      is expressed in a more complicated way.  */
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
operator|*
name|ass_var
operator|&&
operator|(
name|non_ass_var
operator|=
name|independent_of_stmt_p
argument_list|(
name|op1
argument_list|,
name|stmt
argument_list|,
name|call
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|op1
operator|==
operator|*
name|ass_var
operator|&&
operator|(
name|non_ass_var
operator|=
name|independent_of_stmt_p
argument_list|(
name|op0
argument_list|,
name|stmt
argument_list|,
name|call
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
name|false
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* There should be no previous addition.  TODO -- it should be fairly 	 straightforward to lift this restriction -- just allow storing 	 more complicated expressions in *A, and gimplify it in 	 adjust_accumulator_values.  */
if|if
condition|(
operator|*
name|a
condition|)
return|return
name|false
return|;
operator|*
name|a
operator|=
name|non_ass_var
expr_stmt|;
operator|*
name|ass_var
operator|=
name|dest
expr_stmt|;
return|return
name|true
return|;
case|case
name|MULT_EXPR
case|:
comment|/* Similar remark applies here.  Handling multiplication after addition 	 is just slightly more complicated -- we need to multiply both *A and 	 *M.  */
if|if
condition|(
operator|*
name|a
operator|||
operator|*
name|m
condition|)
return|return
name|false
return|;
operator|*
name|m
operator|=
name|non_ass_var
expr_stmt|;
operator|*
name|ass_var
operator|=
name|dest
expr_stmt|;
return|return
name|true
return|;
comment|/* TODO -- Handle other codes (NEGATE_EXPR, MINUS_EXPR).  */
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Propagate VAR through phis on edge E.  */
end_comment

begin_function
specifier|static
name|tree
name|propagate_through_phis
parameter_list|(
name|tree
name|var
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|dest
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|e
argument_list|)
operator|==
name|var
condition|)
return|return
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
return|;
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Finds tailcalls falling into basic block BB. The list of found tailcalls is    added to the start of RET.  */
end_comment

begin_function
specifier|static
name|void
name|find_tail_calls
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|tailcall
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|tree
name|ass_var
decl_stmt|,
name|ret_var
decl_stmt|,
name|stmt
decl_stmt|,
name|func
decl_stmt|,
name|param
decl_stmt|,
name|args
decl_stmt|,
name|call
init|=
name|NULL_TREE
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|absi
decl_stmt|;
name|bool
name|tail_recursion
decl_stmt|;
name|struct
name|tailcall
modifier|*
name|nw
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|m
decl_stmt|,
name|a
decl_stmt|;
name|basic_block
name|abb
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return;
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
comment|/* Ignore labels.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
continue|continue;
comment|/* Check for a call.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|ass_var
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|call
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|call
operator|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ass_var
operator|=
name|NULL_TREE
expr_stmt|;
name|call
operator|=
name|stmt
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|CALL_EXPR
condition|)
break|break;
comment|/* If the statement has virtual or volatile operands, fail.  */
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
operator|(
name|SSA_OP_VUSE
operator||
name|SSA_OP_VIRTUAL_DEFS
operator|)
argument_list|)
operator|||
name|ann
operator|->
name|has_volatile_ops
condition|)
return|return;
block|}
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Recurse to the predecessors.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|find_tail_calls
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We found the call, check whether it is suitable.  */
name|tail_recursion
operator|=
name|false
expr_stmt|;
name|func
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|current_function_decl
condition|)
block|{
for|for
control|(
name|param
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|func
argument_list|)
operator|,
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|1
argument_list|)
init|;
name|param
operator|&&
name|args
condition|;
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
operator|,
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|param
operator|!=
name|arg
condition|)
block|{
comment|/* Make sure there are no problems with copying.  The parameter 	         have a copyable type and the two arguments must have reasonably 	         equivalent types.  The latter requirement could be relaxed if 	         we emitted a suitable type conversion statement.  */
if|if
condition|(
operator|!
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|param
argument_list|)
argument_list|)
operator|||
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|param
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* The parameter should be a real operand, so that phi node 		 created for it at the start of the function has the meaning 		 of copying the value.  This test implies is_gimple_reg_type 		 from the previous condition, however this one could be 		 relaxed by being more careful with copying the new value 		 of the parameter (emitting appropriate MODIFY_EXPR and 		 updating the virtual operands).  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|param
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|args
operator|&&
operator|!
name|param
condition|)
name|tail_recursion
operator|=
name|true
expr_stmt|;
block|}
comment|/* Now check the statements after the call.  None of them has virtual      operands, so they may only depend on the call through its return      value.  The return value should also be dependent on each of them,      since we are running after dce.  */
name|m
operator|=
name|NULL_TREE
expr_stmt|;
name|a
operator|=
name|NULL_TREE
expr_stmt|;
name|abb
operator|=
name|bb
expr_stmt|;
name|absi
operator|=
name|bsi
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|absi
argument_list|)
expr_stmt|;
while|while
condition|(
name|bsi_end_p
argument_list|(
name|absi
argument_list|)
condition|)
block|{
name|ass_var
operator|=
name|propagate_through_phis
argument_list|(
name|ass_var
argument_list|,
name|single_succ_edge
argument_list|(
name|abb
argument_list|)
argument_list|)
expr_stmt|;
name|abb
operator|=
name|single_succ
argument_list|(
name|abb
argument_list|)
expr_stmt|;
name|absi
operator|=
name|bsi_start
argument_list|(
name|abb
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|absi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return;
if|if
condition|(
operator|!
name|process_assignment
argument_list|(
name|stmt
argument_list|,
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ass_var
argument_list|)
condition|)
return|return;
block|}
comment|/* See if this is a tail call we can handle.  */
name|ret_var
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_var
operator|&&
name|TREE_CODE
argument_list|(
name|ret_var
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|ret_op
init|=
name|TREE_OPERAND
argument_list|(
name|ret_var
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|ret_op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tail_recursion
operator|&&
name|TREE_CODE
argument_list|(
name|ret_op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return;
if|if
condition|(
operator|!
name|process_assignment
argument_list|(
name|ret_var
argument_list|,
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|ass_var
argument_list|)
condition|)
return|return;
name|ret_var
operator|=
name|TREE_OPERAND
argument_list|(
name|ret_var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We may proceed if there either is no return value, or the return value      is identical to the call's return.  */
if|if
condition|(
name|ret_var
operator|&&
operator|(
name|ret_var
operator|!=
name|ass_var
operator|)
condition|)
return|return;
comment|/* If this is not a tail recursive call, we cannot handle addends or      multiplicands.  */
if|if
condition|(
operator|!
name|tail_recursion
operator|&&
operator|(
name|m
operator|||
name|a
operator|)
condition|)
return|return;
name|nw
operator|=
name|XNEW
argument_list|(
expr|struct
name|tailcall
argument_list|)
expr_stmt|;
name|nw
operator|->
name|call_block
operator|=
name|bb
expr_stmt|;
name|nw
operator|->
name|call_bsi
operator|=
name|bsi
expr_stmt|;
name|nw
operator|->
name|tail_recursion
operator|=
name|tail_recursion
expr_stmt|;
name|nw
operator|->
name|mult
operator|=
name|m
expr_stmt|;
name|nw
operator|->
name|add
operator|=
name|a
expr_stmt|;
name|nw
operator|->
name|next
operator|=
operator|*
name|ret
expr_stmt|;
operator|*
name|ret
operator|=
name|nw
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust the accumulator values according to A and M after BSI, and update    the phi nodes on edge BACK.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_accumulator_values
parameter_list|(
name|block_stmt_iterator
name|bsi
parameter_list|,
name|tree
name|m
parameter_list|,
name|tree
name|a
parameter_list|,
name|edge
name|back
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|var
decl_stmt|,
name|phi
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|a_acc_arg
init|=
name|a_acc
decl_stmt|,
name|m_acc_arg
init|=
name|m_acc
decl_stmt|;
if|if
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|m_acc
condition|)
block|{
if|if
condition|(
name|integer_onep
argument_list|(
name|a
argument_list|)
condition|)
name|var
operator|=
name|m_acc
expr_stmt|;
else|else
block|{
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ret_type
argument_list|,
name|NULL_TREE
argument_list|,
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ret_type
argument_list|,
name|m_acc
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|ret_type
argument_list|,
literal|"acc_tmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|var
operator|=
name|make_ssa_name
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|var
operator|=
name|a
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ret_type
argument_list|,
name|NULL_TREE
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ret_type
argument_list|,
name|a_acc
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|=
name|make_ssa_name
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|a_acc
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|a_acc_arg
operator|=
name|var
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ret_type
argument_list|,
name|NULL_TREE
argument_list|,
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ret_type
argument_list|,
name|m_acc
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|=
name|make_ssa_name
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|m_acc
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|m_acc_arg
operator|=
name|var
expr_stmt|;
block|}
if|if
condition|(
name|a_acc
condition|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|back
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
operator|==
name|a_acc
condition|)
break|break;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|a_acc_arg
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_acc
condition|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|back
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
operator|==
name|m_acc
condition|)
break|break;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|m_acc_arg
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust value of the return at the end of BB according to M and A    accumulators.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_return_value
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|m
parameter_list|,
name|tree
name|a
parameter_list|)
block|{
name|tree
name|ret_stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|,
name|ret_var
decl_stmt|,
name|var
decl_stmt|,
name|stmt
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ret_stmt
argument_list|)
operator|==
name|RETURN_EXPR
argument_list|)
expr_stmt|;
name|ret_var
operator|=
name|TREE_OPERAND
argument_list|(
name|ret_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_var
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ret_var
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|ret_var
operator|->
name|common
operator|.
name|ann
operator|=
operator|(
name|tree_ann_t
operator|)
name|stmt_ann
argument_list|(
name|ret_stmt
argument_list|)
expr_stmt|;
name|bsi_replace
argument_list|(
operator|&
name|bsi
argument_list|,
name|ret_var
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ret_var
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|ret_var
expr_stmt|;
name|ret_var
operator|=
name|TREE_OPERAND
argument_list|(
name|ret_var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret_stmt
operator|=
name|build1
argument_list|(
name|RETURN_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ret_stmt
argument_list|)
argument_list|,
name|ret_var
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|ret_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ret_type
argument_list|,
name|NULL_TREE
argument_list|,
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|ret_type
argument_list|,
name|m_acc
argument_list|,
name|ret_var
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|ret_type
argument_list|,
literal|"acc_tmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|var
operator|=
name|make_ssa_name
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
else|else
name|var
operator|=
name|ret_var
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ret_type
argument_list|,
name|NULL_TREE
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ret_type
argument_list|,
name|a_acc
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|ret_type
argument_list|,
literal|"acc_tmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|var
operator|=
name|make_ssa_name
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|ret_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
name|update_stmt
argument_list|(
name|ret_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract COUNT and FREQUENCY from the basic block and it's    outgoing edge.  */
end_comment

begin_function
specifier|static
name|void
name|decrease_profile
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|bb
operator|->
name|count
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
literal|0
condition|)
name|bb
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|bb
operator|->
name|frequency
operator|-=
name|frequency
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
literal|0
condition|)
name|bb
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|e
operator|=
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|e
operator|->
name|count
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
condition|)
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if argument PARAM of the tail recursive call needs to be copied    when the call is eliminated.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_needs_copy_p
parameter_list|(
name|tree
name|param
parameter_list|)
block|{
name|tree
name|def
decl_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|param
argument_list|)
operator|||
operator|!
name|var_ann
argument_list|(
name|param
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Parameters that are only defined but never used need not be copied.  */
name|def
operator|=
name|default_def
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Eliminates tail call described by T.  TMP_VARS is a list of    temporary variables used to copy the function arguments.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_tail_call
parameter_list|(
name|struct
name|tailcall
modifier|*
name|t
parameter_list|)
block|{
name|tree
name|param
decl_stmt|,
name|stmt
decl_stmt|,
name|args
decl_stmt|,
name|rslt
decl_stmt|,
name|call
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|first
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|orig_stmt
decl_stmt|;
name|stmt
operator|=
name|orig_stmt
operator|=
name|bsi_stmt
argument_list|(
name|t
operator|->
name|call_bsi
argument_list|)
expr_stmt|;
name|bb
operator|=
name|t
operator|->
name|call_block
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Eliminated tail recursion in bb %d : "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|first
operator|=
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Remove the code after call_bsi that will become unreachable.  The      possibly unreachable code in other blocks is removed later in      cfg cleanup.  */
name|bsi
operator|=
name|t
operator|->
name|call_bsi
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
comment|/* Do not remove the return statement, so that redirect_edge_and_branch 	 sees how the block ends.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
break|break;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|release_defs
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Number of executions of function has reduced by the tailcall.  */
name|e
operator|=
name|single_succ_edge
argument_list|(
name|t
operator|->
name|call_block
argument_list|)
expr_stmt|;
name|decrease_profile
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|e
operator|->
name|count
argument_list|,
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|decrease_profile
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|e
operator|->
name|count
argument_list|,
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|decrease_profile
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|e
operator|->
name|count
argument_list|,
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the call by a jump to the start of function.  */
name|e
operator|=
name|redirect_edge_and_branch
argument_list|(
name|single_succ_edge
argument_list|(
name|t
operator|->
name|call_block
argument_list|)
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Add phi node entries for arguments.  The ordering of the phi nodes should      be the same as the ordering of the arguments.  */
for|for
control|(
name|param
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
operator|,
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|,
name|phi
operator|=
name|phi_nodes
argument_list|(
name|first
argument_list|)
init|;
name|param
condition|;
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
operator|,
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|arg_needs_copy_p
argument_list|(
name|param
argument_list|)
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|param
operator|==
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
block|}
comment|/* Update the values of accumulators.  */
name|adjust_accumulator_values
argument_list|(
name|t
operator|->
name|call_bsi
argument_list|,
name|t
operator|->
name|mult
argument_list|,
name|t
operator|->
name|add
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|call
operator|=
name|bsi_stmt
argument_list|(
name|t
operator|->
name|call_bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|rslt
operator|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Result of the call will no longer be defined.  So adjust the 	 SSA_NAME_DEF_STMT accordingly.  */
name|SSA_NAME_DEF_STMT
argument_list|(
name|rslt
argument_list|)
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
block|}
name|bsi_remove
argument_list|(
operator|&
name|t
operator|->
name|call_bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|release_defs
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add phi nodes for the virtual operands defined in the function to the    header of the loop created by tail recursion elimination.     Originally, we used to add phi nodes only for call clobbered variables,    as the value of the non-call clobbered ones obviously cannot be used    or changed within the recursive call.  However, the local variables    from multiple calls now share the same location, so the virtual ssa form    requires us to say that the location dies on further iterations of the loop,    which requires adding phi nodes. */
end_comment

begin_function
specifier|static
name|void
name|add_virtual_phis
parameter_list|(
name|void
parameter_list|)
block|{
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
comment|/* The problematic part is that there is no way how to know what      to put into phi nodes (there in fact does not have to be such      ssa name available).  A solution would be to have an artificial      use/kill for all virtual operands in EXIT node.  Unless we have      this, we cannot do much better than to rebuild the ssa form for      possibly affected virtual ssa names from scratch.  */
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|var
argument_list|)
operator|&&
name|default_def
argument_list|(
name|var
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|mark_sym_for_renaming
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|update_ssa
argument_list|(
name|TODO_update_ssa_only_virtuals
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Optimizes the tailcall described by T.  If OPT_TAILCALLS is true, also    mark the tailcalls for the sibcall optimization.  */
end_comment

begin_function
specifier|static
name|bool
name|optimize_tail_call
parameter_list|(
name|struct
name|tailcall
modifier|*
name|t
parameter_list|,
name|bool
name|opt_tailcalls
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|tail_recursion
condition|)
block|{
name|eliminate_tail_call
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|opt_tailcalls
condition|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|t
operator|->
name|call_bsi
argument_list|)
decl_stmt|;
name|stmt
operator|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|CALL_EXPR_TAILCALL
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found tail call "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" in bb %i\n"
argument_list|,
name|t
operator|->
name|call_block
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Optimizes tail calls in the function, turning the tail recursion    into iteration.  */
end_comment

begin_function
specifier|static
name|void
name|tree_optimize_tail_calls_1
parameter_list|(
name|bool
name|opt_tailcalls
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|bool
name|phis_constructed
init|=
name|false
decl_stmt|;
name|struct
name|tailcall
modifier|*
name|tailcalls
init|=
name|NULL
decl_stmt|,
modifier|*
name|act
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|basic_block
name|first
init|=
name|single_succ
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|param
decl_stmt|,
name|ret_type
decl_stmt|,
name|tmp
decl_stmt|,
name|phi
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|suitable_for_tail_opt_p
argument_list|()
condition|)
return|return;
if|if
condition|(
name|opt_tailcalls
condition|)
name|opt_tailcalls
operator|=
name|suitable_for_tail_call_opt_p
argument_list|()
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
block|{
comment|/* Only traverse the normal exits, i.e. those that end with return 	 statement.  */
name|stmt
operator|=
name|last_stmt
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
name|find_tail_calls
argument_list|(
name|e
operator|->
name|src
argument_list|,
operator|&
name|tailcalls
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the phi nodes and accumulators if necessary.  */
name|a_acc
operator|=
name|m_acc
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|act
operator|=
name|tailcalls
init|;
name|act
condition|;
name|act
operator|=
name|act
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|act
operator|->
name|tail_recursion
condition|)
continue|continue;
if|if
condition|(
operator|!
name|phis_constructed
condition|)
block|{
comment|/* Ensure that there is only one predecessor of the block.  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|first
argument_list|)
condition|)
name|first
operator|=
name|split_edge
argument_list|(
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the args if needed.  */
for|for
control|(
name|param
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|param
condition|;
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
control|)
if|if
condition|(
name|arg_needs_copy_p
argument_list|(
name|param
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|default_def
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|tree
name|new_name
init|=
name|make_ssa_name
argument_list|(
name|param
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|set_default_def
argument_list|(
name|param
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|phi
operator|=
name|create_phi_node
argument_list|(
name|name
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|name
argument_list|)
operator|=
name|phi
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|new_name
argument_list|,
name|single_pred_edge
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|phis_constructed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|->
name|add
operator|&&
operator|!
name|a_acc
condition|)
block|{
name|ret_type
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|ret_type
argument_list|,
literal|"add_acc"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|phi
operator|=
name|create_phi_node
argument_list|(
name|tmp
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
comment|/* RET_TYPE can be a float when -ffast-maths is 			  enabled.  */
name|fold_convert
argument_list|(
name|ret_type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|single_pred_edge
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|a_acc
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|->
name|mult
operator|&&
operator|!
name|m_acc
condition|)
block|{
name|ret_type
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|ret_type
argument_list|,
literal|"mult_acc"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|phi
operator|=
name|create_phi_node
argument_list|(
name|tmp
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
comment|/* RET_TYPE can be a float when -ffast-maths is 			  enabled.  */
name|fold_convert
argument_list|(
name|ret_type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|single_pred_edge
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|m_acc
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|phis_constructed
condition|)
block|{
comment|/* Reverse the order of the phi nodes, so that it matches the order 	 of operands of the function, as assumed by eliminate_tail_call.  */
name|set_phi_nodes
argument_list|(
name|first
argument_list|,
name|phi_reverse
argument_list|(
name|phi_nodes
argument_list|(
name|first
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|tailcalls
condition|;
name|tailcalls
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tailcalls
operator|->
name|next
expr_stmt|;
name|changed
operator||=
name|optimize_tail_call
argument_list|(
name|tailcalls
argument_list|,
name|opt_tailcalls
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tailcalls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_acc
operator|||
name|m_acc
condition|)
block|{
comment|/* Modify the remaining return statements.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
block|{
name|stmt
operator|=
name|last_stmt
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
name|adjust_return_value
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|m_acc
argument_list|,
name|a_acc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|phis_constructed
condition|)
name|add_virtual_phis
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|execute_tail_recursion
parameter_list|(
name|void
parameter_list|)
block|{
name|tree_optimize_tail_calls_1
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_tail_calls
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_optimize_sibling_calls
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|execute_tail_calls
parameter_list|(
name|void
parameter_list|)
block|{
name|tree_optimize_tail_calls_1
argument_list|(
name|true
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_tail_recursion
init|=
block|{
literal|"tailr"
block|,
comment|/* name */
name|gate_tail_calls
block|,
comment|/* gate */
name|execute_tail_recursion
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_tail_calls
init|=
block|{
literal|"tailc"
block|,
comment|/* name */
name|gate_tail_calls
block|,
comment|/* gate */
name|execute_tail_calls
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

