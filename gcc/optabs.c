begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Expand the basic unary and binary arithmetic operations, for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Include insn-config.h before expr.h so that HAVE_conditional_move    is properly defined.  */
end_comment

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Each optab contains info on how this target machine    can perform a particular operation    for all sizes and kinds of operands.     The operation to be performed is often specified    by passing one of these optabs as an argument.     See expr.h for documentation of these optabs.  */
end_comment

begin_decl_stmt
name|optab
name|optab_table
index|[
name|OTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|libfunc_table
index|[
name|LTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tables of patterns for converting one mode to another.  */
end_comment

begin_decl_stmt
name|convert_optab
name|convert_optab_table
index|[
name|COI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the optab used for each rtx code.  */
end_comment

begin_decl_stmt
name|optab
name|code_to_optab
index|[
name|NUM_RTX_CODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the gen_function to make a branch to test that condition.  */
end_comment

begin_decl_stmt
name|rtxfun
name|bcc_gen_fctn
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)    gives the insn code to make a store-condition insn    to test that condition.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|setcc_gen_code
index|[
name|NUM_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_move
end_ifdef

begin_comment
comment|/* Indexed by the machine mode, gives the insn code to make a conditional    move insn.  This is not indexed by the rtx-code like bcc_gen_fctn and    setcc_gen_code to cut down on the number of named patterns.  Consider a day    when a lot more rtx codes are conditional (eg: for the ARM).  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|movcc_gen_code
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by the machine mode, gives the insn code for vector conditional    operation.  */
end_comment

begin_decl_stmt
name|enum
name|insn_code
name|vcond_gen_code
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|vcondu_gen_code
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The insn generating function can not take an rtx_code argument.    TRAP_RTX is used as an rtx argument.  Its code is replaced with    the code to be used in the trap insn and all other fields are ignored.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|trap_rtx
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|add_equal_note
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|widen_operand
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepare_cmp_insn
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|rtx_code
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|can_compare_purpose
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|insn_code
name|can_fix_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|insn_code
name|can_float_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|optab
name|new_optab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|convert_optab
name|new_convert_optab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|optab
name|init_optab
parameter_list|(
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|optab
name|init_optabv
parameter_list|(
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|convert_optab
name|init_convert_optab
parameter_list|(
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_libfuncs
parameter_list|(
name|optab
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_integral_libfuncs
parameter_list|(
name|optab
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_floating_libfuncs
parameter_list|(
name|optab
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_interclass_conv_libfuncs
parameter_list|(
name|convert_optab
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|mode_class
parameter_list|,
name|enum
name|mode_class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_intraclass_conv_libfuncs
parameter_list|(
name|convert_optab
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|mode_class
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_cmp_and_jump_insn_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepare_float_lib_cmp
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|rtx_code
modifier|*
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|widen_clz
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|expand_parity
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rtx_code
name|get_rtx_code
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|vector_compare_rtx
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|,
name|enum
name|insn_code
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_trap
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_trap
value|0
end_define

begin_define
define|#
directive|define
name|gen_conditional_trap
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(gcc_unreachable (), NULL_RTX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to    the result of operation CODE applied to OP0 (and OP1 if it is a binary    operation).     If the last insn does not set TARGET, don't do anything, but return 1.     If a previous insn sets TARGET and TARGET is one of OP0 or OP1,    don't add the REG_EQUAL note but return 0.  Our caller can then try    again, ensuring that TARGET is not one of the operands.  */
end_comment

begin_function
specifier|static
name|int
name|add_equal_note
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|last_insn
decl_stmt|,
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|gcc_assert
argument_list|(
name|insns
operator|&&
name|INSN_P
argument_list|(
name|insns
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|insns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMM_ARITH
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_BIN_ARITH
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMM_COMPARE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMPARE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_UNARY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
return|return
literal|1
return|;
for|for
control|(
name|last_insn
operator|=
name|insns
init|;
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|!=
name|NULL_RTX
condition|;
name|last_insn
operator|=
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
control|)
empty_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL_RTX
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|target
argument_list|)
comment|/* For a STRICT_LOW_PART, the REG_NOTE applies to what is inside it.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|STRICT_LOW_PART
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If TARGET is in OP0 or OP1, check if anything in SEQ sets TARGET      besides the last insn.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
operator|(
name|op1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
operator|)
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|reg_set_p
argument_list|(
name|target
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_UNARY
condition|)
name|note
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|note
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|last_insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|note
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Widen OP to MODE and return the rtx for the widened operand.  UNSIGNEDP    says whether OP is signed or unsigned.  NO_EXTEND is nonzero if we need    not actually do a sign-extend or zero-extend, but can leave the    higher-order bits of the result rtx undefined, for example, in the case    of logical operations, but not right shifts.  */
end_comment

begin_function
specifier|static
name|rtx
name|widen_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|oldmode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|int
name|no_extend
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|;
comment|/* If we don't have to extend and this is a constant, return it.  */
if|if
condition|(
name|no_extend
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|op
return|;
comment|/* If we must extend do so.  If OP is a SUBREG for a promoted object, also      extend since it will be more efficient to do so unless the signedness of      a promoted object differs from our extension.  */
if|if
condition|(
operator|!
name|no_extend
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|op
argument_list|)
operator|&&
name|SUBREG_PROMOTED_UNSIGNED_P
argument_list|(
name|op
argument_list|)
operator|==
name|unsignedp
operator|)
condition|)
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|oldmode
argument_list|,
name|op
argument_list|,
name|unsignedp
argument_list|)
return|;
comment|/* If MODE is no wider than a single word, we return a paradoxical      SUBREG.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
return|return
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Otherwise, get an object of MODE, clobber it, and set the low-order      part to OP.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|result
argument_list|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the optab used for computing the operation given by    the tree code, CODE.  This function is not always usable (for    example, it cannot give complete results for multiplication    or division) but probably ought to be relied on more widely    throughout the expander.  */
end_comment

begin_function
name|optab
name|optab_for_tree_code
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|bool
name|trapv
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BIT_AND_EXPR
case|:
return|return
name|and_optab
return|;
case|case
name|BIT_IOR_EXPR
case|:
return|return
name|ior_optab
return|;
case|case
name|BIT_NOT_EXPR
case|:
return|return
name|one_cmpl_optab
return|;
case|case
name|BIT_XOR_EXPR
case|:
return|return
name|xor_optab
return|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|umod_optab
else|:
name|smod_optab
return|;
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|udiv_optab
else|:
name|sdiv_optab
return|;
case|case
name|LSHIFT_EXPR
case|:
return|return
name|ashl_optab
return|;
case|case
name|RSHIFT_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|lshr_optab
else|:
name|ashr_optab
return|;
case|case
name|LROTATE_EXPR
case|:
return|return
name|rotl_optab
return|;
case|case
name|RROTATE_EXPR
case|:
return|return
name|rotr_optab
return|;
case|case
name|MAX_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|umax_optab
else|:
name|smax_optab
return|;
case|case
name|MIN_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|umin_optab
else|:
name|smin_optab
return|;
case|case
name|REALIGN_LOAD_EXPR
case|:
return|return
name|vec_realign_load_optab
return|;
case|case
name|WIDEN_SUM_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|usum_widen_optab
else|:
name|ssum_widen_optab
return|;
case|case
name|DOT_PROD_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|udot_prod_optab
else|:
name|sdot_prod_optab
return|;
case|case
name|REDUC_MAX_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|reduc_umax_optab
else|:
name|reduc_smax_optab
return|;
case|case
name|REDUC_MIN_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|reduc_umin_optab
else|:
name|reduc_smin_optab
return|;
case|case
name|REDUC_PLUS_EXPR
case|:
return|return
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|reduc_uplus_optab
else|:
name|reduc_splus_optab
return|;
case|case
name|VEC_LSHIFT_EXPR
case|:
return|return
name|vec_shl_optab
return|;
case|case
name|VEC_RSHIFT_EXPR
case|:
return|return
name|vec_shr_optab
return|;
default|default:
break|break;
block|}
name|trapv
operator|=
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
return|return
name|trapv
condition|?
name|addv_optab
else|:
name|add_optab
return|;
case|case
name|MINUS_EXPR
case|:
return|return
name|trapv
condition|?
name|subv_optab
else|:
name|sub_optab
return|;
case|case
name|MULT_EXPR
case|:
return|return
name|trapv
condition|?
name|smulv_optab
else|:
name|smul_optab
return|;
case|case
name|NEGATE_EXPR
case|:
return|return
name|trapv
condition|?
name|negv_optab
else|:
name|neg_optab
return|;
case|case
name|ABS_EXPR
case|:
return|return
name|trapv
condition|?
name|absv_optab
else|:
name|abs_optab
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand vector widening operations.     There are two different classes of operations handled here:    1) Operations whose result is wider than all the arguments to the operation.       Examples: VEC_UNPACK_HI/LO_EXPR, VEC_WIDEN_MULT_HI/LO_EXPR       In this case OP0 and optionally OP1 would be initialized,       but WIDE_OP wouldn't (not relevant for this case).    2) Operations whose result is of the same size as the last argument to the       operation, but wider than all the other arguments to the operation.       Examples: WIDEN_SUM_EXPR, VEC_DOT_PROD_EXPR.       In the case WIDE_OP, OP0 and optionally OP1 would be initialized.     E.g, when called to expand the following operations, this is how    the arguments will be initialized:                                 nops    OP0     OP1     WIDE_OP    widening-sum                 2       oprnd0  -       oprnd1              widening-dot-product         3       oprnd0  oprnd1  oprnd2    widening-mult                2       oprnd0  oprnd1  -    type-promotion (vec-unpack)  1       oprnd0  -       -  */
end_comment

begin_function
name|rtx
name|expand_widen_pattern_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|wide_op
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|tree
name|oprnd0
decl_stmt|,
name|oprnd1
decl_stmt|,
name|oprnd2
decl_stmt|;
name|enum
name|machine_mode
name|wmode
init|=
literal|0
decl_stmt|,
name|tmode0
decl_stmt|,
name|tmode1
init|=
literal|0
decl_stmt|;
name|optab
name|widen_pattern_optab
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|xmode0
decl_stmt|,
name|xmode1
init|=
literal|0
decl_stmt|,
name|wxmode
init|=
literal|0
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
decl_stmt|,
name|xop1
decl_stmt|,
name|wxop
decl_stmt|;
name|int
name|nops
init|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|oprnd0
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode0
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
argument_list|)
expr_stmt|;
name|widen_pattern_optab
operator|=
name|optab_for_tree_code
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|oprnd0
argument_list|)
argument_list|)
expr_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|widen_pattern_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|tmode0
index|]
operator|.
name|insn_code
expr_stmt|;
name|gcc_assert
argument_list|(
name|icode
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
name|xmode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|nops
operator|>=
literal|2
condition|)
block|{
name|oprnd1
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmode1
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd1
argument_list|)
argument_list|)
expr_stmt|;
name|xmode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
block|}
comment|/* The last operand is of a wider mode than the rest of the operands.  */
if|if
condition|(
name|nops
operator|==
literal|2
condition|)
block|{
name|wmode
operator|=
name|tmode1
expr_stmt|;
name|wxmode
operator|=
name|xmode1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nops
operator|==
literal|3
condition|)
block|{
name|gcc_assert
argument_list|(
name|tmode1
operator|==
name|tmode0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|oprnd2
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|wmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oprnd2
argument_list|)
argument_list|)
expr_stmt|;
name|wxmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wide_op
condition|)
name|wmode
operator|=
name|wxmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|wmode
operator|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|wmode
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|target
expr_stmt|;
name|xop0
operator|=
name|op0
expr_stmt|;
name|xop1
operator|=
name|op1
expr_stmt|;
name|wxop
operator|=
name|wide_op
expr_stmt|;
comment|/* In case the insn wants input operands in modes different from      those of the actual operands, convert the operands.  It would      seem that we don't need to convert CONST_INTs, but we do, so      that they're properly zero-extended, sign-extended or truncated      for their mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|xmode0
operator|&&
name|xmode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|convert_modes
argument_list|(
name|xmode0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|tmode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|xmode1
operator|&&
name|xmode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|convert_modes
argument_list|(
name|xmode1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op1
argument_list|)
else|:
name|tmode1
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_op
condition|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|wide_op
argument_list|)
operator|!=
name|wxmode
operator|&&
name|wxmode
operator|!=
name|VOIDmode
condition|)
name|wxop
operator|=
name|convert_modes
argument_list|(
name|wxmode
argument_list|,
name|GET_MODE
argument_list|(
name|wide_op
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|wide_op
argument_list|)
else|:
name|wmode
argument_list|,
name|wxop
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn's predicates don't allow our operands, put them into      pseudo regs.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop0
operator|,
name|xmode0
operator|)
operator|&&
name|xmode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|xmode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|xop1
operator|,
name|xmode1
operator|)
operator|&&
name|xmode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|xmode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_op
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|wxop
operator|,
name|wxmode
operator|)
operator|&&
name|wxmode
operator|!=
name|VOIDmode
condition|)
name|wxop
operator|=
name|copy_to_mode_reg
argument_list|(
name|wxmode
argument_list|,
name|wxop
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|wxop
argument_list|)
expr_stmt|;
block|}
else|else
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wide_op
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|wxop
operator|,
name|wxmode
operator|)
operator|&&
name|wxmode
operator|!=
name|VOIDmode
condition|)
name|wxop
operator|=
name|copy_to_mode_reg
argument_list|(
name|wxmode
argument_list|,
name|wxop
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|wxop
argument_list|)
expr_stmt|;
block|}
else|else
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Generate code to perform an operation specified by TERNARY_OPTAB    on operands OP0, OP1 and OP2, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_ternary_op
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|optab
name|ternary_optab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|ternary_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode2
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xop2
init|=
name|op2
decl_stmt|;
name|gcc_assert
argument_list|(
name|ternary_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|target
expr_stmt|;
comment|/* In case the insn wants input operands in modes different from      those of the actual operands, convert the operands.  It would      seem that we don't need to convert CONST_INTs, but we do, so      that they're properly zero-extended, sign-extended or truncated      for their mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|mode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|convert_modes
argument_list|(
name|mode0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|convert_modes
argument_list|(
name|mode1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op1
argument_list|)
else|:
name|mode
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|mode2
operator|&&
name|mode2
operator|!=
name|VOIDmode
condition|)
name|xop2
operator|=
name|convert_modes
argument_list|(
name|mode2
argument_list|,
name|GET_MODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op2
argument_list|)
else|:
name|mode
argument_list|,
name|xop2
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn's predicates don't allow our operands, put them into      pseudo regs.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
operator|&&
name|mode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|xop1
argument_list|,
name|mode1
argument_list|)
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
argument_list|(
name|xop2
argument_list|,
name|mode2
argument_list|)
operator|&&
name|mode2
operator|!=
name|VOIDmode
condition|)
name|xop2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|xop2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|xop2
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Like expand_binop, but return a constant rtx if the result can be    calculated at compile time.  The arguments and return value are    otherwise the same as for expand_binop.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_expand_binop
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|optab
name|binoptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|rtx
name|x
init|=
name|simplify_binary_operation
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
return|return
name|x
return|;
block|}
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like simplify_expand_binop, but always put the result in TARGET.    Return true if the expansion succeeded.  */
end_comment

begin_function
name|bool
name|force_expand_binop
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|optab
name|binoptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|)
block|{
name|rtx
name|x
init|=
name|simplify_expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|x
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate insns for VEC_LSHIFT_EXPR, VEC_RSHIFT_EXPR.  */
end_comment

begin_function
name|rtx
name|expand_vec_shift_expr
parameter_list|(
name|tree
name|vec_shift_expr
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|rtx_op1
decl_stmt|,
name|rtx_op2
decl_stmt|;
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|enum
name|machine_mode
name|mode2
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vec_shift_expr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|vec_oprnd
init|=
name|TREE_OPERAND
argument_list|(
name|vec_shift_expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|shift_oprnd
init|=
name|TREE_OPERAND
argument_list|(
name|vec_shift_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|optab
name|shift_optab
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|vec_shift_expr
argument_list|)
condition|)
block|{
case|case
name|VEC_RSHIFT_EXPR
case|:
name|shift_optab
operator|=
name|vec_shr_optab
expr_stmt|;
break|break;
case|case
name|VEC_LSHIFT_EXPR
case|:
name|shift_optab
operator|=
name|vec_shl_optab
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|icode
operator|=
operator|(
name|int
operator|)
name|shift_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
name|gcc_assert
argument_list|(
name|icode
operator|!=
name|CODE_FOR_nothing
argument_list|)
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|rtx_op1
operator|=
name|expand_expr
argument_list|(
name|vec_oprnd
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|rtx_op1
operator|,
name|mode1
operator|)
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|rtx_op1
operator|=
name|force_reg
argument_list|(
name|mode1
argument_list|,
name|rtx_op1
argument_list|)
expr_stmt|;
name|rtx_op2
operator|=
name|expand_expr
argument_list|(
name|shift_oprnd
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|rtx_op2
operator|,
name|mode2
operator|)
operator|&&
name|mode2
operator|!=
name|VOIDmode
condition|)
name|rtx_op2
operator|=
name|force_reg
argument_list|(
name|mode2
argument_list|,
name|rtx_op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|mode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Emit instruction */
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|rtx_op1
argument_list|,
name|rtx_op2
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* This subroutine of expand_doubleword_shift handles the cases in which    the effective shift value is>= BITS_PER_WORD.  The arguments and return    value are the same as for the parent routine, except that SUPERWORD_OP1    is the shift count to use when shifting OUTOF_INPUT into INTO_TARGET.    INTO_TARGET may be null if the caller has decided to calculate it.  */
end_comment

begin_function
specifier|static
name|bool
name|expand_superword_shift
parameter_list|(
name|optab
name|binoptab
parameter_list|,
name|rtx
name|outof_input
parameter_list|,
name|rtx
name|superword_op1
parameter_list|,
name|rtx
name|outof_target
parameter_list|,
name|rtx
name|into_target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|)
block|{
if|if
condition|(
name|into_target
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|force_expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|superword_op1
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|outof_target
operator|!=
literal|0
condition|)
block|{
comment|/* For a signed right shift, we must fill OUTOF_TARGET with copies 	 of the sign bit, otherwise we must fill it with zeros.  */
if|if
condition|(
name|binoptab
operator|!=
name|ashr_optab
condition|)
name|emit_move_insn
argument_list|(
name|outof_target
argument_list|,
name|CONST0_RTX
argument_list|(
name|word_mode
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|force_expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
literal|1
argument_list|)
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This subroutine of expand_doubleword_shift handles the cases in which    the effective shift value is< BITS_PER_WORD.  The arguments and return    value are the same as for the parent routine.  */
end_comment

begin_function
specifier|static
name|bool
name|expand_subword_shift
parameter_list|(
name|enum
name|machine_mode
name|op1_mode
parameter_list|,
name|optab
name|binoptab
parameter_list|,
name|rtx
name|outof_input
parameter_list|,
name|rtx
name|into_input
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|outof_target
parameter_list|,
name|rtx
name|into_target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
parameter_list|)
block|{
name|optab
name|reverse_unsigned_shift
decl_stmt|,
name|unsigned_shift
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|carries
decl_stmt|;
name|reverse_unsigned_shift
operator|=
operator|(
name|binoptab
operator|==
name|ashl_optab
condition|?
name|lshr_optab
else|:
name|ashl_optab
operator|)
expr_stmt|;
name|unsigned_shift
operator|=
operator|(
name|binoptab
operator|==
name|ashl_optab
condition|?
name|ashl_optab
else|:
name|lshr_optab
operator|)
expr_stmt|;
comment|/* The low OP1 bits of INTO_TARGET come from the high bits of OUTOF_INPUT.      We therefore need to shift OUTOF_INPUT by (BITS_PER_WORD - OP1) bits in      the opposite direction to BINOPTAB.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|||
name|shift_mask
operator|>=
name|BITS_PER_WORD
condition|)
block|{
name|carries
operator|=
name|outof_input
expr_stmt|;
name|tmp
operator|=
name|immed_double_const
argument_list|(
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|,
name|op1_mode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_expand_binop
argument_list|(
name|op1_mode
argument_list|,
name|sub_optab
argument_list|,
name|tmp
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We must avoid shifting by BITS_PER_WORD bits since that is either 	 the same as a zero shift (if shift_mask == BITS_PER_WORD - 1) or 	 has unknown behavior.  Do a single shift first, then shift by the 	 remainder.  It's OK to use ~OP1 as the remainder if shift counts 	 are truncated to the mode size.  */
name|carries
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|reverse_unsigned_shift
argument_list|,
name|outof_input
argument_list|,
name|const1_rtx
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_mask
operator|==
name|BITS_PER_WORD
operator|-
literal|1
condition|)
block|{
name|tmp
operator|=
name|immed_double_const
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|op1_mode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_expand_binop
argument_list|(
name|op1_mode
argument_list|,
name|xor_optab
argument_list|,
name|op1
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|immed_double_const
argument_list|(
name|BITS_PER_WORD
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|op1_mode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_expand_binop
argument_list|(
name|op1_mode
argument_list|,
name|sub_optab
argument_list|,
name|tmp
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmp
operator|==
literal|0
operator|||
name|carries
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|carries
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|reverse_unsigned_shift
argument_list|,
name|carries
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|carries
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* Shift INTO_INPUT logically by OP1.  This is the last use of INTO_INPUT      so the result can go directly into INTO_TARGET if convenient.  */
name|tmp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|unsigned_shift
argument_list|,
name|into_input
argument_list|,
name|op1
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* Now OR in the bits carried over from OUTOF_INPUT.  */
if|if
condition|(
operator|!
name|force_expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|tmp
argument_list|,
name|carries
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Use a standard word_mode shift for the out-of half.  */
if|if
condition|(
name|outof_target
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|force_expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|op1
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_move
end_ifdef

begin_comment
comment|/* Try implementing expand_doubleword_shift using conditional moves.    The shift is by< BITS_PER_WORD if (CMP_CODE CMP1 CMP2) is true,    otherwise it is by>= BITS_PER_WORD.  SUBWORD_OP1 and SUPERWORD_OP1    are the shift counts to use in the former and latter case.  All other    arguments are the same as the parent routine.  */
end_comment

begin_function
specifier|static
name|bool
name|expand_doubleword_shift_condmove
parameter_list|(
name|enum
name|machine_mode
name|op1_mode
parameter_list|,
name|optab
name|binoptab
parameter_list|,
name|enum
name|rtx_code
name|cmp_code
parameter_list|,
name|rtx
name|cmp1
parameter_list|,
name|rtx
name|cmp2
parameter_list|,
name|rtx
name|outof_input
parameter_list|,
name|rtx
name|into_input
parameter_list|,
name|rtx
name|subword_op1
parameter_list|,
name|rtx
name|superword_op1
parameter_list|,
name|rtx
name|outof_target
parameter_list|,
name|rtx
name|into_target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
parameter_list|)
block|{
name|rtx
name|outof_superword
decl_stmt|,
name|into_superword
decl_stmt|;
comment|/* Put the superword version of the output into OUTOF_SUPERWORD and      INTO_SUPERWORD.  */
name|outof_superword
operator|=
name|outof_target
operator|!=
literal|0
condition|?
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|outof_target
operator|!=
literal|0
operator|&&
name|subword_op1
operator|==
name|superword_op1
condition|)
block|{
comment|/* The value INTO_TARGET>> SUBWORD_OP1, which we later store in 	 OUTOF_TARGET, is the same as the value of INTO_SUPERWORD.  */
name|into_superword
operator|=
name|outof_target
expr_stmt|;
if|if
condition|(
operator|!
name|expand_superword_shift
argument_list|(
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|superword_op1
argument_list|,
name|outof_superword
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|into_superword
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_superword_shift
argument_list|(
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|superword_op1
argument_list|,
name|outof_superword
argument_list|,
name|into_superword
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Put the subword version directly in OUTOF_TARGET and INTO_TARGET.  */
if|if
condition|(
operator|!
name|expand_subword_shift
argument_list|(
name|op1_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|into_input
argument_list|,
name|subword_op1
argument_list|,
name|outof_target
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|,
name|shift_mask
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Select between them.  Do the INTO half first because INTO_SUPERWORD      might be the current value of OUTOF_TARGET.  */
if|if
condition|(
operator|!
name|emit_conditional_move
argument_list|(
name|into_target
argument_list|,
name|cmp_code
argument_list|,
name|cmp1
argument_list|,
name|cmp2
argument_list|,
name|op1_mode
argument_list|,
name|into_target
argument_list|,
name|into_superword
argument_list|,
name|word_mode
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|outof_target
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
name|emit_conditional_move
argument_list|(
name|outof_target
argument_list|,
name|cmp_code
argument_list|,
name|cmp1
argument_list|,
name|cmp2
argument_list|,
name|op1_mode
argument_list|,
name|outof_target
argument_list|,
name|outof_superword
argument_list|,
name|word_mode
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Expand a doubleword shift (ashl, ashr or lshr) using word-mode shifts.    OUTOF_INPUT and INTO_INPUT are the two word-sized halves of the first    input operand; the shift moves bits in the direction OUTOF_INPUT->    INTO_TARGET.  OUTOF_TARGET and INTO_TARGET are the equivalent words    of the target.  OP1 is the shift count and OP1_MODE is its mode.    If OP1 is constant, it will have been truncated as appropriate    and is known to be nonzero.     If SHIFT_MASK is zero, the result of word shifts is undefined when the    shift count is outside the range [0, BITS_PER_WORD).  This routine must    avoid generating such shifts for OP1s in the range [0, BITS_PER_WORD * 2).     If SHIFT_MASK is nonzero, all word-mode shift counts are effectively    masked by it and shifts in the range [BITS_PER_WORD, SHIFT_MASK) will    fill with zeros or sign bits as appropriate.     If SHIFT_MASK is BITS_PER_WORD - 1, this routine will synthesize    a doubleword shift whose equivalent mask is BITS_PER_WORD * 2 - 1.    Doing this preserves semantics required by SHIFT_COUNT_TRUNCATED.    In all other cases, shifts by values outside [0, BITS_PER_UNIT * 2)    are undefined.     BINOPTAB, UNSIGNEDP and METHODS are as for expand_binop.  This function    may not use INTO_INPUT after modifying INTO_TARGET, and similarly for    OUTOF_INPUT and OUTOF_TARGET.  OUTOF_TARGET can be null if the parent    function wants to calculate it itself.     Return true if the shift could be successfully synthesized.  */
end_comment

begin_function
specifier|static
name|bool
name|expand_doubleword_shift
parameter_list|(
name|enum
name|machine_mode
name|op1_mode
parameter_list|,
name|optab
name|binoptab
parameter_list|,
name|rtx
name|outof_input
parameter_list|,
name|rtx
name|into_input
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|outof_target
parameter_list|,
name|rtx
name|into_target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
parameter_list|)
block|{
name|rtx
name|superword_op1
decl_stmt|,
name|tmp
decl_stmt|,
name|cmp1
decl_stmt|,
name|cmp2
decl_stmt|;
name|rtx
name|subword_label
decl_stmt|,
name|done_label
decl_stmt|;
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
comment|/* See if word-mode shifts by BITS_PER_WORD...BITS_PER_WORD * 2 - 1 will      fill the result with sign or zero bits as appropriate.  If so, the value      of OUTOF_TARGET will always be (SHIFT OUTOF_INPUT OP1).   Recursively call      this routine to calculate INTO_TARGET (which depends on both OUTOF_INPUT      and INTO_INPUT), then emit code to set up OUTOF_TARGET.       This isn't worthwhile for constant shifts since the optimizers will      cope better with in-range shift counts.  */
if|if
condition|(
name|shift_mask
operator|>=
name|BITS_PER_WORD
operator|&&
name|outof_target
operator|!=
literal|0
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|expand_doubleword_shift
argument_list|(
name|op1_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|into_input
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|,
name|shift_mask
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|force_expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|op1
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
comment|/* Set CMP_CODE, CMP1 and CMP2 so that the rtx (CMP_CODE CMP1 CMP2)      is true when the effective shift value is less than BITS_PER_WORD.      Set SUPERWORD_OP1 to the shift count that should be used to shift      OUTOF_INPUT into INTO_TARGET when the condition is false.  */
name|tmp
operator|=
name|immed_double_const
argument_list|(
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|,
name|op1_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|shift_mask
operator|==
name|BITS_PER_WORD
operator|-
literal|1
condition|)
block|{
comment|/* Set CMP1 to OP1& BITS_PER_WORD.  The result is zero iff OP1 	 is a subword shift count.  */
name|cmp1
operator|=
name|simplify_expand_binop
argument_list|(
name|op1_mode
argument_list|,
name|and_optab
argument_list|,
name|op1
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|cmp2
operator|=
name|CONST0_RTX
argument_list|(
name|op1_mode
argument_list|)
expr_stmt|;
name|cmp_code
operator|=
name|EQ
expr_stmt|;
name|superword_op1
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
comment|/* Set CMP1 to OP1 - BITS_PER_WORD.  */
name|cmp1
operator|=
name|simplify_expand_binop
argument_list|(
name|op1_mode
argument_list|,
name|sub_optab
argument_list|,
name|op1
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|cmp2
operator|=
name|CONST0_RTX
argument_list|(
name|op1_mode
argument_list|)
expr_stmt|;
name|cmp_code
operator|=
name|LT
expr_stmt|;
name|superword_op1
operator|=
name|cmp1
expr_stmt|;
block|}
if|if
condition|(
name|cmp1
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* If we can compute the condition at compile time, pick the      appropriate subroutine.  */
name|tmp
operator|=
name|simplify_relational_operation
argument_list|(
name|cmp_code
argument_list|,
name|SImode
argument_list|,
name|op1_mode
argument_list|,
name|cmp1
argument_list|,
name|cmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
name|const0_rtx
condition|)
return|return
name|expand_superword_shift
argument_list|(
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|superword_op1
argument_list|,
name|outof_target
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
else|else
return|return
name|expand_subword_shift
argument_list|(
name|op1_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|into_input
argument_list|,
name|op1
argument_list|,
name|outof_target
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|,
name|shift_mask
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_conditional_move
comment|/* Try using conditional moves to generate straight-line code.  */
block|{
name|rtx
name|start
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|expand_doubleword_shift_condmove
argument_list|(
name|op1_mode
argument_list|,
name|binoptab
argument_list|,
name|cmp_code
argument_list|,
name|cmp1
argument_list|,
name|cmp2
argument_list|,
name|outof_input
argument_list|,
name|into_input
argument_list|,
name|op1
argument_list|,
name|superword_op1
argument_list|,
name|outof_target
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|,
name|shift_mask
argument_list|)
condition|)
return|return
name|true
return|;
name|delete_insns_since
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* As a last resort, use branches to select the correct alternative.  */
name|subword_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|done_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|cmp1
argument_list|,
name|cmp2
argument_list|,
name|cmp_code
argument_list|,
name|false
argument_list|,
name|op1_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|subword_label
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
if|if
condition|(
operator|!
name|expand_superword_shift
argument_list|(
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|superword_op1
argument_list|,
name|outof_target
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
condition|)
return|return
name|false
return|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|done_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|subword_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_subword_shift
argument_list|(
name|op1_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|into_input
argument_list|,
name|op1
argument_list|,
name|outof_target
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|,
name|shift_mask
argument_list|)
condition|)
return|return
name|false
return|;
name|emit_label
argument_list|(
name|done_label
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of expand_binop.  Perform a double word multiplication of    operands OP0 and OP1 both of mode MODE, which is exactly twice as wide    as the target's word_mode.  This function return NULL_RTX if anything    goes wrong, in which case it may have already emitted instructions    which need to be deleted.     If we want to multiply two two-word values and have normal and widening    multiplies of single-word values, we can do this with three smaller    multiplications.  Note that we do not make a REG_NO_CONFLICT block here    because we are not operating on one word at a time.     The multiplication proceeds as follows: 			         _______________________ 			        [__op0_high_|__op0_low__] 			         _______________________         *			[__op1_high_|__op1_low__]         _______________________________________________ 			         _______________________     (1)				[__op0_low__*__op1_low__] 		     _______________________     (2a)	    [__op0_low__*__op1_high_] 		     _______________________     (2b)	    [__op0_high_*__op1_low__]          _______________________     (3) [__op0_high_*__op1_high_]     This gives a 4-word result.  Since we are only interested in the   lower 2 words, partial result (3) and the upper words of (2a) and   (2b) don't need to be calculated.  Hence (2a) and (2b) can be   calculated using non-widening multiplication.    (1), however, needs to be calculated with an unsigned widening   multiplication.  If this operation is not directly supported we   try using a signed widening multiplication and adjust the result.   This adjustment works as follows:        If both operands are positive then no adjustment is needed.        If the operands have different signs, for example op0_low< 0 and       op1_low>= 0, the instruction treats the most significant bit of       op0_low as a sign bit instead of a bit with significance       2**(BITS_PER_WORD-1), i.e. the instruction multiplies op1_low       with 2**BITS_PER_WORD - op0_low, and two's complements the       result.  Conclusion: We need to add op1_low * 2**BITS_PER_WORD to       the result.        Similarly, if both operands are negative, we need to add       (op0_low + op1_low) * 2**BITS_PER_WORD.        We use a trick to adjust quickly.  We logically shift op0_low right       (op1_low) BITS_PER_WORD-1 steps to get 0 or 1, and add this to       op0_high (op1_high) before it is used to calculate 2b (2a).  If no       logical shift exists, we do an arithmetic right shift and subtract       the 0 or -1.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_doubleword_mult
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|bool
name|umulp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|)
block|{
name|int
name|low
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|high
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|rtx
name|wordm1
init|=
name|umulp
condition|?
name|NULL_RTX
else|:
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|product
decl_stmt|,
name|adjust
decl_stmt|,
name|product_high
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|op0_high
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_low
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|low
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_high
init|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_low
init|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|low
argument_list|,
name|mode
argument_list|)
decl_stmt|;
comment|/* If we're using an unsigned multiply to directly compute the product      of the low-order words of the operands and perform any required      adjustments of the operands, we begin by trying two more multiplications      and then computing the appropriate sum.       We have checked above that the required addition is provided.      Full-word addition will normally always succeed, especially if      it is provided at all, so we don't worry about its failure.  The      multiplication may well fail, however, so we do handle that.  */
if|if
condition|(
operator|!
name|umulp
condition|)
block|{
comment|/* ??? This could be done with emit_store_flag where available.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|lshr_optab
argument_list|,
name|op0_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|op0_high
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|op0_high
argument_list|,
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashr_optab
argument_list|,
name|op0_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
return|return
name|NULL_RTX
return|;
name|op0_high
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|sub_optab
argument_list|,
name|op0_high
argument_list|,
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|op0_high
condition|)
return|return
name|NULL_RTX
return|;
block|}
name|adjust
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|smul_optab
argument_list|,
name|op0_high
argument_list|,
name|op1_low
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adjust
condition|)
return|return
name|NULL_RTX
return|;
comment|/* OP0_HIGH should now be dead.  */
if|if
condition|(
operator|!
name|umulp
condition|)
block|{
comment|/* ??? This could be done with emit_store_flag where available.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|lshr_optab
argument_list|,
name|op1_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|op1_high
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|op1_high
argument_list|,
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ashr_optab
argument_list|,
name|op1_low
argument_list|,
name|wordm1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
return|return
name|NULL_RTX
return|;
name|op1_high
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|sub_optab
argument_list|,
name|op1_high
argument_list|,
name|temp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|op1_high
condition|)
return|return
name|NULL_RTX
return|;
block|}
name|temp
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|smul_optab
argument_list|,
name|op1_high
argument_list|,
name|op0_low
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
return|return
name|NULL_RTX
return|;
comment|/* OP1_HIGH should now be dead.  */
name|adjust
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|adjust
argument_list|,
name|temp
argument_list|,
name|adjust
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|&&
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|umulp
condition|)
name|product
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|umul_widen_optab
argument_list|,
name|op0_low
argument_list|,
name|op1_low
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
else|else
name|product
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smul_widen_optab
argument_list|,
name|op0_low
argument_list|,
name|op1_low
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|product
condition|)
return|return
name|NULL_RTX
return|;
name|product_high
operator|=
name|operand_subword
argument_list|(
name|product
argument_list|,
name|high
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|add_optab
argument_list|,
name|product_high
argument_list|,
name|adjust
argument_list|,
name|REG_P
argument_list|(
name|product_high
argument_list|)
condition|?
name|product_high
else|:
name|adjust
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|product_high
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
return|return
name|product
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrapper around expand_binop which takes an rtx code to specify    the operation to perform, not an optab pointer.  All other    arguments are the same.  */
end_comment

begin_function
name|rtx
name|expand_simple_binop
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|)
block|{
name|optab
name|binop
init|=
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|binop
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binop
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether OP0 and OP1 should be swapped when expanding a commutative    binop.  Order them according to commutative_operand_precedence and, if    possible, try to put TARGET or a pseudo first.  */
end_comment

begin_function
specifier|static
name|bool
name|swap_commutative_operands_with_target
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|int
name|op0_prec
init|=
name|commutative_operand_precedence
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|int
name|op1_prec
init|=
name|commutative_operand_precedence
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0_prec
operator|<
name|op1_prec
condition|)
return|return
name|true
return|;
if|if
condition|(
name|op0_prec
operator|>
name|op1_prec
condition|)
return|return
name|false
return|;
comment|/* With equal precedence, both orders are ok, but it is better if the      first operand is TARGET, or if both TARGET and OP0 are pseudos.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
return|return
operator|(
name|REG_P
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|)
operator|||
name|target
operator|==
name|op1
return|;
else|else
return|return
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_binop
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|optab
name|binoptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|)
block|{
name|enum
name|optab_methods
name|next_methods
init|=
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|?
name|OPTAB_WIDEN
else|:
name|methods
operator|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|commutative_op
init|=
literal|0
decl_stmt|;
name|int
name|shift_op
init|=
operator|(
name|binoptab
operator|->
name|code
operator|==
name|ASHIFT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ASHIFTRT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|LSHIFTRT
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ROTATE
operator|||
name|binoptab
operator|->
name|code
operator|==
name|ROTATERT
operator|)
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|bool
name|first_pass_p
init|=
name|true
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If subtracting an integer constant, convert this into an addition of      the negated constant.  */
if|if
condition|(
name|binoptab
operator|==
name|sub_optab
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|negate_rtx
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|add_optab
expr_stmt|;
block|}
comment|/* If we are inside an appropriately-short loop and we are optimizing,      force expensive constants into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|optimize
operator|&&
name|rtx_cost
argument_list|(
name|op0
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|op0
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|optimize
operator|&&
operator|!
name|shift_op
operator|&&
name|rtx_cost
argument_list|(
name|op1
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|op1
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Record where to delete back to if we backtrack.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* If operation is commutative,      try to make the first operand a register.      Even better, try to make it the same as the target.      Also try to make the last operand a constant.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|binoptab
operator|->
name|code
argument_list|)
operator|==
name|RTX_COMM_ARITH
operator|||
name|binoptab
operator|==
name|smul_widen_optab
operator|||
name|binoptab
operator|==
name|umul_widen_optab
operator|||
name|binoptab
operator|==
name|smul_highpart_optab
operator|||
name|binoptab
operator|==
name|umul_highpart_optab
condition|)
block|{
name|commutative_op
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|swap_commutative_operands_with_target
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|temp
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|retry
label|:
comment|/* If we can do it with a three-operand insn, do so.  */
if|if
condition|(
name|methods
operator|!=
name|OPTAB_MUST_WIDEN
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If it is a commutative operator and the modes would match 	 if we would swap the operands, we can save the conversions.  */
if|if
condition|(
name|commutative_op
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode0
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|xop0
expr_stmt|;
name|xop0
operator|=
name|xop1
expr_stmt|;
name|xop1
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* In case the insn wants input operands in modes different from 	 those of the actual operands, convert the operands.  It would 	 seem that we don't need to convert CONST_INTs, but we do, so 	 that they're properly zero-extended, sign-extended or truncated 	 for their mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|mode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|convert_modes
argument_list|(
name|mode0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|convert_modes
argument_list|(
name|mode1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op1
argument_list|)
else|:
name|mode
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn's predicates don't allow our operands, put them into 	 pseudo regs.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
operator|&&
name|mode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|xop1
argument_list|,
name|mode1
argument_list|)
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
comment|/* If PAT is composed of more than one insn, try to add an appropriate 	     REG_EQUAL note to it.  If we can't because TEMP conflicts with an 	     operand, call ourselves again, this time without a target.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|pat
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|pat
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|binoptab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If we were trying to rotate by a constant value, and that didn't      work, try rotating the other direction before falling back to      shifts and bitwise-or.  */
if|if
condition|(
name|first_pass_p
operator|&&
operator|(
name|binoptab
operator|==
name|rotl_optab
operator|||
name|binoptab
operator|==
name|rotr_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|first_pass_p
operator|=
name|false
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|binoptab
operator|==
name|rotl_optab
condition|?
name|rotr_optab
else|:
name|rotl_optab
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* If this is a multiply, see if we can do a widening operation that      takes operands of this mode and makes a wider mode.  */
if|if
condition|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
operator|(
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
index|]
operator|.
name|insn_code
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
else|else
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
block|}
comment|/* Look for a wider mode of the same class for which we think we      can open-code the operation.  Check for a widening multiply at the      wider mode as well.  */
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
operator|&&
name|methods
operator|!=
name|OPTAB_DIRECT
operator|&&
name|methods
operator|!=
name|OPTAB_LIB
condition|)
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|||
operator|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|(
operator|(
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
operator|)
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
index|]
operator|.
name|insn_code
operator|)
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
name|int
name|no_extend
init|=
literal|0
decl_stmt|;
comment|/* For certain integer operations, we need not actually extend 	       the narrow operands, as long as we will truncate 	       the results to the same narrowness.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
condition|)
name|no_extend
operator|=
literal|1
expr_stmt|;
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
argument_list|)
expr_stmt|;
comment|/* The second operand of a shift must always be extended.  */
name|xop1
operator|=
name|widen_operand
argument_list|(
name|xop1
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
operator|&&
name|binoptab
operator|!=
name|ashl_optab
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|binoptab
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
operator|||
operator|!
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These can be done a word at a time.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|rtx
name|equiv_value
decl_stmt|;
comment|/* If TARGET is the same as one of the operands, the REG_EQUAL note 	 won't be accurate, so use a new target.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|code
operator|!=
name|UNKNOWN
condition|)
name|equiv_value
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|equiv_value
operator|=
literal|0
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* Synthesize double word shifts from single word shifts.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|lshr_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|||
name|binoptab
operator|==
name|ashr_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|!
name|optimize_size
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|shift_mask
decl_stmt|,
name|double_shift_mask
decl_stmt|;
name|enum
name|machine_mode
name|op1_mode
decl_stmt|;
name|double_shift_mask
operator|=
name|targetm
operator|.
name|shift_truncation_mask
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|shift_mask
operator|=
name|targetm
operator|.
name|shift_truncation_mask
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|op1_mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op1
argument_list|)
else|:
name|word_mode
expr_stmt|;
comment|/* Apply the truncation to constant shifts.  */
if|if
condition|(
name|double_shift_mask
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op1
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
name|double_shift_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|op1_mode
argument_list|)
condition|)
return|return
name|op0
return|;
comment|/* Make sure that this is a combination that expand_doubleword_shift 	 can handle.  See the comments there for details.  */
if|if
condition|(
name|double_shift_mask
operator|==
literal|0
operator|||
operator|(
name|shift_mask
operator|==
name|BITS_PER_WORD
operator|-
literal|1
operator|&&
name|double_shift_mask
operator|==
name|BITS_PER_WORD
operator|*
literal|2
operator|-
literal|1
operator|)
condition|)
block|{
name|rtx
name|insns
decl_stmt|,
name|equiv_value
decl_stmt|;
name|rtx
name|into_target
decl_stmt|,
name|outof_target
decl_stmt|;
name|rtx
name|into_input
decl_stmt|,
name|outof_input
decl_stmt|;
name|int
name|left_shift
decl_stmt|,
name|outof_word
decl_stmt|;
comment|/* If TARGET is the same as one of the operands, the REG_EQUAL note 	     won't be accurate, so use a new target.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* OUTOF_* is the word we are shifting bits away from, and 	     INTO_* is the word that we are shifting bits towards, thus 	     they differ depending on the direction of the shift and 	     WORDS_BIG_ENDIAN.  */
name|left_shift
operator|=
name|binoptab
operator|==
name|ashl_optab
expr_stmt|;
name|outof_word
operator|=
name|left_shift
operator|^
operator|!
name|WORDS_BIG_ENDIAN
expr_stmt|;
name|outof_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|outof_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_doubleword_shift
argument_list|(
name|op1_mode
argument_list|,
name|binoptab
argument_list|,
name|outof_input
argument_list|,
name|into_input
argument_list|,
name|op1
argument_list|,
name|outof_target
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|,
name|shift_mask
argument_list|)
condition|)
block|{
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|equiv_value
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|equiv_value
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Synthesize double word rotates from single word shifts.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|rotl_optab
operator|||
name|binoptab
operator|==
name|rotr_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|ashl_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|lshr_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|into_target
decl_stmt|,
name|outof_target
decl_stmt|;
name|rtx
name|into_input
decl_stmt|,
name|outof_input
decl_stmt|;
name|rtx
name|inter
decl_stmt|;
name|int
name|shift_count
decl_stmt|,
name|left_shift
decl_stmt|,
name|outof_word
decl_stmt|;
comment|/* If TARGET is the same as one of the operands, the REG_EQUAL note 	 won't be accurate, so use a new target. Do this also if target is not 	 a REG, first because having a register instead may open optimization 	 opportunities, and second because if target and op0 happen to be MEMs 	 designating the same location, we would risk clobbering it too early 	 in the code sequence we generate below.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
operator|||
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|shift_count
operator|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* OUTOF_* is the word we are shifting bits away from, and 	 INTO_* is the word that we are shifting bits towards, thus 	 they differ depending on the direction of the shift and 	 WORDS_BIG_ENDIAN.  */
name|left_shift
operator|=
operator|(
name|binoptab
operator|==
name|rotl_optab
operator|)
expr_stmt|;
name|outof_word
operator|=
name|left_shift
operator|^
operator|!
name|WORDS_BIG_ENDIAN
expr_stmt|;
name|outof_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_target
operator|=
name|operand_subword
argument_list|(
name|target
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|outof_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|into_input
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
literal|1
operator|-
name|outof_word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_count
operator|==
name|BITS_PER_WORD
condition|)
block|{
comment|/* This is just a word swap.  */
name|emit_move_insn
argument_list|(
name|outof_target
argument_list|,
name|into_input
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|into_target
argument_list|,
name|outof_input
argument_list|)
expr_stmt|;
name|inter
operator|=
name|const0_rtx
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|into_temp1
decl_stmt|,
name|into_temp2
decl_stmt|,
name|outof_temp1
decl_stmt|,
name|outof_temp2
decl_stmt|;
name|rtx
name|first_shift_count
decl_stmt|,
name|second_shift_count
decl_stmt|;
name|optab
name|reverse_unsigned_shift
decl_stmt|,
name|unsigned_shift
decl_stmt|;
name|reverse_unsigned_shift
operator|=
operator|(
name|left_shift
operator|^
operator|(
name|shift_count
operator|<
name|BITS_PER_WORD
operator|)
condition|?
name|lshr_optab
else|:
name|ashl_optab
operator|)
expr_stmt|;
name|unsigned_shift
operator|=
operator|(
name|left_shift
operator|^
operator|(
name|shift_count
operator|<
name|BITS_PER_WORD
operator|)
condition|?
name|ashl_optab
else|:
name|lshr_optab
operator|)
expr_stmt|;
if|if
condition|(
name|shift_count
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|first_shift_count
operator|=
name|GEN_INT
argument_list|(
name|shift_count
operator|-
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|second_shift_count
operator|=
name|GEN_INT
argument_list|(
literal|2
operator|*
name|BITS_PER_WORD
operator|-
name|shift_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first_shift_count
operator|=
name|GEN_INT
argument_list|(
name|BITS_PER_WORD
operator|-
name|shift_count
argument_list|)
expr_stmt|;
name|second_shift_count
operator|=
name|GEN_INT
argument_list|(
name|shift_count
argument_list|)
expr_stmt|;
block|}
name|into_temp1
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|unsigned_shift
argument_list|,
name|outof_input
argument_list|,
name|first_shift_count
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
name|into_temp2
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|reverse_unsigned_shift
argument_list|,
name|into_input
argument_list|,
name|second_shift_count
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|into_temp1
operator|!=
literal|0
operator|&&
name|into_temp2
operator|!=
literal|0
condition|)
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|into_temp1
argument_list|,
name|into_temp2
argument_list|,
name|into_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
else|else
name|inter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|into_target
condition|)
name|emit_move_insn
argument_list|(
name|into_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
name|outof_temp1
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|unsigned_shift
argument_list|,
name|into_input
argument_list|,
name|first_shift_count
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
name|outof_temp2
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|reverse_unsigned_shift
argument_list|,
name|outof_input
argument_list|,
name|second_shift_count
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|outof_temp1
operator|!=
literal|0
operator|&&
name|outof_temp2
operator|!=
literal|0
condition|)
name|inter
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|outof_temp1
argument_list|,
name|outof_temp2
argument_list|,
name|outof_target
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
operator|&&
name|inter
operator|!=
name|outof_target
condition|)
name|emit_move_insn
argument_list|(
name|outof_target
argument_list|,
name|inter
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|inter
operator|!=
literal|0
condition|)
block|{
comment|/* One may be tempted to wrap the insns in a REG_NO_CONFLICT 	     block to help the register allocator a bit.  But a multi-word 	     rotate will need all the input bits when setting the output 	     bits, so there clearly is a conflict between the input and 	     output registers.  So we can't use a no-conflict block here.  */
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* These can be done a word at a time by propagating carries.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|optab
name|otheroptab
init|=
name|binoptab
operator|==
name|add_optab
condition|?
name|sub_optab
else|:
name|add_optab
decl_stmt|;
specifier|const
name|unsigned
name|int
name|nwords
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|carry_in
init|=
name|NULL_RTX
decl_stmt|,
name|carry_out
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|xop0
decl_stmt|,
name|xop1
decl_stmt|,
name|xtarget
decl_stmt|;
comment|/* We can handle either a 1 or -1 value for the carry.  If STORE_FLAG 	 value is one of those, use it.  Otherwise, use 1 since it is the 	 one easiest to get.  */
if|#
directive|if
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
name|int
name|normalizep
init|=
name|STORE_FLAG_VALUE
decl_stmt|;
else|#
directive|else
name|int
name|normalizep
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* Prepare the operands.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|xop1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
name|xtarget
expr_stmt|;
comment|/* Indicate for flow that the entire target reg is being set.  */
if|if
condition|(
name|REG_P
argument_list|(
name|target
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|xtarget
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|xtarget
argument_list|,
name|index
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_piece
init|=
name|operand_subword_force
argument_list|(
name|xop0
argument_list|,
name|index
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1_piece
init|=
name|operand_subword_force
argument_list|(
name|xop1
argument_list|,
name|index
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Main add/subtract of the input operands.  */
name|x
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|binoptab
argument_list|,
name|op0_piece
argument_list|,
name|op1_piece
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nwords
condition|)
block|{
comment|/* Store carry from main add/subtract.  */
name|carry_out
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|carry_out
operator|=
name|emit_store_flag_force
argument_list|(
name|carry_out
argument_list|,
operator|(
name|binoptab
operator|==
name|add_optab
condition|?
name|LT
else|:
name|GT
operator|)
argument_list|,
name|x
argument_list|,
name|op0_piece
argument_list|,
name|word_mode
argument_list|,
literal|1
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|rtx
name|newx
decl_stmt|;
comment|/* Add/subtract previous carry to main result.  */
name|newx
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|normalizep
operator|==
literal|1
condition|?
name|binoptab
else|:
name|otheroptab
argument_list|,
name|x
argument_list|,
name|carry_in
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nwords
condition|)
block|{
comment|/* Get out carry from adding/subtracting carry in.  */
name|rtx
name|carry_tmp
init|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
decl_stmt|;
name|carry_tmp
operator|=
name|emit_store_flag_force
argument_list|(
name|carry_tmp
argument_list|,
operator|(
name|binoptab
operator|==
name|add_optab
condition|?
name|LT
else|:
name|GT
operator|)
argument_list|,
name|newx
argument_list|,
name|x
argument_list|,
name|word_mode
argument_list|,
literal|1
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
comment|/* Logical-ior the two poss. carry together.  */
name|carry_out
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|carry_out
argument_list|,
name|carry_tmp
argument_list|,
name|carry_out
argument_list|,
literal|0
argument_list|,
name|next_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|carry_out
operator|==
literal|0
condition|)
break|break;
block|}
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|newx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|!=
name|target_piece
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|carry_in
operator|=
name|carry_out
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
operator|(
name|unsigned
operator|)
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|xtarget
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|xtarget
argument_list|)
decl_stmt|;
name|set_unique_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|xop0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|xop1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|target
operator|=
name|xtarget
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* Attempt to synthesize double word multiplies using a sequence of word      mode multiplications.  We first attempt to generate a sequence using a      more efficient unsigned widening multiply, and if that fails we then      try using a signed widening multiply.  */
if|if
condition|(
name|binoptab
operator|==
name|smul_optab
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|&&
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|product
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|umul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|product
operator|=
name|expand_doubleword_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|true
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|product
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|product
operator|==
name|NULL_RTX
operator|&&
name|smul_widen_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|product
operator|=
name|expand_doubleword_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|false
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|product
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|product
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|temp
operator|=
name|emit_move_insn
argument_list|(
name|target
condition|?
name|target
else|:
name|product
argument_list|,
name|product
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|product
return|;
block|}
block|}
comment|/* It can't be open-coded in this mode.      Use a library call if one is available and caller says that's ok.  */
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|&&
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|)
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|op1x
init|=
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|op1_mode
init|=
name|mode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|shift_op
condition|)
block|{
name|op1_mode
operator|=
name|word_mode
expr_stmt|;
comment|/* Specify unsigned here, 	     since negative shift counts are meaningless.  */
name|op1x
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|mode
argument_list|,
literal|2
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
name|op1x
argument_list|,
name|op1_mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|binoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
operator|!
operator|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_LIB_WIDEN
operator|||
name|methods
operator|==
name|OPTAB_MUST_WIDEN
operator|)
condition|)
block|{
comment|/* Caller says, don't even try.  */
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Compute the value of METHODS to pass to recursive calls.      Don't allow widening to be tried recursively.  */
name|methods
operator|=
operator|(
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|?
name|OPTAB_LIB
else|:
name|OPTAB_DIRECT
operator|)
expr_stmt|;
comment|/* Look for a wider mode of the same class for which it appears we can do      the operation.  */
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
operator|(
name|methods
operator|==
name|OPTAB_LIB
operator|&&
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
name|int
name|no_extend
init|=
literal|0
decl_stmt|;
comment|/* For certain integer operations, we need not actually extend 		 the narrow operands, as long as we will truncate 		 the results to the same narrowness.  */
if|if
condition|(
operator|(
name|binoptab
operator|==
name|ior_optab
operator|||
name|binoptab
operator|==
name|and_optab
operator|||
name|binoptab
operator|==
name|xor_optab
operator|||
name|binoptab
operator|==
name|add_optab
operator|||
name|binoptab
operator|==
name|sub_optab
operator|||
name|binoptab
operator|==
name|smul_optab
operator|||
name|binoptab
operator|==
name|ashl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
condition|)
name|no_extend
operator|=
literal|1
expr_stmt|;
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
argument_list|)
expr_stmt|;
comment|/* The second operand of a shift must always be extended.  */
name|xop1
operator|=
name|widen_operand
argument_list|(
name|xop1
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|no_extend
operator|&&
name|binoptab
operator|!=
name|ashl_optab
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|binoptab
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
operator|||
operator|!
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a binary operator which has both signed and unsigned forms.    UOPTAB is the optab for unsigned operations, and SOPTAB is for    signed operations.     If we widen unsigned operands, we may use a signed wider operation instead    of an unsigned wider operation, since the result would be the same.  */
end_comment

begin_function
name|rtx
name|sign_expand_binop
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|optab
name|uoptab
parameter_list|,
name|optab
name|soptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|enum
name|optab_methods
name|methods
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|;
name|optab
name|direct_optab
init|=
name|unsignedp
condition|?
name|uoptab
else|:
name|soptab
decl_stmt|;
name|struct
name|optab
name|wide_soptab
decl_stmt|;
comment|/* Do it without widening, if possible.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_DIRECT
condition|)
return|return
name|temp
return|;
comment|/* Try widening to a signed int.  Make a fake signed optab that      hides any signed insn for direct use.  */
name|wide_soptab
operator|=
operator|*
name|soptab
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|wide_soptab
operator|.
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
comment|/* For unsigned operands, try widening to an unsigned int.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|unsignedp
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_WIDEN
condition|)
return|return
name|temp
return|;
comment|/* Use the right width lib call if that exists.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|direct_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|||
name|methods
operator|==
name|OPTAB_LIB
condition|)
return|return
name|temp
return|;
comment|/* Must widen and use a lib call, use either signed or unsigned.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|&
name|wide_soptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
if|if
condition|(
name|unsignedp
condition|)
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|uoptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by UNOPPTAB    on operand OP0, with two results to TARG0 and TARG1.    We assume that the order of the operands for the instruction    is TARG0, TARG1, OP0.     Either TARG0 or TARG1 may be zero, but what that means is that    the result is not actually wanted.  We will generate it into    a dummy pseudo-reg and discard it.  They may not both be zero.     Returns 1 if this operation can be performed; 0 if not.  */
end_comment

begin_function
name|int
name|expand_twoval_unop
parameter_list|(
name|optab
name|unoptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|targ0
parameter_list|,
name|rtx
name|targ1
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|targ0
condition|?
name|targ0
else|:
name|targ1
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targ0
condition|)
name|targ0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targ1
condition|)
name|targ1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Record where to go back to if we fail.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept these operands, put them into pseudos.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
comment|/* We could handle this, but we should always be called with a pseudo 	 for our targets and all insns should take them as outputs.  */
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|targ0
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|targ1
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|targ0
argument_list|,
name|targ1
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|t0
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
name|rtx
name|t1
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
name|rtx
name|cop0
init|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
if|if
condition|(
name|expand_twoval_unop
argument_list|(
name|unoptab
argument_list|,
name|cop0
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
condition|)
block|{
name|convert_move
argument_list|(
name|targ0
argument_list|,
name|t0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|targ1
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to perform an operation specified by BINOPTAB    on operands OP0 and OP1, with two results to TARG1 and TARG2.    We assume that the order of the operands for the instruction    is TARG0, OP0, OP1, TARG1, which would fit a pattern like    [(set TARG0 (operate OP0 OP1)) (set TARG1 (operate ...))].     Either TARG0 or TARG1 may be zero, but what that means is that    the result is not actually wanted.  We will generate it into    a dummy pseudo-reg and discard it.  They may not both be zero.     Returns 1 if this operation can be performed; 0 if not.  */
end_comment

begin_function
name|int
name|expand_twoval_binop
parameter_list|(
name|optab
name|binoptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|targ0
parameter_list|,
name|rtx
name|targ1
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|targ0
condition|?
name|targ0
else|:
name|targ1
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|entry_last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If we are inside an appropriately-short loop and we are optimizing,      force expensive constants into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|optimize
operator|&&
name|rtx_cost
argument_list|(
name|op0
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|optimize
operator|&&
name|rtx_cost
argument_list|(
name|op1
argument_list|,
name|binoptab
operator|->
name|code
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targ0
condition|)
name|targ0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targ1
condition|)
name|targ1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Record where to go back to if we fail.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|;
comment|/* In case the insn wants input operands in modes different from 	 those of the actual operands, convert the operands.  It would 	 seem that we don't need to convert CONST_INTs, but we do, so 	 that they're properly zero-extended, sign-extended or truncated 	 for their mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|mode0
operator|!=
name|VOIDmode
condition|)
name|xop0
operator|=
name|convert_modes
argument_list|(
name|mode0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|mode
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|mode1
operator|!=
name|VOIDmode
condition|)
name|xop1
operator|=
name|convert_modes
argument_list|(
name|mode1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op1
argument_list|)
else|:
name|mode
argument_list|,
name|xop1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept these operands, put them into pseudos.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|xop1
argument_list|,
name|mode1
argument_list|)
condition|)
name|xop1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
comment|/* We could handle this, but we should always be called with a pseudo 	 for our targets and all insns should take them as outputs.  */
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|targ0
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
argument_list|(
name|targ1
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|targ0
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|,
name|targ1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|t0
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
name|rtx
name|t1
init|=
name|gen_reg_rtx
argument_list|(
name|wider_mode
argument_list|)
decl_stmt|;
name|rtx
name|cop0
init|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|rtx
name|cop1
init|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|binoptab
argument_list|,
name|cop0
argument_list|,
name|cop1
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
condition|)
block|{
name|convert_move
argument_list|(
name|targ0
argument_list|,
name|t0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|targ1
argument_list|,
name|t1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delete_insns_since
argument_list|(
name|entry_last
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand the two-valued library call indicated by BINOPTAB, but    preserve only one of the values.  If TARG0 is non-NULL, the first    value is placed into TARG0; otherwise the second value is placed    into TARG1.  Exactly one of TARG0 and TARG1 must be non-NULL.  The    value stored into TARG0 or TARG1 is equivalent to (CODE OP0 OP1).    This routine assumes that the value returned by the library call is    as if the return value was of an integral mode twice as wide as the    mode of OP0.  Returns 1 if the call was successful.  */
end_comment

begin_function
name|bool
name|expand_twoval_binop_libfunc
parameter_list|(
name|optab
name|binoptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|targ0
parameter_list|,
name|rtx
name|targ1
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|libval_mode
decl_stmt|;
name|rtx
name|libval
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
comment|/* Exactly one of TARG0 or TARG1 should be non-NULL.  */
name|gcc_assert
argument_list|(
operator|!
name|targ0
operator|!=
operator|!
name|targ1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
return|return
name|false
return|;
comment|/* The value returned by the library function will have twice as      many bits as the nominal MODE.  */
name|libval_mode
operator|=
name|smallest_mode_for_size
argument_list|(
literal|2
operator|*
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|libval
operator|=
name|emit_library_call_value
argument_list|(
name|binoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|libval_mode
argument_list|,
literal|2
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Get the part of VAL containing the value that we want.  */
name|libval
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|libval
argument_list|,
name|libval_mode
argument_list|,
name|targ0
condition|?
literal|0
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Move the into the desired location.  */
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|targ0
condition|?
name|targ0
else|:
name|targ1
argument_list|,
name|libval
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wrapper around expand_unop which takes an rtx code to specify    the operation to perform, not an optab pointer.  All other    arguments are the same.  */
end_comment

begin_function
name|rtx
name|expand_simple_unop
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|optab
name|unop
init|=
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|unop
argument_list|)
expr_stmt|;
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|unop
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try calculating 	(clz:narrow x)    as 	(clz:wide (zero_extend:wide x)) - ((width wide) - (width narrow)).  */
end_comment

begin_function
specifier|static
name|rtx
name|widen_clz
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|clz_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|xop0
decl_stmt|,
name|temp
decl_stmt|,
name|last
decl_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|xop0
operator|=
name|widen_operand
argument_list|(
name|op0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|clz_optab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|sub_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|true
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try calculating (parity x) as (and (popcount x) 1), where    popcount can also be done in a wider mode.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_parity
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
for|for
control|(
name|wider_mode
operator|=
name|mode
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|popcount_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|xop0
decl_stmt|,
name|temp
decl_stmt|,
name|last
decl_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|xop0
operator|=
name|widen_operand
argument_list|(
name|op0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|popcount_optab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|and_optab
argument_list|,
name|temp
argument_list|,
name|const1_rtx
argument_list|,
name|target
argument_list|,
name|true
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Extract the OMODE lowpart from VAL, which has IMODE.  Under certain    conditions, VAL may already be a SUBREG against which we cannot generate    a further SUBREG.  In this case, we expect forcing the value into a    register will work around the situation.  */
end_comment

begin_function
specifier|static
name|rtx
name|lowpart_subreg_maybe_copy
parameter_list|(
name|enum
name|machine_mode
name|omode
parameter_list|,
name|rtx
name|val
parameter_list|,
name|enum
name|machine_mode
name|imode
parameter_list|)
block|{
name|rtx
name|ret
decl_stmt|;
name|ret
operator|=
name|lowpart_subreg
argument_list|(
name|omode
argument_list|,
name|val
argument_list|,
name|imode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
name|force_reg
argument_list|(
name|imode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lowpart_subreg
argument_list|(
name|omode
argument_list|,
name|val
argument_list|,
name|imode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand a floating point absolute value or negation operation via a    logical operation on the sign bit.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_absneg_bit
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|word
decl_stmt|,
name|nwords
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|imode
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|insns
decl_stmt|;
comment|/* The format has to have a simple sign bit.  */
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
return|return
name|NULL_RTX
return|;
name|bitpos
operator|=
name|fmt
operator|->
name|signbit_rw
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Don't create negative zeros if the format doesn't support them.  */
if|if
condition|(
name|code
operator|==
name|NEG
operator|&&
operator|!
name|fmt
operator|->
name|has_signed_zero
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|imode
operator|=
name|int_mode_for_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
return|return
name|NULL_RTX
return|;
name|word
operator|=
literal|0
expr_stmt|;
name|nwords
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|imode
operator|=
name|word_mode
expr_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitpos
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
else|else
name|word
operator|=
name|bitpos
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|bitpos
operator|=
name|bitpos
operator|%
name|BITS_PER_WORD
expr_stmt|;
name|nwords
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitpos
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|ABS
condition|)
name|lo
operator|=
operator|~
name|lo
operator|,
name|hi
operator|=
operator|~
name|hi
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwords
operator|>
literal|1
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|targ_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_piece
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|word
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|code
operator|==
name|ABS
condition|?
name|and_optab
else|:
name|xor_optab
argument_list|,
name|op0_piece
argument_list|,
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|imode
argument_list|)
argument_list|,
name|targ_piece
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|targ_piece
condition|)
name|emit_move_insn
argument_list|(
name|targ_piece
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|targ_piece
argument_list|,
name|op0_piece
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|temp
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|code
operator|==
name|ABS
condition|?
name|and_optab
else|:
name|xor_optab
argument_list|,
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|imode
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|target
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|target
operator|=
name|lowpart_subreg_maybe_copy
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|imode
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Generate code to perform an operation specified by UNOPTAB    on operand OP0, with result having machine-mode MODE.     UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     If TARGET is nonzero, the value    is generated there, if it is convenient to do so.    In all cases an rtx is returned for the locus of the value;    this may or may not be TARGET.  */
end_comment

begin_function
name|rtx
name|expand_unop
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|optab
name|unoptab
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|enum
name|mode_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|class
operator|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
if|if
condition|(
name|target
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|mode0
condition|)
name|xop0
operator|=
name|convert_to_mode
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* Now, if insn doesn't accept our operand, put it into a pseudo.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|xop0
argument_list|,
name|mode0
argument_list|)
condition|)
name|xop0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|temp
argument_list|,
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|pat
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|pat
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|unoptab
operator|->
name|code
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|unoptab
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* It can't be done in this mode.  Can we open-code it in a wider mode?  */
comment|/* Widening clz needs special treatment.  */
if|if
condition|(
name|unoptab
operator|==
name|clz_optab
condition|)
block|{
name|temp
operator|=
name|widen_clz
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
else|else
goto|goto
name|try_libcall
goto|;
block|}
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
comment|/* For certain operations, we need not actually extend 	       the narrow operand, as long as we will truncate the 	       results to the same narrowness.  */
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
operator|(
name|unoptab
operator|==
name|neg_optab
operator|||
name|unoptab
operator|==
name|one_cmpl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|unoptab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
operator|||
operator|!
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* These can be done a word at a time.  */
if|if
condition|(
name|unoptab
operator|==
name|one_cmpl_optab
operator|&&
name|class
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|word_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Do the actual arithmetic.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|BITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|target_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|expand_unop
argument_list|(
name|word_mode
argument_list|,
name|unoptab
argument_list|,
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|target_piece
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_piece
operator|!=
name|x
condition|)
name|emit_move_insn
argument_list|(
name|target_piece
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|unoptab
operator|->
name|code
operator|==
name|NEG
condition|)
block|{
comment|/* Try negating floating point values by flipping the sign bit.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expand_absneg_bit
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
comment|/* If there is no negation pattern, and we have no negative zero, 	 try subtracting from zero.  */
if|if
condition|(
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
operator|(
name|unoptab
operator|==
name|negv_optab
condition|?
name|subv_optab
else|:
name|sub_optab
operator|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
block|}
comment|/* Try calculating parity (x) as popcount (x) % 2.  */
if|if
condition|(
name|unoptab
operator|==
name|parity_optab
condition|)
block|{
name|temp
operator|=
name|expand_parity
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
name|try_libcall
label|:
comment|/* Now try a library call in this mode.  */
if|if
condition|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|enum
name|machine_mode
name|outmode
init|=
name|mode
decl_stmt|;
comment|/* All of these functions return small values.  Thus we choose to 	 have them return something that isn't a double-word.  */
if|if
condition|(
name|unoptab
operator|==
name|ffs_optab
operator|||
name|unoptab
operator|==
name|clz_optab
operator|||
name|unoptab
operator|==
name|ctz_optab
operator|||
name|unoptab
operator|==
name|popcount_optab
operator|||
name|unoptab
operator|==
name|parity_optab
condition|)
name|outmode
operator|=
name|GET_MODE
argument_list|(
name|hard_libcall_value
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Pass 1 for NO_QUEUE so we don't lose any increments 	 if the libcall is cse'd or moved.  */
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|outmode
argument_list|,
literal|1
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|outmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|unoptab
operator|->
name|code
argument_list|,
name|outmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* It can't be done in this mode.  Can we do it in a wider mode?  */
if|if
condition|(
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
for|for
control|(
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
init|;
name|wider_mode
operator|!=
name|VOIDmode
condition|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|||
name|unoptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|libfunc
condition|)
block|{
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
comment|/* For certain operations, we need not actually extend 		 the narrow operand, as long as we will truncate the 		 results to the same narrowness.  */
name|xop0
operator|=
name|widen_operand
argument_list|(
name|xop0
argument_list|,
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
operator|(
name|unoptab
operator|==
name|neg_optab
operator|||
name|unoptab
operator|==
name|one_cmpl_optab
operator|)
operator|&&
name|class
operator|==
name|MODE_INT
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|wider_mode
argument_list|,
name|unoptab
argument_list|,
name|xop0
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* If we are generating clz using wider mode, adjust the 		 result.  */
if|if
condition|(
name|unoptab
operator|==
name|clz_optab
operator|&&
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|sub_optab
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|true
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|)
return|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* One final attempt at implementing negation via subtraction,      this time allowing widening of the operand.  */
if|if
condition|(
name|unoptab
operator|->
name|code
operator|==
name|NEG
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|unoptab
operator|==
name|negv_optab
condition|?
name|subv_optab
else|:
name|sub_optab
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to compute the absolute value of OP0, with result to    TARGET if convenient.  (TARGET may be 0.)  The return value says    where the result actually is to be found.     MODE is the mode of the operand; the mode of the result is    different but can be deduced from MODE.   */
end_comment

begin_function
name|rtx
name|expand_abs_nojump
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|result_unsignedp
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|flag_trapv
condition|)
name|result_unsignedp
operator|=
literal|1
expr_stmt|;
comment|/* First try to do it with a special abs instruction.  */
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|result_unsignedp
condition|?
name|abs_optab
else|:
name|absv_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* For floating point modes, try clearing the sign bit.  */
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expand_absneg_bit
argument_list|(
name|ABS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
comment|/* If we have a MAX insn, we can do this as MAX (x, -x).  */
if|if
condition|(
name|smax_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|!
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|temp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smax_optab
argument_list|,
name|op0
argument_list|,
name|temp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine has expensive jumps, we can do integer absolute      value of X as (((signed) x>> (W-1)) ^ x) - ((signed) x>> (W-1)),      where W is the width of MODE.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|BRANCH_COST
operator|>=
literal|2
condition|)
block|{
name|rtx
name|extended
init|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|extended
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|result_unsignedp
condition|?
name|sub_optab
else|:
name|subv_optab
argument_list|,
name|temp
argument_list|,
name|extended
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|rtx
name|expand_abs
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|result_unsignedp
parameter_list|,
name|int
name|safe
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
operator|!
name|flag_trapv
condition|)
name|result_unsignedp
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|expand_abs_nojump
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
name|result_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* If that does not win, use conditional jump and negate.  */
comment|/* It is safe to use the target if it is the same      as the source if this is also a pseudo register */
if|if
condition|(
name|op0
operator|==
name|target
operator|&&
name|REG_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|safe
operator|=
literal|1
expr_stmt|;
name|op1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|safe
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
operator|||
operator|(
name|MEM_P
argument_list|(
name|target
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|target
argument_list|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|NO_DEFER_POP
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|result_unsignedp
condition|?
name|neg_optab
else|:
name|negv_optab
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|OK_DEFER_POP
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_copysign, perform the copysign operation using the    abs and neg primitives advertised to exist on the target.  The assumption    is that we have a split register file, and leaving op0 in fp registers,    and not playing with subregs so much, will help the register allocator.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_copysign_absneg
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|bool
name|op0_is_abs
parameter_list|)
block|{
name|enum
name|machine_mode
name|imode
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|int
name|word
decl_stmt|;
name|rtx
name|label
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|op0_is_abs
condition|)
block|{
name|op0
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|abs_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|NULL
condition|)
return|return
name|NULL_RTX
return|;
name|target
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|==
name|NULL_RTX
condition|)
name|target
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|imode
operator|=
name|int_mode_for_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
return|return
name|NULL_RTX
return|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imode
operator|=
name|word_mode
expr_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitpos
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
else|else
name|word
operator|=
name|bitpos
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|bitpos
operator|=
name|bitpos
operator|%
name|BITS_PER_WORD
expr_stmt|;
name|op1
operator|=
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|word
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitpos
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
block|}
name|op1
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|and_optab
argument_list|,
name|op1
argument_list|,
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|imode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|op1
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|imode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|op0
operator|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_copysign, perform the entire copysign operation    with integer bitmasks.  BITPOS is the position of the sign bit; OP0_IS_ABS    is true if op0 is known to have its sign bit clear.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_copysign_bit
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|bool
name|op0_is_abs
parameter_list|)
block|{
name|enum
name|machine_mode
name|imode
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|int
name|word
decl_stmt|,
name|nwords
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|insns
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
block|{
name|imode
operator|=
name|int_mode_for_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|==
name|BLKmode
condition|)
return|return
name|NULL_RTX
return|;
name|word
operator|=
literal|0
expr_stmt|;
name|nwords
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|imode
operator|=
name|word_mode
expr_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
name|word
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitpos
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
else|else
name|word
operator|=
name|bitpos
operator|/
name|BITS_PER_WORD
expr_stmt|;
name|bitpos
operator|=
name|bitpos
operator|%
name|BITS_PER_WORD
expr_stmt|;
name|nwords
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
block|}
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|hi
operator|=
literal|0
expr_stmt|;
name|lo
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitpos
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|target
operator|==
name|op0
operator|||
name|target
operator|==
name|op1
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwords
operator|>
literal|1
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|targ_piece
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0_piece
init|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|word
condition|)
block|{
if|if
condition|(
operator|!
name|op0_is_abs
condition|)
name|op0_piece
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|and_optab
argument_list|,
name|op0_piece
argument_list|,
name|immed_double_const
argument_list|(
operator|~
name|lo
argument_list|,
operator|~
name|hi
argument_list|,
name|imode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|and_optab
argument_list|,
name|operand_subword_force
argument_list|(
name|op1
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
argument_list|,
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|imode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|ior_optab
argument_list|,
name|op0_piece
argument_list|,
name|op1
argument_list|,
name|targ_piece
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|targ_piece
condition|)
name|emit_move_insn
argument_list|(
name|targ_piece
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|targ_piece
argument_list|,
name|op0_piece
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_no_conflict_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|and_optab
argument_list|,
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|op1
argument_list|)
argument_list|,
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|imode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0_is_abs
condition|)
name|op0
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|immed_double_const
argument_list|(
operator|~
name|lo
argument_list|,
operator|~
name|hi
argument_list|,
name|imode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|ior_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|gen_lowpart
argument_list|(
name|imode
argument_list|,
name|target
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|target
operator|=
name|lowpart_subreg_maybe_copy
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|imode
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand the C99 copysign operation.  OP0 and OP1 must be the same    scalar floating point mode.  Return NULL if we do not know how to    expand the operation inline.  */
end_comment

begin_function
name|rtx
name|expand_copysign
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|bool
name|op0_is_abs
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|gcc_assert
argument_list|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode
argument_list|)
expr_stmt|;
comment|/* First try to do it with a special instruction.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|copysign_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
operator|||
operator|!
name|fmt
operator|->
name|has_signed_zero
condition|)
return|return
name|NULL_RTX
return|;
name|op0_is_abs
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|real_isneg
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|op0
operator|=
name|simplify_unary_operation
argument_list|(
name|ABS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|op0_is_abs
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|fmt
operator|->
name|signbit_ro
operator|>=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
operator|(
name|neg_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|abs_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
name|temp
operator|=
name|expand_copysign_absneg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|fmt
operator|->
name|signbit_ro
argument_list|,
name|op0_is_abs
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|fmt
operator|->
name|signbit_rw
operator|<
literal|0
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|expand_copysign_bit
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|fmt
operator|->
name|signbit_rw
argument_list|,
name|op0_is_abs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an instruction whose insn-code is INSN_CODE,    with two operands: an output TARGET and an input OP0.    TARGET *must* be nonzero, and the output is always stored there.    CODE is an rtx code such that (CODE OP0) is an rtx that describes    the value that is stored into TARGET.  */
end_comment

begin_function
name|void
name|emit_unop_insn
parameter_list|(
name|int
name|icode
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|rtx
name|temp
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|temp
operator|=
name|target
expr_stmt|;
comment|/* Now, if insn does not accept our operands, put them into pseudos.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|temp
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|temp
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|pat
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|pat
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|code
operator|!=
name|UNKNOWN
condition|)
name|add_equal_note
argument_list|(
name|pat
argument_list|,
name|temp
argument_list|,
name|code
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|no_conflict_data
block|{
name|rtx
name|target
decl_stmt|,
name|first
decl_stmt|,
name|insn
decl_stmt|;
name|bool
name|must_stay
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called via note_stores by emit_no_conflict_block and emit_libcall_block.    Set P->must_stay if the currently examined clobber / store has to stay    in the list of insns that constitute the actual no_conflict block /    libcall block.  */
end_comment

begin_function
specifier|static
name|void
name|no_conflict_move_test
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|set
parameter_list|,
name|void
modifier|*
name|p0
parameter_list|)
block|{
name|struct
name|no_conflict_data
modifier|*
name|p
init|=
name|p0
decl_stmt|;
comment|/* If this inns directly contributes to setting the target, it must stay.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|p
operator|->
name|target
argument_list|,
name|dest
argument_list|)
condition|)
name|p
operator|->
name|must_stay
operator|=
name|true
expr_stmt|;
comment|/* If we haven't committed to keeping any other insns in the list yet,      there is nothing more to check.  */
elseif|else
if|if
condition|(
name|p
operator|->
name|insn
operator|==
name|p
operator|->
name|first
condition|)
return|return;
comment|/* If this insn sets / clobbers a register that feeds one of the insns      already in the list, this insn has to stay too.  */
elseif|else
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|p
operator|->
name|first
argument_list|)
argument_list|)
operator|||
operator|(
name|CALL_P
argument_list|(
name|p
operator|->
name|first
argument_list|)
operator|&&
operator|(
name|find_reg_fusage
argument_list|(
name|p
operator|->
name|first
argument_list|,
name|USE
argument_list|,
name|dest
argument_list|)
operator|)
operator|)
operator|||
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|p
operator|->
name|first
argument_list|,
name|p
operator|->
name|insn
argument_list|)
comment|/* Likewise if this insn depends on a register set by a previous 	      insn in the list, or if it sets a result (presumably a hard 	      register) that is set or clobbered by a previous insn. 	      N.B. the modified_*_p (SET_DEST...) tests applied to a MEM 	      SET_DEST perform the former check on the address, and the latter 	      check on the MEM.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|modified_in_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|p
operator|->
name|first
argument_list|)
operator|||
name|modified_in_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|p
operator|->
name|first
argument_list|)
operator|||
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|p
operator|->
name|first
argument_list|,
name|p
operator|->
name|insn
argument_list|)
operator|||
name|modified_between_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|p
operator|->
name|first
argument_list|,
name|p
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
name|p
operator|->
name|must_stay
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encapsulate the block starting at FIRST and ending with LAST, which is    logically equivalent to EQUIV, so it gets manipulated as a unit if it    is possible to do so.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_encapsulate_block
parameter_list|(
name|rtx
name|first
parameter_list|,
name|rtx
name|last
parameter_list|,
name|rtx
name|equiv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_non_call_exceptions
operator|||
operator|!
name|may_trap_p
argument_list|(
name|equiv
argument_list|)
condition|)
block|{
comment|/* We can't attach the REG_LIBCALL and REG_RETVAL notes when the 	 encapsulated region would not be in one basic block, i.e. when 	 there is a control_flow_insn_p insn between FIRST and LAST.  */
name|bool
name|attach_libcall_retval_notes
init|=
name|true
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
init|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|next
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|attach_libcall_retval_notes
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|attach_libcall_retval_notes
condition|)
block|{
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LIBCALL
argument_list|,
name|last
argument_list|,
name|REG_NOTES
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_RETVAL
argument_list|,
name|first
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Emit code to perform a series of operations on a multi-word quantity, one    word at a time.     Such a block is preceded by a CLOBBER of the output, consists of multiple    insns, each setting one word of the output, and followed by a SET copying    the output to itself.     Each of the insns setting words of the output receives a REG_NO_CONFLICT    note indicating that it doesn't conflict with the (also multi-word)    inputs.  The entire block is surrounded by REG_LIBCALL and REG_RETVAL    notes.     INSNS is a block of code generated to perform the operation, not including    the CLOBBER and final copy.  All insns that compute intermediate values    are first emitted, followed by the block as described above.     TARGET, OP0, and OP1 are the output and inputs of the operations,    respectively.  OP1 may be zero for a unary operation.     EQUIV, if nonzero, is an expression to be placed into a REG_EQUAL note    on the last insn.     If TARGET is not a register, INSNS is simply emitted with no special    processing.  Likewise if anything in INSNS is not an INSN or if    there is a libcall block inside INSNS.     The final insn emitted is returned.  */
end_comment

begin_function
name|rtx
name|emit_no_conflict_block
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|equiv
parameter_list|)
block|{
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|reload_in_progress
condition|)
return|return
name|emit_insn
argument_list|(
name|insns
argument_list|)
return|;
else|else
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|!
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
name|emit_insn
argument_list|(
name|insns
argument_list|)
return|;
comment|/* First emit all insns that do not store into words of the output and remove      these from the list.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|note
decl_stmt|;
name|struct
name|no_conflict_data
name|data
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Some ports (cris) create a libcall regions at their own.  We must 	 avoid any potential nesting of LIBCALLs.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|data
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|data
operator|.
name|first
operator|=
name|insns
expr_stmt|;
name|data
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|data
operator|.
name|must_stay
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|no_conflict_move_test
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|must_stay
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|insns
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Now write the CLOBBER of the output, followed by the setting of each      of the words, followed by the final copy.  */
if|if
condition|(
name|target
operator|!=
name|op0
operator|&&
name|target
operator|!=
name|op1
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NO_CONFLICT
argument_list|,
name|op1
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|&&
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NO_CONFLICT
argument_list|,
name|op0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|target
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|last
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|equiv
condition|)
name|set_unique_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Remove any existing REG_EQUAL note from "last", or else it will 	 be mistaken for a note referring to the full contents of the 	 alleged libcall value when found together with the REG_RETVAL 	 note added below.  An existing note can come from an insn 	 expansion at "last".  */
name|remove_note
argument_list|(
name|last
argument_list|,
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|maybe_encapsulate_block
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to make a call to a constant function or a library call.     INSNS is a list containing all insns emitted in the call.    These insns leave the result in RESULT.  Our block is to copy RESULT    to TARGET, which is logically equivalent to EQUIV.     We first emit any insns that set a pseudo on the assumption that these are    loading constants into registers; doing so allows them to be safely cse'ed    between blocks.  Then we emit all the other insns in the block, followed by    an insn to move RESULT to TARGET.  This last insn will have a REQ_EQUAL    note with an operand of EQUIV.     Moving assignments to pseudos outside of the block is done to improve    the generated code, but is not required to generate correct code,    hence being unable to move an assignment is not grounds for not making    a libcall block.  There are two reasons why it is safe to leave these    insns inside the block: First, we know that these pseudos cannot be    used in generated RTL outside the block since they are created for    temporary purposes within the block.  Second, CSE will not record the    values of anything set inside a libcall block, so we know they must    be dead at the end of the block.     Except for the first group of insns (the ones setting pseudos), the    block is delimited by REG_RETVAL and REG_LIBCALL notes.  */
end_comment

begin_function
name|void
name|emit_libcall_block
parameter_list|(
name|rtx
name|insns
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|result
parameter_list|,
name|rtx
name|equiv
parameter_list|)
block|{
name|rtx
name|final_dest
init|=
name|target
decl_stmt|;
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|insn
decl_stmt|;
comment|/* If this is a reg with REG_USERVAR_P set, then it could possibly turn      into a MEM later.  Protect the libcall block from this change.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|REG_USERVAR_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're using non-call exceptions, a libcall corresponding to an      operation that may trap may also trap.  */
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|equiv
argument_list|)
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|!=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* look for any CALL_INSNs in this sequence, and attach a REG_EH_REGION      reg note to indicate that this call cannot throw or execute a nonlocal      goto (unless there is already a REG_EH_REGION note, in which case      we update it).  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|!=
literal|0
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|constm1_rtx
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|constm1_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* First emit all insns that set pseudos.  Remove them from the list as      we go.  Avoid insns that set pseudos which were referenced in previous      insns.  These can be generated by move_by_pieces, for example,      to update an address.  Similarly, avoid insns that reference things      set in previous insns.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Some ports (cris) create a libcall regions at their own.  We must 	 avoid any potential nesting of LIBCALLs.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|struct
name|no_conflict_data
name|data
decl_stmt|;
name|data
operator|.
name|target
operator|=
name|const0_rtx
expr_stmt|;
name|data
operator|.
name|first
operator|=
name|insns
expr_stmt|;
name|data
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|data
operator|.
name|must_stay
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|no_conflict_move_test
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|must_stay
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|insns
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Some ports use a loop to copy large arguments onto the stack. 	 Don't move anything outside such a loop.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
name|prev
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Write the remaining insns followed by the final copy.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|target
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|set_unique_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_rtx
argument_list|(
name|equiv
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Remove any existing REG_EQUAL note from "last", or else it will 	 be mistaken for a note referring to the full contents of the 	 libcall value when found together with the REG_RETVAL note added 	 below.  An existing note can come from an insn expansion at 	 "last".  */
name|remove_note
argument_list|(
name|last
argument_list|,
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|final_dest
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|final_dest
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|first
operator|=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|maybe_encapsulate_block
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we can perform a comparison of mode MODE straightforwardly.    PURPOSE describes how this comparison will be used.  CODE is the rtx    comparison code we will be using.     ??? Actually, CODE is slightly weaker than that.  A target is still    required to implement all of the normal bcc operations, but not    required to implement all (or any) of the unordered bcc operations.  */
end_comment

begin_function
name|int
name|can_compare_p
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|can_compare_purpose
name|purpose
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|purpose
operator|==
name|ccp_jump
condition|)
return|return
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|!=
name|NULL
return|;
elseif|else
if|if
condition|(
name|purpose
operator|==
name|ccp_store_flag
condition|)
return|return
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|!=
name|CODE_FOR_nothing
return|;
else|else
comment|/* There's only one cmov entry point, and it's allowed to fail.  */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|purpose
operator|==
name|ccp_jump
operator|&&
name|cbranch_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|purpose
operator|==
name|ccp_cmov
operator|&&
name|cmov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|purpose
operator|==
name|ccp_store_flag
operator|&&
name|cstore_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function is called when we are going to emit a compare instruction that    compares the values found in *PX and *PY, using the rtl operator COMPARISON.     *PMODE is the mode of the inputs (in case they are const_int).    *PUNSIGNEDP nonzero says that the operands are unsigned;    this matters if they need to be widened.     If they have mode BLKmode, then SIZE specifies the size of both operands.     This function performs all the setup necessary so that the caller only has    to emit a single comparison insn.  This setup can involve doing a BLKmode    comparison or emitting a library call to perform the comparison if no insn    is available to handle it.    The values which are passed in through pointers can be modified; the caller    should perform the comparison on the modified values.  Constant    comparisons must have already been folded.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_cmp_insn
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|rtx
modifier|*
name|py
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|pcomparison
parameter_list|,
name|rtx
name|size
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode
parameter_list|,
name|int
modifier|*
name|punsignedp
parameter_list|,
name|enum
name|can_compare_purpose
name|purpose
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
operator|*
name|pmode
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|,
name|y
init|=
operator|*
name|py
decl_stmt|;
name|int
name|unsignedp
init|=
operator|*
name|punsignedp
decl_stmt|;
comment|/* If we are inside an appropriately-short loop and we are optimizing,      force expensive constants into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|optimize
operator|&&
name|rtx_cost
argument_list|(
name|x
argument_list|,
name|COMPARE
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
operator|&&
name|optimize
operator|&&
name|rtx_cost
argument_list|(
name|y
argument_list|,
name|COMPARE
argument_list|)
operator|>
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
condition|)
name|y
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Make sure if we have a canonical comparison.  The RTL      documentation states that canonical comparisons are required only      for targets which have cc0.  */
name|gcc_assert
argument_list|(
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't let both operands fail to indicate the mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|VOIDmode
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Handle all BLKmode compares.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|enum
name|machine_mode
name|cmp_mode
decl_stmt|,
name|result_mode
decl_stmt|;
name|enum
name|insn_code
name|cmp_code
decl_stmt|;
name|tree
name|length_type
decl_stmt|;
name|rtx
name|libfunc
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|rtx
name|opalign
init|=
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Try to use a memory block compare insn - either cmpstr 	 or cmpmem will do.  */
for|for
control|(
name|cmp_mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|cmp_mode
operator|!=
name|VOIDmode
condition|;
name|cmp_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|cmp_mode
argument_list|)
control|)
block|{
name|cmp_code
operator|=
name|cmpmem_optab
index|[
name|cmp_mode
index|]
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|==
name|CODE_FOR_nothing
condition|)
name|cmp_code
operator|=
name|cmpstr_optab
index|[
name|cmp_mode
index|]
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|==
name|CODE_FOR_nothing
condition|)
name|cmp_code
operator|=
name|cmpstrn_optab
index|[
name|cmp_mode
index|]
expr_stmt|;
if|if
condition|(
name|cmp_code
operator|==
name|CODE_FOR_nothing
condition|)
continue|continue;
comment|/* Must make sure the size fits the insn's mode.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|cmp_mode
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|cmp_mode
argument_list|)
operator|)
condition|)
continue|continue;
name|result_mode
operator|=
name|insn_data
index|[
name|cmp_code
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|result_mode
argument_list|)
expr_stmt|;
name|size
operator|=
name|convert_to_mode
argument_list|(
name|cmp_mode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|cmp_code
argument_list|)
argument_list|(
name|result
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|size
argument_list|,
name|opalign
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|result
expr_stmt|;
operator|*
name|py
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|pmode
operator|=
name|result_mode
expr_stmt|;
return|return;
block|}
comment|/* Otherwise call a library function, memcmp.  */
name|libfunc
operator|=
name|memcmp_libfunc
expr_stmt|;
name|length_type
operator|=
name|sizetype
expr_stmt|;
name|result_mode
operator|=
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|cmp_mode
operator|=
name|TYPE_MODE
argument_list|(
name|length_type
argument_list|)
expr_stmt|;
name|size
operator|=
name|convert_to_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|length_type
argument_list|)
argument_list|,
name|size
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|length_type
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|emit_library_call_value
argument_list|(
name|libfunc
argument_list|,
literal|0
argument_list|,
name|LCT_PURE_MAKE_BLOCK
argument_list|,
name|result_mode
argument_list|,
literal|3
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|cmp_mode
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|result
expr_stmt|;
operator|*
name|py
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|pmode
operator|=
name|result_mode
expr_stmt|;
return|return;
block|}
comment|/* Don't allow operands to the compare to trap, as that can put the      compare and branch in different basic blocks.  */
if|if
condition|(
name|flag_non_call_exceptions
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_trap_p
argument_list|(
name|y
argument_list|)
condition|)
name|y
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
operator|*
name|px
operator|=
name|x
expr_stmt|;
operator|*
name|py
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|can_compare_p
argument_list|(
operator|*
name|pcomparison
argument_list|,
name|mode
argument_list|,
name|purpose
argument_list|)
condition|)
return|return;
comment|/* Handle a lib call just for the mode we are using.  */
if|if
condition|(
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|&&
operator|!
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|libfunc
init|=
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* If we want unsigned, and this mode has a distinct unsigned 	 comparison routine, use that.  */
if|if
condition|(
name|unsignedp
operator|&&
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
condition|)
name|libfunc
operator|=
name|ucmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
expr_stmt|;
name|result
operator|=
name|emit_library_call_value
argument_list|(
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST_MAKE_BLOCK
argument_list|,
name|word_mode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* There are two kinds of comparison routines. Biased routines 	 return 0/1/2, and unbiased routines return -1/0/1. Other parts 	 of gcc expect that the comparison operation is equivalent 	 to the modified comparison. For signed comparisons compare the  	 result against 1 in the biased case, and zero in the unbiased 	 case. For unsigned comparisons always compare against 1 after 	 biasing the unbiased result by adding 1. This gives us a way to 	 represent LTU. */
operator|*
name|px
operator|=
name|result
expr_stmt|;
operator|*
name|pmode
operator|=
name|word_mode
expr_stmt|;
operator|*
name|py
operator|=
name|const1_rtx
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_LIB_INT_CMP_BIASED
condition|)
block|{
if|if
condition|(
operator|*
name|punsignedp
condition|)
operator|*
name|px
operator|=
name|plus_constant
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|py
operator|=
name|const0_rtx
expr_stmt|;
block|}
return|return;
block|}
name|gcc_assert
argument_list|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|prepare_float_lib_cmp
argument_list|(
name|px
argument_list|,
name|py
argument_list|,
name|pcomparison
argument_list|,
name|pmode
argument_list|,
name|punsignedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Before emitting an insn with code ICODE, make sure that X, which is going    to be used for operand OPNUM of the insn, is converted from mode MODE to    WIDER_MODE (UNSIGNEDP determines whether it is an unsigned conversion), and    that it is accepted by the operand predicate.  Return the new value.  */
end_comment

begin_function
specifier|static
name|rtx
name|prepare_operand
parameter_list|(
name|int
name|icode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|opnum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|wider_mode
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|wider_mode
condition|)
name|x
operator|=
name|convert_modes
argument_list|(
name|wider_mode
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|opnum
index|]
operator|.
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of emit_cmp_and_jump_insns; this function is called when we know    we can do the comparison.    The arguments are the same as for emit_cmp_and_jump_insns; but LABEL may    be NULL_RTX which indicates that only a comparison is to be generated.  */
end_comment

begin_function
specifier|static
name|void
name|emit_cmp_and_jump_insn_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|comparison
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|test
init|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|wider_mode
init|=
name|mode
decl_stmt|;
comment|/* Try combined insns first.  */
do|do
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|PUT_MODE
argument_list|(
name|test
argument_list|,
name|wider_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|icode
operator|=
name|cbranch_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|test
argument_list|,
name|wider_mode
argument_list|)
condition|)
block|{
name|x
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|x
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|y
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|y
argument_list|,
literal|2
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|test
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Handle some compares against zero.  */
name|icode
operator|=
operator|(
name|int
operator|)
name|tst_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|&&
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|x
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|emit_jump_insn
argument_list|(
argument|bcc_gen_fctn[(int) comparison] (label)
argument_list|)
empty_stmt|;
return|return;
block|}
comment|/* Handle compares for which there is a directly suitable insn.  */
name|icode
operator|=
operator|(
name|int
operator|)
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|x
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|y
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|y
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|emit_jump_insn
argument_list|(
argument|bcc_gen_fctn[(int) comparison] (label)
argument_list|)
empty_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|CLASS_HAS_WIDER_MODES_P
argument_list|(
name|class
argument_list|)
condition|)
break|break;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wider_mode
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wider_mode
operator|!=
name|VOIDmode
condition|)
do|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to compare X with Y so that the condition codes are    set and to jump to LABEL if the condition is true.  If X is a    constant and Y is not a constant, then the comparison is swapped to    ensure that the comparison RTL has the canonical form.     UNSIGNEDP nonzero says that X and Y are unsigned; this matters if they    need to be widened by emit_cmp_insn.  UNSIGNEDP is also used to select    the proper branch condition code.     If X and Y have mode BLKmode, then SIZE specifies the size of both X and Y.     MODE is the mode of the inputs (in case they are const_int).     COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  It will    be passed unchanged to emit_cmp_insn, then potentially converted into an    unsigned variant based on UNSIGNEDP to select a proper jump instruction.  */
end_comment

begin_function
name|void
name|emit_cmp_and_jump_insns
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|enum
name|rtx_code
name|comparison
parameter_list|,
name|rtx
name|size
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|op0
init|=
name|x
decl_stmt|,
name|op1
init|=
name|y
decl_stmt|;
comment|/* Swap operands and condition to ensure canonical RTL.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
comment|/* If we're not emitting a branch, this means some caller          is out of sync.  */
name|gcc_assert
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|op0
operator|=
name|y
operator|,
name|op1
operator|=
name|x
expr_stmt|;
name|comparison
operator|=
name|swap_condition
argument_list|(
name|comparison
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If OP0 is still a constant, then both X and Y must be constants.      Force X into a register to create canonical RTL.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unsignedp
condition|)
name|comparison
operator|=
name|unsigned_condition
argument_list|(
name|comparison
argument_list|)
expr_stmt|;
name|prepare_cmp_insn
argument_list|(
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
operator|&
name|comparison
argument_list|,
name|size
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
name|ccp_jump
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insn_1
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|comparison
argument_list|,
name|unsignedp
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like emit_cmp_and_jump_insns, but generate only the comparison.  */
end_comment

begin_function
name|void
name|emit_cmp_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|enum
name|rtx_code
name|comparison
parameter_list|,
name|rtx
name|size
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|comparison
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a library call comparison between floating point X and Y.    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */
end_comment

begin_function
specifier|static
name|void
name|prepare_float_lib_cmp
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|rtx
modifier|*
name|py
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|pcomparison
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|pmode
parameter_list|,
name|int
modifier|*
name|punsignedp
parameter_list|)
block|{
name|enum
name|rtx_code
name|comparison
init|=
operator|*
name|pcomparison
decl_stmt|;
name|enum
name|rtx_code
name|swapped
init|=
name|swap_condition
argument_list|(
name|comparison
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|reversed
init|=
name|reverse_condition_maybe_unordered
argument_list|(
name|comparison
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|rtx
name|y
init|=
operator|*
name|py
decl_stmt|;
name|enum
name|machine_mode
name|orig_mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|value
decl_stmt|,
name|target
decl_stmt|,
name|insns
decl_stmt|,
name|equiv
decl_stmt|;
name|rtx
name|libfunc
init|=
literal|0
decl_stmt|;
name|bool
name|reversed_p
init|=
name|false
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|orig_mode
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|libfunc
operator|=
name|code_to_optab
index|[
name|comparison
index|]
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|libfunc
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|libfunc
operator|=
name|code_to_optab
index|[
name|swapped
index|]
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|libfunc
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|tmp
expr_stmt|;
name|comparison
operator|=
name|swapped
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|libfunc
operator|=
name|code_to_optab
index|[
name|reversed
index|]
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|libfunc
operator|)
operator|&&
name|FLOAT_LIB_COMPARE_RETURNS_BOOL
argument_list|(
name|mode
argument_list|,
name|reversed
argument_list|)
condition|)
block|{
name|comparison
operator|=
name|reversed
expr_stmt|;
name|reversed_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|gcc_assert
argument_list|(
name|mode
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|orig_mode
condition|)
block|{
name|x
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Attach a REG_EQUAL note describing the semantics of the libcall to      the RTL.  The allows the RTL optimizers to delete the libcall if the      condition can be determined at compile-time.  */
if|if
condition|(
name|comparison
operator|==
name|UNORDERED
condition|)
block|{
name|rtx
name|temp
init|=
name|simplify_gen_relational
argument_list|(
name|NE
argument_list|,
name|word_mode
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|equiv
operator|=
name|simplify_gen_relational
argument_list|(
name|NE
argument_list|,
name|word_mode
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|equiv
operator|=
name|simplify_gen_ternary
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|temp
argument_list|,
name|const_true_rtx
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|equiv
operator|=
name|simplify_gen_relational
argument_list|(
name|comparison
argument_list|,
name|word_mode
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FLOAT_LIB_COMPARE_RETURNS_BOOL
argument_list|(
name|mode
argument_list|,
name|comparison
argument_list|)
condition|)
block|{
name|rtx
name|true_rtx
decl_stmt|,
name|false_rtx
decl_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQ
case|:
name|true_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|false_rtx
operator|=
name|const_true_rtx
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|true_rtx
operator|=
name|const_true_rtx
expr_stmt|;
name|false_rtx
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|true_rtx
operator|=
name|const1_rtx
expr_stmt|;
name|false_rtx
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|true_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|false_rtx
operator|=
name|constm1_rtx
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|true_rtx
operator|=
name|constm1_rtx
expr_stmt|;
name|false_rtx
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|true_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|false_rtx
operator|=
name|const1_rtx
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|equiv
operator|=
name|simplify_gen_ternary
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|word_mode
argument_list|,
name|word_mode
argument_list|,
name|equiv
argument_list|,
name|true_rtx
argument_list|,
name|false_rtx
argument_list|)
expr_stmt|;
block|}
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|word_mode
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|y
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison
operator|==
name|UNORDERED
operator|||
name|FLOAT_LIB_COMPARE_RETURNS_BOOL
argument_list|(
name|mode
argument_list|,
name|comparison
argument_list|)
condition|)
name|comparison
operator|=
name|reversed_p
condition|?
name|EQ
else|:
name|NE
expr_stmt|;
operator|*
name|px
operator|=
name|target
expr_stmt|;
operator|*
name|py
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|pmode
operator|=
name|word_mode
expr_stmt|;
operator|*
name|pcomparison
operator|=
name|comparison
expr_stmt|;
operator|*
name|punsignedp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to indirectly jump to a location given in the rtx LOC.  */
end_comment

begin_function
name|void
name|emit_indirect_jump
parameter_list|(
name|rtx
name|loc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_indirect_jump
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|loc
argument_list|,
name|Pmode
argument_list|)
condition|)
name|loc
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_indirect_jump
argument_list|(
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_move
end_ifdef

begin_comment
comment|/* Emit a conditional move instruction if the machine supports one for that    condition and machine mode.     OP0 and OP1 are the operands that should be compared using CODE.  CMODE is    the mode to use should they be constants.  If it is VOIDmode, they cannot    both be constants.     OP2 should be stored in TARGET if the comparison is true, otherwise OP3    should be stored there.  MODE is the mode to use should they be constants.    If it is VOIDmode, they cannot both be constants.     The result is either TARGET (perhaps modified) or NULL_RTX if the operation    is not supported.  */
end_comment

begin_function
name|rtx
name|emit_conditional_move
parameter_list|(
name|rtx
name|target
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|enum
name|machine_mode
name|cmode
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|op3
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|,
name|subtarget
decl_stmt|,
name|comparison
decl_stmt|,
name|insn
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|rtx_code
name|reversed
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* get_condition will prefer to generate LT and GT even if the old      comparison was against zero, so undo that canonicalization here since      comparisons against zero are cheaper.  */
if|if
condition|(
name|code
operator|==
name|LT
operator|&&
name|op1
operator|==
name|const1_rtx
condition|)
name|code
operator|=
name|LE
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GT
operator|&&
name|op1
operator|==
name|constm1_rtx
condition|)
name|code
operator|=
name|GE
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|cmode
operator|==
name|VOIDmode
condition|)
name|cmode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op2
argument_list|,
name|op3
argument_list|)
operator|&&
operator|(
operator|(
name|reversed
operator|=
name|reversed_comparison_code_parts
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|UNKNOWN
operator|)
condition|)
block|{
name|tem
operator|=
name|op2
expr_stmt|;
name|op2
operator|=
name|op3
expr_stmt|;
name|op3
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|reversed
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|icode
operator|=
name|movcc_gen_code
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|target
expr_stmt|;
comment|/* If the insn doesn't accept these operands, put them in pseudos.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|subtarget
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|op2
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
argument_list|(
name|op3
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
argument_list|)
condition|)
name|op3
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* Everything should now be in the suitable form, so emit the compare insn      and then the conditional move.  */
name|comparison
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|cmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */
comment|/* We can get const0_rtx or const_true_rtx in some circumstances.  Just      return NULL and let the caller figure out how best to deal with this      situation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|!=
name|code
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|subtarget
argument_list|,
name|comparison
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* If that failed, then give up.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtarget
operator|!=
name|target
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if a conditional move of mode MODE is supported.     This function is for combine so it can tell whether an insn that looks    like a conditional move is actually supported by the hardware.  If we    guess wrong we lose a bit on optimization, but that's it.  */
end_comment

begin_comment
comment|/* ??? sparc64 supports conditionally moving integers values based on fp    comparisons, and vice versa.  How do we handle them?  */
end_comment

begin_function
name|int
name|can_conditionally_move_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|movcc_gen_code
index|[
name|mode
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_conditional_move */
end_comment

begin_comment
comment|/* Emit a conditional addition instruction if the machine supports one for that    condition and machine mode.     OP0 and OP1 are the operands that should be compared using CODE.  CMODE is    the mode to use should they be constants.  If it is VOIDmode, they cannot    both be constants.     OP2 should be stored in TARGET if the comparison is true, otherwise OP2+OP3    should be stored there.  MODE is the mode to use should they be constants.    If it is VOIDmode, they cannot both be constants.     The result is either TARGET (perhaps modified) or NULL_RTX if the operation    is not supported.  */
end_comment

begin_function
name|rtx
name|emit_conditional_add
parameter_list|(
name|rtx
name|target
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|enum
name|machine_mode
name|cmode
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|op3
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|rtx
name|tem
decl_stmt|,
name|subtarget
decl_stmt|,
name|comparison
decl_stmt|,
name|insn
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|rtx_code
name|reversed
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* get_condition will prefer to generate LT and GT even if the old      comparison was against zero, so undo that canonicalization here since      comparisons against zero are cheaper.  */
if|if
condition|(
name|code
operator|==
name|LT
operator|&&
name|op1
operator|==
name|const1_rtx
condition|)
name|code
operator|=
name|LE
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GT
operator|&&
name|op1
operator|==
name|constm1_rtx
condition|)
name|code
operator|=
name|GE
operator|,
name|op1
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|cmode
operator|==
name|VOIDmode
condition|)
name|cmode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_commutative_operands_p
argument_list|(
name|op2
argument_list|,
name|op3
argument_list|)
operator|&&
operator|(
operator|(
name|reversed
operator|=
name|reversed_comparison_code_parts
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|UNKNOWN
operator|)
condition|)
block|{
name|tem
operator|=
name|op2
expr_stmt|;
name|op2
operator|=
name|op3
expr_stmt|;
name|op3
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|reversed
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|icode
operator|=
name|addcc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If the insn doesn't accept these operands, put them in pseudos.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
else|else
name|subtarget
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|op2
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
argument_list|(
name|op3
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
argument_list|)
condition|)
name|op3
operator|=
name|copy_to_mode_reg
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* Everything should now be in the suitable form, so emit the compare insn      and then the conditional move.  */
name|comparison
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|cmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */
comment|/* We can get const0_rtx or const_true_rtx in some circumstances.  Just      return NULL and let the caller figure out how best to deal with this      situation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|!=
name|code
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|subtarget
argument_list|,
name|comparison
argument_list|,
name|op2
argument_list|,
name|op3
argument_list|)
expr_stmt|;
comment|/* If that failed, then give up.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtarget
operator|!=
name|target
condition|)
name|convert_move
argument_list|(
name|target
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These functions attempt to generate an insn body, rather than    emitting the insn, but if the gen function already emits them, we    make no attempt to turn them back into naked patterns.  */
end_comment

begin_comment
comment|/* Generate and return an insn body to add Y to X.  */
end_comment

begin_function
name|rtx
name|gen_add2_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|y
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to add r1 and c,    storing the result in r0.  */
end_comment

begin_function
name|rtx
name|gen_add3_insn
parameter_list|(
name|rtx
name|r0
parameter_list|,
name|rtx
name|r1
parameter_list|,
name|rtx
name|c
parameter_list|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|r0
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|r0
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|r1
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|c
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|have_add2_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|icode
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|y
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to subtract Y from X.  */
end_comment

begin_function
name|rtx
name|gen_sub2_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|y
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate and return an insn body to subtract r1 and c,    storing the result in r0.  */
end_comment

begin_function
name|rtx
name|gen_sub3_insn
parameter_list|(
name|rtx
name|r0
parameter_list|,
name|rtx
name|r1
parameter_list|,
name|rtx
name|c
parameter_list|)
block|{
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|r0
argument_list|)
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|r0
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|r1
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|c
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
operator|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|have_sub2_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|icode
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|y
argument_list|,
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate the body of an instruction to copy Y into X.    It may be a list of insns, if one insn isn't enough.  */
end_comment

begin_function
name|rtx
name|gen_move_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn_1
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the insn code used to extend FROM_MODE to TO_MODE.    UNSIGNEDP specifies zero-extension instead of sign-extension.  If    no such operation exists, CODE_FOR_nothing will be returned.  */
end_comment

begin_function
name|enum
name|insn_code
name|can_extend_p
parameter_list|(
name|enum
name|machine_mode
name|to_mode
parameter_list|,
name|enum
name|machine_mode
name|from_mode
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|convert_optab
name|tab
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ptr_extend
if|if
condition|(
name|unsignedp
operator|<
literal|0
condition|)
return|return
name|CODE_FOR_ptr_extend
return|;
endif|#
directive|endif
name|tab
operator|=
name|unsignedp
condition|?
name|zext_optab
else|:
name|sext_optab
expr_stmt|;
return|return
name|tab
operator|->
name|handlers
index|[
name|to_mode
index|]
index|[
name|from_mode
index|]
operator|.
name|insn_code
return|;
block|}
end_function

begin_comment
comment|/* Generate the body of an insn to extend Y (with mode MFROM)    into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */
end_comment

begin_function
name|rtx
name|gen_extend_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|enum
name|machine_mode
name|mto
parameter_list|,
name|enum
name|machine_mode
name|mfrom
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
init|=
name|can_extend_p
argument_list|(
name|mto
argument_list|,
name|mfrom
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
return|return
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* can_fix_p and can_float_p say whether the target machine    can directly convert a given fixed point type to    a given floating point type, or vice versa.    The returned value is the CODE_FOR_... value to use,    or CODE_FOR_nothing if these modes cannot be directly converted.     *TRUNCP_PTR is set to 1 if it is necessary to output    an explicit FTRUNC insn before the fix insn; otherwise 0.  */
end_comment

begin_function
specifier|static
name|enum
name|insn_code
name|can_fix_p
parameter_list|(
name|enum
name|machine_mode
name|fixmode
parameter_list|,
name|enum
name|machine_mode
name|fltmode
parameter_list|,
name|int
name|unsignedp
parameter_list|,
name|int
modifier|*
name|truncp_ptr
parameter_list|)
block|{
name|convert_optab
name|tab
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tab
operator|=
name|unsignedp
condition|?
name|ufixtrunc_optab
else|:
name|sfixtrunc_optab
expr_stmt|;
name|icode
operator|=
name|tab
operator|->
name|handlers
index|[
name|fixmode
index|]
index|[
name|fltmode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
operator|*
name|truncp_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|icode
return|;
block|}
comment|/* FIXME: This requires a port to define both FIX and FTRUNC pattern      for this to work. We need to rework the fix* and ftrunc* patterns      and documentation.  */
name|tab
operator|=
name|unsignedp
condition|?
name|ufix_optab
else|:
name|sfix_optab
expr_stmt|;
name|icode
operator|=
name|tab
operator|->
name|handlers
index|[
name|fixmode
index|]
index|[
name|fltmode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|ftrunc_optab
operator|->
name|handlers
index|[
name|fltmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
operator|*
name|truncp_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|icode
return|;
block|}
operator|*
name|truncp_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|CODE_FOR_nothing
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|insn_code
name|can_float_p
parameter_list|(
name|enum
name|machine_mode
name|fltmode
parameter_list|,
name|enum
name|machine_mode
name|fixmode
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|convert_optab
name|tab
decl_stmt|;
name|tab
operator|=
name|unsignedp
condition|?
name|ufloat_optab
else|:
name|sfloat_optab
expr_stmt|;
return|return
name|tab
operator|->
name|handlers
index|[
name|fltmode
index|]
index|[
name|fixmode
index|]
operator|.
name|insn_code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to convert FROM to floating point    and store in TO.  FROM must be fixed point and not VOIDmode.    UNSIGNEDP nonzero means regard FROM as unsigned.    Normally this is done by correcting the final value    if it is negative.  */
end_comment

begin_function
name|void
name|expand_float
parameter_list|(
name|rtx
name|to
parameter_list|,
name|rtx
name|from
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|target
init|=
name|to
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|imode
decl_stmt|;
name|bool
name|can_do_signed
init|=
name|false
decl_stmt|;
comment|/* Crash now, because we won't be able to decide which mode to use.  */
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
operator|!=
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* Look for an insn to do the conversion.  Do it in the specified      modes if possible; otherwise convert either input, output or both to      wider mode.  If the integer mode is wider than the mode of FROM,      we can do the conversion signed even if the input is unsigned.  */
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
for|for
control|(
name|imode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|imode
operator|!=
name|VOIDmode
condition|;
name|imode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|imode
argument_list|)
control|)
block|{
name|int
name|doing_unsigned
init|=
name|unsignedp
decl_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|&&
name|significand_size
argument_list|(
name|fmode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
continue|continue;
name|icode
operator|=
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|imode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|unsignedp
condition|)
block|{
name|enum
name|insn_code
name|scode
init|=
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|imode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|scode
operator|!=
name|CODE_FOR_nothing
condition|)
name|can_do_signed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|icode
operator|=
name|scode
operator|,
name|doing_unsigned
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|imode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|from
argument_list|,
name|doing_unsigned
condition|?
name|UNSIGNED_FLOAT
else|:
name|FLOAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Unsigned integer, and no way to convert directly.  For binary      floating point modes, convert as signed, then conditionally adjust      the result.  */
if|if
condition|(
name|unsignedp
operator|&&
name|can_do_signed
operator|&&
operator|!
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|REAL_VALUE_TYPE
name|offset
decl_stmt|;
comment|/* Look for a usable floating mode FMODE wider than the source and at 	 least as wide as the target.  Using FMODE will avoid rounding woes 	 with unsigned values greater than the signed maximum value.  */
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|fmode
argument_list|)
operator|&&
name|can_float_p
argument_list|(
name|fmode
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
if|if
condition|(
name|fmode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* There is no such mode.  Pretend the target is wide enough.  */
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Avoid double-rounding when TO is narrower than FROM.  */
if|if
condition|(
operator|(
name|significand_size
argument_list|(
name|fmode
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|temp1
decl_stmt|;
name|rtx
name|neglabel
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Don't use TARGET if it isn't a register, is a hard register, 		 or is the wrong mode.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|fmode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
name|imode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Test whether the sign bit is set.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|from
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|NULL_RTX
argument_list|,
name|imode
argument_list|,
literal|0
argument_list|,
name|neglabel
argument_list|)
expr_stmt|;
comment|/* The sign bit is not set.  Convert as signed.  */
name|expand_float
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* The sign bit is set. 		 Convert to a usable (positive signed) value by shifting right 		 one bit, while remembering if a nonzero bit was shifted 		 out; i.e., compute  (from& 1) | (from>> 1).  */
name|emit_label
argument_list|(
name|neglabel
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|and_optab
argument_list|,
name|from
argument_list|,
name|const1_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|imode
argument_list|,
name|from
argument_list|,
name|integer_one_node
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|imode
argument_list|,
name|ior_optab
argument_list|,
name|temp
argument_list|,
name|temp1
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|target
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Multiply by 2 to undo the shift above.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|fmode
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* If we are about to do some arithmetic to correct for an 	 unsigned operand, do it in a pseudo-register.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|!=
name|fmode
operator|||
operator|!
name|REG_P
argument_list|(
name|to
argument_list|)
operator|||
name|REGNO
argument_list|(
name|to
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
comment|/* Convert as signed integer to floating.  */
name|expand_float
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If FROM is negative (and therefore TO is negative), 	 correct its value by 2**bitwidth.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|from
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|real_2expN
argument_list|(
operator|&
name|offset
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|fmode
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|offset
argument_list|,
name|fmode
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* No hardware instruction available; call a library routine.  */
block|{
name|rtx
name|libfunc
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|convert_optab
name|tab
init|=
name|unsignedp
condition|?
name|ufloat_optab
else|:
name|sfloat_optab
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|libfunc
operator|=
name|tab
operator|->
name|handlers
index|[
name|GET_MODE
argument_list|(
name|to
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|from
argument_list|)
index|]
operator|.
name|libfunc
expr_stmt|;
name|gcc_assert
argument_list|(
name|libfunc
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* Copy result to requested destination      if we have been computing in a temp location.  */
if|if
condition|(
name|target
operator|!=
name|to
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to convert FROM to fixed point and store in TO.  FROM    must be floating point.  */
end_comment

begin_function
name|void
name|expand_fix
parameter_list|(
name|rtx
name|to
parameter_list|,
name|rtx
name|from
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|target
init|=
name|to
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|imode
decl_stmt|;
name|int
name|must_trunc
init|=
literal|0
decl_stmt|;
comment|/* We first try to find a pair of modes, one real and one integer, at      least as wide as FROM and TO, respectively, in which we can open-code      this conversion.  If the integer mode is wider than the mode of TO,      we can do the conversion either signed or unsigned.  */
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
for|for
control|(
name|imode
operator|=
name|GET_MODE
argument_list|(
name|to
argument_list|)
init|;
name|imode
operator|!=
name|VOIDmode
condition|;
name|imode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|imode
argument_list|)
control|)
block|{
name|int
name|doing_unsigned
init|=
name|unsignedp
decl_stmt|;
name|icode
operator|=
name|can_fix_p
argument_list|(
name|imode
argument_list|,
name|fmode
argument_list|,
name|unsignedp
argument_list|,
operator|&
name|must_trunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|&&
name|unsignedp
condition|)
name|icode
operator|=
name|can_fix_p
argument_list|(
name|imode
argument_list|,
name|fmode
argument_list|,
literal|0
argument_list|,
operator|&
name|must_trunc
argument_list|)
operator|,
name|doing_unsigned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|fmode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_trunc
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|from
operator|=
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|ftrunc_optab
argument_list|,
name|from
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|imode
operator|!=
name|GET_MODE
argument_list|(
name|to
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|imode
argument_list|)
expr_stmt|;
name|emit_unop_insn
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|from
argument_list|,
name|doing_unsigned
condition|?
name|UNSIGNED_FIX
else|:
name|FIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* For an unsigned conversion, there is one more way to do it.      If we have a signed conversion, we generate code that compares      the real value to the largest representable positive number.  If if      is smaller, the conversion is done normally.  Otherwise, subtract      one plus the highest signed number, convert, and add it back.       We only need to check all real modes, since we know we didn't find      anything with a wider integer mode.       This code used to extend FP value into mode wider than the destination.      This is not needed.  Consider, for instance conversion from SFmode      into DImode.       The hot path through the code is dealing with inputs smaller than 2^63      and doing just the conversion, so there is no bits to lose.       In the other path we know the value is positive in the range 2^63..2^64-1      inclusive.  (as for other imput overflow happens and result is undefined)      So we know that the most important bit set in mantissa corresponds to      2^63.  The subtraction of 2^63 should not generate any rounding as it      simply clears out that bit.  The rest is trivial.  */
if|if
condition|(
name|unsignedp
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
for|for
control|(
name|fmode
operator|=
name|GET_MODE
argument_list|(
name|from
argument_list|)
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
if|if
condition|(
name|CODE_FOR_nothing
operator|!=
name|can_fix_p
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|fmode
argument_list|,
literal|0
argument_list|,
operator|&
name|must_trunc
argument_list|)
condition|)
block|{
name|int
name|bitsize
decl_stmt|;
name|REAL_VALUE_TYPE
name|offset
decl_stmt|;
name|rtx
name|limit
decl_stmt|,
name|lab1
decl_stmt|,
name|lab2
decl_stmt|,
name|insn
decl_stmt|;
name|bitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|real_2expN
argument_list|(
operator|&
name|offset
argument_list|,
name|bitsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|limit
operator|=
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|offset
argument_list|,
name|fmode
argument_list|)
expr_stmt|;
name|lab1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|GET_MODE
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|=
name|convert_to_mode
argument_list|(
name|fmode
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if we need to do the subtraction.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|from
argument_list|,
name|limit
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
literal|0
argument_list|,
name|lab1
argument_list|)
expr_stmt|;
comment|/* If not, do the signed "fix" and branch around fixup code.  */
name|expand_fix
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Otherwise, subtract 2**(N-1), convert to signed number, 	     then add 2**(N-1).  Do the addition using XOR since this 	     will often generate better code.  */
name|emit_label
argument_list|(
name|lab1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|from
argument_list|,
name|limit
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|xor_optab
argument_list|,
name|to
argument_list|,
name|gen_int_mode
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|bitsize
operator|-
literal|1
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|to
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|to
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|to
argument_list|)
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* Make a place for a REG_NOTE and add it.  */
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|UNSIGNED_FIX
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* We can't do it with an insn, so use a library call.  But first ensure      that the mode of TO is at least as wide as SImode, since those are the      only library calls we know about.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
block|{
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|expand_fix
argument_list|(
name|target
argument_list|,
name|from
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|insns
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|rtx
name|libfunc
decl_stmt|;
name|convert_optab
name|tab
init|=
name|unsignedp
condition|?
name|ufix_optab
else|:
name|sfix_optab
decl_stmt|;
name|libfunc
operator|=
name|tab
operator|->
name|handlers
index|[
name|GET_MODE
argument_list|(
name|to
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|from
argument_list|)
index|]
operator|.
name|libfunc
expr_stmt|;
name|gcc_assert
argument_list|(
name|libfunc
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|emit_library_call_value
argument_list|(
name|libfunc
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
literal|1
argument_list|,
name|from
argument_list|,
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|target
argument_list|,
name|value
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|unsignedp
condition|?
name|UNSIGNED_FIX
else|:
name|FIX
argument_list|,
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|!=
name|to
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
name|convert_move
argument_list|(
name|to
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report whether we have an instruction to perform the operation    specified by CODE on operands of mode MODE.  */
end_comment

begin_function
name|int
name|have_insn_for
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|!=
literal|0
operator|&&
operator|(
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a blank optab.  */
end_comment

begin_function
specifier|static
name|optab
name|new_optab
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|optab
name|op
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|optab
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|op
operator|->
name|handlers
index|[
name|i
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
end_function

begin_function
specifier|static
name|convert_optab
name|new_convert_optab
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|convert_optab
name|op
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|convert_optab
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
name|j
operator|++
control|)
block|{
name|op
operator|->
name|handlers
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|insn_code
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|op
operator|->
name|handlers
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Same, but fill in its code as CODE, and write it into the    code_to_optab table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|optab
name|init_optab
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|optab
name|op
init|=
name|new_optab
argument_list|()
decl_stmt|;
name|op
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|code_to_optab
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|=
name|op
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Same, but fill in its code as CODE, and do _not_ write it into    the code_to_optab table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|optab
name|init_optabv
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|optab
name|op
init|=
name|new_optab
argument_list|()
decl_stmt|;
name|op
operator|->
name|code
operator|=
name|code
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Conversion optabs never go in the code_to_optab table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|convert_optab
name|init_convert_optab
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|convert_optab
name|op
init|=
name|new_convert_optab
argument_list|()
decl_stmt|;
name|op
operator|->
name|code
operator|=
name|code
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab.  Each entry is set equal to a string consisting of a leading    pair of underscores followed by a generic operation name followed by    a mode name (downshifted to lowercase) followed by a single character    representing the number of operands for the given operation (which is    usually one of the characters '2', '3', or '4').     OPTABLE is the table in which libfunc fields are to be initialized.    FIRST_MODE is the first machine mode index in the given optab to      initialize.    LAST_MODE is the last machine mode index in the given optab to      initialize.    OPNAME is the generic (string) name of the operation.    SUFFIX is the character which specifies the number of operands for      the given generic operation. */
end_comment

begin_function
specifier|static
name|void
name|init_libfuncs
parameter_list|(
name|optab
name|optable
parameter_list|,
name|int
name|first_mode
parameter_list|,
name|int
name|last_mode
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|,
name|int
name|suffix
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|unsigned
name|opname_len
init|=
name|strlen
argument_list|(
name|opname
argument_list|)
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|first_mode
init|;
operator|(
name|int
operator|)
name|mode
operator|<=
operator|(
name|int
operator|)
name|last_mode
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
specifier|const
name|char
modifier|*
name|mname
init|=
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|mname_len
init|=
name|strlen
argument_list|(
name|mname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|libfunc_name
init|=
name|alloca
argument_list|(
literal|2
operator|+
name|opname_len
operator|+
name|mname_len
operator|+
literal|1
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|libfunc_name
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|opname
init|;
operator|*
name|q
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|mname
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|TOLOWER
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|suffix
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|optable
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|ggc_alloc_string
argument_list|(
name|libfunc_name
argument_list|,
name|p
operator|-
name|libfunc_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab which correspond to all integer mode operations.  The parameters    have the same meaning as similarly named ones for the `init_libfuncs'    routine.  (See above).  */
end_comment

begin_function
specifier|static
name|void
name|init_integral_libfuncs
parameter_list|(
name|optab
name|optable
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|,
name|int
name|suffix
parameter_list|)
block|{
name|int
name|maxsize
init|=
literal|2
operator|*
name|BITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|maxsize
operator|<
name|LONG_LONG_TYPE_SIZE
condition|)
name|maxsize
operator|=
name|LONG_LONG_TYPE_SIZE
expr_stmt|;
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|word_mode
argument_list|,
name|mode_for_size
argument_list|(
name|maxsize
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries in some    optab which correspond to all real mode operations.  The parameters    have the same meaning as similarly named ones for the `init_libfuncs'    routine.  (See above).  */
end_comment

begin_function
specifier|static
name|void
name|init_floating_libfuncs
parameter_list|(
name|optab
name|optable
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|,
name|int
name|suffix
parameter_list|)
block|{
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|MIN_MODE_FLOAT
argument_list|,
name|MAX_MODE_FLOAT
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|init_libfuncs
argument_list|(
name|optable
argument_list|,
name|MIN_MODE_DECIMAL_FLOAT
argument_list|,
name|MAX_MODE_DECIMAL_FLOAT
argument_list|,
name|opname
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries of an    inter-mode-class conversion optab.  The string formation rules are    similar to the ones for init_libfuncs, above, but instead of having    a mode name and an operand count these functions have two mode names    and no operand count.  */
end_comment

begin_function
specifier|static
name|void
name|init_interclass_conv_libfuncs
parameter_list|(
name|convert_optab
name|tab
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|,
name|enum
name|mode_class
name|from_class
parameter_list|,
name|enum
name|mode_class
name|to_class
parameter_list|)
block|{
name|enum
name|machine_mode
name|first_from_mode
init|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|from_class
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|first_to_mode
init|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|to_class
argument_list|)
decl_stmt|;
name|size_t
name|opname_len
init|=
name|strlen
argument_list|(
name|opname
argument_list|)
decl_stmt|;
name|size_t
name|max_mname_len
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|fmode
decl_stmt|,
name|tmode
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|,
modifier|*
name|tname
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|libfunc_name
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|fmode
operator|=
name|first_from_mode
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
name|max_mname_len
operator|=
name|MAX
argument_list|(
name|max_mname_len
argument_list|,
name|strlen
argument_list|(
name|GET_MODE_NAME
argument_list|(
name|fmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tmode
operator|=
name|first_to_mode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
name|max_mname_len
operator|=
name|MAX
argument_list|(
name|max_mname_len
argument_list|,
name|strlen
argument_list|(
name|GET_MODE_NAME
argument_list|(
name|tmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|libfunc_name
operator|=
name|alloca
argument_list|(
literal|2
operator|+
name|opname_len
operator|+
literal|2
operator|*
name|max_mname_len
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|libfunc_name
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|libfunc_name
index|[
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|libfunc_name
index|[
literal|2
index|]
argument_list|,
name|opname
argument_list|,
name|opname_len
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|libfunc_name
operator|+
name|opname_len
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|fmode
operator|=
name|first_from_mode
init|;
name|fmode
operator|!=
name|VOIDmode
condition|;
name|fmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|fmode
argument_list|)
control|)
for|for
control|(
name|tmode
operator|=
name|first_to_mode
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
block|{
name|fname
operator|=
name|GET_MODE_NAME
argument_list|(
name|fmode
argument_list|)
expr_stmt|;
name|tname
operator|=
name|GET_MODE_NAME
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|p
operator|=
name|suffix
expr_stmt|;
for|for
control|(
name|q
operator|=
name|fname
init|;
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|tname
init|;
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|tab
operator|->
name|handlers
index|[
name|tmode
index|]
index|[
name|fmode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|ggc_alloc_string
argument_list|(
name|libfunc_name
argument_list|,
name|p
operator|-
name|libfunc_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the libfunc fields of an entire group of entries of an    intra-mode-class conversion optab.  The string formation rules are    similar to the ones for init_libfunc, above.  WIDENING says whether    the optab goes from narrow to wide modes or vice versa.  These functions    have two mode names _and_ an operand count.  */
end_comment

begin_function
specifier|static
name|void
name|init_intraclass_conv_libfuncs
parameter_list|(
name|convert_optab
name|tab
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|,
name|enum
name|mode_class
name|class
parameter_list|,
name|bool
name|widening
parameter_list|)
block|{
name|enum
name|machine_mode
name|first_mode
init|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|class
argument_list|)
decl_stmt|;
name|size_t
name|opname_len
init|=
name|strlen
argument_list|(
name|opname
argument_list|)
decl_stmt|;
name|size_t
name|max_mname_len
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|nmode
decl_stmt|,
name|wmode
decl_stmt|;
specifier|const
name|char
modifier|*
name|nname
decl_stmt|,
modifier|*
name|wname
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|libfunc_name
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|nmode
operator|=
name|first_mode
init|;
name|nmode
operator|!=
name|VOIDmode
condition|;
name|nmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|nmode
argument_list|)
control|)
name|max_mname_len
operator|=
name|MAX
argument_list|(
name|max_mname_len
argument_list|,
name|strlen
argument_list|(
name|GET_MODE_NAME
argument_list|(
name|nmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|libfunc_name
operator|=
name|alloca
argument_list|(
literal|2
operator|+
name|opname_len
operator|+
literal|2
operator|*
name|max_mname_len
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|libfunc_name
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|libfunc_name
index|[
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|libfunc_name
index|[
literal|2
index|]
argument_list|,
name|opname
argument_list|,
name|opname_len
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|libfunc_name
operator|+
name|opname_len
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|nmode
operator|=
name|first_mode
init|;
name|nmode
operator|!=
name|VOIDmode
condition|;
name|nmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|nmode
argument_list|)
control|)
for|for
control|(
name|wmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|nmode
argument_list|)
init|;
name|wmode
operator|!=
name|VOIDmode
condition|;
name|wmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|wmode
argument_list|)
control|)
block|{
name|nname
operator|=
name|GET_MODE_NAME
argument_list|(
name|nmode
argument_list|)
expr_stmt|;
name|wname
operator|=
name|GET_MODE_NAME
argument_list|(
name|wmode
argument_list|)
expr_stmt|;
name|p
operator|=
name|suffix
expr_stmt|;
for|for
control|(
name|q
operator|=
name|widening
condition|?
name|nname
else|:
name|wname
init|;
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|widening
condition|?
name|wname
else|:
name|nname
init|;
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|tab
operator|->
name|handlers
index|[
name|widening
condition|?
name|wmode
else|:
name|nmode
index|]
index|[
name|widening
condition|?
name|nmode
else|:
name|wmode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|ggc_alloc_string
argument_list|(
name|libfunc_name
argument_list|,
name|p
operator|-
name|libfunc_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|rtx
name|init_one_libfunc
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|rtx
name|symbol
decl_stmt|;
comment|/* Create a FUNCTION_DECL that can be passed to      targetm.encode_section_info.  */
comment|/* ??? We don't have any type information except for this is      a function.  Pretend this is "int foo()".  */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|symbol
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zap the nonsensical SYMBOL_REF_DECL for this.  What we're left with      are the flags assigned by targetm.encode_section_info.  */
name|SET_SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Call this to reset the function entry for one optab (OPTABLE) in mode    MODE to NAME, which should be either 0 or a string constant.  */
end_comment

begin_function
name|void
name|set_optab_libfunc
parameter_list|(
name|optab
name|optable
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
name|optable
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|optable
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this to reset the function entry for one conversion optab    (OPTABLE) from mode FMODE to mode TMODE to NAME, which should be    either 0 or a string constant.  */
end_comment

begin_function
name|void
name|set_conv_libfunc
parameter_list|(
name|convert_optab
name|optable
parameter_list|,
name|enum
name|machine_mode
name|tmode
parameter_list|,
name|enum
name|machine_mode
name|fmode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
name|optable
operator|->
name|handlers
index|[
name|tmode
index|]
index|[
name|fmode
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|optable
operator|->
name|handlers
index|[
name|tmode
index|]
index|[
name|fmode
index|]
operator|.
name|libfunc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this once to initialize the contents of the optabs    appropriately for the current target machine.  */
end_comment

begin_function
name|void
name|init_optabs
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Start by initializing all tables to contain CODE_FOR_nothing.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
name|setcc_gen_code
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_move
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
name|movcc_gen_code
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|vcond_gen_code
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|vcondu_gen_code
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
block|}
name|add_optab
operator|=
name|init_optab
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
name|addv_optab
operator|=
name|init_optabv
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
name|sub_optab
operator|=
name|init_optab
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
name|subv_optab
operator|=
name|init_optabv
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
name|smul_optab
operator|=
name|init_optab
argument_list|(
name|MULT
argument_list|)
expr_stmt|;
name|smulv_optab
operator|=
name|init_optabv
argument_list|(
name|MULT
argument_list|)
expr_stmt|;
name|smul_highpart_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|umul_highpart_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|smul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|umul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|usmul_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|sdiv_optab
operator|=
name|init_optab
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|sdivv_optab
operator|=
name|init_optabv
argument_list|(
name|DIV
argument_list|)
expr_stmt|;
name|sdivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|udiv_optab
operator|=
name|init_optab
argument_list|(
name|UDIV
argument_list|)
expr_stmt|;
name|udivmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|smod_optab
operator|=
name|init_optab
argument_list|(
name|MOD
argument_list|)
expr_stmt|;
name|umod_optab
operator|=
name|init_optab
argument_list|(
name|UMOD
argument_list|)
expr_stmt|;
name|fmod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|drem_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ftrunc_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|and_optab
operator|=
name|init_optab
argument_list|(
name|AND
argument_list|)
expr_stmt|;
name|ior_optab
operator|=
name|init_optab
argument_list|(
name|IOR
argument_list|)
expr_stmt|;
name|xor_optab
operator|=
name|init_optab
argument_list|(
name|XOR
argument_list|)
expr_stmt|;
name|ashl_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFT
argument_list|)
expr_stmt|;
name|ashr_optab
operator|=
name|init_optab
argument_list|(
name|ASHIFTRT
argument_list|)
expr_stmt|;
name|lshr_optab
operator|=
name|init_optab
argument_list|(
name|LSHIFTRT
argument_list|)
expr_stmt|;
name|rotl_optab
operator|=
name|init_optab
argument_list|(
name|ROTATE
argument_list|)
expr_stmt|;
name|rotr_optab
operator|=
name|init_optab
argument_list|(
name|ROTATERT
argument_list|)
expr_stmt|;
name|smin_optab
operator|=
name|init_optab
argument_list|(
name|SMIN
argument_list|)
expr_stmt|;
name|smax_optab
operator|=
name|init_optab
argument_list|(
name|SMAX
argument_list|)
expr_stmt|;
name|umin_optab
operator|=
name|init_optab
argument_list|(
name|UMIN
argument_list|)
expr_stmt|;
name|umax_optab
operator|=
name|init_optab
argument_list|(
name|UMAX
argument_list|)
expr_stmt|;
name|pow_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|atan2_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
comment|/* These three have codes assigned exclusively for the sake of      have_insn_for.  */
name|mov_optab
operator|=
name|init_optab
argument_list|(
name|SET
argument_list|)
expr_stmt|;
name|movstrict_optab
operator|=
name|init_optab
argument_list|(
name|STRICT_LOW_PART
argument_list|)
expr_stmt|;
name|cmp_optab
operator|=
name|init_optab
argument_list|(
name|COMPARE
argument_list|)
expr_stmt|;
name|ucmp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|tst_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|eq_optab
operator|=
name|init_optab
argument_list|(
name|EQ
argument_list|)
expr_stmt|;
name|ne_optab
operator|=
name|init_optab
argument_list|(
name|NE
argument_list|)
expr_stmt|;
name|gt_optab
operator|=
name|init_optab
argument_list|(
name|GT
argument_list|)
expr_stmt|;
name|ge_optab
operator|=
name|init_optab
argument_list|(
name|GE
argument_list|)
expr_stmt|;
name|lt_optab
operator|=
name|init_optab
argument_list|(
name|LT
argument_list|)
expr_stmt|;
name|le_optab
operator|=
name|init_optab
argument_list|(
name|LE
argument_list|)
expr_stmt|;
name|unord_optab
operator|=
name|init_optab
argument_list|(
name|UNORDERED
argument_list|)
expr_stmt|;
name|neg_optab
operator|=
name|init_optab
argument_list|(
name|NEG
argument_list|)
expr_stmt|;
name|negv_optab
operator|=
name|init_optabv
argument_list|(
name|NEG
argument_list|)
expr_stmt|;
name|abs_optab
operator|=
name|init_optab
argument_list|(
name|ABS
argument_list|)
expr_stmt|;
name|absv_optab
operator|=
name|init_optabv
argument_list|(
name|ABS
argument_list|)
expr_stmt|;
name|addcc_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|one_cmpl_optab
operator|=
name|init_optab
argument_list|(
name|NOT
argument_list|)
expr_stmt|;
name|ffs_optab
operator|=
name|init_optab
argument_list|(
name|FFS
argument_list|)
expr_stmt|;
name|clz_optab
operator|=
name|init_optab
argument_list|(
name|CLZ
argument_list|)
expr_stmt|;
name|ctz_optab
operator|=
name|init_optab
argument_list|(
name|CTZ
argument_list|)
expr_stmt|;
name|popcount_optab
operator|=
name|init_optab
argument_list|(
name|POPCOUNT
argument_list|)
expr_stmt|;
name|parity_optab
operator|=
name|init_optab
argument_list|(
name|PARITY
argument_list|)
expr_stmt|;
name|sqrt_optab
operator|=
name|init_optab
argument_list|(
name|SQRT
argument_list|)
expr_stmt|;
name|floor_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|lfloor_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ceil_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|lceil_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|round_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|btrunc_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|nearbyint_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|rint_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|lrint_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|sincos_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|sin_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|asin_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cos_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|acos_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|exp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|exp10_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|exp2_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|expm1_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ldexp_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|logb_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ilogb_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|log_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|log10_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|log2_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|log1p_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|tan_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|atan_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|copysign_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|strlen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cbranch_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cmov_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|cstore_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|push_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|reduc_smax_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|reduc_umax_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|reduc_smin_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|reduc_umin_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|reduc_splus_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|reduc_uplus_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ssum_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|usum_widen_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|sdot_prod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|udot_prod_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|vec_extract_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|vec_set_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|vec_init_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|vec_shl_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|vec_shr_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|vec_realign_load_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|movmisalign_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|powi_optab
operator|=
name|init_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
comment|/* Conversions.  */
name|sext_optab
operator|=
name|init_convert_optab
argument_list|(
name|SIGN_EXTEND
argument_list|)
expr_stmt|;
name|zext_optab
operator|=
name|init_convert_optab
argument_list|(
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
name|trunc_optab
operator|=
name|init_convert_optab
argument_list|(
name|TRUNCATE
argument_list|)
expr_stmt|;
name|sfix_optab
operator|=
name|init_convert_optab
argument_list|(
name|FIX
argument_list|)
expr_stmt|;
name|ufix_optab
operator|=
name|init_convert_optab
argument_list|(
name|UNSIGNED_FIX
argument_list|)
expr_stmt|;
name|sfixtrunc_optab
operator|=
name|init_convert_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|ufixtrunc_optab
operator|=
name|init_convert_optab
argument_list|(
name|UNKNOWN
argument_list|)
expr_stmt|;
name|sfloat_optab
operator|=
name|init_convert_optab
argument_list|(
name|FLOAT
argument_list|)
expr_stmt|;
name|ufloat_optab
operator|=
name|init_convert_optab
argument_list|(
name|UNSIGNED_FLOAT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
name|movmem_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|cmpstr_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|cmpstrn_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|cmpmem_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|setmem_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_add_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_sub_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_ior_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_and_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_xor_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_nand_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_old_add_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_old_sub_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_old_ior_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_old_and_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_old_xor_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_old_nand_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_new_add_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_new_sub_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_new_ior_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_new_and_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_new_xor_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_new_nand_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_compare_and_swap
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_compare_and_swap_cc
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_lock_test_and_set
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|sync_lock_release
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|reload_in_optab
index|[
name|i
index|]
operator|=
name|reload_out_optab
index|[
name|i
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
block|}
comment|/* Fill in the optabs with the insns we support.  */
name|init_all_optabs
argument_list|()
expr_stmt|;
comment|/* Initialize the optabs with the names of the library functions.  */
name|init_integral_libfuncs
argument_list|(
name|add_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|add_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|addv_optab
argument_list|,
literal|"addv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|addv_optab
argument_list|,
literal|"add"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sub_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|sub_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|subv_optab
argument_list|,
literal|"subv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|subv_optab
argument_list|,
literal|"sub"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smul_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smul_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smulv_optab
argument_list|,
literal|"mulv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smulv_optab
argument_list|,
literal|"mul"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sdiv_optab
argument_list|,
literal|"div"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|sdiv_optab
argument_list|,
literal|"div"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sdivv_optab
argument_list|,
literal|"divv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|udiv_optab
argument_list|,
literal|"udiv"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|sdivmod_optab
argument_list|,
literal|"divmod"
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|udivmod_optab
argument_list|,
literal|"udivmod"
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smod_optab
argument_list|,
literal|"mod"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|umod_optab
argument_list|,
literal|"umod"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|ftrunc_optab
argument_list|,
literal|"ftrunc"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|and_optab
argument_list|,
literal|"and"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ior_optab
argument_list|,
literal|"ior"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|xor_optab
argument_list|,
literal|"xor"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ashl_optab
argument_list|,
literal|"ashl"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ashr_optab
argument_list|,
literal|"ashr"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|lshr_optab
argument_list|,
literal|"lshr"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smin_optab
argument_list|,
literal|"min"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smin_optab
argument_list|,
literal|"min"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|smax_optab
argument_list|,
literal|"max"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|smax_optab
argument_list|,
literal|"max"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|umin_optab
argument_list|,
literal|"umin"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|umax_optab
argument_list|,
literal|"umax"
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|neg_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|neg_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|negv_optab
argument_list|,
literal|"negv"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|negv_optab
argument_list|,
literal|"neg"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|one_cmpl_optab
argument_list|,
literal|"one_cmpl"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ffs_optab
argument_list|,
literal|"ffs"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|clz_optab
argument_list|,
literal|"clz"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ctz_optab
argument_list|,
literal|"ctz"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|popcount_optab
argument_list|,
literal|"popcount"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|parity_optab
argument_list|,
literal|"parity"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
comment|/* Comparison libcalls for integers MUST come in pairs,      signed/unsigned.  */
name|init_integral_libfuncs
argument_list|(
name|cmp_optab
argument_list|,
literal|"cmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_integral_libfuncs
argument_list|(
name|ucmp_optab
argument_list|,
literal|"ucmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|cmp_optab
argument_list|,
literal|"cmp"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
comment|/* EQ etc are floating point only.  */
name|init_floating_libfuncs
argument_list|(
name|eq_optab
argument_list|,
literal|"eq"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|ne_optab
argument_list|,
literal|"ne"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|gt_optab
argument_list|,
literal|"gt"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|ge_optab
argument_list|,
literal|"ge"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|lt_optab
argument_list|,
literal|"lt"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|le_optab
argument_list|,
literal|"le"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|unord_optab
argument_list|,
literal|"unord"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|init_floating_libfuncs
argument_list|(
name|powi_optab
argument_list|,
literal|"powi"
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
comment|/* Conversions.  */
name|init_interclass_conv_libfuncs
argument_list|(
name|sfloat_optab
argument_list|,
literal|"float"
argument_list|,
name|MODE_INT
argument_list|,
name|MODE_FLOAT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|sfloat_optab
argument_list|,
literal|"float"
argument_list|,
name|MODE_INT
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|ufloat_optab
argument_list|,
literal|"floatun"
argument_list|,
name|MODE_INT
argument_list|,
name|MODE_FLOAT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|ufloat_optab
argument_list|,
literal|"floatun"
argument_list|,
name|MODE_INT
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|sfix_optab
argument_list|,
literal|"fix"
argument_list|,
name|MODE_FLOAT
argument_list|,
name|MODE_INT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|sfix_optab
argument_list|,
literal|"fix"
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|,
name|MODE_INT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|ufix_optab
argument_list|,
literal|"fixuns"
argument_list|,
name|MODE_FLOAT
argument_list|,
name|MODE_INT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|ufix_optab
argument_list|,
literal|"fixuns"
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|,
name|MODE_INT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|ufloat_optab
argument_list|,
literal|"floatuns"
argument_list|,
name|MODE_INT
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|)
expr_stmt|;
comment|/* sext_optab is also used for FLOAT_EXTEND.  */
name|init_intraclass_conv_libfuncs
argument_list|(
name|sext_optab
argument_list|,
literal|"extend"
argument_list|,
name|MODE_FLOAT
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|init_intraclass_conv_libfuncs
argument_list|(
name|sext_optab
argument_list|,
literal|"extend"
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|sext_optab
argument_list|,
literal|"extend"
argument_list|,
name|MODE_FLOAT
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|sext_optab
argument_list|,
literal|"extend"
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|,
name|MODE_FLOAT
argument_list|)
expr_stmt|;
name|init_intraclass_conv_libfuncs
argument_list|(
name|trunc_optab
argument_list|,
literal|"trunc"
argument_list|,
name|MODE_FLOAT
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|init_intraclass_conv_libfuncs
argument_list|(
name|trunc_optab
argument_list|,
literal|"trunc"
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|trunc_optab
argument_list|,
literal|"trunc"
argument_list|,
name|MODE_FLOAT
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|)
expr_stmt|;
name|init_interclass_conv_libfuncs
argument_list|(
name|trunc_optab
argument_list|,
literal|"trunc"
argument_list|,
name|MODE_DECIMAL_FLOAT
argument_list|,
name|MODE_FLOAT
argument_list|)
expr_stmt|;
comment|/* Use cabs for double complex abs, since systems generally have cabs.      Don't define any libcall for float complex, so that cabs will be used.  */
if|if
condition|(
name|complex_double_type_node
condition|)
name|abs_optab
operator|->
name|handlers
index|[
name|TYPE_MODE
argument_list|(
name|complex_double_type_node
argument_list|)
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"cabs"
argument_list|)
expr_stmt|;
comment|/* The ffs function operates on `int'.  */
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode_for_size
argument_list|(
name|INT_TYPE_SIZE
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
index|]
operator|.
name|libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"ffs"
argument_list|)
expr_stmt|;
name|abort_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"abort"
argument_list|)
expr_stmt|;
name|memcpy_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memcpy"
argument_list|)
expr_stmt|;
name|memmove_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memmove"
argument_list|)
expr_stmt|;
name|memcmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memcmp"
argument_list|)
expr_stmt|;
name|memset_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"memset"
argument_list|)
expr_stmt|;
name|setbits_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__setbits"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DONT_USE_BUILTIN_SETJMP
name|setjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__builtin_setjmp"
argument_list|)
expr_stmt|;
name|longjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__builtin_longjmp"
argument_list|)
expr_stmt|;
else|#
directive|else
name|setjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"setjmp"
argument_list|)
expr_stmt|;
name|longjmp_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"longjmp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unwind_sjlj_register_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"_Unwind_SjLj_Register"
argument_list|)
expr_stmt|;
name|unwind_sjlj_unregister_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"_Unwind_SjLj_Unregister"
argument_list|)
expr_stmt|;
comment|/* For function entry/exit instrumentation.  */
name|profile_function_entry_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__cyg_profile_func_enter"
argument_list|)
expr_stmt|;
name|profile_function_exit_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__cyg_profile_func_exit"
argument_list|)
expr_stmt|;
name|gcov_flush_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__gcov_flush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_conditional_trap
condition|)
name|trap_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|EQ
argument_list|,
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Allow the target to add more libcalls or rename some, etc.  */
name|targetm
operator|.
name|init_libfuncs
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* Print information about the current contents of the optabs on    STDERR.  */
end_comment

begin_function
specifier|static
name|void
name|debug_optab_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* Dump the arithmetic optabs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
operator|(
name|int
operator|)
name|OTI_MAX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
operator|++
name|j
control|)
block|{
name|optab
name|o
decl_stmt|;
name|struct
name|optab_handlers
modifier|*
name|h
decl_stmt|;
name|o
operator|=
name|optab_table
index|[
name|i
index|]
expr_stmt|;
name|h
operator|=
operator|&
name|o
operator|->
name|handlers
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|libfunc
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|h
operator|->
name|libfunc
argument_list|)
operator|=
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t%s:\t%s\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|o
operator|->
name|code
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|j
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|h
operator|->
name|libfunc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Dump the conversion optabs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|COI_MAX
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_MACHINE_MODES
condition|;
operator|++
name|k
control|)
block|{
name|convert_optab
name|o
decl_stmt|;
name|struct
name|optab_handlers
modifier|*
name|h
decl_stmt|;
name|o
operator|=
operator|&
name|convert_optab_table
index|[
name|i
index|]
expr_stmt|;
name|h
operator|=
operator|&
name|o
operator|->
name|handlers
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|libfunc
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|h
operator|->
name|libfunc
argument_list|)
operator|=
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t%s\t%s:\t%s\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|o
operator|->
name|code
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|j
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|k
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|h
operator|->
name|libfunc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition    CODE.  Return 0 on failure.  */
end_comment

begin_function
name|rtx
name|gen_cond_trap
parameter_list|(
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|tcode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_conditional_trap
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|icode
operator|=
name|cmp_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|op1
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|prepare_operand
argument_list|(
name|icode
argument_list|,
name|op2
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op1
operator|||
operator|!
name|op2
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|trap_rtx
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|HAVE_conditional_trap
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_conditional_trap
argument_list|(
name|trap_rtx
argument_list|,
name|tcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return rtx code for TCODE. Use UNSIGNEDP to select signed    or unsigned operation code.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|get_rtx_code
parameter_list|(
name|enum
name|tree_code
name|tcode
parameter_list|,
name|bool
name|unsignedp
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
switch|switch
condition|(
name|tcode
condition|)
block|{
case|case
name|EQ_EXPR
case|:
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|unsignedp
condition|?
name|LTU
else|:
name|LT
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|unsignedp
condition|?
name|LEU
else|:
name|LE
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|unsignedp
condition|?
name|GTU
else|:
name|GT
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|unsignedp
condition|?
name|GEU
else|:
name|GE
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
name|code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|ORDERED_EXPR
case|:
name|code
operator|=
name|ORDERED
expr_stmt|;
break|break;
case|case
name|UNLT_EXPR
case|:
name|code
operator|=
name|UNLT
expr_stmt|;
break|break;
case|case
name|UNLE_EXPR
case|:
name|code
operator|=
name|UNLE
expr_stmt|;
break|break;
case|case
name|UNGT_EXPR
case|:
name|code
operator|=
name|UNGT
expr_stmt|;
break|break;
case|case
name|UNGE_EXPR
case|:
name|code
operator|=
name|UNGE
expr_stmt|;
break|break;
case|case
name|UNEQ_EXPR
case|:
name|code
operator|=
name|UNEQ
expr_stmt|;
break|break;
case|case
name|LTGT_EXPR
case|:
name|code
operator|=
name|LTGT
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Return comparison rtx for COND. Use UNSIGNEDP to select signed or    unsigned operators. Do not generate compare instruction.  */
end_comment

begin_function
specifier|static
name|rtx
name|vector_compare_rtx
parameter_list|(
name|tree
name|cond
parameter_list|,
name|bool
name|unsignedp
parameter_list|,
name|enum
name|insn_code
name|icode
parameter_list|)
block|{
name|enum
name|rtx_code
name|rcode
decl_stmt|;
name|tree
name|t_op0
decl_stmt|,
name|t_op1
decl_stmt|;
name|rtx
name|rtx_op0
decl_stmt|,
name|rtx_op1
decl_stmt|;
comment|/* This is unlikely. While generating VEC_COND_EXPR, auto vectorizer      ensures that condition is a relational operation.  */
name|gcc_assert
argument_list|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|get_rtx_code
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|t_op0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t_op1
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Expand operands.  */
name|rtx_op0
operator|=
name|expand_expr
argument_list|(
name|t_op0
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t_op0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rtx_op1
operator|=
name|expand_expr
argument_list|(
name|t_op1
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t_op1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|4
index|]
operator|.
name|predicate
argument_list|(
name|rtx_op0
argument_list|,
name|GET_MODE
argument_list|(
name|rtx_op0
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|rtx_op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|rtx_op0
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|rtx_op0
argument_list|)
argument_list|,
name|rtx_op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|5
index|]
operator|.
name|predicate
argument_list|(
name|rtx_op1
argument_list|,
name|GET_MODE
argument_list|(
name|rtx_op1
argument_list|)
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|rtx_op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|rtx_op1
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|rtx_op1
argument_list|)
argument_list|,
name|rtx_op1
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|rcode
argument_list|,
name|VOIDmode
argument_list|,
name|rtx_op0
argument_list|,
name|rtx_op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return insn code for VEC_COND_EXPR EXPR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|insn_code
name|get_vcond_icode
parameter_list|(
name|tree
name|expr
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|icode
operator|=
name|vcondu_gen_code
index|[
name|mode
index|]
expr_stmt|;
else|else
name|icode
operator|=
name|vcond_gen_code
index|[
name|mode
index|]
expr_stmt|;
return|return
name|icode
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff, appropriate vector insns are available    for vector cond expr expr in VMODE mode.  */
end_comment

begin_function
name|bool
name|expand_vec_cond_expr_p
parameter_list|(
name|tree
name|expr
parameter_list|,
name|enum
name|machine_mode
name|vmode
parameter_list|)
block|{
if|if
condition|(
name|get_vcond_icode
argument_list|(
name|expr
argument_list|,
name|vmode
argument_list|)
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate insns for VEC_COND_EXPR.  */
end_comment

begin_function
name|rtx
name|expand_vec_cond_expr
parameter_list|(
name|tree
name|vec_cond_expr
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|comparison
decl_stmt|,
name|rtx_op1
decl_stmt|,
name|rtx_op2
decl_stmt|,
name|cc_op0
decl_stmt|,
name|cc_op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vec_cond_expr
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|vec_cond_expr
argument_list|)
argument_list|)
decl_stmt|;
name|icode
operator|=
name|get_vcond_icode
argument_list|(
name|vec_cond_expr
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Get comparison rtx.  First expand both cond expr operands.  */
name|comparison
operator|=
name|vector_compare_rtx
argument_list|(
name|TREE_OPERAND
argument_list|(
name|vec_cond_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unsignedp
argument_list|,
name|icode
argument_list|)
expr_stmt|;
name|cc_op0
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_op1
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Expand both operands and force them in reg, if required.  */
name|rtx_op1
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|vec_cond_expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|rtx_op1
argument_list|,
name|mode
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
name|rtx_op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|rtx_op1
argument_list|)
expr_stmt|;
name|rtx_op2
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|vec_cond_expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|rtx_op2
argument_list|,
name|mode
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
name|rtx_op2
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|rtx_op2
argument_list|)
expr_stmt|;
comment|/* Emit instruction! */
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|rtx_op1
argument_list|,
name|rtx_op2
argument_list|,
name|comparison
argument_list|,
name|cc_op0
argument_list|,
name|cc_op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is an internal subroutine of the other compare_and_swap expanders.    MEM, OLD_VAL and NEW_VAL are as you'd expect for a compare-and-swap    operation.  TARGET is an optional place to store the value result of    the operation.  ICODE is the particular instruction to expand.  Return    the result of the operation.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_val_compare_and_swap_1
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|old_val
parameter_list|,
name|rtx
name|new_val
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|insn_code
name|icode
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|old_val
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|old_val
argument_list|)
operator|!=
name|mode
condition|)
name|old_val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|old_val
argument_list|)
argument_list|,
name|old_val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|old_val
argument_list|,
name|mode
argument_list|)
condition|)
name|old_val
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|old_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|new_val
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|new_val
argument_list|)
operator|!=
name|mode
condition|)
name|new_val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|new_val
argument_list|)
argument_list|,
name|new_val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
argument_list|(
name|new_val
argument_list|,
name|mode
argument_list|)
condition|)
name|new_val
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|new_val
argument_list|)
expr_stmt|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|mem
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a compare-and-swap operation and return its value.  */
end_comment

begin_function
name|rtx
name|expand_val_compare_and_swap
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|old_val
parameter_list|,
name|rtx
name|new_val
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|sync_compare_and_swap
index|[
name|mode
index|]
decl_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|expand_val_compare_and_swap_1
argument_list|(
name|mem
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|target
argument_list|,
name|icode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a compare-and-swap operation and store true into the result if    the operation was successful and false otherwise.  Return the result.    Unlike other routines, TARGET is not optional.  */
end_comment

begin_function
name|rtx
name|expand_bool_compare_and_swap
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|old_val
parameter_list|,
name|rtx
name|new_val
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|,
name|label0
decl_stmt|,
name|label1
decl_stmt|;
comment|/* If the target supports a compare-and-swap pattern that simultaneously      sets some flag for success, then use it.  Otherwise use the regular      compare-and-swap and follow that immediately with a compare insn.  */
name|icode
operator|=
name|sync_compare_and_swap_cc
index|[
name|mode
index|]
expr_stmt|;
switch|switch
condition|(
name|icode
condition|)
block|{
default|default:
name|subtarget
operator|=
name|expand_val_compare_and_swap_1
argument_list|(
name|mem
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|NULL_RTX
argument_list|,
name|icode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtarget
operator|!=
name|NULL_RTX
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|CODE_FOR_nothing
case|:
name|icode
operator|=
name|sync_compare_and_swap
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Ensure that if old_val == mem, that we're not comparing 	 against an old value.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|old_val
argument_list|)
condition|)
name|old_val
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|old_val
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|expand_val_compare_and_swap_1
argument_list|(
name|mem
argument_list|,
name|old_val
argument_list|,
name|new_val
argument_list|,
name|NULL_RTX
argument_list|,
name|icode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtarget
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
name|emit_cmp_insn
argument_list|(
name|subtarget
argument_list|,
name|old_val
argument_list|,
name|EQ
argument_list|,
name|const0_rtx
argument_list|,
name|mode
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* If the target has a sane STORE_FLAG_VALUE, then go ahead and use a      setcc instruction from the beginning.  We don't work too hard here,      but it's nice to not be stupid about initial code gen either.  */
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|)
block|{
name|icode
operator|=
name|setcc_gen_code
index|[
name|EQ
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|enum
name|machine_mode
name|cmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|subtarget
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|cmode
argument_list|)
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|cmode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|subtarget
argument_list|)
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|target
expr_stmt|;
block|}
return|return
name|subtarget
return|;
block|}
block|}
block|}
comment|/* Without an appropriate setcc instruction, use a set of branches to      get 1 and 0 stored into target.  Presumably if the target has a      STORE_FLAG_VALUE that isn't 1, then this will get cleaned up by ifcvt.  */
name|label0
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
argument|bcc_gen_fctn[EQ] (label0)
argument_list|)
empty_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* This is a helper function for the other atomic operations.  This function    emits a loop that contains SEQ that iterates until a compare-and-swap    operation at the end succeeds.  MEM is the memory to be modified.  SEQ is    a set of instructions that takes a value from OLD_REG as an input and    produces a value in NEW_REG as an output.  Before SEQ, OLD_REG will be    set to the current contents of MEM.  After SEQ, a compare-and-swap will    attempt to update MEM with NEW_REG.  The function returns true when the    loop was generated successfully.  */
end_comment

begin_function
specifier|static
name|bool
name|expand_compare_and_swap_loop
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|old_reg
parameter_list|,
name|rtx
name|new_reg
parameter_list|,
name|rtx
name|seq
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|label
decl_stmt|,
name|cmp_reg
decl_stmt|,
name|subtarget
decl_stmt|;
comment|/* The loop we want to generate looks like  	cmp_reg = mem;       label:         old_reg = cmp_reg; 	seq; 	cmp_reg = compare-and-swap(mem, old_reg, new_reg) 	if (cmp_reg != old_reg) 	  goto label;       Note that we only do the plain load from memory once.  Subsequent      iterations use the value loaded by the compare-and-swap pattern.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|cmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cmp_reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|old_reg
argument_list|,
name|cmp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
condition|)
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* If the target supports a compare-and-swap pattern that simultaneously      sets some flag for success, then use it.  Otherwise use the regular      compare-and-swap and follow that immediately with a compare insn.  */
name|icode
operator|=
name|sync_compare_and_swap_cc
index|[
name|mode
index|]
expr_stmt|;
switch|switch
condition|(
name|icode
condition|)
block|{
default|default:
name|subtarget
operator|=
name|expand_val_compare_and_swap_1
argument_list|(
name|mem
argument_list|,
name|old_reg
argument_list|,
name|new_reg
argument_list|,
name|cmp_reg
argument_list|,
name|icode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtarget
operator|!=
name|NULL_RTX
condition|)
block|{
name|gcc_assert
argument_list|(
name|subtarget
operator|==
name|cmp_reg
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|CODE_FOR_nothing
case|:
name|icode
operator|=
name|sync_compare_and_swap
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|false
return|;
name|subtarget
operator|=
name|expand_val_compare_and_swap_1
argument_list|(
name|mem
argument_list|,
name|old_reg
argument_list|,
name|new_reg
argument_list|,
name|cmp_reg
argument_list|,
name|icode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtarget
operator|==
name|NULL_RTX
condition|)
return|return
name|false
return|;
if|if
condition|(
name|subtarget
operator|!=
name|cmp_reg
condition|)
name|emit_move_insn
argument_list|(
name|cmp_reg
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|cmp_reg
argument_list|,
name|old_reg
argument_list|,
name|EQ
argument_list|,
name|const0_rtx
argument_list|,
name|mode
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* ??? Mark this jump predicted not taken?  */
name|emit_jump_insn
argument_list|(
argument|bcc_gen_fctn[NE] (label)
argument_list|)
empty_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function generates the atomic operation MEM CODE= VAL.  In this    case, we do not care about any resulting value.  Returns NULL if we    cannot generate the operation.  */
end_comment

begin_function
name|rtx
name|expand_sync_operation
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Look to see if the target supports the operation directly.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|icode
operator|=
name|sync_add_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|icode
operator|=
name|sync_ior_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|icode
operator|=
name|sync_xor_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|icode
operator|=
name|sync_and_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|icode
operator|=
name|sync_nand_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|icode
operator|=
name|sync_sub_optab
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
block|{
name|icode
operator|=
name|sync_add_optab
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|val
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NEG
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|PLUS
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Generate the direct operation, if present.  */
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
condition|)
name|val
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|mem
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
comment|/* Failing that, generate a compare-and-swap loop in which we perform the      operation with normal arithmetic instructions.  */
if|if
condition|(
name|sync_compare_and_swap
index|[
name|mode
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|t0
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|,
name|t1
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|t1
operator|=
name|t0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOT
condition|)
block|{
name|t1
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|t1
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|code
operator|=
name|AND
expr_stmt|;
block|}
name|t1
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|code
argument_list|,
name|t1
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL
operator|&&
name|expand_compare_and_swap_loop
argument_list|(
name|mem
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* This function generates the atomic operation MEM CODE= VAL.  In this    case, we do care about the resulting value: if AFTER is true then    return the value MEM holds after the operation, if AFTER is false    then return the value MEM holds before the operation.  TARGET is an    optional place for the result value to be stored.  */
end_comment

begin_function
name|rtx
name|expand_sync_fetch_operation
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|bool
name|after
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|old_code
decl_stmt|,
name|new_code
decl_stmt|,
name|icode
decl_stmt|;
name|bool
name|compensate
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Look to see if the target supports the operation directly.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|old_code
operator|=
name|sync_old_add_optab
index|[
name|mode
index|]
expr_stmt|;
name|new_code
operator|=
name|sync_new_add_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|old_code
operator|=
name|sync_old_ior_optab
index|[
name|mode
index|]
expr_stmt|;
name|new_code
operator|=
name|sync_new_ior_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|old_code
operator|=
name|sync_old_xor_optab
index|[
name|mode
index|]
expr_stmt|;
name|new_code
operator|=
name|sync_new_xor_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|old_code
operator|=
name|sync_old_and_optab
index|[
name|mode
index|]
expr_stmt|;
name|new_code
operator|=
name|sync_new_and_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|old_code
operator|=
name|sync_old_nand_optab
index|[
name|mode
index|]
expr_stmt|;
name|new_code
operator|=
name|sync_new_nand_optab
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|old_code
operator|=
name|sync_old_sub_optab
index|[
name|mode
index|]
expr_stmt|;
name|new_code
operator|=
name|sync_new_sub_optab
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|old_code
operator|==
name|CODE_FOR_nothing
operator|&&
name|new_code
operator|==
name|CODE_FOR_nothing
condition|)
block|{
name|old_code
operator|=
name|sync_old_add_optab
index|[
name|mode
index|]
expr_stmt|;
name|new_code
operator|=
name|sync_new_add_optab
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|old_code
operator|!=
name|CODE_FOR_nothing
operator|||
name|new_code
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|val
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NEG
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|PLUS
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If the target does supports the proper new/old operation, great.  But      if we only support the opposite old/new operation, check to see if we      can compensate.  In the case in which the old value is supported, then      we can always perform the operation again with normal arithmetic.  In      the case in which the new value is supported, then we can only handle      this in the case the operation is reversible.  */
name|compensate
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|icode
operator|=
name|new_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
block|{
name|icode
operator|=
name|old_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
name|compensate
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|icode
operator|=
name|old_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|XOR
operator|)
condition|)
block|{
name|icode
operator|=
name|new_code
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
name|compensate
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If we found something supported, great.  */
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
condition|)
name|val
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|mem
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If we need to compensate for using an operation with the 	     wrong return value, do so now.  */
if|if
condition|(
name|compensate
condition|)
block|{
if|if
condition|(
operator|!
name|after
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
name|code
operator|=
name|MINUS
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|code
operator|=
name|PLUS
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|NOT
condition|)
name|target
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|code
argument_list|,
name|target
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
block|}
comment|/* Failing that, generate a compare-and-swap loop in which we perform the      operation with normal arithmetic instructions.  */
if|if
condition|(
name|sync_compare_and_swap
index|[
name|mode
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|rtx
name|t0
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|,
name|t1
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|after
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|t0
argument_list|)
expr_stmt|;
name|t1
operator|=
name|t0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOT
condition|)
block|{
name|t1
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|t1
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|code
operator|=
name|AND
expr_stmt|;
block|}
name|t1
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|code
argument_list|,
name|t1
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL
operator|&&
name|expand_compare_and_swap_loop
argument_list|(
name|mem
argument_list|,
name|t0
argument_list|,
name|t1
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|target
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* This function expands a test-and-set operation.  Ideally we atomically    store VAL in MEM and return the previous value in MEM.  Some targets    may not support this operation and only support VAL with the constant 1;    in this case while the return value will be 0/1, but the exact value    stored in MEM is target defined.  TARGET is an option place to stick    the return value.  */
end_comment

begin_function
name|rtx
name|expand_sync_lock_test_and_set
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* If the target supports the test-and-set directly, great.  */
name|icode
operator|=
name|sync_lock_test_and_set
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
condition|)
name|val
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|insn
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|mem
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
block|}
comment|/* Otherwise, use a compare-and-swap loop for the exchange.  */
if|if
condition|(
name|sync_compare_and_swap
index|[
name|mode
index|]
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|!=
name|mode
condition|)
name|val
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|GET_MODE
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_compare_and_swap_loop
argument_list|(
name|mem
argument_list|,
name|target
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
name|target
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-optabs.h"
end_include

end_unit

