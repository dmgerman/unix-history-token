begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Loop transformation code generation     Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.     Contributed by Daniel Berlin<dberlin@dberlin.org>      This file is part of GCC.          GCC is free software; you can redistribute it and/or modify it under     the terms of the GNU General Public License as published by the Free     Software Foundation; either version 2, or (at your option) any later     version.          GCC is distributed in the hope that it will be useful, but WITHOUT ANY     WARRANTY; without even the implied warranty of MERCHANTABILITY or     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License     for more details.          You should have received a copy of the GNU General Public License     along with GCC; see the file COPYING.  If not, write to the Free     Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA     02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"lambda.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_comment
comment|/* This loop nest code generation is based on non-singular matrix    math.    A little terminology and a general sketch of the algorithm.  See "A singular  loop transformation framework based on non-singular matrices" by Wei Li and  Keshav Pingali for formal proofs that the various statements below are  correct.    A loop iteration space represents the points traversed by the loop.  A point in the  iteration space can be represented by a vector of size<loop depth>.  You can  therefore represent the iteration space as an integral combinations of a set  of basis vectors.    A loop iteration space is dense if every integer point between the loop  bounds is a point in the iteration space.  Every loop with a step of 1  therefore has a dense iteration space.   for i = 1 to 3, step 1 is a dense iteration space.      A loop iteration space is sparse if it is not dense.  That is, the iteration  space skips integer points that are within the loop bounds.     for i = 1 to 3, step 2 is a sparse iteration space, because the integer point  2 is skipped.   Dense source spaces are easy to transform, because they don't skip any  points to begin with.  Thus we can compute the exact bounds of the target  space using min/max and floor/ceil.   For a dense source space, we take the transformation matrix, decompose it  into a lower triangular part (H) and a unimodular part (U).   We then compute the auxiliary space from the unimodular part (source loop  nest . U = auxiliary space) , which has two important properties:   1. It traverses the iterations in the same lexicographic order as the source   space.   2. It is a dense space when the source is a dense space (even if the target   space is going to be sparse).    Given the auxiliary space, we use the lower triangular part to compute the  bounds in the target space by simple matrix multiplication.  The gaps in the target space (IE the new loop step sizes) will be the  diagonals of the H matrix.   Sparse source spaces require another step, because you can't directly compute  the exact bounds of the auxiliary and target space from the sparse space.  Rather than try to come up with a separate algorithm to handle sparse source  spaces directly, we just find a legal transformation matrix that gives you  the sparse source space, from a dense space, and then transform the dense  space.   For a regular sparse space, you can represent the source space as an integer  lattice, and the base space of that lattice will always be dense.  Thus, we  effectively use the lattice to figure out the transformation from the lattice  base space, to the sparse iteration space (IE what transform was applied to  the dense space to make it sparse).  We then compose this transform with the  transformation matrix specified by the user (since our matrix transformations  are closed under composition, this is okay).  We can then use the base space  (which is dense) plus the composed transformation matrix, to compute the rest  of the transform using the dense space algorithm above.    In other words, our sparse source space (B) is decomposed into a dense base  space (A), and a matrix (L) that transforms A into B, such that A.L = B.  We then compute the composition of L and the user transformation matrix (T),  so that T is now a transform from A to the result, instead of from B to the  result.   IE A.(LT) = result instead of B.T = result  Since A is now a dense source space, we can use the dense source space  algorithm above to compute the result of applying transform (LT) to A.   Fourier-Motzkin elimination is used to compute the bounds of the base space  of the lattice.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|perfect_nestify
argument_list|(
expr|struct
name|loops
operator|*
argument_list|,
expr|struct
name|loop
operator|*
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lattice stuff that is internal to the code generation algorithm.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Lattice base matrix.  */
name|lambda_matrix
name|base
decl_stmt|;
comment|/* Lattice dimension.  */
name|int
name|dimension
decl_stmt|;
comment|/* Origin vector for the coefficients.  */
name|lambda_vector
name|origin
decl_stmt|;
comment|/* Origin matrix for the invariants.  */
name|lambda_matrix
name|origin_invariants
decl_stmt|;
comment|/* Number of invariants.  */
name|int
name|invariants
decl_stmt|;
block|}
typedef|*
name|lambda_lattice
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LATTICE_BASE
parameter_list|(
name|T
parameter_list|)
value|((T)->base)
end_define

begin_define
define|#
directive|define
name|LATTICE_DIMENSION
parameter_list|(
name|T
parameter_list|)
value|((T)->dimension)
end_define

begin_define
define|#
directive|define
name|LATTICE_ORIGIN
parameter_list|(
name|T
parameter_list|)
value|((T)->origin)
end_define

begin_define
define|#
directive|define
name|LATTICE_ORIGIN_INVARIANTS
parameter_list|(
name|T
parameter_list|)
value|((T)->origin_invariants)
end_define

begin_define
define|#
directive|define
name|LATTICE_INVARIANTS
parameter_list|(
name|T
parameter_list|)
value|((T)->invariants)
end_define

begin_function_decl
specifier|static
name|bool
name|lle_equal
parameter_list|(
name|lambda_linear_expression
parameter_list|,
name|lambda_linear_expression
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|lambda_lattice
name|lambda_lattice_new
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|lambda_lattice
name|lambda_lattice_compute_base
parameter_list|(
name|lambda_loopnest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|find_induction_var_from_exit_cond
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|can_convert_to_perfect_nest
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create a new lambda body vector.  */
end_comment

begin_function
name|lambda_body_vector
name|lambda_body_vector_new
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|lambda_body_vector
name|ret
decl_stmt|;
name|ret
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|LBV_COEFFICIENTS
argument_list|(
name|ret
argument_list|)
operator|=
name|lambda_vector_new
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|LBV_SIZE
argument_list|(
name|ret
argument_list|)
operator|=
name|size
expr_stmt|;
name|LBV_DENOMINATOR
argument_list|(
name|ret
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Compute the new coefficients for the vector based on the   *inverse* of the transformation matrix.  */
end_comment

begin_function
name|lambda_body_vector
name|lambda_body_vector_compute_new
parameter_list|(
name|lambda_trans_matrix
name|transform
parameter_list|,
name|lambda_body_vector
name|vect
parameter_list|)
block|{
name|lambda_body_vector
name|temp
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* Make sure the matrix is square.  */
name|gcc_assert
argument_list|(
name|LTM_ROWSIZE
argument_list|(
name|transform
argument_list|)
operator|==
name|LTM_COLSIZE
argument_list|(
name|transform
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|=
name|LTM_ROWSIZE
argument_list|(
name|transform
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lambda_body_vector_new
argument_list|(
name|depth
argument_list|)
expr_stmt|;
name|LBV_DENOMINATOR
argument_list|(
name|temp
argument_list|)
operator|=
name|LBV_DENOMINATOR
argument_list|(
name|vect
argument_list|)
operator|*
name|LTM_DENOMINATOR
argument_list|(
name|transform
argument_list|)
expr_stmt|;
name|lambda_vector_matrix_mult
argument_list|(
name|LBV_COEFFICIENTS
argument_list|(
name|vect
argument_list|)
argument_list|,
name|depth
argument_list|,
name|LTM_MATRIX
argument_list|(
name|transform
argument_list|)
argument_list|,
name|depth
argument_list|,
name|LBV_COEFFICIENTS
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|LBV_SIZE
argument_list|(
name|temp
argument_list|)
operator|=
name|LBV_SIZE
argument_list|(
name|vect
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Print out a lambda body vector.  */
end_comment

begin_function
name|void
name|print_lambda_body_vector
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|lambda_body_vector
name|body
parameter_list|)
block|{
name|print_lambda_vector
argument_list|(
name|outfile
argument_list|,
name|LBV_COEFFICIENTS
argument_list|(
name|body
argument_list|)
argument_list|,
name|LBV_SIZE
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if two linear expressions are equal.  */
end_comment

begin_function
specifier|static
name|bool
name|lle_equal
parameter_list|(
name|lambda_linear_expression
name|lle1
parameter_list|,
name|lambda_linear_expression
name|lle2
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|invariants
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lle1
operator|==
name|NULL
operator|||
name|lle2
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|LLE_CONSTANT
argument_list|(
name|lle1
argument_list|)
operator|!=
name|LLE_CONSTANT
argument_list|(
name|lle2
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|LLE_DENOMINATOR
argument_list|(
name|lle1
argument_list|)
operator|!=
name|LLE_DENOMINATOR
argument_list|(
name|lle2
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|LLE_COEFFICIENTS
argument_list|(
name|lle1
argument_list|)
index|[
name|i
index|]
operator|!=
name|LLE_COEFFICIENTS
argument_list|(
name|lle2
argument_list|)
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|invariants
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|lle1
argument_list|)
index|[
name|i
index|]
operator|!=
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|lle2
argument_list|)
index|[
name|i
index|]
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a new linear expression with dimension DIM, and total number    of invariants INVARIANTS.  */
end_comment

begin_function
name|lambda_linear_expression
name|lambda_linear_expression_new
parameter_list|(
name|int
name|dim
parameter_list|,
name|int
name|invariants
parameter_list|)
block|{
name|lambda_linear_expression
name|ret
decl_stmt|;
name|ret
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|LLE_COEFFICIENTS
argument_list|(
name|ret
argument_list|)
operator|=
name|lambda_vector_new
argument_list|(
name|dim
argument_list|)
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|ret
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|ret
argument_list|)
operator|=
name|lambda_vector_new
argument_list|(
name|invariants
argument_list|)
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|ret
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LLE_NEXT
argument_list|(
name|ret
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Print out a linear expression EXPR, with SIZE coefficients, to OUTFILE.    The starting letter used for variable names is START.  */
end_comment

begin_function
specifier|static
name|void
name|print_linear_expression
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|lambda_vector
name|expr
parameter_list|,
name|int
name|size
parameter_list|,
name|char
name|start
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|expr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|expr
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|)
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%c"
argument_list|,
name|start
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d%c"
argument_list|,
name|abs
argument_list|(
name|expr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|start
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print out a lambda linear expression structure, EXPR, to OUTFILE. The    depth/number of coefficients is given by DEPTH, the number of invariants is    given by INVARIANTS, and the character to start variable names with is given    by START.  */
end_comment

begin_function
name|void
name|print_lambda_linear_expression
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|lambda_linear_expression
name|expr
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|invariants
parameter_list|,
name|char
name|start
parameter_list|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tLinear expression: "
argument_list|)
expr_stmt|;
name|print_linear_expression
argument_list|(
name|outfile
argument_list|,
name|LLE_COEFFICIENTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|depth
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" constant: %d "
argument_list|,
name|LLE_CONSTANT
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  invariants: "
argument_list|)
expr_stmt|;
name|print_linear_expression
argument_list|(
name|outfile
argument_list|,
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|invariants
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  denominator: %d\n"
argument_list|,
name|LLE_DENOMINATOR
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a lambda loop structure LOOP to OUTFILE.  The depth/number of    coefficients is given by DEPTH, the number of invariants is     given by INVARIANTS, and the character to start variable names with is given    by START.  */
end_comment

begin_function
name|void
name|print_lambda_loop
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|lambda_loop
name|loop
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|invariants
parameter_list|,
name|char
name|start
parameter_list|)
block|{
name|int
name|step
decl_stmt|;
name|lambda_linear_expression
name|expr
decl_stmt|;
name|gcc_assert
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|expr
operator|=
name|LL_LINEAR_OFFSET
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|step
operator|=
name|LL_STEP
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  step size = %d \n"
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  linear offset: \n"
argument_list|)
expr_stmt|;
name|print_lambda_linear_expression
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  lower bound: \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|loop
argument_list|)
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|LLE_NEXT
argument_list|(
name|expr
argument_list|)
control|)
name|print_lambda_linear_expression
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  upper bound: \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|expr
operator|=
name|LL_UPPER_BOUND
argument_list|(
name|loop
argument_list|)
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|LLE_NEXT
argument_list|(
name|expr
argument_list|)
control|)
name|print_lambda_linear_expression
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new loop nest structure with DEPTH loops, and INVARIANTS as the    number of invariants.  */
end_comment

begin_function
name|lambda_loopnest
name|lambda_loopnest_new
parameter_list|(
name|int
name|depth
parameter_list|,
name|int
name|invariants
parameter_list|)
block|{
name|lambda_loopnest
name|ret
decl_stmt|;
name|ret
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|LN_LOOPS
argument_list|(
name|ret
argument_list|)
operator|=
name|ggc_alloc_cleared
argument_list|(
name|depth
operator|*
sizeof|sizeof
argument_list|(
name|lambda_loop
argument_list|)
argument_list|)
expr_stmt|;
name|LN_DEPTH
argument_list|(
name|ret
argument_list|)
operator|=
name|depth
expr_stmt|;
name|LN_INVARIANTS
argument_list|(
name|ret
argument_list|)
operator|=
name|invariants
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Print a lambda loopnest structure, NEST, to OUTFILE.  The starting    character to use for loop names is given by START.  */
end_comment

begin_function
name|void
name|print_lambda_loopnest
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|lambda_loopnest
name|nest
parameter_list|,
name|char
name|start
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LN_DEPTH
argument_list|(
name|nest
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Loop %c\n"
argument_list|,
name|start
operator|+
name|i
argument_list|)
expr_stmt|;
name|print_lambda_loop
argument_list|(
name|outfile
argument_list|,
name|LN_LOOPS
argument_list|(
name|nest
argument_list|)
index|[
name|i
index|]
argument_list|,
name|LN_DEPTH
argument_list|(
name|nest
argument_list|)
argument_list|,
name|LN_INVARIANTS
argument_list|(
name|nest
argument_list|)
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate a new lattice structure of DEPTH x DEPTH, with INVARIANTS number    of invariants.  */
end_comment

begin_function
specifier|static
name|lambda_lattice
name|lambda_lattice_new
parameter_list|(
name|int
name|depth
parameter_list|,
name|int
name|invariants
parameter_list|)
block|{
name|lambda_lattice
name|ret
decl_stmt|;
name|ret
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|LATTICE_BASE
argument_list|(
name|ret
argument_list|)
operator|=
name|lambda_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|LATTICE_ORIGIN
argument_list|(
name|ret
argument_list|)
operator|=
name|lambda_vector_new
argument_list|(
name|depth
argument_list|)
expr_stmt|;
name|LATTICE_ORIGIN_INVARIANTS
argument_list|(
name|ret
argument_list|)
operator|=
name|lambda_matrix_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|LATTICE_DIMENSION
argument_list|(
name|ret
argument_list|)
operator|=
name|depth
expr_stmt|;
name|LATTICE_INVARIANTS
argument_list|(
name|ret
argument_list|)
operator|=
name|invariants
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Compute the lattice base for NEST.  The lattice base is essentially a    non-singular transform from a dense base space to a sparse iteration space.    We use it so that we don't have to specially handle the case of a sparse    iteration space in other parts of the algorithm.  As a result, this routine    only does something interesting (IE produce a matrix that isn't the    identity matrix) if NEST is a sparse space.  */
end_comment

begin_function
specifier|static
name|lambda_lattice
name|lambda_lattice_compute_base
parameter_list|(
name|lambda_loopnest
name|nest
parameter_list|)
block|{
name|lambda_lattice
name|ret
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|invariants
decl_stmt|;
name|lambda_matrix
name|base
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|step
decl_stmt|;
name|lambda_loop
name|loop
decl_stmt|;
name|lambda_linear_expression
name|expression
decl_stmt|;
name|depth
operator|=
name|LN_DEPTH
argument_list|(
name|nest
argument_list|)
expr_stmt|;
name|invariants
operator|=
name|LN_INVARIANTS
argument_list|(
name|nest
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lambda_lattice_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|base
operator|=
name|LATTICE_BASE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|LN_LOOPS
argument_list|(
name|nest
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|step
operator|=
name|LL_STEP
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* If we have a step of 1, then the base is one, and the          origin and invariant coefficients are 0.  */
if|if
condition|(
name|step
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|depth
condition|;
name|j
operator|++
control|)
name|base
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|base
index|[
name|i
index|]
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|LATTICE_ORIGIN
argument_list|(
name|ret
argument_list|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|LATTICE_ORIGIN_INVARIANTS
argument_list|(
name|ret
argument_list|)
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we need the lower bound expression (which must 	     be an affine function)  to determine the base.  */
name|expression
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|expression
operator|&&
operator|!
name|LLE_NEXT
argument_list|(
name|expression
argument_list|)
operator|&&
name|LLE_DENOMINATOR
argument_list|(
name|expression
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* The lower triangular portion of the base is going to be the 	     coefficient times the step */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|base
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LLE_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|j
index|]
operator|*
name|LL_STEP
argument_list|(
name|LN_LOOPS
argument_list|(
name|nest
argument_list|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|base
index|[
name|i
index|]
index|[
name|i
index|]
operator|=
name|step
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|depth
condition|;
name|j
operator|++
control|)
name|base
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Origin for this loop is the constant of the lower bound 	     expression.  */
name|LATTICE_ORIGIN
argument_list|(
name|ret
argument_list|)
index|[
name|i
index|]
operator|=
name|LLE_CONSTANT
argument_list|(
name|expression
argument_list|)
expr_stmt|;
comment|/* Coefficient for the invariants are equal to the invariant 	     coefficients in the expression.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|LATTICE_ORIGIN_INVARIANTS
argument_list|(
name|ret
argument_list|)
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Compute the least common multiple of two numbers A and B .  */
end_comment

begin_function
specifier|static
name|int
name|lcm
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|abs
argument_list|(
name|a
argument_list|)
operator|*
name|abs
argument_list|(
name|b
argument_list|)
operator|/
name|gcd
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform Fourier-Motzkin elimination to calculate the bounds of the    auxiliary nest.    Fourier-Motzkin is a way of reducing systems of linear inequalities so that    it is easy to calculate the answer and bounds.    A sketch of how it works:    Given a system of linear inequalities, ai * xj>= bk, you can always    rewrite the constraints so they are all of the form    a<= x, or x<= b, or x>= constant for some x in x1 ... xj (and some b    in b1 ... bk, and some a in a1...ai)    You can then eliminate this x from the non-constant inequalities by    rewriting these as a<= b, x>= constant, and delete the x variable.    You can then repeat this for any remaining x variables, and then we have    an easy to use variable<= constant (or no variables at all) form that we    can construct our bounds from.         In our case, each time we eliminate, we construct part of the bound from    the ith variable, then delete the ith variable.         Remember the constant are in our vector a, our coefficient matrix is A,    and our invariant coefficient matrix is B.        SIZE is the size of the matrices being passed.    DEPTH is the loop nest depth.    INVARIANTS is the number of loop invariants.    A, B, and a are the coefficient matrix, invariant coefficient, and a    vector of constants, respectively.  */
end_comment

begin_function
specifier|static
name|lambda_loopnest
name|compute_nest_using_fourier_motzkin
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|invariants
parameter_list|,
name|lambda_matrix
name|A
parameter_list|,
name|lambda_matrix
name|B
parameter_list|,
name|lambda_vector
name|a
parameter_list|)
block|{
name|int
name|multiple
decl_stmt|,
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|lambda_linear_expression
name|expression
decl_stmt|;
name|lambda_loop
name|loop
decl_stmt|;
name|lambda_loopnest
name|auxillary_nest
decl_stmt|;
name|lambda_matrix
name|swapmatrix
decl_stmt|,
name|A1
decl_stmt|,
name|B1
decl_stmt|;
name|lambda_vector
name|swapvector
decl_stmt|,
name|a1
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|A1
operator|=
name|lambda_matrix_new
argument_list|(
literal|128
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|B1
operator|=
name|lambda_matrix_new
argument_list|(
literal|128
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|a1
operator|=
name|lambda_vector_new
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|auxillary_nest
operator|=
name|lambda_loopnest_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|depth
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|loop
operator|=
name|lambda_loop_new
argument_list|()
expr_stmt|;
name|LN_LOOPS
argument_list|(
name|auxillary_nest
argument_list|)
index|[
name|i
index|]
operator|=
name|loop
expr_stmt|;
name|LL_STEP
argument_list|(
name|loop
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|A
index|[
name|j
index|]
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
comment|/* Any linear expression in the matrix with a coefficient less 		 than 0 becomes part of the new lower bound.  */
name|expression
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
name|LLE_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|k
index|]
operator|=
name|A
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|invariants
condition|;
name|k
operator|++
control|)
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|k
index|]
operator|=
operator|-
literal|1
operator|*
name|B
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|expression
argument_list|)
operator|=
operator|-
literal|1
operator|*
name|A
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|expression
argument_list|)
operator|=
operator|-
literal|1
operator|*
name|a
index|[
name|j
index|]
expr_stmt|;
comment|/* Ignore if identical to the existing lower bound.  */
if|if
condition|(
operator|!
name|lle_equal
argument_list|(
name|LL_LOWER_BOUND
argument_list|(
name|loop
argument_list|)
argument_list|,
name|expression
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|)
condition|)
block|{
name|LLE_NEXT
argument_list|(
name|expression
argument_list|)
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|LL_LOWER_BOUND
argument_list|(
name|loop
argument_list|)
operator|=
name|expression
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|A
index|[
name|j
index|]
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
comment|/* Any linear expression with a coefficient greater than 0 		 becomes part of the new upper bound.  */
name|expression
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
name|LLE_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|k
index|]
operator|=
operator|-
literal|1
operator|*
name|A
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|invariants
condition|;
name|k
operator|++
control|)
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|k
index|]
operator|=
name|B
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|expression
argument_list|)
operator|=
name|A
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|expression
argument_list|)
operator|=
name|a
index|[
name|j
index|]
expr_stmt|;
comment|/* Ignore if identical to the existing upper bound.  */
if|if
condition|(
operator|!
name|lle_equal
argument_list|(
name|LL_UPPER_BOUND
argument_list|(
name|loop
argument_list|)
argument_list|,
name|expression
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|)
condition|)
block|{
name|LLE_NEXT
argument_list|(
name|expression
argument_list|)
operator|=
name|LL_UPPER_BOUND
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|LL_UPPER_BOUND
argument_list|(
name|loop
argument_list|)
operator|=
name|expression
expr_stmt|;
block|}
block|}
block|}
comment|/* This portion creates a new system of linear inequalities by deleting 	 the i'th variable, reducing the system by one variable.  */
name|newsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
block|{
comment|/* If the coefficient for the i'th variable is 0, then we can just 	     eliminate the variable straightaway.  Otherwise, we have to 	     multiply through by the coefficients we are eliminating.  */
if|if
condition|(
name|A
index|[
name|j
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|lambda_vector_copy
argument_list|(
name|A
index|[
name|j
index|]
argument_list|,
name|A1
index|[
name|newsize
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|lambda_vector_copy
argument_list|(
name|B
index|[
name|j
index|]
argument_list|,
name|B1
index|[
name|newsize
index|]
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|a1
index|[
name|newsize
index|]
operator|=
name|a
index|[
name|j
index|]
expr_stmt|;
name|newsize
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|A
index|[
name|j
index|]
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|A
index|[
name|k
index|]
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|multiple
operator|=
name|lcm
argument_list|(
name|A
index|[
name|j
index|]
index|[
name|i
index|]
argument_list|,
name|A
index|[
name|k
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|f1
operator|=
name|multiple
operator|/
name|A
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
name|f2
operator|=
operator|-
literal|1
operator|*
name|multiple
operator|/
name|A
index|[
name|k
index|]
index|[
name|i
index|]
expr_stmt|;
name|lambda_vector_add_mc
argument_list|(
name|A
index|[
name|j
index|]
argument_list|,
name|f1
argument_list|,
name|A
index|[
name|k
index|]
argument_list|,
name|f2
argument_list|,
name|A1
index|[
name|newsize
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|lambda_vector_add_mc
argument_list|(
name|B
index|[
name|j
index|]
argument_list|,
name|f1
argument_list|,
name|B
index|[
name|k
index|]
argument_list|,
name|f2
argument_list|,
name|B1
index|[
name|newsize
index|]
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|a1
index|[
name|newsize
index|]
operator|=
name|f1
operator|*
name|a
index|[
name|j
index|]
operator|+
name|f2
operator|*
name|a
index|[
name|k
index|]
expr_stmt|;
name|newsize
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|swapmatrix
operator|=
name|A
expr_stmt|;
name|A
operator|=
name|A1
expr_stmt|;
name|A1
operator|=
name|swapmatrix
expr_stmt|;
name|swapmatrix
operator|=
name|B
expr_stmt|;
name|B
operator|=
name|B1
expr_stmt|;
name|B1
operator|=
name|swapmatrix
expr_stmt|;
name|swapvector
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a1
expr_stmt|;
name|a1
operator|=
name|swapvector
expr_stmt|;
name|size
operator|=
name|newsize
expr_stmt|;
block|}
return|return
name|auxillary_nest
return|;
block|}
end_function

begin_comment
comment|/* Compute the loop bounds for the auxiliary space NEST.    Input system used is Ax<= b.  TRANS is the unimodular transformation.      Given the original nest, this function will     1. Convert the nest into matrix form, which consists of a matrix for the    coefficients, a matrix for the     invariant coefficients, and a vector for the constants.      2. Use the matrix form to calculate the lattice base for the nest (which is    a dense space)     3. Compose the dense space transform with the user specified transform, to     get a transform we can easily calculate transformed bounds for.    4. Multiply the composed transformation matrix times the matrix form of the    loop.    5. Transform the newly created matrix (from step 4) back into a loop nest    using Fourier-Motzkin elimination to figure out the bounds.  */
end_comment

begin_function
specifier|static
name|lambda_loopnest
name|lambda_compute_auxillary_space
parameter_list|(
name|lambda_loopnest
name|nest
parameter_list|,
name|lambda_trans_matrix
name|trans
parameter_list|)
block|{
name|lambda_matrix
name|A
decl_stmt|,
name|B
decl_stmt|,
name|A1
decl_stmt|,
name|B1
decl_stmt|;
name|lambda_vector
name|a
decl_stmt|,
name|a1
decl_stmt|;
name|lambda_matrix
name|invertedtrans
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|invariants
decl_stmt|,
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lambda_loop
name|loop
decl_stmt|;
name|lambda_linear_expression
name|expression
decl_stmt|;
name|lambda_lattice
name|lattice
decl_stmt|;
name|depth
operator|=
name|LN_DEPTH
argument_list|(
name|nest
argument_list|)
expr_stmt|;
name|invariants
operator|=
name|LN_INVARIANTS
argument_list|(
name|nest
argument_list|)
expr_stmt|;
comment|/* Unfortunately, we can't know the number of constraints we'll have      ahead of time, but this should be enough even in ridiculous loop nest      cases. We must not go over this limit.  */
name|A
operator|=
name|lambda_matrix_new
argument_list|(
literal|128
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|B
operator|=
name|lambda_matrix_new
argument_list|(
literal|128
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|a
operator|=
name|lambda_vector_new
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|A1
operator|=
name|lambda_matrix_new
argument_list|(
literal|128
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|B1
operator|=
name|lambda_matrix_new
argument_list|(
literal|128
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|a1
operator|=
name|lambda_vector_new
argument_list|(
literal|128
argument_list|)
expr_stmt|;
comment|/* Store the bounds in the equation matrix A, constant vector a, and      invariant matrix B, so that we have Ax<= a + B.      This requires a little equation rearranging so that everything is on the      correct side of the inequality.  */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|LN_LOOPS
argument_list|(
name|nest
argument_list|)
index|[
name|i
index|]
expr_stmt|;
comment|/* First we do the lower bound.  */
if|if
condition|(
name|LL_STEP
argument_list|(
name|loop
argument_list|)
operator|>
literal|0
condition|)
name|expression
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|loop
argument_list|)
expr_stmt|;
else|else
name|expression
operator|=
name|LL_UPPER_BOUND
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|expression
operator|!=
name|NULL
condition|;
name|expression
operator|=
name|LLE_NEXT
argument_list|(
name|expression
argument_list|)
control|)
block|{
comment|/* Fill in the coefficient.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|A
index|[
name|size
index|]
index|[
name|j
index|]
operator|=
name|LLE_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|j
index|]
expr_stmt|;
comment|/* And the invariant coefficient.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|B
index|[
name|size
index|]
index|[
name|j
index|]
operator|=
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|j
index|]
expr_stmt|;
comment|/* And the constant.  */
name|a
index|[
name|size
index|]
operator|=
name|LLE_CONSTANT
argument_list|(
name|expression
argument_list|)
expr_stmt|;
comment|/* Convert (2x+3y+2+b)/4<= z to 2x+3y-4z<= -2-b.  IE put all 	     constants and single variables on   */
name|A
index|[
name|size
index|]
index|[
name|i
index|]
operator|=
operator|-
literal|1
operator|*
name|LLE_DENOMINATOR
argument_list|(
name|expression
argument_list|)
expr_stmt|;
name|a
index|[
name|size
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|B
index|[
name|size
index|]
index|[
name|j
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|size
operator|++
expr_stmt|;
comment|/* Need to increase matrix sizes above.  */
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|127
argument_list|)
expr_stmt|;
block|}
comment|/* Then do the exact same thing for the upper bounds.  */
if|if
condition|(
name|LL_STEP
argument_list|(
name|loop
argument_list|)
operator|>
literal|0
condition|)
name|expression
operator|=
name|LL_UPPER_BOUND
argument_list|(
name|loop
argument_list|)
expr_stmt|;
else|else
name|expression
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|expression
operator|!=
name|NULL
condition|;
name|expression
operator|=
name|LLE_NEXT
argument_list|(
name|expression
argument_list|)
control|)
block|{
comment|/* Fill in the coefficient.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|A
index|[
name|size
index|]
index|[
name|j
index|]
operator|=
name|LLE_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|j
index|]
expr_stmt|;
comment|/* And the invariant coefficient.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|B
index|[
name|size
index|]
index|[
name|j
index|]
operator|=
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|j
index|]
expr_stmt|;
comment|/* And the constant.  */
name|a
index|[
name|size
index|]
operator|=
name|LLE_CONSTANT
argument_list|(
name|expression
argument_list|)
expr_stmt|;
comment|/* Convert z<= (2x+3y+2+b)/4 to -2x-3y+4z<= 2+b.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|A
index|[
name|size
index|]
index|[
name|j
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|A
index|[
name|size
index|]
index|[
name|i
index|]
operator|=
name|LLE_DENOMINATOR
argument_list|(
name|expression
argument_list|)
expr_stmt|;
name|size
operator|++
expr_stmt|;
comment|/* Need to increase matrix sizes above.  */
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|127
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Compute the lattice base x = base * y + origin, where y is the      base space.  */
name|lattice
operator|=
name|lambda_lattice_compute_base
argument_list|(
name|nest
argument_list|)
expr_stmt|;
comment|/* Ax<= a + B then becomes ALy<= a+B - A*origin.  L is the lattice base  */
comment|/* A1 = A * L */
name|lambda_matrix_mult
argument_list|(
name|A
argument_list|,
name|LATTICE_BASE
argument_list|(
name|lattice
argument_list|)
argument_list|,
name|A1
argument_list|,
name|size
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* a1 = a - A * origin constant.  */
name|lambda_matrix_vector_mult
argument_list|(
name|A
argument_list|,
name|size
argument_list|,
name|depth
argument_list|,
name|LATTICE_ORIGIN
argument_list|(
name|lattice
argument_list|)
argument_list|,
name|a1
argument_list|)
expr_stmt|;
name|lambda_vector_add_mc
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|a1
argument_list|,
operator|-
literal|1
argument_list|,
name|a1
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* B1 = B - A * origin invariant.  */
name|lambda_matrix_mult
argument_list|(
name|A
argument_list|,
name|LATTICE_ORIGIN_INVARIANTS
argument_list|(
name|lattice
argument_list|)
argument_list|,
name|B1
argument_list|,
name|size
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|lambda_matrix_add_mc
argument_list|(
name|B
argument_list|,
literal|1
argument_list|,
name|B1
argument_list|,
operator|-
literal|1
argument_list|,
name|B1
argument_list|,
name|size
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
comment|/* Now compute the auxiliary space bounds by first inverting U, multiplying      it by A1, then performing Fourier-Motzkin.  */
name|invertedtrans
operator|=
name|lambda_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Compute the inverse of U.  */
name|lambda_matrix_inverse
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|invertedtrans
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* A = A1 inv(U).  */
name|lambda_matrix_mult
argument_list|(
name|A1
argument_list|,
name|invertedtrans
argument_list|,
name|A
argument_list|,
name|size
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return
name|compute_nest_using_fourier_motzkin
argument_list|(
name|size
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|,
name|A
argument_list|,
name|B1
argument_list|,
name|a1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the loop bounds for the target space, using the bounds of    the auxiliary nest AUXILLARY_NEST, and the triangular matrix H.      The target space loop bounds are computed by multiplying the triangular    matrix H by the auxiliary nest, to get the new loop bounds.  The sign of    the loop steps (positive or negative) is then used to swap the bounds if    the loop counts downwards.    Return the target loopnest.  */
end_comment

begin_function
specifier|static
name|lambda_loopnest
name|lambda_compute_target_space
parameter_list|(
name|lambda_loopnest
name|auxillary_nest
parameter_list|,
name|lambda_trans_matrix
name|H
parameter_list|,
name|lambda_vector
name|stepsigns
parameter_list|)
block|{
name|lambda_matrix
name|inverse
decl_stmt|,
name|H1
decl_stmt|;
name|int
name|determinant
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|gcd1
decl_stmt|,
name|gcd2
decl_stmt|;
name|int
name|factor
decl_stmt|;
name|lambda_loopnest
name|target_nest
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|invariants
decl_stmt|;
name|lambda_matrix
name|target
decl_stmt|;
name|lambda_loop
name|auxillary_loop
decl_stmt|,
name|target_loop
decl_stmt|;
name|lambda_linear_expression
name|expression
decl_stmt|,
name|auxillary_expr
decl_stmt|,
name|target_expr
decl_stmt|,
name|tmp_expr
decl_stmt|;
name|depth
operator|=
name|LN_DEPTH
argument_list|(
name|auxillary_nest
argument_list|)
expr_stmt|;
name|invariants
operator|=
name|LN_INVARIANTS
argument_list|(
name|auxillary_nest
argument_list|)
expr_stmt|;
name|inverse
operator|=
name|lambda_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|determinant
operator|=
name|lambda_matrix_inverse
argument_list|(
name|LTM_MATRIX
argument_list|(
name|H
argument_list|)
argument_list|,
name|inverse
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* H1 is H excluding its diagonal.  */
name|H1
operator|=
name|lambda_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|lambda_matrix_copy
argument_list|(
name|LTM_MATRIX
argument_list|(
name|H
argument_list|)
argument_list|,
name|H1
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
name|H1
index|[
name|i
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Computes the linear offsets of the loop bounds.  */
name|target
operator|=
name|lambda_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|lambda_matrix_mult
argument_list|(
name|H1
argument_list|,
name|inverse
argument_list|,
name|target
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|target_nest
operator|=
name|lambda_loopnest_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get a new loop structure.  */
name|target_loop
operator|=
name|lambda_loop_new
argument_list|()
expr_stmt|;
name|LN_LOOPS
argument_list|(
name|target_nest
argument_list|)
index|[
name|i
index|]
operator|=
name|target_loop
expr_stmt|;
comment|/* Computes the gcd of the coefficients of the linear part.  */
name|gcd1
operator|=
name|lambda_vector_gcd
argument_list|(
name|target
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Include the denominator in the GCD.  */
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|determinant
argument_list|)
expr_stmt|;
comment|/* Now divide through by the gcd.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|target
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|target
index|[
name|i
index|]
index|[
name|j
index|]
operator|/
name|gcd1
expr_stmt|;
name|expression
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|lambda_vector_copy
argument_list|(
name|target
index|[
name|i
index|]
argument_list|,
name|LLE_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|expression
argument_list|)
operator|=
name|determinant
operator|/
name|gcd1
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|expression
argument_list|)
operator|=
literal|0
expr_stmt|;
name|lambda_vector_clear
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|LL_LINEAR_OFFSET
argument_list|(
name|target_loop
argument_list|)
operator|=
name|expression
expr_stmt|;
block|}
comment|/* For each loop, compute the new bounds from H.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|auxillary_loop
operator|=
name|LN_LOOPS
argument_list|(
name|auxillary_nest
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|target_loop
operator|=
name|LN_LOOPS
argument_list|(
name|target_nest
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|LL_STEP
argument_list|(
name|target_loop
argument_list|)
operator|=
name|LTM_MATRIX
argument_list|(
name|H
argument_list|)
index|[
name|i
index|]
index|[
name|i
index|]
expr_stmt|;
name|factor
operator|=
name|LTM_MATRIX
argument_list|(
name|H
argument_list|)
index|[
name|i
index|]
index|[
name|i
index|]
expr_stmt|;
comment|/* First we do the lower bound.  */
name|auxillary_expr
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|auxillary_loop
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|auxillary_expr
operator|!=
name|NULL
condition|;
name|auxillary_expr
operator|=
name|LLE_NEXT
argument_list|(
name|auxillary_expr
argument_list|)
control|)
block|{
name|target_expr
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|lambda_vector_matrix_mult
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|auxillary_expr
argument_list|)
argument_list|,
name|depth
argument_list|,
name|inverse
argument_list|,
name|depth
argument_list|,
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|)
expr_stmt|;
name|lambda_vector_mult_const
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|depth
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_CONSTANT
argument_list|(
name|auxillary_expr
argument_list|)
operator|*
name|factor
expr_stmt|;
name|lambda_vector_copy
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|auxillary_expr
argument_list|)
argument_list|,
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|lambda_vector_mult_const
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_DENOMINATOR
argument_list|(
name|auxillary_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lambda_vector_zerop
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|depth
argument_list|)
condition|)
block|{
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|*
name|determinant
expr_stmt|;
name|lambda_vector_mult_const
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|,
name|determinant
argument_list|)
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|*
name|determinant
expr_stmt|;
block|}
comment|/* Find the gcd and divide by it here, rather than doing it 	     at the tree level.  */
name|gcd1
operator|=
name|lambda_vector_gcd
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|gcd2
operator|=
name|lambda_vector_gcd
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|gcd2
argument_list|)
expr_stmt|;
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
argument_list|)
expr_stmt|;
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|depth
condition|;
name|j
operator|++
control|)
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
index|[
name|j
index|]
operator|/=
name|gcd1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
index|[
name|j
index|]
operator|/=
name|gcd1
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|/=
name|gcd1
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|/=
name|gcd1
expr_stmt|;
comment|/* Ignore if identical to existing bound.  */
if|if
condition|(
operator|!
name|lle_equal
argument_list|(
name|LL_LOWER_BOUND
argument_list|(
name|target_loop
argument_list|)
argument_list|,
name|target_expr
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|)
condition|)
block|{
name|LLE_NEXT
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|target_loop
argument_list|)
expr_stmt|;
name|LL_LOWER_BOUND
argument_list|(
name|target_loop
argument_list|)
operator|=
name|target_expr
expr_stmt|;
block|}
block|}
comment|/* Now do the upper bound.  */
name|auxillary_expr
operator|=
name|LL_UPPER_BOUND
argument_list|(
name|auxillary_loop
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|auxillary_expr
operator|!=
name|NULL
condition|;
name|auxillary_expr
operator|=
name|LLE_NEXT
argument_list|(
name|auxillary_expr
argument_list|)
control|)
block|{
name|target_expr
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|lambda_vector_matrix_mult
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|auxillary_expr
argument_list|)
argument_list|,
name|depth
argument_list|,
name|inverse
argument_list|,
name|depth
argument_list|,
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|)
expr_stmt|;
name|lambda_vector_mult_const
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|depth
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_CONSTANT
argument_list|(
name|auxillary_expr
argument_list|)
operator|*
name|factor
expr_stmt|;
name|lambda_vector_copy
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|auxillary_expr
argument_list|)
argument_list|,
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|lambda_vector_mult_const
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_DENOMINATOR
argument_list|(
name|auxillary_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lambda_vector_zerop
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|depth
argument_list|)
condition|)
block|{
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|*
name|determinant
expr_stmt|;
name|lambda_vector_mult_const
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|,
name|determinant
argument_list|)
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|*
name|determinant
expr_stmt|;
block|}
comment|/* Find the gcd and divide by it here, instead of at the 	     tree level.  */
name|gcd1
operator|=
name|lambda_vector_gcd
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|gcd2
operator|=
name|lambda_vector_gcd
argument_list|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|gcd2
argument_list|)
expr_stmt|;
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
argument_list|)
expr_stmt|;
name|gcd1
operator|=
name|gcd
argument_list|(
name|gcd1
argument_list|,
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|depth
condition|;
name|j
operator|++
control|)
name|LLE_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
index|[
name|j
index|]
operator|/=
name|gcd1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|target_expr
argument_list|)
index|[
name|j
index|]
operator|/=
name|gcd1
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|target_expr
argument_list|)
operator|/=
name|gcd1
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|target_expr
argument_list|)
operator|/=
name|gcd1
expr_stmt|;
comment|/* Ignore if equal to existing bound.  */
if|if
condition|(
operator|!
name|lle_equal
argument_list|(
name|LL_UPPER_BOUND
argument_list|(
name|target_loop
argument_list|)
argument_list|,
name|target_expr
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|)
condition|)
block|{
name|LLE_NEXT
argument_list|(
name|target_expr
argument_list|)
operator|=
name|LL_UPPER_BOUND
argument_list|(
name|target_loop
argument_list|)
expr_stmt|;
name|LL_UPPER_BOUND
argument_list|(
name|target_loop
argument_list|)
operator|=
name|target_expr
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|target_loop
operator|=
name|LN_LOOPS
argument_list|(
name|target_nest
argument_list|)
index|[
name|i
index|]
expr_stmt|;
comment|/* If necessary, exchange the upper and lower bounds and negate          the step size.  */
if|if
condition|(
name|stepsigns
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|LL_STEP
argument_list|(
name|target_loop
argument_list|)
operator|*=
operator|-
literal|1
expr_stmt|;
name|tmp_expr
operator|=
name|LL_LOWER_BOUND
argument_list|(
name|target_loop
argument_list|)
expr_stmt|;
name|LL_LOWER_BOUND
argument_list|(
name|target_loop
argument_list|)
operator|=
name|LL_UPPER_BOUND
argument_list|(
name|target_loop
argument_list|)
expr_stmt|;
name|LL_UPPER_BOUND
argument_list|(
name|target_loop
argument_list|)
operator|=
name|tmp_expr
expr_stmt|;
block|}
block|}
return|return
name|target_nest
return|;
block|}
end_function

begin_comment
comment|/* Compute the step signs of TRANS, using TRANS and stepsigns.  Return the new    result.  */
end_comment

begin_function
specifier|static
name|lambda_vector
name|lambda_compute_step_signs
parameter_list|(
name|lambda_trans_matrix
name|trans
parameter_list|,
name|lambda_vector
name|stepsigns
parameter_list|)
block|{
name|lambda_matrix
name|matrix
decl_stmt|,
name|H
decl_stmt|;
name|int
name|size
decl_stmt|;
name|lambda_vector
name|newsteps
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|factor
decl_stmt|,
name|minimum_column
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|matrix
operator|=
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
expr_stmt|;
name|size
operator|=
name|LTM_ROWSIZE
argument_list|(
name|trans
argument_list|)
expr_stmt|;
name|H
operator|=
name|lambda_matrix_new
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|newsteps
operator|=
name|lambda_vector_new
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|lambda_vector_copy
argument_list|(
name|stepsigns
argument_list|,
name|newsteps
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|lambda_matrix_copy
argument_list|(
name|matrix
argument_list|,
name|H
argument_list|,
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
block|{
name|lambda_vector
name|row
decl_stmt|;
name|row
operator|=
name|H
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|row
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|lambda_matrix_col_negate
argument_list|(
name|H
argument_list|,
name|size
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|lambda_vector_first_nz
argument_list|(
name|row
argument_list|,
name|size
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|<
name|size
condition|)
block|{
name|minimum_column
operator|=
name|lambda_vector_min_nz
argument_list|(
name|row
argument_list|,
name|size
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|lambda_matrix_col_exchange
argument_list|(
name|H
argument_list|,
name|size
argument_list|,
name|j
argument_list|,
name|minimum_column
argument_list|)
expr_stmt|;
name|temp
operator|=
name|newsteps
index|[
name|j
index|]
expr_stmt|;
name|newsteps
index|[
name|j
index|]
operator|=
name|newsteps
index|[
name|minimum_column
index|]
expr_stmt|;
name|newsteps
index|[
name|minimum_column
index|]
operator|=
name|temp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|+
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|factor
operator|=
name|row
index|[
name|i
index|]
operator|/
name|row
index|[
name|j
index|]
expr_stmt|;
name|lambda_matrix_col_add
argument_list|(
name|H
argument_list|,
name|size
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
operator|-
literal|1
operator|*
name|factor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|newsteps
return|;
block|}
end_function

begin_comment
comment|/* Transform NEST according to TRANS, and return the new loopnest.    This involves    1. Computing a lattice base for the transformation    2. Composing the dense base with the specified transformation (TRANS)    3. Decomposing the combined transformation into a lower triangular portion,    and a unimodular portion.     4. Computing the auxiliary nest using the unimodular portion.    5. Computing the target nest using the auxiliary nest and the lower    triangular portion.  */
end_comment

begin_function
name|lambda_loopnest
name|lambda_loopnest_transform
parameter_list|(
name|lambda_loopnest
name|nest
parameter_list|,
name|lambda_trans_matrix
name|trans
parameter_list|)
block|{
name|lambda_loopnest
name|auxillary_nest
decl_stmt|,
name|target_nest
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|invariants
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lambda_lattice
name|lattice
decl_stmt|;
name|lambda_trans_matrix
name|trans1
decl_stmt|,
name|H
decl_stmt|,
name|U
decl_stmt|;
name|lambda_loop
name|loop
decl_stmt|;
name|lambda_linear_expression
name|expression
decl_stmt|;
name|lambda_vector
name|origin
decl_stmt|;
name|lambda_matrix
name|origin_invariants
decl_stmt|;
name|lambda_vector
name|stepsigns
decl_stmt|;
name|int
name|f
decl_stmt|;
name|depth
operator|=
name|LN_DEPTH
argument_list|(
name|nest
argument_list|)
expr_stmt|;
name|invariants
operator|=
name|LN_INVARIANTS
argument_list|(
name|nest
argument_list|)
expr_stmt|;
comment|/* Keep track of the signs of the loop steps.  */
name|stepsigns
operator|=
name|lambda_vector_new
argument_list|(
name|depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LL_STEP
argument_list|(
name|LN_LOOPS
argument_list|(
name|nest
argument_list|)
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
name|stepsigns
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|stepsigns
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Compute the lattice base.  */
name|lattice
operator|=
name|lambda_lattice_compute_base
argument_list|(
name|nest
argument_list|)
expr_stmt|;
name|trans1
operator|=
name|lambda_trans_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Multiply the transformation matrix by the lattice base.  */
name|lambda_matrix_mult
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|LATTICE_BASE
argument_list|(
name|lattice
argument_list|)
argument_list|,
name|LTM_MATRIX
argument_list|(
name|trans1
argument_list|)
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Compute the Hermite normal form for the new transformation matrix.  */
name|H
operator|=
name|lambda_trans_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|U
operator|=
name|lambda_trans_matrix_new
argument_list|(
name|depth
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|lambda_matrix_hermite
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans1
argument_list|)
argument_list|,
name|depth
argument_list|,
name|LTM_MATRIX
argument_list|(
name|H
argument_list|)
argument_list|,
name|LTM_MATRIX
argument_list|(
name|U
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the auxiliary loop nest's space from the unimodular      portion.  */
name|auxillary_nest
operator|=
name|lambda_compute_auxillary_space
argument_list|(
name|nest
argument_list|,
name|U
argument_list|)
expr_stmt|;
comment|/* Compute the loop step signs from the old step signs and the      transformation matrix.  */
name|stepsigns
operator|=
name|lambda_compute_step_signs
argument_list|(
name|trans1
argument_list|,
name|stepsigns
argument_list|)
expr_stmt|;
comment|/* Compute the target loop nest space from the auxiliary nest and      the lower triangular matrix H.  */
name|target_nest
operator|=
name|lambda_compute_target_space
argument_list|(
name|auxillary_nest
argument_list|,
name|H
argument_list|,
name|stepsigns
argument_list|)
expr_stmt|;
name|origin
operator|=
name|lambda_vector_new
argument_list|(
name|depth
argument_list|)
expr_stmt|;
name|origin_invariants
operator|=
name|lambda_matrix_new
argument_list|(
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
name|lambda_matrix_vector_mult
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|,
name|LATTICE_ORIGIN
argument_list|(
name|lattice
argument_list|)
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|lambda_matrix_mult
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|LATTICE_ORIGIN_INVARIANTS
argument_list|(
name|lattice
argument_list|)
argument_list|,
name|origin_invariants
argument_list|,
name|depth
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|LN_LOOPS
argument_list|(
name|target_nest
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|expression
operator|=
name|LL_LINEAR_OFFSET
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|lambda_vector_zerop
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
argument_list|,
name|depth
argument_list|)
condition|)
name|f
operator|=
literal|1
expr_stmt|;
else|else
name|f
operator|=
name|LLE_DENOMINATOR
argument_list|(
name|expression
argument_list|)
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|expression
argument_list|)
operator|+=
name|f
operator|*
name|origin
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|invariants
condition|;
name|j
operator|++
control|)
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|expression
argument_list|)
index|[
name|j
index|]
operator|+=
name|f
operator|*
name|origin_invariants
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
return|return
name|target_nest
return|;
block|}
end_function

begin_comment
comment|/* Convert a gcc tree expression EXPR to a lambda linear expression, and    return the new expression.  DEPTH is the depth of the loopnest.    OUTERINDUCTIONVARS is an array of the induction variables for outer loops    in this nest.  INVARIANTS is the array of invariants for the loop.  EXTRA    is the amount we have to add/subtract from the expression because of the    type of comparison it is used in.  */
end_comment

begin_decl_stmt
specifier|static
name|lambda_linear_expression
name|gcc_tree_to_linear_expression
argument_list|(
name|int
name|depth
argument_list|,
name|tree
name|expr
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|outerinductionvars
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|invariants
argument_list|,
name|int
name|extra
argument_list|)
block|{
name|lambda_linear_expression
name|lle
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
block|{
name|lle
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
name|LLE_CONSTANT
argument_list|(
name|lle
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|LLE_CONSTANT
argument_list|(
name|lle
argument_list|)
operator|+=
name|extra
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|lle
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SSA_NAME
case|:
block|{
name|tree
name|iv
decl_stmt|,
name|invar
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|outerinductionvars
argument_list|,
name|i
argument_list|,
name|iv
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SSA_NAME_VAR
argument_list|(
name|iv
argument_list|)
operator|==
name|SSA_NAME_VAR
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|lle
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
name|LLE_COEFFICIENTS
argument_list|(
name|lle
argument_list|)
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|LLE_CONSTANT
argument_list|(
name|lle
argument_list|)
operator|=
name|extra
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|lle
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|invariants
argument_list|,
name|i
argument_list|,
name|invar
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|invar
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SSA_NAME_VAR
argument_list|(
name|invar
argument_list|)
operator|==
name|SSA_NAME_VAR
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|lle
operator|=
name|lambda_linear_expression_new
argument_list|(
name|depth
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|lle
argument_list|)
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|LLE_CONSTANT
argument_list|(
name|lle
argument_list|)
operator|=
name|extra
expr_stmt|;
name|LLE_DENOMINATOR
argument_list|(
name|lle
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
return|return
name|NULL
return|;
block|}
return|return
name|lle
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return the depth of the loopnest NEST */
end_comment

begin_function
specifier|static
name|int
name|depth_of_nest
parameter_list|(
name|struct
name|loop
modifier|*
name|nest
parameter_list|)
block|{
name|size_t
name|depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|nest
condition|)
block|{
name|depth
operator|++
expr_stmt|;
name|nest
operator|=
name|nest
operator|->
name|inner
expr_stmt|;
block|}
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is invariant in LOOP and all outer loops.  */
end_comment

begin_function
specifier|static
name|bool
name|invariant_in_loop_and_outer_loops
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|op
parameter_list|)
block|{
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|loop
operator|->
name|depth
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|op
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|loop
operator|->
name|outer
operator|&&
operator|!
name|invariant_in_loop_and_outer_loops
argument_list|(
name|loop
operator|->
name|outer
argument_list|,
name|op
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate a lambda loop from a gcc loop LOOP.  Return the new lambda loop,    or NULL if it could not be converted.    DEPTH is the depth of the loop.    INVARIANTS is a pointer to the array of loop invariants.    The induction variable for this loop should be stored in the parameter    OURINDUCTIONVAR.    OUTERINDUCTIONVARS is an array of induction variables for outer loops.  */
end_comment

begin_decl_stmt
specifier|static
name|lambda_loop
name|gcc_loop_to_lambda_loop
argument_list|(
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|int
name|depth
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|invariants
argument_list|,
name|tree
operator|*
name|ourinductionvar
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|outerinductionvars
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|lboundvars
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|uboundvars
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|steps
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|tree
name|exit_cond
decl_stmt|;
name|tree
name|access_fn
decl_stmt|,
name|inductionvar
decl_stmt|;
name|tree
name|step
decl_stmt|;
name|lambda_loop
name|lloop
init|=
name|NULL
decl_stmt|;
name|lambda_linear_expression
name|lbound
decl_stmt|,
name|ubound
decl_stmt|;
name|tree
name|test
decl_stmt|;
name|int
name|stepint
decl_stmt|;
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|tree
name|lboundvar
decl_stmt|,
name|uboundvar
decl_stmt|,
name|uboundresult
decl_stmt|;
comment|/* Find out induction var and exit condition.  */
name|inductionvar
operator|=
name|find_induction_var_from_exit_cond
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|exit_cond
operator|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|inductionvar
operator|==
name|NULL
operator|||
name|exit_cond
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Cannot determine exit condition or induction variable for loop.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|test
operator|=
name|TREE_OPERAND
argument_list|(
name|exit_cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|inductionvar
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Cannot find PHI node for induction variable\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|phi
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|inductionvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|!=
name|PHI_NODE
condition|)
block|{
name|phi
operator|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|phi
argument_list|,
name|SSA_OP_USE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phi
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Cannot find PHI node for induction variable\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|phi
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|!=
name|PHI_NODE
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Cannot find PHI node for induction variable\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* The induction variable name/version we want to put in the array is the      result of the induction variable phi node.  */
operator|*
name|ourinductionvar
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|access_fn
operator|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_fn
operator|==
name|chrec_dont_know
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Access function for induction variable phi is unknown\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|step
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|step
operator|||
name|step
operator|==
name|chrec_dont_know
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Cannot determine step of loop.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Step of loop is not integer.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stepint
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|step
argument_list|)
expr_stmt|;
comment|/* Only want phis for induction vars, which will have two      arguments.  */
if|if
condition|(
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: PHI node for induction variable has>2 arguments\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Another induction variable check. One argument's source should be      in the loop, one outside the loop.  */
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
operator|->
name|src
argument_list|)
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
literal|1
argument_list|)
operator|->
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: PHI edges both inside loop, or both outside loop.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
operator|->
name|src
argument_list|)
condition|)
block|{
name|lboundvar
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lbound
operator|=
name|gcc_tree_to_linear_expression
argument_list|(
name|depth
argument_list|,
name|lboundvar
argument_list|,
name|outerinductionvars
argument_list|,
operator|*
name|invariants
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lboundvar
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lbound
operator|=
name|gcc_tree_to_linear_expression
argument_list|(
name|depth
argument_list|,
name|lboundvar
argument_list|,
name|outerinductionvars
argument_list|,
operator|*
name|invariants
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lbound
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Cannot convert lower bound to linear expression\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* One part of the test may be a loop invariant tree.  */
name|VEC_reserve
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|invariants
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|invariant_in_loop_and_outer_loops
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
operator|*
name|invariants
argument_list|,
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|invariant_in_loop_and_outer_loops
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
operator|*
name|invariants
argument_list|,
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The non-induction variable part of the test is the upper bound variable.    */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
operator|==
name|inductionvar
condition|)
name|uboundvar
operator|=
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|uboundvar
operator|=
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We only size the vectors assuming we have, at max, 2 times as many      invariants as we do loops (one for each bound).      This is just an arbitrary number, but it has to be matched against the      code below.  */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
operator|*
name|invariants
argument_list|)
operator|<=
call|(
name|unsigned
name|int
call|)
argument_list|(
literal|2
operator|*
name|depth
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We might have some leftover.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|LT_EXPR
condition|)
name|extra
operator|=
operator|-
literal|1
operator|*
name|stepint
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|NE_EXPR
condition|)
name|extra
operator|=
operator|-
literal|1
operator|*
name|stepint
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|GT_EXPR
condition|)
name|extra
operator|=
operator|-
literal|1
operator|*
name|stepint
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|EQ_EXPR
condition|)
name|extra
operator|=
literal|1
operator|*
name|stepint
expr_stmt|;
name|ubound
operator|=
name|gcc_tree_to_linear_expression
argument_list|(
name|depth
argument_list|,
name|uboundvar
argument_list|,
name|outerinductionvars
argument_list|,
operator|*
name|invariants
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|uboundresult
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|uboundvar
argument_list|)
argument_list|,
name|uboundvar
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|uboundvar
argument_list|)
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|uboundvars
argument_list|,
name|uboundresult
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|lboundvars
argument_list|,
name|lboundvar
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
operator|*
name|steps
argument_list|,
name|stepint
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ubound
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to convert loop: Cannot convert upper bound to linear expression\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lloop
operator|=
name|lambda_loop_new
argument_list|()
expr_stmt|;
name|LL_STEP
argument_list|(
name|lloop
argument_list|)
operator|=
name|stepint
expr_stmt|;
name|LL_LOWER_BOUND
argument_list|(
name|lloop
argument_list|)
operator|=
name|lbound
expr_stmt|;
name|LL_UPPER_BOUND
argument_list|(
name|lloop
argument_list|)
operator|=
name|ubound
expr_stmt|;
return|return
name|lloop
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Given a LOOP, find the induction variable it is testing against in the exit    condition.  Return the induction variable if found, NULL otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|find_induction_var_from_exit_cond
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|expr
init|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|tree
name|ivarop
decl_stmt|;
name|tree
name|test
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|test
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|test
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Find the side that is invariant in this loop. The ivar must be the other      side.  */
if|if
condition|(
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|ivarop
operator|=
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|ivarop
operator|=
name|TREE_OPERAND
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ivarop
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|ivarop
return|;
block|}
end_function

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|lambda_loop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|lambda_loop
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Generate a lambda loopnest from a gcc loopnest LOOP_NEST.    Return the new loop nest.      INDUCTIONVARS is a pointer to an array of induction variables for the    loopnest that will be filled in during this process.    INVARIANTS is a pointer to an array of invariants that will be filled in    during this process.  */
end_comment

begin_decl_stmt
name|lambda_loopnest
name|gcc_loopnest_to_lambda_loopnest
argument_list|(
expr|struct
name|loops
operator|*
name|currloops
argument_list|,
expr|struct
name|loop
operator|*
name|loop_nest
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|inductionvars
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|invariants
argument_list|)
block|{
name|lambda_loopnest
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|loop
modifier|*
name|temp
init|=
name|loop_nest
decl_stmt|;
name|int
name|depth
init|=
name|depth_of_nest
argument_list|(
name|loop_nest
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|VEC
argument_list|(
name|lambda_loop
argument_list|,
name|heap
argument_list|)
operator|*
name|loops
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|uboundvars
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|lboundvars
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|steps
operator|=
name|NULL
expr_stmt|;
name|lambda_loop
name|newloop
decl_stmt|;
name|tree
name|inductionvar
init|=
name|NULL
decl_stmt|;
name|bool
name|perfect_nest
init|=
name|perfect_nest_p
argument_list|(
name|loop_nest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|perfect_nest
operator|&&
operator|!
name|can_convert_to_perfect_nest
argument_list|(
name|loop_nest
argument_list|)
condition|)
goto|goto
name|fail
goto|;
while|while
condition|(
name|temp
condition|)
block|{
name|newloop
operator|=
name|gcc_loop_to_lambda_loop
argument_list|(
name|temp
argument_list|,
name|depth
argument_list|,
name|invariants
argument_list|,
operator|&
name|inductionvar
argument_list|,
operator|*
name|inductionvars
argument_list|,
operator|&
name|lboundvars
argument_list|,
operator|&
name|uboundvars
argument_list|,
operator|&
name|steps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newloop
condition|)
goto|goto
name|fail
goto|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|inductionvars
argument_list|,
name|inductionvar
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|lambda_loop
argument_list|,
name|heap
argument_list|,
name|loops
argument_list|,
name|newloop
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|inner
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|perfect_nest
condition|)
block|{
if|if
condition|(
operator|!
name|perfect_nestify
argument_list|(
name|currloops
argument_list|,
name|loop_nest
argument_list|,
name|lboundvars
argument_list|,
name|uboundvars
argument_list|,
name|steps
argument_list|,
operator|*
name|inductionvars
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Not a perfect loop nest and couldn't convert to one.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
elseif|else
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Successfully converted loop nest to perfect loop nest.\n"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|lambda_loopnest_new
argument_list|(
name|depth
argument_list|,
literal|2
operator|*
name|depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_loop
argument_list|,
name|loops
argument_list|,
name|i
argument_list|,
name|newloop
argument_list|)
condition|;
name|i
operator|++
control|)
name|LN_LOOPS
argument_list|(
name|ret
argument_list|)
index|[
name|i
index|]
operator|=
name|newloop
expr_stmt|;
name|fail
label|:
name|VEC_free
argument_list|(
name|lambda_loop
argument_list|,
name|heap
argument_list|,
name|loops
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|uboundvars
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|lboundvars
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|steps
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Convert a lambda body vector LBV to a gcc tree, and return the new tree.     STMTS_TO_INSERT is a pointer to a tree where the statements we need to be    inserted for us are stored.  INDUCTION_VARS is the array of induction    variables for the loop this LBV is from.  TYPE is the tree type to use for    the variables and trees involved.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|lbv_to_gcc_expression
argument_list|(
name|lambda_body_vector
name|lbv
argument_list|,
name|tree
name|type
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|induction_vars
argument_list|,
name|tree
operator|*
name|stmts_to_insert
argument_list|)
block|{
name|tree
name|stmts
decl_stmt|,
name|stmt
decl_stmt|,
name|resvar
decl_stmt|,
name|name
decl_stmt|;
name|tree
name|iv
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree_stmt_iterator
name|tsi
decl_stmt|;
comment|/* Create a statement list and a linear expression temporary.  */
name|stmts
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|resvar
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"lbvtmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|resvar
argument_list|)
expr_stmt|;
comment|/* Start at 0.  */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|induction_vars
argument_list|,
name|i
argument_list|,
name|iv
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LBV_COEFFICIENTS
argument_list|(
name|lbv
argument_list|)
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|tree
name|newname
decl_stmt|;
name|tree
name|coeffmult
decl_stmt|;
comment|/* newname = coefficient * induction_variable */
name|coeffmult
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LBV_COEFFICIENTS
argument_list|(
name|lbv
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|iv
argument_list|,
name|coeffmult
argument_list|)
argument_list|)
expr_stmt|;
name|newname
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|newname
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* name = name + newname */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|newname
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle any denominator that occurs.  */
if|if
condition|(
name|LBV_DENOMINATOR
argument_list|(
name|lbv
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|tree
name|denominator
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LBV_DENOMINATOR
argument_list|(
name|lbv
argument_list|)
argument_list|)
decl_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|build2
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|denominator
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
operator|*
name|stmts_to_insert
operator|=
name|stmts
expr_stmt|;
return|return
name|name
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Convert a linear expression from coefficient and constant form to a    gcc tree.    Return the tree that represents the final value of the expression.    LLE is the linear expression to convert.    OFFSET is the linear offset to apply to the expression.    TYPE is the tree type to use for the variables and math.     INDUCTION_VARS is a vector of induction variables for the loops.    INVARIANTS is a vector of the loop nest invariants.    WRAP specifies what tree code to wrap the results in, if there is more than    one (it is either MAX_EXPR, or MIN_EXPR).    STMTS_TO_INSERT Is a pointer to the statement list we fill in with    statements that need to be inserted for the linear expression.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|lle_to_gcc_expression
argument_list|(
name|lambda_linear_expression
name|lle
argument_list|,
name|lambda_linear_expression
name|offset
argument_list|,
name|tree
name|type
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|induction_vars
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|invariants
argument_list|,
expr|enum
name|tree_code
name|wrap
argument_list|,
name|tree
operator|*
name|stmts_to_insert
argument_list|)
block|{
name|tree
name|stmts
decl_stmt|,
name|stmt
decl_stmt|,
name|resvar
decl_stmt|,
name|name
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree_stmt_iterator
name|tsi
decl_stmt|;
name|tree
name|iv
decl_stmt|,
name|invar
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|results
operator|=
name|NULL
expr_stmt|;
name|gcc_assert
argument_list|(
name|wrap
operator|==
name|MAX_EXPR
operator|||
name|wrap
operator|==
name|MIN_EXPR
argument_list|)
expr_stmt|;
name|name
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Create a statement list and a linear expression temporary.  */
name|stmts
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|resvar
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"lletmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|resvar
argument_list|)
expr_stmt|;
comment|/* Build up the linear expressions, and put the variable representing the      result in the results array.  */
for|for
control|(
init|;
name|lle
operator|!=
name|NULL
condition|;
name|lle
operator|=
name|LLE_NEXT
argument_list|(
name|lle
argument_list|)
control|)
block|{
comment|/* Start at name = 0.  */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* First do the induction variables.            at the end, name = name + all the induction variables added          together.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|induction_vars
argument_list|,
name|i
argument_list|,
name|iv
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LLE_COEFFICIENTS
argument_list|(
name|lle
argument_list|)
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|tree
name|newname
decl_stmt|;
name|tree
name|mult
decl_stmt|;
name|tree
name|coeff
decl_stmt|;
comment|/* mult = induction variable * coefficient.  */
if|if
condition|(
name|LLE_COEFFICIENTS
argument_list|(
name|lle
argument_list|)
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
name|mult
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|induction_vars
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|coeff
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LLE_COEFFICIENTS
argument_list|(
name|lle
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mult
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|iv
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
comment|/* newname = mult */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|mult
argument_list|)
expr_stmt|;
name|newname
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|newname
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* name = name + newname */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|newname
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle our invariants.          At the end, we have name = name + result of adding all multiplied          invariants.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|invariants
argument_list|,
name|i
argument_list|,
name|invar
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|lle
argument_list|)
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|tree
name|newname
decl_stmt|;
name|tree
name|mult
decl_stmt|;
name|tree
name|coeff
decl_stmt|;
name|int
name|invcoeff
init|=
name|LLE_INVARIANT_COEFFICIENTS
argument_list|(
name|lle
argument_list|)
index|[
name|i
index|]
decl_stmt|;
comment|/* mult = invariant * coefficient  */
if|if
condition|(
name|invcoeff
operator|==
literal|1
condition|)
block|{
name|mult
operator|=
name|invar
expr_stmt|;
block|}
else|else
block|{
name|coeff
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|invcoeff
argument_list|)
expr_stmt|;
name|mult
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|invar
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
comment|/* newname = mult */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|mult
argument_list|)
expr_stmt|;
name|newname
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|newname
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* name = name + newname */
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|newname
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now handle the constant.          name = name + constant.  */
if|if
condition|(
name|LLE_CONSTANT
argument_list|(
name|lle
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LLE_CONSTANT
argument_list|(
name|lle
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
comment|/* Now handle the offset.          name = name + linear offset.  */
if|if
condition|(
name|LLE_CONSTANT
argument_list|(
name|offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LLE_CONSTANT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|fold_stmt
argument_list|(
operator|&
name|stmt
argument_list|)
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
comment|/* Handle any denominator that occurs.  */
if|if
condition|(
name|LLE_DENOMINATOR
argument_list|(
name|lle
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|stmt
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LLE_DENOMINATOR
argument_list|(
name|lle
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|wrap
operator|==
name|MAX_EXPR
condition|?
name|CEIL_DIV_EXPR
else|:
name|FLOOR_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|/* name = {ceil, floor}(name/denominator) */
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|results
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Again, out of laziness, we don't handle this case yet.  It's not      hard, it just hasn't occurred.  */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|results
argument_list|)
operator|<=
literal|2
argument_list|)
expr_stmt|;
comment|/* We may need to wrap the results in a MAX_EXPR or MIN_EXPR.  */
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|results
argument_list|)
operator|>
literal|1
condition|)
block|{
name|tree
name|op1
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|results
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op2
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|results
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|resvar
argument_list|,
name|build2
argument_list|(
name|wrap
argument_list|,
name|type
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|make_ssa_name
argument_list|(
name|resvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|name
expr_stmt|;
name|tsi
operator|=
name|tsi_last
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|results
argument_list|)
expr_stmt|;
operator|*
name|stmts_to_insert
operator|=
name|stmts
expr_stmt|;
return|return
name|name
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Transform a lambda loopnest NEW_LOOPNEST, which had TRANSFORM applied to    it, back into gcc code.  This changes the    loops, their induction variables, and their bodies, so that they    match the transformed loopnest.      OLD_LOOPNEST is the loopnest before we've replaced it with the new    loopnest.    OLD_IVS is a vector of induction variables from the old loopnest.    INVARIANTS is a vector of loop invariants from the old loopnest.    NEW_LOOPNEST is the new lambda loopnest to replace OLD_LOOPNEST with.    TRANSFORM is the matrix transform that was applied to OLD_LOOPNEST to get     NEW_LOOPNEST.  */
end_comment

begin_decl_stmt
name|void
name|lambda_loopnest_to_gcc_loopnest
argument_list|(
expr|struct
name|loop
operator|*
name|old_loopnest
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|old_ivs
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|invariants
argument_list|,
name|lambda_loopnest
name|new_loopnest
argument_list|,
name|lambda_trans_matrix
name|transform
argument_list|)
block|{
name|struct
name|loop
modifier|*
name|temp
decl_stmt|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|depth
init|=
literal|0
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|new_ivs
operator|=
name|NULL
expr_stmt|;
name|tree
name|oldiv
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|transform
operator|=
name|lambda_trans_matrix_inverse
argument_list|(
name|transform
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Inverse of transformation matrix:\n"
argument_list|)
expr_stmt|;
name|print_lambda_trans_matrix
argument_list|(
name|dump_file
argument_list|,
name|transform
argument_list|)
expr_stmt|;
block|}
name|depth
operator|=
name|depth_of_nest
argument_list|(
name|old_loopnest
argument_list|)
expr_stmt|;
name|temp
operator|=
name|old_loopnest
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|lambda_loop
name|newloop
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|exit
decl_stmt|;
name|tree
name|ivvar
decl_stmt|,
name|ivvarinced
decl_stmt|,
name|exitcond
decl_stmt|,
name|stmts
decl_stmt|;
name|enum
name|tree_code
name|testtype
decl_stmt|;
name|tree
name|newupperbound
decl_stmt|,
name|newlowerbound
decl_stmt|;
name|lambda_linear_expression
name|offset
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|bool
name|insert_after
decl_stmt|;
name|tree
name|inc_stmt
decl_stmt|;
name|oldiv
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|old_ivs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|oldiv
argument_list|)
expr_stmt|;
comment|/* First, build the new induction variable temporary  */
name|ivvar
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"lnivtmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|ivvar
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|new_ivs
argument_list|,
name|ivvar
argument_list|)
expr_stmt|;
name|newloop
operator|=
name|LN_LOOPS
argument_list|(
name|new_loopnest
argument_list|)
index|[
name|i
index|]
expr_stmt|;
comment|/* Linear offset is a bit tricky to handle.  Punt on the unhandled          cases for now.  */
name|offset
operator|=
name|LL_LINEAR_OFFSET
argument_list|(
name|newloop
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|LLE_DENOMINATOR
argument_list|(
name|offset
argument_list|)
operator|==
literal|1
operator|&&
name|lambda_vector_zerop
argument_list|(
name|LLE_COEFFICIENTS
argument_list|(
name|offset
argument_list|)
argument_list|,
name|depth
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now build the  new lower bounds, and insert the statements          necessary to generate it on the loop preheader.  */
name|newlowerbound
operator|=
name|lle_to_gcc_expression
argument_list|(
name|LL_LOWER_BOUND
argument_list|(
name|newloop
argument_list|)
argument_list|,
name|LL_LINEAR_OFFSET
argument_list|(
name|newloop
argument_list|)
argument_list|,
name|type
argument_list|,
name|new_ivs
argument_list|,
name|invariants
argument_list|,
name|MAX_EXPR
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
name|bsi_insert_on_edge
argument_list|(
name|loop_preheader_edge
argument_list|(
name|temp
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
comment|/* Build the new upper bound and insert its statements in the          basic block of the exit condition */
name|newupperbound
operator|=
name|lle_to_gcc_expression
argument_list|(
name|LL_UPPER_BOUND
argument_list|(
name|newloop
argument_list|)
argument_list|,
name|LL_LINEAR_OFFSET
argument_list|(
name|newloop
argument_list|)
argument_list|,
name|type
argument_list|,
name|new_ivs
argument_list|,
name|invariants
argument_list|,
name|MIN_EXPR
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
name|exit
operator|=
name|temp
operator|->
name|single_exit
expr_stmt|;
name|exitcond
operator|=
name|get_loop_exit_condition
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|exitcond
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmts
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
comment|/* Create the new iv.  */
name|standard_iv_increment_position
argument_list|(
name|temp
argument_list|,
operator|&
name|bsi
argument_list|,
operator|&
name|insert_after
argument_list|)
expr_stmt|;
name|create_iv
argument_list|(
name|newlowerbound
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LL_STEP
argument_list|(
name|newloop
argument_list|)
argument_list|)
argument_list|,
name|ivvar
argument_list|,
name|temp
argument_list|,
operator|&
name|bsi
argument_list|,
name|insert_after
argument_list|,
operator|&
name|ivvar
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Unfortunately, the incremented ivvar that create_iv inserted may not 	 dominate the block containing the exit condition. 	 So we simply create our own incremented iv to use in the new exit 	 test,  and let redundancy elimination sort it out.  */
name|inc_stmt
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|ivvar
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|LL_STEP
argument_list|(
name|newloop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|inc_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|SSA_NAME_VAR
argument_list|(
name|ivvar
argument_list|)
argument_list|,
name|inc_stmt
argument_list|)
expr_stmt|;
name|ivvarinced
operator|=
name|make_ssa_name
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ivvar
argument_list|)
argument_list|,
name|inc_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|inc_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|ivvarinced
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|exitcond
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|inc_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Replace the exit condition with the new upper bound          comparison.  */
name|testtype
operator|=
name|LL_STEP
argument_list|(
name|newloop
argument_list|)
operator|>=
literal|0
condition|?
name|LE_EXPR
else|:
name|GE_EXPR
expr_stmt|;
comment|/* We want to build a conditional where true means exit the loop, and 	 false means continue the loop. 	 So swap the testtype if this isn't the way things are.*/
if|if
condition|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_FALSE_VALUE
condition|)
name|testtype
operator|=
name|swap_tree_comparison
argument_list|(
name|testtype
argument_list|)
expr_stmt|;
name|COND_EXPR_COND
argument_list|(
name|exitcond
argument_list|)
operator|=
name|build2
argument_list|(
name|testtype
argument_list|,
name|boolean_type_node
argument_list|,
name|newupperbound
argument_list|,
name|ivvarinced
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|exitcond
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|new_ivs
argument_list|,
name|i
argument_list|,
name|ivvar
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|inner
expr_stmt|;
block|}
comment|/* Rewrite uses of the old ivs so that they are now specified in terms of      the new ivs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|old_ivs
argument_list|,
name|i
argument_list|,
name|oldiv
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|tree
name|oldiv_def
decl_stmt|;
name|tree
name|oldiv_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|oldiv
argument_list|)
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|oldiv_stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
name|oldiv_def
operator|=
name|PHI_RESULT
argument_list|(
name|oldiv_stmt
argument_list|)
expr_stmt|;
else|else
name|oldiv_def
operator|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|oldiv_stmt
argument_list|,
name|SSA_OP_DEF
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|oldiv_def
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|FOR_EACH_IMM_USE_STMT
argument_list|(
argument|stmt
argument_list|,
argument|imm_iter
argument_list|,
argument|oldiv_def
argument_list|)
block|{
name|tree
name|newiv
decl_stmt|,
name|stmts
decl_stmt|;
name|lambda_body_vector
name|lbv
decl_stmt|,
name|newlbv
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
argument_list|)
expr_stmt|;
comment|/* Compute the new expression for the induction 	     variable.  */
name|depth
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|new_ivs
argument_list|)
expr_stmt|;
name|lbv
operator|=
name|lambda_body_vector_new
argument_list|(
name|depth
argument_list|)
expr_stmt|;
name|LBV_COEFFICIENTS
argument_list|(
name|lbv
argument_list|)
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|newlbv
operator|=
name|lambda_body_vector_compute_new
argument_list|(
name|transform
argument_list|,
name|lbv
argument_list|)
expr_stmt|;
name|newiv
operator|=
name|lbv_to_gcc_expression
argument_list|(
name|newlbv
argument_list|,
name|TREE_TYPE
argument_list|(
name|oldiv
argument_list|)
argument_list|,
name|new_ivs
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Insert the statements to build that 	     expression.  */
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmts
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|FOR_EACH_IMM_USE_ON_STMT
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|)
name|propagate_value
argument_list|(
name|use_p
argument_list|,
name|newiv
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|new_ivs
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Return TRUE if this is not interesting statement from the perspective of    determining if we have a perfect loop nest.  */
end_comment

begin_function
specifier|static
name|bool
name|not_interesting_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
comment|/* Note that COND_EXPR's aren't interesting because if they were exiting the      loop, we would have already failed the number of exits tests.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|GOTO_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if PHI uses DEF for it's in-the-loop edge for LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|phi_loop_edge_uses_def
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|phi
parameter_list|,
name|tree
name|def
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|->
name|src
argument_list|)
condition|)
if|if
condition|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|==
name|def
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if STMT is a use of PHI_RESULT.  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_uses_phi_result
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|phi_result
parameter_list|)
block|{
name|tree
name|use
init|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_USE
argument_list|)
decl_stmt|;
comment|/* This is conservatively true, because we only want SIMPLE bumpers      of the form x +- constant for our pass.  */
return|return
operator|(
name|use
operator|==
name|phi_result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* STMT is a bumper stmt for LOOP if the version it defines is used in the    in-loop-edge in a phi node, and the operand it uses is the result of that    phi node.     I.E. i_29 = i_3 + 1         i_3 = PHI (0, i_29);  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_is_bumper_for_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|use
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|imm_use_iterator
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def
operator|=
name|SINGLE_SSA_TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
name|false
return|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|iter
argument_list|,
argument|def
argument_list|)
block|{
name|use
operator|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
if|if
condition|(
name|phi_loop_edge_uses_def
argument_list|(
name|loop
argument_list|,
name|use
argument_list|,
name|def
argument_list|)
condition|)
if|if
condition|(
name|stmt_uses_phi_result
argument_list|(
name|stmt
argument_list|,
name|PHI_RESULT
argument_list|(
name|use
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if LOOP is a perfect loop nest.    Perfect loop nests are those loop nests where all code occurs in the    innermost loop body.    If S is a program statement, then     i.e.     DO I = 1, 20        S1        DO J = 1, 20        ...        END DO    END DO    is not a perfect loop nest because of S1.        DO I = 1, 20       DO J = 1, 20         S1 	...       END DO    END DO     is a perfect loop nest.       Since we don't have high level loops anymore, we basically have to walk our    statements and ignore those that are there because the loop needs them (IE    the induction variable increment, and jump back to the top of the loop).  */
end_comment

begin_function
name|bool
name|perfect_nest_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|exit_cond
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|->
name|inner
condition|)
return|return
name|true
return|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|exit_cond
operator|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bbs
index|[
name|i
index|]
operator|->
name|loop_father
operator|==
name|loop
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|==
name|exit_cond
operator|||
name|not_interesting_stmt
argument_list|(
name|stmt
argument_list|)
operator|||
name|stmt_is_bumper_for_loop
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|)
condition|)
continue|continue;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
comment|/* See if the inner loops are perfectly nested as well.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
return|return
name|perfect_nest_p
argument_list|(
name|loop
operator|->
name|inner
argument_list|)
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Replace the USES of X in STMT, or uses with the same step as X with Y.    YINIT is the initial value of Y, REPLACEMENTS is a hash table to    avoid creating duplicate temporaries and FIRSTBSI is statement    iterator where new temporaries should be inserted at the beginning    of body basic block.  */
end_comment

begin_function
specifier|static
name|void
name|replace_uses_equiv_to_x_with_y
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|x
parameter_list|,
name|int
name|xstep
parameter_list|,
name|tree
name|y
parameter_list|,
name|tree
name|yinit
parameter_list|,
name|htab_t
name|replacements
parameter_list|,
name|block_stmt_iterator
modifier|*
name|firstbsi
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|tree
name|step
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|scev
decl_stmt|,
name|init
decl_stmt|,
name|val
decl_stmt|,
name|var
decl_stmt|,
name|setstmt
decl_stmt|;
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Replace uses of X with Y right away.  */
if|if
condition|(
name|use
operator|==
name|x
condition|)
block|{
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|y
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|scev
operator|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|use
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scev
operator|==
name|NULL
operator|||
name|scev
operator|==
name|chrec_dont_know
condition|)
continue|continue;
name|step
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|scev
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|==
name|NULL
operator|||
name|step
operator|==
name|chrec_dont_know
operator|||
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|int_cst_value
argument_list|(
name|step
argument_list|)
operator|!=
name|xstep
condition|)
continue|continue;
comment|/* Use REPLACEMENTS hash table to cache already created 	 temporaries.  */
name|in
operator|.
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|use
argument_list|)
expr_stmt|;
name|in
operator|.
name|from
operator|=
name|use
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|replacements
argument_list|,
operator|&
name|in
argument_list|,
name|in
operator|.
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|h
operator|->
name|to
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* USE which has the same step as X should be replaced 	 with a temporary set to Y + YINIT - INIT.  */
name|init
operator|=
name|initial_condition_in_loop_num
argument_list|(
name|scev
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|init
operator|!=
name|NULL
operator|&&
name|init
operator|!=
name|chrec_dont_know
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|use
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|val
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|y
argument_list|)
argument_list|,
name|init
argument_list|,
name|yinit
argument_list|)
expr_stmt|;
name|val
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|y
argument_list|)
argument_list|,
name|y
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|y
condition|)
block|{
comment|/* If X has the same type as USE, the same step 		 and same initial value, it can be replaced by Y.  */
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|y
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|val
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|y
argument_list|)
argument_list|,
name|y
argument_list|,
name|yinit
argument_list|)
expr_stmt|;
name|val
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|use
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|use
argument_list|)
argument_list|,
name|val
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
comment|/* Create a temporary variable and insert it at the beginning 	 of the loop body basic block, right after the PHI node 	 which sets Y.  */
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|use
argument_list|)
argument_list|,
literal|"perfecttmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|firstbsi
argument_list|,
name|val
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|setstmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|var
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|setstmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|setstmt
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|firstbsi
argument_list|,
name|setstmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|setstmt
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|in
operator|.
name|hash
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|use
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|var
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|replacements
argument_list|,
name|h
argument_list|,
name|in
operator|.
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if STMT is an exit PHI for LOOP */
end_comment

begin_function
specifier|static
name|bool
name|exit_phi_for_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
operator|||
name|PHI_NUM_ARGS
argument_list|(
name|stmt
argument_list|)
operator|!=
literal|1
operator|||
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|!=
name|loop
operator|->
name|single_exit
operator|->
name|dest
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if STMT can be put back into the loop INNER, by    copying it to the beginning of that loop and changing the uses.  */
end_comment

begin_function
specifier|static
name|bool
name|can_put_in_inner_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|inner
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
operator|||
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|inner
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|TREE_OPERAND (stmt,
literal|0
argument|)
argument_list|)
block|{
if|if
condition|(
operator|!
name|exit_phi_for_loop_p
argument_list|(
name|inner
argument_list|,
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
condition|)
block|{
name|basic_block
name|immbb
init|=
name|bb_for_stmt
argument_list|(
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|inner
argument_list|,
name|immbb
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if STMT can be put *after* the inner loop of LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|can_put_after_inner_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
condition|)
return|return
name|false
return|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|TREE_OPERAND (stmt,
literal|0
argument|)
argument_list|)
block|{
if|if
condition|(
operator|!
name|exit_phi_for_loop_p
argument_list|(
name|loop
argument_list|,
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
condition|)
block|{
name|basic_block
name|immbb
init|=
name|bb_for_stmt
argument_list|(
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|immbb
argument_list|,
name|loop
operator|->
name|inner
operator|->
name|header
argument_list|)
operator|&&
operator|!
name|can_put_in_inner_loop
argument_list|(
name|loop
operator|->
name|inner
argument_list|,
name|stmt
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if LOOP is an imperfect nest that we can convert to a    perfect one.  At the moment, we only handle imperfect nests of    depth 2, where all of the statements occur after the inner loop.  */
end_comment

begin_function
specifier|static
name|bool
name|can_convert_to_perfect_nest
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|tree
name|exit_condition
decl_stmt|,
name|phi
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|exitdest
decl_stmt|;
comment|/* Can't handle triply nested+ loops yet.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|inner
operator|||
name|loop
operator|->
name|inner
operator|->
name|inner
condition|)
return|return
name|false
return|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|exit_condition
operator|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bbs
index|[
name|i
index|]
operator|->
name|loop_father
operator|==
name|loop
condition|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|==
name|exit_condition
operator|||
name|not_interesting_stmt
argument_list|(
name|stmt
argument_list|)
operator|||
name|stmt_is_bumper_for_loop
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|)
condition|)
continue|continue;
comment|/* If this is a scalar operation that can be put back 	         into the inner loop, or after the inner loop, through 		 copying, then do so. This works on the theory that 		 any amount of scalar code we have to reduplicate 		 into or after the loops is less expensive that the 		 win we get from rearranging the memory walk 		 the loop is doing so that it has better 		 cache behavior.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|use_operand_p
name|use_a
decl_stmt|,
name|use_b
decl_stmt|;
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|ssa_op_iter
name|op_iter
decl_stmt|,
name|op_iter1
decl_stmt|;
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|scev
init|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|op0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the IV is simple, it can be duplicated.  */
if|if
condition|(
operator|!
name|automatically_generated_chrec_p
argument_list|(
name|scev
argument_list|)
condition|)
block|{
name|tree
name|step
init|=
name|evolution_part_in_loop_num
argument_list|(
name|scev
argument_list|,
name|loop
operator|->
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|step
operator|&&
name|step
operator|!=
name|chrec_dont_know
operator|&&
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|==
name|INTEGER_CST
condition|)
continue|continue;
block|}
comment|/* The statement should not define a variable used 		     in the inner loop.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_a
argument_list|,
argument|imm_iter
argument_list|,
argument|op0
argument_list|)
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|USE_STMT
argument_list|(
name|use_a
argument_list|)
argument_list|)
operator|->
name|loop_father
operator|==
name|loop
operator|->
name|inner
condition|)
goto|goto
name|fail
goto|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_a
argument_list|,
argument|stmt
argument_list|,
argument|op_iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|node
decl_stmt|,
name|op
init|=
name|USE_FROM_PTR
argument_list|(
name|use_a
argument_list|)
decl_stmt|;
comment|/* The variables should not be used in both loops.  */
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_b
argument_list|,
argument|imm_iter
argument_list|,
argument|op
argument_list|)
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|USE_STMT
argument_list|(
name|use_b
argument_list|)
argument_list|)
operator|->
name|loop_father
operator|==
name|loop
operator|->
name|inner
condition|)
goto|goto
name|fail
goto|;
comment|/* The statement should not use the value of a 			 scalar that was modified in the loop.  */
name|node
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|PHI_NODE
condition|)
name|FOR_EACH_PHI_ARG
argument_list|(
argument|use_b
argument_list|,
argument|node
argument_list|,
argument|op_iter1
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|arg
init|=
name|USE_FROM_PTR
argument_list|(
name|use_b
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|arg_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|arg_stmt
argument_list|)
operator|->
name|loop_father
operator|==
name|loop
operator|->
name|inner
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
block|}
if|if
condition|(
name|can_put_in_inner_loop
argument_list|(
name|loop
operator|->
name|inner
argument_list|,
name|stmt
argument_list|)
operator|||
name|can_put_after_inner_loop
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Otherwise, if the bb of a statement we care about isn't 		 dominated by the header of the inner loop, then we can't 		 handle this case right now.  This test ensures that the 		 statement comes completely *after* the inner loop.  */
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|loop
operator|->
name|inner
operator|->
name|header
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
block|}
comment|/* We also need to make sure the loop exit only has simple copy phis in it,      otherwise we don't know how to transform it into a perfect nest right      now.  */
name|exitdest
operator|=
name|loop
operator|->
name|single_exit
operator|->
name|dest
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|exitdest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Transform the loop nest into a perfect nest, if possible.    LOOPS is the current struct loops *    LOOP is the loop nest to transform into a perfect nest    LBOUNDS are the lower bounds for the loops to transform    UBOUNDS are the upper bounds for the loops to transform    STEPS is the STEPS for the loops to transform.    LOOPIVS is the induction variables for the loops to transform.        Basically, for the case of     FOR (i = 0; i< 50; i++)     {      FOR (j =0; j< 50; j++)      {<whatever>      }<some code>     }     This function will transform it into a perfect loop nest by splitting the    outer loop into two loops, like so:     FOR (i = 0; i< 50; i++)    {      FOR (j = 0; j< 50; j++)      {<whatever>      }    }        FOR (i = 0; i< 50; i ++)    {<some code>    }     Return FALSE if we can't make this loop into a perfect nest.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|perfect_nestify
argument_list|(
expr|struct
name|loops
operator|*
name|loops
argument_list|,
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|lbounds
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|ubounds
argument_list|,
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|steps
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|loopivs
argument_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|tree
name|exit_condition
decl_stmt|;
name|tree
name|then_label
decl_stmt|,
name|else_label
decl_stmt|,
name|cond_stmt
decl_stmt|;
name|basic_block
name|preheaderbb
decl_stmt|,
name|headerbb
decl_stmt|,
name|bodybb
decl_stmt|,
name|latchbb
decl_stmt|,
name|olddest
decl_stmt|;
name|int
name|i
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|firstbsi
decl_stmt|;
name|bool
name|insert_after
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|struct
name|loop
modifier|*
name|newloop
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|tree
name|uboundvar
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|tree
name|oldivvar
decl_stmt|,
name|ivvar
decl_stmt|,
name|ivvarinced
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|phis
operator|=
name|NULL
expr_stmt|;
name|htab_t
name|replacements
init|=
name|NULL
decl_stmt|;
comment|/* Create the new loop.  */
name|olddest
operator|=
name|loop
operator|->
name|single_exit
operator|->
name|dest
expr_stmt|;
name|preheaderbb
operator|=
name|loop_split_edge_with
argument_list|(
name|loop
operator|->
name|single_exit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|headerbb
operator|=
name|create_empty_bb
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
comment|/* Push the exit phi nodes that we are moving.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|olddest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|VEC_reserve
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|phis
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|redirect_edge_and_branch
argument_list|(
name|single_succ_edge
argument_list|(
name|preheaderbb
argument_list|)
argument_list|,
name|headerbb
argument_list|)
expr_stmt|;
comment|/* Remove the exit phis from the old basic block.  Make sure to set      PHI_RESULT to null so it doesn't get released.  */
while|while
condition|(
name|phi_nodes
argument_list|(
name|olddest
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|SET_PHI_RESULT
argument_list|(
name|phi_nodes
argument_list|(
name|olddest
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|remove_phi_node
argument_list|(
name|phi_nodes
argument_list|(
name|olddest
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* and add them back to the new basic block.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|def
decl_stmt|;
name|tree
name|phiname
decl_stmt|;
name|def
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|)
expr_stmt|;
name|phiname
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|)
expr_stmt|;
name|phi
operator|=
name|create_phi_node
argument_list|(
name|phiname
argument_list|,
name|preheaderbb
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|def
argument_list|,
name|single_pred_edge
argument_list|(
name|preheaderbb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flush_pending_stmts
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|phis
argument_list|)
expr_stmt|;
name|bodybb
operator|=
name|create_empty_bb
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|latchbb
operator|=
name|create_empty_bb
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|headerbb
argument_list|,
name|bodybb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|then_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|latchbb
argument_list|)
argument_list|)
expr_stmt|;
name|else_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|olddest
argument_list|)
argument_list|)
expr_stmt|;
name|cond_stmt
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|then_label
argument_list|,
name|else_label
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bodybb
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|cond_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|bodybb
argument_list|,
name|olddest
argument_list|,
name|EDGE_FALSE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bodybb
argument_list|,
name|latchbb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|latchbb
argument_list|,
name|headerbb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
comment|/* Update the loop structures.  */
name|newloop
operator|=
name|duplicate_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|olddest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
name|newloop
operator|->
name|header
operator|=
name|headerbb
expr_stmt|;
name|newloop
operator|->
name|latch
operator|=
name|latchbb
expr_stmt|;
name|newloop
operator|->
name|single_exit
operator|=
name|e
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|latchbb
argument_list|,
name|newloop
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|bodybb
argument_list|,
name|newloop
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|headerbb
argument_list|,
name|newloop
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bodybb
argument_list|,
name|headerbb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|headerbb
argument_list|,
name|preheaderbb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|preheaderbb
argument_list|,
name|loop
operator|->
name|single_exit
operator|->
name|src
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|latchbb
argument_list|,
name|bodybb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|olddest
argument_list|,
name|bodybb
argument_list|)
expr_stmt|;
comment|/* Create the new iv.  */
name|oldivvar
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|loopivs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ivvar
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldivvar
argument_list|)
argument_list|,
literal|"perfectiv"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|ivvar
argument_list|)
expr_stmt|;
name|standard_iv_increment_position
argument_list|(
name|newloop
argument_list|,
operator|&
name|bsi
argument_list|,
operator|&
name|insert_after
argument_list|)
expr_stmt|;
name|create_iv
argument_list|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|lbounds
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldivvar
argument_list|)
argument_list|,
name|VEC_index
argument_list|(
name|int
argument_list|,
name|steps
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ivvar
argument_list|,
name|newloop
argument_list|,
operator|&
name|bsi
argument_list|,
name|insert_after
argument_list|,
operator|&
name|ivvar
argument_list|,
operator|&
name|ivvarinced
argument_list|)
expr_stmt|;
comment|/* Create the new upper bound.  This may be not just a variable, so we copy      it to one just in case.  */
name|exit_condition
operator|=
name|get_loop_exit_condition
argument_list|(
name|newloop
argument_list|)
expr_stmt|;
name|uboundvar
operator|=
name|create_tmp_var
argument_list|(
name|integer_type_node
argument_list|,
literal|"uboundvar"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|uboundvar
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|uboundvar
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|ubounds
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|uboundvar
operator|=
name|make_ssa_name
argument_list|(
name|uboundvar
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|uboundvar
expr_stmt|;
if|if
condition|(
name|insert_after
condition|)
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
else|else
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|COND_EXPR_COND
argument_list|(
name|exit_condition
argument_list|)
operator|=
name|build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|uboundvar
argument_list|,
name|ivvarinced
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|exit_condition
argument_list|)
expr_stmt|;
name|replacements
operator|=
name|htab_create_ggc
argument_list|(
literal|20
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bbs
operator|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Now move the statements, and replace the induction variable in the moved      statements with the correct loop induction variable.  */
name|oldivvar
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|loopivs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|firstbsi
operator|=
name|bsi_start
argument_list|(
name|bodybb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|loop
operator|->
name|num_nodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|block_stmt_iterator
name|tobsi
init|=
name|bsi_last
argument_list|(
name|bodybb
argument_list|)
decl_stmt|;
if|if
condition|(
name|bbs
index|[
name|i
index|]
operator|->
name|loop_father
operator|==
name|loop
condition|)
block|{
comment|/* If this is true, we are *before* the inner loop. 	     If this isn't true, we are *after* it.  	     The only time can_convert_to_perfect_nest returns true when we 	     have statements before the inner loop is if they can be moved 	     into the inner loop.   	     The only time can_convert_to_perfect_nest returns true when we 	     have statements after the inner loop is if they can be moved into 	     the new split loop.  */
if|if
condition|(
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|inner
operator|->
name|header
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|block_stmt_iterator
name|header_bsi
init|=
name|bsi_after_labels
argument_list|(
name|loop
operator|->
name|inner
operator|->
name|header
argument_list|)
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|==
name|exit_condition
operator|||
name|not_interesting_stmt
argument_list|(
name|stmt
argument_list|)
operator|||
name|stmt_is_bumper_for_loop
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|)
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bsi_move_before
argument_list|(
operator|&
name|bsi
argument_list|,
operator|&
name|header_bsi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Note that the bsi only needs to be explicitly incremented 		 when we don't move something, since it is automatically 		 incremented when we do.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
control|)
block|{
name|ssa_op_iter
name|i
decl_stmt|;
name|tree
name|n
decl_stmt|,
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|==
name|exit_condition
operator|||
name|not_interesting_stmt
argument_list|(
name|stmt
argument_list|)
operator|||
name|stmt_is_bumper_for_loop
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|)
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|replace_uses_equiv_to_x_with_y
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|,
name|oldivvar
argument_list|,
name|VEC_index
argument_list|(
name|int
argument_list|,
name|steps
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ivvar
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|lbounds
argument_list|,
literal|0
argument_list|)
argument_list|,
name|replacements
argument_list|,
operator|&
name|firstbsi
argument_list|)
expr_stmt|;
name|bsi_move_before
argument_list|(
operator|&
name|bsi
argument_list|,
operator|&
name|tobsi
argument_list|)
expr_stmt|;
comment|/* If the statement has any virtual operands, they may 		     need to be rewired because the original loop may 		     still reference them.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|n
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_ALL_VIRTUALS
argument_list|)
name|mark_sym_for_renaming
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|replacements
argument_list|)
expr_stmt|;
return|return
name|perfect_nest_p
argument_list|(
name|loop
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return true if TRANS is a legal transformation matrix that respects    the dependence vectors in DISTS and DIRS.  The conservative answer    is false.     "Wolfe proves that a unimodular transformation represented by the    matrix T is legal when applied to a loop nest with a set of    lexicographically non-negative distance vectors RDG if and only if    for each vector d in RDG, (T.d>= 0) is lexicographically positive.    i.e.: if and only if it transforms the lexicographically positive    distance vectors to lexicographically positive vectors.  Note that    a unimodular matrix must transform the zero vector (and only it) to    the zero vector." S.Muchnick.  */
end_comment

begin_decl_stmt
name|bool
name|lambda_transform_legal_p
argument_list|(
name|lambda_trans_matrix
name|trans
argument_list|,
name|int
name|nb_loops
argument_list|,
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|dependence_relations
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lambda_vector
name|distres
decl_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
name|gcc_assert
argument_list|(
name|LTM_COLSIZE
argument_list|(
name|trans
argument_list|)
operator|==
name|nb_loops
operator|&&
name|LTM_ROWSIZE
argument_list|(
name|trans
argument_list|)
operator|==
name|nb_loops
argument_list|)
expr_stmt|;
comment|/* When there is an unknown relation in the dependence_relations, we      know that it is no worth looking at this loop nest: give up.  */
name|ddr
operator|=
name|VEC_index
argument_list|(
name|ddr_p
argument_list|,
name|dependence_relations
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddr
operator|==
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_dont_know
condition|)
return|return
name|false
return|;
name|distres
operator|=
name|lambda_vector_new
argument_list|(
name|nb_loops
argument_list|)
expr_stmt|;
comment|/* For each distance vector in the dependence graph.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ddr_p
argument_list|,
name|dependence_relations
argument_list|,
name|i
argument_list|,
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Don't care about relations for which we know that there is no 	 dependence, nor about read-read (aka. output-dependences): 	 these data accesses can happen in any order.  */
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_known
operator|||
operator|(
name|DR_IS_READ
argument_list|(
name|DDR_A
argument_list|(
name|ddr
argument_list|)
argument_list|)
operator|&&
name|DR_IS_READ
argument_list|(
name|DDR_B
argument_list|(
name|ddr
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Conservatively answer: "this transformation is not valid".  */
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_dont_know
condition|)
return|return
name|false
return|;
comment|/* If the dependence could not be captured by a distance vector, 	 conservatively answer that the transform is not valid.  */
if|if
condition|(
name|DDR_NUM_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* Compute trans.dist_vect */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DDR_NUM_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|lambda_matrix_vector_mult
argument_list|(
name|LTM_MATRIX
argument_list|(
name|trans
argument_list|)
argument_list|,
name|nb_loops
argument_list|,
name|nb_loops
argument_list|,
name|DDR_DIST_VECT
argument_list|(
name|ddr
argument_list|,
name|j
argument_list|)
argument_list|,
name|distres
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lambda_vector_lexico_pos
argument_list|(
name|distres
argument_list|,
name|nb_loops
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

end_unit

