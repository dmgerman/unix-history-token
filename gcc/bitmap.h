begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions to support general ended bitmaps.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_BITMAP_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_BITMAP_H
end_define

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* Fundamental storage type for bitmap.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|BITMAP_WORD
typedef|;
end_typedef

begin_comment
comment|/* BITMAP_WORD_BITS needs to be unsigned, but cannot contain casts as    it is used in preprocessor directives -- hence the 1u.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_WORD_BITS
value|(CHAR_BIT * SIZEOF_LONG * 1u)
end_define

begin_comment
comment|/* Number of words to use for each element in the linked list.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITMAP_ELEMENT_WORDS
end_ifndef

begin_define
define|#
directive|define
name|BITMAP_ELEMENT_WORDS
value|((128 + BITMAP_WORD_BITS - 1) / BITMAP_WORD_BITS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in each actual element of a bitmap.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_ELEMENT_ALL_BITS
value|(BITMAP_ELEMENT_WORDS * BITMAP_WORD_BITS)
end_define

begin_comment
comment|/* Obstack for allocating bitmaps and elements from.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|bitmap_obstack
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|bitmap_element_def
modifier|*
name|elements
block|;
name|struct
name|bitmap_head_def
modifier|*
name|heads
block|;
name|struct
name|obstack
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|obstack
block|; }
end_typedef

begin_expr_stmt
name|bitmap_obstack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Bitmap set element.  We use a linked list to hold only the bits that    are set.  This allows for use to grow the bitset dynamically without    having to realloc and copy a giant bit array.     The free list is implemented as a list of lists.  There is one    outer list connected together by prev fields.  Each element of that    outer is an inner list (that may consist only of the outer list    element) that are connected by the next fields.  The prev pointer    is undefined for interior elements.  This allows    bitmap_elt_clear_from to be implemented in unit time rather than    linear in the number of elements to be freed.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|bitmap_element_def
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|bitmap_element_def
modifier|*
name|next
block|;
comment|/* Next element.  */
name|struct
name|bitmap_element_def
modifier|*
name|prev
block|;
comment|/* Previous element.  */
name|unsigned
name|int
name|indx
block|;
comment|/* regno/BITMAP_ELEMENT_ALL_BITS.  */
name|BITMAP_WORD
name|bits
index|[
name|BITMAP_ELEMENT_WORDS
index|]
block|;
comment|/* Bits that are set.  */
block|}
end_typedef

begin_expr_stmt
name|bitmap_element
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Head of bitmap linked list.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|bitmap_head_def
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|bitmap_element
modifier|*
name|first
block|;
comment|/* First element in linked list.  */
name|bitmap_element
modifier|*
name|current
block|;
comment|/* Last element looked at.  */
name|unsigned
name|int
name|indx
block|;
comment|/* Index of last element looked at.  */
name|bitmap_obstack
modifier|*
name|obstack
block|;
comment|/* Obstack to allocate elements from. 				   If NULL, then use ggc_alloc.  */
block|}
end_typedef

begin_expr_stmt
name|bitmap_head
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Global data */
end_comment

begin_decl_stmt
specifier|extern
name|bitmap_element
name|bitmap_zero_bits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero bitmap element */
end_comment

begin_decl_stmt
specifier|extern
name|bitmap_obstack
name|bitmap_default_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default bitmap obstack */
end_comment

begin_comment
comment|/* Clear a bitmap by freeing up the linked list.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bitmap_clear
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Copy a bitmap to another bitmap.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bitmap_copy
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* True if two bitmaps are identical.  */
end_comment

begin_function_decl
specifier|extern
name|bool
name|bitmap_equal_p
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* True if the bitmaps intersect (their AND is non-empty).  */
end_comment

begin_function_decl
specifier|extern
name|bool
name|bitmap_intersect_p
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* True if the complement of the second intersects the first (their    AND_COMPL is non-empty).  */
end_comment

begin_function_decl
specifier|extern
name|bool
name|bitmap_intersect_compl_p
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* True if MAP is an empty bitmap.  */
end_comment

begin_define
define|#
directive|define
name|bitmap_empty_p
parameter_list|(
name|MAP
parameter_list|)
value|(!(MAP)->first)
end_define

begin_comment
comment|/* Count the number of bits set in the bitmap.  */
end_comment

begin_function_decl
specifier|extern
name|unsigned
name|long
name|bitmap_count_bits
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Boolean operations on bitmaps.  The _into variants are two operand    versions that modify the first source operand.  The other variants    are three operand versions that to not destroy the source bitmaps.    The operations supported are&,& ~, |, ^.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bitmap_and
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bitmap_and_into
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bitmap_and_compl
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool
name|bitmap_and_compl_into
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|bitmap_compl_and
parameter_list|(
name|DST
parameter_list|,
name|A
parameter_list|,
name|B
parameter_list|)
value|bitmap_and_compl (DST, B, A)
end_define

begin_function_decl
specifier|extern
name|void
name|bitmap_compl_and_into
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bitmap_clear_range
parameter_list|(
name|bitmap
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool
name|bitmap_ior
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool
name|bitmap_ior_into
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bitmap_xor
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bitmap_xor_into
parameter_list|(
name|bitmap
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* DST = A | (B& ~C).  Return true if DST changes.  */
end_comment

begin_function_decl
specifier|extern
name|bool
name|bitmap_ior_and_compl
parameter_list|(
name|bitmap
name|DST
parameter_list|,
name|bitmap
name|A
parameter_list|,
name|bitmap
name|B
parameter_list|,
name|bitmap
name|C
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A |= (B& ~C).  Return true if A changes.  */
end_comment

begin_function_decl
specifier|extern
name|bool
name|bitmap_ior_and_compl_into
parameter_list|(
name|bitmap
name|DST
parameter_list|,
name|bitmap
name|B
parameter_list|,
name|bitmap
name|C
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Clear a single register in a register set.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bitmap_clear_bit
parameter_list|(
name|bitmap
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set a single register in a register set.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bitmap_set_bit
parameter_list|(
name|bitmap
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return true if a register is set in a register set.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|bitmap_bit_p
parameter_list|(
name|bitmap
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Debug functions to print a bitmap linked list.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|debug_bitmap
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|debug_bitmap_file
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print a bitmap.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bitmap_print
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|bitmap
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialize and release a bitmap obstack.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|bitmap_obstack_initialize
parameter_list|(
name|bitmap_obstack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bitmap_obstack_release
parameter_list|(
name|bitmap_obstack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialize a bitmap header.  OBSTACK indicates the bitmap obstack    to allocate from, NULL for GC'd bitmap.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bitmap_initialize
parameter_list|(
name|bitmap
name|head
parameter_list|,
name|bitmap_obstack
modifier|*
name|obstack
parameter_list|)
block|{
name|head
operator|->
name|first
operator|=
name|head
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and free bitmaps from obstack, malloc and gc'd memory.  */
end_comment

begin_function_decl
specifier|extern
name|bitmap
name|bitmap_obstack_alloc
parameter_list|(
name|bitmap_obstack
modifier|*
name|obstack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bitmap
name|bitmap_gc_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bitmap_obstack_free
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A few compatibility/functions macros for compatibility with sbitmaps */
end_comment

begin_define
define|#
directive|define
name|dump_bitmap
parameter_list|(
name|file
parameter_list|,
name|bitmap
parameter_list|)
value|bitmap_print (file, bitmap, "", "\n")
end_define

begin_define
define|#
directive|define
name|bitmap_zero
parameter_list|(
name|a
parameter_list|)
value|bitmap_clear (a)
end_define

begin_function_decl
specifier|extern
name|unsigned
name|bitmap_first_set_bit
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Compute bitmap hash (for purposes of hashing etc.)  */
end_comment

begin_function_decl
specifier|extern
name|hashval_t
name|bitmap_hash
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate a bitmap from a bit obstack.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_ALLOC
parameter_list|(
name|OBSTACK
parameter_list|)
value|bitmap_obstack_alloc (OBSTACK)
end_define

begin_comment
comment|/* Allocate a gc'd bitmap.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_GGC_ALLOC
parameter_list|()
value|bitmap_gc_alloc ()
end_define

begin_comment
comment|/* Do any cleanup needed on a bitmap when it is no longer used.  */
end_comment

begin_define
define|#
directive|define
name|BITMAP_FREE
parameter_list|(
name|BITMAP
parameter_list|)
define|\
value|((void)(bitmap_obstack_free (BITMAP), (BITMAP) = NULL))
end_define

begin_comment
comment|/* Iterator for bitmaps.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Pointer to the current bitmap element.  */
name|bitmap_element
modifier|*
name|elt1
decl_stmt|;
comment|/* Pointer to 2nd bitmap element when two are involved.  */
name|bitmap_element
modifier|*
name|elt2
decl_stmt|;
comment|/* Word within the current element.  */
name|unsigned
name|word_no
decl_stmt|;
comment|/* Contents of the actually processed word.  When finding next bit      it is shifted right, so that the actual bit is always the least      significant bit of ACTUAL.  */
name|BITMAP_WORD
name|bits
decl_stmt|;
block|}
name|bitmap_iterator
typedef|;
end_typedef

begin_comment
comment|/* Initialize a single bitmap iterator.  START_BIT is the first bit to    iterate from.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bmp_iter_set_init
parameter_list|(
name|bitmap_iterator
modifier|*
name|bi
parameter_list|,
name|bitmap
name|map
parameter_list|,
name|unsigned
name|start_bit
parameter_list|,
name|unsigned
modifier|*
name|bit_no
parameter_list|)
block|{
name|bi
operator|->
name|elt1
operator|=
name|map
operator|->
name|first
expr_stmt|;
name|bi
operator|->
name|elt2
operator|=
name|NULL
expr_stmt|;
comment|/* Advance elt1 until it is not before the block containing start_bit.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bi
operator|->
name|elt1
condition|)
block|{
name|bi
operator|->
name|elt1
operator|=
operator|&
name|bitmap_zero_bits
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|>=
name|start_bit
operator|/
name|BITMAP_ELEMENT_ALL_BITS
condition|)
break|break;
name|bi
operator|->
name|elt1
operator|=
name|bi
operator|->
name|elt1
operator|->
name|next
expr_stmt|;
block|}
comment|/* We might have gone past the start bit, so reinitialize it.  */
if|if
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|!=
name|start_bit
operator|/
name|BITMAP_ELEMENT_ALL_BITS
condition|)
name|start_bit
operator|=
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|*
name|BITMAP_ELEMENT_ALL_BITS
expr_stmt|;
comment|/* Initialize for what is now start_bit.  */
name|bi
operator|->
name|word_no
operator|=
name|start_bit
operator|/
name|BITMAP_WORD_BITS
operator|%
name|BITMAP_ELEMENT_WORDS
expr_stmt|;
name|bi
operator|->
name|bits
operator|=
name|bi
operator|->
name|elt1
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
name|bi
operator|->
name|bits
operator|>>=
name|start_bit
operator|%
name|BITMAP_WORD_BITS
expr_stmt|;
comment|/* If this word is zero, we must make sure we're not pointing at the      first bit, otherwise our incrementing to the next word boundary      will fail.  It won't matter if this increment moves us into the      next word.  */
name|start_bit
operator|+=
operator|!
name|bi
operator|->
name|bits
expr_stmt|;
operator|*
name|bit_no
operator|=
name|start_bit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize an iterator to iterate over the intersection of two    bitmaps.  START_BIT is the bit to commence from.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bmp_iter_and_init
parameter_list|(
name|bitmap_iterator
modifier|*
name|bi
parameter_list|,
name|bitmap
name|map1
parameter_list|,
name|bitmap
name|map2
parameter_list|,
name|unsigned
name|start_bit
parameter_list|,
name|unsigned
modifier|*
name|bit_no
parameter_list|)
block|{
name|bi
operator|->
name|elt1
operator|=
name|map1
operator|->
name|first
expr_stmt|;
name|bi
operator|->
name|elt2
operator|=
name|map2
operator|->
name|first
expr_stmt|;
comment|/* Advance elt1 until it is not before the block containing      start_bit.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bi
operator|->
name|elt1
condition|)
block|{
name|bi
operator|->
name|elt2
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|>=
name|start_bit
operator|/
name|BITMAP_ELEMENT_ALL_BITS
condition|)
break|break;
name|bi
operator|->
name|elt1
operator|=
name|bi
operator|->
name|elt1
operator|->
name|next
expr_stmt|;
block|}
comment|/* Advance elt2 until it is not before elt1.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bi
operator|->
name|elt2
condition|)
block|{
name|bi
operator|->
name|elt1
operator|=
name|bi
operator|->
name|elt2
operator|=
operator|&
name|bitmap_zero_bits
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bi
operator|->
name|elt2
operator|->
name|indx
operator|>=
name|bi
operator|->
name|elt1
operator|->
name|indx
condition|)
break|break;
name|bi
operator|->
name|elt2
operator|=
name|bi
operator|->
name|elt2
operator|->
name|next
expr_stmt|;
block|}
comment|/* If we're at the same index, then we have some intersecting bits.  */
if|if
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|==
name|bi
operator|->
name|elt2
operator|->
name|indx
condition|)
block|{
comment|/* We might have advanced beyond the start_bit, so reinitialize 	 for that.  */
if|if
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|!=
name|start_bit
operator|/
name|BITMAP_ELEMENT_ALL_BITS
condition|)
name|start_bit
operator|=
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|*
name|BITMAP_ELEMENT_ALL_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|=
name|start_bit
operator|/
name|BITMAP_WORD_BITS
operator|%
name|BITMAP_ELEMENT_WORDS
expr_stmt|;
name|bi
operator|->
name|bits
operator|=
name|bi
operator|->
name|elt1
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
operator|&
name|bi
operator|->
name|elt2
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
name|bi
operator|->
name|bits
operator|>>=
name|start_bit
operator|%
name|BITMAP_WORD_BITS
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise we must immediately advance elt1, so initialize for 	 that.  */
name|bi
operator|->
name|word_no
operator|=
name|BITMAP_ELEMENT_WORDS
operator|-
literal|1
expr_stmt|;
name|bi
operator|->
name|bits
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this word is zero, we must make sure we're not pointing at the      first bit, otherwise our incrementing to the next word boundary      will fail.  It won't matter if this increment moves us into the      next word.  */
name|start_bit
operator|+=
operator|!
name|bi
operator|->
name|bits
expr_stmt|;
operator|*
name|bit_no
operator|=
name|start_bit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize an iterator to iterate over the bits in MAP1& ~MAP2.    */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bmp_iter_and_compl_init
parameter_list|(
name|bitmap_iterator
modifier|*
name|bi
parameter_list|,
name|bitmap
name|map1
parameter_list|,
name|bitmap
name|map2
parameter_list|,
name|unsigned
name|start_bit
parameter_list|,
name|unsigned
modifier|*
name|bit_no
parameter_list|)
block|{
name|bi
operator|->
name|elt1
operator|=
name|map1
operator|->
name|first
expr_stmt|;
name|bi
operator|->
name|elt2
operator|=
name|map2
operator|->
name|first
expr_stmt|;
comment|/* Advance elt1 until it is not before the block containing start_bit.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bi
operator|->
name|elt1
condition|)
block|{
name|bi
operator|->
name|elt1
operator|=
operator|&
name|bitmap_zero_bits
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|>=
name|start_bit
operator|/
name|BITMAP_ELEMENT_ALL_BITS
condition|)
break|break;
name|bi
operator|->
name|elt1
operator|=
name|bi
operator|->
name|elt1
operator|->
name|next
expr_stmt|;
block|}
comment|/* Advance elt2 until it is not before elt1.  */
while|while
condition|(
name|bi
operator|->
name|elt2
operator|&&
name|bi
operator|->
name|elt2
operator|->
name|indx
operator|<
name|bi
operator|->
name|elt1
operator|->
name|indx
condition|)
name|bi
operator|->
name|elt2
operator|=
name|bi
operator|->
name|elt2
operator|->
name|next
expr_stmt|;
comment|/* We might have advanced beyond the start_bit, so reinitialize for      that.  */
if|if
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|!=
name|start_bit
operator|/
name|BITMAP_ELEMENT_ALL_BITS
condition|)
name|start_bit
operator|=
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|*
name|BITMAP_ELEMENT_ALL_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|=
name|start_bit
operator|/
name|BITMAP_WORD_BITS
operator|%
name|BITMAP_ELEMENT_WORDS
expr_stmt|;
name|bi
operator|->
name|bits
operator|=
name|bi
operator|->
name|elt1
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|elt2
operator|&&
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|==
name|bi
operator|->
name|elt2
operator|->
name|indx
condition|)
name|bi
operator|->
name|bits
operator|&=
operator|~
name|bi
operator|->
name|elt2
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
name|bi
operator|->
name|bits
operator|>>=
name|start_bit
operator|%
name|BITMAP_WORD_BITS
expr_stmt|;
comment|/* If this word is zero, we must make sure we're not pointing at the      first bit, otherwise our incrementing to the next word boundary      will fail.  It won't matter if this increment moves us into the      next word.  */
name|start_bit
operator|+=
operator|!
name|bi
operator|->
name|bits
expr_stmt|;
operator|*
name|bit_no
operator|=
name|start_bit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance to the next bit in BI.  We don't advance to the next    nonzero bit yet.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bmp_iter_next
parameter_list|(
name|bitmap_iterator
modifier|*
name|bi
parameter_list|,
name|unsigned
modifier|*
name|bit_no
parameter_list|)
block|{
name|bi
operator|->
name|bits
operator|>>=
literal|1
expr_stmt|;
operator|*
name|bit_no
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance to the next nonzero bit of a single bitmap, we will have    already advanced past the just iterated bit.  Return true if there    is a bit to iterate.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|bmp_iter_set
parameter_list|(
name|bitmap_iterator
modifier|*
name|bi
parameter_list|,
name|unsigned
modifier|*
name|bit_no
parameter_list|)
block|{
comment|/* If our current word is nonzero, it contains the bit we want.  */
if|if
condition|(
name|bi
operator|->
name|bits
condition|)
block|{
name|next_bit
label|:
while|while
condition|(
operator|!
operator|(
name|bi
operator|->
name|bits
operator|&
literal|1
operator|)
condition|)
block|{
name|bi
operator|->
name|bits
operator|>>=
literal|1
expr_stmt|;
operator|*
name|bit_no
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* Round up to the word boundary.  We might have just iterated past      the end of the last word, hence the -1.  It is not possible for      bit_no to point at the beginning of the now last word.  */
operator|*
name|bit_no
operator|=
operator|(
operator|(
operator|*
name|bit_no
operator|+
name|BITMAP_WORD_BITS
operator|-
literal|1
operator|)
operator|/
name|BITMAP_WORD_BITS
operator|*
name|BITMAP_WORD_BITS
operator|)
expr_stmt|;
name|bi
operator|->
name|word_no
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find the next nonzero word in this elt.  */
while|while
condition|(
name|bi
operator|->
name|word_no
operator|!=
name|BITMAP_ELEMENT_WORDS
condition|)
block|{
name|bi
operator|->
name|bits
operator|=
name|bi
operator|->
name|elt1
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|bits
condition|)
goto|goto
name|next_bit
goto|;
operator|*
name|bit_no
operator|+=
name|BITMAP_WORD_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|++
expr_stmt|;
block|}
comment|/* Advance to the next element.  */
name|bi
operator|->
name|elt1
operator|=
name|bi
operator|->
name|elt1
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|elt1
condition|)
return|return
name|false
return|;
operator|*
name|bit_no
operator|=
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|*
name|BITMAP_ELEMENT_ALL_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Advance to the next nonzero bit of an intersecting pair of    bitmaps.  We will have already advanced past the just iterated bit.    Return true if there is a bit to iterate.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|bmp_iter_and
parameter_list|(
name|bitmap_iterator
modifier|*
name|bi
parameter_list|,
name|unsigned
modifier|*
name|bit_no
parameter_list|)
block|{
comment|/* If our current word is nonzero, it contains the bit we want.  */
if|if
condition|(
name|bi
operator|->
name|bits
condition|)
block|{
name|next_bit
label|:
while|while
condition|(
operator|!
operator|(
name|bi
operator|->
name|bits
operator|&
literal|1
operator|)
condition|)
block|{
name|bi
operator|->
name|bits
operator|>>=
literal|1
expr_stmt|;
operator|*
name|bit_no
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* Round up to the word boundary.  We might have just iterated past      the end of the last word, hence the -1.  It is not possible for      bit_no to point at the beginning of the now last word.  */
operator|*
name|bit_no
operator|=
operator|(
operator|(
operator|*
name|bit_no
operator|+
name|BITMAP_WORD_BITS
operator|-
literal|1
operator|)
operator|/
name|BITMAP_WORD_BITS
operator|*
name|BITMAP_WORD_BITS
operator|)
expr_stmt|;
name|bi
operator|->
name|word_no
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find the next nonzero word in this elt.  */
while|while
condition|(
name|bi
operator|->
name|word_no
operator|!=
name|BITMAP_ELEMENT_WORDS
condition|)
block|{
name|bi
operator|->
name|bits
operator|=
name|bi
operator|->
name|elt1
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
operator|&
name|bi
operator|->
name|elt2
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|bits
condition|)
goto|goto
name|next_bit
goto|;
operator|*
name|bit_no
operator|+=
name|BITMAP_WORD_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|++
expr_stmt|;
block|}
comment|/* Advance to the next identical element.  */
do|do
block|{
comment|/* Advance elt1 while it is less than elt2.  We always want 	     to advance one elt.  */
do|do
block|{
name|bi
operator|->
name|elt1
operator|=
name|bi
operator|->
name|elt1
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|elt1
condition|)
return|return
name|false
return|;
block|}
do|while
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|<
name|bi
operator|->
name|elt2
operator|->
name|indx
condition|)
do|;
comment|/* Advance elt2 to be no less than elt1.  This might not 	     advance.  */
while|while
condition|(
name|bi
operator|->
name|elt2
operator|->
name|indx
operator|<
name|bi
operator|->
name|elt1
operator|->
name|indx
condition|)
block|{
name|bi
operator|->
name|elt2
operator|=
name|bi
operator|->
name|elt2
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|elt2
condition|)
return|return
name|false
return|;
block|}
block|}
do|while
condition|(
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|!=
name|bi
operator|->
name|elt2
operator|->
name|indx
condition|)
do|;
operator|*
name|bit_no
operator|=
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|*
name|BITMAP_ELEMENT_ALL_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Advance to the next nonzero bit in the intersection of    complemented bitmaps.  We will have already advanced past the just    iterated bit.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|bmp_iter_and_compl
parameter_list|(
name|bitmap_iterator
modifier|*
name|bi
parameter_list|,
name|unsigned
modifier|*
name|bit_no
parameter_list|)
block|{
comment|/* If our current word is nonzero, it contains the bit we want.  */
if|if
condition|(
name|bi
operator|->
name|bits
condition|)
block|{
name|next_bit
label|:
while|while
condition|(
operator|!
operator|(
name|bi
operator|->
name|bits
operator|&
literal|1
operator|)
condition|)
block|{
name|bi
operator|->
name|bits
operator|>>=
literal|1
expr_stmt|;
operator|*
name|bit_no
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* Round up to the word boundary.  We might have just iterated past      the end of the last word, hence the -1.  It is not possible for      bit_no to point at the beginning of the now last word.  */
operator|*
name|bit_no
operator|=
operator|(
operator|(
operator|*
name|bit_no
operator|+
name|BITMAP_WORD_BITS
operator|-
literal|1
operator|)
operator|/
name|BITMAP_WORD_BITS
operator|*
name|BITMAP_WORD_BITS
operator|)
expr_stmt|;
name|bi
operator|->
name|word_no
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find the next nonzero word in this elt.  */
while|while
condition|(
name|bi
operator|->
name|word_no
operator|!=
name|BITMAP_ELEMENT_WORDS
condition|)
block|{
name|bi
operator|->
name|bits
operator|=
name|bi
operator|->
name|elt1
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|elt2
operator|&&
name|bi
operator|->
name|elt2
operator|->
name|indx
operator|==
name|bi
operator|->
name|elt1
operator|->
name|indx
condition|)
name|bi
operator|->
name|bits
operator|&=
operator|~
name|bi
operator|->
name|elt2
operator|->
name|bits
index|[
name|bi
operator|->
name|word_no
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|bits
condition|)
goto|goto
name|next_bit
goto|;
operator|*
name|bit_no
operator|+=
name|BITMAP_WORD_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|++
expr_stmt|;
block|}
comment|/* Advance to the next element of elt1.  */
name|bi
operator|->
name|elt1
operator|=
name|bi
operator|->
name|elt1
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|bi
operator|->
name|elt1
condition|)
return|return
name|false
return|;
comment|/* Advance elt2 until it is no less than elt1.  */
while|while
condition|(
name|bi
operator|->
name|elt2
operator|&&
name|bi
operator|->
name|elt2
operator|->
name|indx
operator|<
name|bi
operator|->
name|elt1
operator|->
name|indx
condition|)
name|bi
operator|->
name|elt2
operator|=
name|bi
operator|->
name|elt2
operator|->
name|next
expr_stmt|;
operator|*
name|bit_no
operator|=
name|bi
operator|->
name|elt1
operator|->
name|indx
operator|*
name|BITMAP_ELEMENT_ALL_BITS
expr_stmt|;
name|bi
operator|->
name|word_no
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Loop over all bits set in BITMAP, starting with MIN and setting    BITNUM to the bit number.  ITER is a bitmap iterator.  BITNUM    should be treated as a read-only variable as it contains loop    state.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_SET_IN_BITMAP
parameter_list|(
name|BITMAP
parameter_list|,
name|MIN
parameter_list|,
name|BITNUM
parameter_list|,
name|ITER
parameter_list|)
define|\
value|for (bmp_iter_set_init (&(ITER), (BITMAP), (MIN),&(BITNUM));		\        bmp_iter_set (&(ITER),&(BITNUM));				\        bmp_iter_next (&(ITER),&(BITNUM)))
end_define

begin_comment
comment|/* Loop over all the bits set in BITMAP1& BITMAP2, starting with MIN    and setting BITNUM to the bit number.  ITER is a bitmap iterator.    BITNUM should be treated as a read-only variable as it contains    loop state.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_AND_IN_BITMAP
parameter_list|(
name|BITMAP1
parameter_list|,
name|BITMAP2
parameter_list|,
name|MIN
parameter_list|,
name|BITNUM
parameter_list|,
name|ITER
parameter_list|)
define|\
value|for (bmp_iter_and_init (&(ITER), (BITMAP1), (BITMAP2), (MIN),		\&(BITNUM));					\        bmp_iter_and (&(ITER),&(BITNUM));				\        bmp_iter_next (&(ITER),&(BITNUM)))
end_define

begin_comment
comment|/* Loop over all the bits set in BITMAP1& ~BITMAP2, starting with MIN    and setting BITNUM to the bit number.  ITER is a bitmap iterator.    BITNUM should be treated as a read-only variable as it contains    loop state.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_AND_COMPL_IN_BITMAP
parameter_list|(
name|BITMAP1
parameter_list|,
name|BITMAP2
parameter_list|,
name|MIN
parameter_list|,
name|BITNUM
parameter_list|,
name|ITER
parameter_list|)
define|\
value|for (bmp_iter_and_compl_init (&(ITER), (BITMAP1), (BITMAP2), (MIN),	\&(BITNUM));				\        bmp_iter_and_compl (&(ITER),&(BITNUM));				\        bmp_iter_next (&(ITER),&(BITNUM)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC_BITMAP_H */
end_comment

end_unit

