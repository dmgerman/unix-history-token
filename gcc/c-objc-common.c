begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Some code common to C and ObjC front ends.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-pretty-print.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"c-objc-common.h"
end_include

begin_function_decl
specifier|static
name|bool
name|c_tree_printer
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|text_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|bool
name|c_missing_noreturn_ok_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* A missing noreturn is not ok for freestanding implementations and      ok for the `main' function in hosted implementations.  */
return|return
name|flag_hosted
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We want to inline `extern inline' functions even if this would    violate inlining limits.  Some glibc and linux constructs depend on    such functions always being inlined when optimizing.  */
end_comment

begin_function
name|int
name|c_disregard_inline_limits
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
return|return
operator|(
operator|!
name|flag_really_no_inline
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|c_cannot_inline_tree_fn
parameter_list|(
name|tree
modifier|*
name|fnp
parameter_list|)
block|{
name|tree
name|fn
init|=
operator|*
name|fnp
decl_stmt|;
name|bool
name|do_warning
init|=
operator|(
name|warn_inline
operator|&&
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|fn
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|flag_really_no_inline
operator|&&
name|lookup_attribute
argument_list|(
literal|"always_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
name|OPT_Winline
argument_list|,
literal|"function %q+F can never be inlined because it "
literal|"is suppressed using -fno-inline"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
comment|/* Don't auto-inline anything that might not be bound within      this unit of translation.  */
if|if
condition|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
name|OPT_Winline
argument_list|,
literal|"function %q+F can never be inlined because it "
literal|"might not be bound within this unit of translation"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
if|if
condition|(
operator|!
name|function_attribute_inlinable_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_warning
condition|)
name|warning
argument_list|(
name|OPT_Winline
argument_list|,
literal|"function %q+F can never be inlined because it "
literal|"uses attributes conflicting with inlining"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|cannot_inline
goto|;
block|}
return|return
literal|0
return|;
name|cannot_inline
label|:
name|DECL_UNINLINABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called from check_global_declarations.  */
end_comment

begin_function
name|bool
name|c_warn_unused_global_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Initialization common to C and Objective-C front ends.  */
end_comment

begin_function
name|bool
name|c_objc_common_init
parameter_list|(
name|void
parameter_list|)
block|{
name|c_init_decl_processing
argument_list|()
expr_stmt|;
if|if
condition|(
name|c_common_init
argument_list|()
operator|==
name|false
condition|)
return|return
name|false
return|;
comment|/* These were not defined in the Objective-C front end, but I'm      putting them here anyway.  The diagnostic format decoder might      want an enhanced ObjC implementation.  */
name|diagnostic_format_decoder
argument_list|(
name|global_dc
argument_list|)
operator|=
operator|&
name|c_tree_printer
expr_stmt|;
comment|/* If still unspecified, make it match -std=c99      (allowing for -pedantic-errors).  */
if|if
condition|(
name|mesg_implicit_function_declaration
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|flag_isoc99
condition|)
name|mesg_implicit_function_declaration
operator|=
name|flag_pedantic_errors
condition|?
literal|2
else|:
literal|1
expr_stmt|;
else|else
name|mesg_implicit_function_declaration
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Called during diagnostic message formatting process to print a    source-level entity onto BUFFER.  The meaning of the format specifiers    is as follows:    %D: a general decl,    %E: an identifier or expression,    %F: a function declaration,    %T: a type.     These format specifiers form a subset of the format specifiers set used    by the C++ front-end.    Please notice when called, the `%' part was already skipped by the    diagnostic machinery.  */
end_comment

begin_function
specifier|static
name|bool
name|c_tree_printer
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|,
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|int
name|precision
parameter_list|,
name|bool
name|wide
parameter_list|,
name|bool
name|set_locus
parameter_list|,
name|bool
name|hash
parameter_list|)
block|{
name|tree
name|t
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|tree
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|n
init|=
literal|"({anonymous})"
decl_stmt|;
name|c_pretty_printer
modifier|*
name|cpp
init|=
operator|(
name|c_pretty_printer
operator|*
operator|)
name|pp
decl_stmt|;
name|pp
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
if|if
condition|(
name|precision
operator|!=
literal|0
operator|||
name|wide
operator|||
name|hash
condition|)
return|return
name|false
return|;
if|if
condition|(
name|set_locus
operator|&&
name|text
operator|->
name|locus
condition|)
operator|*
name|text
operator|->
name|locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|spec
condition|)
block|{
case|case
literal|'D'
case|:
if|if
condition|(
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|DECL_DEBUG_EXPR
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_c_expression
argument_list|(
name|cpp
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* FALLTHRU */
case|case
literal|'F'
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|n
operator|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|name
argument_list|)
condition|)
name|pp_string
argument_list|(
name|cpp
argument_list|,
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_type_id
argument_list|(
name|cpp
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|pp_type_id
argument_list|(
name|cpp
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|n
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|pp_expression
argument_list|(
name|cpp
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
default|default:
return|return
name|false
return|;
block|}
name|pp_string
argument_list|(
name|cpp
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* In C and ObjC, all decls have "C" linkage.  */
end_comment

begin_function
name|bool
name|has_c_linkage
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|c_initialize_diagnostics
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|pretty_printer
modifier|*
name|base
init|=
name|context
operator|->
name|printer
decl_stmt|;
name|c_pretty_printer
modifier|*
name|pp
init|=
name|XNEW
argument_list|(
name|c_pretty_printer
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|pp_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|pretty_printer
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_pretty_printer_init
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|context
operator|->
name|printer
operator|=
operator|(
name|pretty_printer
operator|*
operator|)
name|pp
expr_stmt|;
comment|/* It is safe to free this object because it was previously XNEW()'d.  */
name|XDELETE
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|c_types_compatible_p
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|y
parameter_list|)
block|{
return|return
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|y
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if the type is a vla type for the backend.  */
end_comment

begin_function
name|bool
name|c_vla_unspec_p
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|fn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|c_vla_type_p
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

end_unit

