begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ARM EABI compliant unwinding routines    Copyright (C) 2004, 2005 Free Software Foundation, Inc.    Contributed by Paul Brook      This file is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combine    executable.)     This file is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_comment
comment|/* We add a prototype for abort here to avoid creating a dependency on    target headers.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|abort
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|struct
name|_ZSt9type_info
name|type_info
typedef|;
end_typedef

begin_comment
comment|/* This names C++ type_info type */
end_comment

begin_comment
comment|/* Misc constants.  */
end_comment

begin_define
define|#
directive|define
name|R_IP
value|12
end_define

begin_define
define|#
directive|define
name|R_SP
value|13
end_define

begin_define
define|#
directive|define
name|R_LR
value|14
end_define

begin_define
define|#
directive|define
name|R_PC
value|15
end_define

begin_define
define|#
directive|define
name|uint32_highbit
value|(((_uw) 1)<< 31)
end_define

begin_decl_stmt
name|void
name|__attribute__
argument_list|(
operator|(
name|weak
operator|)
argument_list|)
name|__cxa_call_unexpected
argument_list|(
name|_Unwind_Control_Block
operator|*
name|ucbp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unwind descriptors.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|_uw16
name|length
decl_stmt|;
name|_uw16
name|offset
decl_stmt|;
block|}
name|EHT16
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|_uw
name|length
decl_stmt|;
name|_uw
name|offset
decl_stmt|;
block|}
name|EHT32
typedef|;
end_typedef

begin_comment
comment|/* Calculate the address encoded by a 31-bit self-relative offset at address    P.  Copy of routine in unwind-arm.c.  */
end_comment

begin_function
specifier|static
specifier|inline
name|_uw
name|selfrel_offset31
parameter_list|(
specifier|const
name|_uw
modifier|*
name|p
parameter_list|)
block|{
name|_uw
name|offset
decl_stmt|;
name|offset
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Sign extend to 32 bits.  */
if|if
condition|(
name|offset
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
name|offset
operator||=
literal|1u
operator|<<
literal|31
expr_stmt|;
return|return
name|offset
operator|+
operator|(
name|_uw
operator|)
name|p
return|;
block|}
end_function

begin_comment
comment|/* Personality routine helper functions.  */
end_comment

begin_define
define|#
directive|define
name|CODE_FINISH
value|(0xb0)
end_define

begin_comment
comment|/* Return the next byte of unwinding information, or CODE_FINISH if there is    no data remaining.  */
end_comment

begin_function
specifier|static
specifier|inline
name|_uw8
name|next_unwind_byte
parameter_list|(
name|__gnu_unwind_state
modifier|*
name|uws
parameter_list|)
block|{
name|_uw8
name|b
decl_stmt|;
if|if
condition|(
name|uws
operator|->
name|bytes_left
operator|==
literal|0
condition|)
block|{
comment|/* Load another word */
if|if
condition|(
name|uws
operator|->
name|words_left
operator|==
literal|0
condition|)
return|return
name|CODE_FINISH
return|;
comment|/* Nothing left.  */
name|uws
operator|->
name|words_left
operator|--
expr_stmt|;
name|uws
operator|->
name|data
operator|=
operator|*
operator|(
name|uws
operator|->
name|next
operator|++
operator|)
expr_stmt|;
name|uws
operator|->
name|bytes_left
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|uws
operator|->
name|bytes_left
operator|--
expr_stmt|;
comment|/* Extract the most significant byte.  */
name|b
operator|=
operator|(
name|uws
operator|->
name|data
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|uws
operator|->
name|data
operator|<<=
literal|8
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Execute the unwinding instructions described by UWS.  */
end_comment

begin_function
name|_Unwind_Reason_Code
name|__gnu_unwind_execute
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|__gnu_unwind_state
modifier|*
name|uws
parameter_list|)
block|{
name|_uw
name|op
decl_stmt|;
name|int
name|set_pc
decl_stmt|;
name|_uw
name|reg
decl_stmt|;
name|set_pc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|CODE_FINISH
condition|)
block|{
comment|/* If we haven't already set pc then copy it from lr.  */
if|if
condition|(
operator|!
name|set_pc
condition|)
block|{
name|_Unwind_VRS_Get
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|R_LR
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|_Unwind_VRS_Set
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|R_PC
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|set_pc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Drop out of the loop.  */
break|break;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* vsp = vsp +- (imm6<< 2 + 4).  */
name|_uw
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
operator|(
name|op
operator|&
literal|0x3f
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
name|_Unwind_VRS_Get
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|R_SP
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|0x40
condition|)
name|reg
operator|-=
name|offset
expr_stmt|;
else|else
name|reg
operator|+=
name|offset
expr_stmt|;
name|_Unwind_VRS_Set
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|R_SP
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0x80
condition|)
block|{
name|op
operator|=
operator|(
name|op
operator|<<
literal|8
operator|)
operator||
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x8000
condition|)
block|{
comment|/* Refuse to unwind.  */
return|return
name|_URC_FAILURE
return|;
block|}
comment|/* Pop r4-r15 under mask.  */
name|op
operator|=
operator|(
name|op
operator|<<
literal|4
operator|)
operator|&
literal|0xfff0
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|op
argument_list|,
name|_UVRSD_UINT32
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
if|if
condition|(
name|op
operator|&
operator|(
literal|1
operator|<<
name|R_PC
operator|)
condition|)
name|set_pc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0x90
condition|)
block|{
name|op
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|13
operator|||
name|op
operator|==
literal|15
condition|)
comment|/* Reserved.  */
return|return
name|_URC_FAILURE
return|;
comment|/* vsp = r[nnnn].  */
name|_Unwind_VRS_Get
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|op
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|_Unwind_VRS_Set
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|R_SP
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0xa0
condition|)
block|{
comment|/* Pop r4-r[4+nnn], [lr].  */
name|_uw
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
literal|0xff0
operator|>>
operator|(
literal|7
operator|-
operator|(
name|op
operator|&
literal|7
operator|)
operator|)
operator|)
operator|&
literal|0xff0
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|8
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|R_LR
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|mask
argument_list|,
name|_UVRSD_UINT32
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0xb0
condition|)
block|{
comment|/* op == 0xb0 already handled.  */
if|if
condition|(
name|op
operator|==
literal|0xb1
condition|)
block|{
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
operator|||
operator|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
operator|)
condition|)
comment|/* Spare.  */
return|return
name|_URC_FAILURE
return|;
comment|/* Pop r0-r4 under mask.  */
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|op
argument_list|,
name|_UVRSD_UINT32
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|==
literal|0xb2
condition|)
block|{
comment|/* vsp = vsp + 0x204 + (uleb128<< 2).  */
name|int
name|shift
decl_stmt|;
name|_Unwind_VRS_Get
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|R_SP
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
name|shift
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|op
operator|&
literal|0x80
condition|)
block|{
name|reg
operator|+=
operator|(
operator|(
name|op
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
block|}
name|reg
operator|+=
operator|(
operator|(
name|op
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
operator|+
literal|0x204
expr_stmt|;
name|_Unwind_VRS_Set
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|R_SP
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|==
literal|0xb3
condition|)
block|{
comment|/* Pop VFP registers with fldmx.  */
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_VFP
argument_list|,
name|op
argument_list|,
name|_UVRSD_VFPX
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc
operator|)
operator|==
literal|0xb4
condition|)
block|{
comment|/* Pop FPA E[4]-E[4+nn].  */
name|op
operator|=
literal|0x40000
operator||
operator|(
operator|(
name|op
operator|&
literal|3
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_FPA
argument_list|,
name|op
argument_list|,
name|_UVRSD_FPAX
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
comment|/* op& 0xf8 == 0xb8.  */
comment|/* Pop VFP D[8]-D[8+nnn] with fldmx.  */
name|op
operator|=
literal|0x80000
operator||
operator|(
operator|(
name|op
operator|&
literal|7
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_VFP
argument_list|,
name|op
argument_list|,
name|_UVRSD_VFPX
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0xc0
condition|)
block|{
if|if
condition|(
name|op
operator|==
literal|0xc6
condition|)
block|{
comment|/* Pop iWMMXt D registers.  */
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_WMMXD
argument_list|,
name|op
argument_list|,
name|_UVRSD_UINT64
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|==
literal|0xc7
condition|)
block|{
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
operator|||
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
condition|)
comment|/* Spare.  */
return|return
name|_URC_FAILURE
return|;
comment|/* Pop iWMMXt wCGR{3,2,1,0} under mask.  */
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_WMMXC
argument_list|,
name|op
argument_list|,
name|_UVRSD_UINT32
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf8
operator|)
operator|==
literal|0xc0
condition|)
block|{
comment|/* Pop iWMMXt wR[10]-wR[10+nnn].  */
name|op
operator|=
literal|0xa0000
operator||
operator|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_WMMXD
argument_list|,
name|op
argument_list|,
name|_UVRSD_UINT64
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|==
literal|0xc8
condition|)
block|{
comment|/* Pop FPA registers.  */
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_FPA
argument_list|,
name|op
argument_list|,
name|_UVRSD_FPAX
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|==
literal|0xc9
condition|)
block|{
comment|/* Pop VFP registers with fldmd.  */
name|op
operator|=
name|next_unwind_byte
argument_list|(
name|uws
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_VFP
argument_list|,
name|op
argument_list|,
name|_UVRSD_DOUBLE
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
comment|/* Spare.  */
return|return
name|_URC_FAILURE
return|;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf8
operator|)
operator|==
literal|0xd0
condition|)
block|{
comment|/* Pop VFP D[8]-D[8+nnn] with fldmd.  */
name|op
operator|=
literal|0x80000
operator||
operator|(
operator|(
name|op
operator|&
literal|7
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|_Unwind_VRS_Pop
argument_list|(
name|context
argument_list|,
name|_UVRSC_VFP
argument_list|,
name|op
argument_list|,
name|_UVRSD_DOUBLE
argument_list|)
operator|!=
name|_UVRSR_OK
condition|)
return|return
name|_URC_FAILURE
return|;
continue|continue;
block|}
comment|/* Spare.  */
return|return
name|_URC_FAILURE
return|;
block|}
return|return
name|_URC_OK
return|;
block|}
end_function

begin_comment
comment|/* Execute the unwinding instructions associated with a frame.  UCBP and    CONTEXT are the current exception object and virtual CPU state    respectively.  */
end_comment

begin_function
name|_Unwind_Reason_Code
name|__gnu_unwind_frame
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|_uw
modifier|*
name|ptr
decl_stmt|;
name|__gnu_unwind_state
name|uws
decl_stmt|;
name|ptr
operator|=
operator|(
name|_uw
operator|*
operator|)
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
expr_stmt|;
comment|/* Skip over the personality routine address.  */
name|ptr
operator|++
expr_stmt|;
comment|/* Setup the unwinder state.  */
name|uws
operator|.
name|data
operator|=
operator|(
operator|*
name|ptr
operator|)
operator|<<
literal|8
expr_stmt|;
name|uws
operator|.
name|next
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
name|uws
operator|.
name|bytes_left
operator|=
literal|3
expr_stmt|;
name|uws
operator|.
name|words_left
operator|=
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
name|__gnu_unwind_execute
argument_list|(
name|context
argument_list|,
operator|&
name|uws
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the _Unwind_Control_Block from an _Unwind_Context.  */
end_comment

begin_function
specifier|static
specifier|inline
name|_Unwind_Control_Block
modifier|*
name|unwind_UCB_from_context
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Control_Block
operator|*
operator|)
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_IP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the start address of the function being unwound.  */
end_comment

begin_function
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|_Unwind_Control_Block
modifier|*
name|ucbp
decl_stmt|;
name|ucbp
operator|=
name|unwind_UCB_from_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|ucbp
operator|->
name|pr_cache
operator|.
name|fnstart
return|;
block|}
end_function

begin_comment
comment|/* Find the Language specific exception data.  */
end_comment

begin_function
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
name|_Unwind_Control_Block
modifier|*
name|ucbp
decl_stmt|;
name|_uw
modifier|*
name|ptr
decl_stmt|;
comment|/* Get a pointer to the exception table entry.  */
name|ucbp
operator|=
name|unwind_UCB_from_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|_uw
operator|*
operator|)
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
expr_stmt|;
comment|/* Skip the personality routine address.  */
name|ptr
operator|++
expr_stmt|;
comment|/* Skip the unwind opcodes.  */
name|ptr
operator|+=
operator|(
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|+
literal|1
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

end_unit

