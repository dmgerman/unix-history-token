begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 128-bit long double support routines for Darwin.    Copyright (C) 1993, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Implementations of floating-point long double basic arithmetic    functions called by the IBM C compiler when generating code for    PowerPC platforms.  In particular, the following functions are    implemented: __gcc_qadd, __gcc_qsub, __gcc_qmul, and __gcc_qdiv.    Double-double algorithms are based on the paper "Doubled-Precision    IEEE Standard 754 Floating-Point Arithmetic" by W. Kahan, February 26,    1987.  An alternative published reference is "Software for    Doubled-Precision Floating-Point Computations", by Seppo Linnainmaa,    ACM TOMS vol 7 no 3, September 1981, pages 272-283.  */
end_comment

begin_comment
comment|/* Each long double is made up of two IEEE doubles.  The value of the    long double is the sum of the values of the two parts.  The most    significant part is required to be the value of the long double    rounded to the nearest double, as specified by IEEE.  For Inf    values, the least significant part is required to be one of +0.0 or    -0.0.  No other requirements are made; so, for example, 1.0 may be    represented as (1.0, +0.0) or (1.0, -0.0), and the low part of a    NaN is don't-care.     This code currently assumes big-endian.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|(
operator|!
name|defined
argument_list|(
name|__NO_FPRS__
argument_list|)
operator|||
name|defined
argument_list|(
name|_SOFT_FLOAT
argument_list|)
operator|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|__LITTLE_ENDIAN__
argument_list|)
expr|\
operator|&&
operator|(
name|defined
argument_list|(
name|__MACH__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|fabs
parameter_list|(
name|x
parameter_list|)
value|__builtin_fabs(x)
end_define

begin_define
define|#
directive|define
name|isless
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|__builtin_isless (x, y)
end_define

begin_define
define|#
directive|define
name|inf
parameter_list|()
value|__builtin_inf()
end_define

begin_define
define|#
directive|define
name|unlikely
parameter_list|(
name|x
parameter_list|)
value|__builtin_expect ((x), 0)
end_define

begin_define
define|#
directive|define
name|nonfinite
parameter_list|(
name|a
parameter_list|)
value|unlikely (! isless (fabs (a), inf ()))
end_define

begin_comment
comment|/* Define ALIASNAME as a strong alias for NAME.  */
end_comment

begin_define
define|#
directive|define
name|strong_alias
parameter_list|(
name|name
parameter_list|,
name|aliasname
parameter_list|)
value|_strong_alias(name, aliasname)
end_define

begin_define
define|#
directive|define
name|_strong_alias
parameter_list|(
name|name
parameter_list|,
name|aliasname
parameter_list|)
define|\
value|extern __typeof (name) aliasname __attribute__ ((alias (#name)));
end_define

begin_comment
comment|/* All these routines actually take two long doubles as parameters,    but GCC currently generates poor code when a union is used to turn    a long double into a pair of doubles.  */
end_comment

begin_function_decl
name|long
name|double
name|__gcc_qadd
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|double
name|__gcc_qsub
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|double
name|__gcc_qmul
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|double
name|__gcc_qdiv
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
name|__ELF__
operator|&&
name|defined
name|SHARED
expr|\
operator|&&
operator|(
name|defined
name|__powerpc64__
operator|||
operator|!
operator|(
name|defined
name|__linux__
operator|||
name|defined
name|__gnu_hurd__
operator|)
operator|)
end_if

begin_comment
comment|/* Provide definitions of the old symbol names to satisfy apps and    shared libs built against an older libgcc.  To access the _xlq    symbols an explicit version reference is needed, so these won't    satisfy an unadorned reference like _xlqadd.  If dot symbols are    not needed, the assembler will remove the aliases from the symbol    table.  */
end_comment

begin_asm
asm|__asm__ (".symver __gcc_qadd,_xlqadd@GCC_3.4\n\t" 	 ".symver __gcc_qsub,_xlqsub@GCC_3.4\n\t" 	 ".symver __gcc_qmul,_xlqmul@GCC_3.4\n\t" 	 ".symver __gcc_qdiv,_xlqdiv@GCC_3.4\n\t" 	 ".symver .__gcc_qadd,._xlqadd@GCC_3.4\n\t" 	 ".symver .__gcc_qsub,._xlqsub@GCC_3.4\n\t" 	 ".symver .__gcc_qmul,._xlqmul@GCC_3.4\n\t" 	 ".symver .__gcc_qdiv,._xlqdiv@GCC_3.4");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
union|union
block|{
name|long
name|double
name|ldval
decl_stmt|;
name|double
name|dval
index|[
literal|2
index|]
decl_stmt|;
block|}
name|longDblUnion
typedef|;
end_typedef

begin_comment
comment|/* Add two 'long double' values and return the result.	*/
end_comment

begin_function
name|long
name|double
name|__gcc_qadd
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|cc
parameter_list|)
block|{
name|longDblUnion
name|x
decl_stmt|;
name|double
name|z
decl_stmt|,
name|q
decl_stmt|,
name|zz
decl_stmt|,
name|xh
decl_stmt|;
name|z
operator|=
name|a
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|nonfinite
argument_list|(
name|z
argument_list|)
condition|)
block|{
name|z
operator|=
name|cc
operator|+
name|aa
operator|+
name|c
operator|+
name|a
expr_stmt|;
if|if
condition|(
name|nonfinite
argument_list|(
name|z
argument_list|)
condition|)
return|return
name|z
return|;
name|x
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
comment|/* Will always be DBL_MAX.  */
name|zz
operator|=
name|aa
operator|+
name|cc
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|a
argument_list|)
operator|>
name|fabs
argument_list|(
name|c
argument_list|)
condition|)
name|x
operator|.
name|dval
index|[
literal|1
index|]
operator|=
name|a
operator|-
name|z
operator|+
name|c
operator|+
name|zz
expr_stmt|;
else|else
name|x
operator|.
name|dval
index|[
literal|1
index|]
operator|=
name|c
operator|-
name|z
operator|+
name|a
operator|+
name|zz
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|a
operator|-
name|z
expr_stmt|;
name|zz
operator|=
name|q
operator|+
name|c
operator|+
operator|(
name|a
operator|-
operator|(
name|q
operator|+
name|z
operator|)
operator|)
operator|+
name|aa
operator|+
name|cc
expr_stmt|;
comment|/* Keep -0 result.  */
if|if
condition|(
name|zz
operator|==
literal|0.0
condition|)
return|return
name|z
return|;
name|xh
operator|=
name|z
operator|+
name|zz
expr_stmt|;
if|if
condition|(
name|nonfinite
argument_list|(
name|xh
argument_list|)
condition|)
return|return
name|xh
return|;
name|x
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|xh
expr_stmt|;
name|x
operator|.
name|dval
index|[
literal|1
index|]
operator|=
name|z
operator|-
name|xh
operator|+
name|zz
expr_stmt|;
block|}
return|return
name|x
operator|.
name|ldval
return|;
block|}
end_function

begin_function
name|long
name|double
name|__gcc_qsub
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|d
parameter_list|)
block|{
return|return
name|__gcc_qadd
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|-
name|c
argument_list|,
operator|-
name|d
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_SOFT_FLOAT
end_ifdef

begin_function_decl
specifier|static
name|double
name|fmsub
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|long
name|double
name|__gcc_qmul
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|d
parameter_list|)
block|{
name|longDblUnion
name|z
decl_stmt|;
name|double
name|t
decl_stmt|,
name|tau
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|;
name|t
operator|=
name|a
operator|*
name|c
expr_stmt|;
comment|/* Highest order double term.  */
if|if
condition|(
name|unlikely
argument_list|(
name|t
operator|==
literal|0
argument_list|)
comment|/* Preserve -0.  */
operator|||
name|nonfinite
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Sum terms of two highest orders. */
comment|/* Use fused multiply-add to get low part of a * c.  */
ifndef|#
directive|ifndef
name|_SOFT_FLOAT
asm|asm ("fmsub %0,%1,%2,%3" : "=f"(tau) : "f"(a), "f"(c), "f"(t));
else|#
directive|else
name|tau
operator|=
name|fmsub
argument_list|(
name|a
argument_list|,
name|c
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|a
operator|*
name|d
expr_stmt|;
name|w
operator|=
name|b
operator|*
name|c
expr_stmt|;
name|tau
operator|+=
name|v
operator|+
name|w
expr_stmt|;
comment|/* Add in other second-order terms.	 */
name|u
operator|=
name|t
operator|+
name|tau
expr_stmt|;
comment|/* Construct long double result.  */
if|if
condition|(
name|nonfinite
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|u
return|;
name|z
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|u
expr_stmt|;
name|z
operator|.
name|dval
index|[
literal|1
index|]
operator|=
operator|(
name|t
operator|-
name|u
operator|)
operator|+
name|tau
expr_stmt|;
return|return
name|z
operator|.
name|ldval
return|;
block|}
end_function

begin_function
name|long
name|double
name|__gcc_qdiv
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|d
parameter_list|)
block|{
name|longDblUnion
name|z
decl_stmt|;
name|double
name|s
decl_stmt|,
name|sigma
decl_stmt|,
name|t
decl_stmt|,
name|tau
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|;
name|t
operator|=
name|a
operator|/
name|c
expr_stmt|;
comment|/* highest order double term */
if|if
condition|(
name|unlikely
argument_list|(
name|t
operator|==
literal|0
argument_list|)
comment|/* Preserve -0.  */
operator|||
name|nonfinite
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Finite nonzero result requires corrections to the highest order term.  */
name|s
operator|=
name|c
operator|*
name|t
expr_stmt|;
comment|/* (s,sigma) = c*t exactly.  */
name|w
operator|=
operator|-
operator|(
operator|-
name|b
operator|+
name|d
operator|*
name|t
operator|)
expr_stmt|;
comment|/* Written to get fnmsub for speed, but not 			   numerically necessary.  */
comment|/* Use fused multiply-add to get low part of c * t.	 */
ifndef|#
directive|ifndef
name|_SOFT_FLOAT
asm|asm ("fmsub %0,%1,%2,%3" : "=f"(sigma) : "f"(c), "f"(t), "f"(s));
else|#
directive|else
name|sigma
operator|=
name|fmsub
argument_list|(
name|c
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|a
operator|-
name|s
expr_stmt|;
name|tau
operator|=
operator|(
operator|(
name|v
operator|-
name|sigma
operator|)
operator|+
name|w
operator|)
operator|/
name|c
expr_stmt|;
comment|/* Correction to t.  */
name|u
operator|=
name|t
operator|+
name|tau
expr_stmt|;
comment|/* Construct long double result.  */
if|if
condition|(
name|nonfinite
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|u
return|;
name|z
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|u
expr_stmt|;
name|z
operator|.
name|dval
index|[
literal|1
index|]
operator|=
operator|(
name|t
operator|-
name|u
operator|)
operator|+
name|tau
expr_stmt|;
return|return
name|z
operator|.
name|ldval
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_SOFT_FLOAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|__LONG_DOUBLE_128__
argument_list|)
end_if

begin_function_decl
name|long
name|double
name|__gcc_qneg
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__gcc_qeq
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__gcc_qne
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__gcc_qge
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__gcc_qle
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__gcc_qunord
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|double
name|__gcc_stoq
parameter_list|(
name|float
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|double
name|__gcc_dtoq
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|float
name|__gcc_qtos
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|__gcc_qtod
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__gcc_qtoi
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|int
name|__gcc_qtou
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|double
name|__gcc_itoq
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|double
name|__gcc_utoq
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|__eqdf2
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|__ledf2
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|__gedf2
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|__unorddf2
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Negate 'long double' value and return the result.	*/
end_comment

begin_function
name|long
name|double
name|__gcc_qneg
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|)
block|{
name|longDblUnion
name|x
decl_stmt|;
name|x
operator|.
name|dval
index|[
literal|0
index|]
operator|=
operator|-
name|a
expr_stmt|;
name|x
operator|.
name|dval
index|[
literal|1
index|]
operator|=
operator|-
name|aa
expr_stmt|;
return|return
name|x
operator|.
name|ldval
return|;
block|}
end_function

begin_comment
comment|/* Compare two 'long double' values for equality.  */
end_comment

begin_function
name|int
name|__gcc_qeq
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|cc
parameter_list|)
block|{
if|if
condition|(
name|__eqdf2
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|==
literal|0
condition|)
return|return
name|__eqdf2
argument_list|(
name|aa
argument_list|,
name|cc
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|strong_alias
argument_list|(
name|__gcc_qeq
argument_list|,
name|__gcc_qne
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Compare two 'long double' values for less than or equal.  */
end_comment

begin_function
name|int
name|__gcc_qle
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|cc
parameter_list|)
block|{
if|if
condition|(
name|__eqdf2
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|==
literal|0
condition|)
return|return
name|__ledf2
argument_list|(
name|aa
argument_list|,
name|cc
argument_list|)
return|;
return|return
name|__ledf2
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|strong_alias
argument_list|(
name|__gcc_qle
argument_list|,
name|__gcc_qlt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Compare two 'long double' values for greater than or equal.  */
end_comment

begin_function
name|int
name|__gcc_qge
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|cc
parameter_list|)
block|{
if|if
condition|(
name|__eqdf2
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|==
literal|0
condition|)
return|return
name|__gedf2
argument_list|(
name|aa
argument_list|,
name|cc
argument_list|)
return|;
return|return
name|__gedf2
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|strong_alias
argument_list|(
name|__gcc_qge
argument_list|,
name|__gcc_qgt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Compare two 'long double' values for unordered.  */
end_comment

begin_function
name|int
name|__gcc_qunord
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|,
name|double
name|c
parameter_list|,
name|double
name|cc
parameter_list|)
block|{
if|if
condition|(
name|__eqdf2
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|==
literal|0
condition|)
return|return
name|__unorddf2
argument_list|(
name|aa
argument_list|,
name|cc
argument_list|)
return|;
return|return
name|__unorddf2
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert single to long double.  */
end_comment

begin_function
name|long
name|double
name|__gcc_stoq
parameter_list|(
name|float
name|a
parameter_list|)
block|{
name|longDblUnion
name|x
decl_stmt|;
name|x
operator|.
name|dval
index|[
literal|0
index|]
operator|=
operator|(
name|double
operator|)
name|a
expr_stmt|;
name|x
operator|.
name|dval
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
return|return
name|x
operator|.
name|ldval
return|;
block|}
end_function

begin_comment
comment|/* Convert double to long double.  */
end_comment

begin_function
name|long
name|double
name|__gcc_dtoq
parameter_list|(
name|double
name|a
parameter_list|)
block|{
name|longDblUnion
name|x
decl_stmt|;
name|x
operator|.
name|dval
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
name|x
operator|.
name|dval
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
return|return
name|x
operator|.
name|ldval
return|;
block|}
end_function

begin_comment
comment|/* Convert long double to single.  */
end_comment

begin_decl_stmt
name|float
name|__gcc_qtos
argument_list|(
name|double
name|a
argument_list|,
name|double
name|aa
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
return|return
operator|(
name|float
operator|)
name|a
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Convert long double to double.  */
end_comment

begin_decl_stmt
name|double
name|__gcc_qtod
argument_list|(
name|double
name|a
argument_list|,
name|double
name|aa
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
return|return
name|a
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Convert long double to int.  */
end_comment

begin_function
name|int
name|__gcc_qtoi
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|)
block|{
name|double
name|z
init|=
name|a
operator|+
name|aa
decl_stmt|;
return|return
operator|(
name|int
operator|)
name|z
return|;
block|}
end_function

begin_comment
comment|/* Convert long double to unsigned int.  */
end_comment

begin_function
name|unsigned
name|int
name|__gcc_qtou
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|aa
parameter_list|)
block|{
name|double
name|z
init|=
name|a
operator|+
name|aa
decl_stmt|;
return|return
operator|(
name|unsigned
name|int
operator|)
name|z
return|;
block|}
end_function

begin_comment
comment|/* Convert int to long double.  */
end_comment

begin_function
name|long
name|double
name|__gcc_itoq
parameter_list|(
name|int
name|a
parameter_list|)
block|{
return|return
name|__gcc_dtoq
argument_list|(
operator|(
name|double
operator|)
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert unsigned int to long double.  */
end_comment

begin_function
name|long
name|double
name|__gcc_utoq
parameter_list|(
name|unsigned
name|int
name|a
parameter_list|)
block|{
return|return
name|__gcc_dtoq
argument_list|(
operator|(
name|double
operator|)
name|a
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"config/soft-fp/soft-fp.h"
end_include

begin_include
include|#
directive|include
file|"config/soft-fp/double.h"
end_include

begin_include
include|#
directive|include
file|"config/soft-fp/quad.h"
end_include

begin_comment
comment|/* Compute floating point multiply-subtract with higher (quad) precision.  */
end_comment

begin_function
specifier|static
name|double
name|fmsub
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|c
parameter_list|)
block|{
name|FP_DECL_EX
expr_stmt|;
name|FP_DECL_D
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|FP_DECL_D
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|FP_DECL_D
argument_list|(
name|C
argument_list|)
expr_stmt|;
name|FP_DECL_Q
argument_list|(
name|X
argument_list|)
expr_stmt|;
name|FP_DECL_Q
argument_list|(
name|Y
argument_list|)
expr_stmt|;
name|FP_DECL_Q
argument_list|(
name|Z
argument_list|)
expr_stmt|;
name|FP_DECL_Q
argument_list|(
name|U
argument_list|)
expr_stmt|;
name|FP_DECL_Q
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|FP_DECL_D
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|double
name|r
decl_stmt|;
name|long
name|double
name|u
decl_stmt|,
name|v
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|FP_INIT_ROUNDMODE
expr_stmt|;
name|FP_UNPACK_RAW_D
argument_list|(
name|A
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|FP_UNPACK_RAW_D
argument_list|(
name|B
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|FP_UNPACK_RAW_D
argument_list|(
name|C
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Extend double to quad.  */
if|#
directive|if
operator|(
literal|2
operator|*
name|_FP_W_TYPE_SIZE
operator|)
operator|<
name|_FP_FRACBITS_Q
name|FP_EXTEND
argument_list|(
name|Q
argument_list|,
name|D
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
name|X
argument_list|,
name|A
argument_list|)
expr_stmt|;
name|FP_EXTEND
argument_list|(
name|Q
argument_list|,
name|D
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
name|Y
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|FP_EXTEND
argument_list|(
name|Q
argument_list|,
name|D
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
name|Z
argument_list|,
name|C
argument_list|)
expr_stmt|;
else|#
directive|else
name|FP_EXTEND
argument_list|(
name|Q
argument_list|,
name|D
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|X
argument_list|,
name|A
argument_list|)
expr_stmt|;
name|FP_EXTEND
argument_list|(
name|Q
argument_list|,
name|D
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|Y
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|FP_EXTEND
argument_list|(
name|Q
argument_list|,
name|D
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|Z
argument_list|,
name|C
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FP_PACK_RAW_Q
argument_list|(
name|x
argument_list|,
name|X
argument_list|)
expr_stmt|;
name|FP_PACK_RAW_Q
argument_list|(
name|y
argument_list|,
name|Y
argument_list|)
expr_stmt|;
name|FP_PACK_RAW_Q
argument_list|(
name|z
argument_list|,
name|Z
argument_list|)
expr_stmt|;
name|FP_HANDLE_EXCEPTIONS
expr_stmt|;
comment|/* Multiply.  */
name|FP_INIT_ROUNDMODE
expr_stmt|;
name|FP_UNPACK_Q
argument_list|(
name|X
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|FP_UNPACK_Q
argument_list|(
name|Y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|FP_MUL_Q
argument_list|(
name|U
argument_list|,
name|X
argument_list|,
name|Y
argument_list|)
expr_stmt|;
name|FP_PACK_Q
argument_list|(
name|u
argument_list|,
name|U
argument_list|)
expr_stmt|;
name|FP_HANDLE_EXCEPTIONS
expr_stmt|;
comment|/* Subtract.  */
name|FP_INIT_ROUNDMODE
expr_stmt|;
name|FP_UNPACK_SEMIRAW_Q
argument_list|(
name|U
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|FP_UNPACK_SEMIRAW_Q
argument_list|(
name|Z
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|FP_SUB_Q
argument_list|(
name|V
argument_list|,
name|U
argument_list|,
name|Z
argument_list|)
expr_stmt|;
name|FP_PACK_SEMIRAW_Q
argument_list|(
name|v
argument_list|,
name|V
argument_list|)
expr_stmt|;
name|FP_HANDLE_EXCEPTIONS
expr_stmt|;
comment|/* Truncate quad to double.  */
name|FP_INIT_ROUNDMODE
expr_stmt|;
name|FP_UNPACK_SEMIRAW_Q
argument_list|(
name|V
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
literal|2
operator|*
name|_FP_W_TYPE_SIZE
operator|)
operator|<
name|_FP_FRACBITS_Q
name|FP_TRUNC
argument_list|(
name|D
argument_list|,
name|Q
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
name|R
argument_list|,
name|V
argument_list|)
expr_stmt|;
else|#
directive|else
name|FP_TRUNC
argument_list|(
name|D
argument_list|,
name|Q
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|R
argument_list|,
name|V
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FP_PACK_SEMIRAW_D
argument_list|(
name|r
argument_list|,
name|R
argument_list|)
expr_stmt|;
name|FP_HANDLE_EXCEPTIONS
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

