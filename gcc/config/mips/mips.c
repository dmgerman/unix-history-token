begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for MIPS code generation.    Copyright (C) 1989, 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by A. Lichnewsky, lich@inria.inria.fr.    Changes by Michael Meissner, meissner@osf.org.    64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and    Brendan Eich, brendan@microunity.com.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_comment
comment|/* True if X is an unspec wrapper around a SYMBOL_REF or LABEL_REF.  */
end_comment

begin_define
define|#
directive|define
name|UNSPEC_ADDRESS_P
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == UNSPEC					\&& XINT (X, 1)>= UNSPEC_ADDRESS_FIRST			\&& XINT (X, 1)< UNSPEC_ADDRESS_FIRST + NUM_SYMBOL_TYPES)
end_define

begin_comment
comment|/* Extract the symbol or label from UNSPEC wrapper X.  */
end_comment

begin_define
define|#
directive|define
name|UNSPEC_ADDRESS
parameter_list|(
name|X
parameter_list|)
define|\
value|XVECEXP (X, 0, 0)
end_define

begin_comment
comment|/* Extract the symbol type from UNSPEC wrapper X.  */
end_comment

begin_define
define|#
directive|define
name|UNSPEC_ADDRESS_TYPE
parameter_list|(
name|X
parameter_list|)
define|\
value|((enum mips_symbol_type) (XINT (X, 1) - UNSPEC_ADDRESS_FIRST))
end_define

begin_comment
comment|/* The maximum distance between the top of the stack frame and the    value $sp has when we save& restore registers.     Use a maximum gap of 0x100 in the mips16 case.  We can then use    unextended instructions to save and restore registers, and to    allocate and deallocate the top part of the frame.     The value in the !mips16 case must be a SMALL_OPERAND and must    preserve the maximum stack alignment.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_MAX_FIRST_STACK_STEP
value|(TARGET_MIPS16 ? 0x100 : 0x7ff0)
end_define

begin_comment
comment|/* True if INSN is a mips.md pattern or asm statement.  */
end_comment

begin_define
define|#
directive|define
name|USEFUL_INSN_P
parameter_list|(
name|INSN
parameter_list|)
define|\
value|(INSN_P (INSN)							\&& GET_CODE (PATTERN (INSN)) != USE					\&& GET_CODE (PATTERN (INSN)) != CLOBBER				\&& GET_CODE (PATTERN (INSN)) != ADDR_VEC				\&& GET_CODE (PATTERN (INSN)) != ADDR_DIFF_VEC)
end_define

begin_comment
comment|/* If INSN is a delayed branch sequence, return the first instruction    in the sequence, otherwise return INSN itself.  */
end_comment

begin_define
define|#
directive|define
name|SEQ_BEGIN
parameter_list|(
name|INSN
parameter_list|)
define|\
value|(INSN_P (INSN)&& GET_CODE (PATTERN (INSN)) == SEQUENCE		\    ? XVECEXP (PATTERN (INSN), 0, 0)					\    : (INSN))
end_define

begin_comment
comment|/* Likewise for the last instruction in a delayed branch sequence.  */
end_comment

begin_define
define|#
directive|define
name|SEQ_END
parameter_list|(
name|INSN
parameter_list|)
define|\
value|(INSN_P (INSN)&& GET_CODE (PATTERN (INSN)) == SEQUENCE		\    ? XVECEXP (PATTERN (INSN), 0, XVECLEN (PATTERN (INSN), 0) - 1)	\    : (INSN))
end_define

begin_comment
comment|/* Execute the following loop body with SUBINSN set to each instruction    between SEQ_BEGIN (INSN) and SEQ_END (INSN) inclusive.  */
end_comment

begin_define
define|#
directive|define
name|FOR_EACH_SUBINSN
parameter_list|(
name|SUBINSN
parameter_list|,
name|INSN
parameter_list|)
define|\
value|for ((SUBINSN) = SEQ_BEGIN (INSN);					\        (SUBINSN) != NEXT_INSN (SEQ_END (INSN));				\        (SUBINSN) = NEXT_INSN (SUBINSN))
end_define

begin_comment
comment|/* Classifies an address.     ADDRESS_REG        A natural register + offset address.  The register satisfies        mips_valid_base_register_p and the offset is a const_arith_operand.     ADDRESS_LO_SUM        A LO_SUM rtx.  The first operand is a valid base register and        the second operand is a symbolic address.     ADDRESS_CONST_INT        A signed 16-bit constant address.     ADDRESS_SYMBOLIC:        A constant symbolic address (equivalent to CONSTANT_SYMBOLIC).  */
end_comment

begin_enum
enum|enum
name|mips_address_type
block|{
name|ADDRESS_REG
block|,
name|ADDRESS_LO_SUM
block|,
name|ADDRESS_CONST_INT
block|,
name|ADDRESS_SYMBOLIC
block|}
enum|;
end_enum

begin_comment
comment|/* Classifies the prototype of a builtin function.  */
end_comment

begin_enum
enum|enum
name|mips_function_type
block|{
name|MIPS_V2SF_FTYPE_V2SF
block|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
block|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF_INT
block|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF
block|,
name|MIPS_V2SF_FTYPE_SF_SF
block|,
name|MIPS_INT_FTYPE_V2SF_V2SF
block|,
name|MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF
block|,
name|MIPS_INT_FTYPE_SF_SF
block|,
name|MIPS_INT_FTYPE_DF_DF
block|,
name|MIPS_SF_FTYPE_V2SF
block|,
name|MIPS_SF_FTYPE_SF
block|,
name|MIPS_SF_FTYPE_SF_SF
block|,
name|MIPS_DF_FTYPE_DF
block|,
name|MIPS_DF_FTYPE_DF_DF
block|,
comment|/* For MIPS DSP ASE  */
name|MIPS_DI_FTYPE_DI_SI
block|,
name|MIPS_DI_FTYPE_DI_SI_SI
block|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
block|,
name|MIPS_DI_FTYPE_DI_V4QI_V4QI
block|,
name|MIPS_SI_FTYPE_DI_SI
block|,
name|MIPS_SI_FTYPE_PTR_SI
block|,
name|MIPS_SI_FTYPE_SI
block|,
name|MIPS_SI_FTYPE_SI_SI
block|,
name|MIPS_SI_FTYPE_V2HI
block|,
name|MIPS_SI_FTYPE_V2HI_V2HI
block|,
name|MIPS_SI_FTYPE_V4QI
block|,
name|MIPS_SI_FTYPE_V4QI_V4QI
block|,
name|MIPS_SI_FTYPE_VOID
block|,
name|MIPS_V2HI_FTYPE_SI
block|,
name|MIPS_V2HI_FTYPE_SI_SI
block|,
name|MIPS_V2HI_FTYPE_V2HI
block|,
name|MIPS_V2HI_FTYPE_V2HI_SI
block|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
block|,
name|MIPS_V2HI_FTYPE_V4QI
block|,
name|MIPS_V2HI_FTYPE_V4QI_V2HI
block|,
name|MIPS_V4QI_FTYPE_SI
block|,
name|MIPS_V4QI_FTYPE_V2HI_V2HI
block|,
name|MIPS_V4QI_FTYPE_V4QI_SI
block|,
name|MIPS_V4QI_FTYPE_V4QI_V4QI
block|,
name|MIPS_VOID_FTYPE_SI_SI
block|,
name|MIPS_VOID_FTYPE_V2HI_V2HI
block|,
name|MIPS_VOID_FTYPE_V4QI_V4QI
block|,
comment|/* The last type.  */
name|MIPS_MAX_FTYPE_MAX
block|}
enum|;
end_enum

begin_comment
comment|/* Specifies how a builtin function should be converted into rtl.  */
end_comment

begin_enum
enum|enum
name|mips_builtin_type
block|{
comment|/* The builtin corresponds directly to an .md pattern.  The return      value is mapped to operand 0 and the arguments are mapped to      operands 1 and above.  */
name|MIPS_BUILTIN_DIRECT
block|,
comment|/* The builtin corresponds directly to an .md pattern.  There is no return      value and the arguments are mapped to operands 0 and above.  */
name|MIPS_BUILTIN_DIRECT_NO_TARGET
block|,
comment|/* The builtin corresponds to a comparison instruction followed by      a mips_cond_move_tf_ps pattern.  The first two arguments are the      values to compare and the second two arguments are the vector      operands for the movt.ps or movf.ps instruction (in assembly order).  */
name|MIPS_BUILTIN_MOVF
block|,
name|MIPS_BUILTIN_MOVT
block|,
comment|/* The builtin corresponds to a V2SF comparison instruction.  Operand 0      of this instruction is the result of the comparison, which has mode      CCV2 or CCV4.  The function arguments are mapped to operands 1 and      above.  The function's return value is an SImode boolean that is      true under the following conditions:       MIPS_BUILTIN_CMP_ANY: one of the registers is true      MIPS_BUILTIN_CMP_ALL: all of the registers are true      MIPS_BUILTIN_CMP_LOWER: the first register is true      MIPS_BUILTIN_CMP_UPPER: the second register is true.  */
name|MIPS_BUILTIN_CMP_ANY
block|,
name|MIPS_BUILTIN_CMP_ALL
block|,
name|MIPS_BUILTIN_CMP_UPPER
block|,
name|MIPS_BUILTIN_CMP_LOWER
block|,
comment|/* As above, but the instruction only sets a single $fcc register.  */
name|MIPS_BUILTIN_CMP_SINGLE
block|,
comment|/* For generating bposge32 branch instructions in MIPS32 DSP ASE.  */
name|MIPS_BUILTIN_BPOSGE32
block|}
enum|;
end_enum

begin_comment
comment|/* Invokes MACRO (COND) for each c.cond.fmt condition.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_FP_CONDITIONS
parameter_list|(
name|MACRO
parameter_list|)
define|\
value|MACRO (f),	\   MACRO (un),	\   MACRO (eq),	\   MACRO (ueq),	\   MACRO (olt),	\   MACRO (ult),	\   MACRO (ole),	\   MACRO (ule),	\   MACRO (sf),	\   MACRO (ngle),	\   MACRO (seq),	\   MACRO (ngl),	\   MACRO (lt),	\   MACRO (nge),	\   MACRO (le),	\   MACRO (ngt)
end_define

begin_comment
comment|/* Enumerates the codes above as MIPS_FP_COND_<X>.  */
end_comment

begin_define
define|#
directive|define
name|DECLARE_MIPS_COND
parameter_list|(
name|X
parameter_list|)
value|MIPS_FP_COND_ ## X
end_define

begin_enum
enum|enum
name|mips_fp_condition
block|{
name|MIPS_FP_CONDITIONS
argument_list|(
argument|DECLARE_MIPS_COND
argument_list|)
block|}
enum|;
end_enum

begin_comment
comment|/* Index X provides the string representation of MIPS_FP_COND_<X>.  */
end_comment

begin_define
define|#
directive|define
name|STRINGIFY
parameter_list|(
name|X
parameter_list|)
value|#X
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_fp_conditions
index|[]
init|=
block|{
name|MIPS_FP_CONDITIONS
argument_list|(
argument|STRINGIFY
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A function to save or store a register.  The first argument is the    register and the second is the stack slot.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|mips_save_restore_fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_typedef

begin_struct_decl
struct_decl|struct
name|mips16_constant
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|mips_arg_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|mips_address_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|mips_integer_op
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|mips_sim
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|enum
name|mips_symbol_type
name|mips_classify_symbol
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_split_const
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_offset_within_object_p
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_valid_base_register_p
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_symbolic_address_p
parameter_list|(
name|enum
name|mips_symbol_type
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_classify_address
parameter_list|(
name|struct
name|mips_address_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_cannot_force_const_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_use_blocks_for_constant_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_symbol_insns
parameter_list|(
name|enum
name|mips_symbol_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips16_unextended_reference_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_force_temporary
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_unspec_offset_high
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|mips_symbol_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_add_offset
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|mips_build_shift
parameter_list|(
name|struct
name|mips_integer_op
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|mips_build_lower
parameter_list|(
name|struct
name|mips_integer_op
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|mips_build_integer
parameter_list|(
name|struct
name|mips_integer_op
modifier|*
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_legitimize_const_move
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|m16_check_op
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_address_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_emit_compare
parameter_list|(
name|enum
name|rtx_code
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_load_call_address
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_block_move_straight
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_adjust_block_mem
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_block_move_loop
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_arg_info
parameter_list|(
specifier|const
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|struct
name|mips_arg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_get_unaligned_mem
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_set_architecture
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_set_tune
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_handle_option
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|mips_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_operand_reloc
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_IRIX
end_if

begin_function_decl
specifier|static
name|void
name|irix_output_external_libcall
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mips_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_file_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_rewrite_small_data_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_small_data_pattern_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_rewrite_small_data_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_function_has_gp_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|mips_global_pointer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_save_reg_p
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_save_restore_reg
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|mips_save_restore_fn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_for_each_saved_reg
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|mips_save_restore_fn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_output_cplocal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_emit_loadgp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_set_frame_expr
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_frame_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_save_reg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_restore_reg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|symbolic_expression_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|section
modifier|*
name|mips_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|section
modifier|*
name|mips_function_rodata_section
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_in_small_data_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_use_anchors_for_symbol_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_fpr_return_fields
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_return_in_msb
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_return_fpr_pair
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|mode1
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|machine_mode
name|mode2
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips16_gp_pseudo_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_fp_args
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_mips16_function_stub
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|dump_constants_1
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_constants
parameter_list|(
name|struct
name|mips16_constant
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips16_insn_length
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips16_rewrite_pool_refs
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips16_lay_out_constants
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_reset
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_init
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|,
name|state_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_next_cycle
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_wait_reg
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_sim_wait_regs_2
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_wait_regs_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_wait_regs
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_wait_units
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_wait_insn
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_record_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_issue_insn
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_issue_nop
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_sim_finish_insn
parameter_list|(
name|struct
name|mips_sim
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vr4130_avoid_branch_rt_conflict
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vr4130_align_insns
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_avoid_hazard
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_avoid_hazards
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_strict_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_parse_cpu
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_isa
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_return_in_memory
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_strict_argument_naming
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_macc_chains_record
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_macc_chains_reorder
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vr4130_true_reg_dependence_p_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vr4130_true_reg_dependence_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vr4130_swap_insns_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vr4130_reorder
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_promote_ready
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_sched_reorder
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_variable_issue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_init_libfuncs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mips_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|mips_gimplify_va_arg_expr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_callee_copies
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_valid_pointer_mode
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mips_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_prepare_builtin_arg
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_prepare_builtin_target
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_expand_builtin_direct
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_expand_builtin_movtf
parameter_list|(
name|enum
name|mips_builtin_type
parameter_list|,
name|enum
name|insn_code
parameter_list|,
name|enum
name|mips_fp_condition
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_expand_builtin_compare
parameter_list|(
name|enum
name|mips_builtin_type
parameter_list|,
name|enum
name|insn_code
parameter_list|,
name|enum
name|mips_fp_condition
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mips_expand_builtin_bposge
parameter_list|(
name|enum
name|mips_builtin_type
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_encode_section_info
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_extra_live_on_entry
parameter_list|(
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_mode_rep_extended
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Structure to be filled in by compute_frame_size with register    save masks, and offsets for the current function.  */
end_comment

begin_decl_stmt
name|struct
name|mips_frame_info
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up */
name|HOST_WIDE_INT
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up */
name|HOST_WIDE_INT
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up */
name|HOST_WIDE_INT
name|cprestore_size
decl_stmt|;
comment|/* # bytes that the .cprestore slot takes up */
name|HOST_WIDE_INT
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs */
name|HOST_WIDE_INT
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs */
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/* mask of saved gp registers */
name|unsigned
name|int
name|fmask
decl_stmt|;
comment|/* mask of saved fp registers */
name|HOST_WIDE_INT
name|gp_save_offset
decl_stmt|;
comment|/* offset from vfp to store gp registers */
name|HOST_WIDE_INT
name|fp_save_offset
decl_stmt|;
comment|/* offset from vfp to store fp registers */
name|HOST_WIDE_INT
name|gp_sp_offset
decl_stmt|;
comment|/* offset from new sp to store gp registers */
name|HOST_WIDE_INT
name|fp_sp_offset
decl_stmt|;
comment|/* offset from new sp to store fp registers */
name|bool
name|initialized
decl_stmt|;
comment|/* true if frame size already calculated */
name|int
name|num_gp
decl_stmt|;
comment|/* number of gp registers saved */
name|int
name|num_fp
decl_stmt|;
comment|/* number of fp registers saved */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|machine_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Pseudo-reg holding the value of $28 in a mips16 function which      refers to GP relative global variables.  */
name|rtx
name|mips16_gp_pseudo_rtx
decl_stmt|;
comment|/* The number of extra stack bytes taken up by register varargs.      This area is allocated by the callee at the very top of the frame.  */
name|int
name|varargs_size
decl_stmt|;
comment|/* Current frame information, calculated by compute_frame_size.  */
name|struct
name|mips_frame_info
name|frame
decl_stmt|;
comment|/* The register to use as the global pointer within this function.  */
name|unsigned
name|int
name|global_pointer
decl_stmt|;
comment|/* True if mips_adjust_insn_length should ignore an instruction's      hazard attribute.  */
name|bool
name|ignore_hazard_length_p
decl_stmt|;
comment|/* True if the whole function is suitable for .set noreorder and      .set nomacro.  */
name|bool
name|all_noreorder_p
decl_stmt|;
comment|/* True if the function is known to have an instruction that needs $gp.  */
name|bool
name|has_gp_insn_p
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Information about a single argument.  */
end_comment

begin_struct
struct|struct
name|mips_arg_info
block|{
comment|/* True if the argument is passed in a floating-point register, or      would have been if we hadn't run out of registers.  */
name|bool
name|fpr_p
decl_stmt|;
comment|/* The number of words passed in registers, rounded up.  */
name|unsigned
name|int
name|reg_words
decl_stmt|;
comment|/* For EABI, the offset of the first register from GP_ARG_FIRST or      FP_ARG_FIRST.  For other ABIs, the offset of the first register from      the start of the ABI's argument structure (see the CUMULATIVE_ARGS      comment for details).       The value is MAX_ARGS_IN_REGISTERS if the argument is passed entirely      on the stack.  */
name|unsigned
name|int
name|reg_offset
decl_stmt|;
comment|/* The number of words that must be passed on the stack, rounded up.  */
name|unsigned
name|int
name|stack_words
decl_stmt|;
comment|/* The offset from the start of the stack overflow area of the argument's      first stack word.  Only meaningful when STACK_WORDS is nonzero.  */
name|unsigned
name|int
name|stack_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information about an address described by mips_address_type.     ADDRESS_CONST_INT        No fields are used.     ADDRESS_REG        REG is the base register and OFFSET is the constant offset.     ADDRESS_LO_SUM        REG is the register that contains the high part of the address,        OFFSET is the symbolic address being referenced and SYMBOL_TYPE        is the type of OFFSET's symbol.     ADDRESS_SYMBOLIC        SYMBOL_TYPE is the type of symbol being referenced.  */
end_comment

begin_struct
struct|struct
name|mips_address_info
block|{
name|enum
name|mips_address_type
name|type
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|enum
name|mips_symbol_type
name|symbol_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* One stage in a constant building sequence.  These sequences have    the form:  	A = VALUE[0] 	A = A CODE[1] VALUE[1] 	A = A CODE[2] VALUE[2] 	...     where A is an accumulator, each CODE[i] is a binary rtl operation    and each VALUE[i] is a constant integer.  */
end_comment

begin_struct
struct|struct
name|mips_integer_op
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The largest number of operations needed to load an integer constant.    The worst accepted case for 64-bit constants is LUI,ORI,SLL,ORI,SLL,ORI.    When the lowest bit is clear, we can try, but reject a sequence with    an extra SLL at the end.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_MAX_INTEGER_OPS
value|7
end_define

begin_comment
comment|/* Global variables for machine-dependent things.  */
end_comment

begin_comment
comment|/* Threshold for data being put into the small data/bss area, instead    of the normal data area.  */
end_comment

begin_decl_stmt
name|int
name|mips_section_threshold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of .file directives, so that .loc is up to date.  */
end_comment

begin_decl_stmt
name|int
name|num_source_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count the number of sdb related labels are generated (to find block    start and end boundaries).  */
end_comment

begin_decl_stmt
name|int
name|sdb_label_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next label # for each statement for Silicon Graphics IRIS systems.  */
end_comment

begin_decl_stmt
name|int
name|sym_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of all externals that are to be emitted when optimizing    for the global pointer if they haven't been declared by the end of    the program with an appropriate .comm or initialization.  */
end_comment

begin_decl_stmt
name|struct
name|extern_list
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|extern_list
modifier|*
name|next
decl_stmt|;
comment|/* next external */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the external */
name|int
name|size
decl_stmt|;
comment|/* size in bytes */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|extern_list
operator|*
name|extern_head
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Name of the file containing the current function.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|current_function_file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of nested .set noreorder, noat, nomacro, and volatile requests.  */
end_comment

begin_decl_stmt
name|int
name|set_noreorder
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_noat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_nomacro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next branch instruction is a branch likely, not branch normal.  */
end_comment

begin_decl_stmt
name|int
name|mips_branch_likely
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The operands passed to the last cmpMM expander.  */
end_comment

begin_decl_stmt
name|rtx
name|cmp_operands
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target cpu for code generation.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|mips_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_arch_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target cpu for optimization and scheduling.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|mips_tune
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_tune_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|int
name|mips_isa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which ABI to use.  */
end_comment

begin_decl_stmt
name|int
name|mips_abi
init|=
name|MIPS_ABI_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cost information to use.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|mips_rtx_cost_data
modifier|*
name|mips_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are generating mips16 hard float code.  In mips16 mode    we always set TARGET_SOFT_FLOAT; this variable is nonzero if    -msoft-float was not specified by the user, which means that we    should arrange to call mips32 hard floating point code.  */
end_comment

begin_decl_stmt
name|int
name|mips16_hard_float
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The architecture selected by -mipsN.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_isa_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If TRUE, we split addresses into their high and low parts in the RTL.  */
end_comment

begin_decl_stmt
name|int
name|mips_split_addresses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode used for saving/restoring general purpose registers.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|gpr_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array giving truth value on whether or not a given hard register    can support a given mode.  */
end_comment

begin_decl_stmt
name|char
name|mips_hard_regno_mode_ok
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all MIPS punctuation characters used by print_operand.  */
end_comment

begin_decl_stmt
name|char
name|mips_print_operand_punct
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map GCC register number to debugger register number.  */
end_comment

begin_decl_stmt
name|int
name|mips_dbx_regno
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A copy of the original flag_delayed_branch: see override_options.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_flag_delayed_branch
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|mips_output_filename_first_time
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* mips_split_p[X] is true if symbols of type X can be split by    mips_split_symbol().  */
end_comment

begin_decl_stmt
name|bool
name|mips_split_p
index|[
name|NUM_SYMBOL_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mips_lo_relocs[X] is the relocation to use when a symbol of type X    appears in a LO_SUM.  It can be null if such LO_SUMs aren't valid or    if they are matched by a special .md file pattern.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_lo_relocs
index|[
name|NUM_SYMBOL_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for HIGHs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mips_hi_relocs
index|[
name|NUM_SYMBOL_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map hard register number to register class */
end_comment

begin_decl_stmt
specifier|const
name|enum
name|reg_class
name|mips_regno_to_class
index|[]
init|=
block|{
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|M16_NA_REGS
block|,
name|V1_REG
block|,
name|M16_REGS
block|,
name|M16_REGS
block|,
name|M16_REGS
block|,
name|M16_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|M16_NA_REGS
block|,
name|M16_NA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|T_REG
block|,
name|PIC_FN_ADDR_REG
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|LEA_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|FP_REGS
block|,
name|HI_REG
block|,
name|LO_REG
block|,
name|NO_REGS
block|,
name|ST_REGS
block|,
name|ST_REGS
block|,
name|ST_REGS
block|,
name|ST_REGS
block|,
name|ST_REGS
block|,
name|ST_REGS
block|,
name|ST_REGS
block|,
name|ST_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|ALL_REGS
block|,
name|ALL_REGS
block|,
name|NO_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP0_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP2_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|COP3_REGS
block|,
name|DSP_ACC_REGS
block|,
name|DSP_ACC_REGS
block|,
name|DSP_ACC_REGS
block|,
name|DSP_ACC_REGS
block|,
name|DSP_ACC_REGS
block|,
name|DSP_ACC_REGS
block|,
name|ALL_REGS
block|,
name|ALL_REGS
block|,
name|ALL_REGS
block|,
name|ALL_REGS
block|,
name|ALL_REGS
block|,
name|ALL_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of machine dependent attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|mips_attribute_table
index|[]
init|=
block|{
block|{
literal|"long_call"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* A table describing all the processors gcc knows about.  Names are    matched in the order listed.  The first mention of an ISA level is    taken as the canonical name for that ISA.     To ease comparison, please keep this table in the same order as    gas's mips_cpu_info_table[].  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|mips_cpu_info
name|mips_cpu_info_table
index|[]
init|=
block|{
comment|/* Entries for generic ISAs */
block|{
literal|"mips1"
block|,
name|PROCESSOR_R3000
block|,
literal|1
block|}
block|,
block|{
literal|"mips2"
block|,
name|PROCESSOR_R6000
block|,
literal|2
block|}
block|,
block|{
literal|"mips3"
block|,
name|PROCESSOR_R4000
block|,
literal|3
block|}
block|,
block|{
literal|"mips4"
block|,
name|PROCESSOR_R8000
block|,
literal|4
block|}
block|,
block|{
literal|"mips32"
block|,
name|PROCESSOR_4KC
block|,
literal|32
block|}
block|,
block|{
literal|"mips32r2"
block|,
name|PROCESSOR_M4K
block|,
literal|33
block|}
block|,
block|{
literal|"mips64"
block|,
name|PROCESSOR_5KC
block|,
literal|64
block|}
block|,
comment|/* MIPS I */
block|{
literal|"r3000"
block|,
name|PROCESSOR_R3000
block|,
literal|1
block|}
block|,
block|{
literal|"r2000"
block|,
name|PROCESSOR_R3000
block|,
literal|1
block|}
block|,
comment|/* = r3000 */
block|{
literal|"r3900"
block|,
name|PROCESSOR_R3900
block|,
literal|1
block|}
block|,
comment|/* MIPS II */
block|{
literal|"r6000"
block|,
name|PROCESSOR_R6000
block|,
literal|2
block|}
block|,
comment|/* MIPS III */
block|{
literal|"r4000"
block|,
name|PROCESSOR_R4000
block|,
literal|3
block|}
block|,
block|{
literal|"vr4100"
block|,
name|PROCESSOR_R4100
block|,
literal|3
block|}
block|,
block|{
literal|"vr4111"
block|,
name|PROCESSOR_R4111
block|,
literal|3
block|}
block|,
block|{
literal|"vr4120"
block|,
name|PROCESSOR_R4120
block|,
literal|3
block|}
block|,
block|{
literal|"vr4130"
block|,
name|PROCESSOR_R4130
block|,
literal|3
block|}
block|,
block|{
literal|"vr4300"
block|,
name|PROCESSOR_R4300
block|,
literal|3
block|}
block|,
block|{
literal|"r4400"
block|,
name|PROCESSOR_R4000
block|,
literal|3
block|}
block|,
comment|/* = r4000 */
block|{
literal|"r4600"
block|,
name|PROCESSOR_R4600
block|,
literal|3
block|}
block|,
block|{
literal|"orion"
block|,
name|PROCESSOR_R4600
block|,
literal|3
block|}
block|,
comment|/* = r4600 */
block|{
literal|"r4650"
block|,
name|PROCESSOR_R4650
block|,
literal|3
block|}
block|,
comment|/* MIPS IV */
block|{
literal|"r8000"
block|,
name|PROCESSOR_R8000
block|,
literal|4
block|}
block|,
block|{
literal|"vr5000"
block|,
name|PROCESSOR_R5000
block|,
literal|4
block|}
block|,
block|{
literal|"vr5400"
block|,
name|PROCESSOR_R5400
block|,
literal|4
block|}
block|,
block|{
literal|"vr5500"
block|,
name|PROCESSOR_R5500
block|,
literal|4
block|}
block|,
block|{
literal|"rm7000"
block|,
name|PROCESSOR_R7000
block|,
literal|4
block|}
block|,
block|{
literal|"rm9000"
block|,
name|PROCESSOR_R9000
block|,
literal|4
block|}
block|,
comment|/* MIPS32 */
block|{
literal|"4kc"
block|,
name|PROCESSOR_4KC
block|,
literal|32
block|}
block|,
block|{
literal|"4km"
block|,
name|PROCESSOR_4KC
block|,
literal|32
block|}
block|,
comment|/* = 4kc */
block|{
literal|"4kp"
block|,
name|PROCESSOR_4KP
block|,
literal|32
block|}
block|,
comment|/* MIPS32 Release 2 */
block|{
literal|"m4k"
block|,
name|PROCESSOR_M4K
block|,
literal|33
block|}
block|,
block|{
literal|"24k"
block|,
name|PROCESSOR_24K
block|,
literal|33
block|}
block|,
block|{
literal|"24kc"
block|,
name|PROCESSOR_24K
block|,
literal|33
block|}
block|,
comment|/* 24K  no FPU */
block|{
literal|"24kf"
block|,
name|PROCESSOR_24K
block|,
literal|33
block|}
block|,
comment|/* 24K 1:2 FPU */
block|{
literal|"24kx"
block|,
name|PROCESSOR_24KX
block|,
literal|33
block|}
block|,
comment|/* 24K 1:1 FPU */
comment|/* MIPS64 */
block|{
literal|"5kc"
block|,
name|PROCESSOR_5KC
block|,
literal|64
block|}
block|,
block|{
literal|"5kf"
block|,
name|PROCESSOR_5KF
block|,
literal|64
block|}
block|,
block|{
literal|"20kc"
block|,
name|PROCESSOR_20KC
block|,
literal|64
block|}
block|,
block|{
literal|"sb1"
block|,
name|PROCESSOR_SB1
block|,
literal|64
block|}
block|,
block|{
literal|"sb1a"
block|,
name|PROCESSOR_SB1A
block|,
literal|64
block|}
block|,
block|{
literal|"sr71000"
block|,
name|PROCESSOR_SR71000
block|,
literal|64
block|}
block|,
comment|/* End marker */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default costs. If these are used for a processor we should look    up the actual costs.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_COSTS
value|COSTS_N_INSNS (6),
comment|/* fp_add */
value|\                       COSTS_N_INSNS (7),
comment|/* fp_mult_sf */
value|\                       COSTS_N_INSNS (8),
comment|/* fp_mult_df */
value|\                       COSTS_N_INSNS (23),
comment|/* fp_div_sf */
value|\                       COSTS_N_INSNS (36),
comment|/* fp_div_df */
value|\                       COSTS_N_INSNS (10),
comment|/* int_mult_si */
value|\                       COSTS_N_INSNS (10),
comment|/* int_mult_di */
value|\                       COSTS_N_INSNS (69),
comment|/* int_div_si */
value|\                       COSTS_N_INSNS (69),
comment|/* int_div_di */
value|\                                        2,
comment|/* branch_cost */
value|\                                        4
end_define

begin_comment
comment|/* memory_latency */
end_comment

begin_comment
comment|/* Need to replace these with the costs of calling the appropriate    libgcc routine.  */
end_comment

begin_define
define|#
directive|define
name|SOFT_FP_COSTS
value|COSTS_N_INSNS (256),
comment|/* fp_add */
value|\                       COSTS_N_INSNS (256),
comment|/* fp_mult_sf */
value|\                       COSTS_N_INSNS (256),
comment|/* fp_mult_df */
value|\                       COSTS_N_INSNS (256),
comment|/* fp_div_sf */
value|\                       COSTS_N_INSNS (256)
end_define

begin_comment
comment|/* fp_div_df */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_rtx_cost_data
specifier|const
name|mips_rtx_cost_data
index|[
name|PROCESSOR_MAX
index|]
init|=
block|{
block|{
comment|/* R3000 */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* 4KC */
name|SOFT_FP_COSTS
block|,
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* 4KP */
name|SOFT_FP_COSTS
block|,
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|37
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* 5KC */
name|SOFT_FP_COSTS
block|,
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|68
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* 5KF */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|68
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* 20KC */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* 24k */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|34
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|64
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|41
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|41
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* 24kx */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|41
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|41
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* M4k */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R3900 */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R6000 */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|16
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|38
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|38
argument_list|)
block|,
comment|/* int_div_di */
literal|2
block|,
comment|/* branch_cost */
literal|6
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R4000 */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_di */
literal|2
block|,
comment|/* branch_cost */
literal|6
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R4100 */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R4111 */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R4120 */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R4130 */
comment|/* The only costs that appear to be updated here are 	 integer multiplication.  */
name|SOFT_FP_COSTS
block|,
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R4300 */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R4600 */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R4650 */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R5000 */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R5400 */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|30
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|59
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|42
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R5500 */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|30
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|59
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|9
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|42
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R7000 */
comment|/* The only costs that are changed here are 	 integer multiplication.  */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|9
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* R8000 */
name|DEFAULT_COSTS
block|}
block|,
block|{
comment|/* R9000 */
comment|/* The only costs that are changed here are 	 integer multiplication.  */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|69
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* SB1 */
comment|/* These costs are the same as the SB-1A below.  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|24
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|68
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* SB1-A */
comment|/* These costs are the same as the SB-1 above.  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_add */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_sf */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* fp_mult_df */
name|COSTS_N_INSNS
argument_list|(
literal|24
argument_list|)
block|,
comment|/* fp_div_sf */
name|COSTS_N_INSNS
argument_list|(
literal|32
argument_list|)
block|,
comment|/* fp_div_df */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* int_mult_si */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* int_mult_di */
name|COSTS_N_INSNS
argument_list|(
literal|36
argument_list|)
block|,
comment|/* int_div_si */
name|COSTS_N_INSNS
argument_list|(
literal|68
argument_list|)
block|,
comment|/* int_div_di */
literal|1
block|,
comment|/* branch_cost */
literal|4
comment|/* memory_latency */
block|}
block|,
block|{
comment|/* SR71000 */
name|DEFAULT_COSTS
block|}
block|,   }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Nonzero if -march should decide the default value of MASK_SOFT_FLOAT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_MARCH_CONTROLS_SOFT_FLOAT
end_ifndef

begin_define
define|#
directive|define
name|MIPS_MARCH_CONTROLS_SOFT_FLOAT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\t.half\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\t.word\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\t.dword\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|mips_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|mips_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_SELECT_RTX_SECTION
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_SELECT_RTX_SECTION
value|mips_select_rtx_section
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_RODATA_SECTION
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_RODATA_SECTION
value|mips_function_rodata_section
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER
value|mips_sched_reorder
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|mips_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|mips_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|mips_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
define|\
value|mips_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_TARGET_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_TARGET_FLAGS
define|\
value|(TARGET_DEFAULT				\    | TARGET_CPU_DEFAULT				\    | TARGET_ENDIAN_DEFAULT			\    | TARGET_FP_EXCEPTIONS_DEFAULT		\    | MASK_CHECK_ZERO_DIV			\    | MASK_FUSED_MADD)
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HANDLE_OPTION
end_undef

begin_define
define|#
directive|define
name|TARGET_HANDLE_OPTION
value|mips_handle_option
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|mips_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VALID_POINTER_MODE
end_undef

begin_define
define|#
directive|define
name|TARGET_VALID_POINTER_MODE
value|mips_valid_pointer_mode
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|mips_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|mips_address_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_IN_SMALL_DATA_P
end_undef

begin_define
define|#
directive|define
name|TARGET_IN_SMALL_DATA_P
value|mips_in_small_data_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|mips_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_END
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|mips_file_start
end_define

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_END
value|mips_file_end
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START_FILE_DIRECTIVE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START_FILE_DIRECTIVE
value|true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_LIBFUNCS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_LIBFUNCS
value|mips_init_libfuncs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|mips_build_builtin_va_list
end_define

begin_undef
undef|#
directive|undef
name|TARGET_GIMPLIFY_VA_ARG_EXPR
end_undef

begin_define
define|#
directive|define
name|TARGET_GIMPLIFY_VA_ARG_EXPR
value|mips_gimplify_va_arg_expr
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_PROTOTYPES
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_PROTOTYPES
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|mips_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MSB
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MSB
value|mips_return_in_msb
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|mips_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SETUP_INCOMING_VARARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SETUP_INCOMING_VARARGS
value|mips_setup_incoming_varargs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRICT_ARGUMENT_NAMING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRICT_ARGUMENT_NAMING
value|mips_strict_argument_naming
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MUST_PASS_IN_STACK
end_undef

begin_define
define|#
directive|define
name|TARGET_MUST_PASS_IN_STACK
value|must_pass_in_stack_var_size
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PASS_BY_REFERENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_PASS_BY_REFERENCE
value|mips_pass_by_reference
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CALLEE_COPIES
end_undef

begin_define
define|#
directive|define
name|TARGET_CALLEE_COPIES
value|mips_callee_copies
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ARG_PARTIAL_BYTES
end_undef

begin_define
define|#
directive|define
name|TARGET_ARG_PARTIAL_BYTES
value|mips_arg_partial_bytes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MODE_REP_EXTENDED
end_undef

begin_define
define|#
directive|define
name|TARGET_MODE_REP_EXTENDED
value|mips_mode_rep_extended
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_MODE_SUPPORTED_P
value|mips_vector_mode_supported_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|mips_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|mips_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|HAVE_AS_TLS
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|mips_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|mips_encode_section_info
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|mips_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXTRA_LIVE_ON_ENTRY
end_undef

begin_define
define|#
directive|define
name|TARGET_EXTRA_LIVE_ON_ENTRY
value|mips_extra_live_on_entry
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MIN_ANCHOR_OFFSET
end_undef

begin_define
define|#
directive|define
name|TARGET_MIN_ANCHOR_OFFSET
value|-32768
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MAX_ANCHOR_OFFSET
end_undef

begin_define
define|#
directive|define
name|TARGET_MAX_ANCHOR_OFFSET
value|32767
end_define

begin_undef
undef|#
directive|undef
name|TARGET_USE_BLOCKS_FOR_CONSTANT_P
end_undef

begin_define
define|#
directive|define
name|TARGET_USE_BLOCKS_FOR_CONSTANT_P
value|mips_use_blocks_for_constant_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_USE_ANCHORS_FOR_SYMBOL_P
end_undef

begin_define
define|#
directive|define
name|TARGET_USE_ANCHORS_FOR_SYMBOL_P
value|mips_use_anchors_for_symbol_p
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */
end_comment

begin_function
specifier|static
name|enum
name|mips_symbol_type
name|mips_classify_symbol
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
return|return
name|SYMBOL_CONSTANT_POOL
return|;
if|if
condition|(
name|TARGET_ABICALLS
operator|&&
operator|!
name|TARGET_ABSOLUTE_ABICALLS
condition|)
return|return
name|SYMBOL_GOT_LOCAL
return|;
return|return
name|SYMBOL_GENERAL
return|;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|SYMBOL_TLS
return|;
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
return|return
name|SYMBOL_CONSTANT_POOL
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|mips_section_threshold
condition|)
return|return
name|SYMBOL_SMALL_DATA
return|;
block|}
comment|/* Do not use small-data accesses for weak symbols; they may end up      being zero.  */
if|if
condition|(
name|SYMBOL_REF_SMALL_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|SYMBOL_REF_WEAK
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|SYMBOL_SMALL_DATA
return|;
if|if
condition|(
name|TARGET_ABICALLS
condition|)
block|{
if|if
condition|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|SYMBOL_GOT_GLOBAL
return|;
block|}
else|else
block|{
comment|/* Don't use GOT accesses for locally-binding symbols if 	     TARGET_ABSOLUTE_ABICALLS.  Otherwise, there are three 	     cases to consider:  		- o32 PIC (either with or without explicit relocs) 		- n32/n64 PIC without explicit relocs 		- n32/n64 PIC with explicit relocs  	     In the first case, both local and global accesses will use an 	     R_MIPS_GOT16 relocation.  We must correctly predict which of 	     the two semantics (local or global) the assembler and linker 	     will apply.  The choice doesn't depend on the symbol's 	     visibility, so we deliberately ignore decl_visibility and 	     binds_local_p here.  	     In the second case, the assembler will not use R_MIPS_GOT16 	     relocations, but it chooses between local and global accesses 	     in the same way as for o32 PIC.  	     In the third case we have more freedom since both forms of 	     access will work for any kind of symbol.  However, there seems 	     little point in doing things differently.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|TARGET_ABSOLUTE_ABICALLS
operator|&&
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|SYMBOL_GOT_GLOBAL
return|;
block|}
if|if
condition|(
operator|!
name|TARGET_ABSOLUTE_ABICALLS
condition|)
return|return
name|SYMBOL_GOT_LOCAL
return|;
block|}
return|return
name|SYMBOL_GENERAL
return|;
block|}
end_function

begin_comment
comment|/* Split X into a base and a constant offset, storing them in *BASE    and *OFFSET respectively.  */
end_comment

begin_function
specifier|static
name|void
name|mips_split_const
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
modifier|*
name|base
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|)
block|{
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|base
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points    to the same object as SYMBOL, or to the same object_block.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_offset_within_object_p
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|symbol
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|false
return|;
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|symbol
argument_list|)
operator|&&
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
operator|!=
literal|0
operator|&&
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|symbol
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|SYMBOL_REF_HAS_BLOCK_INFO_P
argument_list|(
name|symbol
argument_list|)
operator|&&
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
operator|&&
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|offset
operator|+
name|SYMBOL_REF_BLOCK_OFFSET
argument_list|(
name|symbol
argument_list|)
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|SYMBOL_REF_BLOCK
argument_list|(
name|symbol
argument_list|)
operator|->
name|size
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is a symbolic constant that can be calculated in    the same way as a bare symbol.  If it is, store the type of the    symbol in *SYMBOL_TYPE.  */
end_comment

begin_function
name|bool
name|mips_symbolic_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|mips_symbol_type
modifier|*
name|symbol_type
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|mips_split_const
argument_list|(
name|x
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNSPEC_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
operator|*
name|symbol_type
operator|=
name|UNSPEC_ADDRESS_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
operator|*
name|symbol_type
operator|=
name|mips_classify_symbol
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|symbol_type
operator|==
name|SYMBOL_TLS
condition|)
return|return
name|false
return|;
block|}
else|else
return|return
name|false
return|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Check whether a nonzero offset is valid for the underlying      relocations.  */
switch|switch
condition|(
operator|*
name|symbol_type
condition|)
block|{
case|case
name|SYMBOL_GENERAL
case|:
case|case
name|SYMBOL_64_HIGH
case|:
case|case
name|SYMBOL_64_MID
case|:
case|case
name|SYMBOL_64_LOW
case|:
comment|/* If the target has 64-bit pointers and the object file only 	 supports 32-bit symbols, the values of those symbols will be 	 sign-extended.  In this case we can't allow an arbitrary offset 	 in case the 32-bit value X + OFFSET has a different sign from X.  */
if|if
condition|(
name|Pmode
operator|==
name|DImode
operator|&&
operator|!
name|ABI_HAS_64BIT_SYMBOLS
condition|)
return|return
name|mips_offset_within_object_p
argument_list|(
name|x
argument_list|,
name|offset
argument_list|)
return|;
comment|/* In other cases the relocations can handle any offset.  */
return|return
name|true
return|;
case|case
name|SYMBOL_CONSTANT_POOL
case|:
comment|/* Allow constant pool references to be converted to LABEL+CONSTANT. 	 In this case, we no longer have access to the underlying constant, 	 but the original symbol-based access was known to be valid.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|true
return|;
comment|/* Fall through.  */
case|case
name|SYMBOL_SMALL_DATA
case|:
comment|/* Make sure that the offset refers to something within the 	 underlying object.  This should guarantee that the final 	 PC- or GP-relative offset is within the 16-bit limit.  */
return|return
name|mips_offset_within_object_p
argument_list|(
name|x
argument_list|,
name|offset
argument_list|)
return|;
case|case
name|SYMBOL_GOT_LOCAL
case|:
case|case
name|SYMBOL_GOTOFF_PAGE
case|:
comment|/* The linker should provide enough local GOT entries for a 	 16-bit offset.  Larger offsets may lead to GOT overflow.  */
return|return
name|SMALL_OPERAND
argument_list|(
name|offset
argument_list|)
return|;
case|case
name|SYMBOL_GOT_GLOBAL
case|:
case|case
name|SYMBOL_GOTOFF_GLOBAL
case|:
case|case
name|SYMBOL_GOTOFF_CALL
case|:
case|case
name|SYMBOL_GOTOFF_LOADGP
case|:
case|case
name|SYMBOL_TLSGD
case|:
case|case
name|SYMBOL_TLSLDM
case|:
case|case
name|SYMBOL_DTPREL
case|:
case|case
name|SYMBOL_TPREL
case|:
case|case
name|SYMBOL_GOTTPREL
case|:
case|case
name|SYMBOL_TLS
case|:
return|return
name|false
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is used to implement REG_MODE_OK_FOR_BASE_P.  */
end_comment

begin_function
name|int
name|mips_regno_mode_ok_for_base_p
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
operator|!
name|strict
condition|)
return|return
name|true
return|;
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
block|}
comment|/* These fake registers will be eliminated to either the stack or      hard frame pointer, both of which are usually valid base registers.      Reload deals with the cases where the eliminated form isn't valid.  */
if|if
condition|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
condition|)
return|return
name|true
return|;
comment|/* In mips16 mode, the stack pointer can only address word and doubleword      values, nothing smaller.  There are two problems here:         (a) Instantiating virtual registers can introduce new uses of the 	   stack pointer.  If these virtual registers are valid addresses, 	   the stack pointer should be too.         (b) Most uses of the stack pointer are not made explicit until 	   FRAME_POINTER_REGNUM and ARG_POINTER_REGNUM have been eliminated. 	   We don't know until that stage whether we'll be eliminating to the 	   stack pointer (which needs the restriction) or the hard frame 	   pointer (which doesn't).       All in all, it seems more consistent to only enforce this restriction      during and after reload.  */
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
operator|!
name|strict
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|4
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
return|;
return|return
name|TARGET_MIPS16
condition|?
name|M16_REG_P
argument_list|(
name|regno
argument_list|)
else|:
name|GP_REG_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is a valid base register for the given mode.    Allow only hard registers if STRICT.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_valid_base_register_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strict
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
name|mips_regno_mode_ok_for_base_p
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|strict
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if symbols of type SYMBOL_TYPE can directly address a value    with mode MODE.  This is used for both symbolic and LO_SUM addresses.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_symbolic_address_p
parameter_list|(
name|enum
name|mips_symbol_type
name|symbol_type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|symbol_type
condition|)
block|{
case|case
name|SYMBOL_GENERAL
case|:
return|return
operator|!
name|TARGET_MIPS16
return|;
case|case
name|SYMBOL_SMALL_DATA
case|:
return|return
name|true
return|;
case|case
name|SYMBOL_CONSTANT_POOL
case|:
comment|/* PC-relative addressing is only available for lw and ld.  */
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|4
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
return|;
case|case
name|SYMBOL_GOT_LOCAL
case|:
return|return
name|true
return|;
case|case
name|SYMBOL_GOT_GLOBAL
case|:
comment|/* The address will have to be loaded from the GOT first.  */
return|return
name|false
return|;
case|case
name|SYMBOL_GOTOFF_PAGE
case|:
case|case
name|SYMBOL_GOTOFF_GLOBAL
case|:
case|case
name|SYMBOL_GOTOFF_CALL
case|:
case|case
name|SYMBOL_GOTOFF_LOADGP
case|:
case|case
name|SYMBOL_TLS
case|:
case|case
name|SYMBOL_TLSGD
case|:
case|case
name|SYMBOL_TLSLDM
case|:
case|case
name|SYMBOL_DTPREL
case|:
case|case
name|SYMBOL_GOTTPREL
case|:
case|case
name|SYMBOL_TPREL
case|:
case|case
name|SYMBOL_64_HIGH
case|:
case|case
name|SYMBOL_64_MID
case|:
case|case
name|SYMBOL_64_LOW
case|:
return|return
name|true
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if X is a valid address for machine mode MODE.  If it is,    fill in INFO appropriately.  STRICT is true if we should only accept    hard base registers.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_classify_address
parameter_list|(
name|struct
name|mips_address_info
modifier|*
name|info
parameter_list|,
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
name|info
operator|->
name|type
operator|=
name|ADDRESS_REG
expr_stmt|;
name|info
operator|->
name|reg
operator|=
name|x
expr_stmt|;
name|info
operator|->
name|offset
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|mips_valid_base_register_p
argument_list|(
name|info
operator|->
name|reg
argument_list|,
name|mode
argument_list|,
name|strict
argument_list|)
return|;
case|case
name|PLUS
case|:
name|info
operator|->
name|type
operator|=
name|ADDRESS_REG
expr_stmt|;
name|info
operator|->
name|reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info
operator|->
name|offset
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|mips_valid_base_register_p
argument_list|(
name|info
operator|->
name|reg
argument_list|,
name|mode
argument_list|,
name|strict
argument_list|)
operator|&&
name|const_arith_operand
argument_list|(
name|info
operator|->
name|offset
argument_list|,
name|VOIDmode
argument_list|)
operator|)
return|;
case|case
name|LO_SUM
case|:
name|info
operator|->
name|type
operator|=
name|ADDRESS_LO_SUM
expr_stmt|;
name|info
operator|->
name|reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info
operator|->
name|offset
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|mips_valid_base_register_p
argument_list|(
name|info
operator|->
name|reg
argument_list|,
name|mode
argument_list|,
name|strict
argument_list|)
operator|&&
name|mips_symbolic_constant_p
argument_list|(
name|info
operator|->
name|offset
argument_list|,
operator|&
name|info
operator|->
name|symbol_type
argument_list|)
operator|&&
name|mips_symbolic_address_p
argument_list|(
name|info
operator|->
name|symbol_type
argument_list|,
name|mode
argument_list|)
operator|&&
name|mips_lo_relocs
index|[
name|info
operator|->
name|symbol_type
index|]
operator|!=
literal|0
operator|)
return|;
case|case
name|CONST_INT
case|:
comment|/* Small-integer addresses don't occur very often, but they 	 are legitimate if $0 is a valid base register.  */
name|info
operator|->
name|type
operator|=
name|ADDRESS_CONST_INT
expr_stmt|;
return|return
operator|!
name|TARGET_MIPS16
operator|&&
name|SMALL_INT
argument_list|(
name|x
argument_list|)
return|;
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
name|info
operator|->
name|type
operator|=
name|ADDRESS_SYMBOLIC
expr_stmt|;
return|return
operator|(
name|mips_symbolic_constant_p
argument_list|(
name|x
argument_list|,
operator|&
name|info
operator|->
name|symbol_type
argument_list|)
operator|&&
name|mips_symbolic_address_p
argument_list|(
name|info
operator|->
name|symbol_type
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|mips_split_p
index|[
name|info
operator|->
name|symbol_type
index|]
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if X is a thread-local symbol.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_tls_operand_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if X can not be forced into a constant pool.  */
end_comment

begin_function
specifier|static
name|int
name|mips_tls_symbol_ref_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|mips_tls_operand_p
argument_list|(
operator|*
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if X can not be forced into a constant pool.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_MIPS16
condition|)
block|{
comment|/* As an optimization, reject constants that mips_legitimize_move 	 can expand inline.  	 Suppose we have a multi-instruction sequence that loads constant C 	 into register R.  If R does not get allocated a hard register, and 	 R is used in an operand that allows both registers and memory 	 references, reload will consider forcing C into memory and using 	 one of the instruction's memory alternatives.  Returning false 	 here will force it to use an input reload instead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|true
return|;
name|mips_split_const
argument_list|(
name|x
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolic_operand
argument_list|(
name|base
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|SMALL_OPERAND
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|TARGET_HAVE_TLS
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|mips_tls_symbol_ref_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_USE_BLOCKS_FOR_CONSTANT_P.  MIPS16 uses per-function    constant pools, but normal-mode code doesn't need to.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_use_blocks_for_constant_p
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|!
name|TARGET_MIPS16
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of instructions needed to load a symbol of the    given type into a register.  If valid in an address, the same number    of instructions are needed for loads and stores.  Treat extended    mips16 instructions as two instructions.  */
end_comment

begin_function
specifier|static
name|int
name|mips_symbol_insns
parameter_list|(
name|enum
name|mips_symbol_type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYMBOL_GENERAL
case|:
comment|/* In mips16 code, general symbols must be fetched from the 	 constant pool.  */
if|if
condition|(
name|TARGET_MIPS16
condition|)
return|return
literal|0
return|;
comment|/* When using 64-bit symbols, we need 5 preparatory instructions, 	 such as:  	     lui     $at,%highest(symbol) 	     daddiu  $at,$at,%higher(symbol) 	     dsll    $at,$at,16 	     daddiu  $at,$at,%hi(symbol) 	     dsll    $at,$at,16  	 The final address is then $at + %lo(symbol).  With 32-bit 	 symbols we just need a preparatory lui.  */
return|return
operator|(
name|ABI_HAS_64BIT_SYMBOLS
condition|?
literal|6
else|:
literal|2
operator|)
return|;
case|case
name|SYMBOL_SMALL_DATA
case|:
return|return
literal|1
return|;
case|case
name|SYMBOL_CONSTANT_POOL
case|:
comment|/* This case is for mips16 only.  Assume we'll need an 	 extended instruction.  */
return|return
literal|2
return|;
case|case
name|SYMBOL_GOT_LOCAL
case|:
case|case
name|SYMBOL_GOT_GLOBAL
case|:
comment|/* Unless -funit-at-a-time is in effect, we can't be sure whether 	 the local/global classification is accurate.  See override_options 	 for details.  	 The worst cases are:  	 (1) For local symbols when generating o32 or o64 code.  The assembler 	     will use:  		 lw	      $at,%got(symbol) 		 nop  	     ...and the final address will be $at + %lo(symbol).  	 (2) For global symbols when -mxgot.  The assembler will use:  	         lui     $at,%got_hi(symbol) 	         (d)addu $at,$at,$gp  	     ...and the final address will be $at + %got_lo(symbol).  */
return|return
literal|3
return|;
case|case
name|SYMBOL_GOTOFF_PAGE
case|:
case|case
name|SYMBOL_GOTOFF_GLOBAL
case|:
case|case
name|SYMBOL_GOTOFF_CALL
case|:
case|case
name|SYMBOL_GOTOFF_LOADGP
case|:
case|case
name|SYMBOL_64_HIGH
case|:
case|case
name|SYMBOL_64_MID
case|:
case|case
name|SYMBOL_64_LOW
case|:
case|case
name|SYMBOL_TLSGD
case|:
case|case
name|SYMBOL_TLSLDM
case|:
case|case
name|SYMBOL_DTPREL
case|:
case|case
name|SYMBOL_GOTTPREL
case|:
case|case
name|SYMBOL_TPREL
case|:
comment|/* Check whether the offset is a 16- or 32-bit value.  */
return|return
name|mips_split_p
index|[
name|type
index|]
condition|?
literal|2
else|:
literal|1
return|;
case|case
name|SYMBOL_TLS
case|:
comment|/* We don't treat a bare TLS symbol as a constant.  */
return|return
literal|0
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if X is a legitimate $sp-based address for mode MDOE.  */
end_comment

begin_function
name|bool
name|mips_stack_address_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|mips_address_info
name|addr
decl_stmt|;
return|return
operator|(
name|mips_classify_address
argument_list|(
operator|&
name|addr
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|false
argument_list|)
operator|&&
name|addr
operator|.
name|type
operator|==
name|ADDRESS_REG
operator|&&
name|addr
operator|.
name|reg
operator|==
name|stack_pointer_rtx
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if a value at OFFSET bytes from BASE can be accessed    using an unextended mips16 instruction.  MODE is the mode of the    value.     Usually the offset in an unextended instruction is a 5-bit field.    The offset is unsigned and shifted left once for HIs, twice    for SIs, and so on.  An exception is SImode accesses off the    stack pointer, which have an 8-bit immediate field.  */
end_comment

begin_function
specifier|static
name|bool
name|mips16_unextended_reference_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|base
parameter_list|,
name|rtx
name|offset
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|4
operator|&&
name|base
operator|==
name|stack_pointer_rtx
condition|)
return|return
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|<
literal|256
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
return|return
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|<
literal|32
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instructions needed to load or store a value    of mode MODE at X.  Return 0 if X isn't valid for MODE.     For mips16 code, count extended instructions as two instructions.  */
end_comment

begin_function
name|int
name|mips_address_insns
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|mips_address_info
name|addr
decl_stmt|;
name|int
name|factor
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
comment|/* BLKmode is used for single unaligned loads and stores.  */
name|factor
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Each word of a multi-word value will be accessed individually.  */
name|factor
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|mips_classify_address
argument_list|(
operator|&
name|addr
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|false
argument_list|)
condition|)
switch|switch
condition|(
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|ADDRESS_REG
case|:
if|if
condition|(
name|TARGET_MIPS16
operator|&&
operator|!
name|mips16_unextended_reference_p
argument_list|(
name|mode
argument_list|,
name|addr
operator|.
name|reg
argument_list|,
name|addr
operator|.
name|offset
argument_list|)
condition|)
return|return
name|factor
operator|*
literal|2
return|;
return|return
name|factor
return|;
case|case
name|ADDRESS_LO_SUM
case|:
return|return
operator|(
name|TARGET_MIPS16
condition|?
name|factor
operator|*
literal|2
else|:
name|factor
operator|)
return|;
case|case
name|ADDRESS_CONST_INT
case|:
return|return
name|factor
return|;
case|case
name|ADDRESS_SYMBOLIC
case|:
return|return
name|factor
operator|*
name|mips_symbol_insns
argument_list|(
name|addr
operator|.
name|symbol_type
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Likewise for constant X.  */
end_comment

begin_function
name|int
name|mips_const_insns
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|mips_integer_op
name|codes
index|[
name|MIPS_MAX_INTEGER_OPS
index|]
decl_stmt|;
name|enum
name|mips_symbol_type
name|symbol_type
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|HIGH
case|:
if|if
condition|(
name|TARGET_MIPS16
operator|||
operator|!
name|mips_symbolic_constant_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|symbol_type
argument_list|)
operator|||
operator|!
name|mips_split_p
index|[
name|symbol_type
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|TARGET_MIPS16
condition|)
comment|/* Unsigned 8-bit constants can be loaded using an unextended 	   LI instruction.  Unsigned 16-bit constants can be loaded 	   using an extended LI.  Negative constants must be loaded 	   using LI and then negated.  */
return|return
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
condition|?
literal|1
else|:
name|SMALL_OPERAND_UNSIGNED
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
literal|2
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|?
literal|2
else|:
name|SMALL_OPERAND_UNSIGNED
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
literal|3
else|:
literal|0
operator|)
return|;
return|return
name|mips_build_integer
argument_list|(
name|codes
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
return|return
operator|(
operator|!
name|TARGET_MIPS16
operator|&&
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
case|case
name|CONST
case|:
if|if
condition|(
name|CONST_GP_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* See if we can refer to X directly.  */
if|if
condition|(
name|mips_symbolic_constant_p
argument_list|(
name|x
argument_list|,
operator|&
name|symbol_type
argument_list|)
condition|)
return|return
name|mips_symbol_insns
argument_list|(
name|symbol_type
argument_list|)
return|;
comment|/* Otherwise try splitting the constant into a base and offset. 	 16-bit offsets can be added using an extra addiu.  Larger offsets 	 must be calculated separately and then added to the base.  */
name|mips_split_const
argument_list|(
name|x
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|mips_const_insns
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SMALL_OPERAND
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|n
operator|+
literal|1
return|;
else|else
return|return
name|n
operator|+
literal|1
operator|+
name|mips_build_integer
argument_list|(
name|codes
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|mips_symbol_insns
argument_list|(
name|mips_classify_symbol
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number of instructions needed for memory reference X.    Count extended mips16 instructions as two instructions.  */
end_comment

begin_function
name|int
name|mips_fetch_insns
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mips_address_insns
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instructions needed for an integer division.  */
end_comment

begin_function
name|int
name|mips_idiv_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_CHECK_ZERO_DIV
condition|)
block|{
if|if
condition|(
name|GENERATE_DIVIDE_TRAPS
condition|)
name|count
operator|++
expr_stmt|;
else|else
name|count
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_FIX_R4000
operator|||
name|TARGET_FIX_R4400
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is used to implement GO_IF_LEGITIMATE_ADDRESS.  It    returns a nonzero value if X is a legitimate address for a memory    operand of the indicated MODE.  STRICT is nonzero if this function    is called during reload.  */
end_comment

begin_function
name|bool
name|mips_legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|struct
name|mips_address_info
name|addr
decl_stmt|;
return|return
name|mips_classify_address
argument_list|(
operator|&
name|addr
argument_list|,
name|x
argument_list|,
name|mode
argument_list|,
name|strict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy VALUE to a register and return that register.  If new psuedos    are allowed, copy it into a new register, otherwise use DEST.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_force_temporary
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|value
argument_list|)
return|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a LO_SUM expression for ADDR.  TEMP is as for mips_force_temporary    and is used to load the high part into a register.  */
end_comment

begin_function
name|rtx
name|mips_split_symbol
parameter_list|(
name|rtx
name|temp
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|high
decl_stmt|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
name|high
operator|=
name|mips16_gp_pseudo_reg
argument_list|()
expr_stmt|;
else|else
name|high
operator|=
name|mips_force_temporary
argument_list|(
name|temp
argument_list|,
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|copy_rtx
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|high
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an UNSPEC address with underlying address ADDRESS and symbol    type SYMBOL_TYPE.  */
end_comment

begin_function
name|rtx
name|mips_unspec_address
parameter_list|(
name|rtx
name|address
parameter_list|,
name|enum
name|mips_symbol_type
name|symbol_type
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|mips_split_const
argument_list|(
name|address
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|base
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|base
argument_list|)
argument_list|,
name|UNSPEC_ADDRESS_FIRST
operator|+
name|symbol_type
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If mips_unspec_address (ADDR, SYMBOL_TYPE) is a 32-bit value, add the    high part to BASE and return the result.  Just return BASE otherwise.    TEMP is available as a temporary register if needed.     The returned expression can be used as the first operand to a LO_SUM.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_unspec_offset_high
parameter_list|(
name|rtx
name|temp
parameter_list|,
name|rtx
name|base
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|enum
name|mips_symbol_type
name|symbol_type
parameter_list|)
block|{
if|if
condition|(
name|mips_split_p
index|[
name|symbol_type
index|]
condition|)
block|{
name|addr
operator|=
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|mips_unspec_address
argument_list|(
name|addr
argument_list|,
name|symbol_type
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mips_force_temporary
argument_list|(
name|temp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|mips_force_temporary
argument_list|(
name|temp
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|base
argument_list|)
argument_list|)
return|;
block|}
return|return
name|base
return|;
block|}
end_function

begin_comment
comment|/* Return a legitimate address for REG + OFFSET.  TEMP is as for    mips_force_temporary; it is only needed when OFFSET is not a    SMALL_OPERAND.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_add_offset
parameter_list|(
name|rtx
name|temp
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SMALL_OPERAND
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|rtx
name|high
decl_stmt|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
comment|/* Load the full offset into a register so that we can use 	     an unextended instruction for the address itself.  */
name|high
operator|=
name|GEN_INT
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave OFFSET as a 16-bit offset and put the excess in HIGH.  */
name|high
operator|=
name|GEN_INT
argument_list|(
name|CONST_HIGH_PART
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|CONST_LOW_PART
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
name|high
operator|=
name|mips_force_temporary
argument_list|(
name|temp
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mips_force_temporary
argument_list|(
name|temp
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|high
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|plus_constant
argument_list|(
name|reg
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit a call to __tls_get_addr.  SYM is the TLS symbol we are    referencing, and TYPE is the symbol type to use (either global    dynamic or local dynamic).  V0 is an RTX for the return value    location.  The entire insn sequence is returned.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|mips_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|mips_call_tls_get_addr
parameter_list|(
name|rtx
name|sym
parameter_list|,
name|enum
name|mips_symbol_type
name|type
parameter_list|,
name|rtx
name|v0
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|loc
decl_stmt|,
name|tga
decl_stmt|,
name|a0
decl_stmt|;
name|a0
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GP_ARG_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_tls_symbol
condition|)
name|mips_tls_symbol
operator|=
name|init_one_libfunc
argument_list|(
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
name|loc
operator|=
name|mips_unspec_address
argument_list|(
name|sym
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|Pmode
argument_list|,
name|a0
argument_list|,
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|loc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tga
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|mips_tls_symbol
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_call_value
argument_list|(
name|v0
argument_list|,
name|tga
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|a0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Generate the code to access LOC, a thread local SYMBOL_REF.  The    return value will be a valid address and move_operand (either a REG    or a LO_SUM).  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_legitimize_tls_address
parameter_list|(
name|rtx
name|loc
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|insn
decl_stmt|,
name|v0
decl_stmt|,
name|v1
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|eqv
decl_stmt|;
name|enum
name|tls_model
name|model
decl_stmt|;
name|v0
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GP_RETURN
argument_list|)
expr_stmt|;
name|v1
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GP_RETURN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|model
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|loc
argument_list|)
expr_stmt|;
comment|/* Only TARGET_ABICALLS code can have more than one module; other      code must be be static and should not use a GOT.  All TLS models      reduce to local exec in this situation.  */
if|if
condition|(
operator|!
name|TARGET_ABICALLS
condition|)
name|model
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
switch|switch
condition|(
name|model
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|insn
operator|=
name|mips_call_tls_get_addr
argument_list|(
name|loc
argument_list|,
name|SYMBOL_TLSGD
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
name|v0
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|insn
operator|=
name|mips_call_tls_get_addr
argument_list|(
name|loc
argument_list|,
name|SYMBOL_TLSLDM
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Attach a unique REG_EQUIV, to allow the RTL optimizers to 	 share the LDM result with other LD model accesses.  */
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLS_LDM
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insn
argument_list|,
name|tmp1
argument_list|,
name|v0
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|mips_unspec_offset_high
argument_list|(
name|NULL
argument_list|,
name|tmp1
argument_list|,
name|loc
argument_list|,
name|SYMBOL_DTPREL
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|tmp2
argument_list|,
name|mips_unspec_address
argument_list|(
name|loc
argument_list|,
name|SYMBOL_DTPREL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|mips_unspec_address
argument_list|(
name|loc
argument_list|,
name|SYMBOL_GOTTPREL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pmode
operator|==
name|DImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_tls_get_tp_di
argument_list|(
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_gotdi
argument_list|(
name|tmp1
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_tls_get_tp_si
argument_list|(
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_gotsi
argument_list|(
name|tmp1
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|dest
argument_list|,
name|tmp1
argument_list|,
name|v1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
if|if
condition|(
name|Pmode
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_tls_get_tp_di
argument_list|(
name|v1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_tls_get_tp_si
argument_list|(
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|mips_unspec_offset_high
argument_list|(
name|NULL
argument_list|,
name|v1
argument_list|,
name|loc
argument_list|,
name|SYMBOL_TPREL
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|tmp1
argument_list|,
name|mips_unspec_address
argument_list|(
name|loc
argument_list|,
name|SYMBOL_TPREL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can    be legitimized in a way that the generic machinery might not expect,    put the new address in *XLOC and return true.  MODE is the mode of    the memory being accessed.  */
end_comment

begin_function
name|bool
name|mips_legitimize_address
parameter_list|(
name|rtx
modifier|*
name|xloc
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|mips_symbol_type
name|symbol_type
decl_stmt|;
if|if
condition|(
name|mips_tls_operand_p
argument_list|(
operator|*
name|xloc
argument_list|)
condition|)
block|{
operator|*
name|xloc
operator|=
name|mips_legitimize_tls_address
argument_list|(
operator|*
name|xloc
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* See if the address can split into a high part and a LO_SUM.  */
if|if
condition|(
name|mips_symbolic_constant_p
argument_list|(
operator|*
name|xloc
argument_list|,
operator|&
name|symbol_type
argument_list|)
operator|&&
name|mips_symbolic_address_p
argument_list|(
name|symbol_type
argument_list|,
name|mode
argument_list|)
operator|&&
name|mips_split_p
index|[
name|symbol_type
index|]
condition|)
block|{
operator|*
name|xloc
operator|=
name|mips_split_symbol
argument_list|(
literal|0
argument_list|,
operator|*
name|xloc
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|xloc
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|xloc
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Handle REG + CONSTANT using mips_add_offset.  */
name|rtx
name|reg
decl_stmt|;
name|reg
operator|=
name|XEXP
argument_list|(
operator|*
name|xloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_valid_base_register_p
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
condition|)
name|reg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
operator|*
name|xloc
operator|=
name|mips_add_offset
argument_list|(
literal|0
argument_list|,
name|reg
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
operator|*
name|xloc
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of mips_build_integer (with the same interface).    Assume that the final action in the sequence should be a left shift.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mips_build_shift
parameter_list|(
name|struct
name|mips_integer_op
modifier|*
name|codes
parameter_list|,
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|;
comment|/* Shift VALUE right until its lowest bit is set.  Shift arithmetically      since signed numbers are easier to load than unsigned ones.  */
name|shift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|value
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|value
operator|/=
literal|2
operator|,
name|shift
operator|++
expr_stmt|;
name|i
operator|=
name|mips_build_integer
argument_list|(
name|codes
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|codes
index|[
name|i
index|]
operator|.
name|code
operator|=
name|ASHIFT
expr_stmt|;
name|codes
index|[
name|i
index|]
operator|.
name|value
operator|=
name|shift
expr_stmt|;
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* As for mips_build_shift, but assume that the final action will be    an IOR or PLUS operation.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mips_build_lower
parameter_list|(
name|struct
name|mips_integer_op
modifier|*
name|codes
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|high
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|high
operator|=
name|value
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffff
expr_stmt|;
if|if
condition|(
operator|!
name|LUI_OPERAND
argument_list|(
name|high
argument_list|)
operator|&&
operator|(
name|value
operator|&
literal|0x18000
operator|)
operator|==
literal|0x18000
condition|)
block|{
comment|/* The constant is too complex to load with a simple lui/ori pair 	 so our goal is to clear as many trailing zeros as possible. 	 In this case, we know bit 16 is set and that the low 16 bits 	 form a negative number.  If we subtract that number from VALUE, 	 we will clear at least the lowest 17 bits, maybe more.  */
name|i
operator|=
name|mips_build_integer
argument_list|(
name|codes
argument_list|,
name|CONST_HIGH_PART
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|codes
index|[
name|i
index|]
operator|.
name|code
operator|=
name|PLUS
expr_stmt|;
name|codes
index|[
name|i
index|]
operator|.
name|value
operator|=
name|CONST_LOW_PART
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|mips_build_integer
argument_list|(
name|codes
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|codes
index|[
name|i
index|]
operator|.
name|code
operator|=
name|IOR
expr_stmt|;
name|codes
index|[
name|i
index|]
operator|.
name|value
operator|=
name|value
operator|&
literal|0xffff
expr_stmt|;
block|}
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill CODES with a sequence of rtl operations to load VALUE.    Return the number of operations needed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mips_build_integer
parameter_list|(
name|struct
name|mips_integer_op
modifier|*
name|codes
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
if|if
condition|(
name|SMALL_OPERAND
argument_list|(
name|value
argument_list|)
operator|||
name|SMALL_OPERAND_UNSIGNED
argument_list|(
name|value
argument_list|)
operator|||
name|LUI_OPERAND
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* The value can be loaded with a single instruction.  */
name|codes
index|[
literal|0
index|]
operator|.
name|code
operator|=
name|UNKNOWN
expr_stmt|;
name|codes
index|[
literal|0
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|||
name|LUI_OPERAND
argument_list|(
name|CONST_HIGH_PART
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Either the constant is a simple LUI/ORI combination or its 	 lowest bit is set.  We don't want to shift in this case.  */
return|return
name|mips_build_lower
argument_list|(
name|codes
argument_list|,
name|value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* The constant will need at least three actions.  The lowest 	 16 bits are clear, so the final action will be a shift.  */
return|return
name|mips_build_shift
argument_list|(
name|codes
argument_list|,
name|value
argument_list|)
return|;
block|}
else|else
block|{
comment|/* The final action could be a shift, add or inclusive OR. 	 Rather than use a complex condition to select the best 	 approach, try both mips_build_shift and mips_build_lower 	 and pick the one that gives the shortest sequence. 	 Note that this case is only used once per constant.  */
name|struct
name|mips_integer_op
name|alt_codes
index|[
name|MIPS_MAX_INTEGER_OPS
index|]
decl_stmt|;
name|unsigned
name|int
name|cost
decl_stmt|,
name|alt_cost
decl_stmt|;
name|cost
operator|=
name|mips_build_shift
argument_list|(
name|codes
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|alt_cost
operator|=
name|mips_build_lower
argument_list|(
name|alt_codes
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_cost
operator|<
name|cost
condition|)
block|{
name|memcpy
argument_list|(
name|codes
argument_list|,
name|alt_codes
argument_list|,
name|alt_cost
operator|*
sizeof|sizeof
argument_list|(
name|codes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cost
operator|=
name|alt_cost
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
block|}
end_function

begin_comment
comment|/* Load VALUE into DEST, using TEMP as a temporary register if need be.  */
end_comment

begin_function
name|void
name|mips_move_integer
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|temp
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|struct
name|mips_integer_op
name|codes
index|[
name|MIPS_MAX_INTEGER_OPS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cost
operator|=
name|mips_build_integer
argument_list|(
name|codes
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Apply each binary operation to X.  Invariant: X is a legitimate      source operand for a SET pattern.  */
name|x
operator|=
name|GEN_INT
argument_list|(
name|codes
index|[
literal|0
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cost
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|temp
expr_stmt|;
block|}
else|else
name|x
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|codes
index|[
name|i
index|]
operator|.
name|code
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|codes
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of mips_legitimize_move.  Move constant SRC into register    DEST given that SRC satisfies immediate_operand but doesn't satisfy    move_operand.  */
end_comment

begin_function
specifier|static
name|void
name|mips_legitimize_const_move
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* Split moves of big integers into smaller pieces.  */
if|if
condition|(
name|splittable_const_int_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|mips_move_integer
argument_list|(
name|dest
argument_list|,
name|dest
argument_list|,
name|INTVAL
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Split moves of symbolic constants into high/low pairs.  */
if|if
condition|(
name|splittable_symbolic_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|mips_split_symbol
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mips_tls_operand_p
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|mips_legitimize_tls_address
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have (const (plus symbol offset)), load the symbol first      and then add in the offset.  This is usually better than forcing      the constant into memory, at least in non-mips16 code.  */
name|mips_split_const
argument_list|(
name|src
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_MIPS16
operator|&&
name|offset
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|no_new_pseudos
operator|||
name|SMALL_OPERAND
argument_list|(
name|offset
argument_list|)
operator|)
condition|)
block|{
name|base
operator|=
name|mips_force_temporary
argument_list|(
name|dest
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|mips_add_offset
argument_list|(
literal|0
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* When using explicit relocs, constant pool references are sometimes      not legitimate addresses.  */
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|src
operator|=
name|replace_equiv_address
argument_list|(
name|src
argument_list|,
name|mips_split_symbol
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If (set DEST SRC) is not a valid instruction, emit an equivalent    sequence that is valid.  */
end_comment

begin_function
name|bool
name|mips_legitimize_move
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|reg_or_0_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Check for individual, fully-reloaded mflo and mfhi instructions.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|REG_P
argument_list|(
name|src
argument_list|)
operator|&&
name|MD_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|&&
name|GP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|other_regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|HI_REGNUM
condition|?
name|LO_REGNUM
else|:
name|HI_REGNUM
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
condition|)
name|emit_insn
argument_list|(
name|gen_mfhilo_si
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|other_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_mfhilo_di
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|other_regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We need to deal with constants that would be legitimate      immediate_operands but not legitimate move_operands.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|&&
operator|!
name|move_operand
argument_list|(
name|src
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|mips_legitimize_const_move
argument_list|(
name|mode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We need a lot of little routines to check constant values on the    mips16.  These are used to figure out how long the instruction will    be.  It would be much better to do this using constraints, but    there aren't nearly enough letters available.  */
end_comment

begin_function
specifier|static
name|int
name|m16_check_op
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
name|low
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
name|high
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
name|mask
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|m16_uimm3_b
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
literal|0x1
argument_list|,
literal|0x8
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_simm4_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0x8
argument_list|,
literal|0x7
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_nsimm4_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0x7
argument_list|,
literal|0x8
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_simm5_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0x10
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_nsimm5_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0xf
argument_list|,
literal|0x10
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_uimm5_4
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|(
operator|-
literal|0x10
operator|)
operator|<<
literal|2
argument_list|,
literal|0xf
operator|<<
literal|2
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_nuimm5_4
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|(
operator|-
literal|0xf
operator|)
operator|<<
literal|2
argument_list|,
literal|0x10
operator|<<
literal|2
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_simm8_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0x80
argument_list|,
literal|0x7f
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_nsimm8_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0x7f
argument_list|,
literal|0x80
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_uimm8_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
literal|0x0
argument_list|,
literal|0xff
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_nuimm8_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0xff
argument_list|,
literal|0x0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_uimm8_m1_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|-
literal|0x1
argument_list|,
literal|0xfe
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_uimm8_4
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
literal|0x0
argument_list|,
literal|0xff
operator|<<
literal|2
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_nuimm8_4
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|(
operator|-
literal|0xff
operator|)
operator|<<
literal|2
argument_list|,
literal|0x0
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_simm8_8
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|(
operator|-
literal|0x80
operator|)
operator|<<
literal|3
argument_list|,
literal|0x7f
operator|<<
literal|3
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|m16_nsimm8_8
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|m16_check_op
argument_list|(
name|op
argument_list|,
operator|(
operator|-
literal|0x7f
operator|)
operator|<<
literal|3
argument_list|,
literal|0x80
operator|<<
literal|3
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|mips_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|bool
name|float_mode_p
init|=
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
comment|/* A number between 1 and 8 inclusive is efficient for a shift. 	     Otherwise, we will need an extended instruction.  */
if|if
condition|(
operator|(
name|outer_code
operator|)
operator|==
name|ASHIFT
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|ASHIFTRT
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|LSHIFTRT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|1
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<=
literal|8
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We can use cmpi for an xor with an unsigned 16 bit value.  */
if|if
condition|(
operator|(
name|outer_code
operator|)
operator|==
name|XOR
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0x10000
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We may be able to use slt or sltu for a comparison with a 	     signed 16 bit value.  (The boundary conditions aren't quite 	     right, but this is just a heuristic anyhow.)  */
if|if
condition|(
operator|(
operator|(
name|outer_code
operator|)
operator|==
name|LT
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|LE
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|GE
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|GT
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|LTU
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|LEU
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|GEU
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|GTU
operator|)
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
operator|-
literal|0x8000
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0x8000
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Equality comparisons with 0 are cheap.  */
if|if
condition|(
operator|(
operator|(
name|outer_code
operator|)
operator|==
name|EQ
operator|||
operator|(
name|outer_code
operator|)
operator|==
name|NE
operator|)
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Constants in the range 0...255 can be loaded with an unextended 	     instruction.  They are therefore as cheap as a register move.  	     Given the choice between "li R1,0...255" and "move R1,R2" 	     (where R2 is a known constant), it is usually better to use "li", 	     since we do not want to unnecessarily extend the lifetime 	     of R2.  */
if|if
condition|(
name|outer_code
operator|==
name|SET
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
else|else
block|{
comment|/* These can be used anywhere. */
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Otherwise fall through to the handling below because 	 we'll need to construct the constant.  */
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* The value will need to be fetched from the constant pool.  */
operator|*
name|total
operator|=
name|CONSTANT_POOL_COST
expr_stmt|;
return|return
name|true
return|;
block|}
case|case
name|MEM
case|:
block|{
comment|/* If the address is legitimate, return the number of 	   instructions it needs, otherwise use the default handling.  */
name|int
name|n
init|=
name|mips_address_insns
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
case|case
name|FFS
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|NOT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
operator|(
name|mode
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|?
literal|4
else|:
literal|12
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|ABS
case|:
if|if
condition|(
name|float_mode_p
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|LO_SUM
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|float_mode_p
condition|)
block|{
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|fp_add
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|NEG
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|fp_mult_sf
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|fp_mult_df
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|int_mult_si
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|int_mult_di
expr_stmt|;
return|return
name|true
return|;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
if|if
condition|(
name|float_mode_p
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|fp_div_sf
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|fp_div_df
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Fall through.  */
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|int_div_di
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|int_div_si
expr_stmt|;
return|return
name|true
return|;
case|case
name|SIGN_EXTEND
case|:
comment|/* A sign extend from SImode to DImode in 64 bit mode is often          zero instructions, because the result can often be used          directly by another instruction; we'll call it one.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SImode
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|ZERO_EXTEND
case|:
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SImode
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|FLOAT
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|SQRT
case|:
operator|*
name|total
operator|=
name|mips_cost
operator|->
name|fp_add
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Provide the costs of an addressing mode that contains ADDR.    If ADDR is not a valid address, its cost is irrelevant.  */
end_comment

begin_function
specifier|static
name|int
name|mips_address_cost
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
return|return
name|mips_address_insns
argument_list|(
name|addr
argument_list|,
name|SImode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return one word of double-word value OP, taking into account the fixed    endianness of certain registers.  HIGH_P is true to select the high part,    false to select the low part.  */
end_comment

begin_function
name|rtx
name|mips_subword
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|high_p
parameter_list|)
block|{
name|unsigned
name|int
name|byte
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|DImode
expr_stmt|;
if|if
condition|(
name|TARGET_BIG_ENDIAN
condition|?
operator|!
name|high_p
else|:
name|high_p
condition|)
name|byte
operator|=
name|UNITS_PER_WORD
expr_stmt|;
else|else
name|byte
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|high_p
condition|?
name|REGNO
argument_list|(
name|op
argument_list|)
operator|+
literal|1
else|:
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ACC_HI_REG_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|high_p
condition|?
name|REGNO
argument_list|(
name|op
argument_list|)
else|:
name|REGNO
argument_list|(
name|op
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|mips_rewrite_small_data
argument_list|(
name|adjust_address
argument_list|(
name|op
argument_list|,
name|word_mode
argument_list|,
name|byte
argument_list|)
argument_list|)
return|;
return|return
name|simplify_gen_subreg
argument_list|(
name|word_mode
argument_list|,
name|op
argument_list|,
name|mode
argument_list|,
name|byte
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if a 64-bit move from SRC to DEST should be split into two.  */
end_comment

begin_function
name|bool
name|mips_split_64bit_move_p
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|false
return|;
comment|/* FP->FP moves can be done in a single instruction.  */
if|if
condition|(
name|FP_REG_RTX_P
argument_list|(
name|src
argument_list|)
operator|&&
name|FP_REG_RTX_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Check for floating-point loads and stores.  They can be done using      ldc1 and sdc1 on MIPS II and above.  */
if|if
condition|(
name|mips_isa
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|FP_REG_RTX_P
argument_list|(
name|dest
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|FP_REG_RTX_P
argument_list|(
name|src
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Split a 64-bit move from SRC to DEST assuming that    mips_split_64bit_move_p holds.     Moves into and out of FPRs cause some difficulty here.  Such moves    will always be DFmode, since paired FPRs are not allowed to store    DImode values.  The most natural representation would be two separate    32-bit moves, such as:  	(set (reg:SI $f0) (mem:SI ...)) 	(set (reg:SI $f1) (mem:SI ...))     However, the second insn is invalid because odd-numbered FPRs are    not allowed to store independent values.  Use the patterns load_df_low,    load_df_high and store_df_high instead.  */
end_comment

begin_function
name|void
name|mips_split_64bit_move
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
name|FP_REG_RTX_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Loading an FPR from memory or from GPRs.  */
name|emit_insn
argument_list|(
name|gen_load_df_low
argument_list|(
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|,
name|mips_subword
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_df_high
argument_list|(
name|dest
argument_list|,
name|mips_subword
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_RTX_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Storing an FPR into memory or GPRs.  */
name|emit_move_insn
argument_list|(
name|mips_subword
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mips_subword
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_store_df_high
argument_list|(
name|mips_subword
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The operation can be split into two normal moves.  Decide in 	 which order to do them.  */
name|rtx
name|low_dest
decl_stmt|;
name|low_dest
operator|=
name|mips_subword
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|low_dest
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|low_dest
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|mips_subword
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mips_subword
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|low_dest
argument_list|,
name|mips_subword
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|low_dest
argument_list|,
name|mips_subword
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mips_subword
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mips_subword
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the appropriate instructions to move SRC into DEST.  Assume    that SRC is operand 1 and DEST is operand 0.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mips_output_move
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|enum
name|rtx_code
name|dest_code
decl_stmt|,
name|src_code
decl_stmt|;
name|bool
name|dbl_p
decl_stmt|;
name|dest_code
operator|=
name|GET_CODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|src_code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dbl_p
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|dbl_p
operator|&&
name|mips_split_64bit_move_p
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
condition|)
return|return
literal|"#"
return|;
if|if
condition|(
operator|(
name|src_code
operator|==
name|REG
operator|&&
name|GP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|TARGET_MIPS16
operator|&&
name|src
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dest_code
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|"move\t%0,%z1"
return|;
if|if
condition|(
name|MD_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|"mt%0\t%z1"
return|;
if|if
condition|(
name|DSP_ACC_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|char
name|retval
index|[]
init|=
literal|"mt__\t%z1,%q0"
decl_stmt|;
name|retval
index|[
literal|2
index|]
operator|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
index|[
literal|4
index|]
expr_stmt|;
name|retval
index|[
literal|3
index|]
operator|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
index|[
literal|5
index|]
expr_stmt|;
return|return
name|retval
return|;
block|}
if|if
condition|(
name|FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|dbl_p
condition|?
literal|"dmtc1\t%z1,%0"
else|:
literal|"mtc1\t%z1,%0"
operator|)
return|;
if|if
condition|(
name|ALL_COP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|char
name|retval
index|[]
init|=
literal|"dmtc_\t%z1,%0"
decl_stmt|;
name|retval
index|[
literal|4
index|]
operator|=
name|COPNUM_AS_CHAR_FROM_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dbl_p
condition|?
name|retval
else|:
name|retval
operator|+
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dest_code
operator|==
name|MEM
condition|)
return|return
operator|(
name|dbl_p
condition|?
literal|"sd\t%z1,%0"
else|:
literal|"sw\t%z1,%0"
operator|)
return|;
block|}
if|if
condition|(
name|dest_code
operator|==
name|REG
operator|&&
name|GP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|src_code
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|DSP_ACC_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|char
name|retval
index|[]
init|=
literal|"mf__\t%0,%q1"
decl_stmt|;
name|retval
index|[
literal|2
index|]
operator|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
index|[
literal|4
index|]
expr_stmt|;
name|retval
index|[
literal|3
index|]
operator|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
index|[
literal|5
index|]
expr_stmt|;
return|return
name|retval
return|;
block|}
if|if
condition|(
name|ST_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|&&
name|ISA_HAS_8CC
condition|)
return|return
literal|"lui\t%0,0x3f80\n\tmovf\t%0,%.,%1"
return|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|dbl_p
condition|?
literal|"dmfc1\t%0,%1"
else|:
literal|"mfc1\t%0,%1"
operator|)
return|;
if|if
condition|(
name|ALL_COP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|char
name|retval
index|[]
init|=
literal|"dmfc_\t%0,%1"
decl_stmt|;
name|retval
index|[
literal|4
index|]
operator|=
name|COPNUM_AS_CHAR_FROM_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dbl_p
condition|?
name|retval
else|:
name|retval
operator|+
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|src_code
operator|==
name|MEM
condition|)
return|return
operator|(
name|dbl_p
condition|?
literal|"ld\t%0,%1"
else|:
literal|"lw\t%0,%1"
operator|)
return|;
if|if
condition|(
name|src_code
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Don't use the X format, because that will give out of 	     range numbers for 64 bit hosts and 32 bit targets.  */
if|if
condition|(
operator|!
name|TARGET_MIPS16
condition|)
return|return
literal|"li\t%0,%1\t\t\t# %X1"
return|;
if|if
condition|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|<=
literal|0xffff
condition|)
return|return
literal|"li\t%0,%1"
return|;
if|if
condition|(
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|<
literal|0
operator|&&
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|>=
operator|-
literal|0xffff
condition|)
return|return
literal|"#"
return|;
block|}
if|if
condition|(
name|src_code
operator|==
name|HIGH
condition|)
return|return
literal|"lui\t%0,%h1"
return|;
if|if
condition|(
name|CONST_GP_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|"move\t%0,%1"
return|;
if|if
condition|(
name|symbolic_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
operator|(
name|dbl_p
condition|?
literal|"dla\t%0,%1"
else|:
literal|"la\t%0,%1"
operator|)
return|;
block|}
if|if
condition|(
name|src_code
operator|==
name|REG
operator|&&
name|FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|dest_code
operator|==
name|REG
operator|&&
name|FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|V2SFmode
condition|)
return|return
literal|"mov.ps\t%0,%1"
return|;
else|else
return|return
operator|(
name|dbl_p
condition|?
literal|"mov.d\t%0,%1"
else|:
literal|"mov.s\t%0,%1"
operator|)
return|;
block|}
if|if
condition|(
name|dest_code
operator|==
name|MEM
condition|)
return|return
operator|(
name|dbl_p
condition|?
literal|"sdc1\t%1,%0"
else|:
literal|"swc1\t%1,%0"
operator|)
return|;
block|}
if|if
condition|(
name|dest_code
operator|==
name|REG
operator|&&
name|FP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|src_code
operator|==
name|MEM
condition|)
return|return
operator|(
name|dbl_p
condition|?
literal|"ldc1\t%0,%1"
else|:
literal|"lwc1\t%0,%1"
operator|)
return|;
block|}
if|if
condition|(
name|dest_code
operator|==
name|REG
operator|&&
name|ALL_COP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
name|src_code
operator|==
name|MEM
condition|)
block|{
specifier|static
name|char
name|retval
index|[]
init|=
literal|"l_c_\t%0,%1"
decl_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
operator|(
name|dbl_p
condition|?
literal|'d'
else|:
literal|'w'
operator|)
expr_stmt|;
name|retval
index|[
literal|3
index|]
operator|=
name|COPNUM_AS_CHAR_FROM_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
if|if
condition|(
name|dest_code
operator|==
name|MEM
operator|&&
name|src_code
operator|==
name|REG
operator|&&
name|ALL_COP_REG_P
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|char
name|retval
index|[]
init|=
literal|"s_c_\t%1,%0"
decl_stmt|;
name|retval
index|[
literal|1
index|]
operator|=
operator|(
name|dbl_p
condition|?
literal|'d'
else|:
literal|'w'
operator|)
expr_stmt|;
name|retval
index|[
literal|3
index|]
operator|=
name|COPNUM_AS_CHAR_FROM_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Restore $gp from its save slot.  Valid only when using o32 or    o64 abicalls.  */
end_comment

begin_function
name|void
name|mips_restore_gp
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|address
decl_stmt|,
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|TARGET_ABICALLS
operator|&&
name|TARGET_OLDABI
argument_list|)
expr_stmt|;
name|address
operator|=
name|mips_add_offset
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
argument_list|,
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|slot
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_EXPLICIT_RELOCS
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an instruction of the form (set TARGET (CODE OP0 OP1)).  */
end_comment

begin_function
specifier|static
name|void
name|mips_emit_binary
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if CMP1 is a suitable second operand for relational    operator CODE.  See also the *sCC patterns in mips.md.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_relational_operand_ok_p
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|cmp1
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
case|case
name|GTU
case|:
return|return
name|reg_or_0_operand
argument_list|(
name|cmp1
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|GE
case|:
case|case
name|GEU
case|:
return|return
operator|!
name|TARGET_MIPS16
operator|&&
name|cmp1
operator|==
name|const1_rtx
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
return|return
name|arith_operand
argument_list|(
name|cmp1
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|LE
case|:
return|return
name|sle_operand
argument_list|(
name|cmp1
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
name|LEU
case|:
return|return
name|sleu_operand
argument_list|(
name|cmp1
argument_list|,
name|VOIDmode
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Canonicalize LE or LEU comparisons into LT comparisons when    possible to avoid extra instructions or inverting the    comparison.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_canonicalize_comparison
parameter_list|(
name|enum
name|rtx_code
modifier|*
name|code
parameter_list|,
name|rtx
modifier|*
name|cmp1
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|HOST_WIDE_INT
name|original
decl_stmt|,
name|plus_one
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|cmp1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|false
return|;
name|original
operator|=
name|INTVAL
argument_list|(
operator|*
name|cmp1
argument_list|)
expr_stmt|;
name|plus_one
operator|=
name|trunc_int_for_mode
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|original
operator|+
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|code
condition|)
block|{
case|case
name|LE
case|:
if|if
condition|(
name|original
operator|<
name|plus_one
condition|)
block|{
operator|*
name|code
operator|=
name|LT
expr_stmt|;
operator|*
name|cmp1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|GEN_INT
argument_list|(
name|plus_one
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|plus_one
operator|!=
literal|0
condition|)
block|{
operator|*
name|code
operator|=
name|LTU
expr_stmt|;
operator|*
name|cmp1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|GEN_INT
argument_list|(
name|plus_one
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Compare CMP0 and CMP1 using relational operator CODE and store the    result in TARGET.  CMP0 and TARGET are register_operands that have    the same integer mode.  If INVERT_PTR is nonnull, it's OK to set    TARGET to the inverse of the result and flip *INVERT_PTR instead.  */
end_comment

begin_function
specifier|static
name|void
name|mips_emit_int_relational
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|bool
modifier|*
name|invert_ptr
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|cmp0
parameter_list|,
name|rtx
name|cmp1
parameter_list|)
block|{
comment|/* First see if there is a MIPS instruction that can do this operation      with CMP1 in its current form. If not, try to canonicalize the      comparison to LT. If that fails, try doing the same for the      inverse operation.  If that also fails, force CMP1 into a register      and try again.  */
if|if
condition|(
name|mips_relational_operand_ok_p
argument_list|(
name|code
argument_list|,
name|cmp1
argument_list|)
condition|)
name|mips_emit_binary
argument_list|(
name|code
argument_list|,
name|target
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_canonicalize_comparison
argument_list|(
operator|&
name|code
argument_list|,
operator|&
name|cmp1
argument_list|,
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
condition|)
name|mips_emit_binary
argument_list|(
name|code
argument_list|,
name|target
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|rtx_code
name|inv_code
init|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mips_relational_operand_ok_p
argument_list|(
name|inv_code
argument_list|,
name|cmp1
argument_list|)
condition|)
block|{
name|cmp1
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|cmp0
argument_list|)
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
name|mips_emit_int_relational
argument_list|(
name|code
argument_list|,
name|invert_ptr
argument_list|,
name|target
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|invert_ptr
operator|==
literal|0
condition|)
block|{
name|rtx
name|inv_target
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
decl_stmt|;
name|mips_emit_binary
argument_list|(
name|inv_code
argument_list|,
name|inv_target
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
name|mips_emit_binary
argument_list|(
name|XOR
argument_list|,
name|target
argument_list|,
name|inv_target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|invert_ptr
operator|=
operator|!
operator|*
name|invert_ptr
expr_stmt|;
name|mips_emit_binary
argument_list|(
name|inv_code
argument_list|,
name|target
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a register that is zero iff CMP0 and CMP1 are equal.    The register will have the same mode as CMP0.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_zero_if_equal
parameter_list|(
name|rtx
name|cmp0
parameter_list|,
name|rtx
name|cmp1
parameter_list|)
block|{
if|if
condition|(
name|cmp1
operator|==
name|const0_rtx
condition|)
return|return
name|cmp0
return|;
if|if
condition|(
name|uns_arith_operand
argument_list|(
name|cmp1
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|cmp0
argument_list|)
argument_list|,
name|xor_optab
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
return|;
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|cmp0
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|cmp0
argument_list|,
name|cmp1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_DIRECT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert *CODE into a code that can be used in a floating-point    scc instruction (c.<cond>.<fmt>).  Return true if the values of    the condition code registers will be inverted, with 0 indicating    that the condition holds.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_reverse_fp_cond_p
parameter_list|(
name|enum
name|rtx_code
modifier|*
name|code
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|code
condition|)
block|{
case|case
name|NE
case|:
case|case
name|LTGT
case|:
case|case
name|ORDERED
case|:
operator|*
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
operator|*
name|code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a comparison into something that can be used in a branch or    conditional move.  cmp_operands[0] and cmp_operands[1] are the values    being compared and *CODE is the code used to compare them.     Update *CODE, *OP0 and *OP1 so that they describe the final comparison.    If NEED_EQ_NE_P, then only EQ/NE comparisons against zero are possible,    otherwise any standard branch condition can be used.  The standard branch    conditions are:        - EQ/NE between two registers.       - any comparison between a register and zero.  */
end_comment

begin_function
specifier|static
name|void
name|mips_emit_compare
parameter_list|(
name|enum
name|rtx_code
modifier|*
name|code
parameter_list|,
name|rtx
modifier|*
name|op0
parameter_list|,
name|rtx
modifier|*
name|op1
parameter_list|,
name|bool
name|need_eq_ne_p
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|cmp_operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
if|if
condition|(
operator|!
name|need_eq_ne_p
operator|&&
name|cmp_operands
index|[
literal|1
index|]
operator|==
name|const0_rtx
condition|)
block|{
operator|*
name|op0
operator|=
name|cmp_operands
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|op1
operator|=
name|cmp_operands
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|code
operator|==
name|EQ
operator|||
operator|*
name|code
operator|==
name|NE
condition|)
block|{
if|if
condition|(
name|need_eq_ne_p
condition|)
block|{
operator|*
name|op0
operator|=
name|mips_zero_if_equal
argument_list|(
name|cmp_operands
index|[
literal|0
index|]
argument_list|,
name|cmp_operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|op1
operator|=
name|const0_rtx
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op0
operator|=
name|cmp_operands
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|op1
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|op0
argument_list|)
argument_list|,
name|cmp_operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The comparison needs a separate scc instruction.  Store the 	     result of the scc in *OP0 and compare it against zero.  */
name|bool
name|invert
init|=
name|false
decl_stmt|;
operator|*
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|cmp_operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|mips_emit_int_relational
argument_list|(
operator|*
name|code
argument_list|,
operator|&
name|invert
argument_list|,
operator|*
name|op0
argument_list|,
name|cmp_operands
index|[
literal|0
index|]
argument_list|,
name|cmp_operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|code
operator|=
operator|(
name|invert
condition|?
name|EQ
else|:
name|NE
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
comment|/* Floating-point tests use a separate c.cond.fmt comparison to 	 set a condition code register.  The branch or conditional move 	 will then compare that register against zero.  	 Set CMP_CODE to the code of the comparison instruction and 	 *CODE to the code that the branch or move should use.  */
name|cmp_code
operator|=
operator|*
name|code
expr_stmt|;
operator|*
name|code
operator|=
name|mips_reverse_fp_cond_p
argument_list|(
operator|&
name|cmp_code
argument_list|)
condition|?
name|EQ
else|:
name|NE
expr_stmt|;
operator|*
name|op0
operator|=
operator|(
name|ISA_HAS_8CC
condition|?
name|gen_reg_rtx
argument_list|(
name|CCmode
argument_list|)
else|:
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FPSW_REGNUM
argument_list|)
operator|)
expr_stmt|;
operator|*
name|op1
operator|=
name|const0_rtx
expr_stmt|;
name|mips_emit_binary
argument_list|(
name|cmp_code
argument_list|,
operator|*
name|op0
argument_list|,
name|cmp_operands
index|[
literal|0
index|]
argument_list|,
name|cmp_operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try comparing cmp_operands[0] and cmp_operands[1] using rtl code CODE.    Store the result in TARGET and return true if successful.     On 64-bit targets, TARGET may be wider than cmp_operands[0].  */
end_comment

begin_function
name|bool
name|mips_emit_scc
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|cmp_operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
name|false
return|;
name|target
operator|=
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|cmp_operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
condition|)
block|{
name|rtx
name|zie
init|=
name|mips_zero_if_equal
argument_list|(
name|cmp_operands
index|[
literal|0
index|]
argument_list|,
name|cmp_operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|mips_emit_binary
argument_list|(
name|code
argument_list|,
name|target
argument_list|,
name|zie
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
name|mips_emit_int_relational
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
name|target
argument_list|,
name|cmp_operands
index|[
literal|0
index|]
argument_list|,
name|cmp_operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Emit the common code for doing conditional branches.    operand[0] is the label to jump to.    The comparison operands are saved away by cmp{si,di,sf,df}.  */
end_comment

begin_function
name|void
name|gen_conditional_branch
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|condition
decl_stmt|;
name|mips_emit_compare
argument_list|(
operator|&
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|TARGET_MIPS16
argument_list|)
expr_stmt|;
name|condition
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_condjump
argument_list|(
name|condition
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement:     (set temp (COND:CCV2 CMP_OP0 CMP_OP1))    (set DEST (unspec [TRUE_SRC FALSE_SRC temp] UNSPEC_MOVE_TF_PS))  */
end_comment

begin_function
name|void
name|mips_expand_vcondv2sf
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|true_src
parameter_list|,
name|rtx
name|false_src
parameter_list|,
name|enum
name|rtx_code
name|cond
parameter_list|,
name|rtx
name|cmp_op0
parameter_list|,
name|rtx
name|cmp_op1
parameter_list|)
block|{
name|rtx
name|cmp_result
decl_stmt|;
name|bool
name|reversed_p
decl_stmt|;
name|reversed_p
operator|=
name|mips_reverse_fp_cond_p
argument_list|(
operator|&
name|cond
argument_list|)
expr_stmt|;
name|cmp_result
operator|=
name|gen_reg_rtx
argument_list|(
name|CCV2mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_scc_ps
argument_list|(
name|cmp_result
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cond
argument_list|,
name|VOIDmode
argument_list|,
name|cmp_op0
argument_list|,
name|cmp_op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed_p
condition|)
name|emit_insn
argument_list|(
name|gen_mips_cond_move_tf_ps
argument_list|(
name|dest
argument_list|,
name|false_src
argument_list|,
name|true_src
argument_list|,
name|cmp_result
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_mips_cond_move_tf_ps
argument_list|(
name|dest
argument_list|,
name|true_src
argument_list|,
name|false_src
argument_list|,
name|cmp_result
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the common code for conditional moves.  OPERANDS is the array    of operands passed to the conditional move define_expand.  */
end_comment

begin_function
name|void
name|gen_conditional_move
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mips_emit_compare
argument_list|(
operator|&
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a conditional trap.  OPERANDS is the array of operands passed to    the conditional_trap expander.  */
end_comment

begin_function
name|void
name|mips_gen_conditional_trap
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|rtx_code
name|cmp_code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|cmp_operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* MIPS conditional trap machine instructions don't have GT or LE      flavors, so we must invert the comparison and convert to LT and      GE, respectively.  */
switch|switch
condition|(
name|cmp_code
condition|)
block|{
case|case
name|GT
case|:
name|cmp_code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|cmp_code
operator|=
name|GE
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|cmp_code
operator|=
name|LTU
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|cmp_code
operator|=
name|GEU
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|cmp_code
operator|==
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|op0
operator|=
name|cmp_operands
index|[
literal|0
index|]
expr_stmt|;
name|op1
operator|=
name|cmp_operands
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|cmp_operands
index|[
literal|1
index|]
expr_stmt|;
name|op1
operator|=
name|cmp_operands
index|[
literal|0
index|]
expr_stmt|;
block|}
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arith_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_TRAP_IF
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|cmp_code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load function address ADDR into register DEST.  SIBCALL_P is true    if the address is needed for a sibling call.  */
end_comment

begin_function
specifier|static
name|void
name|mips_load_call_address
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|int
name|sibcall_p
parameter_list|)
block|{
comment|/* If we're generating PIC, and this call is to a global function,      try to allow its address to be resolved lazily.  This isn't      possible for NewABI sibcalls since the value of $gp on entry      to the stub would be our caller's gp, not ours.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
operator|!
operator|(
name|sibcall_p
operator|&&
name|TARGET_NEWABI
operator|)
operator|&&
name|global_got_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|rtx
name|high
decl_stmt|,
name|lo_sum_symbol
decl_stmt|;
name|high
operator|=
name|mips_unspec_offset_high
argument_list|(
name|dest
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|addr
argument_list|,
name|SYMBOL_GOTOFF_CALL
argument_list|)
expr_stmt|;
name|lo_sum_symbol
operator|=
name|mips_unspec_address
argument_list|(
name|addr
argument_list|,
name|SYMBOL_GOTOFF_CALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pmode
operator|==
name|SImode
condition|)
name|emit_insn
argument_list|(
name|gen_load_callsi
argument_list|(
name|dest
argument_list|,
name|high
argument_list|,
name|lo_sum_symbol
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_load_calldi
argument_list|(
name|dest
argument_list|,
name|high
argument_list|,
name|lo_sum_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a call or call_value instruction.  RESULT is where the    result will go (null for calls), ADDR is the address of the    function, ARGS_SIZE is the size of the arguments and AUX is    the value passed to us by mips_function_arg.  SIBCALL_P is true    if we are expanding a sibling call, false if we're expanding    a normal call.  */
end_comment

begin_function
name|void
name|mips_expand_call
parameter_list|(
name|rtx
name|result
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|rtx
name|args_size
parameter_list|,
name|rtx
name|aux
parameter_list|,
name|int
name|sibcall_p
parameter_list|)
block|{
name|rtx
name|orig_addr
decl_stmt|,
name|pattern
decl_stmt|,
name|insn
decl_stmt|;
name|orig_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|call_insn_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|addr
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|mips_load_call_address
argument_list|(
name|addr
argument_list|,
name|orig_addr
argument_list|,
name|sibcall_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|mips16_hard_float
operator|&&
name|build_mips16_call_stub
argument_list|(
name|result
argument_list|,
name|addr
argument_list|,
name|args_size
argument_list|,
name|aux
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|aux
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|pattern
operator|=
operator|(
name|sibcall_p
condition|?
name|gen_sibcall_internal
argument_list|(
name|addr
argument_list|,
name|args_size
argument_list|)
else|:
name|gen_call_internal
argument_list|(
name|addr
argument_list|,
name|args_size
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
condition|)
block|{
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
name|reg1
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pattern
operator|=
operator|(
name|sibcall_p
condition|?
name|gen_sibcall_value_multiple_internal
argument_list|(
name|reg1
argument_list|,
name|addr
argument_list|,
name|args_size
argument_list|,
name|reg2
argument_list|)
else|:
name|gen_call_value_multiple_internal
argument_list|(
name|reg1
argument_list|,
name|addr
argument_list|,
name|args_size
argument_list|,
name|reg2
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|pattern
operator|=
operator|(
name|sibcall_p
condition|?
name|gen_sibcall_value_internal
argument_list|(
name|result
argument_list|,
name|addr
argument_list|,
name|args_size
argument_list|)
else|:
name|gen_call_value_internal
argument_list|(
name|result
argument_list|,
name|addr
argument_list|,
name|args_size
argument_list|)
operator|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* Lazy-binding stubs require $gp to be valid on entry.  */
if|if
condition|(
name|global_got_operand
argument_list|(
name|orig_addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We can handle any sibcall when TARGET_SIBCALLS is true.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TARGET_SIBCALLS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to move general operand SRC into condition-code    register DEST.  SCRATCH is a scratch TFmode float register.    The sequence is:  	FP1 = SRC 	FP2 = 0.0f 	DEST = FP2< FP1     where FP1 and FP2 are single-precision float registers    taken from SCRATCH.  */
end_comment

begin_function
name|void
name|mips_emit_fcc_reload
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|fp1
decl_stmt|,
name|fp2
decl_stmt|;
comment|/* Change the source to SFmode.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|src
argument_list|)
condition|)
name|src
operator|=
name|adjust_address
argument_list|(
name|src
argument_list|,
name|SFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
condition|)
name|src
operator|=
name|gen_rtx_REG
argument_list|(
name|SFmode
argument_list|,
name|true_regnum
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|fp1
operator|=
name|gen_rtx_REG
argument_list|(
name|SFmode
argument_list|,
name|REGNO
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|fp2
operator|=
name|gen_rtx_REG
argument_list|(
name|SFmode
argument_list|,
name|REGNO
argument_list|(
name|scratch
argument_list|)
operator|+
name|FP_INC
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|fp1
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|fp2
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_slt_sf
argument_list|(
name|dest
argument_list|,
name|fp2
argument_list|,
name|fp1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code to change the current function's return address to    ADDRESS.  SCRATCH is available as a scratch register, if needed.    ADDRESS and SCRATCH are both word-mode GPRs.  */
end_comment

begin_function
name|void
name|mips_set_return_address
parameter_list|(
name|rtx
name|address
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|slot_address
decl_stmt|;
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|mask
operator|>>
literal|31
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|slot_address
operator|=
name|mips_add_offset
argument_list|(
name|scratch
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_sp_offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|address
argument_list|)
argument_list|,
name|slot_address
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit straight-line code to move LENGTH bytes from SRC to DEST.    Assume that the areas do not overlap.  */
end_comment

begin_function
specifier|static
name|void
name|mips_block_move_straight
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|HOST_WIDE_INT
name|length
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|delta
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|regs
decl_stmt|;
comment|/* Work out how many bits to move at a time.  If both operands have      half-word alignment, it is usually better to move in half words.      For instance, lh/lh/sh/sh is usually better than lwl/lwr/swl/swr      and lw/lw/sw/sw is usually better than ldl/ldr/sdl/sdr.      Otherwise move word-sized chunks.  */
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|src
argument_list|)
operator|==
name|BITS_PER_WORD
operator|/
literal|2
operator|&&
name|MEM_ALIGN
argument_list|(
name|dest
argument_list|)
operator|==
name|BITS_PER_WORD
operator|/
literal|2
condition|)
name|bits
operator|=
name|BITS_PER_WORD
operator|/
literal|2
expr_stmt|;
else|else
name|bits
operator|=
name|BITS_PER_WORD
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|bits
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta
operator|=
name|bits
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Allocate a buffer for the temporary registers.  */
name|regs
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
name|length
operator|/
name|delta
argument_list|)
expr_stmt|;
comment|/* Load as many BITS-sized chunks as possible.  Use a normal load if      the source has enough alignment, otherwise use left/right pairs.  */
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|offset
operator|+
name|delta
operator|<=
name|length
condition|;
name|offset
operator|+=
name|delta
operator|,
name|i
operator|++
control|)
block|{
name|regs
index|[
name|i
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|src
argument_list|)
operator|>=
name|bits
condition|)
name|emit_move_insn
argument_list|(
name|regs
index|[
name|i
index|]
argument_list|,
name|adjust_address
argument_list|(
name|src
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|part
init|=
name|adjust_address
argument_list|(
name|src
argument_list|,
name|BLKmode
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mips_expand_unaligned_load
argument_list|(
name|regs
index|[
name|i
index|]
argument_list|,
name|part
argument_list|,
name|bits
argument_list|,
literal|0
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Copy the chunks to the destination.  */
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|offset
operator|+
name|delta
operator|<=
name|length
condition|;
name|offset
operator|+=
name|delta
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|dest
argument_list|)
operator|>=
name|bits
condition|)
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|part
init|=
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|BLKmode
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mips_expand_unaligned_store
argument_list|(
name|part
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|,
name|bits
argument_list|,
literal|0
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Mop up any left-over bytes.  */
if|if
condition|(
name|offset
operator|<
name|length
condition|)
block|{
name|src
operator|=
name|adjust_address
argument_list|(
name|src
argument_list|,
name|BLKmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dest
operator|=
name|adjust_address
argument_list|(
name|dest
argument_list|,
name|BLKmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|move_by_pieces
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|length
operator|-
name|offset
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|src
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_MOVE_REGS
value|4
end_define

begin_define
define|#
directive|define
name|MAX_MOVE_BYTES
value|(MAX_MOVE_REGS * UNITS_PER_WORD)
end_define

begin_comment
comment|/* Helper function for doing a loop-based block operation on memory    reference MEM.  Each iteration of the loop will operate on LENGTH    bytes of MEM.     Create a new base register for use within the loop and point it to    the start of MEM.  Create a new memory reference that uses this    register.  Store them in *LOOP_REG and *LOOP_MEM respectively.  */
end_comment

begin_function
specifier|static
name|void
name|mips_adjust_block_mem
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|HOST_WIDE_INT
name|length
parameter_list|,
name|rtx
modifier|*
name|loop_reg
parameter_list|,
name|rtx
modifier|*
name|loop_mem
parameter_list|)
block|{
operator|*
name|loop_reg
operator|=
name|copy_addr_to_reg
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Although the new mem does not refer to a known location,      it does keep up to LENGTH bytes of alignment.  */
operator|*
name|loop_mem
operator|=
name|change_address
argument_list|(
name|mem
argument_list|,
name|BLKmode
argument_list|,
operator|*
name|loop_reg
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
operator|*
name|loop_mem
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|mem
argument_list|)
argument_list|,
name|length
operator|*
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move LENGTH bytes from SRC to DEST using a loop that moves MAX_MOVE_BYTES    per iteration.  LENGTH must be at least MAX_MOVE_BYTES.  Assume that the    memory regions do not overlap.  */
end_comment

begin_function
specifier|static
name|void
name|mips_block_move_loop
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|HOST_WIDE_INT
name|length
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|,
name|src_reg
decl_stmt|,
name|dest_reg
decl_stmt|,
name|final_src
decl_stmt|;
name|HOST_WIDE_INT
name|leftover
decl_stmt|;
name|leftover
operator|=
name|length
operator|%
name|MAX_MOVE_BYTES
expr_stmt|;
name|length
operator|-=
name|leftover
expr_stmt|;
comment|/* Create registers and memory references for use within the loop.  */
name|mips_adjust_block_mem
argument_list|(
name|src
argument_list|,
name|MAX_MOVE_BYTES
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|mips_adjust_block_mem
argument_list|(
name|dest
argument_list|,
name|MAX_MOVE_BYTES
argument_list|,
operator|&
name|dest_reg
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
comment|/* Calculate the value that SRC_REG should have after the last iteration      of the loop.  */
name|final_src
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|src_reg
argument_list|,
name|GEN_INT
argument_list|(
name|length
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Emit the start of the loop.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* Emit the loop body.  */
name|mips_block_move_straight
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|MAX_MOVE_BYTES
argument_list|)
expr_stmt|;
comment|/* Move on to the next block.  */
name|emit_move_insn
argument_list|(
name|src_reg
argument_list|,
name|plus_constant
argument_list|(
name|src_reg
argument_list|,
name|MAX_MOVE_BYTES
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest_reg
argument_list|,
name|plus_constant
argument_list|(
name|dest_reg
argument_list|,
name|MAX_MOVE_BYTES
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit the loop condition.  */
if|if
condition|(
name|Pmode
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_cmpdi
argument_list|(
name|src_reg
argument_list|,
name|final_src
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_cmpsi
argument_list|(
name|src_reg
argument_list|,
name|final_src
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bne
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mop up any left-over bytes.  */
if|if
condition|(
name|leftover
condition|)
name|mips_block_move_straight
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|leftover
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a movmemsi instruction.  */
end_comment

begin_function
name|bool
name|mips_expand_block_move
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|length
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|length
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|length
argument_list|)
operator|<=
literal|2
operator|*
name|MAX_MOVE_BYTES
condition|)
block|{
name|mips_block_move_straight
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|INTVAL
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|optimize
condition|)
block|{
name|mips_block_move_loop
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|INTVAL
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Initialize CUMULATIVE_ARGS for a function.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cum
decl_stmt|;
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
operator|*
name|cum
operator|=
name|zero_cum
expr_stmt|;
name|cum
operator|->
name|prototype
operator|=
operator|(
name|fntype
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
expr_stmt|;
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  The standard MIPS calling sequence      passes all arguments in the general purpose registers in this case.  */
for|for
control|(
name|param
operator|=
name|fntype
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
name|cum
operator|->
name|gp_reg_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill INFO with information about a single argument.  CUM is the    cumulative state for earlier arguments.  MODE is the mode of this    argument and TYPE is its type (if known).  NAMED is true if this    is a named (fixed) argument rather than a variable one.  */
end_comment

begin_function
specifier|static
name|void
name|mips_arg_info
parameter_list|(
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|,
name|struct
name|mips_arg_info
modifier|*
name|info
parameter_list|)
block|{
name|bool
name|doubleword_aligned_p
decl_stmt|;
name|unsigned
name|int
name|num_bytes
decl_stmt|,
name|num_words
decl_stmt|,
name|max_regs
decl_stmt|;
comment|/* Work out the size of the argument.  */
name|num_bytes
operator|=
name|type
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|num_words
operator|=
operator|(
name|num_bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Decide whether it should go in a floating-point register, assuming      one is free.  Later code checks for availability.       The checks against UNITS_PER_FPVALUE handle the soft-float and      single-float cases.  */
switch|switch
condition|(
name|mips_abi
condition|)
block|{
case|case
name|ABI_EABI
case|:
comment|/* The EABI conventions have traditionally been defined in terms 	 of TYPE_MODE, regardless of the actual type.  */
name|info
operator|->
name|fpr_p
operator|=
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_FPVALUE
operator|)
expr_stmt|;
break|break;
case|case
name|ABI_32
case|:
case|case
name|ABI_O64
case|:
comment|/* Only leading floating-point scalars are passed in 	 floating-point registers.  We also handle vector floats the same 	 say, which is OK because they are not covered by the standard ABI.  */
name|info
operator|->
name|fpr_p
operator|=
operator|(
operator|!
name|cum
operator|->
name|gp_reg_found
operator|&&
name|cum
operator|->
name|arg_number
operator|<
literal|2
operator|&&
operator|(
name|type
operator|==
literal|0
operator|||
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|VECTOR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_FPVALUE
operator|)
expr_stmt|;
break|break;
case|case
name|ABI_N32
case|:
case|case
name|ABI_64
case|:
comment|/* Scalar and complex floating-point types are passed in 	 floating-point registers.  */
name|info
operator|->
name|fpr_p
operator|=
operator|(
name|named
operator|&&
operator|(
name|type
operator|==
literal|0
operator|||
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_FPVALUE
operator|)
expr_stmt|;
comment|/* ??? According to the ABI documentation, the real and imaginary 	 parts of complex floats should be passed in individual registers. 	 The real and imaginary parts of stack arguments are supposed 	 to be contiguous and there should be an extra word of padding 	 at the end.  	 This has two problems.  First, it makes it impossible to use a 	 single "void *" va_list type, since register and stack arguments 	 are passed differently.  (At the time of writing, MIPSpro cannot 	 handle complex float varargs correctly.)  Second, it's unclear 	 what should happen when there is only one register free.  	 For now, we assume that named complex floats should go into FPRs 	 if there are two FPRs free, otherwise they should be passed in the 	 same way as a struct containing two floats.  */
if|if
condition|(
name|info
operator|->
name|fpr_p
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_FPVALUE
condition|)
block|{
if|if
condition|(
name|cum
operator|->
name|num_gprs
operator|>=
name|MAX_ARGS_IN_REGISTERS
operator|-
literal|1
condition|)
name|info
operator|->
name|fpr_p
operator|=
name|false
expr_stmt|;
else|else
name|num_words
operator|=
literal|2
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* See whether the argument has doubleword alignment.  */
name|doubleword_aligned_p
operator|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|>
name|BITS_PER_WORD
expr_stmt|;
comment|/* Set REG_OFFSET to the register count we're interested in.      The EABI allocates the floating-point registers separately,      but the other ABIs allocate them like integer registers.  */
name|info
operator|->
name|reg_offset
operator|=
operator|(
name|mips_abi
operator|==
name|ABI_EABI
operator|&&
name|info
operator|->
name|fpr_p
condition|?
name|cum
operator|->
name|num_fprs
else|:
name|cum
operator|->
name|num_gprs
operator|)
expr_stmt|;
comment|/* Advance to an even register if the argument is doubleword-aligned.  */
if|if
condition|(
name|doubleword_aligned_p
condition|)
name|info
operator|->
name|reg_offset
operator|+=
name|info
operator|->
name|reg_offset
operator|&
literal|1
expr_stmt|;
comment|/* Work out the offset of a stack argument.  */
name|info
operator|->
name|stack_offset
operator|=
name|cum
operator|->
name|stack_words
expr_stmt|;
if|if
condition|(
name|doubleword_aligned_p
condition|)
name|info
operator|->
name|stack_offset
operator|+=
name|info
operator|->
name|stack_offset
operator|&
literal|1
expr_stmt|;
name|max_regs
operator|=
name|MAX_ARGS_IN_REGISTERS
operator|-
name|info
operator|->
name|reg_offset
expr_stmt|;
comment|/* Partition the argument between registers and stack.  */
name|info
operator|->
name|reg_words
operator|=
name|MIN
argument_list|(
name|num_words
argument_list|,
name|max_regs
argument_list|)
expr_stmt|;
name|info
operator|->
name|stack_words
operator|=
name|num_words
operator|-
name|info
operator|->
name|reg_words
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement FUNCTION_ARG_ADVANCE.  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|struct
name|mips_arg_info
name|info
decl_stmt|;
name|mips_arg_info
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|.
name|fpr_p
condition|)
name|cum
operator|->
name|gp_reg_found
operator|=
name|true
expr_stmt|;
comment|/* See the comment above the cumulative args structure in mips.h      for an explanation of what this code does.  It assumes the O32      ABI, which passes at most 2 arguments in float registers.  */
if|if
condition|(
name|cum
operator|->
name|arg_number
operator|<
literal|2
operator|&&
name|info
operator|.
name|fpr_p
condition|)
name|cum
operator|->
name|fp_code
operator|+=
operator|(
name|mode
operator|==
name|SFmode
condition|?
literal|1
else|:
literal|2
operator|)
operator|<<
operator|(
operator|(
name|cum
operator|->
name|arg_number
operator|-
literal|1
operator|)
operator|*
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|mips_abi
operator|!=
name|ABI_EABI
operator|||
operator|!
name|info
operator|.
name|fpr_p
condition|)
name|cum
operator|->
name|num_gprs
operator|=
name|info
operator|.
name|reg_offset
operator|+
name|info
operator|.
name|reg_words
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|reg_words
operator|>
literal|0
condition|)
name|cum
operator|->
name|num_fprs
operator|+=
name|FP_INC
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|stack_words
operator|>
literal|0
condition|)
name|cum
operator|->
name|stack_words
operator|=
name|info
operator|.
name|stack_offset
operator|+
name|info
operator|.
name|stack_words
expr_stmt|;
name|cum
operator|->
name|arg_number
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement FUNCTION_ARG.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|function_arg
parameter_list|(
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|struct
name|mips_arg_info
name|info
decl_stmt|;
comment|/* We will be called with a mode of VOIDmode after the last argument      has been seen.  Whatever we return will be passed to the call      insn.  If we need a mips16 fp_code, return a REG with the code      stored as the mode.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|cum
operator|->
name|fp_code
operator|!=
literal|0
condition|)
return|return
name|gen_rtx_REG
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
name|cum
operator|->
name|fp_code
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
name|mips_arg_info
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Return straight away if the whole argument is passed on the stack.  */
if|if
condition|(
name|info
operator|.
name|reg_offset
operator|==
name|MAX_ARGS_IN_REGISTERS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TARGET_NEWABI
operator|&&
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|named
condition|)
block|{
comment|/* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the 	 structure contains a double in its entirety, then that 64 bit 	 chunk is passed in a floating point register.  */
name|tree
name|field
decl_stmt|;
comment|/* First check to see if there is any such field.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|BITS_PER_WORD
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|field
operator|!=
literal|0
condition|)
block|{
comment|/* Now handle the special case by returning a PARALLEL 	     indicating where each 64 bit chunk goes.  INFO.REG_WORDS 	     chunks are passed in registers.  */
name|unsigned
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
comment|/* assign_parms checks the mode of ENTRY_PARM, so we must 	     use the actual mode here.  */
name|ret
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|info
operator|.
name|reg_words
argument_list|)
argument_list|)
expr_stmt|;
name|bitpos
operator|=
literal|0
expr_stmt|;
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|.
name|reg_words
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
decl_stmt|;
for|for
control|(
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|>=
name|bitpos
condition|)
break|break;
if|if
condition|(
name|field
operator|&&
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|==
name|bitpos
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|!
name|TARGET_SOFT_FLOAT
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|BITS_PER_WORD
condition|)
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|FP_ARG_FIRST
operator|+
name|info
operator|.
name|reg_offset
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|GP_ARG_FIRST
operator|+
name|info
operator|.
name|reg_offset
operator|+
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|bitpos
operator|+=
name|BITS_PER_WORD
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
comment|/* Handle the n32/n64 conventions for passing complex floating-point      arguments in FPR pairs.  The real part goes in the lower register      and the imaginary part goes in the upper register.  */
if|if
condition|(
name|TARGET_NEWABI
operator|&&
name|info
operator|.
name|fpr_p
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
block|{
name|rtx
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|enum
name|machine_mode
name|inner
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|inner
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FP_ARG_FIRST
operator|+
name|info
operator|.
name|reg_offset
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|reg_words
operator|*
name|UNITS_PER_WORD
operator|==
name|GET_MODE_SIZE
argument_list|(
name|inner
argument_list|)
condition|)
block|{
comment|/* Real part in registers, imaginary part on stack.  */
name|gcc_assert
argument_list|(
name|info
operator|.
name|stack_words
operator|==
name|info
operator|.
name|reg_words
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|inner
argument_list|,
name|reg
argument_list|)
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|info
operator|.
name|stack_words
operator|==
literal|0
argument_list|)
expr_stmt|;
name|real
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner
argument_list|,
name|reg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|imag
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner
argument_list|,
name|reg
operator|+
name|info
operator|.
name|reg_words
operator|/
literal|2
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|real
argument_list|,
name|imag
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|info
operator|.
name|fpr_p
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_ARG_FIRST
operator|+
name|info
operator|.
name|reg_offset
argument_list|)
return|;
elseif|else
if|if
condition|(
name|info
operator|.
name|reg_offset
operator|==
literal|1
condition|)
comment|/* This code handles the special o32 case in which the second word        of the argument structure is passed in floating-point registers.  */
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FP_ARG_FIRST
operator|+
name|FP_INC
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FP_ARG_FIRST
operator|+
name|info
operator|.
name|reg_offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_ARG_PARTIAL_BYTES.  */
end_comment

begin_function
specifier|static
name|int
name|mips_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
parameter_list|)
block|{
name|struct
name|mips_arg_info
name|info
decl_stmt|;
name|mips_arg_info
argument_list|(
name|cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
name|named
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
return|return
name|info
operator|.
name|stack_words
operator|>
literal|0
condition|?
name|info
operator|.
name|reg_words
operator|*
name|UNITS_PER_WORD
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implement FUNCTION_ARG_BOUNDARY.  Every parameter gets at least    PARM_BOUNDARY bits of alignment, but will be given anything up    to STACK_BOUNDARY bits if the type requires it.  */
end_comment

begin_function
name|int
name|function_arg_boundary
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|alignment
decl_stmt|;
name|alignment
operator|=
name|type
condition|?
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|<
name|PARM_BOUNDARY
condition|)
name|alignment
operator|=
name|PARM_BOUNDARY
expr_stmt|;
if|if
condition|(
name|alignment
operator|>
name|STACK_BOUNDARY
condition|)
name|alignment
operator|=
name|STACK_BOUNDARY
expr_stmt|;
return|return
name|alignment
return|;
block|}
end_function

begin_comment
comment|/* Return true if FUNCTION_ARG_PADDING (MODE, TYPE) should return    upward rather than downward.  In other words, return true if the    first byte of the stack slot has useful data, false if the last    byte does.  */
end_comment

begin_function
name|bool
name|mips_pad_arg_upward
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* On little-endian targets, the first byte of every stack argument      is passed in the first byte of the stack slot.  */
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
return|return
name|true
return|;
comment|/* Otherwise, integral types are padded downward: the last byte of a      stack argument is passed in the last byte of the stack slot.  */
if|if
condition|(
name|type
operator|!=
literal|0
condition|?
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
return|return
name|false
return|;
comment|/* Big-endian o64 pads floating-point arguments downward.  */
if|if
condition|(
name|mips_abi
operator|==
name|ABI_O64
condition|)
if|if
condition|(
name|type
operator|!=
literal|0
condition|?
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
name|false
return|;
comment|/* Other types are padded upward for o32, o64, n32 and n64.  */
if|if
condition|(
name|mips_abi
operator|!=
name|ABI_EABI
condition|)
return|return
name|true
return|;
comment|/* Arguments smaller than a stack slot are padded downward.  */
if|if
condition|(
name|mode
operator|!=
name|BLKmode
condition|)
return|return
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|PARM_BOUNDARY
operator|)
return|;
else|else
return|return
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>=
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Likewise BLOCK_REG_PADDING (MODE, TYPE, ...).  Return !BYTES_BIG_ENDIAN    if the least significant byte of the register has useful data.  Return    the opposite if the most significant byte does.  */
end_comment

begin_function
name|bool
name|mips_pad_reg_upward
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* No shifting is required for floating-point arguments.  */
if|if
condition|(
name|type
operator|!=
literal|0
condition|?
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|!
name|BYTES_BIG_ENDIAN
return|;
comment|/* Otherwise, apply the same padding to register arguments as we do      to stack arguments.  */
return|return
name|mips_pad_arg_upward
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|mips_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|no_rtl
parameter_list|)
block|{
name|CUMULATIVE_ARGS
name|local_cum
decl_stmt|;
name|int
name|gp_saved
decl_stmt|,
name|fp_saved
decl_stmt|;
comment|/* The caller has advanced CUM up to, but not beyond, the last named      argument.  Advance a local copy of CUM past the last "real" named      argument, to find out how many registers are left over.  */
name|local_cum
operator|=
operator|*
name|cum
expr_stmt|;
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|local_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Found out how many registers we need to save.  */
name|gp_saved
operator|=
name|MAX_ARGS_IN_REGISTERS
operator|-
name|local_cum
operator|.
name|num_gprs
expr_stmt|;
name|fp_saved
operator|=
operator|(
name|EABI_FLOAT_VARARGS_P
condition|?
name|MAX_ARGS_IN_REGISTERS
operator|-
name|local_cum
operator|.
name|num_fprs
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
condition|)
block|{
if|if
condition|(
name|gp_saved
operator|>
literal|0
condition|)
block|{
name|rtx
name|ptr
decl_stmt|,
name|mem
decl_stmt|;
name|ptr
operator|=
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|REG_PARM_STACK_SPACE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|-
name|gp_saved
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|move_block_from_reg
argument_list|(
name|local_cum
operator|.
name|num_gprs
operator|+
name|GP_ARG_FIRST
argument_list|,
name|mem
argument_list|,
name|gp_saved
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp_saved
operator|>
literal|0
condition|)
block|{
comment|/* We can't use move_block_from_reg, because it will use 	     the wrong mode.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|off
decl_stmt|,
name|i
decl_stmt|;
comment|/* Set OFF to the offset from virtual_incoming_args_rtx of 	     the first float register.  The FP save area lies below 	     the integer one, and is aligned to UNITS_PER_FPVALUE bytes.  */
name|off
operator|=
operator|-
name|gp_saved
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|off
operator|&=
operator|~
operator|(
name|UNITS_PER_FPVALUE
operator|-
literal|1
operator|)
expr_stmt|;
name|off
operator|-=
name|fp_saved
operator|*
name|UNITS_PER_FPREG
expr_stmt|;
name|mode
operator|=
name|TARGET_SINGLE_FLOAT
condition|?
name|SFmode
else|:
name|DFmode
expr_stmt|;
for|for
control|(
name|i
operator|=
name|local_cum
operator|.
name|num_fprs
init|;
name|i
operator|<
name|MAX_ARGS_IN_REGISTERS
condition|;
name|i
operator|+=
name|FP_INC
control|)
block|{
name|rtx
name|ptr
decl_stmt|,
name|mem
decl_stmt|;
name|ptr
operator|=
name|plus_constant
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FP_ARG_FIRST
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|UNITS_PER_HWFPVALUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|REG_PARM_STACK_SPACE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|cfun
operator|->
name|machine
operator|->
name|varargs_size
operator|=
operator|(
name|gp_saved
operator|*
name|UNITS_PER_WORD
operator|+
name|fp_saved
operator|*
name|UNITS_PER_FPREG
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the va_list data type.    We keep 3 pointers, and two offsets.    Two pointers are to the overflow area, which starts at the CFA.      One of these is constant, for addressing into the GPR save area below it.      The other is advanced up the stack through the overflow region.    The third pointer is to the GPR save area.  Since the FPR save area      is just below it, we can address FPR slots off this pointer.    We also keep two one-byte offsets, which are to be subtracted from the      constant pointers to yield addresses in the GPR and FPR save areas.      These are downcounted as float or non-float arguments are used,      and when they get to zero, the argument must be obtained from the      overflow region.    If !EABI_FLOAT_VARARGS_P, then no FPR save area exists, and a single      pointer is enough.  It's started at the GPR save area, and is      advanced, period.    Note that the GPR save area is not constant size, due to optimization      in the prologue.  Hence, we can't use a design with two pointers      and two offsets, although we could have designed this with two pointers      and three offsets.  */
end_comment

begin_function
specifier|static
name|tree
name|mips_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|EABI_FLOAT_VARARGS_P
condition|)
block|{
name|tree
name|f_ovfl
decl_stmt|,
name|f_gtop
decl_stmt|,
name|f_ftop
decl_stmt|,
name|f_goff
decl_stmt|,
name|f_foff
decl_stmt|,
name|f_res
decl_stmt|,
name|record
decl_stmt|;
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
name|record
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|f_ovfl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__overflow_argptr"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_gtop
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__gpr_top"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_ftop
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__fpr_top"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_goff
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__gpr_offset"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|f_foff
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__fpr_offset"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* Explicitly pad to the size of a pointer, so that -Wpadded won't 	 warn on every user file.  */
name|index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|ptr_mode
argument_list|)
operator|-
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|array
operator|=
name|build_array_type
argument_list|(
name|unsigned_char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|f_res
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__reserved"
argument_list|)
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovfl
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gtop
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ftop
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_goff
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_foff
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_res
argument_list|)
operator|=
name|record
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_ovfl
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovfl
argument_list|)
operator|=
name|f_gtop
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gtop
argument_list|)
operator|=
name|f_ftop
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ftop
argument_list|)
operator|=
name|f_goff
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_goff
argument_list|)
operator|=
name|f_foff
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_foff
argument_list|)
operator|=
name|f_res
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
return|return
name|record
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_IRIX
operator|&&
name|TARGET_IRIX6
condition|)
comment|/* On IRIX 6, this type is 'char *'.  */
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
else|else
comment|/* Otherwise, we use 'void *'.  */
return|return
name|ptr_type_node
return|;
block|}
end_function

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|mips_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
if|if
condition|(
name|EABI_FLOAT_VARARGS_P
condition|)
block|{
specifier|const
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|tree
name|f_ovfl
decl_stmt|,
name|f_gtop
decl_stmt|,
name|f_ftop
decl_stmt|,
name|f_goff
decl_stmt|,
name|f_foff
decl_stmt|;
name|tree
name|ovfl
decl_stmt|,
name|gtop
decl_stmt|,
name|ftop
decl_stmt|,
name|goff
decl_stmt|,
name|foff
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|gpr_save_area_size
decl_stmt|;
name|int
name|fpr_save_area_size
decl_stmt|;
name|int
name|fpr_offset
decl_stmt|;
name|cum
operator|=
operator|&
name|current_function_args_info
expr_stmt|;
name|gpr_save_area_size
operator|=
operator|(
name|MAX_ARGS_IN_REGISTERS
operator|-
name|cum
operator|->
name|num_gprs
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|fpr_save_area_size
operator|=
operator|(
name|MAX_ARGS_IN_REGISTERS
operator|-
name|cum
operator|->
name|num_fprs
operator|)
operator|*
name|UNITS_PER_FPREG
expr_stmt|;
name|f_ovfl
operator|=
name|TYPE_FIELDS
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
name|f_gtop
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovfl
argument_list|)
expr_stmt|;
name|f_ftop
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gtop
argument_list|)
expr_stmt|;
name|f_goff
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ftop
argument_list|)
expr_stmt|;
name|f_foff
operator|=
name|TREE_CHAIN
argument_list|(
name|f_goff
argument_list|)
expr_stmt|;
name|ovfl
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovfl
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovfl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gtop
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gtop
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gtop
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ftop
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ftop
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ftop
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|goff
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_goff
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_goff
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|foff
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_foff
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_foff
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Emit code to initialize OVFL, which points to the next varargs 	 stack argument.  CUM->STACK_WORDS gives the number of stack 	 words used by named arguments.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|stack_words
operator|>
literal|0
condition|)
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|cum
operator|->
name|stack_words
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|ovfl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Emit code to initialize GTOP, the top of the GPR save area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|gtop
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gtop
argument_list|)
argument_list|,
name|gtop
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Emit code to initialize FTOP, the top of the FPR save area. 	 This address is gpr_save_area_bytes below GTOP, rounded 	 down to the next fp-aligned boundary.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ftop
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
name|fpr_offset
operator|=
name|gpr_save_area_size
operator|+
name|UNITS_PER_FPVALUE
operator|-
literal|1
expr_stmt|;
name|fpr_offset
operator|&=
operator|~
operator|(
name|UNITS_PER_FPVALUE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fpr_offset
condition|)
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ftop
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
name|fpr_offset
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ftop
argument_list|)
argument_list|,
name|ftop
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Emit code to initialize GOFF, the offset from GTOP of the 	 next GPR argument.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|goff
argument_list|)
argument_list|,
name|goff
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|gpr_save_area_size
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Likewise emit code to initialize FOFF, the offset from FTOP 	 of the next FPR argument.  */
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|foff
argument_list|)
argument_list|,
name|foff
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|fpr_save_area_size
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextarg
operator|=
name|plus_constant
argument_list|(
name|nextarg
argument_list|,
operator|-
name|cfun
operator|->
name|machine
operator|->
name|varargs_size
argument_list|)
expr_stmt|;
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
specifier|static
name|tree
name|mips_gimplify_va_arg_expr
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|rsize
decl_stmt|;
name|tree
name|addr
decl_stmt|;
name|bool
name|indirect
decl_stmt|;
name|indirect
operator|=
name|pass_by_reference
argument_list|(
name|NULL
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|&
operator|-
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|mips_abi
operator|!=
name|ABI_EABI
operator|||
operator|!
name|EABI_FLOAT_VARARGS_P
condition|)
name|addr
operator|=
name|std_gimplify_va_arg_expr
argument_list|(
name|valist
argument_list|,
name|type
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Not a simple merged stack.	 */
name|tree
name|f_ovfl
decl_stmt|,
name|f_gtop
decl_stmt|,
name|f_ftop
decl_stmt|,
name|f_goff
decl_stmt|,
name|f_foff
decl_stmt|;
name|tree
name|ovfl
decl_stmt|,
name|top
decl_stmt|,
name|off
decl_stmt|,
name|align
decl_stmt|;
name|HOST_WIDE_INT
name|osize
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|u
decl_stmt|;
name|f_ovfl
operator|=
name|TYPE_FIELDS
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
name|f_gtop
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovfl
argument_list|)
expr_stmt|;
name|f_ftop
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gtop
argument_list|)
expr_stmt|;
name|f_goff
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ftop
argument_list|)
expr_stmt|;
name|f_foff
operator|=
name|TREE_CHAIN
argument_list|(
name|f_goff
argument_list|)
expr_stmt|;
comment|/* We maintain separate pointers and offsets for floating-point 	 and integer arguments, but we need similar code in both cases. 	 Let:  	 TOP be the top of the register save area; 	 OFF be the offset from TOP of the next register; 	 ADDR_RTX be the address of the argument; 	 RSIZE be the number of bytes used to store the argument 	 when it's in the register save area; 	 OSIZE be the number of bytes used to store it when it's 	 in the stack overflow area; and 	 PADDING be (BYTES_BIG_ENDIAN ? OSIZE - RSIZE : 0)  	 The code we want is:  	 1: off&= -rsize;	  // round down 	 2: if (off != 0) 	 3:   { 	 4:	 addr_rtx = top - off; 	 5:	 off -= rsize; 	 6:   } 	 7: else 	 8:   { 	 9:	 ovfl += ((intptr_t) ovfl + osize - 1)& -osize; 	 10:	 addr_rtx = ovfl + PADDING; 	 11:	 ovfl += osize; 	 14:   }  	 [1] and [9] can sometimes be optimized away.  */
name|ovfl
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovfl
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovfl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_FPVALUE
condition|)
block|{
name|top
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ftop
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ftop
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|off
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_foff
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_foff
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* When floating-point registers are saved to the stack, 	     each one will take up UNITS_PER_HWFPVALUE bytes, regardless 	     of the float's precision.  */
name|rsize
operator|=
name|UNITS_PER_HWFPVALUE
expr_stmt|;
comment|/* Overflow arguments are padded to UNITS_PER_WORD bytes 	     (= PARM_BOUNDARY bits).  This can be different from RSIZE 	     in two cases:  	     (1) On 32-bit targets when TYPE is a structure such as:  	     struct s { float f; };  	     Such structures are passed in paired FPRs, so RSIZE 	     will be 8 bytes.  However, the structure only takes 	     up 4 bytes of memory, so OSIZE will only be 4.  	     (2) In combinations such as -mgp64 -msingle-float 	     -fshort-double.  Doubles passed in registers 	     will then take up 4 (UNITS_PER_HWFPVALUE) bytes, 	     but those passed on the stack take up 	     UNITS_PER_WORD bytes.  */
name|osize
operator|=
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gtop
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gtop
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|off
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_goff
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_goff
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
name|UNITS_PER_WORD
condition|)
block|{
comment|/* [1] Emit code for: off&= -rsize.	*/
name|t
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|off
argument_list|)
argument_list|,
name|off
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
name|rsize
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|off
argument_list|)
argument_list|,
name|off
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
name|osize
operator|=
name|rsize
expr_stmt|;
block|}
comment|/* [2] Emit code to branch if off == 0.  */
name|t
operator|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|off
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|off
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* [5] Emit code for: off -= rsize.  We do this as a form of 	 post-increment not available to C.  Also widen for the 	 coming pointer arithmetic.  */
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|off
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|rsize
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|POSTDECREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|off
argument_list|)
argument_list|,
name|off
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|top
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* [4] Emit code for: addr_rtx = top - off.  On big endian machines, 	 the argument has RSIZE - SIZE bytes of leading padding.  */
name|t
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|top
argument_list|)
argument_list|,
name|top
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|rsize
operator|>
name|size
condition|)
block|{
name|u
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|rsize
operator|-
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|COND_EXPR_THEN
argument_list|(
name|addr
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|osize
operator|>
name|UNITS_PER_WORD
condition|)
block|{
comment|/* [9] Emit: ovfl += ((intptr_t) ovfl + osize - 1)& -osize.  */
name|u
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|osize
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|ovfl
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
name|osize
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|align
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|ovfl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|align
operator|=
name|NULL
expr_stmt|;
comment|/* [10, 11].	Emit code to store ovfl in addr_rtx, then 	 post-increment ovfl by osize.  On big-endian machines, 	 the argument has OSIZE - SIZE bytes of leading padding.  */
name|u
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|osize
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovfl
argument_list|)
argument_list|,
name|ovfl
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|osize
operator|>
name|size
condition|)
block|{
name|u
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|osize
operator|-
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
comment|/* String [9] and [10,11] together.  */
if|if
condition|(
name|align
condition|)
name|t
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|align
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|COND_EXPR_ELSE
argument_list|(
name|addr
argument_list|)
operator|=
name|t
expr_stmt|;
name|addr
operator|=
name|fold_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirect
condition|)
name|addr
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if it is possible to use left/right accesses for a    bitfield of WIDTH bits starting BITPOS bits into *OP.  When    returning true, update *OP, *LEFT and *RIGHT as follows:     *OP is a BLKmode reference to the whole field.     *LEFT is a QImode reference to the first byte if big endian or    the last byte if little endian.  This address can be used in the    left-side instructions (lwl, swl, ldl, sdl).     *RIGHT is a QImode reference to the opposite end of the field and    can be used in the patterning right-side instruction.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_get_unaligned_mem
parameter_list|(
name|rtx
modifier|*
name|op
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|int
name|bitpos
parameter_list|,
name|rtx
modifier|*
name|left
parameter_list|,
name|rtx
modifier|*
name|right
parameter_list|)
block|{
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
comment|/* Check that the operand really is a MEM.  Not all the extv and      extzv predicates are checked.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
operator|*
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Check that the size is valid.  */
if|if
condition|(
name|width
operator|!=
literal|32
operator|&&
operator|(
operator|!
name|TARGET_64BIT
operator|||
name|width
operator|!=
literal|64
operator|)
condition|)
return|return
name|false
return|;
comment|/* We can only access byte-aligned values.  Since we are always passed      a reference to the first byte of the field, it is not necessary to      do anything with BITPOS after this check.  */
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Reject aligned bitfields: we want to use a normal load or store      instead of a left/right pair.  */
if|if
condition|(
name|MEM_ALIGN
argument_list|(
operator|*
name|op
argument_list|)
operator|>=
name|width
condition|)
return|return
name|false
return|;
comment|/* Adjust *OP to refer to the whole field.  This also has the effect      of legitimizing *OP's address for BLKmode, possibly simplifying it.  */
operator|*
name|op
operator|=
name|adjust_address
argument_list|(
operator|*
name|op
argument_list|,
name|BLKmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_mem_size
argument_list|(
operator|*
name|op
argument_list|,
name|GEN_INT
argument_list|(
name|width
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get references to both ends of the field.  We deliberately don't      use the original QImode *OP for FIRST since the new BLKmode one      might have a simpler address.  */
name|first
operator|=
name|adjust_address
argument_list|(
operator|*
name|op
argument_list|,
name|QImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|adjust_address
argument_list|(
operator|*
name|op
argument_list|,
name|QImode
argument_list|,
name|width
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate to LEFT and RIGHT according to endianness.  LEFT should      be the upper word and RIGHT the lower word.  */
if|if
condition|(
name|TARGET_BIG_ENDIAN
condition|)
operator|*
name|left
operator|=
name|first
operator|,
operator|*
name|right
operator|=
name|last
expr_stmt|;
else|else
operator|*
name|left
operator|=
name|last
operator|,
operator|*
name|right
operator|=
name|first
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Try to emit the equivalent of (set DEST (zero_extract SRC WIDTH BITPOS)).    Return true on success.  We only handle cases where zero_extract is    equivalent to sign_extract.  */
end_comment

begin_function
name|bool
name|mips_expand_unaligned_load
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|int
name|bitpos
parameter_list|)
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If TARGET_64BIT, the destination of a 32-bit load will be a      paradoxical word_mode subreg.  This is the only case in which      we allow the destination to be larger than the source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|DImode
operator|&&
name|SUBREG_BYTE
argument_list|(
name|dest
argument_list|)
operator|==
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|SImode
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* After the above adjustment, the destination must be the same      width as the source.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|width
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|mips_get_unaligned_mem
argument_list|(
operator|&
name|src
argument_list|,
name|width
argument_list|,
name|bitpos
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|)
condition|)
return|return
name|false
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_mov_ldl
argument_list|(
name|temp
argument_list|,
name|src
argument_list|,
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mov_ldr
argument_list|(
name|dest
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|,
name|right
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_mov_lwl
argument_list|(
name|temp
argument_list|,
name|src
argument_list|,
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mov_lwr
argument_list|(
name|dest
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|,
name|right
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Try to expand (set (zero_extract DEST WIDTH BITPOS) SRC).  Return    true on success.  */
end_comment

begin_function
name|bool
name|mips_expand_unaligned_store
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|int
name|bitpos
parameter_list|)
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|mips_get_unaligned_mem
argument_list|(
operator|&
name|dest
argument_list|,
name|width
argument_list|,
name|bitpos
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|)
condition|)
return|return
name|false
return|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|width
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_mov_sdl
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mov_sdr
argument_list|(
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_mov_swl
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mov_swr
argument_list|(
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is a MEM with the same size as MODE.  */
end_comment

begin_function
name|bool
name|mips_mem_fits_mode_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
name|size
operator|=
name|MEM_SIZE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|size
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if (zero_extract OP SIZE POSITION) can be used as the    source of an "ext" instruction or the destination of an "ins"    instruction.  OP must be a register operand and the following    conditions must hold:       0<= POSITION< GET_MODE_BITSIZE (GET_MODE (op))      0< SIZE<= GET_MODE_BITSIZE (GET_MODE (op))      0< POSITION + SIZE<= GET_MODE_BITSIZE (GET_MODE (op))     Also reject lengths equal to a word as they are better handled    by the move patterns.  */
end_comment

begin_function
name|bool
name|mips_use_ins_ext_p
parameter_list|(
name|rtx
name|op
parameter_list|,
name|rtx
name|size
parameter_list|,
name|rtx
name|position
parameter_list|)
block|{
name|HOST_WIDE_INT
name|len
decl_stmt|,
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|ISA_HAS_EXT_INS
operator|||
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
return|return
name|false
return|;
name|len
operator|=
name|INTVAL
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|pos
operator|=
name|INTVAL
argument_list|(
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|pos
operator|<
literal|0
operator|||
name|pos
operator|+
name|len
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set up globals to generate code for the ISA or processor    described by INFO.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_architecture
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|!=
literal|0
condition|)
block|{
name|mips_arch_info
operator|=
name|info
expr_stmt|;
name|mips_arch
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
name|mips_isa
operator|=
name|info
operator|->
name|isa
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise for tuning.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_tune
parameter_list|(
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|!=
literal|0
condition|)
block|{
name|mips_tune_info
operator|=
name|info
expr_stmt|;
name|mips_tune
operator|=
name|info
operator|->
name|cpu
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement TARGET_HANDLE_OPTION.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_handle_option
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT_mabi_
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|ABI_32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"o64"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|ABI_O64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"n32"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|ABI_N32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|ABI_64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"eabi"
argument_list|)
operator|==
literal|0
condition|)
name|mips_abi
operator|=
name|ABI_EABI
expr_stmt|;
else|else
return|return
name|false
return|;
return|return
name|true
return|;
case|case
name|OPT_march_
case|:
case|case
name|OPT_mtune_
case|:
return|return
name|mips_parse_cpu
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
return|;
case|case
name|OPT_mips
case|:
name|mips_isa_info
operator|=
name|mips_parse_cpu
argument_list|(
name|ACONCAT
argument_list|(
operator|(
literal|"mips"
operator|,
name|arg
operator|,
name|NULL
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mips_isa_info
operator|!=
literal|0
return|;
case|case
name|OPT_mno_flush_func
case|:
name|mips_cache_flush_func
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set up the threshold for data to go into the small data area, instead    of the normal data area, and detect any conflicts in the switches.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mips_section_threshold
operator|=
name|g_switch_set
condition|?
name|g_switch_value
else|:
name|MIPS_DEFAULT_GVALUE
expr_stmt|;
comment|/* The following code determines the architecture and register size.      Similar code was added to GAS 2.14 (see tc-mips.c:md_after_parse_args()).      The GAS and GCC code should be kept in sync as much as possible.  */
if|if
condition|(
name|mips_arch_string
operator|!=
literal|0
condition|)
name|mips_set_architecture
argument_list|(
name|mips_parse_cpu
argument_list|(
name|mips_arch_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_isa_info
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mips_arch_info
operator|==
literal|0
condition|)
name|mips_set_architecture
argument_list|(
name|mips_isa_info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mips_arch_info
operator|->
name|isa
operator|!=
name|mips_isa_info
operator|->
name|isa
condition|)
name|error
argument_list|(
literal|"-%s conflicts with the other architecture options, "
literal|"which specify a %s processor"
argument_list|,
name|mips_isa_info
operator|->
name|name
argument_list|,
name|mips_cpu_info_from_isa
argument_list|(
name|mips_arch_info
operator|->
name|isa
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_arch_info
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MIPS_CPU_STRING_DEFAULT
name|mips_set_architecture
argument_list|(
name|mips_parse_cpu
argument_list|(
name|MIPS_CPU_STRING_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|mips_set_architecture
argument_list|(
name|mips_cpu_info_from_isa
argument_list|(
name|MIPS_ISA_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|ABI_NEEDS_64BIT_REGS
operator|&&
operator|!
name|ISA_HAS_64BIT_REGS
condition|)
name|error
argument_list|(
literal|"-march=%s is not compatible with the selected ABI"
argument_list|,
name|mips_arch_info
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Optimize for mips_arch, unless -mtune selects a different processor.  */
if|if
condition|(
name|mips_tune_string
operator|!=
literal|0
condition|)
name|mips_set_tune
argument_list|(
name|mips_parse_cpu
argument_list|(
name|mips_tune_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_tune_info
operator|==
literal|0
condition|)
name|mips_set_tune
argument_list|(
name|mips_arch_info
argument_list|)
expr_stmt|;
comment|/* Set cost structure for the processor.  */
name|mips_cost
operator|=
operator|&
name|mips_rtx_cost_data
index|[
name|mips_tune
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_64BIT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The user specified the size of the integer registers.  Make sure 	 it agrees with the ABI and ISA.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|ISA_HAS_64BIT_REGS
condition|)
name|error
argument_list|(
literal|"-mgp64 used with a 32-bit processor"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|ABI_NEEDS_64BIT_REGS
condition|)
name|error
argument_list|(
literal|"-mgp32 used with a 64-bit ABI"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|ABI_NEEDS_32BIT_REGS
condition|)
name|error
argument_list|(
literal|"-mgp64 used with a 32-bit ABI"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Infer the integer register size from the ABI and processor. 	 Restrict ourselves to 32-bit registers if that's all the 	 processor has, or if the ABI cannot handle 64-bit registers.  */
if|if
condition|(
name|ABI_NEEDS_32BIT_REGS
operator|||
operator|!
name|ISA_HAS_64BIT_REGS
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_64BIT
expr_stmt|;
else|else
name|target_flags
operator||=
name|MASK_64BIT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_FLOAT64
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Really, -mfp32 and -mfp64 are ornamental options.  There's 	 only one right answer here.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|TARGET_DOUBLE_FLOAT
operator|&&
operator|!
name|TARGET_FLOAT64
condition|)
name|error
argument_list|(
literal|"unsupported combination: %s"
argument_list|,
literal|"-mgp64 -mfp32 -mdouble-float"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|TARGET_FLOAT64
condition|)
name|error
argument_list|(
literal|"unsupported combination: %s"
argument_list|,
literal|"-mgp32 -mfp64"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_SINGLE_FLOAT
operator|&&
name|TARGET_FLOAT64
condition|)
name|error
argument_list|(
literal|"unsupported combination: %s"
argument_list|,
literal|"-mfp64 -msingle-float"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* -msingle-float selects 32-bit float registers.  Otherwise the 	 float registers should be the same size as the integer ones.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|TARGET_DOUBLE_FLOAT
condition|)
name|target_flags
operator||=
name|MASK_FLOAT64
expr_stmt|;
else|else
name|target_flags
operator|&=
operator|~
name|MASK_FLOAT64
expr_stmt|;
block|}
comment|/* End of code shared with GAS.  */
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_LONG64
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mips_abi
operator|==
name|ABI_EABI
operator|&&
name|TARGET_64BIT
operator|)
operator|||
name|mips_abi
operator|==
name|ABI_64
condition|)
name|target_flags
operator||=
name|MASK_LONG64
expr_stmt|;
else|else
name|target_flags
operator|&=
operator|~
name|MASK_LONG64
expr_stmt|;
block|}
if|if
condition|(
name|MIPS_MARCH_CONTROLS_SOFT_FLOAT
operator|&&
operator|(
name|target_flags_explicit
operator|&
name|MASK_SOFT_FLOAT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* For some configurations, it is useful to have -march control 	 the default setting of MASK_SOFT_FLOAT.  */
switch|switch
condition|(
operator|(
name|int
operator|)
name|mips_arch
condition|)
block|{
case|case
name|PROCESSOR_R4100
case|:
case|case
name|PROCESSOR_R4111
case|:
case|case
name|PROCESSOR_R4120
case|:
case|case
name|PROCESSOR_R4130
case|:
name|target_flags
operator||=
name|MASK_SOFT_FLOAT
expr_stmt|;
break|break;
default|default:
name|target_flags
operator|&=
operator|~
name|MASK_SOFT_FLOAT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|TARGET_OLDABI
condition|)
name|flag_pcc_struct_return
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_BRANCHLIKELY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If neither -mbranch-likely nor -mno-branch-likely was given 	 on the command line, set MASK_BRANCHLIKELY based on the target 	 architecture.  	 By default, we enable use of Branch Likely instructions on 	 all architectures which support them with the following 	 exceptions: when creating MIPS32 or MIPS64 code, and when 	 tuning for architectures where their use tends to hurt 	 performance.  	 The MIPS32 and MIPS64 architecture specifications say "Software 	 is strongly encouraged to avoid use of Branch Likely 	 instructions, as they will be removed from a future revision 	 of the [MIPS32 and MIPS64] architecture."  Therefore, we do not 	 issue those instructions unless instructed to do so by 	 -mbranch-likely.  */
if|if
condition|(
name|ISA_HAS_BRANCHLIKELY
operator|&&
operator|!
operator|(
name|ISA_MIPS32
operator|||
name|ISA_MIPS32R2
operator|||
name|ISA_MIPS64
operator|)
operator|&&
operator|!
operator|(
name|TUNE_MIPS5500
operator|||
name|TUNE_SB1
operator|)
condition|)
name|target_flags
operator||=
name|MASK_BRANCHLIKELY
expr_stmt|;
else|else
name|target_flags
operator|&=
operator|~
name|MASK_BRANCHLIKELY
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_BRANCHLIKELY
operator|&&
operator|!
name|ISA_HAS_BRANCHLIKELY
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"generation of Branch Likely instructions enabled, but not supported by architecture"
argument_list|)
expr_stmt|;
comment|/* The effect of -mabicalls isn't defined for the EABI.  */
if|if
condition|(
name|mips_abi
operator|==
name|ABI_EABI
operator|&&
name|TARGET_ABICALLS
condition|)
block|{
name|error
argument_list|(
literal|"unsupported combination: %s"
argument_list|,
literal|"-mabicalls -mabi=eabi"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_ABICALLS
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ABICALLS
condition|)
block|{
comment|/* We need to set flag_pic for executables as well as DSOs 	 because we may reference symbols that are not defined in 	 the final executable.  (MIPS does not use things like 	 copy relocs, for example.)  	 Also, there is a body of code that uses __PIC__ to distinguish 	 between -mabicalls and -mno-abicalls code.  */
name|flag_pic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_section_threshold
operator|>
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<-G%> is incompatible with %<-mabicalls%>"
argument_list|)
expr_stmt|;
block|}
comment|/* mips_split_addresses is a half-way house between explicit      relocations and the traditional assembler macros.  It can      split absolute 32-bit symbolic constants into a high/lo_sum      pair but uses macros for other sorts of access.       Like explicit relocation support for REL targets, it relies      on GNU extensions in the assembler and the linker.       Although this code should work for -O0, it has traditionally      been treated as an optimization.  */
if|if
condition|(
operator|!
name|TARGET_MIPS16
operator|&&
name|TARGET_SPLIT_ADDRESSES
operator|&&
name|optimize
operator|&&
operator|!
name|flag_pic
operator|&&
operator|!
name|ABI_HAS_64BIT_SYMBOLS
condition|)
name|mips_split_addresses
operator|=
literal|1
expr_stmt|;
else|else
name|mips_split_addresses
operator|=
literal|0
expr_stmt|;
comment|/* -mvr4130-align is a "speed over size" optimization: it usually produces      faster code, but at the expense of more nops.  Enable it at -O3 and      above.  */
if|if
condition|(
name|optimize
operator|>
literal|2
operator|&&
operator|(
name|target_flags_explicit
operator|&
name|MASK_VR4130_ALIGN
operator|)
operator|==
literal|0
condition|)
name|target_flags
operator||=
name|MASK_VR4130_ALIGN
expr_stmt|;
comment|/* When compiling for the mips16, we cannot use floating point.  We      record the original hard float value in mips16_hard_float.  */
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
if|if
condition|(
name|TARGET_SOFT_FLOAT
condition|)
name|mips16_hard_float
operator|=
literal|0
expr_stmt|;
else|else
name|mips16_hard_float
operator|=
literal|1
expr_stmt|;
name|target_flags
operator||=
name|MASK_SOFT_FLOAT
expr_stmt|;
comment|/* Don't run the scheduler before reload, since it tends to          increase register pressure.  */
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
comment|/* Don't do hot/cold partitioning.  The constant layout code expects 	 the whole function to be in a single section.  */
name|flag_reorder_blocks_and_partition
operator|=
literal|0
expr_stmt|;
comment|/* Silently disable -mexplicit-relocs since it doesn't apply 	 to mips16 code.  Even so, it would overly pedantic to warn 	 about "-mips16 -mexplicit-relocs", especially given that 	 we use a %gprel() operator.  */
name|target_flags
operator|&=
operator|~
name|MASK_EXPLICIT_RELOCS
expr_stmt|;
block|}
comment|/* When using explicit relocs, we call dbr_schedule from within      mips_reorg.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
name|mips_flag_delayed_branch
operator|=
name|flag_delayed_branch
expr_stmt|;
name|flag_delayed_branch
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MIPS_TFMODE_FORMAT
name|REAL_MODE_FORMAT
argument_list|(
name|TFmode
argument_list|)
operator|=
operator|&
name|MIPS_TFMODE_FORMAT
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure that the user didn't turn off paired single support when      MIPS-3D support is requested.  */
if|if
condition|(
name|TARGET_MIPS3D
operator|&&
operator|(
name|target_flags_explicit
operator|&
name|MASK_PAIRED_SINGLE_FLOAT
operator|)
operator|&&
operator|!
name|TARGET_PAIRED_SINGLE_FLOAT
condition|)
name|error
argument_list|(
literal|"-mips3d requires -mpaired-single"
argument_list|)
expr_stmt|;
comment|/* If TARGET_MIPS3D, enable MASK_PAIRED_SINGLE_FLOAT.  */
if|if
condition|(
name|TARGET_MIPS3D
condition|)
name|target_flags
operator||=
name|MASK_PAIRED_SINGLE_FLOAT
expr_stmt|;
comment|/* Make sure that when TARGET_PAIRED_SINGLE_FLOAT is true, TARGET_FLOAT64      and TARGET_HARD_FLOAT are both true.  */
if|if
condition|(
name|TARGET_PAIRED_SINGLE_FLOAT
operator|&&
operator|!
operator|(
name|TARGET_FLOAT64
operator|&&
name|TARGET_HARD_FLOAT
operator|)
condition|)
name|error
argument_list|(
literal|"-mips3d/-mpaired-single must be used with -mfp64 -mhard-float"
argument_list|)
expr_stmt|;
comment|/* Make sure that the ISA supports TARGET_PAIRED_SINGLE_FLOAT when it is      enabled.  */
if|if
condition|(
name|TARGET_PAIRED_SINGLE_FLOAT
operator|&&
operator|!
name|ISA_MIPS64
condition|)
name|error
argument_list|(
literal|"-mips3d/-mpaired-single must be used with -mips64"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|TARGET_DSP
condition|)
name|error
argument_list|(
literal|"-mips16 and -mdsp cannot be used together"
argument_list|)
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'?'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'#'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'/'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'&'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'!'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'*'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'@'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'.'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'('
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|')'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'['
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|']'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'<'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'>'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'{'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'}'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'^'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'$'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'+'
index|]
operator|=
literal|1
expr_stmt|;
name|mips_print_operand_punct
index|[
literal|'~'
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Set up array to map GCC register number to debug register number.      Ignore the special purpose register numbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|mips_dbx_regno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|start
operator|=
name|GP_DBX_FIRST
operator|-
name|GP_REG_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GP_REG_FIRST
init|;
name|i
operator|<=
name|GP_REG_LAST
condition|;
name|i
operator|++
control|)
name|mips_dbx_regno
index|[
name|i
index|]
operator|=
name|i
operator|+
name|start
expr_stmt|;
name|start
operator|=
name|FP_DBX_FIRST
operator|-
name|FP_REG_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP_REG_FIRST
init|;
name|i
operator|<=
name|FP_REG_LAST
condition|;
name|i
operator|++
control|)
name|mips_dbx_regno
index|[
name|i
index|]
operator|=
name|i
operator|+
name|start
expr_stmt|;
name|mips_dbx_regno
index|[
name|HI_REGNUM
index|]
operator|=
name|MD_DBX_FIRST
operator|+
literal|0
expr_stmt|;
name|mips_dbx_regno
index|[
name|LO_REGNUM
index|]
operator|=
name|MD_DBX_FIRST
operator|+
literal|1
expr_stmt|;
comment|/* Set up array giving whether a given register can hold a given mode.  */
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
name|mode
operator|!=
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|mode_class
name|class
init|=
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
specifier|register
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCV2mode
condition|)
name|temp
operator|=
operator|(
name|ISA_HAS_8CC
operator|&&
name|ST_REG_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
name|regno
operator|-
name|ST_REG_FIRST
operator|)
operator|%
literal|2
operator|==
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCV4mode
condition|)
name|temp
operator|=
operator|(
name|ISA_HAS_8CC
operator|&&
name|ST_REG_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
name|regno
operator|-
name|ST_REG_FIRST
operator|)
operator|%
literal|4
operator|==
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCmode
condition|)
block|{
if|if
condition|(
operator|!
name|ISA_HAS_8CC
condition|)
name|temp
operator|=
operator|(
name|regno
operator|==
name|FPSW_REGNUM
operator|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|ST_REG_P
argument_list|(
name|regno
argument_list|)
operator|||
name|GP_REG_P
argument_list|(
name|regno
argument_list|)
operator|||
name|FP_REG_P
argument_list|(
name|regno
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|temp
operator|=
operator|(
operator|(
name|regno
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
name|size
operator|<=
name|UNITS_PER_WORD
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|temp
operator|=
operator|(
operator|(
name|regno
operator|%
name|FP_INC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|class
operator|==
name|MODE_FLOAT
operator|||
name|class
operator|==
name|MODE_COMPLEX_FLOAT
operator|||
name|class
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
name|size
operator|<=
name|UNITS_PER_FPVALUE
operator|)
comment|/* Allow integer modes that fit into a single 			   register.  We need to put integers into FPRs 			   when using instructions like cvt and trunc. 			   We can't allow sizes smaller than a word, 			   the FPU has no appropriate load/store 			   instructions for those.  */
operator|||
operator|(
name|class
operator|==
name|MODE_INT
operator|&&
name|size
operator|>=
name|MIN_UNITS_PER_WORD
operator|&&
name|size
operator|<=
name|UNITS_PER_FPREG
operator|)
comment|/* Allow TFmode for CCmode reloads.  */
operator|||
operator|(
name|ISA_HAS_8CC
operator|&&
name|mode
operator|==
name|TFmode
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ACC_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|temp
operator|=
operator|(
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
name|size
operator|<=
name|UNITS_PER_WORD
operator|||
operator|(
name|ACC_HI_REG_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|size
operator|==
literal|2
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ALL_COP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
name|temp
operator|=
operator|(
name|class
operator|==
name|MODE_INT
operator|&&
name|size
operator|<=
name|UNITS_PER_WORD
operator|)
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
name|mips_hard_regno_mode_ok
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|regno
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Save GPR registers in word_mode sized hunks.  word_mode hasn't been      initialized yet, so we can't use that here.  */
name|gpr_mode
operator|=
name|TARGET_64BIT
condition|?
name|DImode
else|:
name|SImode
expr_stmt|;
comment|/* Provide default values for align_* for 64-bit targets.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_MIPS16
condition|)
block|{
if|if
condition|(
name|align_loops
operator|==
literal|0
condition|)
name|align_loops
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|==
literal|0
condition|)
name|align_jumps
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|align_functions
operator|==
literal|0
condition|)
name|align_functions
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Function to allocate machine-dependent function status.  */
name|init_machine_status
operator|=
operator|&
name|mips_init_machine_status
expr_stmt|;
if|if
condition|(
name|ABI_HAS_64BIT_SYMBOLS
condition|)
block|{
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
name|mips_split_p
index|[
name|SYMBOL_64_HIGH
index|]
operator|=
name|true
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_64_HIGH
index|]
operator|=
literal|"%highest("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_64_HIGH
index|]
operator|=
literal|"%higher("
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_64_MID
index|]
operator|=
name|true
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_64_MID
index|]
operator|=
literal|"%higher("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_64_MID
index|]
operator|=
literal|"%hi("
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_64_LOW
index|]
operator|=
name|true
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_64_LOW
index|]
operator|=
literal|"%hi("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_64_LOW
index|]
operator|=
literal|"%lo("
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_GENERAL
index|]
operator|=
name|true
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GENERAL
index|]
operator|=
literal|"%lo("
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|||
name|mips_split_addresses
condition|)
block|{
name|mips_split_p
index|[
name|SYMBOL_GENERAL
index|]
operator|=
name|true
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_GENERAL
index|]
operator|=
literal|"%hi("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GENERAL
index|]
operator|=
literal|"%lo("
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
comment|/* The high part is provided by a pseudo copy of $gp.  */
name|mips_split_p
index|[
name|SYMBOL_SMALL_DATA
index|]
operator|=
name|true
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_SMALL_DATA
index|]
operator|=
literal|"%gprel("
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
comment|/* Small data constants are kept whole until after reload, 	 then lowered by mips_rewrite_small_data.  */
name|mips_lo_relocs
index|[
name|SYMBOL_SMALL_DATA
index|]
operator|=
literal|"%gp_rel("
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_GOT_LOCAL
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TARGET_NEWABI
condition|)
block|{
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_PAGE
index|]
operator|=
literal|"%got_page("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GOT_LOCAL
index|]
operator|=
literal|"%got_ofst("
expr_stmt|;
block|}
else|else
block|{
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_PAGE
index|]
operator|=
literal|"%got("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GOT_LOCAL
index|]
operator|=
literal|"%lo("
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_XGOT
condition|)
block|{
comment|/* The HIGH and LO_SUM are matched by special .md patterns.  */
name|mips_split_p
index|[
name|SYMBOL_GOT_GLOBAL
index|]
operator|=
name|true
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_GOTOFF_GLOBAL
index|]
operator|=
name|true
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_GOTOFF_GLOBAL
index|]
operator|=
literal|"%got_hi("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_GLOBAL
index|]
operator|=
literal|"%got_lo("
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_GOTOFF_CALL
index|]
operator|=
name|true
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_GOTOFF_CALL
index|]
operator|=
literal|"%call_hi("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_CALL
index|]
operator|=
literal|"%call_lo("
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_NEWABI
condition|)
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_GLOBAL
index|]
operator|=
literal|"%got_disp("
expr_stmt|;
else|else
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_GLOBAL
index|]
operator|=
literal|"%got("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_CALL
index|]
operator|=
literal|"%call16("
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_NEWABI
condition|)
block|{
name|mips_split_p
index|[
name|SYMBOL_GOTOFF_LOADGP
index|]
operator|=
name|true
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_GOTOFF_LOADGP
index|]
operator|=
literal|"%hi(%neg(%gp_rel("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GOTOFF_LOADGP
index|]
operator|=
literal|"%lo(%neg(%gp_rel("
expr_stmt|;
block|}
comment|/* Thread-local relocation operators.  */
name|mips_lo_relocs
index|[
name|SYMBOL_TLSGD
index|]
operator|=
literal|"%tlsgd("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_TLSLDM
index|]
operator|=
literal|"%tlsldm("
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_DTPREL
index|]
operator|=
literal|1
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_DTPREL
index|]
operator|=
literal|"%dtprel_hi("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_DTPREL
index|]
operator|=
literal|"%dtprel_lo("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_GOTTPREL
index|]
operator|=
literal|"%gottprel("
expr_stmt|;
name|mips_split_p
index|[
name|SYMBOL_TPREL
index|]
operator|=
literal|1
expr_stmt|;
name|mips_hi_relocs
index|[
name|SYMBOL_TPREL
index|]
operator|=
literal|"%tprel_hi("
expr_stmt|;
name|mips_lo_relocs
index|[
name|SYMBOL_TPREL
index|]
operator|=
literal|"%tprel_lo("
expr_stmt|;
comment|/* We don't have a thread pointer access instruction on MIPS16, or      appropriate TLS relocations.  */
if|if
condition|(
name|TARGET_MIPS16
condition|)
name|targetm
operator|.
name|have_tls
operator|=
name|false
expr_stmt|;
comment|/* Default to working around R4000 errata only if the processor      was selected explicitly.  */
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_FIX_R4000
operator|)
operator|==
literal|0
operator|&&
name|mips_matching_cpu_name_p
argument_list|(
name|mips_arch_info
operator|->
name|name
argument_list|,
literal|"r4000"
argument_list|)
condition|)
name|target_flags
operator||=
name|MASK_FIX_R4000
expr_stmt|;
comment|/* Default to working around R4400 errata only if the processor      was selected explicitly.  */
if|if
condition|(
operator|(
name|target_flags_explicit
operator|&
name|MASK_FIX_R4400
operator|)
operator|==
literal|0
operator|&&
name|mips_matching_cpu_name_p
argument_list|(
name|mips_arch_info
operator|->
name|name
argument_list|,
literal|"r4400"
argument_list|)
condition|)
name|target_flags
operator||=
name|MASK_FIX_R4400
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement CONDITIONAL_REGISTER_USAGE.  */
end_comment

begin_function
name|void
name|mips_conditional_register_usage
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_DSP
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|DSP_ACC_REG_FIRST
init|;
name|regno
operator|<=
name|DSP_ACC_REG_LAST
condition|;
name|regno
operator|++
control|)
name|fixed_regs
index|[
name|regno
index|]
operator|=
name|call_used_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_HARD_FLOAT
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FP_REG_FIRST
init|;
name|regno
operator|<=
name|FP_REG_LAST
condition|;
name|regno
operator|++
control|)
name|fixed_regs
index|[
name|regno
index|]
operator|=
name|call_used_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|ST_REG_FIRST
init|;
name|regno
operator|<=
name|ST_REG_LAST
condition|;
name|regno
operator|++
control|)
name|fixed_regs
index|[
name|regno
index|]
operator|=
name|call_used_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ISA_HAS_8CC
condition|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* We only have a single condition code register.  We 	 implement this by hiding all the condition code registers, 	 and generating RTL that refers directly to ST_REG_FIRST.  */
for|for
control|(
name|regno
operator|=
name|ST_REG_FIRST
init|;
name|regno
operator|<=
name|ST_REG_LAST
condition|;
name|regno
operator|++
control|)
name|fixed_regs
index|[
name|regno
index|]
operator|=
name|call_used_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* In mips16 mode, we permit the $t temporary registers to be used      for reload.  We prohibit the unused $s registers, since they      are caller saved, and saving them via a mips16 register would      probably waste more time than just reloading the value.  */
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
name|fixed_regs
index|[
literal|18
index|]
operator|=
name|call_used_regs
index|[
literal|18
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|19
index|]
operator|=
name|call_used_regs
index|[
literal|19
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|20
index|]
operator|=
name|call_used_regs
index|[
literal|20
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|21
index|]
operator|=
name|call_used_regs
index|[
literal|21
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|22
index|]
operator|=
name|call_used_regs
index|[
literal|22
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|23
index|]
operator|=
name|call_used_regs
index|[
literal|23
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|26
index|]
operator|=
name|call_used_regs
index|[
literal|26
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|27
index|]
operator|=
name|call_used_regs
index|[
literal|27
index|]
operator|=
literal|1
expr_stmt|;
name|fixed_regs
index|[
literal|30
index|]
operator|=
name|call_used_regs
index|[
literal|30
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* fp20-23 are now caller saved.  */
if|if
condition|(
name|mips_abi
operator|==
name|ABI_64
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FP_REG_FIRST
operator|+
literal|20
init|;
name|regno
operator|<
name|FP_REG_FIRST
operator|+
literal|24
condition|;
name|regno
operator|++
control|)
name|call_really_used_regs
index|[
name|regno
index|]
operator|=
name|call_used_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Odd registers from fp21 to fp31 are now caller saved.  */
if|if
condition|(
name|mips_abi
operator|==
name|ABI_N32
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FP_REG_FIRST
operator|+
literal|21
init|;
name|regno
operator|<=
name|FP_REG_FIRST
operator|+
literal|31
condition|;
name|regno
operator|+=
literal|2
control|)
name|call_really_used_regs
index|[
name|regno
index|]
operator|=
name|call_used_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate a chunk of memory for per-function machine-dependent data.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|mips_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* On the mips16, we want to allocate $24 (T_REG) before other    registers for instructions for which it is possible.  This helps    avoid shuffling registers around in order to set up for an xor,    encouraging the compiler to use a cmp instead.  */
end_comment

begin_function
name|void
name|mips_order_regs_for_local_alloc
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
comment|/* It really doesn't matter where we put register 0, since it is          a fixed register anyhow.  */
name|reg_alloc_order
index|[
literal|0
index|]
operator|=
literal|24
expr_stmt|;
name|reg_alloc_order
index|[
literal|24
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The MIPS debug format wants all automatic variables and arguments    to be in terms of the virtual frame pointer (stack pointer before    any adjustment in the function), while the MIPS 3.0 linker wants    the frame pointer to be the stack pointer after the initial    adjustment.  So, we do the adjustment here.  The arg pointer (which    is eliminated) points to the virtual frame pointer, while the frame    pointer (which may be eliminated) points to the stack pointer after    the initial adjustments.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|mips_debugger_offset
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|rtx
name|offset2
init|=
name|const0_rtx
decl_stmt|;
name|rtx
name|reg
init|=
name|eliminate_constant_term
argument_list|(
name|addr
argument_list|,
operator|&
name|offset2
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|offset2
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|stack_pointer_rtx
operator|||
name|reg
operator|==
name|frame_pointer_rtx
operator|||
name|reg
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
name|HOST_WIDE_INT
name|frame_size
init|=
operator|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|initialized
operator|)
condition|?
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
else|:
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|total_size
decl_stmt|;
comment|/* MIPS16 frame is smaller */
if|if
condition|(
name|frame_pointer_needed
operator|&&
name|TARGET_MIPS16
condition|)
name|frame_size
operator|-=
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
expr_stmt|;
name|offset
operator|=
name|offset
operator|-
name|frame_size
expr_stmt|;
block|}
comment|/* sdbout_parms does not want this to crash for unrecognized cases.  */
if|#
directive|if
literal|0
block|else if (reg != arg_pointer_rtx)     fatal_insn ("mips_debugger_offset called with non stack/frame/arg pointer", 		addr);
endif|#
directive|endif
return|return
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement the PRINT_OPERAND macro.  The MIPS-specific operand codes are:     'X'  OP is CONST_INT, prints 32 bits in hexadecimal format = "0x%08x",    'x'  OP is CONST_INT, prints 16 bits in hexadecimal format = "0x%04x",    'h'  OP is HIGH, prints %hi(X),    'd'  output integer constant in decimal,    'z'	if the operand is 0, use $0 instead of normal operand.    'D'  print second part of double-word register or memory operand.    'L'  print low-order register of double-word register operand.    'M'  print high-order register of double-word register operand.    'C'  print part of opcode for a branch condition.    'F'  print part of opcode for a floating-point branch condition.    'N'  print part of opcode for a branch condition, inverted.    'W'  print part of opcode for a floating-point branch condition, inverted.    'T'  print 'f' for (eq:CC ...), 't' for (ne:CC ...), 	      'z' for (eq:?I ...), 'n' for (ne:?I ...).    't'  like 'T', but with the EQ/NE cases reversed    'Y'  for a CONST_INT X, print mips_fp_conditions[X]    'Z'  print the operand and a comma for ISA_HAS_8CC, otherwise print nothing    'R'  print the reloc associated with LO_SUM    'q'  print DSP accumulator registers     The punctuation characters are:     '('	Turn on .set noreorder    ')'	Turn on .set reorder    '['	Turn on .set noat    ']'	Turn on .set at    '<'	Turn on .set nomacro    '>'	Turn on .set macro    '{'	Turn on .set volatile (not GAS)    '}'	Turn on .set novolatile (not GAS)    '&'	Turn on .set noreorder if filling delay slots    '*'	Turn on both .set noreorder and .set nomacro if filling delay slots    '!'	Turn on .set nomacro if filling delay slots    '#'	Print nop if in a .set noreorder section.    '/'	Like '#', but does nothing within a delayed branch sequence    '?'	Print 'l' if we are to use a branch likely instead of normal branch.    '@'	Print the name of the assembler temporary register (at or $1).    '.'	Print the name of the register with a hard-wired zero (zero or $0).    '^'	Print the name of the pic call-through register (t9 or $25).    '$'	Print the name of the stack pointer register (sp or $29).    '+'	Print the name of the gp register (usually gp or $28).    '~'	Output a branch alignment to LABEL_ALIGN(NULL).  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|op
parameter_list|,
name|int
name|letter
parameter_list|)
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|PRINT_OPERAND_PUNCT_VALID_P
argument_list|(
name|letter
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|letter
condition|)
block|{
case|case
literal|'?'
case|:
if|if
condition|(
name|mips_branch_likely
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|PIC_FUNCTION_ADDR_REGNUM
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|0
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|final_sequence
operator|!=
literal|0
operator|&&
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoreorder\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|final_sequence
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoreorder\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_nomacro
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnomacro\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|final_sequence
operator|!=
literal|0
operator|&&
name|set_nomacro
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\tnomacro"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|set_noreorder
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\tnop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* Print an extra newline so that the delayed insn is separated 	     from the following ones.  This looks neater and is consistent 	     with non-nop delayed sequences.  */
if|if
condition|(
name|set_noreorder
operator|!=
literal|0
operator|&&
name|final_sequence
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\tnop\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|set_noreorder
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoreorder\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|set_noreorder
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%) found without a %%( in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_noreorder
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\treorder"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
if|if
condition|(
name|set_noat
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnoat\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
name|set_noat
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%] found without a %%[ in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_noat
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\tat"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|set_nomacro
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|".set\tnomacro\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|set_nomacro
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%> found without a %%< in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_nomacro
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t.set\tmacro"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
name|set_volatile
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"#.set\tvolatile\n\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
name|set_volatile
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"internal error: %%} found without a %%{ in assembler pattern"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|set_volatile
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\t#.set\tnovolatile"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
block|{
if|if
condition|(
name|align_labels_log
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|align_labels_log
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"PRINT_OPERAND: unknown punctuation '%c'"
argument_list|,
name|letter
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|op
condition|)
block|{
name|error
argument_list|(
literal|"PRINT_OPERAND null pointer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
operator|==
literal|'C'
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"gtu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"geu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"ltu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"leu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"PRINT_OPERAND, invalid insn for %%C"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'N'
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"leu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"ltu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"geu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"gtu"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"PRINT_OPERAND, invalid insn for %%N"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'F'
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"c1f"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"c1t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"PRINT_OPERAND, invalid insn for %%F"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'W'
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"c1t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"c1f"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"PRINT_OPERAND, invalid insn for %%W"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|HIGH
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_operand_reloc
argument_list|(
name|file
argument_list|,
name|op
argument_list|,
name|mips_hi_relocs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'R'
condition|)
name|print_operand_reloc
argument_list|(
name|file
argument_list|,
name|op
argument_list|,
name|mips_lo_relocs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'Y'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_fp_conditions
argument_list|)
operator|)
condition|)
name|fputs
argument_list|(
name|mips_fp_conditions
index|[
name|INTVAL
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%Y value"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'Z'
condition|)
block|{
if|if
condition|(
name|ISA_HAS_8CC
condition|)
block|{
name|print_operand
argument_list|(
name|file
argument_list|,
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'q'
condition|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|REG
condition|)
name|fatal_insn
argument_list|(
literal|"PRINT_OPERAND, invalid insn for %%q"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|regnum
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|MD_REG_P
argument_list|(
name|regnum
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$ac0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DSP_ACC_REG_P
argument_list|(
name|regnum
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$ac%c"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|fatal_insn
argument_list|(
literal|"PRINT_OPERAND, invalid insn for %%q"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
operator|||
name|code
operator|==
name|SUBREG
condition|)
block|{
specifier|register
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
name|regnum
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|regnum
operator|=
name|true_regnum
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|letter
operator|==
literal|'M'
operator|&&
operator|!
name|WORDS_BIG_ENDIAN
operator|)
operator|||
operator|(
name|letter
operator|==
literal|'L'
operator|&&
name|WORDS_BIG_ENDIAN
operator|)
operator|||
name|letter
operator|==
literal|'D'
condition|)
name|regnum
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|letter
operator|==
literal|'D'
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'x'
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
literal|0xffff
operator|&
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'X'
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'d'
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'z'
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|GP_REG_FIRST
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'d'
operator|||
name|letter
operator|==
literal|'x'
operator|||
name|letter
operator|==
literal|'X'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid use of %%d, %%x, or %%X"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'T'
operator|||
name|letter
operator|==
literal|'t'
condition|)
block|{
name|int
name|truth
init|=
operator|(
name|code
operator|==
name|NE
operator|)
operator|==
operator|(
name|letter
operator|==
literal|'T'
operator|)
decl_stmt|;
name|fputc
argument_list|(
literal|"zfnt"
index|[
name|truth
operator|*
literal|2
operator|+
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|CCmode
operator|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_GP_P
argument_list|(
name|op
argument_list|)
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|GLOBAL_POINTER_REGNUM
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print symbolic operand OP, which is part of a HIGH or LO_SUM.    RELOCS is the array of relocations to use.  */
end_comment

begin_function
specifier|static
name|void
name|print_operand_reloc
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|op
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|relocs
parameter_list|)
block|{
name|enum
name|mips_symbol_type
name|symbol_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|mips_symbolic_constant_p
argument_list|(
name|op
argument_list|,
operator|&
name|symbol_type
argument_list|)
operator|||
name|relocs
index|[
name|symbol_type
index|]
operator|==
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"PRINT_OPERAND, invalid operand for relocation"
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* If OP uses an UNSPEC address, we want to print the inner symbol.  */
name|mips_split_const
argument_list|(
name|op
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNSPEC_ADDRESS_P
argument_list|(
name|base
argument_list|)
condition|)
name|op
operator|=
name|plus_constant
argument_list|(
name|UNSPEC_ADDRESS
argument_list|(
name|base
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|relocs
index|[
name|symbol_type
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|relocs
index|[
name|symbol_type
index|]
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output address operand X to FILE.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|mips_address_info
name|addr
decl_stmt|;
if|if
condition|(
name|mips_classify_address
argument_list|(
operator|&
name|addr
argument_list|,
name|x
argument_list|,
name|word_mode
argument_list|,
name|true
argument_list|)
condition|)
switch|switch
condition|(
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|ADDRESS_REG
case|:
name|print_operand
argument_list|(
name|file
argument_list|,
name|addr
operator|.
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
operator|.
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDRESS_LO_SUM
case|:
name|print_operand
argument_list|(
name|file
argument_list|,
name|addr
operator|.
name|offset
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
operator|.
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDRESS_CONST_INT
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDRESS_SYMBOLIC
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When using assembler macros, keep track of all of small-data externs    so that mips_file_end can emit the appropriate declarations for them.     In most cases it would be safe (though pointless) to emit .externs    for other symbols too.  One exception is when an object is within    the -G limit but declared by the user to be in a section other    than .sbss or .sdata.  */
end_comment

begin_function
name|int
name|mips_output_external
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|mips_in_small_data_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extern_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IRIX
operator|&&
name|mips_abi
operator|==
name|ABI_32
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extern_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_IRIX
end_if

begin_function
specifier|static
name|void
name|irix_output_external_libcall
parameter_list|(
name|rtx
name|fun
parameter_list|)
block|{
specifier|register
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|mips_abi
operator|==
name|ABI_32
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extern_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Emit a new filename to a stream.  If we are smuggling stabs, try to    put out a MIPS ECOFF file and a stab.  */
end_comment

begin_function
name|void
name|mips_output_filename
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* If we are emitting DWARF-2, let dwarf2out handle the ".file"      directives.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
return|return;
elseif|else
if|if
condition|(
name|mips_output_filename_first_time
condition|)
block|{
name|mips_output_filename_first_time
operator|=
literal|0
expr_stmt|;
name|num_source_filenames
operator|+=
literal|1
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* If we are emitting stabs, let dbxout.c handle this (except for      the mips_output_filename_first_time case).  */
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
return|return;
elseif|else
if|if
condition|(
name|name
operator|!=
name|current_function_file
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|current_function_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|num_source_filenames
operator|+=
literal|1
expr_stmt|;
name|current_function_file
operator|=
name|name
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t.file\t%d "
argument_list|,
name|num_source_filenames
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an ASCII string, in a space-saving way.  PREFIX is the string    that should be written before the opening quote, such as "\t.ascii\t"    for real string data or "\t# " for a comment.  */
end_comment

begin_function
name|void
name|mips_output_ascii
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|string_param
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|cur_pos
init|=
literal|17
decl_stmt|;
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|string
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string_param
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\""
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'\"'
condition|)
block|{
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|cur_pos
operator|++
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|cur_pos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|cur_pos
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|cur_pos
operator|>
literal|72
operator|&&
name|i
operator|+
literal|1
operator|<
name|len
condition|)
block|{
name|cur_pos
operator|=
literal|17
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\"\n%s\""
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement TARGET_ASM_FILE_START.  */
end_comment

begin_function
specifier|static
name|void
name|mips_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|default_file_start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_IRIX
condition|)
block|{
comment|/* Generate a special section to describe the ABI switches used to 	 produce the resultant binary.  This used to be done by the assembler 	 setting bits in the ELF header's flags field, but we have run out of 	 bits.  GDB needs this information in order to be able to correctly 	 debug these binaries.  See the function mips_gdbarch_init() in 	 gdb/mips-tdep.c.  This is unnecessary for the IRIX 5/6 ABIs and 	 causes unnecessary IRIX 6 ld warnings.  */
specifier|const
name|char
modifier|*
name|abi_string
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|mips_abi
condition|)
block|{
case|case
name|ABI_32
case|:
name|abi_string
operator|=
literal|"abi32"
expr_stmt|;
break|break;
case|case
name|ABI_N32
case|:
name|abi_string
operator|=
literal|"abiN32"
expr_stmt|;
break|break;
case|case
name|ABI_64
case|:
name|abi_string
operator|=
literal|"abi64"
expr_stmt|;
break|break;
case|case
name|ABI_O64
case|:
name|abi_string
operator|=
literal|"abiO64"
expr_stmt|;
break|break;
case|case
name|ABI_EABI
case|:
name|abi_string
operator|=
name|TARGET_64BIT
condition|?
literal|"eabi64"
else|:
literal|"eabi32"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Note - we use fprintf directly rather than calling switch_to_section 	 because in this way we can avoid creating an allocated section.  We 	 do not want this section to take up any space in the running 	 executable.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section .mdebug.%s\n"
argument_list|,
name|abi_string
argument_list|)
expr_stmt|;
comment|/* There is no ELF header flag to distinguish long32 forms of the 	 EABI from long64 forms.  Emit a special section to help tools 	 such as GDB.  Do the same for o64, which is sometimes used with 	 -mlong64.  */
if|if
condition|(
name|mips_abi
operator|==
name|ABI_EABI
operator|||
name|mips_abi
operator|==
name|ABI_O64
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section .gcc_compiled_long%d\n"
argument_list|,
name|TARGET_LONG64
condition|?
literal|64
else|:
literal|32
argument_list|)
expr_stmt|;
comment|/* Restore the default section.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.previous\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Generate the pseudo ops that System V.4 wants.  */
if|if
condition|(
name|TARGET_ABICALLS
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.abicalls\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tmips16\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n%s -G value = %d, Arch = %s, ISA = %d\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|mips_section_threshold
argument_list|,
name|mips_arch_info
operator|->
name|name
argument_list|,
name|mips_isa
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BSS_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* Implement ASM_OUTPUT_ALIGNED_BSS.  This differs from the default only    in the use of sbss.  */
end_comment

begin_function
name|void
name|mips_output_aligned_bss
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
specifier|extern
name|tree
name|last_assemble_variable_decl
decl_stmt|;
if|if
condition|(
name|mips_in_small_data_p
argument_list|(
name|decl
argument_list|)
condition|)
name|switch_to_section
argument_list|(
name|get_named_section
argument_list|(
name|NULL
argument_list|,
literal|".sbss"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|bss_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|stream
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SKIP
argument_list|(
name|stream
argument_list|,
name|size
operator|!=
literal|0
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit    .externs for any small-data variables that turned out to be external.  */
end_comment

begin_function
specifier|static
name|void
name|mips_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|name_tree
decl_stmt|;
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|extern_head
condition|)
block|{
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|extern_head
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name_tree
operator|=
name|get_identifier
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Positively ensure only one .extern for any given symbol.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|name_tree
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In IRIX 5 or IRIX 6 for the O32 ABI, we must output a 		 `.global name .text' directive for every used but 		 undefined function.  If we don't, the linker may perform 		 an optimization (skipping over the insns that set $gp) 		 when it is unsafe.  */
if|if
condition|(
name|TARGET_IRIX
operator|&&
name|mips_abi
operator|==
name|ABI_32
operator|&&
name|p
operator|->
name|size
operator|==
operator|-
literal|1
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.globl "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" .text\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"\t.extern\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|", %d\n"
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Implement ASM_OUTPUT_ALIGNED_DECL_COMMON.  This is usually the same as the    elfos.h version, but we also need to handle -muninit-const-in-rodata.  */
end_comment

begin_function
name|void
name|mips_output_aligned_decl_common
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|)
block|{
comment|/* If the target wants uninitialized const declarations in      .rdata then don't put them in .comm.  */
if|if
condition|(
name|TARGET_EMBEDDED_DATA
operator|&&
name|TARGET_UNINIT_CONST_IN_RODATA
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|readonly_data_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|stream
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|mips_declare_object
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
literal|""
argument_list|,
literal|":\n\t.space\t"
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|mips_declare_common_object
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
literal|"\n\t.comm\t"
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Declare a common object of SIZE bytes using asm directive INIT_STRING.    NAME is the name of the object and ALIGN is the required alignment    in bytes.  TAKES_ALIGNMENT_P is true if the directive takes a third    alignment argument.  */
end_comment

begin_function
name|void
name|mips_declare_common_object
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|init_string
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|unsigned
name|int
name|align
parameter_list|,
name|bool
name|takes_alignment_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|takes_alignment_p
condition|)
block|{
name|size
operator|+=
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|size
operator|-=
name|size
operator|%
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|mips_declare_object
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|init_string
argument_list|,
literal|","
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|mips_declare_object
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|init_string
argument_list|,
literal|","
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|",%u\n"
argument_list|,
name|size
argument_list|,
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit either a label, .comm, or .lcomm directive.  When using assembler    macros, mark the symbol as written so that mips_file_end won't emit an    .extern for it.  STREAM is the output file, NAME is the name of the    symbol, INIT_STRING is the string that should be written before the    symbol and FINAL_STRING is the string that should be written after it.    FINAL_STRING is a printf() format that consumes the remaining arguments.  */
end_comment

begin_function
name|void
name|mips_declare_object
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|init_string
parameter_list|,
specifier|const
name|char
modifier|*
name|final_string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|fputs
argument_list|(
name|init_string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|final_string
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|final_string
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
name|tree
name|name_tree
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|name_tree
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SIZE_DIRECTIVE
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|size_directive_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implement ASM_DECLARE_OBJECT_NAME.  This is like most of the standard ELF    definitions except that it uses mips_declare_object() to emit the label.  */
end_comment

begin_function
name|void
name|mips_declare_object_name
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_TYPE_DIRECTIVE
name|ASM_OUTPUT_TYPE_DIRECTIVE
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
literal|"object"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size_directive_output
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|size_directive_output
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SIZE_DIRECTIVE
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|mips_declare_object
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
literal|""
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement ASM_FINISH_DECLARE_OBJECT.  This is generic ELF stuff.  */
end_comment

begin_function
name|void
name|mips_finish_declare_object
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|tree
name|decl
parameter_list|,
name|int
name|top_level
parameter_list|,
name|int
name|at_end
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|at_end
operator|&&
name|top_level
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|&&
operator|!
name|size_directive_output
condition|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|size_directive_output
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SIZE_DIRECTIVE
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return true if X is a small data address that can be rewritten    as a LO_SUM.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_rewrite_small_data_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|mips_symbol_type
name|symbol_type
decl_stmt|;
return|return
operator|(
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|mips_symbolic_constant_p
argument_list|(
name|x
argument_list|,
operator|&
name|symbol_type
argument_list|)
operator|&&
name|symbol_type
operator|==
name|SYMBOL_SMALL_DATA
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A for_each_rtx callback for mips_small_data_pattern_p.  */
end_comment

begin_function
specifier|static
name|int
name|mips_small_data_pattern_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|mips_rewrite_small_data_p
argument_list|(
operator|*
name|loc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP refers to small data symbols directly, not through    a LO_SUM.  */
end_comment

begin_function
name|bool
name|mips_small_data_pattern_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|op
argument_list|,
name|mips_small_data_pattern_1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A for_each_rtx callback, used by mips_rewrite_small_data.  */
end_comment

begin_function
specifier|static
name|int
name|mips_rewrite_small_data_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|mips_rewrite_small_data_p
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
operator|*
name|loc
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
operator|*
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If possible, rewrite OP so that it refers to small data using    explicit relocations.  */
end_comment

begin_function
name|rtx
name|mips_rewrite_small_data
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
name|op
operator|=
name|copy_insn
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|op
argument_list|,
name|mips_rewrite_small_data_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the current function has an insn that implicitly    refers to $gp.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_function_has_gp_insn
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Don't bother rechecking if we found one last time.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|has_gp_insn_p
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
operator|(
name|get_attr_got
argument_list|(
name|insn
argument_list|)
operator|!=
name|GOT_UNSET
operator|||
name|small_data_pattern
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
break|break;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|has_gp_insn_p
operator|=
operator|(
name|insn
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|cfun
operator|->
name|machine
operator|->
name|has_gp_insn_p
return|;
block|}
end_function

begin_comment
comment|/* Return the register that should be used as the global pointer    within this function.  Return 0 if the function doesn't need    a global pointer.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mips_global_pointer
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* $gp is always available in non-abicalls code.  */
if|if
condition|(
operator|!
name|TARGET_ABICALLS
condition|)
return|return
name|GLOBAL_POINTER_REGNUM
return|;
comment|/* We must always provide $gp when it is used implicitly.  */
if|if
condition|(
operator|!
name|TARGET_EXPLICIT_RELOCS
condition|)
return|return
name|GLOBAL_POINTER_REGNUM
return|;
comment|/* FUNCTION_PROFILER includes a jal macro, so we need to give it      a valid gp.  */
if|if
condition|(
name|current_function_profile
condition|)
return|return
name|GLOBAL_POINTER_REGNUM
return|;
comment|/* If the function has a nonlocal goto, $gp must hold the correct      global pointer for the target function.  */
if|if
condition|(
name|current_function_has_nonlocal_goto
condition|)
return|return
name|GLOBAL_POINTER_REGNUM
return|;
comment|/* If the gp is never referenced, there's no need to initialize it.      Note that reload can sometimes introduce constant pool references      into a function that otherwise didn't need them.  For example,      suppose we have an instruction like:  	  (set (reg:DF R1) (float:DF (reg:SI R2)))       If R2 turns out to be constant such as 1, the instruction may have a      REG_EQUAL note saying that R1 == 1.0.  Reload then has the option of      using this constant if R2 doesn't get allocated to a register.       In cases like these, reload will have added the constant to the pool      but no instruction will yet refer to it.  */
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|GLOBAL_POINTER_REGNUM
index|]
operator|&&
operator|!
name|current_function_uses_const_pool
operator|&&
operator|!
name|mips_function_has_gp_insn
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* We need a global pointer, but perhaps we can use a call-clobbered      register instead of $gp.  */
if|if
condition|(
name|TARGET_NEWABI
operator|&&
name|current_function_is_leaf
condition|)
for|for
control|(
name|regno
operator|=
name|GP_REG_FIRST
init|;
name|regno
operator|<=
name|GP_REG_LAST
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
name|regno
operator|!=
name|PIC_FUNCTION_ADDR_REGNUM
condition|)
return|return
name|regno
return|;
return|return
name|GLOBAL_POINTER_REGNUM
return|;
block|}
end_function

begin_comment
comment|/* Return true if the current function must save REGNO.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_save_reg_p
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
comment|/* We only need to save $gp for NewABI PIC.  */
if|if
condition|(
name|regno
operator|==
name|GLOBAL_POINTER_REGNUM
condition|)
return|return
operator|(
name|TARGET_ABICALLS
operator|&&
name|TARGET_NEWABI
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
operator|==
name|regno
operator|)
return|;
comment|/* Check call-saved registers.  */
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
name|true
return|;
comment|/* We need to save the old frame pointer before setting up a new one.  */
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
condition|)
return|return
name|true
return|;
comment|/* We need to save the incoming return address if it is ever clobbered      within the function.  */
if|if
condition|(
name|regno
operator|==
name|GP_REG_FIRST
operator|+
literal|31
operator|&&
name|regs_ever_live
index|[
name|regno
index|]
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
name|tree
name|return_type
decl_stmt|;
name|return_type
operator|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* $18 is a special case in mips16 code.  It may be used to call 	 a function which returns a floating point value, but it is 	 marked in call_used_regs.  */
if|if
condition|(
name|regno
operator|==
name|GP_REG_FIRST
operator|+
literal|18
operator|&&
name|regs_ever_live
index|[
name|regno
index|]
condition|)
return|return
name|true
return|;
comment|/* $31 is also a special case.  It will be used to copy a return 	 value into the floating point registers if the return value is 	 floating point.  */
if|if
condition|(
name|regno
operator|==
name|GP_REG_FIRST
operator|+
literal|31
operator|&&
name|mips16_hard_float
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|return_type
argument_list|,
name|current_function_decl
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|DECL_MODE
argument_list|(
name|return_type
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|return_type
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_FPVALUE
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the bytes needed to compute the frame pointer from the current    stack pointer.  SIZE is the size (in bytes) of the local variables.     MIPS stack frames look like:               Before call		        After call         +-----------------------+	+-----------------------+    high |			|       |      			|    mem. |		        |	|			|         |  caller's temps.    	|       |  caller's temps.    	| 	|       		|       |       	        |         +-----------------------+	+-----------------------+  	|       		|	|		        |         |  arguments on stack.  |	|  arguments on stack.  | 	|       		|	|			|         +-----------------------+	+-----------------------+  	|  4 words to save     	|	|  4 words to save	| 	|  arguments passed	|	|  arguments passed	| 	|  in registers, even	|	|  in registers, even	|     SP->|  if not passed.       |  VFP->|  if not passed.	| 	+-----------------------+       +-----------------------+ 					|		        |                                         |  fp register save     | 					|			| 					+-----------------------+ 					|		        |                                         |  gp register save     |                                         |       		| 					+-----------------------+ 					|			| 					|  local variables	| 					|			| 					+-----------------------+ 					|			|                                         |  alloca allocations   |         				|			| 					+-----------------------+ 					|			| 					|  GP save for V.4 abi	| 					|			| 					+-----------------------+ 					|			|                                         |  arguments on stack   |         				|		        | 					+-----------------------+                                         |  4 words to save      | 					|  arguments passed     |                                         |  in registers, even   |    low                              SP->|  if not passed.       |    memory        			+-----------------------+  */
end_comment

begin_function
name|HOST_WIDE_INT
name|compute_frame_size
parameter_list|(
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up */
name|HOST_WIDE_INT
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up */
name|HOST_WIDE_INT
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up */
name|HOST_WIDE_INT
name|cprestore_size
decl_stmt|;
comment|/* # bytes that the cprestore slot takes up */
name|HOST_WIDE_INT
name|gp_reg_rounded
decl_stmt|;
comment|/* # bytes needed to store gp after rounding */
name|HOST_WIDE_INT
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs */
name|HOST_WIDE_INT
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs */
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/* mask of saved gp registers */
name|unsigned
name|int
name|fmask
decl_stmt|;
comment|/* mask of saved fp registers */
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
operator|=
name|mips_global_pointer
argument_list|()
expr_stmt|;
name|gp_reg_size
operator|=
literal|0
expr_stmt|;
name|fp_reg_size
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|fmask
operator|=
literal|0
expr_stmt|;
name|var_size
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|args_size
operator|=
name|current_function_outgoing_args_size
expr_stmt|;
name|cprestore_size
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
name|STARTING_FRAME_OFFSET
argument_list|)
operator|-
name|args_size
expr_stmt|;
comment|/* The space set aside by STARTING_FRAME_OFFSET isn't needed in leaf      functions.  If the function has local variables, we're committed      to allocating it anyway.  Otherwise reclaim it here.  */
if|if
condition|(
name|var_size
operator|==
literal|0
operator|&&
name|current_function_is_leaf
condition|)
name|cprestore_size
operator|=
name|args_size
operator|=
literal|0
expr_stmt|;
comment|/* The MIPS 3.0 linker does not like functions that dynamically      allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it      looks like we are trying to create a second frame pointer to the      function, so allocate some stack space to make it happy.  */
if|if
condition|(
name|args_size
operator|==
literal|0
operator|&&
name|current_function_calls_alloca
condition|)
name|args_size
operator|=
literal|4
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|total_size
operator|=
name|var_size
operator|+
name|args_size
operator|+
name|cprestore_size
expr_stmt|;
comment|/* Calculate space needed for gp registers.  */
for|for
control|(
name|regno
operator|=
name|GP_REG_FIRST
init|;
name|regno
operator|<=
name|GP_REG_LAST
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|mips_save_reg_p
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|gp_reg_size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|gpr_mode
argument_list|)
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
name|GP_REG_FIRST
operator|)
expr_stmt|;
block|}
comment|/* We need to restore these for the handler.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|regno
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|gp_reg_size
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|gpr_mode
argument_list|)
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
name|GP_REG_FIRST
operator|)
expr_stmt|;
block|}
block|}
comment|/* This loop must iterate over the same space as its companion in      save_restore_insns.  */
for|for
control|(
name|regno
operator|=
operator|(
name|FP_REG_LAST
operator|-
name|FP_INC
operator|+
literal|1
operator|)
init|;
name|regno
operator|>=
name|FP_REG_FIRST
condition|;
name|regno
operator|-=
name|FP_INC
control|)
block|{
if|if
condition|(
name|mips_save_reg_p
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|fp_reg_size
operator|+=
name|FP_INC
operator|*
name|UNITS_PER_FPREG
expr_stmt|;
name|fmask
operator||=
operator|(
operator|(
literal|1
operator|<<
name|FP_INC
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|regno
operator|-
name|FP_REG_FIRST
operator|)
expr_stmt|;
block|}
block|}
name|gp_reg_rounded
operator|=
name|MIPS_STACK_ALIGN
argument_list|(
name|gp_reg_size
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|gp_reg_rounded
operator|+
name|MIPS_STACK_ALIGN
argument_list|(
name|fp_reg_size
argument_list|)
expr_stmt|;
comment|/* Add in the space required for saving incoming register arguments.  */
name|total_size
operator|+=
name|current_function_pretend_args_size
expr_stmt|;
name|total_size
operator|+=
name|MIPS_STACK_ALIGN
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|varargs_size
argument_list|)
expr_stmt|;
comment|/* Save other computed information.  */
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|var_size
operator|=
name|var_size
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
operator|=
name|args_size
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|cprestore_size
operator|=
name|cprestore_size
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_reg_size
operator|=
name|gp_reg_size
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fp_reg_size
operator|=
name|fp_reg_size
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fmask
operator|=
name|fmask
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|num_gp
operator|=
name|gp_reg_size
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|num_fp
operator|=
name|fp_reg_size
operator|/
operator|(
name|FP_INC
operator|*
name|UNITS_PER_FPREG
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|args_size
operator|+
name|cprestore_size
operator|+
name|var_size
operator|+
name|gp_reg_size
operator|-
name|GET_MODE_SIZE
argument_list|(
name|gpr_mode
argument_list|)
operator|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_sp_offset
operator|=
name|offset
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_save_offset
operator|=
name|offset
operator|-
name|total_size
expr_stmt|;
block|}
else|else
block|{
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_sp_offset
operator|=
literal|0
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_save_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fmask
condition|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|args_size
operator|+
name|cprestore_size
operator|+
name|var_size
operator|+
name|gp_reg_rounded
operator|+
name|fp_reg_size
operator|-
name|FP_INC
operator|*
name|UNITS_PER_FPREG
operator|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fp_sp_offset
operator|=
name|offset
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fp_save_offset
operator|=
name|offset
operator|-
name|total_size
expr_stmt|;
block|}
else|else
block|{
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fp_sp_offset
operator|=
literal|0
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fp_save_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ok, we're done.  */
return|return
name|total_size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame    pointer or argument pointer.  TO is either the stack pointer or    hard frame pointer.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|mips_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set OFFSET to the offset from the stack pointer.  */
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|FRAME_POINTER_REGNUM
case|:
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ARG_POINTER_REGNUM
case|:
name|offset
operator|=
operator|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|total_size
operator|-
name|current_function_pretend_args_size
operator|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|offset
operator|-=
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement RETURN_ADDR_RTX.  Note, we do not support moving    back to a previous frame.  */
end_comment

begin_function
name|rtx
name|mips_return_addr
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|const0_rtx
return|;
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|GP_REG_FIRST
operator|+
literal|31
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use FN to save or restore register REGNO.  MODE is the register's    mode and OFFSET is the offset of its save slot from the current    stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|mips_save_restore_reg
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|regno
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|mips_save_restore_fn
name|fn
parameter_list|)
block|{
name|rtx
name|mem
decl_stmt|;
name|mem
operator|=
name|gen_frame_mem
argument_list|(
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|fn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call FN for each register that is saved by the current function.    SP_OFFSET is the offset of the current stack pointer from the start    of the frame.  */
end_comment

begin_function
specifier|static
name|void
name|mips_for_each_saved_reg
parameter_list|(
name|HOST_WIDE_INT
name|sp_offset
parameter_list|,
name|mips_save_restore_fn
name|fn
parameter_list|)
block|{
define|#
directive|define
name|BITSET_P
parameter_list|(
name|VALUE
parameter_list|,
name|BIT
parameter_list|)
value|(((VALUE)& (1L<< (BIT))) != 0)
name|enum
name|machine_mode
name|fpr_mode
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Save registers starting from high to low.  The debuggers prefer at least      the return register be stored at func+4, and also it allows us not to      need a nop in the epilog if at least one register is reloaded in      addition to return address.  */
name|offset
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_sp_offset
operator|-
name|sp_offset
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GP_REG_LAST
init|;
name|regno
operator|>=
name|GP_REG_FIRST
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|BITSET_P
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|mask
argument_list|,
name|regno
operator|-
name|GP_REG_FIRST
argument_list|)
condition|)
block|{
name|mips_save_restore_reg
argument_list|(
name|gpr_mode
argument_list|,
name|regno
argument_list|,
name|offset
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|gpr_mode
argument_list|)
expr_stmt|;
block|}
comment|/* This loop must iterate over the same space as its companion in      compute_frame_size.  */
name|offset
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fp_sp_offset
operator|-
name|sp_offset
expr_stmt|;
name|fpr_mode
operator|=
operator|(
name|TARGET_SINGLE_FLOAT
condition|?
name|SFmode
else|:
name|DFmode
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
operator|(
name|FP_REG_LAST
operator|-
name|FP_INC
operator|+
literal|1
operator|)
init|;
name|regno
operator|>=
name|FP_REG_FIRST
condition|;
name|regno
operator|-=
name|FP_INC
control|)
if|if
condition|(
name|BITSET_P
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fmask
argument_list|,
name|regno
operator|-
name|FP_REG_FIRST
argument_list|)
condition|)
block|{
name|mips_save_restore_reg
argument_list|(
name|fpr_mode
argument_list|,
name|regno
argument_list|,
name|offset
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|fpr_mode
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|BITSET_P
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we're generating n32 or n64 abicalls, and the current function    does not use $28 as its global pointer, emit a cplocal directive.    Use pic_offset_table_rtx as the argument to the directive.  */
end_comment

begin_function
specifier|static
name|void
name|mips_output_cplocal
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_EXPLICIT_RELOCS
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
operator|>
literal|0
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
operator|!=
name|GLOBAL_POINTER_REGNUM
condition|)
name|output_asm_insn
argument_list|(
literal|".cplocal %+"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the style of GP load sequence that is being used for the    current function.  */
end_comment

begin_function
name|enum
name|mips_loadgp_style
name|mips_current_loadgp_style
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_ABICALLS
operator|||
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
operator|==
literal|0
condition|)
return|return
name|LOADGP_NONE
return|;
if|if
condition|(
name|TARGET_ABSOLUTE_ABICALLS
condition|)
return|return
name|LOADGP_ABSOLUTE
return|;
return|return
name|TARGET_NEWABI
condition|?
name|LOADGP_NEWABI
else|:
name|LOADGP_OLDABI
return|;
block|}
end_function

begin_comment
comment|/* The __gnu_local_gp symbol.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|mips_gnu_local_gp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If we're generating n32 or n64 abicalls, emit instructions    to set up the global pointer.  */
end_comment

begin_function
specifier|static
name|void
name|mips_emit_loadgp
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|offset
decl_stmt|,
name|incoming_address
decl_stmt|;
switch|switch
condition|(
name|mips_current_loadgp_style
argument_list|()
condition|)
block|{
case|case
name|LOADGP_ABSOLUTE
case|:
if|if
condition|(
name|mips_gnu_local_gp
operator|==
name|NULL
condition|)
block|{
name|mips_gnu_local_gp
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__gnu_local_gp"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|mips_gnu_local_gp
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_loadgp_noshared
argument_list|(
name|mips_gnu_local_gp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOADGP_NEWABI
case|:
name|addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|mips_unspec_address
argument_list|(
name|addr
argument_list|,
name|SYMBOL_GOTOFF_LOADGP
argument_list|)
expr_stmt|;
name|incoming_address
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_FUNCTION_ADDR_REGNUM
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_loadgp
argument_list|(
name|offset
argument_list|,
name|incoming_address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_EXPLICIT_RELOCS
condition|)
name|emit_insn
argument_list|(
name|gen_loadgp_blockage
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Set up the stack and frame (if desired) for the function.  */
end_comment

begin_function
specifier|static
name|void
name|mips_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|HOST_WIDE_INT
name|tsize
init|=
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|total_size
decl_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|&&
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|SDB_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* In mips16 mode, we may need to generate a 32 bit to handle      floating point arguments.  The linker will arrange for any 32 bit      functions to call this stub, which will then jump to the 16 bit      function proper.  */
if|if
condition|(
name|TARGET_MIPS16
operator|&&
operator|!
name|TARGET_SOFT_FLOAT
operator|&&
name|current_function_args_info
operator|.
name|fp_code
operator|!=
literal|0
condition|)
name|build_mips16_function_stub
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FUNCTION_NAME_ALREADY_DECLARED
condition|)
block|{
comment|/* Get the function name the same way that toplev.c does before calling 	 assemble_start_function.  This is needed so that the name used here 	 exactly matches the name used in ASM_DECLARE_FUNCTION_NAME.  */
name|fnname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.ent\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Stop mips_file_end from treating this function as external.  */
if|if
condition|(
name|TARGET_IRIX
operator|&&
name|mips_abi
operator|==
name|ABI_32
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|DECL_NAME
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
comment|/* .frame FRAMEREG, FRAMESIZE, RETREG */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame\t%s,"
name|HOST_WIDE_INT_PRINT_DEC
literal|",%s\t\t"
literal|"# vars= "
name|HOST_WIDE_INT_PRINT_DEC
literal|", regs= %d/%d"
literal|", args= "
name|HOST_WIDE_INT_PRINT_DEC
literal|", gp= "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
operator|(
name|reg_names
index|[
operator|(
name|frame_pointer_needed
operator|)
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
index|]
operator|)
argument_list|,
operator|(
operator|(
name|frame_pointer_needed
operator|&&
name|TARGET_MIPS16
operator|)
condition|?
name|tsize
operator|-
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
else|:
name|tsize
operator|)
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|31
index|]
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|var_size
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|num_gp
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|num_fp
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|cprestore_size
argument_list|)
expr_stmt|;
comment|/* .mask MASK, GPOFFSET; .fmask FPOFFSET */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask\t0x%08x,"
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|mask
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|gp_save_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask\t0x%08x,"
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fmask
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fp_save_offset
argument_list|)
expr_stmt|;
comment|/* Require: 	 OLD_SP == *FRAMEREG + FRAMESIZE => can find old_sp from nominated FP reg. 	 HIGHEST_GP_SAVED == *FRAMEREG + FRAMESIZE + GPOFFSET => can find saved regs.  */
block|}
if|if
condition|(
name|mips_current_loadgp_style
argument_list|()
operator|==
name|LOADGP_OLDABI
condition|)
block|{
comment|/* Handle the initialization of $gp for SVR4 PIC.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
condition|)
name|output_asm_insn
argument_list|(
literal|"%(.cpload\t%^%)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"%(.cpload\t%^\n\t%<"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
condition|)
name|output_asm_insn
argument_list|(
literal|"%(%<"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tell the assembler which register we're using as the global      pointer.  This is needed for thunks, since they can use either      explicit relocs or assembler macros.  */
name|mips_output_cplocal
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make the last instruction frame related and note that it performs    the operation described by FRAME_PATTERN.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_frame_expr
parameter_list|(
name|rtx
name|frame_pattern
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|frame_pattern
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a frame-related rtx that stores REG at MEM.    REG must be a single register.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_frame_set
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
comment|/* If we're saving the return address register and the dwarf return      address column differs from the hard register number, adjust the      note reg to refer to the former.  */
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|GP_REG_FIRST
operator|+
literal|31
operator|&&
name|DWARF_FRAME_RETURN_COLUMN
operator|!=
name|GP_REG_FIRST
operator|+
literal|31
condition|)
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|)
expr_stmt|;
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|set
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Save register REG to MEM.  Make the instruction frame-related.  */
end_comment

begin_function
specifier|static
name|void
name|mips_save_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|DFmode
operator|&&
operator|!
name|TARGET_FLOAT64
condition|)
block|{
name|rtx
name|x1
decl_stmt|,
name|x2
decl_stmt|;
if|if
condition|(
name|mips_split_64bit_move_p
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
condition|)
name|mips_split_64bit_move
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|x1
operator|=
name|mips_frame_set
argument_list|(
name|mips_subword
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mips_subword
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x2
operator|=
name|mips_frame_set
argument_list|(
name|mips_subword
argument_list|(
name|mem
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mips_subword
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mips_set_frame_expr
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|!=
name|GP_REG_FIRST
operator|+
literal|31
operator|&&
operator|!
name|M16_REG_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Save a non-mips16 register by moving it through a temporary. 	     We don't need to do this for $31 since there's a special 	     instruction for it.  */
name|emit_move_insn
argument_list|(
name|MIPS_PROLOGUE_TEMP
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|MIPS_PROLOGUE_TEMP
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mips_set_frame_expr
argument_list|(
name|mips_frame_set
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|mips_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
operator|>
literal|0
condition|)
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|=
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
expr_stmt|;
name|size
operator|=
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP      bytes beforehand; this is enough to cover the register save area      without going out of range.  */
if|if
condition|(
operator|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|mask
operator||
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fmask
operator|)
operator|!=
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|step1
decl_stmt|;
name|step1
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|MIPS_MAX_FIRST_STACK_STEP
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|step1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|size
operator|-=
name|step1
expr_stmt|;
name|mips_for_each_saved_reg
argument_list|(
name|size
argument_list|,
name|mips_save_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the rest of the frame.  */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|SMALL_OPERAND
argument_list|(
operator|-
name|size
argument_list|)
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|MIPS_PROLOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
comment|/* There are no instructions to add or subtract registers 		 from the stack pointer, so use the frame pointer as a 		 temporary.  We should always be using a frame pointer 		 in this case anyway.  */
name|gcc_assert
argument_list|(
name|frame_pointer_needed
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sub3_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|MIPS_PROLOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_sub3_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|MIPS_PROLOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Describe the combined effect of the previous instructions.  */
name|mips_set_frame_expr
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up the frame pointer, if we're using one.  In mips16 code,      we point the frame pointer ahead of the outgoing argument area.      This should allow more variables& incoming arguments to be      accessed with unextended instructions.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset
init|=
name|GEN_INT
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|SMALL_OPERAND
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
argument_list|)
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|MIPS_PROLOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|MIPS_PROLOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mips_set_frame_expr
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|RTX_FRAME_RELATED_P
argument_list|(
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|mips_emit_loadgp
argument_list|()
expr_stmt|;
comment|/* If generating o32/o64 abicalls, save $gp on the stack.  */
if|if
condition|(
name|TARGET_ABICALLS
operator|&&
operator|!
name|TARGET_NEWABI
operator|&&
operator|!
name|current_function_is_leaf
condition|)
name|emit_insn
argument_list|(
name|gen_cprestore
argument_list|(
name|GEN_INT
argument_list|(
name|current_function_outgoing_args_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  */
if|if
condition|(
name|current_function_profile
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any necessary cleanup after a function to restore stack, frame,    and regs.  */
end_comment

begin_define
define|#
directive|define
name|RA_MASK
value|BITMASK_HIGH
end_define

begin_comment
comment|/* 1<< 31 */
end_comment

begin_function
specifier|static
name|void
name|mips_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Reinstate the normal $gp.  */
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|=
name|GLOBAL_POINTER_REGNUM
expr_stmt|;
name|mips_output_cplocal
argument_list|()
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
condition|)
block|{
comment|/* Avoid using %>%) since it adds excess whitespace.  */
name|output_asm_insn
argument_list|(
literal|".set\tmacro"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".set\treorder"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_noreorder
operator|=
name|set_nomacro
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FUNCTION_NAME_ALREADY_DECLARED
operator|&&
operator|!
name|flag_inhibit_size_directive
condition|)
block|{
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
comment|/* Get the function name the same way that toplev.c does before calling 	 assemble_start_function.  This is needed so that the name used here 	 exactly matches the name used in ASM_DECLARE_FUNCTION_NAME.  */
name|fnname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.end\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit instructions to restore register REG from slot MEM.  */
end_comment

begin_function
specifier|static
name|void
name|mips_restore_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
comment|/* There's no mips16 instruction to load $31 directly.  Load into      $7 instead and adjust the return insn appropriately.  */
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|GP_REG_FIRST
operator|+
literal|31
condition|)
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
operator|&&
operator|!
name|M16_REG_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Can't restore directly; move through a temporary.  */
name|emit_move_insn
argument_list|(
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the epilogue into a bunch of separate insns.  SIBCALL_P is true    if this epilogue precedes a sibling call, false if it is for a normal    "epilogue" pattern.  */
end_comment

begin_function
name|void
name|mips_expand_epilogue
parameter_list|(
name|int
name|sibcall_p
parameter_list|)
block|{
name|HOST_WIDE_INT
name|step1
decl_stmt|,
name|step2
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|target
decl_stmt|;
if|if
condition|(
operator|!
name|sibcall_p
operator|&&
name|mips_can_use_return_insn
argument_list|()
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Split the frame into two.  STEP1 is the amount of stack we should      deallocate before restoring the registers.  STEP2 is the amount we      should deallocate afterwards.       Start off by assuming that no registers need to be restored.  */
name|step1
operator|=
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|total_size
expr_stmt|;
name|step2
operator|=
literal|0
expr_stmt|;
comment|/* Work out which register holds the frame address.  Account for the      frame pointer offset used by mips16 code.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|base
operator|=
name|stack_pointer_rtx
expr_stmt|;
else|else
block|{
name|base
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
name|step1
operator|-=
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|args_size
expr_stmt|;
block|}
comment|/* If we need to restore registers, deallocate as much stack as      possible in the second step without going out of range.  */
if|if
condition|(
operator|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|mask
operator||
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|fmask
operator|)
operator|!=
literal|0
condition|)
block|{
name|step2
operator|=
name|MIN
argument_list|(
name|step1
argument_list|,
name|MIPS_MAX_FIRST_STACK_STEP
argument_list|)
expr_stmt|;
name|step1
operator|-=
name|step2
expr_stmt|;
block|}
comment|/* Set TARGET to BASE + STEP1.  */
name|target
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|step1
operator|>
literal|0
condition|)
block|{
name|rtx
name|adjust
decl_stmt|;
comment|/* Get an rtx for STEP1 that we can add to BASE.  */
name|adjust
operator|=
name|GEN_INT
argument_list|(
name|step1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SMALL_OPERAND
argument_list|(
name|step1
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* Normal mode code can copy the result straight into $sp.  */
if|if
condition|(
operator|!
name|TARGET_MIPS16
condition|)
name|target
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|target
argument_list|,
name|base
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy TARGET into the stack pointer.  */
if|if
condition|(
name|target
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* If we're using addressing macros for n32/n64 abicalls, $gp is      implicitly used by all SYMBOL_REFs.  We must emit a blockage      insn before restoring it.  */
if|if
condition|(
name|TARGET_ABICALLS
operator|&&
name|TARGET_NEWABI
operator|&&
operator|!
name|TARGET_EXPLICIT_RELOCS
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Restore the registers.  */
name|mips_for_each_saved_reg
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|total_size
operator|-
name|step2
argument_list|,
name|mips_restore_reg
argument_list|)
expr_stmt|;
comment|/* Deallocate the final bit of the frame.  */
if|if
condition|(
name|step2
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|step2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add in the __builtin_eh_return stack adjustment.  We need to      use a temporary in mips16 code.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
name|emit_move_insn
argument_list|(
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|EH_RETURN_STACKADJ_RTX
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|MIPS_EPILOGUE_TEMP
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|EH_RETURN_STACKADJ_RTX
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sibcall_p
condition|)
block|{
comment|/* The mips16 loads the return address into $7, not $31.  */
if|if
condition|(
name|TARGET_MIPS16
operator|&&
operator|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|mask
operator|&
name|RA_MASK
operator|)
operator|!=
literal|0
condition|)
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GP_REG_FIRST
operator|+
literal|7
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GP_REG_FIRST
operator|+
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if this function is known to have a null epilogue.    This allows the optimizer to omit jumps to jumps if no stack    was created.  */
end_comment

begin_function
name|int
name|mips_can_use_return_insn
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|return_type
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|regs_ever_live
index|[
literal|31
index|]
operator|||
name|current_function_profile
condition|)
return|return
literal|0
return|;
name|return_type
operator|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* In mips16 mode, a function which returns a floating point value      needs to arrange to copy the return value into the floating point      registers.  */
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|mips16_hard_float
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|return_type
argument_list|,
name|current_function_decl
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|DECL_MODE
argument_list|(
name|return_type
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|DECL_MODE
argument_list|(
name|return_type
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_FPVALUE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|initialized
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|frame
operator|.
name|total_size
operator|==
literal|0
return|;
return|return
name|compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text    in order to avoid duplicating too much logic from elsewhere.  */
end_comment

begin_function
specifier|static
name|void
name|mips_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk_fndecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|this
decl_stmt|,
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|insn
decl_stmt|,
name|fnaddr
decl_stmt|;
comment|/* Pretend to be a post-reload pass while generating rtl.  */
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|reset_block_changes
argument_list|()
expr_stmt|;
comment|/* Pick a global pointer for -mabicalls.  Use $15 rather than $28      for TARGET_NEWABI since the latter is a call-saved register.  */
if|if
condition|(
name|TARGET_ABICALLS
condition|)
name|cfun
operator|->
name|machine
operator|->
name|global_pointer
operator|=
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|=
name|TARGET_NEWABI
condition|?
literal|15
else|:
name|GLOBAL_POINTER_REGNUM
expr_stmt|;
comment|/* Set up the global pointer for n32 or n64 abicalls.  */
name|mips_emit_loadgp
argument_list|()
expr_stmt|;
comment|/* We need two temporary registers in some cases.  */
name|temp1
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Find out which register contains the "this" pointer.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|)
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GP_ARG_FIRST
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GP_ARG_FIRST
argument_list|)
expr_stmt|;
comment|/* Add DELTA to THIS.  */
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
name|rtx
name|offset
init|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SMALL_OPERAND
argument_list|(
name|delta
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|temp1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|temp1
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */
if|if
condition|(
name|vcall_offset
operator|!=
literal|0
condition|)
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* Set TEMP1 to *THIS.  */
name|emit_move_insn
argument_list|(
name|temp1
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */
name|addr
operator|=
name|mips_add_offset
argument_list|(
name|temp2
argument_list|,
name|temp1
argument_list|,
name|vcall_offset
argument_list|)
expr_stmt|;
comment|/* Load the offset and add it to THIS.  */
name|emit_move_insn
argument_list|(
name|temp1
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add3_insn
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|temp1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Jump to the target function.  Use a sibcall if direct jumps are      allowed, otherwise load the address into a register first.  */
name|fnaddr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
operator|||
name|TARGET_ABICALLS
operator|||
name|TARGET_LONG_CALLS
condition|)
block|{
comment|/* This is messy.  gas treats "la $25,foo" as part of a call 	 sequence and may allow a global "foo" to be lazily bound. 	 The general move patterns therefore reject this combination.  	 In this context, lazy binding would actually be OK for o32 and o64, 	 but it's still wrong for n32 and n64; see mips_load_call_address. 	 We must therefore load the address via a temporary register if 	 mips_dangerous_for_la25_p.  	 If we jump to the temporary register rather than $25, the assembler 	 can use the move insn to fill the jump's delay slot.  */
if|if
condition|(
name|TARGET_ABICALLS
operator|&&
operator|!
name|mips_dangerous_for_la25_p
argument_list|(
name|fnaddr
argument_list|)
condition|)
name|temp1
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_FUNCTION_ADDR_REGNUM
argument_list|)
expr_stmt|;
name|mips_load_call_address
argument_list|(
name|temp1
argument_list|,
name|fnaddr
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ABICALLS
operator|&&
name|REGNO
argument_list|(
name|temp1
argument_list|)
operator|!=
name|PIC_FUNCTION_ADDR_REGNUM
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|PIC_FUNCTION_ADDR_REGNUM
argument_list|)
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_indirect_jump
argument_list|(
name|temp1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_sibcall_internal
argument_list|(
name|fnaddr
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Run just enough of rest_of_compilation.  This sequence was      "borrowed" from alpha.c.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|insn_locators_initialize
argument_list|()
expr_stmt|;
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
condition|)
name|mips16_lay_out_constants
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
comment|/* Clean up the vars set above.  Note that final_end_function resets      the global pointer for us.  */
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns nonzero if X contains a SYMBOL_REF.  */
end_comment

begin_function
specifier|static
name|int
name|symbolic_expression_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|symbolic_expression_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|UNARY_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|symbolic_expression_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|symbolic_expression_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|symbolic_expression_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Choose the section to use for the constant rtx expression X that has    mode MODE.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|mips_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
comment|/* In mips16 mode, the constant table always goes in the same section          as the function, so that constants can be loaded using PC relative          addressing.  */
return|return
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_EMBEDDED_DATA
condition|)
block|{
comment|/* For embedded applications, always put constants in read-only data, 	 in order to reduce RAM usage.  */
return|return
name|mergeable_constant_section
argument_list|(
name|mode
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
comment|/* For hosted applications, always put constants in small data if 	 possible, as this gives the best performance.  */
comment|/* ??? Consider using mergeable small data sections.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
operator|(
name|unsigned
operator|)
name|mips_section_threshold
operator|&&
name|mips_section_threshold
operator|>
literal|0
condition|)
return|return
name|get_named_section
argument_list|(
name|NULL
argument_list|,
literal|".sdata"
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|flag_pic
operator|&&
name|symbolic_expression_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|get_named_section
argument_list|(
name|NULL
argument_list|,
literal|".data.rel.ro"
argument_list|,
literal|3
argument_list|)
return|;
else|else
return|return
name|mergeable_constant_section
argument_list|(
name|mode
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implement TARGET_ASM_FUNCTION_RODATA_SECTION.     The complication here is that, with the combination TARGET_ABICALLS&& !TARGET_GPWORD, jump tables will use absolute addresses, and should    therefore not be included in the read-only part of a DSO.  Handle such    cases by selecting a normal data section instead of a read-only one.    The logic apes that in default_function_rodata_section.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|mips_function_rodata_section
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_ABICALLS
operator|||
name|TARGET_GPWORD
condition|)
return|return
name|default_function_rodata_section
argument_list|(
name|decl
argument_list|)
return|;
if|if
condition|(
name|decl
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|rname
init|=
name|ASTRDUP
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|rname
index|[
literal|14
index|]
operator|=
literal|'d'
expr_stmt|;
return|return
name|get_section
argument_list|(
name|rname
argument_list|,
name|SECTION_LINKONCE
operator||
name|SECTION_WRITE
argument_list|,
name|decl
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|flag_function_sections
operator|&&
name|flag_data_sections
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".text."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|rname
init|=
name|ASTRDUP
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|rname
operator|+
literal|1
argument_list|,
literal|"data"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|get_section
argument_list|(
name|rname
argument_list|,
name|SECTION_WRITE
argument_list|,
name|decl
argument_list|)
return|;
block|}
block|}
return|return
name|data_section
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_IN_SMALL_DATA_P.  This function controls whether    locally-defined objects go in a small data section.  It also controls    the setting of the SYMBOL_REF_SMALL_P flag, which in turn helps    mips_classify_symbol decide when to use %gp_rel(...)($gp) accesses.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_in_small_data_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
comment|/* We don't yet generate small-data references for -mabicalls.  See related      -G handling in override_options.  */
if|if
condition|(
name|TARGET_ABICALLS
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Reject anything that isn't in a known small-data section.  */
name|name
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* If a symbol is defined externally, the assembler will use the 	 usual -G rules when deciding how to implement macros.  */
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|TARGET_EMBEDDED_DATA
condition|)
block|{
comment|/* Don't put constants into the small data section: we want them 	 to be in ROM rather than RAM.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|mips_section_threshold
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_USE_ANCHORS_FOR_SYMBOL_P.  We don't want to use    anchors for small data: the GP register acts as an anchor in that    case.  We also don't want to use them for PC-relative accesses,    where the PC acts as an anchor.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_use_anchors_for_symbol_p
parameter_list|(
name|rtx
name|symbol
parameter_list|)
block|{
switch|switch
condition|(
name|mips_classify_symbol
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_CONSTANT_POOL
case|:
case|case
name|SYMBOL_SMALL_DATA
case|:
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See whether VALTYPE is a record whose fields should be returned in    floating-point registers.  If so, return the number of fields and    list them in FIELDS (which should have two elements).  Return 0    otherwise.     For n32& n64, a structure with one or two fields is returned in    floating-point registers as long as every field has a floating-point    type.  */
end_comment

begin_function
specifier|static
name|int
name|mips_fpr_return_fields
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
modifier|*
name|fields
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_NEWABI
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
literal|0
return|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|valtype
argument_list|)
init|;
name|field
operator|!=
literal|0
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
return|return
literal|0
return|;
name|fields
index|[
name|i
operator|++
index|]
operator|=
name|field
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_RETURN_IN_MSB.  For n32& n64, we should return    a value in the most significant part of $2/$3 if:        - the target is big-endian;        - the value has a structure or union type (we generalize this to 	cover aggregates from other languages too); and        - the structure is not returned in floating-point registers.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_return_in_msb
parameter_list|(
name|tree
name|valtype
parameter_list|)
block|{
name|tree
name|fields
index|[
literal|2
index|]
decl_stmt|;
return|return
operator|(
name|TARGET_NEWABI
operator|&&
name|TARGET_BIG_ENDIAN
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
name|mips_fpr_return_fields
argument_list|(
name|valtype
argument_list|,
name|fields
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a composite value in a pair of floating-point registers.    MODE1 and OFFSET1 are the mode and byte offset for the first value,    likewise MODE2 and OFFSET2 for the second.  MODE is the mode of the    complete value.     For n32& n64, $f0 always holds the first value and $f2 the second.    Otherwise the values are packed together as closely as possible.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_return_fpr_pair
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|mode1
parameter_list|,
name|HOST_WIDE_INT
name|offset1
parameter_list|,
name|enum
name|machine_mode
name|mode2
parameter_list|,
name|HOST_WIDE_INT
name|offset2
parameter_list|)
block|{
name|int
name|inc
decl_stmt|;
name|inc
operator|=
operator|(
name|TARGET_NEWABI
condition|?
literal|2
else|:
name|FP_INC
operator|)
expr_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode1
argument_list|,
name|FP_RETURN
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset1
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode2
argument_list|,
name|FP_RETURN
operator|+
name|inc
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,    VALTYPE is the return type and MODE is VOIDmode.  For libcalls,    VALTYPE is null and MODE is the mode of the return value.  */
end_comment

begin_function
name|rtx
name|mips_function_value
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|func
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|valtype
condition|)
block|{
name|tree
name|fields
index|[
literal|2
index|]
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|unsignedp
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
comment|/* Since we define TARGET_PROMOTE_FUNCTION_RETURN that returns 	 true, we must promote the mode just as PROMOTE_MODE does.  */
name|mode
operator|=
name|promote_mode
argument_list|(
name|valtype
argument_list|,
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Handle structures whose fields are returned in $f0/$f2.  */
switch|switch
condition|(
name|mips_fpr_return_fields
argument_list|(
name|valtype
argument_list|,
name|fields
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FP_RETURN
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|mips_return_fpr_pair
argument_list|(
name|mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
name|int_byte_position
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|int_byte_position
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/* If a value is passed in the most significant part of a register, see 	 whether we have to round the mode up to a whole number of words.  */
if|if
condition|(
name|mips_return_in_msb
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|%
name|UNITS_PER_WORD
operator|!=
literal|0
condition|)
block|{
name|size
operator|+=
name|UNITS_PER_WORD
operator|-
name|size
operator|%
name|UNITS_PER_WORD
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For EABI, the class of return register depends entirely on MODE. 	 For example, "struct { some_type x; }" and "union { some_type x; }" 	 are returned in the same way as a bare "some_type" would be. 	 Other ABIs only use FPRs for scalar, complex or vector types.  */
if|if
condition|(
name|mips_abi
operator|!=
name|ABI_EABI
operator|&&
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|valtype
argument_list|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_RETURN
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_FLOAT
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_HWFPVALUE
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FP_RETURN
argument_list|)
return|;
comment|/* Handle long doubles for n32& n64.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
return|return
name|mips_return_fpr_pair
argument_list|(
name|mode
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
argument_list|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_HWFPVALUE
operator|*
literal|2
condition|)
return|return
name|mips_return_fpr_pair
argument_list|(
name|mode
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|2
argument_list|)
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GP_RETURN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero when an argument must be passed by reference.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|mips_abi
operator|==
name|ABI_EABI
condition|)
block|{
name|int
name|size
decl_stmt|;
comment|/* ??? How should SCmode be handled?  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|type
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|size
operator|==
operator|-
literal|1
operator|||
name|size
operator|>
name|UNITS_PER_WORD
return|;
block|}
else|else
block|{
comment|/* If we have a variable-sized parameter, we have no choice.  */
return|return
name|targetm
operator|.
name|calls
operator|.
name|must_pass_in_stack
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|mips_callee_copies
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|named
parameter_list|)
block|{
return|return
name|mips_abi
operator|==
name|ABI_EABI
operator|&&
name|named
return|;
block|}
end_function

begin_comment
comment|/* Return true if registers of class CLASS cannot change from mode FROM    to mode TO.  */
end_comment

begin_function
name|bool
name|mips_cannot_change_mode_class
parameter_list|(
name|enum
name|machine_mode
name|from
parameter_list|,
name|enum
name|machine_mode
name|to
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
if|if
condition|(
name|MIN
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|from
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|MAX
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|from
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|TARGET_BIG_ENDIAN
condition|)
block|{
comment|/* When a multi-word value is stored in paired floating-point 	     registers, the first register always holds the low word. 	     We therefore can't allow FPRs to change between single-word 	     and multi-word modes.  */
if|if
condition|(
name|FP_INC
operator|>
literal|1
operator|&&
name|reg_classes_intersect_p
argument_list|(
name|FP_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* LO_REGNO == HI_REGNO + 1, so if a multi-word value is stored 	     in LO and HI, the high word always comes first.  We therefore 	     can't allow values stored in HI to change between single-word 	     and multi-word modes. 	     This rule applies to both the original HI/LO pair and the new 	     DSP accumulators.  */
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|ACC_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
comment|/* Loading a 32-bit value into a 64-bit floating-point register      will not sign-extend the value, despite what LOAD_EXTEND_OP says.      We can't allow 64-bit float registers to change from SImode to      to a wider mode.  */
if|if
condition|(
name|TARGET_FLOAT64
operator|&&
name|from
operator|==
name|SImode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|to
argument_list|)
operator|>=
name|UNITS_PER_WORD
operator|&&
name|reg_classes_intersect_p
argument_list|(
name|FP_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if X should not be moved directly into register $25.    We need this because many versions of GAS will treat "la $25,foo" as    part of a call sequence and so allow a global "foo" to be lazily bound.  */
end_comment

begin_function
name|bool
name|mips_dangerous_for_la25_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
return|return
name|false
return|;
name|mips_split_const
argument_list|(
name|x
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
return|return
name|global_got_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement PREFERRED_RELOAD_CLASS.  */
end_comment

begin_function
name|enum
name|reg_class
name|mips_preferred_reload_class
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
if|if
condition|(
name|mips_dangerous_for_la25_p
argument_list|(
name|x
argument_list|)
operator|&&
name|reg_class_subset_p
argument_list|(
name|LEA_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|LEA_REGS
return|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|reg_class_subset_p
argument_list|(
name|FP_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|FP_REGS
return|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|GR_REGS
argument_list|,
name|class
argument_list|)
condition|)
name|class
operator|=
name|GR_REGS
expr_stmt|;
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|reg_class_subset_p
argument_list|(
name|M16_REGS
argument_list|,
name|class
argument_list|)
condition|)
name|class
operator|=
name|M16_REGS
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* This function returns the register class required for a secondary    register when copying between one of the registers in CLASS, and X,    using MODE.  If IN_P is nonzero, the copy is going from X to the    register, otherwise the register is the source.  A return value of    NO_REGS means that no secondary register is required.  */
end_comment

begin_function
name|enum
name|reg_class
name|mips_secondary_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|in_p
parameter_list|)
block|{
name|enum
name|reg_class
name|gr_regs
init|=
name|TARGET_MIPS16
condition|?
name|M16_REGS
else|:
name|GR_REGS
decl_stmt|;
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|gp_reg_p
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|gp_reg_p
operator|=
name|TARGET_MIPS16
condition|?
name|M16_REG_P
argument_list|(
name|regno
argument_list|)
else|:
name|GP_REG_P
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_dangerous_for_la25_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|gr_regs
operator|=
name|LEA_REGS
expr_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
literal|25
argument_list|)
condition|)
return|return
name|gr_regs
return|;
block|}
comment|/* Copying from HI or LO to anywhere other than a general register      requires a general register.      This rule applies to both the original HI/LO pair and the new      DSP accumulators.  */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|ACC_REGS
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|in_p
condition|)
block|{
comment|/* We can't really copy to HI or LO at all in mips16 mode.  */
return|return
name|M16_REGS
return|;
block|}
return|return
name|gp_reg_p
condition|?
name|NO_REGS
else|:
name|gr_regs
return|;
block|}
if|if
condition|(
name|ACC_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
operator|&&
operator|!
name|in_p
condition|)
block|{
comment|/* We can't really copy to HI or LO at all in mips16 mode.  */
return|return
name|M16_REGS
return|;
block|}
return|return
name|class
operator|==
name|gr_regs
condition|?
name|NO_REGS
else|:
name|gr_regs
return|;
block|}
comment|/* We can only copy a value to a condition code register from a      floating point register, and even then we require a scratch      floating point register.  We can only copy a value out of a      condition code register into a general register.  */
if|if
condition|(
name|class
operator|==
name|ST_REGS
condition|)
block|{
if|if
condition|(
name|in_p
condition|)
return|return
name|FP_REGS
return|;
return|return
name|gp_reg_p
condition|?
name|NO_REGS
else|:
name|gr_regs
return|;
block|}
if|if
condition|(
name|ST_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|in_p
condition|)
return|return
name|FP_REGS
return|;
return|return
name|class
operator|==
name|gr_regs
condition|?
name|NO_REGS
else|:
name|gr_regs
return|;
block|}
if|if
condition|(
name|class
operator|==
name|FP_REGS
condition|)
block|{
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* In this case we can use lwc1, swc1, ldc1 or sdc1.  */
return|return
name|NO_REGS
return|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
comment|/* We can use the l.s and l.d macros to load floating-point 	     constants.  ??? For l.s, we could probably get better 	     code by returning GR_REGS here.  */
return|return
name|NO_REGS
return|;
block|}
elseif|else
if|if
condition|(
name|gp_reg_p
operator|||
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */
return|return
name|NO_REGS
return|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* In this case we can use mov.s or mov.d.  */
return|return
name|NO_REGS
return|;
block|}
else|else
block|{
comment|/* Otherwise, we need to reload through an integer register.  */
return|return
name|gr_regs
return|;
block|}
block|}
comment|/* In mips16 mode, going between memory and anything but M16_REGS      requires an M16_REG.  */
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
if|if
condition|(
name|class
operator|!=
name|M16_REGS
operator|&&
name|class
operator|!=
name|M16_NA_REGS
condition|)
block|{
if|if
condition|(
name|gp_reg_p
condition|)
return|return
name|NO_REGS
return|;
return|return
name|M16_REGS
return|;
block|}
if|if
condition|(
operator|!
name|gp_reg_p
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|M16_REGS
operator|||
name|class
operator|==
name|M16_NA_REGS
condition|)
return|return
name|NO_REGS
return|;
return|return
name|M16_REGS
return|;
block|}
block|}
return|return
name|NO_REGS
return|;
block|}
end_function

begin_comment
comment|/* Implement CLASS_MAX_NREGS.     Usually all registers are word-sized.  The only supported exception    is -mgp64 -msingle-float, which has 64-bit words but 32-bit float    registers.  A word-based calculation is correct even in that case,    since -msingle-float disallows multi-FPR values.     The FP status registers are an exception to this rule.  They are always    4 bytes wide as they only hold condition code modes, and CCmode is always    considered to be 4 bytes wide.  */
end_comment

begin_function
name|int
name|mips_class_max_nregs
parameter_list|(
name|enum
name|reg_class
name|class
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|class
operator|==
name|ST_REGS
condition|)
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
return|;
else|else
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mips_valid_pointer_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|mode
operator|==
name|SImode
operator|||
operator|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Target hook for vector_mode_supported_p.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2SFmode
case|:
return|return
name|TARGET_PAIRED_SINGLE_FLOAT
return|;
case|case
name|V2HImode
case|:
case|case
name|V4QImode
case|:
return|return
name|TARGET_DSP
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we can access small data directly (using gp-relative relocation    operators) return the small data pointer, otherwise return null.     For each mips16 function which refers to GP relative symbols, we    use a pseudo register, initialized at the start of the function, to    hold the $gp value.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips16_gp_pseudo_reg
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|mips16_gp_pseudo_rtx
operator|==
name|NULL_RTX
condition|)
block|{
name|rtx
name|unspec
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|scan
decl_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|mips16_gp_pseudo_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* We want to initialize this to a value which gcc will believe          is constant.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|unspec
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_GP
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|mips16_gp_pseudo_rtx
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|unspec
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|push_topmost_sequence
argument_list|()
expr_stmt|;
comment|/* We need to emit the initialization after the FUNCTION_BEG          note, so that it will be integrated.  */
for|for
control|(
name|scan
operator|=
name|get_insns
argument_list|()
init|;
name|scan
operator|!=
name|NULL_RTX
condition|;
name|scan
operator|=
name|NEXT_INSN
argument_list|(
name|scan
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|scan
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|scan
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
break|break;
if|if
condition|(
name|scan
operator|==
name|NULL_RTX
condition|)
name|scan
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|pop_topmost_sequence
argument_list|()
expr_stmt|;
block|}
return|return
name|cfun
operator|->
name|machine
operator|->
name|mips16_gp_pseudo_rtx
return|;
block|}
end_function

begin_comment
comment|/* Write out code to move floating point arguments in or out of    general registers.  Output the instructions to FILE.  FP_CODE is    the code describing which arguments are present (see the comment at    the definition of CUMULATIVE_ARGS in mips.h).  FROM_FP_P is nonzero if    we are copying from the floating point registers.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_fp_args
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|fp_code
parameter_list|,
name|int
name|from_fp_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|gparg
decl_stmt|,
name|fparg
decl_stmt|;
name|unsigned
name|int
name|f
decl_stmt|;
comment|/* This code only works for the original 32 bit ABI and the O64 ABI.  */
name|gcc_assert
argument_list|(
name|TARGET_OLDABI
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_fp_p
condition|)
name|s
operator|=
literal|"mfc1"
expr_stmt|;
else|else
name|s
operator|=
literal|"mtc1"
expr_stmt|;
name|gparg
operator|=
name|GP_ARG_FIRST
expr_stmt|;
name|fparg
operator|=
name|FP_ARG_FIRST
expr_stmt|;
for|for
control|(
name|f
operator|=
operator|(
name|unsigned
name|int
operator|)
name|fp_code
init|;
name|f
operator|!=
literal|0
condition|;
name|f
operator|>>=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|f
operator|&
literal|3
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fparg
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|++
name|fparg
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s,%s\n"
argument_list|,
name|s
argument_list|,
name|reg_names
index|[
name|gparg
index|]
argument_list|,
name|reg_names
index|[
name|fparg
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|&
literal|3
operator|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\td%s\t%s,%s\n"
argument_list|,
name|s
argument_list|,
name|reg_names
index|[
name|gparg
index|]
argument_list|,
name|reg_names
index|[
name|fparg
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|fparg
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|++
name|fparg
expr_stmt|;
if|if
condition|(
name|TARGET_BIG_ENDIAN
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s,%s\n\t%s\t%s,%s\n"
argument_list|,
name|s
argument_list|,
name|reg_names
index|[
name|gparg
index|]
argument_list|,
name|reg_names
index|[
name|fparg
operator|+
literal|1
index|]
argument_list|,
name|s
argument_list|,
name|reg_names
index|[
name|gparg
operator|+
literal|1
index|]
argument_list|,
name|reg_names
index|[
name|fparg
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%s,%s\n\t%s\t%s,%s\n"
argument_list|,
name|s
argument_list|,
name|reg_names
index|[
name|gparg
index|]
argument_list|,
name|reg_names
index|[
name|fparg
index|]
argument_list|,
name|s
argument_list|,
name|reg_names
index|[
name|gparg
operator|+
literal|1
index|]
argument_list|,
name|reg_names
index|[
name|fparg
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
operator|++
name|gparg
expr_stmt|;
operator|++
name|fparg
expr_stmt|;
block|}
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
operator|++
name|gparg
expr_stmt|;
operator|++
name|fparg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a mips16 function stub.  This is used for functions which    take arguments in the floating point registers.  It is 32 bit code    that moves the floating point args into the general registers, and    then jumps to the 16 bit code.  */
end_comment

begin_function
specifier|static
name|void
name|build_mips16_function_stub
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|,
modifier|*
name|stubname
decl_stmt|;
name|tree
name|stubid
decl_stmt|,
name|stubdecl
decl_stmt|;
name|int
name|need_comma
decl_stmt|;
name|unsigned
name|int
name|f
decl_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|secname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fnname
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|secname
argument_list|,
literal|".mips16.fn.%s"
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|stubname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fnname
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|stubname
argument_list|,
literal|"__fn_stub_%s"
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|stubid
operator|=
name|get_identifier
argument_list|(
name|stubname
argument_list|)
expr_stmt|;
name|stubdecl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|stubid
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|stubdecl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|secname
argument_list|)
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t# Stub function for %s ("
argument_list|,
name|current_function_name
argument_list|()
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
operator|(
name|unsigned
name|int
operator|)
name|current_function_args_info
operator|.
name|fp_code
init|;
name|f
operator|!=
literal|0
condition|;
name|f
operator|>>=
literal|2
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s"
argument_list|,
name|need_comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
literal|3
operator|)
operator|==
literal|1
condition|?
literal|"float"
else|:
literal|"double"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set\tnomips16\n"
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|stubdecl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? If FUNCTION_NAME_ALREADY_DECLARED is defined, then we are      within a .ent, and we cannot emit another .ent.  */
if|if
condition|(
operator|!
name|FUNCTION_NAME_ALREADY_DECLARED
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.ent\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|stubname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|assemble_name
argument_list|(
name|file
argument_list|,
name|stubname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* We don't want the assembler to insert any nops here.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set\tnoreorder\n"
argument_list|)
expr_stmt|;
name|mips16_fp_args
argument_list|(
name|file
argument_list|,
name|current_function_args_info
operator|.
name|fp_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tnoat\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tla\t%s,"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tjr\t%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tat\n"
argument_list|)
expr_stmt|;
comment|/* Unfortunately, we can't fill the jump delay slot.  We can't fill      with one of the mfc1 instructions, because the result is not      available for one instruction, so if the very first instruction      in the function refers to the register, it will see the wrong      value.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set\treorder\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FUNCTION_NAME_ALREADY_DECLARED
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.end\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|stubname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.set\tmips16\n"
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We keep a list of functions for which we have already built stubs    in build_mips16_call_stub.  */
end_comment

begin_struct
struct|struct
name|mips16_stub
block|{
name|struct
name|mips16_stub
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fpret
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mips16_stub
modifier|*
name|mips16_stubs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build a call stub for a mips16 call.  A stub is needed if we are    passing any floating point values which should go into the floating    point registers.  If we are, and the call turns out to be to a 32    bit function, the stub will be used to move the values into the    floating point registers before calling the 32 bit function.  The    linker will magically adjust the function call to either the 16 bit    function or the 32 bit stub, depending upon where the function call    is actually defined.     Similarly, we need a stub if the return value might come back in a    floating point register.     RETVAL is the location of the return value, or null if this is    a call rather than a call_value.  FN is the address of the    function and ARG_SIZE is the size of the arguments.  FP_CODE    is the code built by function_arg.  This function returns a nonzero    value if it builds the call instruction itself.  */
end_comment

begin_function
name|int
name|build_mips16_call_stub
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|fn
parameter_list|,
name|rtx
name|arg_size
parameter_list|,
name|int
name|fp_code
parameter_list|)
block|{
name|int
name|fpret
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|,
modifier|*
name|stubname
decl_stmt|;
name|struct
name|mips16_stub
modifier|*
name|l
decl_stmt|;
name|tree
name|stubid
decl_stmt|,
name|stubdecl
decl_stmt|;
name|int
name|need_comma
decl_stmt|;
name|unsigned
name|int
name|f
decl_stmt|;
comment|/* We don't need to do anything if we aren't in mips16 mode, or if      we were invoked with the -msoft-float option.  */
if|if
condition|(
operator|!
name|TARGET_MIPS16
operator|||
operator|!
name|mips16_hard_float
condition|)
return|return
literal|0
return|;
comment|/* Figure out whether the value might come back in a floating point      register.  */
name|fpret
operator|=
operator|(
name|retval
operator|!=
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_FPVALUE
operator|)
expr_stmt|;
comment|/* We don't need to do anything if there were no floating point      arguments and the value will not be returned in a floating point      register.  */
if|if
condition|(
name|fp_code
operator|==
literal|0
operator|&&
operator|!
name|fpret
condition|)
return|return
literal|0
return|;
comment|/* We don't need to do anything if this is a call to a special      mips16 support function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|strncmp
argument_list|(
name|XSTR
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"__mips16_"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* This code will only work for o32 and o64 abis.  The other ABI's      require more sophisticated support.  */
name|gcc_assert
argument_list|(
name|TARGET_OLDABI
argument_list|)
expr_stmt|;
comment|/* We can only handle SFmode and DFmode floating point return      values.  */
if|if
condition|(
name|fpret
condition|)
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|retval
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|retval
argument_list|)
operator|==
name|DFmode
argument_list|)
expr_stmt|;
comment|/* If we're calling via a function pointer, then we must always call      via a stub.  There are magic stubs provided in libgcc.a for each      of the required cases.  Each of them expects the function address      to arrive in register $2.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|rtx
name|stub_fn
decl_stmt|,
name|insn
decl_stmt|;
comment|/* ??? If this code is modified to support other ABI's, we need          to handle PARALLEL return values here.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__mips16_call_stub_%s%d"
argument_list|,
operator|(
name|fpret
condition|?
operator|(
name|GET_MODE
argument_list|(
name|retval
argument_list|)
operator|==
name|SFmode
condition|?
literal|"sf_"
else|:
literal|"df_"
operator|)
else|:
literal|""
operator|)
argument_list|,
name|fp_code
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|stub_fn
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL_RTX
condition|)
name|insn
operator|=
name|gen_call_internal
argument_list|(
name|stub_fn
argument_list|,
name|arg_size
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_internal
argument_list|(
name|retval
argument_list|,
name|stub_fn
argument_list|,
name|arg_size
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Put the register usage information on the CALL.  */
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are handling a floating point return value, we need to          save $18 in the function prologue.  Putting a note on the          call will mean that regs_ever_live[$18] will be true if the          call is not eliminated, and we can check that in the prologue          code.  */
if|if
condition|(
name|fpret
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|18
argument_list|)
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return 1 to tell the caller that we've generated the call          insn.  */
return|return
literal|1
return|;
block|}
comment|/* We know the function we are going to call.  If we have already      built a stub, we don't need to do anything further.  */
name|fnname
operator|=
name|XSTR
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|mips16_stubs
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|l
operator|->
name|name
argument_list|,
name|fnname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
block|{
comment|/* Build a special purpose stub.  When the linker sees a 	 function call in mips16 code, it will check where the target 	 is defined.  If the target is a 32 bit call, the linker will 	 search for the section defined here.  It can tell which 	 symbol this section is associated with by looking at the 	 relocation information (the name is unreliable, since this 	 might be a static function).  If such a section is found, the 	 linker will redirect the call to the start of the magic 	 section.  	 If the function does not return a floating point value, the 	 special stub section is named 	     .mips16.call.FNNAME  	 If the function does return a floating point value, the stub 	 section is named 	     .mips16.call.fp.FNNAME 	 */
name|secname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fnname
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|secname
argument_list|,
literal|".mips16.call.%s%s"
argument_list|,
name|fpret
condition|?
literal|"fp."
else|:
literal|""
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|stubname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fnname
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|stubname
argument_list|,
literal|"__call_stub_%s%s"
argument_list|,
name|fpret
condition|?
literal|"fp_"
else|:
literal|""
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|stubid
operator|=
name|get_identifier
argument_list|(
name|stubname
argument_list|)
expr_stmt|;
name|stubdecl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|stubid
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|stubdecl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|secname
argument_list|)
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t# Stub function to call %s%s ("
argument_list|,
operator|(
name|fpret
condition|?
operator|(
name|GET_MODE
argument_list|(
name|retval
argument_list|)
operator|==
name|SFmode
condition|?
literal|"float "
else|:
literal|"double "
operator|)
else|:
literal|""
operator|)
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
operator|(
name|unsigned
name|int
operator|)
name|fp_code
init|;
name|f
operator|!=
literal|0
condition|;
name|f
operator|>>=
literal|2
control|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s%s"
argument_list|,
name|need_comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
operator|(
name|f
operator|&
literal|3
operator|)
operator|==
literal|1
condition|?
literal|"float"
else|:
literal|"double"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tnomips16\n"
argument_list|)
expr_stmt|;
name|assemble_start_function
argument_list|(
name|stubdecl
argument_list|,
name|stubname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FUNCTION_NAME_ALREADY_DECLARED
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.ent\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|stubname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|stubname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* We build the stub code by hand.  That's the only way we can 	 do it, since we can't generate 32 bit code during a 16 bit 	 compilation.  */
comment|/* We don't want the assembler to insert any nops here.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tnoreorder\n"
argument_list|)
expr_stmt|;
name|mips16_fp_args
argument_list|(
name|asm_out_file
argument_list|,
name|fp_code
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fpret
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tnoat\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tla\t%s,%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|1
index|]
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tjr\t%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tat\n"
argument_list|)
expr_stmt|;
comment|/* Unfortunately, we can't fill the jump delay slot.  We 	     can't fill with one of the mtc1 instructions, because the 	     result is not available for one instruction, so if the 	     very first instruction in the function refers to the 	     register, it will see the wrong value.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmove\t%s,%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|18
index|]
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tjal\t%s\n"
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
comment|/* As above, we can't fill the delay slot.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|retval
argument_list|)
operator|==
name|SFmode
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmfc1\t%s,%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|2
index|]
argument_list|,
name|reg_names
index|[
name|FP_REG_FIRST
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TARGET_BIG_ENDIAN
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmfc1\t%s,%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|2
index|]
argument_list|,
name|reg_names
index|[
name|FP_REG_FIRST
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmfc1\t%s,%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|3
index|]
argument_list|,
name|reg_names
index|[
name|FP_REG_FIRST
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmfc1\t%s,%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|2
index|]
argument_list|,
name|reg_names
index|[
name|FP_REG_FIRST
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmfc1\t%s,%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|3
index|]
argument_list|,
name|reg_names
index|[
name|FP_REG_FIRST
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tj\t%s\n"
argument_list|,
name|reg_names
index|[
name|GP_REG_FIRST
operator|+
literal|18
index|]
argument_list|)
expr_stmt|;
comment|/* As above, we can't fill the delay slot.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\treorder\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_SIZE
name|ASM_DECLARE_FUNCTION_SIZE
argument_list|(
name|asm_out_file
argument_list|,
name|stubname
argument_list|,
name|stubdecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|FUNCTION_NAME_ALREADY_DECLARED
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.end\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|stubname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.set\tmips16\n"
argument_list|)
expr_stmt|;
comment|/* Record this stub.  */
name|l
operator|=
operator|(
expr|struct
name|mips16_stub
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|l
operator|->
name|fpret
operator|=
name|fpret
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|mips16_stubs
expr_stmt|;
name|mips16_stubs
operator|=
name|l
expr_stmt|;
block|}
comment|/* If we expect a floating point return value, but we've built a      stub which does not expect one, then we're in trouble.  We can't      use the existing stub, because it won't handle the floating point      value.  We can't build a new stub, because the linker won't know      which stub to use for the various calls in this object file.      Fortunately, this case is illegal, since it means that a function      was declared in two different ways in a single compilation.  */
if|if
condition|(
name|fpret
operator|&&
operator|!
name|l
operator|->
name|fpret
condition|)
name|error
argument_list|(
literal|"cannot handle inconsistent calls to %qs"
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
comment|/* If we are calling a stub which handles a floating point return      value, we need to arrange to save $18 in the prologue.  We do      this by marking the function call as using the register.  The      prologue will later see that it is used, and emit code to save      it.  */
if|if
condition|(
name|l
operator|->
name|fpret
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL_RTX
condition|)
name|insn
operator|=
name|gen_call_internal
argument_list|(
name|fn
argument_list|,
name|arg_size
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_internal
argument_list|(
name|retval
argument_list|,
name|fn
argument_list|,
name|arg_size
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|18
argument_list|)
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return 1 to tell the caller that we've generated the call          insn.  */
return|return
literal|1
return|;
block|}
comment|/* Return 0 to let the caller generate the call insn.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* An entry in the mips16 constant pool.  VALUE is the pool constant,    MODE is its mode, and LABEL is the CODE_LABEL associated with it.  */
end_comment

begin_struct
struct|struct
name|mips16_constant
block|{
name|struct
name|mips16_constant
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information about an incomplete mips16 constant pool.  FIRST is the    first constant, HIGHEST_ADDRESS is the highest address that the first    byte of the pool can have, and INSN_ADDRESS is the current instruction    address.  */
end_comment

begin_struct
struct|struct
name|mips16_constant_pool
block|{
name|struct
name|mips16_constant
modifier|*
name|first
decl_stmt|;
name|int
name|highest_address
decl_stmt|;
name|int
name|insn_address
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Add constant VALUE to POOL and return its label.  MODE is the    value's mode (used for CONST_INTs, etc.).  */
end_comment

begin_function
specifier|static
name|rtx
name|add_constant
parameter_list|(
name|struct
name|mips16_constant_pool
modifier|*
name|pool
parameter_list|,
name|rtx
name|value
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|mips16_constant
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|bool
name|first_of_size_p
decl_stmt|;
comment|/* See whether the constant is already in the pool.  If so, return the      existing label, otherwise leave P pointing to the place where the      constant should be added.       Keep the pool sorted in increasing order of mode size so that we can      reduce the number of alignments needed.  */
name|first_of_size_p
operator|=
name|true
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pool
operator|->
name|first
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mode
operator|==
operator|(
operator|*
name|p
operator|)
operator|->
name|mode
operator|&&
name|rtx_equal_p
argument_list|(
name|value
argument_list|,
operator|(
operator|*
name|p
operator|)
operator|->
name|value
argument_list|)
condition|)
return|return
operator|(
operator|*
name|p
operator|)
operator|->
name|label
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|mode
argument_list|)
condition|)
break|break;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|mode
argument_list|)
condition|)
name|first_of_size_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* In the worst case, the constant needed by the earliest instruction      will end up at the end of the pool.  The entire pool must then be      accessible from that instruction.       When adding the first constant, set the pool's highest address to      the address of the first out-of-range byte.  Adjust this address      downwards each time a new constant is added.  */
if|if
condition|(
name|pool
operator|->
name|first
operator|==
literal|0
condition|)
comment|/* For pc-relative lw, addiu and daddiu instructions, the base PC value        is the address of the instruction with the lowest two bits clear.        The base PC value for ld has the lowest three bits clear.  Assume        the worst case here.  */
name|pool
operator|->
name|highest_address
operator|=
name|pool
operator|->
name|insn_address
operator|-
operator|(
name|UNITS_PER_WORD
operator|-
literal|2
operator|)
operator|+
literal|0x8000
expr_stmt|;
name|pool
operator|->
name|highest_address
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_of_size_p
condition|)
comment|/* Take into account the worst possible padding due to alignment.  */
name|pool
operator|->
name|highest_address
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Create a new entry.  */
name|c
operator|=
operator|(
expr|struct
name|mips16_constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|c
operator|->
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|c
operator|->
name|next
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
name|c
operator|->
name|label
return|;
block|}
end_function

begin_comment
comment|/* Output constant VALUE after instruction INSN and return the last    instruction emitted.  MODE is the mode of the constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|dump_constants_1
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|value
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_INT
case|:
block|{
name|rtx
name|size
init|=
name|GEN_INT
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|emit_insn_after
argument_list|(
name|gen_consttable_int
argument_list|(
name|value
argument_list|,
name|size
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
block|}
case|case
name|MODE_FLOAT
case|:
return|return
name|emit_insn_after
argument_list|(
name|gen_consttable_float
argument_list|(
name|value
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
case|case
name|MODE_VECTOR_FLOAT
case|:
case|case
name|MODE_VECTOR_INT
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CONST_VECTOR_NUNITS
argument_list|(
name|value
argument_list|)
condition|;
name|i
operator|++
control|)
name|insn
operator|=
name|dump_constants_1
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|CONST_VECTOR_ELT
argument_list|(
name|value
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump out the constants in CONSTANTS after INSN.  */
end_comment

begin_function
specifier|static
name|void
name|dump_constants
parameter_list|(
name|struct
name|mips16_constant
modifier|*
name|constants
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|mips16_constant
modifier|*
name|c
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|align
decl_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|constants
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|next
control|)
block|{
comment|/* If necessary, increase the alignment of PC.  */
if|if
condition|(
name|align
operator|<
name|GET_MODE_SIZE
argument_list|(
name|c
operator|->
name|mode
argument_list|)
condition|)
block|{
name|int
name|align_log
init|=
name|floor_log2
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|c
operator|->
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_align
argument_list|(
name|GEN_INT
argument_list|(
name|align_log
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|align
operator|=
name|GET_MODE_SIZE
argument_list|(
name|c
operator|->
name|mode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_label_after
argument_list|(
name|c
operator|->
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|dump_constants_1
argument_list|(
name|c
operator|->
name|mode
argument_list|,
name|c
operator|->
name|value
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|next
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the length of instruction INSN.  */
end_comment

begin_function
specifier|static
name|int
name|mips16_insn_length
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|get_attr_length
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rewrite *X so that constant pool references refer to the constant's    label instead.  DATA points to the constant pool structure.  */
end_comment

begin_function
specifier|static
name|int
name|mips16_rewrite_pool_refs
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mips16_constant_pool
modifier|*
name|pool
init|=
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
operator|*
name|x
argument_list|)
condition|)
operator|*
name|x
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|add_constant
argument_list|(
name|pool
argument_list|,
name|get_pool_constant
argument_list|(
operator|*
name|x
argument_list|)
argument_list|,
name|get_pool_mode
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build MIPS16 constant pools.  */
end_comment

begin_function
specifier|static
name|void
name|mips16_lay_out_constants
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mips16_constant_pool
name|pool
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|barrier
decl_stmt|;
name|barrier
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Rewrite constant pool references in INSN.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mips16_rewrite_pool_refs
argument_list|,
operator|&
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|.
name|insn_address
operator|+=
name|mips16_insn_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|.
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* If there are no natural barriers between the first user of 	     the pool and the highest acceptable address, we'll need to 	     create a new instruction to jump around the constant pool. 	     In the worst case, this instruction will be 4 bytes long.  	     If it's too late to do this transformation after INSN, 	     do it immediately before INSN.  */
if|if
condition|(
name|barrier
operator|==
literal|0
operator|&&
name|pool
operator|.
name|insn_address
operator|+
literal|4
operator|>
name|pool
operator|.
name|highest_address
condition|)
block|{
name|rtx
name|label
decl_stmt|,
name|jump
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|pool
operator|.
name|insn_address
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* See whether the constant pool is now out of range of the first 	     user.  If so, output the constants after the previous barrier. 	     Note that any instructions between BARRIER and INSN (inclusive) 	     will use negative offsets to refer to the pool.  */
if|if
condition|(
name|pool
operator|.
name|insn_address
operator|>
name|pool
operator|.
name|highest_address
condition|)
block|{
name|dump_constants
argument_list|(
name|pool
operator|.
name|first
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|pool
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|barrier
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
name|barrier
operator|=
name|insn
expr_stmt|;
block|}
block|}
name|dump_constants
argument_list|(
name|pool
operator|.
name|first
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A temporary variable used by for_each_rtx callbacks, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|mips_sim_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A structure representing the state of the processor pipeline.    Used by the mips_sim_* family of functions.  */
end_comment

begin_struct
struct|struct
name|mips_sim
block|{
comment|/* The maximum number of instructions that can be issued in a cycle.      (Caches mips_issue_rate.)  */
name|unsigned
name|int
name|issue_rate
decl_stmt|;
comment|/* The current simulation time.  */
name|unsigned
name|int
name|time
decl_stmt|;
comment|/* How many more instructions can be issued in the current cycle.  */
name|unsigned
name|int
name|insns_left
decl_stmt|;
comment|/* LAST_SET[X].INSN is the last instruction to set register X.      LAST_SET[X].TIME is the time at which that instruction was issued.      INSN is null if no instruction has yet set register X.  */
struct|struct
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|time
decl_stmt|;
block|}
name|last_set
index|[
name|FIRST_PSEUDO_REGISTER
index|]
struct|;
comment|/* The pipeline's current DFA state.  */
name|state_t
name|dfa_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Reset STATE to the initial simulation state.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_reset
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|)
block|{
name|state
operator|->
name|time
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|insns_left
operator|=
name|state
operator|->
name|issue_rate
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
operator|->
name|last_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|last_set
argument_list|)
argument_list|)
expr_stmt|;
name|state_reset
argument_list|(
name|state
operator|->
name|dfa_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize STATE before its first use.  DFA_STATE points to an    allocated but uninitialized DFA state.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_init
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|,
name|state_t
name|dfa_state
parameter_list|)
block|{
name|state
operator|->
name|issue_rate
operator|=
name|mips_issue_rate
argument_list|()
expr_stmt|;
name|state
operator|->
name|dfa_state
operator|=
name|dfa_state
expr_stmt|;
name|mips_sim_reset
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance STATE by one clock cycle.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_next_cycle
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|)
block|{
name|state
operator|->
name|time
operator|++
expr_stmt|;
name|state
operator|->
name|insns_left
operator|=
name|state
operator|->
name|issue_rate
expr_stmt|;
name|state_transition
argument_list|(
name|state
operator|->
name|dfa_state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance simulation state STATE until instruction INSN can read    register REG.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_wait_reg
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|state
operator|->
name|last_set
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|i
index|]
operator|.
name|insn
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|t
decl_stmt|;
name|t
operator|=
name|state
operator|->
name|last_set
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|i
index|]
operator|.
name|time
expr_stmt|;
name|t
operator|+=
name|insn_latency
argument_list|(
name|state
operator|->
name|last_set
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|i
index|]
operator|.
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|time
operator|<
name|t
condition|)
name|mips_sim_next_cycle
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A for_each_rtx callback.  If *X is a register, advance simulation state    DATA until mips_sim_insn can read the register's value.  */
end_comment

begin_function
specifier|static
name|int
name|mips_sim_wait_regs_2
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
operator|*
name|x
argument_list|)
condition|)
name|mips_sim_wait_reg
argument_list|(
name|data
argument_list|,
name|mips_sim_insn
argument_list|,
operator|*
name|x
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Call mips_sim_wait_regs_2 (R, DATA) for each register R mentioned in *X.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_wait_regs_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|for_each_rtx
argument_list|(
name|x
argument_list|,
name|mips_sim_wait_regs_2
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance simulation state STATE until all of INSN's register    dependencies are satisfied.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_wait_regs
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|mips_sim_insn
operator|=
name|insn
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mips_sim_wait_regs_1
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance simulation state STATE until the units required by    instruction INSN are available.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_wait_units
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|state_t
name|tmp_state
decl_stmt|;
name|tmp_state
operator|=
name|alloca
argument_list|(
name|state_size
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|insns_left
operator|==
literal|0
operator|||
operator|(
name|memcpy
argument_list|(
name|tmp_state
argument_list|,
name|state
operator|->
name|dfa_state
argument_list|,
name|state_size
argument_list|()
argument_list|)
operator|,
name|state_transition
argument_list|(
name|tmp_state
argument_list|,
name|insn
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|mips_sim_next_cycle
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance simulation state STATE until INSN is ready to issue.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_wait_insn
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|mips_sim_wait_regs
argument_list|(
name|state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|mips_sim_wait_units
argument_list|(
name|state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mips_sim_insn has just set X.  Update the LAST_SET array    in simulation state DATA.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_record_set
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mips_sim
modifier|*
name|state
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|state
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|state
operator|->
name|last_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|i
index|]
operator|.
name|insn
operator|=
name|mips_sim_insn
expr_stmt|;
name|state
operator|->
name|last_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|i
index|]
operator|.
name|time
operator|=
name|state
operator|->
name|time
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Issue instruction INSN in scheduler state STATE.  Assume that INSN    can issue immediately (i.e., that mips_sim_wait_insn has already    been called).  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_issue_insn
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|state_transition
argument_list|(
name|state
operator|->
name|dfa_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|state
operator|->
name|insns_left
operator|--
expr_stmt|;
name|mips_sim_insn
operator|=
name|insn
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mips_sim_record_set
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simulate issuing a NOP in state STATE.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_issue_nop
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|insns_left
operator|==
literal|0
condition|)
name|mips_sim_next_cycle
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|->
name|insns_left
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update simulation state STATE so that it's ready to accept the instruction    after INSN.  INSN should be part of the main rtl chain, not a member of a    SEQUENCE.  */
end_comment

begin_function
specifier|static
name|void
name|mips_sim_finish_insn
parameter_list|(
name|struct
name|mips_sim
modifier|*
name|state
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* If INSN is a jump with an implicit delay slot, simulate a nop.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mips_sim_issue_nop
argument_list|(
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SEQ_BEGIN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
case|case
name|CALL_INSN
case|:
comment|/* We can't predict the processor state after a call or label.  */
name|mips_sim_reset
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* The delay slots of branch likely instructions are only executed 	 when the branch is taken.  Therefore, if the caller has simulated 	 the delay slot instruction, STATE does not really reflect the state 	 of the pipeline for the instruction after the delay slot.  Also, 	 branch likely instructions tend to incur a penalty when not taken, 	 so there will probably be an extra delay between the branch and 	 the instruction after the delay slot.  */
if|if
condition|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|SEQ_BEGIN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|mips_sim_reset
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The VR4130 pipeline issues aligned pairs of instructions together,    but it stalls the second instruction if it depends on the first.    In order to cut down the amount of logic required, this dependence    check is not based on a full instruction decode.  Instead, any non-SPECIAL    instruction is assumed to modify the register specified by bits 20-16    (which is usually the "rt" field).     In beq, beql, bne and bnel instructions, the rt field is actually an    input, so we can end up with a false dependence between the branch    and its delay slot.  If this situation occurs in instruction INSN,    try to avoid it by swapping rs and rt.  */
end_comment

begin_function
specifier|static
name|void
name|vr4130_avoid_branch_rt_conflict
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|first
decl_stmt|,
name|second
decl_stmt|;
name|first
operator|=
name|SEQ_BEGIN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|second
operator|=
name|SEQ_END
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|first
argument_list|)
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|second
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
comment|/* Check for the right kind of condition.  */
name|rtx
name|cond
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|second
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|second
argument_list|)
argument_list|)
condition|)
block|{
comment|/* SECOND mentions the rt register but not the rs register.  */
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Implement -mvr4130-align.  Go through each basic block and simulate the    processor pipeline.  If we find that a pair of instructions could execute    in parallel, and the first of those instruction is not 8-byte aligned,    insert a nop to make it aligned.  */
end_comment

begin_function
specifier|static
name|void
name|vr4130_align_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mips_sim
name|state
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|subinsn
decl_stmt|,
name|last
decl_stmt|,
name|last2
decl_stmt|,
name|next
decl_stmt|;
name|bool
name|aligned_p
decl_stmt|;
name|dfa_start
argument_list|()
expr_stmt|;
comment|/* LAST is the last instruction before INSN to have a nonzero length.      LAST2 is the last such instruction before LAST.  */
name|last
operator|=
literal|0
expr_stmt|;
name|last2
operator|=
literal|0
expr_stmt|;
comment|/* ALIGNED_P is true if INSN is known to be at an aligned address.  */
name|aligned_p
operator|=
name|true
expr_stmt|;
name|mips_sim_init
argument_list|(
operator|&
name|state
argument_list|,
name|alloca
argument_list|(
name|state_size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* See the comment above vr4130_avoid_branch_rt_conflict for details. 	 This isn't really related to the alignment pass, but we do it on 	 the fly to avoid a separate instruction walk.  */
name|vr4130_avoid_branch_rt_conflict
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|USEFUL_INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|FOR_EACH_SUBINSN
argument_list|(
argument|subinsn
argument_list|,
argument|insn
argument_list|)
block|{
name|mips_sim_wait_insn
argument_list|(
operator|&
name|state
argument_list|,
name|subinsn
argument_list|)
expr_stmt|;
comment|/* If we want this instruction to issue in parallel with the 	       previous one, make sure that the previous instruction is 	       aligned.  There are several reasons why this isn't worthwhile 	       when the second instruction is a call:  	          - Calls are less likely to be performance critical, 		  - There's a good chance that the delay slot can execute 		    in parallel with the call. 	          - The return address would then be unaligned.  	       In general, if we're going to insert a nop between instructions 	       X and Y, it's better to insert it immediately after X.  That 	       way, if the nop makes Y aligned, it will also align any labels 	       between X and Y.  */
if|if
condition|(
name|state
operator|.
name|insns_left
operator|!=
name|state
operator|.
name|issue_rate
operator|&&
operator|!
name|CALL_P
argument_list|(
name|subinsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|subinsn
operator|==
name|SEQ_BEGIN
argument_list|(
name|insn
argument_list|)
operator|&&
name|aligned_p
condition|)
block|{
comment|/* SUBINSN is the first instruction in INSN and INSN is 		       aligned.  We want to align the previous instruction 		       instead, so insert a nop between LAST2 and LAST.  		       Note that LAST could be either a single instruction 		       or a branch with a delay slot.  In the latter case, 		       LAST, like INSN, is already aligned, but the delay 		       slot must have some extra delay that stops it from 		       issuing at the same time as the branch.  We therefore 		       insert a nop before the branch in order to align its 		       delay slot.  */
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|last2
argument_list|)
expr_stmt|;
name|aligned_p
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subinsn
operator|!=
name|SEQ_BEGIN
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|aligned_p
condition|)
block|{
comment|/* SUBINSN is the delay slot of INSN, but INSN is 		       currently unaligned.  Insert a nop between 		       LAST and INSN to align it.  */
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|aligned_p
operator|=
name|true
expr_stmt|;
block|}
block|}
name|mips_sim_issue_insn
argument_list|(
operator|&
name|state
argument_list|,
name|subinsn
argument_list|)
expr_stmt|;
block|}
name|mips_sim_finish_insn
argument_list|(
operator|&
name|state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Update LAST, LAST2 and ALIGNED_P for the next instruction.  */
name|length
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/* If the instruction is an asm statement or multi-instruction 	     mips.md patern, the length is only an estimate.  Insert an 	     8 byte alignment after it so that the following instructions 	     can be handled correctly.  */
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|SEQ_BEGIN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
name|length
operator|>=
literal|8
operator|)
condition|)
block|{
name|next
operator|=
name|emit_insn_after
argument_list|(
name|gen_align
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|mips_sim_next_cycle
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|aligned_p
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|&
literal|4
condition|)
name|aligned_p
operator|=
operator|!
name|aligned_p
expr_stmt|;
name|last2
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
block|}
comment|/* See whether INSN is an aligned label.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|label_to_alignment
argument_list|(
name|insn
argument_list|)
operator|>=
literal|3
condition|)
name|aligned_p
operator|=
name|true
expr_stmt|;
block|}
name|dfa_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of mips_reorg.  If there is a hazard between INSN    and a previous instruction, avoid it by inserting nops after    instruction AFTER.     *DELAYED_REG and *HILO_DELAY describe the hazards that apply at    this point.  If *DELAYED_REG is non-null, INSN must wait a cycle    before using the value of that register.  *HILO_DELAY counts the    number of instructions since the last hilo hazard (that is,    the number of instructions since the last mflo or mfhi).     After inserting nops for INSN, update *DELAYED_REG and *HILO_DELAY    for the next instruction.     LO_REG is an rtx for the LO register, used in dependence checking.  */
end_comment

begin_function
specifier|static
name|void
name|mips_avoid_hazard
parameter_list|(
name|rtx
name|after
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
modifier|*
name|hilo_delay
parameter_list|,
name|rtx
modifier|*
name|delayed_reg
parameter_list|,
name|rtx
name|lo_reg
parameter_list|)
block|{
name|rtx
name|pattern
decl_stmt|,
name|set
decl_stmt|;
name|int
name|nops
decl_stmt|,
name|ninsns
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Do not put the whole function in .set noreorder if it contains      an asm statement.  We don't know whether there will be hazards      between the asm statement and the gcc-generated code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|pattern
argument_list|)
operator|>=
literal|0
condition|)
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
operator|=
name|false
expr_stmt|;
comment|/* Ignore zero-length instructions (barriers and the like).  */
name|ninsns
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|ninsns
operator|==
literal|0
condition|)
return|return;
comment|/* Work out how many nops are needed.  Note that we only care about      registers that are explicitly mentioned in the instruction's pattern.      It doesn't matter that calls use the argument registers or that they      clobber hi and lo.  */
if|if
condition|(
operator|*
name|hilo_delay
operator|<
literal|2
operator|&&
name|reg_set_p
argument_list|(
name|lo_reg
argument_list|,
name|pattern
argument_list|)
condition|)
name|nops
operator|=
literal|2
operator|-
operator|*
name|hilo_delay
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|delayed_reg
operator|!=
literal|0
operator|&&
name|reg_referenced_p
argument_list|(
operator|*
name|delayed_reg
argument_list|,
name|pattern
argument_list|)
condition|)
name|nops
operator|=
literal|1
expr_stmt|;
else|else
name|nops
operator|=
literal|0
expr_stmt|;
comment|/* Insert the nops between this instruction and the previous one.      Each new nop takes us further from the last hilo hazard.  */
operator|*
name|hilo_delay
operator|+=
name|nops
expr_stmt|;
while|while
condition|(
name|nops
operator|--
operator|>
literal|0
condition|)
name|emit_insn_after
argument_list|(
name|gen_hazard_nop
argument_list|()
argument_list|,
name|after
argument_list|)
expr_stmt|;
comment|/* Set up the state for the next instruction.  */
operator|*
name|hilo_delay
operator|+=
name|ninsns
expr_stmt|;
operator|*
name|delayed_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
switch|switch
condition|(
name|get_attr_hazard
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|HAZARD_NONE
case|:
break|break;
case|case
name|HAZARD_HILO
case|:
operator|*
name|hilo_delay
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HAZARD_DELAY
case|:
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|set
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|delayed_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Go through the instruction stream and insert nops where necessary.    See if the whole function can then be put into .set noreorder&    .set nomacro.  */
end_comment

begin_function
specifier|static
name|void
name|mips_avoid_hazards
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|last_insn
decl_stmt|,
name|lo_reg
decl_stmt|,
name|delayed_reg
decl_stmt|;
name|int
name|hilo_delay
decl_stmt|,
name|i
decl_stmt|;
comment|/* Force all instructions to be split into their final form.  */
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
comment|/* Recalculate instruction lengths without taking nops into account.  */
name|cfun
operator|->
name|machine
operator|->
name|ignore_hazard_length_p
operator|=
name|true
expr_stmt|;
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
operator|=
name|true
expr_stmt|;
comment|/* Profiled functions can't be all noreorder because the profiler      support uses assembler macros.  */
if|if
condition|(
name|current_function_profile
condition|)
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
operator|=
name|false
expr_stmt|;
comment|/* Code compiled with -mfix-vr4120 can't be all noreorder because      we rely on the assembler to work around some errata.  */
if|if
condition|(
name|TARGET_FIX_VR4120
condition|)
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
operator|=
name|false
expr_stmt|;
comment|/* The same is true for -mfix-vr4130 if we might generate mflo or      mfhi instructions.  Note that we avoid using mflo and mfhi if      the VR4130 macc and dmacc instructions are available instead;      see the *mfhilo_{si,di}_macc patterns.  */
if|if
condition|(
name|TARGET_FIX_VR4130
operator|&&
operator|!
name|ISA_HAS_MACCHI
condition|)
name|cfun
operator|->
name|machine
operator|->
name|all_noreorder_p
operator|=
name|false
expr_stmt|;
name|last_insn
operator|=
literal|0
expr_stmt|;
name|hilo_delay
operator|=
literal|2
expr_stmt|;
name|delayed_reg
operator|=
literal|0
expr_stmt|;
name|lo_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LO_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|mips_avoid_hazard
argument_list|(
name|last_insn
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|hilo_delay
argument_list|,
operator|&
name|delayed_reg
argument_list|,
name|lo_reg
argument_list|)
expr_stmt|;
else|else
name|mips_avoid_hazard
argument_list|(
name|last_insn
argument_list|,
name|insn
argument_list|,
operator|&
name|hilo_delay
argument_list|,
operator|&
name|delayed_reg
argument_list|,
name|lo_reg
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement TARGET_MACHINE_DEPENDENT_REORG.  */
end_comment

begin_function
specifier|static
name|void
name|mips_reorg
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
name|mips16_lay_out_constants
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
block|{
if|if
condition|(
name|mips_flag_delayed_branch
condition|)
name|dbr_schedule
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|mips_avoid_hazards
argument_list|()
expr_stmt|;
if|if
condition|(
name|TUNE_MIPS4130
operator|&&
name|TARGET_VR4130_ALIGN
condition|)
name|vr4130_align_insns
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function does three things:     - Register the special divsi3 and modsi3 functions if -mfix-vr4120.    - Register the mips16 hardware floating point stubs.    - Register the gofast functions if selected using --enable-gofast.  */
end_comment

begin_include
include|#
directive|include
file|"config/gofast.h"
end_include

begin_function
specifier|static
name|void
name|mips_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_FIX_VR4120
condition|)
block|{
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"__vr4120_divsi3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|"__vr4120_modsi3"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_MIPS16
operator|&&
name|mips16_hard_float
condition|)
block|{
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_addsf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_subsf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_mulsf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_divsf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_eqsf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_nesf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_gtsf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_gesf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_ltsf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_lesf2"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_fix_truncsfsi"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|SFmode
argument_list|,
name|SImode
argument_list|,
literal|"__mips16_floatsisf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DOUBLE_FLOAT
condition|)
block|{
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_adddf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_subdf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_muldf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_divdf3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_eqdf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_nedf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_gtdf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_gedf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_ltdf2"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_ledf2"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|DFmode
argument_list|,
name|SFmode
argument_list|,
literal|"__mips16_extendsfdf2"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_truncdfsf2"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|DFmode
argument_list|,
literal|"__mips16_fix_truncdfsi"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|DFmode
argument_list|,
name|SImode
argument_list|,
literal|"__mips16_floatsidf"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|gofast_maybe_init_libfuncs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a number assessing the cost of moving a register in class    FROM to class TO.  The classes are expressed using the enumeration    values such as `GENERAL_REGS'.  A value of 2 is the default; other    values are interpreted relative to that.     It is not required that the cost always equal 2 when FROM is the    same as TO; on some machines it is expensive to move between    registers if they are not general registers.     If reload sees an insn consisting of a single `set' between two    hard registers, and if `REGISTER_MOVE_COST' applied to their    classes returns a value of 2, reload does not check to ensure that    the constraints of the insn are met.  Setting a cost of other than    2 will allow reload to verify that the constraints are met.  You    should do this if the `movM' pattern's constraints do not allow    such copying.     ??? We make the cost of moving from HI/LO into general    registers the same as for one of moving general registers to    HI/LO for TARGET_MIPS16 in order to prevent allocating a    pseudo to HI/LO.  This might hurt optimizations though, it    isn't clear if it is wise.  And it might not work in all cases.  We    could solve the DImode LO reg problem by using a multiply, just    like reload_{in,out}si.  We could solve the SImode/HImode HI reg    problem by using divide instructions.  divu puts the remainder in    the HI reg, so doing a divide by -1 will move the value in the HI    reg for all values except -1.  We could handle that case by using a    signed divide, e.g.  -1 / 2 (or maybe 1 / -2?).  We'd have to emit    a compare/branch to test the input value to see which instruction    we need to use.  This gets pretty messy, but it is feasible.  */
end_comment

begin_function
name|int
name|mips_register_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|reg_class
name|to
parameter_list|,
name|enum
name|reg_class
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
name|M16_REGS
operator|&&
name|GR_REG_CLASS_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|M16_NA_REGS
operator|&&
name|GR_REG_CLASS_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|GR_REG_CLASS_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
if|if
condition|(
name|to
operator|==
name|M16_REGS
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|to
operator|==
name|M16_NA_REGS
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|GR_REG_CLASS_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|to
operator|==
name|FP_REGS
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|to
argument_list|,
name|ACC_REGS
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
return|return
literal|12
return|;
else|else
return|return
literal|6
return|;
block|}
elseif|else
if|if
condition|(
name|COP_REG_CLASS_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
return|return
literal|5
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|from
operator|==
name|FP_REGS
condition|)
block|{
if|if
condition|(
name|GR_REG_CLASS_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|to
operator|==
name|FP_REGS
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|to
operator|==
name|ST_REGS
condition|)
return|return
literal|8
return|;
block|}
elseif|else
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|from
argument_list|,
name|ACC_REGS
argument_list|)
condition|)
block|{
if|if
condition|(
name|GR_REG_CLASS_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
return|return
literal|12
return|;
else|else
return|return
literal|6
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|from
operator|==
name|ST_REGS
operator|&&
name|GR_REG_CLASS_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|COP_REG_CLASS_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
return|return
literal|5
return|;
block|}
comment|/* Fall through.      ??? What cases are these? Shouldn't we return 2 here?  */
return|return
literal|12
return|;
block|}
end_function

begin_comment
comment|/* Return the length of INSN.  LENGTH is the initial length computed by    attributes in the machine-description file.  */
end_comment

begin_function
name|int
name|mips_adjust_insn_length
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* A unconditional jump has an unfilled delay slot if it is not part      of a sequence.  A conditional jump normally has a delay slot, but      does not on MIPS16.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|TARGET_MIPS16
condition|?
name|simplejump_p
argument_list|(
name|insn
argument_list|)
else|:
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|length
operator|+=
literal|4
expr_stmt|;
comment|/* See how many nops might be needed to avoid hardware hazards.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|ignore_hazard_length_p
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
switch|switch
condition|(
name|get_attr_hazard
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|HAZARD_NONE
case|:
break|break;
case|case
name|HAZARD_DELAY
case|:
name|length
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|HAZARD_HILO
case|:
name|length
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
comment|/* All MIPS16 instructions are a measly two bytes.  */
if|if
condition|(
name|TARGET_MIPS16
condition|)
name|length
operator|/=
literal|2
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Return an asm sequence to start a noat block and load the address    of a label into $1.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mips_output_load_label
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_EXPLICIT_RELOCS
condition|)
switch|switch
condition|(
name|mips_abi
condition|)
block|{
case|case
name|ABI_N32
case|:
return|return
literal|"%[lw\t%@,%%got_page(%0)(%+)\n\taddiu\t%@,%@,%%got_ofst(%0)"
return|;
case|case
name|ABI_64
case|:
return|return
literal|"%[ld\t%@,%%got_page(%0)(%+)\n\tdaddiu\t%@,%@,%%got_ofst(%0)"
return|;
default|default:
if|if
condition|(
name|ISA_HAS_LOAD_DELAY
condition|)
return|return
literal|"%[lw\t%@,%%got(%0)(%+)%#\n\taddiu\t%@,%@,%%lo(%0)"
return|;
return|return
literal|"%[lw\t%@,%%got(%0)(%+)\n\taddiu\t%@,%@,%%lo(%0)"
return|;
block|}
else|else
block|{
if|if
condition|(
name|Pmode
operator|==
name|DImode
condition|)
return|return
literal|"%[dla\t%@,%0"
return|;
else|else
return|return
literal|"%[la\t%@,%0"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the assembly code for INSN, which has the operands given by    OPERANDS, and which branches to OPERANDS[1] if some condition is true.    BRANCH_IF_TRUE is the asm template that should be used if OPERANDS[1]    is in range of a direct branch.  BRANCH_IF_FALSE is an inverted    version of BRANCH_IF_TRUE.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mips_output_conditional_branch
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
specifier|const
name|char
modifier|*
name|branch_if_true
parameter_list|,
specifier|const
name|char
modifier|*
name|branch_if_false
parameter_list|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|rtx
name|taken
decl_stmt|,
name|not_taken
decl_stmt|;
name|length
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|8
condition|)
block|{
comment|/* Just a simple conditional branch.  */
name|mips_branch_likely
operator|=
operator|(
name|final_sequence
operator|&&
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|)
expr_stmt|;
return|return
name|branch_if_true
return|;
block|}
comment|/* Generate a reversed branch around a direct jump.  This fallback does      not use branch-likely instructions.  */
name|mips_branch_likely
operator|=
name|false
expr_stmt|;
name|not_taken
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|taken
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* Generate the reversed branch to NOT_TAKEN.  */
name|operands
index|[
literal|1
index|]
operator|=
name|not_taken
expr_stmt|;
name|output_asm_insn
argument_list|(
name|branch_if_false
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* If INSN has a delay slot, we must provide delay slots for both the      branch to NOT_TAKEN and the conditional jump.  We must also ensure      that INSN's delay slot is executed in the appropriate cases.  */
if|if
condition|(
name|final_sequence
condition|)
block|{
comment|/* This first delay slot will always be executed, so use INSN's 	 delay slot if is not annulled.  */
if|if
condition|(
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|final_scan_insn
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSN_DELETED_P
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"nop"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Output the unconditional branch to TAKEN.  */
if|if
condition|(
name|length
operator|<=
literal|16
condition|)
name|output_asm_insn
argument_list|(
literal|"j\t%0%/"
argument_list|,
operator|&
name|taken
argument_list|)
expr_stmt|;
else|else
block|{
name|output_asm_insn
argument_list|(
name|mips_output_load_label
argument_list|()
argument_list|,
operator|&
name|taken
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jr\t%@%]%/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now deal with its delay slot; see above.  */
if|if
condition|(
name|final_sequence
condition|)
block|{
comment|/* This delay slot will only be executed if the branch is taken. 	 Use INSN's delay slot if is annulled.  */
if|if
condition|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|final_scan_insn
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSN_DELETED_P
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"nop"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Output NOT_TAKEN.  */
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|not_taken
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Return the assembly code for INSN, which branches to OPERANDS[1]    if some ordered condition is true.  The condition is given by    OPERANDS[0] if !INVERTED_P, otherwise it is the inverse of    OPERANDS[0].  OPERANDS[2] is the comparison's first operand;    its second is always zero.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mips_output_order_conditional_branch
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
name|bool
name|inverted_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|branch
index|[
literal|2
index|]
decl_stmt|;
comment|/* Make BRANCH[1] branch to OPERANDS[1] when the condition is true.      Make BRANCH[0] branch on the inverse condition.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* These cases are equivalent to comparisons against zero.  */
case|case
name|LEU
case|:
name|inverted_p
operator|=
operator|!
name|inverted_p
expr_stmt|;
comment|/* Fall through.  */
case|case
name|GTU
case|:
name|branch
index|[
operator|!
name|inverted_p
index|]
operator|=
name|MIPS_BRANCH
argument_list|(
literal|"bne"
argument_list|,
literal|"%2,%.,%1"
argument_list|)
expr_stmt|;
name|branch
index|[
name|inverted_p
index|]
operator|=
name|MIPS_BRANCH
argument_list|(
literal|"beq"
argument_list|,
literal|"%2,%.,%1"
argument_list|)
expr_stmt|;
break|break;
comment|/* These cases are always true or always false.  */
case|case
name|LTU
case|:
name|inverted_p
operator|=
operator|!
name|inverted_p
expr_stmt|;
comment|/* Fall through.  */
case|case
name|GEU
case|:
name|branch
index|[
operator|!
name|inverted_p
index|]
operator|=
name|MIPS_BRANCH
argument_list|(
literal|"beq"
argument_list|,
literal|"%.,%.,%1"
argument_list|)
expr_stmt|;
name|branch
index|[
name|inverted_p
index|]
operator|=
name|MIPS_BRANCH
argument_list|(
literal|"bne"
argument_list|,
literal|"%.,%.,%1"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|branch
index|[
operator|!
name|inverted_p
index|]
operator|=
name|MIPS_BRANCH
argument_list|(
literal|"b%C0z"
argument_list|,
literal|"%2,%1"
argument_list|)
expr_stmt|;
name|branch
index|[
name|inverted_p
index|]
operator|=
name|MIPS_BRANCH
argument_list|(
literal|"b%N0z"
argument_list|,
literal|"%2,%1"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|mips_output_conditional_branch
argument_list|(
name|insn
argument_list|,
name|operands
argument_list|,
name|branch
index|[
literal|1
index|]
argument_list|,
name|branch
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used to output div or ddiv instruction DIVISION, which has the operands    given by OPERANDS.  Add in a divide-by-zero check if needed.     When working around R4000 and R4400 errata, we need to make sure that    the division is not immediately followed by a shift[1][2].  We also    need to stop the division from being put into a branch delay slot[3].    The easiest way to avoid both problems is to add a nop after the    division.  When a divide-by-zero check is needed, this nop can be    used to fill the branch delay slot.     [1] If a double-word or a variable shift executes immediately        after starting an integer division, the shift may give an        incorrect result.  See quotations of errata #16 and #28 from        "MIPS R4000PC/SC Errata, Processor Revision 2.2 and 3.0"        in mips.md for details.     [2] A similar bug to [1] exists for all revisions of the        R4000 and the R4400 when run in an MC configuration.        From "MIPS R4000MC Errata, Processor Revision 2.2 and 3.0":         "19. In this following sequence:  		    ddiv		(or ddivu or div or divu) 		    dsll32		(or dsrl32, dsra32)  	    if an MPT stall occurs, while the divide is slipping the cpu 	    pipeline, then the following double shift would end up with an 	    incorrect result.  	    Workaround: The compiler needs to avoid generating any 	    sequence with divide followed by extended double shift."         This erratum is also present in "MIPS R4400MC Errata, Processor        Revision 1.0" and "MIPS R4400MC Errata, Processor Revision 2.0& 3.0" as errata #10 and #4, respectively.     [3] From "MIPS R4000PC/SC Errata, Processor Revision 2.2 and 3.0"        (also valid for MIPS R4000MC processors):         "52. R4000SC: This bug does not apply for the R4000PC.  	    There are two flavors of this bug:  	    1) If the instruction just after divide takes an RF exception 	       (tlb-refill, tlb-invalid) and gets an instruction cache 	       miss (both primary and secondary) and the line which is 	       currently in secondary cache at this index had the first 	       data word, where the bits 5..2 are set, then R4000 would 	       get a wrong result for the div.  	    ##1 		    nop 		    div	r8, r9 		    -------------------		# end-of page. -tlb-refill 		    nop 	    ##2 		    nop 		    div	r8, r9 		    -------------------		# end-of page. -tlb-invalid 		    nop  	    2) If the divide is in the taken branch delay slot, where the 	       target takes RF exception and gets an I-cache miss for the 	       exception vector or where I-cache miss occurs for the 	       target address, under the above mentioned scenarios, the 	       div would get wrong results.  	    ##1 		    j	r2		# to next page mapped or unmapped 		    div	r8,r9		# this bug would be there as long 					# as there is an ICache miss and 		    nop			# the "data pattern" is present  	    ##2 		    beq	r0, r0, NextPage	# to Next page 		    div	r8,r9 		    nop  	    This bug is present for div, divu, ddiv, and ddivu 	    instructions.  	    Workaround: For item 1), OS could make sure that the next page 	    after the divide instruction is also mapped.  For item 2), the 	    compiler could make sure that the divide instruction is not in 	    the branch delay slot."         These processors have PRId values of 0x00004220 and 0x00004300 for        the R4000 and 0x00004400, 0x00004500 and 0x00004600 for the R4400.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|mips_output_division
parameter_list|(
specifier|const
name|char
modifier|*
name|division
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|division
expr_stmt|;
if|if
condition|(
name|TARGET_FIX_R4000
operator|||
name|TARGET_FIX_R4400
condition|)
block|{
name|output_asm_insn
argument_list|(
name|s
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"nop"
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_CHECK_ZERO_DIV
condition|)
block|{
if|if
condition|(
name|TARGET_MIPS16
condition|)
block|{
name|output_asm_insn
argument_list|(
name|s
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"bnez\t%2,1f\n\tbreak\t7\n1:"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GENERATE_DIVIDE_TRAPS
condition|)
block|{
name|output_asm_insn
argument_list|(
name|s
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"teq\t%2,%.,7"
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"%(bne\t%2,%.,1f"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|s
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"break\t7%)\n1:"
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if GIVEN is the same as CANONICAL, or if it is CANONICAL    with a final "000" replaced by "k".  Ignore case.     Note: this function is shared between GCC and GAS.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_strict_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|canonical
parameter_list|,
specifier|const
name|char
modifier|*
name|given
parameter_list|)
block|{
while|while
condition|(
operator|*
name|given
operator|!=
literal|0
operator|&&
name|TOLOWER
argument_list|(
operator|*
name|given
argument_list|)
operator|==
name|TOLOWER
argument_list|(
operator|*
name|canonical
argument_list|)
condition|)
name|given
operator|++
operator|,
name|canonical
operator|++
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|given
operator|==
literal|0
operator|&&
operator|*
name|canonical
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|canonical
argument_list|,
literal|"000"
argument_list|)
operator|==
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|given
argument_list|,
literal|"k"
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if GIVEN matches CANONICAL, where GIVEN is a user-supplied    CPU name.  We've traditionally allowed a lot of variation here.     Note: this function is shared between GCC and GAS.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_matching_cpu_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|canonical
parameter_list|,
specifier|const
name|char
modifier|*
name|given
parameter_list|)
block|{
comment|/* First see if the name matches exactly, or with a final "000"      turned into "k".  */
if|if
condition|(
name|mips_strict_matching_cpu_name_p
argument_list|(
name|canonical
argument_list|,
name|given
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If not, try comparing based on numerical designation alone.      See if GIVEN is an unadorned number, or 'r' followed by a number.  */
if|if
condition|(
name|TOLOWER
argument_list|(
operator|*
name|given
argument_list|)
operator|==
literal|'r'
condition|)
name|given
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|given
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Skip over some well-known prefixes in the canonical name,      hoping to find a number there too.  */
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'v'
operator|&&
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'r'
condition|)
name|canonical
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
operator|&&
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'m'
condition|)
name|canonical
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|TOLOWER
argument_list|(
name|canonical
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'r'
condition|)
name|canonical
operator|+=
literal|1
expr_stmt|;
return|return
name|mips_strict_matching_cpu_name_p
argument_list|(
name|canonical
argument_list|,
name|given
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the mips_cpu_info entry for the processor or ISA given    by CPU_STRING.  Return null if the string isn't recognized.     A similar function exists in GAS.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_parse_cpu
parameter_list|(
specifier|const
name|char
modifier|*
name|cpu_string
parameter_list|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* In the past, we allowed upper-case CPU names, but it doesn't      work well with the multilib machinery.  */
for|for
control|(
name|s
operator|=
name|cpu_string
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"the cpu name must be lower case"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 'from-abi' selects the most compatible architecture for the given      ABI: MIPS I for 32-bit ABIs and MIPS III for 64-bit ABIs.  For the      EABIs, we have to decide whether we're using the 32-bit or 64-bit      version.  Look first at the -mgp options, if given, otherwise base      the choice on MASK_64BIT in TARGET_DEFAULT.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|cpu_string
argument_list|,
literal|"from-abi"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mips_cpu_info_from_isa
argument_list|(
name|ABI_NEEDS_32BIT_REGS
condition|?
literal|1
else|:
name|ABI_NEEDS_64BIT_REGS
condition|?
literal|3
else|:
operator|(
name|TARGET_64BIT
condition|?
literal|3
else|:
literal|1
operator|)
argument_list|)
return|;
comment|/* 'default' has traditionally been a no-op.  Probably not very useful.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|cpu_string
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|mips_cpu_info_table
init|;
name|p
operator|->
name|name
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|mips_matching_cpu_name_p
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cpu_string
argument_list|)
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the processor associated with the given ISA level, or null    if the ISA isn't valid.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|mips_cpu_info_from_isa
parameter_list|(
name|int
name|isa
parameter_list|)
block|{
specifier|const
name|struct
name|mips_cpu_info
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|mips_cpu_info_table
init|;
name|p
operator|->
name|name
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|isa
operator|==
name|isa
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement HARD_REGNO_NREGS.  The size of FP registers is controlled    by UNITS_PER_FPREG.  The size of FP status registers is always 4, because    they only hold condition code modes, and CCmode is always considered to    be 4 bytes wide.  All other registers are word sized.  */
end_comment

begin_function
name|unsigned
name|int
name|mips_hard_regno_nregs
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|ST_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_FPREG
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_FPREG
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_RETURN_IN_MEMORY.  Under the old (i.e., 32 and O64 ABIs)    all BLKmode objects are returned in memory.  Under the new (N32 and    64-bit MIPS ABIs) small structures are returned in a register.    Objects with varying size must still be returned in memory, of    course.  */
end_comment

begin_function
specifier|static
name|bool
name|mips_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_OLDABI
condition|)
return|return
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
operator|(
literal|2
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
operator|||
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|mips_strict_argument_naming
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|!
name|TARGET_OLDABI
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if INSN is a multiply-add or multiply-subtract    instruction and PREV assigns to the accumulator operand.  */
end_comment

begin_function
name|bool
name|mips_linked_madd_p
parameter_list|(
name|rtx
name|prev
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|prev
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|prev
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used by TUNE_MACC_CHAINS to record the last scheduled instruction    that may clobber hi or lo.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|mips_macc_chains_last_hilo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A TUNE_MACC_CHAINS helper function.  Record that instruction INSN has    been scheduled, updating mips_macc_chains_last_hilo appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|mips_macc_chains_record
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|get_attr_may_clobber_hilo
argument_list|(
name|insn
argument_list|)
condition|)
name|mips_macc_chains_last_hilo
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A TUNE_MACC_CHAINS helper function.  Search ready queue READY, which    has NREADY elements, looking for a multiply-add or multiply-subtract    instruction that is cumulative with mips_macc_chains_last_hilo.    If there is one, promote it ahead of anything else that might    clobber hi or lo.  */
end_comment

begin_function
specifier|static
name|void
name|mips_macc_chains_reorder
parameter_list|(
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
name|nready
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|mips_macc_chains_last_hilo
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
name|nready
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|mips_linked_madd_p
argument_list|(
name|mips_macc_chains_last_hilo
argument_list|,
name|ready
index|[
name|i
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
name|nready
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|recog_memoized
argument_list|(
name|ready
index|[
name|j
index|]
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_may_clobber_hilo
argument_list|(
name|ready
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|mips_promote_ready
argument_list|(
name|ready
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The last instruction to be scheduled.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|vr4130_last_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A note_stores callback used by vr4130_true_reg_dependence_p.  DATA    points to an rtx that is initially an instruction.  Nullify the rtx    if the instruction uses the value of register X.  */
end_comment

begin_function
specifier|static
name|void
name|vr4130_true_reg_dependence_p_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
modifier|*
name|insn_ptr
init|=
name|data
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|*
name|insn_ptr
operator|!=
literal|0
operator|&&
name|reg_referenced_p
argument_list|(
name|x
argument_list|,
name|PATTERN
argument_list|(
operator|*
name|insn_ptr
argument_list|)
argument_list|)
condition|)
operator|*
name|insn_ptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if there is true register dependence between vr4130_last_insn    and INSN.  */
end_comment

begin_function
specifier|static
name|bool
name|vr4130_true_reg_dependence_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|vr4130_last_insn
argument_list|)
argument_list|,
name|vr4130_true_reg_dependence_p_1
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A TUNE_MIPS4130 helper function.  Given that INSN1 is at the head of    the ready queue and that INSN2 is the instruction after it, return    true if it is worth promoting INSN2 ahead of INSN1.  Look for cases    in which INSN1 and INSN2 can probably issue in parallel, but for    which (INSN2, INSN1) should be less sensitive to instruction    alignment than (INSN1, INSN2).  See 4130.md for more details.  */
end_comment

begin_function
specifier|static
name|bool
name|vr4130_swap_insns_p
parameter_list|(
name|rtx
name|insn1
parameter_list|,
name|rtx
name|insn2
parameter_list|)
block|{
name|rtx
name|dep
decl_stmt|;
comment|/* Check for the following case:       1) there is some other instruction X with an anti dependence on INSN1;      2) X has a higher priority than INSN2; and      3) X is an arithmetic instruction (and thus has no unit restrictions).       If INSN1 is the last instruction blocking X, it would better to      choose (INSN1, X) over (INSN2, INSN1).  */
for|for
control|(
name|dep
operator|=
name|INSN_DEPEND
argument_list|(
name|insn1
argument_list|)
init|;
name|dep
operator|!=
literal|0
condition|;
name|dep
operator|=
name|XEXP
argument_list|(
name|dep
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|dep
argument_list|)
operator|==
name|REG_DEP_ANTI
operator|&&
name|INSN_PRIORITY
argument_list|(
name|XEXP
argument_list|(
name|dep
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|INSN_PRIORITY
argument_list|(
name|insn2
argument_list|)
operator|&&
name|recog_memoized
argument_list|(
name|XEXP
argument_list|(
name|dep
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_vr4130_class
argument_list|(
name|XEXP
argument_list|(
name|dep
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VR4130_CLASS_ALU
condition|)
return|return
name|false
return|;
if|if
condition|(
name|vr4130_last_insn
operator|!=
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|insn1
argument_list|)
operator|>=
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|insn2
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* See whether INSN1 and INSN2 use different execution units, 	 or if they are both ALU-type instructions.  If so, they can 	 probably execute in parallel.  */
name|enum
name|attr_vr4130_class
name|class1
init|=
name|get_attr_vr4130_class
argument_list|(
name|insn1
argument_list|)
decl_stmt|;
name|enum
name|attr_vr4130_class
name|class2
init|=
name|get_attr_vr4130_class
argument_list|(
name|insn2
argument_list|)
decl_stmt|;
if|if
condition|(
name|class1
operator|!=
name|class2
operator|||
name|class1
operator|==
name|VR4130_CLASS_ALU
condition|)
block|{
comment|/* If only one of the instructions has a dependence on 	     vr4130_last_insn, prefer to schedule the other one first.  */
name|bool
name|dep1
init|=
name|vr4130_true_reg_dependence_p
argument_list|(
name|insn1
argument_list|)
decl_stmt|;
name|bool
name|dep2
init|=
name|vr4130_true_reg_dependence_p
argument_list|(
name|insn2
argument_list|)
decl_stmt|;
if|if
condition|(
name|dep1
operator|!=
name|dep2
condition|)
return|return
name|dep1
return|;
comment|/* Prefer to schedule INSN2 ahead of INSN1 if vr4130_last_insn 	     is not an ALU-type instruction and if INSN1 uses the same 	     execution unit.  (Note that if this condition holds, we already 	     know that INSN2 uses a different execution unit.)  */
if|if
condition|(
name|class1
operator|!=
name|VR4130_CLASS_ALU
operator|&&
name|recog_memoized
argument_list|(
name|vr4130_last_insn
argument_list|)
operator|>=
literal|0
operator|&&
name|class1
operator|==
name|get_attr_vr4130_class
argument_list|(
name|vr4130_last_insn
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A TUNE_MIPS4130 helper function.  (READY, NREADY) describes a ready    queue with at least two instructions.  Swap the first two if    vr4130_swap_insns_p says that it could be worthwhile.  */
end_comment

begin_function
specifier|static
name|void
name|vr4130_reorder
parameter_list|(
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
name|nready
parameter_list|)
block|{
if|if
condition|(
name|vr4130_swap_insns_p
argument_list|(
name|ready
index|[
name|nready
operator|-
literal|1
index|]
argument_list|,
name|ready
index|[
name|nready
operator|-
literal|2
index|]
argument_list|)
condition|)
name|mips_promote_ready
argument_list|(
name|ready
argument_list|,
name|nready
operator|-
literal|2
argument_list|,
name|nready
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove the instruction at index LOWER from ready queue READY and    reinsert it in front of the instruction at index HIGHER.  LOWER must    be<= HIGHER.  */
end_comment

begin_function
specifier|static
name|void
name|mips_promote_ready
parameter_list|(
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
name|lower
parameter_list|,
name|int
name|higher
parameter_list|)
block|{
name|rtx
name|new_head
decl_stmt|;
name|int
name|i
decl_stmt|;
name|new_head
operator|=
name|ready
index|[
name|lower
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lower
init|;
name|i
operator|<
name|higher
condition|;
name|i
operator|++
control|)
name|ready
index|[
name|i
index|]
operator|=
name|ready
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|ready
index|[
name|i
index|]
operator|=
name|new_head
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_SCHED_REORDER.  */
end_comment

begin_function
specifier|static
name|int
name|mips_sched_reorder
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|nreadyp
parameter_list|,
name|int
name|cycle
parameter_list|)
block|{
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|TUNE_MACC_CHAINS
condition|)
block|{
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
name|mips_macc_chains_last_hilo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|nreadyp
operator|>
literal|0
condition|)
name|mips_macc_chains_reorder
argument_list|(
name|ready
argument_list|,
operator|*
name|nreadyp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_completed
operator|&&
name|TUNE_MIPS4130
operator|&&
operator|!
name|TARGET_VR4130_ALIGN
condition|)
block|{
if|if
condition|(
name|cycle
operator|==
literal|0
condition|)
name|vr4130_last_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|nreadyp
operator|>
literal|1
condition|)
name|vr4130_reorder
argument_list|(
name|ready
argument_list|,
operator|*
name|nreadyp
argument_list|)
expr_stmt|;
block|}
return|return
name|mips_issue_rate
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_SCHED_VARIABLE_ISSUE.  */
end_comment

begin_function
specifier|static
name|int
name|mips_variable_issue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|more
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
comment|/* Don't count USEs and CLOBBERs against the issue rate.  */
break|break;
default|default:
name|more
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|TUNE_MACC_CHAINS
condition|)
name|mips_macc_chains_record
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|vr4130_last_insn
operator|=
name|insn
expr_stmt|;
break|break;
block|}
return|return
name|more
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement TARGET_SCHED_ADJUST_COST.  We assume that anti and output    dependencies have no cost.  */
end_comment

begin_function
specifier|static
name|int
name|mips_adjust_cost
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return the number of instructions that can be issued per cycle.  */
end_comment

begin_function
specifier|static
name|int
name|mips_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|mips_tune
condition|)
block|{
case|case
name|PROCESSOR_R4130
case|:
case|case
name|PROCESSOR_R5400
case|:
case|case
name|PROCESSOR_R5500
case|:
case|case
name|PROCESSOR_R7000
case|:
case|case
name|PROCESSOR_R9000
case|:
return|return
literal|2
return|;
case|case
name|PROCESSOR_SB1
case|:
case|case
name|PROCESSOR_SB1A
case|:
comment|/* This is actually 4, but we get better performance if we claim 3. 	 This is partly because of unwanted speculative code motion with the 	 larger number, and partly because in most common cases we can't 	 reach the theoretical max of 4.  */
return|return
literal|3
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implements TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD.  This should    be as wide as the scheduling freedom in the DFA.  */
end_comment

begin_function
specifier|static
name|int
name|mips_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Can schedule up to 4 of the 6 function units in any one cycle.  */
if|if
condition|(
name|TUNE_SB1
condition|)
return|return
literal|4
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implements a store data bypass check.  We need this because the cprestore    pattern is type store, but defined using an UNSPEC.  This UNSPEC causes the    default routine to abort.  We just return false for that case.  */
end_comment

begin_comment
comment|/* ??? Should try to give a better result here than assuming false.  */
end_comment

begin_function
name|int
name|mips_store_data_bypass_p
parameter_list|(
name|rtx
name|out_insn
parameter_list|,
name|rtx
name|in_insn
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|in_insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
condition|)
return|return
name|false
return|;
return|return
operator|!
name|store_data_bypass_p
argument_list|(
name|out_insn
argument_list|,
name|in_insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given that we have an rtx of the form (prefetch ... WRITE LOCALITY),    return the first operand of the associated "pref" or "prefx" insn.  */
end_comment

begin_function
name|rtx
name|mips_prefetch_cookie
parameter_list|(
name|rtx
name|write
parameter_list|,
name|rtx
name|locality
parameter_list|)
block|{
comment|/* store_streamed / load_streamed.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|locality
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|write
argument_list|)
operator|+
literal|4
argument_list|)
return|;
comment|/* store / load.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|locality
argument_list|)
operator|<=
literal|2
condition|)
return|return
name|write
return|;
comment|/* store_retained / load_retained.  */
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|write
argument_list|)
operator|+
literal|6
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS builtin function support. */
end_comment

begin_struct
struct|struct
name|builtin_description
block|{
comment|/* The code of the main .md file instruction.  See mips_builtin_type      for more information.  */
name|enum
name|insn_code
name|icode
decl_stmt|;
comment|/* The floating-point comparison code to use with ICODE, if any.  */
name|enum
name|mips_fp_condition
name|cond
decl_stmt|;
comment|/* The name of the builtin function.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Specifies how the function should be expanded.  */
name|enum
name|mips_builtin_type
name|builtin_type
decl_stmt|;
comment|/* The function's prototype.  */
name|enum
name|mips_function_type
name|function_type
decl_stmt|;
comment|/* The target flags required for this function.  */
name|int
name|target_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Define a MIPS_BUILTIN_DIRECT function for instruction CODE_FOR_mips_<INSN>.    FUNCTION_TYPE and TARGET_FLAGS are builtin_description fields.  */
end_comment

begin_define
define|#
directive|define
name|DIRECT_BUILTIN
parameter_list|(
name|INSN
parameter_list|,
name|FUNCTION_TYPE
parameter_list|,
name|TARGET_FLAGS
parameter_list|)
define|\
value|{ CODE_FOR_mips_ ## INSN, 0, "__builtin_mips_" #INSN,			\     MIPS_BUILTIN_DIRECT, FUNCTION_TYPE, TARGET_FLAGS }
end_define

begin_comment
comment|/* Define __builtin_mips_<INSN>_<COND>_{s,d}, both of which require    TARGET_FLAGS.  */
end_comment

begin_define
define|#
directive|define
name|CMP_SCALAR_BUILTINS
parameter_list|(
name|INSN
parameter_list|,
name|COND
parameter_list|,
name|TARGET_FLAGS
parameter_list|)
define|\
value|{ CODE_FOR_mips_ ## INSN ## _cond_s, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_" #INSN "_" #COND "_s",				\     MIPS_BUILTIN_CMP_SINGLE, MIPS_INT_FTYPE_SF_SF, TARGET_FLAGS },	\   { CODE_FOR_mips_ ## INSN ## _cond_d, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_" #INSN "_" #COND "_d",				\     MIPS_BUILTIN_CMP_SINGLE, MIPS_INT_FTYPE_DF_DF, TARGET_FLAGS }
end_define

begin_comment
comment|/* Define __builtin_mips_{any,all,upper,lower}_<INSN>_<COND>_ps.    The lower and upper forms require TARGET_FLAGS while the any and all    forms require MASK_MIPS3D.  */
end_comment

begin_define
define|#
directive|define
name|CMP_PS_BUILTINS
parameter_list|(
name|INSN
parameter_list|,
name|COND
parameter_list|,
name|TARGET_FLAGS
parameter_list|)
define|\
value|{ CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_any_" #INSN "_" #COND "_ps",			\     MIPS_BUILTIN_CMP_ANY, MIPS_INT_FTYPE_V2SF_V2SF, MASK_MIPS3D },	\   { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_all_" #INSN "_" #COND "_ps",			\     MIPS_BUILTIN_CMP_ALL, MIPS_INT_FTYPE_V2SF_V2SF, MASK_MIPS3D },	\   { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_lower_" #INSN "_" #COND "_ps",			\     MIPS_BUILTIN_CMP_LOWER, MIPS_INT_FTYPE_V2SF_V2SF, TARGET_FLAGS },	\   { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_upper_" #INSN "_" #COND "_ps",			\     MIPS_BUILTIN_CMP_UPPER, MIPS_INT_FTYPE_V2SF_V2SF, TARGET_FLAGS }
end_define

begin_comment
comment|/* Define __builtin_mips_{any,all}_<INSN>_<COND>_4s.  The functions    require MASK_MIPS3D.  */
end_comment

begin_define
define|#
directive|define
name|CMP_4S_BUILTINS
parameter_list|(
name|INSN
parameter_list|,
name|COND
parameter_list|)
define|\
value|{ CODE_FOR_mips_ ## INSN ## _cond_4s, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_any_" #INSN "_" #COND "_4s",			\     MIPS_BUILTIN_CMP_ANY, MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF,		\     MASK_MIPS3D },							\   { CODE_FOR_mips_ ## INSN ## _cond_4s, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_all_" #INSN "_" #COND "_4s",			\     MIPS_BUILTIN_CMP_ALL, MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF,		\     MASK_MIPS3D }
end_define

begin_comment
comment|/* Define __builtin_mips_mov{t,f}_<INSN>_<COND>_ps.  The comparison    instruction requires TARGET_FLAGS.  */
end_comment

begin_define
define|#
directive|define
name|MOVTF_BUILTINS
parameter_list|(
name|INSN
parameter_list|,
name|COND
parameter_list|,
name|TARGET_FLAGS
parameter_list|)
define|\
value|{ CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_movt_" #INSN "_" #COND "_ps",			\     MIPS_BUILTIN_MOVT, MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF,		\     TARGET_FLAGS },							\   { CODE_FOR_mips_ ## INSN ## _cond_ps, MIPS_FP_COND_ ## COND,		\     "__builtin_mips_movf_" #INSN "_" #COND "_ps",			\     MIPS_BUILTIN_MOVF, MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF,		\     TARGET_FLAGS }
end_define

begin_comment
comment|/* Define all the builtins related to c.cond.fmt condition COND.  */
end_comment

begin_define
define|#
directive|define
name|CMP_BUILTINS
parameter_list|(
name|COND
parameter_list|)
define|\
value|MOVTF_BUILTINS (c, COND, MASK_PAIRED_SINGLE_FLOAT),			\   MOVTF_BUILTINS (cabs, COND, MASK_MIPS3D),				\   CMP_SCALAR_BUILTINS (cabs, COND, MASK_MIPS3D),			\   CMP_PS_BUILTINS (c, COND, MASK_PAIRED_SINGLE_FLOAT),			\   CMP_PS_BUILTINS (cabs, COND, MASK_MIPS3D),				\   CMP_4S_BUILTINS (c, COND),						\   CMP_4S_BUILTINS (cabs, COND)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|mips_bdesc
index|[]
init|=
block|{
name|DIRECT_BUILTIN
argument_list|(
name|pll_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|pul_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|plu_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|puu_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cvt_ps_s
argument_list|,
name|MIPS_V2SF_FTYPE_SF_SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cvt_s_pl
argument_list|,
name|MIPS_SF_FTYPE_V2SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cvt_s_pu
argument_list|,
name|MIPS_SF_FTYPE_V2SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|abs_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|alnv_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF_INT
argument_list|,
name|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|addr_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|mulr_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cvt_pw_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cvt_ps_pw
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|recip1_s
argument_list|,
name|MIPS_SF_FTYPE_SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|recip1_d
argument_list|,
name|MIPS_DF_FTYPE_DF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|recip1_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|recip2_s
argument_list|,
name|MIPS_SF_FTYPE_SF_SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|recip2_d
argument_list|,
name|MIPS_DF_FTYPE_DF_DF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|recip2_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|rsqrt1_s
argument_list|,
name|MIPS_SF_FTYPE_SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|rsqrt1_d
argument_list|,
name|MIPS_DF_FTYPE_DF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|rsqrt1_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|rsqrt2_s
argument_list|,
name|MIPS_SF_FTYPE_SF_SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|rsqrt2_d
argument_list|,
name|MIPS_DF_FTYPE_DF_DF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|rsqrt2_ps
argument_list|,
name|MIPS_V2SF_FTYPE_V2SF_V2SF
argument_list|,
name|MASK_MIPS3D
argument_list|)
block|,
name|MIPS_FP_CONDITIONS
argument_list|(
argument|CMP_BUILTINS
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Builtin functions for the SB-1 processor.  */
end_comment

begin_define
define|#
directive|define
name|CODE_FOR_mips_sqrt_ps
value|CODE_FOR_sqrtv2sf2
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|sb1_bdesc
index|[]
init|=
block|{
name|DIRECT_BUILTIN
argument_list|(
argument|sqrt_ps
argument_list|,
argument|MIPS_V2SF_FTYPE_V2SF
argument_list|,
argument|MASK_PAIRED_SINGLE_FLOAT
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Builtin functions for DSP ASE.  */
end_comment

begin_define
define|#
directive|define
name|CODE_FOR_mips_addq_ph
value|CODE_FOR_addv2hi3
end_define

begin_define
define|#
directive|define
name|CODE_FOR_mips_addu_qb
value|CODE_FOR_addv4qi3
end_define

begin_define
define|#
directive|define
name|CODE_FOR_mips_subq_ph
value|CODE_FOR_subv2hi3
end_define

begin_define
define|#
directive|define
name|CODE_FOR_mips_subu_qb
value|CODE_FOR_subv4qi3
end_define

begin_comment
comment|/* Define a MIPS_BUILTIN_DIRECT_NO_TARGET function for instruction    CODE_FOR_mips_<INSN>.  FUNCTION_TYPE and TARGET_FLAGS are    builtin_description fields.  */
end_comment

begin_define
define|#
directive|define
name|DIRECT_NO_TARGET_BUILTIN
parameter_list|(
name|INSN
parameter_list|,
name|FUNCTION_TYPE
parameter_list|,
name|TARGET_FLAGS
parameter_list|)
define|\
value|{ CODE_FOR_mips_ ## INSN, 0, "__builtin_mips_" #INSN,			\     MIPS_BUILTIN_DIRECT_NO_TARGET, FUNCTION_TYPE, TARGET_FLAGS }
end_define

begin_comment
comment|/* Define __builtin_mips_bposge<VALUE>.<VALUE> is 32 for the MIPS32 DSP    branch instruction.  TARGET_FLAGS is a builtin_description field.  */
end_comment

begin_define
define|#
directive|define
name|BPOSGE_BUILTIN
parameter_list|(
name|VALUE
parameter_list|,
name|TARGET_FLAGS
parameter_list|)
define|\
value|{ CODE_FOR_mips_bposge, 0, "__builtin_mips_bposge" #VALUE,		\     MIPS_BUILTIN_BPOSGE ## VALUE, MIPS_SI_FTYPE_VOID, TARGET_FLAGS }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|dsp_bdesc
index|[]
init|=
block|{
name|DIRECT_BUILTIN
argument_list|(
name|addq_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|addq_s_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|addq_s_w
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|addu_qb
argument_list|,
name|MIPS_V4QI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|addu_s_qb
argument_list|,
name|MIPS_V4QI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|subq_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|subq_s_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|subq_s_w
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|subu_qb
argument_list|,
name|MIPS_V4QI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|subu_s_qb
argument_list|,
name|MIPS_V4QI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|addsc
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|addwc
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|modsub
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|raddu_w_qb
argument_list|,
name|MIPS_SI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|absq_s_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|absq_s_w
argument_list|,
name|MIPS_SI_FTYPE_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precrq_qb_ph
argument_list|,
name|MIPS_V4QI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precrq_ph_w
argument_list|,
name|MIPS_V2HI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precrq_rs_ph_w
argument_list|,
name|MIPS_V2HI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precrqu_s_qb_ph
argument_list|,
name|MIPS_V4QI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|preceq_w_phl
argument_list|,
name|MIPS_SI_FTYPE_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|preceq_w_phr
argument_list|,
name|MIPS_SI_FTYPE_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precequ_ph_qbl
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precequ_ph_qbr
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precequ_ph_qbla
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|precequ_ph_qbra
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|preceu_ph_qbl
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|preceu_ph_qbr
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|preceu_ph_qbla
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|preceu_ph_qbra
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shll_qb
argument_list|,
name|MIPS_V4QI_FTYPE_V4QI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shll_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shll_s_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shll_s_w
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shrl_qb
argument_list|,
name|MIPS_V4QI_FTYPE_V4QI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shra_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shra_r_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shra_r_w
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|muleu_s_ph_qbl
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|muleu_s_ph_qbr
argument_list|,
name|MIPS_V2HI_FTYPE_V4QI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|mulq_rs_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|muleq_s_w_phl
argument_list|,
name|MIPS_SI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|muleq_s_w_phr
argument_list|,
name|MIPS_SI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpau_h_qbl
argument_list|,
name|MIPS_DI_FTYPE_DI_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpau_h_qbr
argument_list|,
name|MIPS_DI_FTYPE_DI_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpsu_h_qbl
argument_list|,
name|MIPS_DI_FTYPE_DI_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpsu_h_qbr
argument_list|,
name|MIPS_DI_FTYPE_DI_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpaq_s_w_ph
argument_list|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpsq_s_w_ph
argument_list|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|mulsaq_s_w_ph
argument_list|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpaq_sa_l_w
argument_list|,
name|MIPS_DI_FTYPE_DI_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|dpsq_sa_l_w
argument_list|,
name|MIPS_DI_FTYPE_DI_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|maq_s_w_phl
argument_list|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|maq_s_w_phr
argument_list|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|maq_sa_w_phl
argument_list|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|maq_sa_w_phr
argument_list|,
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|bitrev
argument_list|,
name|MIPS_SI_FTYPE_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|insv
argument_list|,
name|MIPS_SI_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|repl_qb
argument_list|,
name|MIPS_V4QI_FTYPE_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|repl_ph
argument_list|,
name|MIPS_V2HI_FTYPE_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_NO_TARGET_BUILTIN
argument_list|(
name|cmpu_eq_qb
argument_list|,
name|MIPS_VOID_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_NO_TARGET_BUILTIN
argument_list|(
name|cmpu_lt_qb
argument_list|,
name|MIPS_VOID_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_NO_TARGET_BUILTIN
argument_list|(
name|cmpu_le_qb
argument_list|,
name|MIPS_VOID_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cmpgu_eq_qb
argument_list|,
name|MIPS_SI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cmpgu_lt_qb
argument_list|,
name|MIPS_SI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|cmpgu_le_qb
argument_list|,
name|MIPS_SI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_NO_TARGET_BUILTIN
argument_list|(
name|cmp_eq_ph
argument_list|,
name|MIPS_VOID_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_NO_TARGET_BUILTIN
argument_list|(
name|cmp_lt_ph
argument_list|,
name|MIPS_VOID_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_NO_TARGET_BUILTIN
argument_list|(
name|cmp_le_ph
argument_list|,
name|MIPS_VOID_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|pick_qb
argument_list|,
name|MIPS_V4QI_FTYPE_V4QI_V4QI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|pick_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|packrl_ph
argument_list|,
name|MIPS_V2HI_FTYPE_V2HI_V2HI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|extr_w
argument_list|,
name|MIPS_SI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|extr_r_w
argument_list|,
name|MIPS_SI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|extr_rs_w
argument_list|,
name|MIPS_SI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|extr_s_h
argument_list|,
name|MIPS_SI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|extp
argument_list|,
name|MIPS_SI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|extpdp
argument_list|,
name|MIPS_SI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|shilo
argument_list|,
name|MIPS_DI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|mthlip
argument_list|,
name|MIPS_DI_FTYPE_DI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_NO_TARGET_BUILTIN
argument_list|(
name|wrdsp
argument_list|,
name|MIPS_VOID_FTYPE_SI_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|rddsp
argument_list|,
name|MIPS_SI_FTYPE_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|lbux
argument_list|,
name|MIPS_SI_FTYPE_PTR_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|lhx
argument_list|,
name|MIPS_SI_FTYPE_PTR_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|DIRECT_BUILTIN
argument_list|(
name|lwx
argument_list|,
name|MIPS_SI_FTYPE_PTR_SI
argument_list|,
name|MASK_DSP
argument_list|)
block|,
name|BPOSGE_BUILTIN
argument_list|(
literal|32
argument_list|,
argument|MASK_DSP
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This helps provide a mapping from builtin function codes to bdesc    arrays.  */
end_comment

begin_struct
struct|struct
name|bdesc_map
block|{
comment|/* The builtin function table that this entry describes.  */
specifier|const
name|struct
name|builtin_description
modifier|*
name|bdesc
decl_stmt|;
comment|/* The number of entries in the builtin function table.  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* The target processor that supports these builtin functions.      PROCESSOR_MAX means we enable them for all processors.  */
name|enum
name|processor_type
name|proc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bdesc_map
name|bdesc_arrays
index|[]
init|=
block|{
block|{
name|mips_bdesc
block|,
name|ARRAY_SIZE
argument_list|(
name|mips_bdesc
argument_list|)
block|,
name|PROCESSOR_MAX
block|}
block|,
block|{
name|sb1_bdesc
block|,
name|ARRAY_SIZE
argument_list|(
name|sb1_bdesc
argument_list|)
block|,
name|PROCESSOR_SB1
block|}
block|,
block|{
name|dsp_bdesc
block|,
name|ARRAY_SIZE
argument_list|(
name|dsp_bdesc
argument_list|)
block|,
name|PROCESSOR_MAX
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take the head of argument list *ARGLIST and convert it into a form    suitable for input operand OP of instruction ICODE.  Return the value    and point *ARGLIST at the next element of the list.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_prepare_builtin_arg
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|,
name|tree
modifier|*
name|arglist
parameter_list|)
block|{
name|rtx
name|value
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|value
operator|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|op
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|op
index|]
operator|.
name|predicate
argument_list|(
name|value
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|value
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Check the predicate again.  */
if|if
condition|(
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|op
index|]
operator|.
name|predicate
argument_list|(
name|value
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid argument to builtin function"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
block|}
operator|*
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|arglist
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx suitable for output operand OP of instruction ICODE.    If TARGET is non-null, try to use it where possible.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_prepare_builtin_target
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|op
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
operator|!
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
name|op
index|]
operator|.
name|predicate
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand builtin functions.  This is called from TARGET_EXPAND_BUILTIN.  */
end_comment

begin_function
name|rtx
name|mips_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|mips_builtin_type
name|type
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|arglist
decl_stmt|;
name|unsigned
name|int
name|fcode
decl_stmt|;
specifier|const
name|struct
name|builtin_description
modifier|*
name|bdesc
decl_stmt|;
specifier|const
name|struct
name|bdesc_map
modifier|*
name|m
decl_stmt|;
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|bdesc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|m
operator|=
name|bdesc_arrays
init|;
name|m
operator|<
operator|&
name|bdesc_arrays
index|[
name|ARRAY_SIZE
argument_list|(
name|bdesc_arrays
argument_list|)
index|]
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
name|fcode
operator|<
name|m
operator|->
name|size
condition|)
block|{
name|bdesc
operator|=
name|m
operator|->
name|bdesc
expr_stmt|;
name|icode
operator|=
name|bdesc
index|[
name|fcode
index|]
operator|.
name|icode
expr_stmt|;
name|type
operator|=
name|bdesc
index|[
name|fcode
index|]
operator|.
name|builtin_type
expr_stmt|;
break|break;
block|}
name|fcode
operator|-=
name|m
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|bdesc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MIPS_BUILTIN_DIRECT
case|:
return|return
name|mips_expand_builtin_direct
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|arglist
argument_list|,
name|true
argument_list|)
return|;
case|case
name|MIPS_BUILTIN_DIRECT_NO_TARGET
case|:
return|return
name|mips_expand_builtin_direct
argument_list|(
name|icode
argument_list|,
name|target
argument_list|,
name|arglist
argument_list|,
name|false
argument_list|)
return|;
case|case
name|MIPS_BUILTIN_MOVT
case|:
case|case
name|MIPS_BUILTIN_MOVF
case|:
return|return
name|mips_expand_builtin_movtf
argument_list|(
name|type
argument_list|,
name|icode
argument_list|,
name|bdesc
index|[
name|fcode
index|]
operator|.
name|cond
argument_list|,
name|target
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|MIPS_BUILTIN_CMP_ANY
case|:
case|case
name|MIPS_BUILTIN_CMP_ALL
case|:
case|case
name|MIPS_BUILTIN_CMP_UPPER
case|:
case|case
name|MIPS_BUILTIN_CMP_LOWER
case|:
case|case
name|MIPS_BUILTIN_CMP_SINGLE
case|:
return|return
name|mips_expand_builtin_compare
argument_list|(
name|type
argument_list|,
name|icode
argument_list|,
name|bdesc
index|[
name|fcode
index|]
operator|.
name|cond
argument_list|,
name|target
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|MIPS_BUILTIN_BPOSGE32
case|:
return|return
name|mips_expand_builtin_bposge
argument_list|(
name|type
argument_list|,
name|target
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Init builtin functions.  This is called from TARGET_INIT_BUILTIN.  */
end_comment

begin_function
name|void
name|mips_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
specifier|const
name|struct
name|bdesc_map
modifier|*
name|m
decl_stmt|;
name|tree
name|types
index|[
operator|(
name|int
operator|)
name|MIPS_MAX_FTYPE_MAX
index|]
decl_stmt|;
name|tree
name|V2SF_type_node
decl_stmt|;
name|tree
name|V2HI_type_node
decl_stmt|;
name|tree
name|V4QI_type_node
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* We have only builtins for -mpaired-single, -mips3d and -mdsp.  */
if|if
condition|(
operator|!
name|TARGET_PAIRED_SINGLE_FLOAT
operator|&&
operator|!
name|TARGET_DSP
condition|)
return|return;
if|if
condition|(
name|TARGET_PAIRED_SINGLE_FLOAT
condition|)
block|{
name|V2SF_type_node
operator|=
name|build_vector_type_for_mode
argument_list|(
name|float_type_node
argument_list|,
name|V2SFmode
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2SF_FTYPE_V2SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2SF_FTYPE_V2SF_V2SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2SF_FTYPE_V2SF_V2SF_INT
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2SF_FTYPE_SF_SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_INT_FTYPE_V2SF_V2SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_INT_FTYPE_SF_SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_INT_FTYPE_DF_DF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|double_type_node
argument_list|,
name|double_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SF_FTYPE_V2SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|float_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SF_FTYPE_SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SF_FTYPE_SF_SF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|float_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_DF_FTYPE_DF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|double_type_node
argument_list|,
name|double_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_DF_FTYPE_DF_DF
index|]
operator|=
name|build_function_type_list
argument_list|(
name|double_type_node
argument_list|,
name|double_type_node
argument_list|,
name|double_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_DSP
condition|)
block|{
name|V2HI_type_node
operator|=
name|build_vector_type_for_mode
argument_list|(
name|intHI_type_node
argument_list|,
name|V2HImode
argument_list|)
expr_stmt|;
name|V4QI_type_node
operator|=
name|build_vector_type_for_mode
argument_list|(
name|intQI_type_node
argument_list|,
name|V4QImode
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2HI_FTYPE_V2HI_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_SI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V4QI_FTYPE_V4QI_V4QI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V4QI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_V4QI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2HI_FTYPE_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V4QI_FTYPE_V2HI_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V4QI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2HI_FTYPE_SI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2HI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2HI_FTYPE_V4QI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2HI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V4QI_FTYPE_V4QI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V4QI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2HI_FTYPE_V2HI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2HI_FTYPE_V4QI_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2HI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_V2HI_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_DI_FTYPE_DI_V4QI_V4QI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intDI_type_node
argument_list|,
name|intDI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_DI_FTYPE_DI_V2HI_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intDI_type_node
argument_list|,
name|intDI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_DI_FTYPE_DI_SI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intDI_type_node
argument_list|,
name|intDI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V4QI_FTYPE_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V4QI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_V2HI_FTYPE_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|V2HI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_VOID_FTYPE_V4QI_V4QI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_V4QI_V4QI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|V4QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_VOID_FTYPE_V2HI_V2HI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|V2HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_DI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|intDI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_DI_FTYPE_DI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intDI_type_node
argument_list|,
name|intDI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_VOID_FTYPE_SI_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_PTR_SI
index|]
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|ptr_type_node
argument_list|,
name|intSI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|types
index|[
name|MIPS_SI_FTYPE_VOID
index|]
operator|=
name|build_function_type
argument_list|(
name|intSI_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
block|}
comment|/* Iterate through all of the bdesc arrays, initializing all of the      builtin functions.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|bdesc_arrays
init|;
name|m
operator|<
operator|&
name|bdesc_arrays
index|[
name|ARRAY_SIZE
argument_list|(
name|bdesc_arrays
argument_list|)
index|]
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|proc
operator|==
name|PROCESSOR_MAX
operator|||
operator|(
name|m
operator|->
name|proc
operator|==
name|mips_arch
operator|)
condition|)
for|for
control|(
name|d
operator|=
name|m
operator|->
name|bdesc
init|;
name|d
operator|<
operator|&
name|m
operator|->
name|bdesc
index|[
name|m
operator|->
name|size
index|]
condition|;
name|d
operator|++
control|)
if|if
condition|(
operator|(
name|d
operator|->
name|target_flags
operator|&
name|target_flags
operator|)
operator|==
name|d
operator|->
name|target_flags
condition|)
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|types
index|[
name|d
operator|->
name|function_type
index|]
argument_list|,
name|d
operator|-
name|m
operator|->
name|bdesc
operator|+
name|offset
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|m
operator|->
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a MIPS_BUILTIN_DIRECT function.  ICODE is the code of the    .md pattern and ARGLIST is the list of function arguments.  TARGET,    if nonnull, suggests a good place to put the result.    HAS_TARGET indicates the function must return something.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_expand_builtin_direct
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|rtx
name|target
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|bool
name|has_target
parameter_list|)
block|{
name|rtx
name|ops
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|has_target
condition|)
block|{
comment|/* We save target to ops[0].  */
name|ops
index|[
literal|0
index|]
operator|=
name|mips_prepare_builtin_target
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We need to test if arglist is not zero.  Some instructions have extra      clobber registers.  */
for|for
control|(
init|;
name|i
operator|<
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_operands
operator|&&
name|arglist
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
name|i
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|2
case|:
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|ops
index|[
literal|0
index|]
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|,
name|ops
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a __builtin_mips_movt_*_ps() or __builtin_mips_movf_*_ps()    function (TYPE says which).  ARGLIST is the list of arguments to the    function, ICODE is the instruction that should be used to compare    the first two arguments, and COND is the condition it should test.    TARGET, if nonnull, suggests a good place to put the result.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_expand_builtin_movtf
parameter_list|(
name|enum
name|mips_builtin_type
name|type
parameter_list|,
name|enum
name|insn_code
name|icode
parameter_list|,
name|enum
name|mips_fp_condition
name|cond
parameter_list|,
name|rtx
name|target
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|rtx
name|cmp_result
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|cmp_result
operator|=
name|mips_prepare_builtin_target
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
name|op1
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|cmp_result
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|GEN_INT
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_mips_cond_move_tf_ps
expr_stmt|;
name|target
operator|=
name|mips_prepare_builtin_target
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MIPS_BUILTIN_MOVT
condition|)
block|{
name|op1
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
literal|1
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
name|op1
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
literal|2
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_mips_cond_move_tf_ps
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|cmp_result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Move VALUE_IF_TRUE into TARGET if CONDITION is true; move VALUE_IF_FALSE    into TARGET otherwise.  Return TARGET.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_builtin_branch_and_move
parameter_list|(
name|rtx
name|condition
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|value_if_true
parameter_list|,
name|rtx
name|value_if_false
parameter_list|)
block|{
name|rtx
name|true_label
decl_stmt|,
name|done_label
decl_stmt|;
name|true_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|done_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* First assume that CONDITION is false.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value_if_false
argument_list|)
expr_stmt|;
comment|/* Branch to TRUE_LABEL if CONDITION is true and DONE_LABEL otherwise.  */
name|emit_jump_insn
argument_list|(
name|gen_condjump
argument_list|(
name|condition
argument_list|,
name|true_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|done_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Fix TARGET if CONDITION is true.  */
name|emit_label
argument_list|(
name|true_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value_if_true
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|done_label
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand a comparison builtin of type BUILTIN_TYPE.  ICODE is the code    of the comparison instruction and COND is the condition it should test.    ARGLIST is the list of function arguments and TARGET, if nonnull,    suggests a good place to put the boolean result.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_expand_builtin_compare
parameter_list|(
name|enum
name|mips_builtin_type
name|builtin_type
parameter_list|,
name|enum
name|insn_code
name|icode
parameter_list|,
name|enum
name|mips_fp_condition
name|cond
parameter_list|,
name|rtx
name|target
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|rtx
name|offset
decl_stmt|,
name|condition
decl_stmt|,
name|cmp_result
decl_stmt|,
name|ops
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|SImode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
comment|/* Prepare the operands to the comparison.  */
name|cmp_result
operator|=
name|mips_prepare_builtin_target
argument_list|(
name|icode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_operands
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|ops
index|[
name|i
index|]
operator|=
name|mips_prepare_builtin_arg
argument_list|(
name|icode
argument_list|,
name|i
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|insn_data
index|[
name|icode
index|]
operator|.
name|n_operands
condition|)
block|{
case|case
literal|4
case|:
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|cmp_result
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|cmp_result
argument_list|,
name|ops
index|[
literal|1
index|]
argument_list|,
name|ops
index|[
literal|2
index|]
argument_list|,
name|ops
index|[
literal|3
index|]
argument_list|,
name|ops
index|[
literal|4
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If the comparison sets more than one register, we define the result      to be 0 if all registers are false and -1 if all registers are true.      The value of the complete result is indeterminate otherwise.  */
switch|switch
condition|(
name|builtin_type
condition|)
block|{
case|case
name|MIPS_BUILTIN_CMP_ALL
case|:
name|condition
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cmp_result
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
return|return
name|mips_builtin_branch_and_move
argument_list|(
name|condition
argument_list|,
name|target
argument_list|,
name|const0_rtx
argument_list|,
name|const1_rtx
argument_list|)
return|;
case|case
name|MIPS_BUILTIN_CMP_UPPER
case|:
case|case
name|MIPS_BUILTIN_CMP_LOWER
case|:
name|offset
operator|=
name|GEN_INT
argument_list|(
name|builtin_type
operator|==
name|MIPS_BUILTIN_CMP_UPPER
argument_list|)
expr_stmt|;
name|condition
operator|=
name|gen_single_cc
argument_list|(
name|cmp_result
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|mips_builtin_branch_and_move
argument_list|(
name|condition
argument_list|,
name|target
argument_list|,
name|const1_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
default|default:
name|condition
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|cmp_result
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|mips_builtin_branch_and_move
argument_list|(
name|condition
argument_list|,
name|target
argument_list|,
name|const1_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a bposge builtin of type BUILTIN_TYPE.  TARGET, if nonnull,    suggests a good place to put the boolean result.  */
end_comment

begin_function
specifier|static
name|rtx
name|mips_expand_builtin_bposge
parameter_list|(
name|enum
name|mips_builtin_type
name|builtin_type
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|condition
decl_stmt|,
name|cmp_result
decl_stmt|;
name|int
name|cmp_value
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|SImode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|cmp_result
operator|=
name|gen_rtx_REG
argument_list|(
name|CCDSPmode
argument_list|,
name|CCDSP_PO_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin_type
operator|==
name|MIPS_BUILTIN_BPOSGE32
condition|)
name|cmp_value
operator|=
literal|32
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|condition
operator|=
name|gen_rtx_GE
argument_list|(
name|VOIDmode
argument_list|,
name|cmp_result
argument_list|,
name|GEN_INT
argument_list|(
name|cmp_value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mips_builtin_branch_and_move
argument_list|(
name|condition
argument_list|,
name|target
argument_list|,
name|const1_rtx
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set SYMBOL_REF_FLAGS for the SYMBOL_REF inside RTL, which belongs to DECL.    FIRST is true if this is the first time handling this decl.  */
end_comment

begin_function
specifier|static
name|void
name|mips_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|symbol
init|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator||=
name|SYMBOL_FLAG_LONG_CALL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  PIC_FUNCTION_ADDR_REGNUM is live    on entry to a function when generating -mshared abicalls code.  */
end_comment

begin_function
specifier|static
name|void
name|mips_extra_live_on_entry
parameter_list|(
name|bitmap
name|regs
parameter_list|)
block|{
if|if
condition|(
name|TARGET_ABICALLS
operator|&&
operator|!
name|TARGET_ABSOLUTE_ABICALLS
condition|)
name|bitmap_set_bit
argument_list|(
name|regs
argument_list|,
name|PIC_FUNCTION_ADDR_REGNUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SImode values are represented as sign-extended to DImode.  */
end_comment

begin_function
name|int
name|mips_mode_rep_extended
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|mode_rep
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|mode_rep
operator|==
name|DImode
condition|)
return|return
name|SIGN_EXTEND
return|;
return|return
name|UNKNOWN
return|;
block|}
end_function

begin_escape
end_escape

begin_include
include|#
directive|include
file|"gt-mips.h"
end_include

end_unit

