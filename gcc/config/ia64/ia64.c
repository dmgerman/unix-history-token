begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions of target machine for GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Contributed by James E. Wilson<wilson@cygnus.com> and 		  David Mosberger<davidm@hpl.hp.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* This is used for communication between ASM_OUTPUT_LABEL and    ASM_OUTPUT_LABELREF.  */
end_comment

begin_decl_stmt
name|int
name|ia64_asm_output_label
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the information needed to generate branch and scc insns.  This is    stored from the compare operation.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|ia64_compare_op0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|ia64_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register names for ia64_expand_prologue.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_reg_numbers
index|[
literal|96
index|]
init|=
block|{
literal|"r32"
block|,
literal|"r33"
block|,
literal|"r34"
block|,
literal|"r35"
block|,
literal|"r36"
block|,
literal|"r37"
block|,
literal|"r38"
block|,
literal|"r39"
block|,
literal|"r40"
block|,
literal|"r41"
block|,
literal|"r42"
block|,
literal|"r43"
block|,
literal|"r44"
block|,
literal|"r45"
block|,
literal|"r46"
block|,
literal|"r47"
block|,
literal|"r48"
block|,
literal|"r49"
block|,
literal|"r50"
block|,
literal|"r51"
block|,
literal|"r52"
block|,
literal|"r53"
block|,
literal|"r54"
block|,
literal|"r55"
block|,
literal|"r56"
block|,
literal|"r57"
block|,
literal|"r58"
block|,
literal|"r59"
block|,
literal|"r60"
block|,
literal|"r61"
block|,
literal|"r62"
block|,
literal|"r63"
block|,
literal|"r64"
block|,
literal|"r65"
block|,
literal|"r66"
block|,
literal|"r67"
block|,
literal|"r68"
block|,
literal|"r69"
block|,
literal|"r70"
block|,
literal|"r71"
block|,
literal|"r72"
block|,
literal|"r73"
block|,
literal|"r74"
block|,
literal|"r75"
block|,
literal|"r76"
block|,
literal|"r77"
block|,
literal|"r78"
block|,
literal|"r79"
block|,
literal|"r80"
block|,
literal|"r81"
block|,
literal|"r82"
block|,
literal|"r83"
block|,
literal|"r84"
block|,
literal|"r85"
block|,
literal|"r86"
block|,
literal|"r87"
block|,
literal|"r88"
block|,
literal|"r89"
block|,
literal|"r90"
block|,
literal|"r91"
block|,
literal|"r92"
block|,
literal|"r93"
block|,
literal|"r94"
block|,
literal|"r95"
block|,
literal|"r96"
block|,
literal|"r97"
block|,
literal|"r98"
block|,
literal|"r99"
block|,
literal|"r100"
block|,
literal|"r101"
block|,
literal|"r102"
block|,
literal|"r103"
block|,
literal|"r104"
block|,
literal|"r105"
block|,
literal|"r106"
block|,
literal|"r107"
block|,
literal|"r108"
block|,
literal|"r109"
block|,
literal|"r110"
block|,
literal|"r111"
block|,
literal|"r112"
block|,
literal|"r113"
block|,
literal|"r114"
block|,
literal|"r115"
block|,
literal|"r116"
block|,
literal|"r117"
block|,
literal|"r118"
block|,
literal|"r119"
block|,
literal|"r120"
block|,
literal|"r121"
block|,
literal|"r122"
block|,
literal|"r123"
block|,
literal|"r124"
block|,
literal|"r125"
block|,
literal|"r126"
block|,
literal|"r127"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_input_reg_names
index|[
literal|8
index|]
init|=
block|{
literal|"in0"
block|,
literal|"in1"
block|,
literal|"in2"
block|,
literal|"in3"
block|,
literal|"in4"
block|,
literal|"in5"
block|,
literal|"in6"
block|,
literal|"in7"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_local_reg_names
index|[
literal|80
index|]
init|=
block|{
literal|"loc0"
block|,
literal|"loc1"
block|,
literal|"loc2"
block|,
literal|"loc3"
block|,
literal|"loc4"
block|,
literal|"loc5"
block|,
literal|"loc6"
block|,
literal|"loc7"
block|,
literal|"loc8"
block|,
literal|"loc9"
block|,
literal|"loc10"
block|,
literal|"loc11"
block|,
literal|"loc12"
block|,
literal|"loc13"
block|,
literal|"loc14"
block|,
literal|"loc15"
block|,
literal|"loc16"
block|,
literal|"loc17"
block|,
literal|"loc18"
block|,
literal|"loc19"
block|,
literal|"loc20"
block|,
literal|"loc21"
block|,
literal|"loc22"
block|,
literal|"loc23"
block|,
literal|"loc24"
block|,
literal|"loc25"
block|,
literal|"loc26"
block|,
literal|"loc27"
block|,
literal|"loc28"
block|,
literal|"loc29"
block|,
literal|"loc30"
block|,
literal|"loc31"
block|,
literal|"loc32"
block|,
literal|"loc33"
block|,
literal|"loc34"
block|,
literal|"loc35"
block|,
literal|"loc36"
block|,
literal|"loc37"
block|,
literal|"loc38"
block|,
literal|"loc39"
block|,
literal|"loc40"
block|,
literal|"loc41"
block|,
literal|"loc42"
block|,
literal|"loc43"
block|,
literal|"loc44"
block|,
literal|"loc45"
block|,
literal|"loc46"
block|,
literal|"loc47"
block|,
literal|"loc48"
block|,
literal|"loc49"
block|,
literal|"loc50"
block|,
literal|"loc51"
block|,
literal|"loc52"
block|,
literal|"loc53"
block|,
literal|"loc54"
block|,
literal|"loc55"
block|,
literal|"loc56"
block|,
literal|"loc57"
block|,
literal|"loc58"
block|,
literal|"loc59"
block|,
literal|"loc60"
block|,
literal|"loc61"
block|,
literal|"loc62"
block|,
literal|"loc63"
block|,
literal|"loc64"
block|,
literal|"loc65"
block|,
literal|"loc66"
block|,
literal|"loc67"
block|,
literal|"loc68"
block|,
literal|"loc69"
block|,
literal|"loc70"
block|,
literal|"loc71"
block|,
literal|"loc72"
block|,
literal|"loc73"
block|,
literal|"loc74"
block|,
literal|"loc75"
block|,
literal|"loc76"
block|,
literal|"loc77"
block|,
literal|"loc78"
block|,
literal|"loc79"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_output_reg_names
index|[
literal|8
index|]
init|=
block|{
literal|"out0"
block|,
literal|"out1"
block|,
literal|"out2"
block|,
literal|"out3"
block|,
literal|"out4"
block|,
literal|"out5"
block|,
literal|"out6"
block|,
literal|"out7"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which cpu are we scheduling for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ia64_tune
init|=
name|PROCESSOR_ITANIUM2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines whether we run our final scheduling pass or not.  We always    avoid the normal second scheduling pass.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ia64_flag_schedule_insns2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines whether we run variable tracking in machine dependent    reorganization.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ia64_flag_var_tracking
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which are this size or smaller are put in the sdata/sbss    sections.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|ia64_section_threshold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable is used by the DFA insn scheduler.  The value is    TRUE if we do insn bundling instead of insn scheduling.  */
end_comment

begin_decl_stmt
name|int
name|bundling_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to be filled in by ia64_compute_frame_size with register    save masks and offsets for the current function.  */
end_comment

begin_struct
struct|struct
name|ia64_frame_info
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
comment|/* size of the stack frame, not including 				   the caller's scratch area.  */
name|HOST_WIDE_INT
name|spill_cfa_off
decl_stmt|;
comment|/* top of the reg spill area from the cfa.  */
name|HOST_WIDE_INT
name|spill_size
decl_stmt|;
comment|/* size of the gr/br/fr spill area.  */
name|HOST_WIDE_INT
name|extra_spill_size
decl_stmt|;
comment|/* size of spill area for others.  */
name|HARD_REG_SET
name|mask
decl_stmt|;
comment|/* mask of saved registers.  */
name|unsigned
name|int
name|gr_used_mask
decl_stmt|;
comment|/* mask of registers in use as gr spill 				   registers or long-term scratches.  */
name|int
name|n_spilled
decl_stmt|;
comment|/* number of spilled registers.  */
name|int
name|reg_fp
decl_stmt|;
comment|/* register for fp.  */
name|int
name|reg_save_b0
decl_stmt|;
comment|/* save register for b0.  */
name|int
name|reg_save_pr
decl_stmt|;
comment|/* save register for prs.  */
name|int
name|reg_save_ar_pfs
decl_stmt|;
comment|/* save register for ar.pfs.  */
name|int
name|reg_save_ar_unat
decl_stmt|;
comment|/* save register for ar.unat.  */
name|int
name|reg_save_ar_lc
decl_stmt|;
comment|/* save register for ar.lc.  */
name|int
name|reg_save_gp
decl_stmt|;
comment|/* save register for gp.  */
name|int
name|n_input_regs
decl_stmt|;
comment|/* number of input registers used.  */
name|int
name|n_local_regs
decl_stmt|;
comment|/* number of local registers used.  */
name|int
name|n_output_regs
decl_stmt|;
comment|/* number of output registers used.  */
name|int
name|n_rotate_regs
decl_stmt|;
comment|/* number of rotating registers used.  */
name|char
name|need_regstk
decl_stmt|;
comment|/* true if a .regstk directive needed.  */
name|char
name|initialized
decl_stmt|;
comment|/* true if the data is finalized.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Current frame information calculated by ia64_compute_frame_size.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ia64_frame_info
name|current_frame_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_dependencies_evaluation_hook
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_init_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead_guard
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_first_cycle_multipass_dfa_lookahead_guard_spec
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_dfa_new_cycle
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_h_i_d_extended
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_mode_to_int
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_set_sched_flags
parameter_list|(
name|spec_info_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_speculate_insn
parameter_list|(
name|rtx
parameter_list|,
name|ds_t
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_gen_spec_insn
parameter_list|(
name|rtx
parameter_list|,
name|ds_t
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_needs_block_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_gen_check
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_spec_check_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_spec_check_src_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_tls_get_addr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_thread_pointer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_gr_spill
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|next_scratch_gr_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_gr_used_mask
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_compute_frame_size
parameter_list|(
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_spill_pointers
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_spill_pointers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spill_restore_mem
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_spill
parameter_list|(
name|rtx
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_restore
parameter_list|(
name|rtx
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_movdi_x
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_fr_spill_x
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_fr_restore_x
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|machine_mode
name|hfa_element_mode
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_return_in_memory
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_range
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_handle_option
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|ia64_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_all_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|final_emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_predicate_relation_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_in_small_data_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_set
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_function_end_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_adjust_cost_2
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_sched_init
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_sched_init_global
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_sched_finish_global
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_sched_finish
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_dfa_sched_reorder
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_sched_reorder
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_sched_reorder2
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_variable_issue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bundle_state
modifier|*
name|get_free_bundle_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_bundle_states
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_bundle_states
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|bundle_state_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bundle_state_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insert_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_bundle_state_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_bundle_state_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_issue_nops
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_issue_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|issue_nops_and_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_max_pos
parameter_list|(
name|state_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_template
parameter_list|(
name|state_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_next_important_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bundling
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ia64_hpux_reloc_rw_mask
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ia64_reloc_rw_mask
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|section
modifier|*
name|ia64_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|ia64_output_dwarf_dtprel
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|,
name|rtx
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|ia64_section_type_flags
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|ia64_hpux_add_extern_decl
argument_list|(
name|tree
name|decl
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_hpux_file_end
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_init_libfuncs
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_hpux_init_libfuncs
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_sysv4_init_libfuncs
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_vms_init_libfuncs
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|ia64_handle_model_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_encode_section_info
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_struct_value_rtx
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ia64_gimplify_va_arg
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_cannot_force_const_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ia64_mangle_fundamental_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ia64_invalid_conversion
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ia64_invalid_unary_op
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ia64_invalid_binary_op
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
name|ia64_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"syscall_linkage"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
block|{
literal|"model"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|ia64_handle_model_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|ia64_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|ia64_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|ia64_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_BYTE_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_BYTE_OP
value|"\tdata1\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\tdata2\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\tdata4\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\tdata8\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\tdata2.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\tdata4.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\tdata8.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|ia64_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|ia64_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_END_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_END_PROLOGUE
value|ia64_output_function_end_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|ia64_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_IN_SMALL_DATA_P
end_undef

begin_define
define|#
directive|define
name|TARGET_IN_SMALL_DATA_P
value|ia64_in_small_data_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST_2
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST_2
value|ia64_adjust_cost_2
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|ia64_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|ia64_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT
value|ia64_sched_init
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FINISH
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FINISH
value|ia64_sched_finish
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT_GLOBAL
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT_GLOBAL
value|ia64_sched_init_global
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FINISH_GLOBAL
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FINISH_GLOBAL
value|ia64_sched_finish_global
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER
value|ia64_sched_reorder
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER2
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER2
value|ia64_sched_reorder2
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK
value|ia64_dependencies_evaluation_hook
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
value|ia64_first_cycle_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN
value|ia64_init_dfa_pre_cycle_insn
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_DFA_PRE_CYCLE_INSN
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_DFA_PRE_CYCLE_INSN
value|ia64_dfa_pre_cycle_insn
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD
define|\
value|ia64_first_cycle_multipass_dfa_lookahead_guard
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_DFA_NEW_CYCLE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_DFA_NEW_CYCLE
value|ia64_dfa_new_cycle
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_H_I_D_EXTENDED
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_H_I_D_EXTENDED
value|ia64_h_i_d_extended
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_SET_SCHED_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_SET_SCHED_FLAGS
value|ia64_set_sched_flags
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_SPECULATE_INSN
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_SPECULATE_INSN
value|ia64_speculate_insn
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_NEEDS_BLOCK_P
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_NEEDS_BLOCK_P
value|ia64_needs_block_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_GEN_CHECK
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_GEN_CHECK
value|ia64_gen_check
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD_SPEC
define|\
value|ia64_first_cycle_multipass_dfa_lookahead_guard_spec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|ia64_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ARG_PARTIAL_BYTES
end_undef

begin_define
define|#
directive|define
name|TARGET_ARG_PARTIAL_BYTES
value|ia64_arg_partial_bytes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|ia64_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|ia64_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|ia64_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|hook_int_rtx_0
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|ia64_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|ia64_encode_section_info
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SECTION_TYPE_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SECTION_TYPE_FLAGS
value|ia64_section_type_flags
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
value|ia64_output_dwarf_dtprel
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ??? ABI doesn't allow us to define this.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ??? ABI doesn't allow us to define this.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ??? Investigate.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_PROTOTYPES
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_PROTOTYPES
value|hook_bool_tree_true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_STRUCT_VALUE_RTX
end_undef

begin_define
define|#
directive|define
name|TARGET_STRUCT_VALUE_RTX
value|ia64_struct_value_rtx
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MEMORY
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MEMORY
value|ia64_return_in_memory
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SETUP_INCOMING_VARARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SETUP_INCOMING_VARARGS
value|ia64_setup_incoming_varargs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRICT_ARGUMENT_NAMING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRICT_ARGUMENT_NAMING
value|hook_bool_CUMULATIVE_ARGS_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MUST_PASS_IN_STACK
end_undef

begin_define
define|#
directive|define
name|TARGET_MUST_PASS_IN_STACK
value|must_pass_in_stack_var_size
end_define

begin_undef
undef|#
directive|undef
name|TARGET_GIMPLIFY_VA_ARG_EXPR
end_undef

begin_define
define|#
directive|define
name|TARGET_GIMPLIFY_VA_ARG_EXPR
value|ia64_gimplify_va_arg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_UNWIND_EMIT
end_undef

begin_define
define|#
directive|define
name|TARGET_UNWIND_EMIT
value|process_for_unwind_directive
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCALAR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_SCALAR_MODE_SUPPORTED_P
value|ia64_scalar_mode_supported_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_MODE_SUPPORTED_P
value|ia64_vector_mode_supported_p
end_define

begin_comment
comment|/* ia64 architecture manual 4.4.7: ... reads, writes, and flushes may occur    in an order different from the specified program order.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_RELAXED_ORDERING
end_undef

begin_define
define|#
directive|define
name|TARGET_RELAXED_ORDERING
value|true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_TARGET_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_TARGET_FLAGS
value|(TARGET_DEFAULT | TARGET_CPU_DEFAULT)
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HANDLE_OPTION
end_undef

begin_define
define|#
directive|define
name|TARGET_HANDLE_OPTION
value|ia64_handle_option
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|ia64_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
value|ia64_mangle_fundamental_type
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INVALID_CONVERSION
end_undef

begin_define
define|#
directive|define
name|TARGET_INVALID_CONVERSION
value|ia64_invalid_conversion
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INVALID_UNARY_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_INVALID_UNARY_OP
value|ia64_invalid_unary_op
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INVALID_BINARY_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_INVALID_BINARY_OP
value|ia64_invalid_binary_op
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_typedef
typedef|typedef
enum|enum
block|{
name|ADDR_AREA_NORMAL
block|,
comment|/* normal address area */
name|ADDR_AREA_SMALL
comment|/* addressable by "addl" (-2MB< addr< 2MB) */
block|}
name|ia64_addr_area
typedef|;
end_typedef

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|small_ident1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|small_ident2
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|init_idents
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|small_ident1
operator|==
literal|0
condition|)
block|{
name|small_ident1
operator|=
name|get_identifier
argument_list|(
literal|"small"
argument_list|)
expr_stmt|;
name|small_ident2
operator|=
name|get_identifier
argument_list|(
literal|"__small__"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the address area that has been chosen for the given decl.  */
end_comment

begin_function
specifier|static
name|ia64_addr_area
name|ia64_get_addr_area
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|model_attr
decl_stmt|;
name|model_attr
operator|=
name|lookup_attribute
argument_list|(
literal|"model"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|model_attr
condition|)
block|{
name|tree
name|id
decl_stmt|;
name|init_idents
argument_list|()
expr_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|model_attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|small_ident1
operator|||
name|id
operator|==
name|small_ident2
condition|)
return|return
name|ADDR_AREA_SMALL
return|;
block|}
return|return
name|ADDR_AREA_NORMAL
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ia64_handle_model_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|ia64_addr_area
name|addr_area
init|=
name|ADDR_AREA_NORMAL
decl_stmt|;
name|ia64_addr_area
name|area
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|init_idents
argument_list|()
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|small_ident1
operator|||
name|arg
operator|==
name|small_ident2
condition|)
block|{
name|addr_area
operator|=
name|ADDR_AREA_SMALL
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"invalid argument of %qs attribute"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jan address area attribute cannot be specified for "
literal|"local variables"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
name|area
operator|=
name|ia64_get_addr_area
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|area
operator|!=
name|ADDR_AREA_NORMAL
operator|&&
name|addr_area
operator|!=
name|area
condition|)
block|{
name|error
argument_list|(
literal|"address area of %q+D conflicts with previous "
literal|"declaration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"%Jaddress area attribute cannot be specified for functions"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_encode_addr_area
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|symbol
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ia64_get_addr_area
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ADDR_AREA_NORMAL
case|:
break|break;
case|case
name|ADDR_AREA_SMALL
case|:
name|flags
operator||=
name|SYMBOL_FLAG_SMALL_ADDR
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
comment|/* Careful not to prod global register variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|ia64_encode_addr_area
argument_list|(
name|decl
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement CONST_OK_FOR_LETTER_P.  */
end_comment

begin_function
name|bool
name|ia64_const_ok_for_letter_p
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|,
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
return|return
name|CONST_OK_FOR_I
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'J'
case|:
return|return
name|CONST_OK_FOR_J
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'K'
case|:
return|return
name|CONST_OK_FOR_K
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'L'
case|:
return|return
name|CONST_OK_FOR_L
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'M'
case|:
return|return
name|CONST_OK_FOR_M
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'N'
case|:
return|return
name|CONST_OK_FOR_N
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'O'
case|:
return|return
name|CONST_OK_FOR_O
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'P'
case|:
return|return
name|CONST_OK_FOR_P
argument_list|(
name|value
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implement CONST_DOUBLE_OK_FOR_LETTER_P.  */
end_comment

begin_function
name|bool
name|ia64_const_double_ok_for_letter_p
parameter_list|(
name|rtx
name|value
parameter_list|,
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'G'
case|:
return|return
name|CONST_DOUBLE_OK_FOR_G
argument_list|(
name|value
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implement EXTRA_CONSTRAINT.  */
end_comment

begin_function
name|bool
name|ia64_extra_constraint
parameter_list|(
name|rtx
name|value
parameter_list|,
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
comment|/* Non-volatile memory for FP_REG loads/stores.  */
return|return
name|memory_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|'R'
case|:
comment|/* 1..4 for shladd arguments.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|>=
literal|1
operator|&&
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<=
literal|4
operator|)
return|;
case|case
literal|'S'
case|:
comment|/* Non-post-inc memory for asms and other unsavory creatures.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|RTX_AUTOINC
operator|&&
operator|(
name|reload_in_progress
operator|||
name|memory_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|)
return|;
case|case
literal|'T'
case|:
comment|/* Symbol ref to small-address-area.  */
return|return
name|small_addr_symbolic_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
return|;
case|case
literal|'U'
case|:
comment|/* Vector zero.  */
return|return
name|value
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
case|case
literal|'W'
case|:
comment|/* An integer vector, such that conversion to an integer yields a 	 value appropriate for an integer 'J' constraint.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_VECTOR_INT
condition|)
block|{
name|value
operator|=
name|simplify_subreg
argument_list|(
name|DImode
argument_list|,
name|value
argument_list|,
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ia64_const_ok_for_letter_p
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|,
literal|'J'
argument_list|)
return|;
block|}
return|return
name|false
return|;
case|case
literal|'Y'
case|:
comment|/* A V2SF vector containing elements that satisfy 'G'.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|V2SFmode
operator|&&
name|ia64_const_double_ok_for_letter_p
argument_list|(
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|'G'
argument_list|)
operator|&&
name|ia64_const_double_ok_for_letter_p
argument_list|(
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|'G'
argument_list|)
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the operands of a move are ok.  */
end_comment

begin_function
name|int
name|ia64_move_ok
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
comment|/* If we're under init_recog_no_volatile, we'll not be able to use      memory_operand.  So check the code directly and don't worry about      the validity of the underlying address, which should have been      checked elsewhere anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, this must be a constant, and that either 0 or 0.0 or 1.0.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return
name|src
operator|==
name|const0_rtx
return|;
else|else
return|return
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_G
argument_list|(
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operands are ok for a floating point load pair.  */
end_comment

begin_function
name|int
name|ia64_load_pair_ok
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MEM
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|src
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|POST_INC
case|:
break|break;
case|case
name|POST_DEC
case|:
return|return
literal|0
return|;
case|case
name|POST_MODIFY
case|:
block|{
name|rtx
name|adjust
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|adjust
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|adjust
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|addp4_optimize_ok
parameter_list|(
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
return|return
operator|(
name|basereg_operand
argument_list|(
name|op1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|basereg_operand
argument_list|(
name|op2
argument_list|,
name|GET_MODE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if OP is a mask suitable for use with SHIFT in a dep.z instruction.    Return the length of the field, or<= 0 on failure.  */
end_comment

begin_function
name|int
name|ia64_depz_field_mask
parameter_list|(
name|rtx
name|rop
parameter_list|,
name|rtx
name|rshift
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|op
init|=
name|INTVAL
argument_list|(
name|rop
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|shift
init|=
name|INTVAL
argument_list|(
name|rshift
argument_list|)
decl_stmt|;
comment|/* Get rid of the zero bits we're shifting in.  */
name|op
operator|>>=
name|shift
expr_stmt|;
comment|/* We must now have a solid block of 1's at bit 0.  */
return|return
name|exact_log2
argument_list|(
name|op
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the TLS model to use for ADDR.  */
end_comment

begin_function
specifier|static
name|enum
name|tls_model
name|tls_symbolic_operand_type
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
name|enum
name|tls_model
name|tls_kind
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|tls_kind
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|tls_kind
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|tls_kind
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is a constant that is valid for some immediate    field in an instruction.  */
end_comment

begin_function
name|bool
name|ia64_legitimate_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
return|return
name|true
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|true
return|;
return|return
name|CONST_DOUBLE_OK_FOR_G
argument_list|(
name|x
argument_list|)
return|;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
comment|/* ??? Short term workaround for PR 28490.  We must make the code here 	 match the code in ia64_expand_move and move_operand, even though they 	 are both technically wrong.  */
if|if
condition|(
name|tls_symbolic_operand_type
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|addend
init|=
literal|0
decl_stmt|;
name|rtx
name|op
init|=
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_offset_symbol_operand
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|function_operand
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|aligned_offset_symbol_operand
argument_list|(
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|addend
operator|&
literal|0x3fff
operator|)
operator|==
literal|0
return|;
return|return
name|false
return|;
block|}
return|return
name|false
return|;
case|case
name|CONST_VECTOR
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|V2SFmode
condition|)
return|return
name|ia64_extra_constraint
argument_list|(
name|x
argument_list|,
literal|'Y'
argument_list|)
return|;
return|return
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|8
operator|)
return|;
block|}
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Don't allow TLS addresses to get spilled to memory.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_type
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a symbolic constant load.  */
end_comment

begin_function
name|bool
name|ia64_expand_load_address
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
comment|/* ILP32 mode still loads 64-bits of data from the GOT.  This avoids      having to pointer-extend the value afterward.  Other forms of address      computation below are also more natural to compute as 64-bit quantities.      If we've been given an SImode destination register, change it.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|Pmode
condition|)
name|dest
operator|=
name|gen_rtx_REG_offset
argument_list|(
name|dest
argument_list|,
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_NO_PIC
condition|)
return|return
name|false
return|;
if|if
condition|(
name|small_addr_symbolic_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
name|emit_insn
argument_list|(
name|gen_load_gprel64
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|src
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_load_fptr
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sdata_symbolic_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_load_gprel
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|addend
init|=
literal|0
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* We did split constant offsets in ia64_expand_move, and we did try 	 to keep them split in move_operand, but we also allowed reload to 	 rematerialize arbitrary constants rather than spill the value to 	 the stack and reload it.  So we have to be prepared here to split 	 them apart again.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|hi
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
name|hi
operator|&
literal|0x3fff
operator|)
operator|^
literal|0x2000
operator|)
operator|-
literal|0x2000
expr_stmt|;
name|hi
operator|=
name|hi
operator|-
name|lo
expr_stmt|;
if|if
condition|(
name|lo
operator|!=
literal|0
condition|)
block|{
name|addend
operator|=
name|lo
expr_stmt|;
name|src
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
block|}
name|tmp
operator|=
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|addend
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|gen_tls_tga
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|gen_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gen_tls_tga
condition|)
name|gen_tls_tga
operator|=
name|init_one_libfunc
argument_list|(
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
return|return
name|gen_tls_tga
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|thread_pointer_rtx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|gen_thread_pointer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|thread_pointer_rtx
condition|)
name|thread_pointer_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
return|return
name|thread_pointer_rtx
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|ia64_expand_tls_address
parameter_list|(
name|enum
name|tls_model
name|tls_kind
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|orig_op1
parameter_list|,
name|HOST_WIDE_INT
name|addend
parameter_list|)
block|{
name|rtx
name|tga_op1
decl_stmt|,
name|tga_op2
decl_stmt|,
name|tga_ret
decl_stmt|,
name|tga_eqv
decl_stmt|,
name|tmp
decl_stmt|,
name|insns
decl_stmt|;
name|rtx
name|orig_op0
init|=
name|op0
decl_stmt|;
name|HOST_WIDE_INT
name|addend_lo
decl_stmt|,
name|addend_hi
decl_stmt|;
switch|switch
condition|(
name|tls_kind
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|tga_op1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_dtpmod
argument_list|(
name|tga_op1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|tga_op2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_dtprel
argument_list|(
name|tga_op2
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|tga_ret
operator|=
name|emit_library_call_value
argument_list|(
name|gen_tls_get_addr
argument_list|()
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|Pmode
argument_list|,
literal|2
argument_list|,
name|tga_op1
argument_list|,
name|Pmode
argument_list|,
name|tga_op2
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|Pmode
condition|)
name|op0
operator|=
name|tga_ret
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|op0
argument_list|,
name|tga_ret
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
comment|/* ??? This isn't the completely proper way to do local-dynamic 	 If the call to __tls_get_addr is used only by a single symbol, 	 then we should (somehow) move the dtprel to the second arg 	 to avoid the extra add.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|tga_op1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_dtpmod
argument_list|(
name|tga_op1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|tga_op2
operator|=
name|const0_rtx
expr_stmt|;
name|tga_ret
operator|=
name|emit_library_call_value
argument_list|(
name|gen_tls_get_addr
argument_list|()
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|Pmode
argument_list|,
literal|2
argument_list|,
name|tga_op1
argument_list|,
name|Pmode
argument_list|,
name|tga_op2
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|tga_eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_LD_BASE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|tmp
argument_list|,
name|tga_ret
argument_list|,
name|tga_eqv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
condition|)
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_TLS64
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_dtprel
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|op0
argument_list|,
name|tmp
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_add_dtprel
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
name|addend_lo
operator|=
operator|(
operator|(
name|addend
operator|&
literal|0x3fff
operator|)
operator|^
literal|0x2000
operator|)
operator|-
literal|0x2000
expr_stmt|;
name|addend_hi
operator|=
name|addend
operator|-
name|addend_lo
expr_stmt|;
name|op1
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|addend_hi
argument_list|)
expr_stmt|;
name|addend
operator|=
name|addend_lo
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_tprel
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
condition|)
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|op0
argument_list|,
name|tmp
argument_list|,
name|gen_thread_pointer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
condition|)
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|orig_op1
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_TLS64
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_tprel
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|gen_thread_pointer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_add_tprel
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|gen_thread_pointer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|addend
condition|)
name|op0
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|addend
argument_list|)
argument_list|,
name|orig_op0
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_op0
operator|==
name|op0
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|Pmode
condition|)
return|return
name|op0
return|;
return|return
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|op0
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|ia64_expand_move
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|ia64_move_ok
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|==
name|Pmode
operator|||
name|mode
operator|==
name|ptr_mode
operator|)
operator|&&
name|symbolic_operand
argument_list|(
name|op1
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|addend
init|=
literal|0
decl_stmt|;
name|enum
name|tls_model
name|tls_kind
decl_stmt|;
name|rtx
name|sym
init|=
name|op1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addend
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|tls_kind
operator|=
name|tls_symbolic_operand_type
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_kind
condition|)
return|return
name|ia64_expand_tls_address
argument_list|(
name|tls_kind
argument_list|,
name|op0
argument_list|,
name|sym
argument_list|,
name|op1
argument_list|,
name|addend
argument_list|)
return|;
if|if
condition|(
name|any_offset_symbol_operand
argument_list|(
name|sym
argument_list|,
name|mode
argument_list|)
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|aligned_offset_symbol_operand
argument_list|(
name|sym
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|addend_lo
decl_stmt|,
name|addend_hi
decl_stmt|;
name|addend_lo
operator|=
operator|(
operator|(
name|addend
operator|&
literal|0x3fff
operator|)
operator|^
literal|0x2000
operator|)
operator|-
literal|0x2000
expr_stmt|;
name|addend_hi
operator|=
name|addend
operator|-
name|addend_lo
expr_stmt|;
if|if
condition|(
name|addend_lo
operator|!=
literal|0
condition|)
block|{
name|op1
operator|=
name|plus_constant
argument_list|(
name|sym
argument_list|,
name|addend_hi
argument_list|)
expr_stmt|;
name|addend
operator|=
name|addend_lo
expr_stmt|;
block|}
else|else
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|op1
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|reload_completed
condition|)
block|{
comment|/* We really should have taken care of this offset earlier.  */
name|gcc_assert
argument_list|(
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_expand_load_address
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
block|}
if|if
condition|(
name|addend
condition|)
block|{
name|rtx
name|subtarget
init|=
name|no_new_pseudos
condition|?
name|op0
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|subtarget
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|subtarget
argument_list|,
name|GEN_INT
argument_list|(
name|addend
argument_list|)
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|op1
condition|)
return|return
name|NULL_RTX
return|;
block|}
block|}
return|return
name|op1
return|;
block|}
end_function

begin_comment
comment|/* Split a move from OP1 to OP0 conditional on COND.  */
end_comment

begin_function
name|void
name|ia64_emit_cond_move
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|cond
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|first
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
operator|!=
name|first
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|cond
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split a post-reload TImode or TFmode reference into two DImode    components.  This is made extra difficult by the fact that we do    not get any scratch registers to work with, because reload cannot    be prevented from giving us a scratch that overlaps the register    pair involved.  So instead, when addressing memory, we tweak the    pointer register up and back down with POST_INCs.  Or up and not    back down when we can get away with it.     REVERSED is true when the loads must be done in reversed order    (high word first) for correctness.  DEAD is true when the pointer    dies with the second insn we generate and therefore the second    address must not carry a postmodify.     May return an insn which is to be emitted after the moves.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_split_tmode
parameter_list|(
name|rtx
name|out
index|[
literal|2
index|]
parameter_list|,
name|rtx
name|in
parameter_list|,
name|bool
name|reversed
parameter_list|,
name|bool
name|dead
parameter_list|)
block|{
name|rtx
name|fixup
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|out
index|[
name|reversed
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
operator|!
name|reversed
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* Cannot occur reversed.  */
name|gcc_assert
argument_list|(
operator|!
name|reversed
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
operator|!=
name|TFmode
condition|)
name|split_double
argument_list|(
name|in
argument_list|,
operator|&
name|out
index|[
literal|0
index|]
argument_list|,
operator|&
name|out
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* split_double does not understand how to split a TFmode 	   quantity into a pair of DImode constants.  */
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|p
index|[
literal|2
index|]
decl_stmt|;
name|long
name|l
index|[
literal|4
index|]
decl_stmt|;
comment|/* TFmode is 128 bits */
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|l
argument_list|,
operator|&
name|r
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|0
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|2
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|2
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|0
index|]
expr_stmt|;
block|}
name|out
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MEM
case|:
block|{
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
operator|!
name|reversed
condition|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|dead
condition|?
literal|0
else|:
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reversal requires a pre-increment, which can only 		   be done as a separate insn.  */
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|base
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|POST_INC
case|:
name|gcc_assert
argument_list|(
operator|!
name|reversed
operator|&&
operator|!
name|dead
argument_list|)
expr_stmt|;
comment|/* Just do the increment in two steps.  */
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|gcc_assert
argument_list|(
operator|!
name|reversed
operator|&&
operator|!
name|dead
argument_list|)
expr_stmt|;
comment|/* Add 8, subtract 24.  */
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
operator|-
literal|24
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_MODIFY
case|:
name|gcc_assert
argument_list|(
operator|!
name|reversed
operator|&&
operator|!
name|dead
argument_list|)
expr_stmt|;
comment|/* Extract and adjust the modification.  This case is 	       trickier than the others, because we might have an 	       index register, or we might have a combined offset that 	       doesn't fit a signed 9-bit displacement field.  We can 	       assume the incoming expression is already legitimate.  */
name|offset
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Can't adjust the postmodify to match.  Emit the 		   original, then a separate addition insn.  */
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fixup
operator|=
name|gen_adddi3
argument_list|(
name|base
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
operator|-
literal|256
operator|+
literal|8
condition|)
block|{
comment|/* Again the postmodify cannot be made to match, 		       but in this case it's more efficient to get rid 		       of the postmodify entirely and fix up with an 		       add insn.  */
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|base
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fixup
operator|=
name|gen_adddi3
argument_list|(
name|base
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Combined offset still fits in the displacement field. 		       (We cannot overflow it at the high end.)  */
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|fixup
return|;
block|}
end_function

begin_comment
comment|/* Split a TImode or TFmode move instruction after reload.    This is used by *movtf_internal and *movti_internal.  */
end_comment

begin_function
name|void
name|ia64_split_tmode_move
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|in
index|[
literal|2
index|]
decl_stmt|,
name|out
index|[
literal|2
index|]
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|fixup
index|[
literal|2
index|]
decl_stmt|;
name|bool
name|dead
init|=
name|false
decl_stmt|;
name|bool
name|reversed
init|=
name|false
decl_stmt|;
comment|/* It is possible for reload to decide to overwrite a pointer with      the value it points to.  In that case we have to do the loads in      the appropriate order so that the pointer is not destroyed too      early.  Also we must not generate a postmodify for that second      load, or rws_access_regno will die.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|reversed
operator|=
name|true
expr_stmt|;
name|dead
operator|=
name|true
expr_stmt|;
block|}
comment|/* Another reason to do the moves in reversed order is if the first      element of the target register pair is also the second element of      the source register pair.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
condition|)
name|reversed
operator|=
name|true
expr_stmt|;
name|fixup
index|[
literal|0
index|]
operator|=
name|ia64_split_tmode
argument_list|(
name|in
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|reversed
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|fixup
index|[
literal|1
index|]
operator|=
name|ia64_split_tmode
argument_list|(
name|out
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|reversed
argument_list|,
name|dead
argument_list|)
expr_stmt|;
define|#
directive|define
name|MAYBE_ADD_REG_INC_NOTE
parameter_list|(
name|INSN
parameter_list|,
name|EXP
parameter_list|)
define|\
value|if (GET_CODE (EXP) == MEM						\&& (GET_CODE (XEXP (EXP, 0)) == POST_MODIFY			\ 	  || GET_CODE (XEXP (EXP, 0)) == POST_INC			\ 	  || GET_CODE (XEXP (EXP, 0)) == POST_DEC))			\     REG_NOTES (INSN) = gen_rtx_EXPR_LIST (REG_INC,			\ 					  XEXP (XEXP (EXP, 0), 0),	\ 					  REG_NOTES (INSN))
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
index|[
literal|0
index|]
argument_list|,
name|in
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|in
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|out
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
index|[
literal|1
index|]
argument_list|,
name|in
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|in
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|out
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
index|[
literal|0
index|]
condition|)
name|emit_insn
argument_list|(
name|fixup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
index|[
literal|1
index|]
condition|)
name|emit_insn
argument_list|(
name|fixup
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MAYBE_ADD_REG_INC_NOTE
block|}
end_function

begin_comment
comment|/* ??? Fixing GR->FR XFmode moves during reload is hard.  You need to go    through memory plus an extra GR scratch register.  Except that you can    either get the first from SECONDARY_MEMORY_NEEDED or the second from    SECONDARY_RELOAD_CLASS, but not both.     We got into problems in the first place by allowing a construct like    (subreg:XF (reg:TI)), which we got from a union containing a long double.    This solution attempts to prevent this situation from occurring.  When    we see something like the above, we spill the inner register to memory.  */
end_comment

begin_function
specifier|static
name|rtx
name|spill_xfmode_rfmode_operand
parameter_list|(
name|rtx
name|in
parameter_list|,
name|int
name|force
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|TImode
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|memt
init|=
name|assign_stack_temp
argument_list|(
name|TImode
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|memt
argument_list|,
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|adjust_address
argument_list|(
name|memt
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|force
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|memx
init|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|memx
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return
name|memx
return|;
block|}
else|else
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/* Expand the movxf or movrf pattern (MODE says which) with the given    OPERANDS, returning true if the pattern should then invoke    DONE.  */
end_comment

begin_function
name|bool
name|ia64_expand_movxf_movrf
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* We must support XFmode loads into general registers for stdarg/vararg,      unprototyped calls, and a rare case where a long double is passed as      an argument after a float HFA fills the FP registers.  We split them into      DImode loads for convenience.  We also need to support XFmode stores      for the last case.  This case does not happen for stdarg/vararg routines,      because we do a block store to memory of unnamed arguments.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|GR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|out
index|[
literal|2
index|]
decl_stmt|;
comment|/* We're hoping to transform everything that deals with XFmode 	 quantities and GR registers early in the compiler.  */
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
comment|/* Struct to register can just use TImode instead.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|TImode
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|GR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
condition|)
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|gen_rtx_REG
argument_list|(
name|TImode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|TImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* Don't word-swap when reading in the constant.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|,
name|operand_subword
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|WORDS_BIG_ENDIAN
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|operand_subword
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|!
name|WORDS_BIG_ENDIAN
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If the quantity is in a register not known to be GR, spill it.  */
if|if
condition|(
name|register_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|spill_xfmode_rfmode_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
comment|/* Don't word-swap when reading in the value.  */
name|out
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|out
index|[
literal|0
index|]
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|out
index|[
literal|1
index|]
argument_list|,
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|GR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We're hoping to transform everything that deals with XFmode 	 quantities and GR registers early in the compiler.  */
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
comment|/* Op0 can't be a GR_REG here, as that case is handled above. 	 If op0 is a register, then we spill op1, so that we now have a 	 MEM operand.  This requires creating an XFmode subreg of a TImode reg 	 to force the spill.  */
if|if
condition|(
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|op1
init|=
name|gen_rtx_REG
argument_list|(
name|TImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|op1
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|spill_xfmode_rfmode_operand
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|in
index|[
literal|2
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
comment|/* Don't word-swap when writing out the value.  */
name|in
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|in
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
argument_list|,
name|in
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|spill_xfmode_rfmode_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TImode
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|memt
decl_stmt|,
name|memx
decl_stmt|,
name|in
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
condition|)
name|in
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
condition|)
name|memt
operator|=
name|adjust_address
argument_list|(
name|in
argument_list|,
name|TImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|memt
operator|=
name|assign_stack_temp
argument_list|(
name|TImode
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memx
operator|=
name|adjust_address
argument_list|(
name|memt
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|memx
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|memt
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|ia64_move_ok
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Emit comparison instruction if necessary, returning the expression    that holds the compare result in the proper mode.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|cmptf_libfunc
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|ia64_expand_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|op0
init|=
name|ia64_compare_op0
decl_stmt|,
name|op1
init|=
name|ia64_compare_op1
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
comment|/* If we have a BImode input, then we already have a compare result, and      do not need to emit another comparison.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BImode
condition|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|op1
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|op0
expr_stmt|;
block|}
comment|/* HPUX TFmode compare requires a library call to _U_Qfcmp, which takes a      magic number as its third argument, that indicates what to do.      The return value is an integer to be compared against zero.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TFmode
condition|)
block|{
enum|enum
name|qfcmp_magic
block|{
name|QCMP_INV
init|=
literal|1
block|,
comment|/* Raise FP_INVALID on SNaN as a side effect.  */
name|QCMP_UNORD
init|=
literal|2
block|,
name|QCMP_EQ
init|=
literal|4
block|,
name|QCMP_LT
init|=
literal|8
block|,
name|QCMP_GT
init|=
literal|16
block|}
name|magic
enum|;
name|enum
name|rtx_code
name|ncode
decl_stmt|;
name|rtx
name|ret
decl_stmt|,
name|insns
decl_stmt|;
name|gcc_assert
argument_list|(
name|cmptf_libfunc
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|TFmode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 1 = equal, 0 = not equal.  Equality operators do 	     not raise FP_INVALID when given an SNaN operand.  */
case|case
name|EQ
case|:
name|magic
operator|=
name|QCMP_EQ
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|magic
operator|=
name|QCMP_EQ
expr_stmt|;
name|ncode
operator|=
name|EQ
expr_stmt|;
break|break;
comment|/* isunordered() from C99.  */
case|case
name|UNORDERED
case|:
name|magic
operator|=
name|QCMP_UNORD
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|magic
operator|=
name|QCMP_UNORD
expr_stmt|;
name|ncode
operator|=
name|EQ
expr_stmt|;
break|break;
comment|/* Relational operators raise FP_INVALID when given 	     an SNaN operand.  */
case|case
name|LT
case|:
name|magic
operator|=
name|QCMP_LT
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|magic
operator|=
name|QCMP_LT
operator||
name|QCMP_EQ
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|magic
operator|=
name|QCMP_GT
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|magic
operator|=
name|QCMP_GT
operator||
name|QCMP_EQ
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
comment|/* FUTURE: Implement UNEQ, UNLT, UNLE, UNGT, UNGE, LTGT. 	     Expanders for buneq etc. weuld have to be added to ia64.md 	     for this to be useful.  */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|ret
operator|=
name|emit_library_call_value
argument_list|(
name|cmptf_libfunc
argument_list|,
literal|0
argument_list|,
name|LCT_CONST
argument_list|,
name|DImode
argument_list|,
literal|3
argument_list|,
name|op0
argument_list|,
name|TFmode
argument_list|,
name|op1
argument_list|,
name|TFmode
argument_list|,
name|GEN_INT
argument_list|(
name|magic
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|gen_reg_rtx
argument_list|(
name|BImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|ncode
argument_list|,
name|BImode
argument_list|,
name|ret
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|cmp
argument_list|,
name|cmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|BImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|gen_reg_rtx
argument_list|(
name|BImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|BImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate an integral vector comparison.  Return true if the condition has    been reversed, and so the sense of the comparison should be inverted.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_expand_vecint_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|bool
name|negate
init|=
name|false
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Canonicalize the comparison to EQ, GT, GTU.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
break|break;
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|negate
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|negate
operator|=
name|true
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|LT
case|:
case|case
name|LTU
case|:
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|x
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|x
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Unsigned parallel compare is not supported by the hardware.  Play some      tricks to turn this into a signed comparison against 0.  */
if|if
condition|(
name|code
operator|==
name|GTU
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2SImode
case|:
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|mask
decl_stmt|;
comment|/* Perform a parallel modulo subtraction.  */
name|t1
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subv2si3
argument_list|(
name|t1
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the original sign bit of op0.  */
name|mask
operator|=
name|GEN_INT
argument_list|(
operator|-
literal|0x80000000
argument_list|)
expr_stmt|;
name|mask
operator|=
name|gen_rtx_CONST_VECTOR
argument_list|(
name|V2SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|force_reg
argument_list|(
name|V2SImode
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andv2si3
argument_list|(
name|t2
argument_list|,
name|op0
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XOR it back into the result of the subtraction.  This results 	       in the sign bit set iff we saw unsigned underflow.  */
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorv2si3
argument_list|(
name|x
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|GT
expr_stmt|;
name|op0
operator|=
name|x
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V8QImode
case|:
case|case
name|V4HImode
case|:
comment|/* Perform a parallel unsigned saturating subtraction.  */
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|gen_rtx_US_MINUS
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
name|op0
operator|=
name|x
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|x
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|negate
return|;
block|}
end_function

begin_comment
comment|/* Emit an integral vector conditional move.  */
end_comment

begin_function
name|void
name|ia64_expand_vecint_cmov
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|bool
name|negate
decl_stmt|;
name|rtx
name|cmp
decl_stmt|,
name|x
decl_stmt|,
name|ot
decl_stmt|,
name|of
decl_stmt|;
name|cmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|negate
operator|=
name|ia64_expand_vecint_compare
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp
argument_list|,
name|operands
index|[
literal|4
index|]
argument_list|,
name|operands
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|ot
operator|=
name|operands
index|[
literal|1
operator|+
name|negate
index|]
expr_stmt|;
name|of
operator|=
name|operands
index|[
literal|2
operator|-
name|negate
index|]
expr_stmt|;
if|if
condition|(
name|ot
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|of
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|ot
argument_list|)
expr_stmt|;
return|return;
block|}
name|x
operator|=
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|of
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|cmp
argument_list|,
name|ot
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|t
decl_stmt|,
name|f
decl_stmt|;
name|t
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|cmp
argument_list|,
name|operands
index|[
literal|1
operator|+
name|negate
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|t
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|operands
index|[
literal|2
operator|-
name|negate
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|f
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit an integral vector min or max operation.  Return true if all done.  */
end_comment

begin_function
name|bool
name|ia64_expand_vecint_minmax
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|xops
index|[
literal|6
index|]
decl_stmt|;
comment|/* These four combinations are supported directly.  */
if|if
condition|(
name|mode
operator|==
name|V8QImode
operator|&&
operator|(
name|code
operator|==
name|UMIN
operator|||
name|code
operator|==
name|UMAX
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|mode
operator|==
name|V4HImode
operator|&&
operator|(
name|code
operator|==
name|SMIN
operator|||
name|code
operator|==
name|SMAX
operator|)
condition|)
return|return
name|false
return|;
comment|/* This combination can be implemented with only saturating subtraction.  */
if|if
condition|(
name|mode
operator|==
name|V4HImode
operator|&&
name|code
operator|==
name|UMAX
condition|)
block|{
name|rtx
name|x
decl_stmt|,
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx_US_MINUS
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addv4hi3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Everything else implemented via vector comparisons.  */
name|xops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xops
index|[
literal|4
index|]
operator|=
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xops
index|[
literal|5
index|]
operator|=
name|xops
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UMIN
case|:
name|code
operator|=
name|LTU
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|code
operator|=
name|GTU
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|code
operator|=
name|GT
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|xops
index|[
literal|3
index|]
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ia64_expand_vecint_cmov
argument_list|(
name|xops
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Emit an integral vector widening sum operations.  */
end_comment

begin_function
name|void
name|ia64_expand_widen_sum
parameter_list|(
name|rtx
name|operands
index|[
literal|3
index|]
parameter_list|,
name|bool
name|unsignedp
parameter_list|)
block|{
name|rtx
name|l
decl_stmt|,
name|h
decl_stmt|,
name|x
decl_stmt|,
name|s
decl_stmt|;
name|enum
name|machine_mode
name|wmode
decl_stmt|,
name|mode
decl_stmt|;
name|rtx
function_decl|(
modifier|*
name|unpack_l
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|unpack_h
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
name|rtx
function_decl|(
modifier|*
name|plus
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
name|wmode
operator|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V8QImode
case|:
name|unpack_l
operator|=
name|gen_unpack1_l
expr_stmt|;
name|unpack_h
operator|=
name|gen_unpack1_h
expr_stmt|;
name|plus
operator|=
name|gen_addv4hi3
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|unpack_l
operator|=
name|gen_unpack2_l
expr_stmt|;
name|unpack_h
operator|=
name|gen_unpack2_h
expr_stmt|;
name|plus
operator|=
name|gen_addv2si3
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Fill in x with the sign extension of each element in op1.  */
if|if
condition|(
name|unsignedp
condition|)
name|x
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
name|bool
name|neg
decl_stmt|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|neg
operator|=
name|ia64_expand_vecint_compare
argument_list|(
name|LT
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|neg
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|gen_reg_rtx
argument_list|(
name|wmode
argument_list|)
expr_stmt|;
name|h
operator|=
name|gen_reg_rtx
argument_list|(
name|wmode
argument_list|)
expr_stmt|;
name|s
operator|=
name|gen_reg_rtx
argument_list|(
name|wmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|unpack_l
argument_list|(
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|l
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|unpack_h
argument_list|(
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|h
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|plus
argument_list|(
name|s
argument_list|,
name|l
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|plus
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|h
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a signed or unsigned V8QI dot product operation.  */
end_comment

begin_function
name|void
name|ia64_expand_dot_prod_v8qi
parameter_list|(
name|rtx
name|operands
index|[
literal|4
index|]
parameter_list|,
name|bool
name|unsignedp
parameter_list|)
block|{
name|rtx
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|p4
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
comment|/* Fill in x1 and x2 with the sign extension of each element.  */
if|if
condition|(
name|unsignedp
condition|)
name|x1
operator|=
name|x2
operator|=
name|CONST0_RTX
argument_list|(
name|V8QImode
argument_list|)
expr_stmt|;
else|else
block|{
name|bool
name|neg
decl_stmt|;
name|x1
operator|=
name|gen_reg_rtx
argument_list|(
name|V8QImode
argument_list|)
expr_stmt|;
name|x2
operator|=
name|gen_reg_rtx
argument_list|(
name|V8QImode
argument_list|)
expr_stmt|;
name|neg
operator|=
name|ia64_expand_vecint_compare
argument_list|(
name|LT
argument_list|,
name|V8QImode
argument_list|,
name|x1
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|CONST0_RTX
argument_list|(
name|V8QImode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|neg
argument_list|)
expr_stmt|;
name|neg
operator|=
name|ia64_expand_vecint_compare
argument_list|(
name|LT
argument_list|,
name|V8QImode
argument_list|,
name|x2
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|CONST0_RTX
argument_list|(
name|V8QImode
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|neg
argument_list|)
expr_stmt|;
block|}
name|l1
operator|=
name|gen_reg_rtx
argument_list|(
name|V4HImode
argument_list|)
expr_stmt|;
name|l2
operator|=
name|gen_reg_rtx
argument_list|(
name|V4HImode
argument_list|)
expr_stmt|;
name|h1
operator|=
name|gen_reg_rtx
argument_list|(
name|V4HImode
argument_list|)
expr_stmt|;
name|h2
operator|=
name|gen_reg_rtx
argument_list|(
name|V4HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_unpack1_l
argument_list|(
name|gen_lowpart
argument_list|(
name|V8QImode
argument_list|,
name|l1
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|x1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_unpack1_l
argument_list|(
name|gen_lowpart
argument_list|(
name|V8QImode
argument_list|,
name|l2
argument_list|)
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|x2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_unpack1_h
argument_list|(
name|gen_lowpart
argument_list|(
name|V8QImode
argument_list|,
name|h1
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|x1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_unpack1_h
argument_list|(
name|gen_lowpart
argument_list|(
name|V8QImode
argument_list|,
name|h2
argument_list|)
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|x2
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|p2
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|p3
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|p4
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pmpy2_r
argument_list|(
name|p1
argument_list|,
name|l1
argument_list|,
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pmpy2_l
argument_list|(
name|p2
argument_list|,
name|l1
argument_list|,
name|l2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pmpy2_r
argument_list|(
name|p3
argument_list|,
name|h1
argument_list|,
name|h2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pmpy2_l
argument_list|(
name|p4
argument_list|,
name|h1
argument_list|,
name|h2
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|s3
operator|=
name|gen_reg_rtx
argument_list|(
name|V2SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addv2si3
argument_list|(
name|s1
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addv2si3
argument_list|(
name|s2
argument_list|,
name|p3
argument_list|,
name|p4
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addv2si3
argument_list|(
name|s3
argument_list|,
name|s1
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addv2si3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the appropriate sequence for a call.  */
end_comment

begin_function
name|void
name|ia64_expand_call
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sibcall_p
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|b0
decl_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|DImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|b0
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|R_BR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Should do this for functions known to bind local too.  */
if|if
condition|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
condition|)
block|{
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_nogp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_nogp
argument_list|(
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_nogp
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_gp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_gp
argument_list|(
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_gp
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sibcall_p
condition|)
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|b0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_reload_gp
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_gp
condition|)
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_gp
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|tmp
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|offset
operator|=
name|current_frame_info
operator|.
name|total_size
operator|-
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|offset
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_split_call
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|rtx
name|retaddr
parameter_list|,
name|rtx
name|scratch_r
parameter_list|,
name|rtx
name|scratch_b
parameter_list|,
name|int
name|noreturn_p
parameter_list|,
name|int
name|sibcall_p
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|bool
name|is_desc
init|=
name|false
decl_stmt|;
comment|/* If we find we're calling through a register, then we're actually      calling through a descriptor, so load up the values.  */
if|if
condition|(
name|REG_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|GR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|bool
name|addr_dead_p
decl_stmt|;
comment|/* ??? We are currently constrained to *not* use peep2, because 	 we can legitimately change the global lifetime of the GP 	 (in the form of killing where previously live).  This is 	 because a call through a descriptor doesn't use the previous 	 value of the GP, while a direct call does, and we do not 	 commit to either form until the split here.  	 That said, this means that we lack precise life info for 	 whether ADDR is dead after this call.  This is not terribly 	 important, since we can fix things up essentially for free 	 with the POST_DEC below, but it's nice to not use it when we 	 can immediately tell it's not necessary.  */
name|addr_dead_p
operator|=
operator|(
operator|(
name|noreturn_p
operator|||
name|sibcall_p
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Load the code address into scratch_b.  */
name|tmp
operator|=
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch_r
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch_b
argument_list|,
name|scratch_r
argument_list|)
expr_stmt|;
comment|/* Load the GP address.  If ADDR is not dead here, then we must 	 revert the change made above via the POST_INCREMENT.  */
if|if
condition|(
operator|!
name|addr_dead_p
condition|)
name|tmp
operator|=
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|addr
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|is_desc
operator|=
name|true
expr_stmt|;
name|addr
operator|=
name|scratch_b
expr_stmt|;
block|}
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_nogp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
condition|)
name|insn
operator|=
name|gen_call_value_nogp
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_nogp
argument_list|(
name|addr
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|TARGET_CONST_GP
operator|||
name|is_desc
operator|)
operator|&&
operator|!
name|noreturn_p
operator|&&
operator|!
name|sibcall_p
condition|)
name|ia64_reload_gp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an atomic operation.  We want to perform MEM<CODE>= VAL atomically.     This differs from the generic code in that we know about the zero-extending    properties of cmpxchg, and the zero-extending requirements of ar.ccv.  We    also know that ld.acq+cmpxchg.rel equals a full barrier.     The loop we want to generate looks like  	cmp_reg = mem;       label:         old_reg = cmp_reg; 	new_reg = cmp_reg op val; 	cmp_reg = compare-and-swap(mem, old_reg, new_reg) 	if (cmp_reg != old_reg) 	  goto label;     Note that we only do the plain load from memory once.  Subsequent    iterations use the value loaded by the compare-and-swap pattern.  */
end_comment

begin_function
name|void
name|ia64_expand_atomic_op
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|val
parameter_list|,
name|rtx
name|old_dst
parameter_list|,
name|rtx
name|new_dst
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|old_reg
decl_stmt|,
name|new_reg
decl_stmt|,
name|cmp_reg
decl_stmt|,
name|ar_ccv
decl_stmt|,
name|label
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
comment|/* Special case for using fetchadd.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|DImode
operator|)
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|&&
name|fetchadd_operand
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|val
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_dst
condition|)
name|old_dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_memory_barrier
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|icode
operator|=
name|CODE_FOR_fetchadd_acq_si
expr_stmt|;
else|else
name|icode
operator|=
name|CODE_FOR_fetchadd_acq_di
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|old_dst
argument_list|,
name|mem
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dst
condition|)
block|{
name|new_reg
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|old_dst
argument_list|,
name|val
argument_list|,
name|new_dst
argument_list|,
name|true
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_reg
operator|!=
name|new_dst
condition|)
name|emit_move_insn
argument_list|(
name|new_dst
argument_list|,
name|new_reg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Because of the volatile mem read, we get an ld.acq, which is the      front half of the full barrier.  The end half is the cmpxchg.rel.  */
name|gcc_assert
argument_list|(
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|old_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|cmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DImode
condition|)
block|{
name|val
operator|=
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|val
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_extend_insn
argument_list|(
name|cmp_reg
argument_list|,
name|mem
argument_list|,
name|DImode
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|cmp_reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|ar_ccv
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_CCV_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|old_reg
argument_list|,
name|cmp_reg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ar_ccv
argument_list|,
name|cmp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_dst
condition|)
name|emit_move_insn
argument_list|(
name|old_dst
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|cmp_reg
argument_list|)
argument_list|)
expr_stmt|;
name|new_reg
operator|=
name|cmp_reg
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOT
condition|)
block|{
name|new_reg
operator|=
name|expand_simple_unop
argument_list|(
name|DImode
argument_list|,
name|NOT
argument_list|,
name|new_reg
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|code
operator|=
name|AND
expr_stmt|;
block|}
name|new_reg
operator|=
name|expand_simple_binop
argument_list|(
name|DImode
argument_list|,
name|code
argument_list|,
name|new_reg
argument_list|,
name|val
argument_list|,
name|NULL_RTX
argument_list|,
name|true
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DImode
condition|)
name|new_reg
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|new_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dst
condition|)
name|emit_move_insn
argument_list|(
name|new_dst
argument_list|,
name|new_reg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
name|icode
operator|=
name|CODE_FOR_cmpxchg_rel_qi
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|icode
operator|=
name|CODE_FOR_cmpxchg_rel_hi
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|icode
operator|=
name|CODE_FOR_cmpxchg_rel_si
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|icode
operator|=
name|CODE_FOR_cmpxchg_rel_di
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|cmp_reg
argument_list|,
name|mem
argument_list|,
name|ar_ccv
argument_list|,
name|new_reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|cmp_reg
argument_list|,
name|old_reg
argument_list|,
name|NE
argument_list|,
name|NULL
argument_list|,
name|DImode
argument_list|,
name|true
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin the assembly file.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_file_start
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Variable tracking should be run after all optimizations which change order      of insns.  It also needs a valid CFG.  This can't be done in      ia64_override_options, because flag_var_tracking is finalized after      that.  */
name|ia64_flag_var_tracking
operator|=
name|flag_var_tracking
expr_stmt|;
name|flag_var_tracking
operator|=
literal|0
expr_stmt|;
name|default_file_start
argument_list|()
expr_stmt|;
name|emit_safe_across_calls
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emit_safe_across_calls
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|rs
decl_stmt|,
name|re
decl_stmt|;
name|int
name|out_state
decl_stmt|;
name|rs
operator|=
literal|1
expr_stmt|;
name|out_state
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|rs
operator|<
literal|64
operator|&&
name|call_used_regs
index|[
name|PR_REG
argument_list|(
name|rs
argument_list|)
index|]
condition|)
name|rs
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|>=
literal|64
condition|)
break|break;
for|for
control|(
name|re
operator|=
name|rs
operator|+
literal|1
init|;
name|re
operator|<
literal|64
operator|&&
operator|!
name|call_used_regs
index|[
name|PR_REG
argument_list|(
name|re
argument_list|)
index|]
condition|;
name|re
operator|++
control|)
continue|continue;
if|if
condition|(
name|out_state
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.pred.safe_across_calls "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|out_state
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|rs
operator|+
literal|1
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"p%u"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"p%u-p%u"
argument_list|,
name|rs
argument_list|,
name|re
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|=
name|re
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|out_state
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for ia64_compute_frame_size: find an appropriate general    register to spill some special register to.  SPECIAL_SPILL_MASK contains    bits in GR0 to GR31 that have already been allocated by this routine.    TRY_LOCALS is true if we should attempt to locate a local regnum.  */
end_comment

begin_function
specifier|static
name|int
name|find_gr_spill
parameter_list|(
name|int
name|try_locals
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* If this is a leaf function, first try an otherwise unused      call-clobbered register.  */
if|if
condition|(
name|current_function_is_leaf
condition|)
block|{
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|global_regs
index|[
name|regno
index|]
operator|&&
operator|(
operator|(
name|current_frame_info
operator|.
name|gr_used_mask
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
return|return
name|regno
return|;
block|}
block|}
if|if
condition|(
name|try_locals
condition|)
block|{
name|regno
operator|=
name|current_frame_info
operator|.
name|n_local_regs
expr_stmt|;
comment|/* If there is a frame pointer, then we can't use loc79, because 	 that is HARD_FRAME_POINTER_REGNUM.  In particular, see the 	 reg_name switching code in ia64_expand_prologue.  */
if|if
condition|(
name|regno
operator|<
operator|(
literal|80
operator|-
name|frame_pointer_needed
operator|)
condition|)
block|{
name|current_frame_info
operator|.
name|n_local_regs
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
return|return
name|LOC_REG
argument_list|(
literal|0
argument_list|)
operator|+
name|regno
return|;
block|}
block|}
comment|/* Failed to find a general register to spill to.  Must use stack.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* In order to make for nice schedules, we try to allocate every temporary    to a different register.  We must of course stay away from call-saved,    fixed, and global registers.  We must also stay away from registers    allocated in current_frame_info.gr_used_mask, since those include regs    used all through the prologue.     Any register allocated here must be used immediately.  The idea is to    aid scheduling, not to solve data flow problems.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_scratch_gr_reg
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|next_scratch_gr_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|regno
operator|=
operator|(
name|last_scratch_gr_reg
operator|+
name|i
operator|+
literal|1
operator|)
operator|&
literal|31
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|global_regs
index|[
name|regno
index|]
operator|&&
operator|(
operator|(
name|current_frame_info
operator|.
name|gr_used_mask
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|last_scratch_gr_reg
operator|=
name|regno
expr_stmt|;
return|return
name|regno
return|;
block|}
block|}
comment|/* There must be _something_ available.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for ia64_compute_frame_size, called through    diddle_return_value.  Mark REG in current_frame_info.gr_used_mask.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_gr_used_mask
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|n
init|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|+
name|i
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the number of bytes offset between the frame pointer and the stack    pointer for the current function.  SIZE is the number of bytes of space    needed for local variables.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_compute_frame_size
parameter_list|(
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
name|HOST_WIDE_INT
name|spill_size
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|extra_spill_size
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|pretend_args_size
decl_stmt|;
name|HARD_REG_SET
name|mask
decl_stmt|;
name|int
name|n_spilled
init|=
literal|0
decl_stmt|;
name|int
name|spilled_gr_p
init|=
literal|0
decl_stmt|;
name|int
name|spilled_fr_p
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|initialized
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|current_frame_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|current_frame_info
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* Don't allocate scratches to the return register.  */
name|diddle_return_value
argument_list|(
name|mark_reg_gr_used_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't allocate scratches to the EH scratch registers.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
name|mark_reg_gr_used_mask
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
condition|)
name|mark_reg_gr_used_mask
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the size of the register stack frame.  We have only 80 local      registers, because we reserve 8 for the inputs and 8 for the      outputs.  */
comment|/* Skip HARD_FRAME_POINTER_REGNUM (loc79) when frame_pointer_needed,      since we'll be adjusting that down later.  */
name|regno
operator|=
name|LOC_REG
argument_list|(
literal|78
argument_list|)
operator|+
operator|!
name|frame_pointer_needed
expr_stmt|;
for|for
control|(
init|;
name|regno
operator|>=
name|LOC_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|current_frame_info
operator|.
name|n_local_regs
operator|=
name|regno
operator|-
name|LOC_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* For functions marked with the syscall_linkage attribute, we must mark      all eight input registers as in use, so that locals aren't visible to      the caller.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|>
literal|0
operator|||
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|current_frame_info
operator|.
name|n_input_regs
operator|=
literal|8
expr_stmt|;
else|else
block|{
for|for
control|(
name|regno
operator|=
name|IN_REG
argument_list|(
literal|7
argument_list|)
init|;
name|regno
operator|>=
name|IN_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|current_frame_info
operator|.
name|n_input_regs
operator|=
name|regno
operator|-
name|IN_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|OUT_REG
argument_list|(
literal|7
argument_list|)
init|;
name|regno
operator|>=
name|OUT_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|i
operator|=
name|regno
operator|-
name|OUT_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|PROFILE_HOOK
comment|/* When -p profiling, we need one output register for the mcount argument.      Likewise for -a profiling for the bb_init_func argument.  For -ax      profiling, we need two output registers for the two bb_init_trace_func      arguments.  */
if|if
condition|(
name|current_function_profile
condition|)
name|i
operator|=
name|MAX
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_frame_info
operator|.
name|n_output_regs
operator|=
name|i
expr_stmt|;
comment|/* ??? No rotating register support yet.  */
name|current_frame_info
operator|.
name|n_rotate_regs
operator|=
literal|0
expr_stmt|;
comment|/* Discover which registers need spilling, and how much room that      will take.  Begin with floating point and general registers,      which will always wind up on the stack.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|16
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
name|spilled_fr_p
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
name|spilled_gr_p
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Now come all special registers that might get saved in other      general registers.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we did not get a register, then we take LOC79.  This is guaranteed 	 to be free, even if regs_ever_live is already set, because this is 	 HARD_FRAME_POINTER_REGNUM.  This requires incrementing n_local_regs, 	 as we don't count loc79 above.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|==
literal|0
condition|)
block|{
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|LOC_REG
argument_list|(
literal|79
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_local_regs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
block|{
comment|/* Emit a save of BR0 if we call other functions.  Do this even 	 if this function doesn't return, as EH depends on this to be 	 able to unwind the stack.  */
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_b0
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Similarly for ar.pfs.  */
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Similarly for gp.  Note that if we're calling setjmp, the stacked 	 registers are clobbered, so we fall back to the stack.  */
name|current_frame_info
operator|.
name|reg_save_gp
operator|=
operator|(
name|current_function_calls_setjmp
condition|?
literal|0
else|:
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_gp
operator|==
literal|0
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|GR_REG
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|BR_REG
argument_list|(
literal|0
argument_list|)
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|BR_REG
argument_list|(
literal|0
argument_list|)
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
name|AR_PFS_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Unwind descriptor hackery: things are most efficient if we allocate      consecutive GR save registers for RP, PFS, FP in that order. However,      it is absolutely critical that FP get the only hard register that's      guaranteed to be free, so we allocated it first.  If all three did      happen to be allocated hard regs, and are consecutive, rearrange them      into the preferred order now.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|!=
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|1
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|2
condition|)
block|{
name|current_frame_info
operator|.
name|reg_save_b0
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|1
expr_stmt|;
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|2
expr_stmt|;
block|}
comment|/* See if we need to store the predicate register block.  */
for|for
control|(
name|regno
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
break|break;
if|if
condition|(
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_pr
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* ??? Mark them all as used so that register renaming and such 	 are free to use them.  */
for|for
control|(
name|regno
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|;
name|regno
operator|++
control|)
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we're forced to use st8.spill, we're forced to save and restore      ar.unat as well.  The check for existing liveness allows inline asm      to touch ar.unat.  */
if|if
condition|(
name|spilled_gr_p
operator|||
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|||
name|regs_ever_live
index|[
name|AR_UNAT_REGNUM
index|]
condition|)
block|{
name|regs_ever_live
index|[
name|AR_UNAT_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|=
name|find_gr_spill
argument_list|(
name|spill_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regs_ever_live
index|[
name|AR_LC_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|=
name|find_gr_spill
argument_list|(
name|spill_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we have an odd number of words of pretend arguments written to      the stack, then the FR save area will be unaligned.  We round the      size of this area up to keep things 16 byte aligned.  */
if|if
condition|(
name|spilled_fr_p
condition|)
name|pretend_args_size
operator|=
name|IA64_STACK_ALIGN
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|else
name|pretend_args_size
operator|=
name|current_function_pretend_args_size
expr_stmt|;
name|total_size
operator|=
operator|(
name|spill_size
operator|+
name|extra_spill_size
operator|+
name|size
operator|+
name|pretend_args_size
operator|+
name|current_function_outgoing_args_size
operator|)
expr_stmt|;
name|total_size
operator|=
name|IA64_STACK_ALIGN
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
comment|/* We always use the 16-byte scratch area provided by the caller, but      if we are a leaf function, there's no one to which we need to provide      a scratch area.  */
if|if
condition|(
name|current_function_is_leaf
condition|)
name|total_size
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|total_size
operator|-
literal|16
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|current_frame_info
operator|.
name|spill_cfa_off
operator|=
name|pretend_args_size
operator|-
literal|16
expr_stmt|;
name|current_frame_info
operator|.
name|spill_size
operator|=
name|spill_size
expr_stmt|;
name|current_frame_info
operator|.
name|extra_spill_size
operator|=
name|extra_spill_size
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_spilled
operator|=
name|n_spilled
expr_stmt|;
name|current_frame_info
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the initial difference between the specified pair of registers.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|ia64_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|FRAME_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|HARD_FRAME_POINTER_REGNUM
case|:
if|if
condition|(
name|current_function_is_leaf
condition|)
name|offset
operator|=
operator|-
name|current_frame_info
operator|.
name|total_size
expr_stmt|;
else|else
name|offset
operator|=
operator|-
operator|(
name|current_frame_info
operator|.
name|total_size
operator|-
name|current_function_outgoing_args_size
operator|-
literal|16
operator|)
expr_stmt|;
break|break;
case|case
name|STACK_POINTER_REGNUM
case|:
if|if
condition|(
name|current_function_is_leaf
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
literal|16
operator|+
name|current_function_outgoing_args_size
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ARG_POINTER_REGNUM
case|:
comment|/* Arguments start above the 16 byte save area, unless stdarg 	 in which case we store through the 16 byte save area.  */
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|HARD_FRAME_POINTER_REGNUM
case|:
name|offset
operator|=
literal|16
operator|-
name|current_function_pretend_args_size
expr_stmt|;
break|break;
case|case
name|STACK_POINTER_REGNUM
case|:
name|offset
operator|=
operator|(
name|current_frame_info
operator|.
name|total_size
operator|+
literal|16
operator|-
name|current_function_pretend_args_size
operator|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* If there are more than a trivial number of register spills, we use    two interleaved iterators so that we can get two memory references    per insn group.     In order to simplify things in the prologue and epilogue expanders,    we use helper functions to fix up the memory references after the    fact with the appropriate offsets to a POST_MODIFY memory mode.    The following data structure tracks the state of the two iterators    while insns are being emitted.  */
end_comment

begin_struct
struct|struct
name|spill_fill_data
block|{
name|rtx
name|init_after
decl_stmt|;
comment|/* point at which to emit initializations */
name|rtx
name|init_reg
index|[
literal|2
index|]
decl_stmt|;
comment|/* initial base register */
name|rtx
name|iter_reg
index|[
literal|2
index|]
decl_stmt|;
comment|/* the iterator registers */
name|rtx
modifier|*
name|prev_addr
index|[
literal|2
index|]
decl_stmt|;
comment|/* address of last memory use */
name|rtx
name|prev_insn
index|[
literal|2
index|]
decl_stmt|;
comment|/* the insn corresponding to prev_addr */
name|HOST_WIDE_INT
name|prev_off
index|[
literal|2
index|]
decl_stmt|;
comment|/* last offset */
name|int
name|n_iter
decl_stmt|;
comment|/* number of iterators in use */
name|int
name|next_iter
decl_stmt|;
comment|/* next iterator to use */
name|unsigned
name|int
name|save_gr_used_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|spill_fill_data
name|spill_fill_data
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setup_spill_pointers
parameter_list|(
name|int
name|n_spills
parameter_list|,
name|rtx
name|init_reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|spill_fill_data
operator|.
name|init_after
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|spill_fill_data
operator|.
name|init_reg
index|[
literal|0
index|]
operator|=
name|init_reg
expr_stmt|;
name|spill_fill_data
operator|.
name|init_reg
index|[
literal|1
index|]
operator|=
name|init_reg
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
literal|0
index|]
operator|=
name|cfa_off
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
literal|1
index|]
operator|=
name|cfa_off
expr_stmt|;
name|spill_fill_data
operator|.
name|next_iter
operator|=
literal|0
expr_stmt|;
name|spill_fill_data
operator|.
name|save_gr_used_mask
operator|=
name|current_frame_info
operator|.
name|gr_used_mask
expr_stmt|;
name|spill_fill_data
operator|.
name|n_iter
operator|=
literal|1
operator|+
operator|(
name|n_spills
operator|>
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spill_fill_data
operator|.
name|n_iter
condition|;
operator|++
name|i
control|)
block|{
name|int
name|regno
init|=
name|next_scratch_gr_reg
argument_list|()
decl_stmt|;
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|i
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|finish_spill_pointers
parameter_list|(
name|void
parameter_list|)
block|{
name|current_frame_info
operator|.
name|gr_used_mask
operator|=
name|spill_fill_data
operator|.
name|save_gr_used_mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|spill_restore_mem
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|)
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|HOST_WIDE_INT
name|disp
init|=
name|spill_fill_data
operator|.
name|prev_off
index|[
name|iter
index|]
operator|-
name|cfa_off
decl_stmt|;
name|rtx
name|disp_rtx
init|=
name|GEN_INT
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_N
argument_list|(
name|disp
argument_list|)
condition|)
block|{
operator|*
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
operator|=
name|gen_rtx_POST_MODIFY
argument_list|(
name|DImode
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Could use register post_modify for loads.  */
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|disp_rtx
argument_list|)
expr_stmt|;
name|disp_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Micro-optimization: if we've created a frame pointer, it's at      CFA 0, which may allow the real iterator to be initialized lower,      slightly increasing parallelism.  Also, if there are few saves      it may eliminate the iterator entirely.  */
elseif|else
if|if
condition|(
name|disp
operator|==
literal|0
operator|&&
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
operator|==
name|stack_pointer_rtx
operator|&&
name|frame_pointer_needed
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
else|else
block|{
name|rtx
name|seq
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|seq
operator|=
name|gen_movdi
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|disp_rtx
argument_list|)
expr_stmt|;
name|disp_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Careful for being the first insn in a sequence.  */
if|if
condition|(
name|spill_fill_data
operator|.
name|init_after
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|spill_fill_data
operator|.
name|init_after
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|first
init|=
name|get_insns
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|first
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
name|spill_fill_data
operator|.
name|init_after
operator|=
name|insn
expr_stmt|;
comment|/* If DISP is 0, we may or may not have a further adjustment 	 afterward.  If we do, then the load/store insn may be modified 	 to be a post-modify.  If we don't, then this copy may be 	 eliminated by copyprop_hardreg_forward, which makes this 	 insn garbage, which runs afoul of the sanity check in 	 propagate_one_insn.  So mark this insn as legal to delete.  */
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
comment|/* ??? Not all of the spills are for varargs, but some of them are.      The rest of the spills belong in an alias set of their own.  But      it doesn't actually hurt to include them here.  */
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
operator|=
operator|&
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
name|iter
index|]
operator|=
name|cfa_off
expr_stmt|;
if|if
condition|(
operator|++
name|iter
operator|>=
name|spill_fill_data
operator|.
name|n_iter
condition|)
name|iter
operator|=
literal|0
expr_stmt|;
name|spill_fill_data
operator|.
name|next_iter
operator|=
name|iter
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_spill
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|move_fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|,
name|rtx
name|frame_reg
parameter_list|)
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|insn
decl_stmt|;
name|mem
operator|=
name|spill_restore_mem
argument_list|(
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
call|(
modifier|*
name|move_fn
call|)
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|cfa_off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|frame_reg
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|off
decl_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't even pretend that the unwind code can intuit its way 	 through a pair of interleaved post_modify iterators.  Just 	 provide the correct answer.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|base
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
name|off
operator|=
operator|-
name|cfa_off
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|off
operator|=
name|current_frame_info
operator|.
name|total_size
operator|-
name|cfa_off
expr_stmt|;
block|}
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|,
name|frame_reg
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_restore
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|move_fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|)
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
call|(
modifier|*
name|move_fn
call|)
argument_list|(
name|reg
argument_list|,
name|spill_restore_mem
argument_list|(
name|reg
argument_list|,
name|cfa_off
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|cfa_off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper functions that discards the CONST_INT spill offset.  These    exist so that we can give gr_spill/gr_fill the offset they need and    use a consistent function interface.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_movdi_x
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|gen_movdi
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_fr_spill_x
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|gen_fr_spill
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_fr_restore_x
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|gen_fr_restore
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    prologue.  Using a prologue insn is favored compared to putting all of the    instructions in output_function_prologue(), since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.     Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1    so that the debug info generation code can handle them properly.     The register save area is layed out like so:    cfa+16 	[ varargs spill area ] 	[ fr register spill area ] 	[ br register spill area ] 	[ ar register spill area ] 	[ pr register spill area ] 	[ gr register spill area ] */
end_comment

begin_comment
comment|/* ??? Get inefficient code when the frame size is larger than can fit in an    adds instruction.  */
end_comment

begin_function
name|void
name|ia64_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|ar_pfs_save_reg
decl_stmt|,
name|ar_unat_save_reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|epilogue_p
decl_stmt|,
name|regno
decl_stmt|,
name|alt_regno
decl_stmt|,
name|cfa_off
decl_stmt|,
name|n_varargs
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|alt_reg
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
name|last_scratch_gr_reg
operator|=
literal|15
expr_stmt|;
comment|/* If there is no epilogue, then we don't need some prologue insns.      We need to avoid emitting the dead prologue insns, because flow      will complain about them.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
condition|)
break|break;
name|epilogue_p
operator|=
operator|(
name|e
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
else|else
name|epilogue_p
operator|=
literal|1
expr_stmt|;
comment|/* Set the local, input, and output register names.  We need to do this      for GNU libc, which creates crti.S/crtn.S by splitting initfini.c in      half.  If we use in/loc/out register names, then we get assembler errors      in crtn.S because there is no alloc insn or regstk directive in there.  */
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
block|{
name|int
name|inputs
init|=
name|current_frame_info
operator|.
name|n_input_regs
decl_stmt|;
name|int
name|locals
init|=
name|current_frame_info
operator|.
name|n_local_regs
decl_stmt|;
name|int
name|outputs
init|=
name|current_frame_info
operator|.
name|n_output_regs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inputs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|IN_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|locals
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|LOC_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|inputs
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outputs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|OUT_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|inputs
operator|+
name|locals
operator|+
name|i
index|]
expr_stmt|;
block|}
comment|/* Set the frame pointer register name.  The regnum is logically loc79,      but of course we'll not have allocated that many locals.  Rather than      worrying about renumbering the existing rtxs, we adjust the name.  */
comment|/* ??? This code means that we can never use one local register when      there is a frame pointer.  loc79 gets wasted in this case, as it is      renamed to a register that will never be used.  See also the try_locals      code in find_gr_spill.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
expr_stmt|;
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* We don't need an alloc instruction if we've used no outputs or locals.  */
if|if
condition|(
name|current_frame_info
operator|.
name|n_local_regs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_output_regs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_input_regs
operator|<=
name|current_function_args_info
operator|.
name|int_regs
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
condition|)
block|{
comment|/* If there is no alloc, but there are input registers used, then we 	 need a .regstk directive.  */
name|current_frame_info
operator|.
name|need_regstk
operator|=
operator|(
name|TARGET_REG_NAMES
operator|!=
literal|0
operator|)
expr_stmt|;
name|ar_pfs_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
block|{
name|current_frame_info
operator|.
name|need_regstk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
name|regno
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
else|else
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_pfs_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_alloc
argument_list|(
name|ar_pfs_save_reg
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_input_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_local_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_output_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_rotate_regs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Set up frame pointer, stack pointer, and spill iterators.  */
name|n_varargs
operator|=
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
expr_stmt|;
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
operator|+
name|n_varargs
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|!=
literal|0
condition|)
block|{
name|rtx
name|frame_size_rtx
init|=
name|GEN_INT
argument_list|(
operator|-
name|current_frame_info
operator|.
name|total_size
argument_list|)
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
operator|-
name|current_frame_info
operator|.
name|total_size
argument_list|)
condition|)
name|offset
operator|=
name|frame_size_rtx
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset
argument_list|,
name|frame_size_rtx
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_size_rtx
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? At this point we must generate a magic insn that appears to 	 modify the stack pointer, the frame pointer, and all spill 	 iterators.  This would allow the most scheduling freedom.  For 	 now, just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Must copy out ar.unat before doing any integer spills.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|alt_regno
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|ar_unat_save_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	 need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|ar_unat_save_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ar_unat_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Spill all varargs registers.  Do this before spilling any GR registers,      since we want the UNAT bits for the GR registers to override the UNAT      bits from varargs, which we don't care about.  */
name|cfa_off
operator|=
operator|-
literal|16
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GR_ARG_FIRST
operator|+
literal|7
init|;
name|n_varargs
operator|>
literal|0
condition|;
operator|--
name|n_varargs
operator|,
operator|--
name|regno
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_gr_spill
argument_list|,
name|reg
argument_list|,
name|cfa_off
operator|+=
literal|8
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Locate the bottom of the register save area.  */
name|cfa_off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|+
name|current_frame_info
operator|.
name|extra_spill_size
operator|)
expr_stmt|;
comment|/* Save the predicate register block either in a register or in memory.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* ??? Denote pr spill/fill by a DImode move that modifies all 	     64 hard registers.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|alt_reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Handle AR regs in numerical order.  All of them get special handling.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_unat_save_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* The alloc insn already copied ar.pfs into a general register.  The      only thing we have to do now is copy that register to a stack slot      if we'd not allocated a local register for the job.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_pfs_save_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Save the return pointer.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_gp
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_gp
argument_list|)
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
comment|/* We don't know for sure yet if this is actually needed, since 	 we've not split the PIC call patterns.  If all of the calls 	 are indirect, and not followed by any uses of the gp, then 	 this save is dead.  Allow it to go away.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We should now be at the base of the gr/br/fr spill area.  */
name|gcc_assert
argument_list|(
name|cfa_off
operator|==
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
argument_list|)
expr_stmt|;
comment|/* Spill all general registers.  */
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_gr_spill
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Spill the rest of the BR registers.  */
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Align the frame and spill all FR registers.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
operator|(
name|cfa_off
operator|&
literal|15
operator|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_fr_spill_x
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|16
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|cfa_off
operator|==
name|current_frame_info
operator|.
name|spill_cfa_off
argument_list|)
expr_stmt|;
name|finish_spill_pointers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    epilogue.  Using an epilogue insn is favored compared to putting all of the    instructions in output_function_prologue(), since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.  */
end_comment

begin_function
name|void
name|ia64_expand_epilogue
parameter_list|(
name|int
name|sibcall_p
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|,
name|alt_reg
decl_stmt|,
name|ar_unat_save_reg
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|alt_regno
decl_stmt|,
name|cfa_off
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If there is a frame pointer, then we use it instead of the stack      pointer, so that the stack pointer does not need to be valid when      the epilogue starts.  See EXIT_IGNORE_STACK.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|current_frame_info
operator|.
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|!=
literal|0
condition|)
block|{
comment|/* ??? At this point we must generate a magic insn that appears to          modify the spill iterators and the frame pointer.  This would 	 allow the most scheduling freedom.  For now, just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Locate the bottom of the register save area.  */
name|cfa_off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|+
name|current_frame_info
operator|.
name|extra_spill_size
operator|)
expr_stmt|;
comment|/* Restore the predicate registers.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the application registers.  */
comment|/* Load the saved unat from the stack, but do not restore it until      after the GRs have been restored.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
condition|)
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|alt_regno
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_unat_save_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
else|else
name|ar_unat_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_pfs
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the return pointer.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* We should now be at the base of the gr/br/fr spill area.  */
name|gcc_assert
argument_list|(
name|cfa_off
operator|==
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
argument_list|)
expr_stmt|;
comment|/* The GP may be stored on the stack in the prologue, but it's      never restored in the epilogue.  Skip the stack slot.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|GR_REG
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
name|cfa_off
operator|-=
literal|8
expr_stmt|;
comment|/* Restore all general registers.  */
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_gr_restore
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Restore the branch registers.  */
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restore floating point registers.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
operator|(
name|cfa_off
operator|&
literal|15
operator|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_fr_restore_x
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* Restore ar.unat for real.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|ar_unat_save_reg
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|cfa_off
operator|==
name|current_frame_info
operator|.
name|spill_cfa_off
argument_list|)
expr_stmt|;
name|finish_spill_pointers
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
block|{
comment|/* ??? At this point we must generate a magic insn that appears to          modify the spill iterators, the stack pointer, and the frame 	 pointer.  This would allow the most scheduling freedom.  For now, 	 just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
condition|)
block|{
name|rtx
name|offset
decl_stmt|,
name|frame_size_rtx
decl_stmt|;
name|frame_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|current_frame_info
operator|.
name|total_size
argument_list|)
condition|)
name|offset
operator|=
name|frame_size_rtx
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset
argument_list|,
name|frame_size_rtx
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_size_rtx
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
condition|)
name|emit_insn
argument_list|(
name|gen_set_bsp
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sibcall_p
condition|)
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|fp
init|=
name|GR_REG
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/* We need a throw away register here, r0 and r1 are reserved, so r2 is the 	 first available call clobbered register.  If there was a frame_pointer 	 register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM, 	 so we have to make sure we're using the string "r2" when emitting 	 the register name for the assembler.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|&&
name|current_frame_info
operator|.
name|reg_fp
operator|==
name|GR_REG
argument_list|(
literal|2
argument_list|)
condition|)
name|fp
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* We must emit an alloc to force the input registers to become output 	 registers.  Otherwise, if the callee tries to pass its parameters 	 through to another call without an intervening alloc, then these 	 values get lost.  */
comment|/* ??? We don't need to preserve all input registers.  We only need to 	 preserve those input registers used as arguments to the sibling call. 	 It is unclear how to compute that number here.  */
if|if
condition|(
name|current_frame_info
operator|.
name|n_input_regs
operator|!=
literal|0
condition|)
block|{
name|rtx
name|n_inputs
init|=
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_input_regs
argument_list|)
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_alloc
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|fp
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|n_inputs
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if br.ret can do all the work required to return from a    function.  */
end_comment

begin_function
name|int
name|ia64_direct_return
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
operator|!
name|frame_pointer_needed
condition|)
block|{
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_spilled
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|==
literal|0
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the magic cookie that we use to hold the return address    during early compilation.  */
end_comment

begin_function
name|rtx
name|ia64_return_addr_rtx
parameter_list|(
name|HOST_WIDE_INT
name|count
parameter_list|,
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_RET_ADDR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Split this value after reload, now that we know where the return    address is saved.  */
end_comment

begin_function
name|void
name|ia64_split_return_addr_rtx
parameter_list|(
name|rtx
name|dest
parameter_list|)
block|{
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|src
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|off
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* Compute offset from CFA for BR0.  */
comment|/* ??? Must be kept in sync with ia64_expand_prologue.  */
name|off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
name|off
operator|-=
literal|8
expr_stmt|;
comment|/* Convert CFA offset to a register based offset.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|src
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
else|else
block|{
name|src
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|off
operator|+=
name|current_frame_info
operator|.
name|total_size
expr_stmt|;
block|}
comment|/* Load address into scratch register.  */
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|off
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|src
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ia64_hard_regno_rename_ok
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
comment|/* Don't clobber any of the registers we reserved for the prologue.  */
if|if
condition|(
name|to
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|from
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|0
return|;
comment|/* Don't use output registers outside the register frame.  */
if|if
condition|(
name|OUT_REGNO_P
argument_list|(
name|to
argument_list|)
operator|&&
name|to
operator|>=
name|OUT_REG
argument_list|(
name|current_frame_info
operator|.
name|n_output_regs
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Retain even/oddness on predicate register pairs.  */
if|if
condition|(
name|PR_REGNO_P
argument_list|(
name|from
argument_list|)
operator|&&
name|PR_REGNO_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
operator|(
name|from
operator|&
literal|1
operator|)
operator|==
operator|(
name|to
operator|&
literal|1
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Target hook for assembling integer objects.  Handle word-sized    aligned objects and detect the cases when @fptr is needed.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
operator|&&
operator|!
operator|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|directive
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
comment|/* 64-bit pointer */
comment|/* 32-bit pointer */
block|{
literal|"\tdata8.ua\t@fptr("
block|,
literal|"\tdata4.ua\t@fptr("
block|}
block|,
comment|/* unaligned */
block|{
literal|"\tdata8\t@fptr("
block|,
literal|"\tdata4\t@fptr("
block|}
comment|/* aligned */
block|}
decl_stmt|;
name|fputs
argument_list|(
name|directive
index|[
operator|(
name|aligned_p
operator|!=
literal|0
operator|)
index|]
index|[
name|POINTER_SIZE
operator|==
literal|32
index|]
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the function prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|grsave
decl_stmt|,
name|grsave_prev
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|need_regstk
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.regstk %d, %d, %d, %d\n"
argument_list|,
name|current_frame_info
operator|.
name|n_input_regs
argument_list|,
name|current_frame_info
operator|.
name|n_local_regs
argument_list|,
name|current_frame_info
operator|.
name|n_output_regs
argument_list|,
name|current_frame_info
operator|.
name|n_rotate_regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unwind_tables
operator|&&
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
return|return;
comment|/* Emit the .prologue directive.  */
name|mask
operator|=
literal|0
expr_stmt|;
name|grsave
operator|=
name|grsave_prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
block|{
name|mask
operator||=
literal|8
expr_stmt|;
name|grsave
operator|=
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_save_b0
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|4
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_fp
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|current_frame_info
operator|.
name|reg_save_pr
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&&
name|TARGET_GNU_AS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.prologue %d, %d\n"
argument_list|,
name|mask
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|grsave
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t.prologue\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Emit a .spill directive, if necessary, to relocate the base of      the register spill area.  */
if|if
condition|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|!=
operator|-
literal|16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.spill %ld\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the .body directive at the scheduled end of the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_end_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_unwind_tables
operator|&&
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
return|return;
name|fputs
argument_list|(
literal|"\t.body\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the function epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
expr_stmt|;
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_input_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|IN_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_input_reg_names
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_local_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|LOC_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_local_reg_names
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_output_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|OUT_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_output_reg_names
index|[
name|i
index|]
expr_stmt|;
block|}
name|current_frame_info
operator|.
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ia64_dbx_register_number
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* In ia64_expand_prologue we quite literally renamed the frame pointer      from its home at loc79 to something inside the register frame.  We      must perform the same renumbering here for the debug info.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|regno
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_fp
condition|)
name|regno
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
block|}
if|if
condition|(
name|IN_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|32
operator|+
name|regno
operator|-
name|IN_REG
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|LOC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|32
operator|+
name|current_frame_info
operator|.
name|n_input_regs
operator|+
name|regno
operator|-
name|LOC_REG
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|OUT_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
literal|32
operator|+
name|current_frame_info
operator|.
name|n_input_regs
operator|+
name|current_frame_info
operator|.
name|n_local_regs
operator|+
name|regno
operator|-
name|OUT_REG
argument_list|(
literal|0
argument_list|)
operator|)
return|;
else|else
return|return
name|regno
return|;
block|}
end_function

begin_function
name|void
name|ia64_initialize_trampoline
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|static_chain
parameter_list|)
block|{
name|rtx
name|addr_reg
decl_stmt|,
name|eight
init|=
name|GEN_INT
argument_list|(
literal|8
argument_list|)
decl_stmt|;
comment|/* The Intel assembler requires that the global __ia64_trampoline symbol      be declared explicitly */
if|if
condition|(
operator|!
name|TARGET_GNU_AS
condition|)
block|{
specifier|static
name|bool
name|declared_ia64_trampoline
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|declared_ia64_trampoline
condition|)
block|{
name|declared_ia64_trampoline
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"__ia64_trampoline"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure addresses are Pmode even if we are in ILP32 mode. */
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|fnaddr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|static_chain
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|static_chain
argument_list|)
expr_stmt|;
comment|/* Load up our iterator.  */
name|addr_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* The first two words are the fake descriptor:      __ia64_trampoline, ADDR+16.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__ia64_trampoline"
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|addr
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The third word is the target descriptor.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The fourth word is the static chain.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|static_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any needed setup for a variadic function.  CUM has not been updated    for the last named argument which has type TYPE and mode MODE.     We generate the actual spill instructions during prologue generation.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_size
parameter_list|,
name|int
name|second_time
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|CUMULATIVE_ARGS
name|next_cum
init|=
operator|*
name|cum
decl_stmt|;
comment|/* Skip the current argument.  */
name|ia64_function_arg_advance
argument_list|(
operator|&
name|next_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_cum
operator|.
name|words
operator|<
name|MAX_ARGUMENT_SLOTS
condition|)
block|{
name|int
name|n
init|=
name|MAX_ARGUMENT_SLOTS
operator|-
name|next_cum
operator|.
name|words
decl_stmt|;
operator|*
name|pretend_size
operator|=
name|n
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether TYPE is a homogeneous floating point aggregate.  If    it is, return the mode of the floating point type that appears    in all leafs.  If it is not, return VOIDmode.     An aggregate is a homogeneous floating point aggregate is if all    fields/elements in it have the same floating point type (e.g,    SFmode).  128-bit quad-precision floats are excluded.     Variable sized aggregates should never arrive here, since we should    have already decided to pass them by reference.  Top-level zero-sized    aggregates are excluded because our parallels crash the middle-end.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|hfa_element_mode
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|nested
parameter_list|)
block|{
name|enum
name|machine_mode
name|element_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|know_element_mode
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|nested
operator|&&
operator|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|VOIDmode
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|LANG_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
return|return
name|VOIDmode
return|;
comment|/* Fortran complex types are supposed to be HFAs, so we need to handle 	 gcc's COMPLEX_TYPEs as HFAs.  We need to exclude the integral complex 	 types though.  */
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TCmode
condition|)
return|return
name|GET_MODE_INNER
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
return|return
name|VOIDmode
return|;
case|case
name|REAL_TYPE
case|:
comment|/* We want to return VOIDmode for raw REAL_TYPEs, but the actual 	 mode if this is contained within an aggregate.  */
if|if
condition|(
name|nested
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TFmode
condition|)
return|return
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
name|VOIDmode
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
name|hfa_element_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|mode
operator|=
name|hfa_element_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|know_element_mode
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|element_mode
condition|)
return|return
name|VOIDmode
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
return|return
name|VOIDmode
return|;
else|else
block|{
name|know_element_mode
operator|=
literal|1
expr_stmt|;
name|element_mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
return|return
name|element_mode
return|;
default|default:
comment|/* If we reach here, we probably have some front-end specific type 	 that the backend doesn't know about.  This can happen via the 	 aggregate_value_p call in init_function_start.  All we can do is 	 ignore unknown tree types.  */
return|return
name|VOIDmode
return|;
block|}
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Return the number of words required to hold a quantity of TYPE and MODE    when passed as an argument.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_function_arg_words
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|words
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|words
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|words
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|words
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
return|;
comment|/* round up */
block|}
end_function

begin_comment
comment|/* Return the number of registers that should be skipped so the current    argument (described by TYPE and WORDS) will be properly aligned.     Integer and float arguments larger than 8 bytes start at the next    even boundary.  Aggregates larger than 8 bytes start at the next    even boundary if the aggregate has 16 byte alignment.  Note that    in the 32-bit ABI, TImode and TFmode have only 8-byte alignment    but are still to be aligned in registers.     ??? The ABI does not specify how to handle aggregates with    alignment from 9 to 15 bytes, or greater than 16.  We handle them    all as if they had 16 byte alignment.  Such aggregates can occur    only if gcc extensions are used.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_function_arg_offset
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|words
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cum
operator|->
name|words
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
return|return
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
return|;
else|else
return|return
name|words
operator|>
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return rtx for register where argument is passed, or zero if it is passed    on the stack.  */
end_comment

begin_comment
comment|/* ??? 128-bit quad-precision floats are always passed in general    registers.  */
end_comment

begin_function
name|rtx
name|ia64_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|,
name|int
name|incoming
parameter_list|)
block|{
name|int
name|basereg
init|=
operator|(
name|incoming
condition|?
name|GR_ARG_FIRST
else|:
name|AR_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|words
init|=
name|ia64_function_arg_words
argument_list|(
name|type
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ia64_function_arg_offset
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* If all argument slots are used, then it must go on the stack.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|+
name|offset
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
comment|/* Check for and handle homogeneous FP aggregates.  */
if|if
condition|(
name|type
condition|)
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas      and unprototyped hfas are passed specially.  */
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|!
name|cum
operator|->
name|prototype
operator|||
name|named
operator|)
condition|)
block|{
name|rtx
name|loc
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|fp_regs
init|=
name|cum
operator|->
name|fp_regs
decl_stmt|;
name|int
name|int_regs
init|=
name|cum
operator|->
name|words
operator|+
name|offset
decl_stmt|;
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|args_byte_size
decl_stmt|;
comment|/* If prototyped, pass it in FR regs then GR regs. 	 If not prototyped, pass it in both FR and GR regs.  	 If this is an SFmode aggregate, then it is possible to run out of 	 FR regs while GR regs are still left.  In that case, we pass the 	 remaining part in the GR regs.  */
comment|/* Fill the FP regs.  We do this always.  We stop if we reach the end 	 of the argument, the last FP register, or the last argument slot.  */
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|args_byte_size
operator|=
name|int_regs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|offset
operator|<
name|byte_size
operator|&&
name|fp_regs
operator|<
name|MAX_ARGUMENT_SLOTS
operator|&&
name|args_byte_size
operator|<
operator|(
name|MAX_ARGUMENT_SLOTS
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|hfa_mode
argument_list|,
operator|(
name|FR_ARG_FIRST
operator|+
name|fp_regs
operator|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|hfa_size
expr_stmt|;
name|args_byte_size
operator|+=
name|hfa_size
expr_stmt|;
name|fp_regs
operator|++
expr_stmt|;
block|}
comment|/* If no prototype, then the whole thing must go in GR regs.  */
if|if
condition|(
operator|!
name|cum
operator|->
name|prototype
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* If this is an SFmode aggregate, then we might have some left over 	 that needs to go in GR regs.  */
elseif|else
if|if
condition|(
name|byte_size
operator|!=
name|offset
condition|)
name|int_regs
operator|+=
name|offset
operator|/
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Fill in the GR regs.  We must use DImode here, not the hfa mode.  */
for|for
control|(
init|;
name|offset
operator|<
name|byte_size
operator|&&
name|int_regs
operator|<
name|MAX_ARGUMENT_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|gr_mode
init|=
name|DImode
decl_stmt|;
name|unsigned
name|int
name|gr_size
decl_stmt|;
comment|/* If we have an odd 4 byte hunk because we ran out of FR regs, 	     then this goes in a GR reg left adjusted/little endian, right 	     adjusted/big endian.  */
comment|/* ??? Currently this is handled wrong, because 4-byte hunks are 	     always right adjusted/little endian.  */
if|if
condition|(
name|offset
operator|&
literal|0x4
condition|)
name|gr_mode
operator|=
name|SImode
expr_stmt|;
comment|/* If we have an even 4 byte hunk because the aggregate is a 	     multiple of 4 bytes in size, then this goes in a GR reg right 	     adjusted/little endian.  */
elseif|else
if|if
condition|(
name|byte_size
operator|-
name|offset
operator|==
literal|4
condition|)
name|gr_mode
operator|=
name|SImode
expr_stmt|;
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|gr_mode
argument_list|,
operator|(
name|basereg
operator|+
name|int_regs
operator|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|gr_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|gr_mode
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|gr_size
expr_stmt|;
if|if
condition|(
name|gr_size
operator|==
name|UNITS_PER_WORD
operator|||
operator|(
name|gr_size
operator|<
name|UNITS_PER_WORD
operator|&&
name|offset
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
operator|)
condition|)
name|int_regs
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|gr_size
operator|>
name|UNITS_PER_WORD
condition|)
name|int_regs
operator|+=
name|gr_size
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
comment|/* Integral and aggregates go in general registers.  If we have run out of      FR registers, then FP values must also go in general registers.  This can      happen when we have a SFmode HFA.  */
elseif|else
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|TCmode
operator|||
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|cum
operator|->
name|fp_regs
operator|==
name|MAX_ARGUMENT_SLOTS
operator|)
condition|)
block|{
name|int
name|byte_size
init|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|&&
name|byte_size
operator|<
name|UNITS_PER_WORD
operator|&&
name|byte_size
operator|>
literal|0
condition|)
block|{
name|rtx
name|gr_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
operator|(
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|gr_reg
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
return|;
block|}
comment|/* If there is a prototype, then FP values go in a FR register when      named, and in a GR register when unnamed.  */
elseif|else
if|if
condition|(
name|cum
operator|->
name|prototype
condition|)
block|{
if|if
condition|(
name|named
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FR_ARG_FIRST
operator|+
name|cum
operator|->
name|fp_regs
argument_list|)
return|;
comment|/* In big-endian mode, an anonymous SFmode value must be represented          as (parallel:SF [(expr_list (reg:DI n) (const_int 0))]) to force 	 the value into the high half of the general register.  */
elseif|else
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|==
name|SFmode
condition|)
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
return|;
block|}
comment|/* If there is no prototype, then FP values go in both FR and GR      registers.  */
else|else
block|{
comment|/* See comment above.  */
name|enum
name|machine_mode
name|inner_mode
init|=
operator|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|==
name|SFmode
operator|)
condition|?
name|DImode
else|:
name|mode
decl_stmt|;
name|rtx
name|fp_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
operator|(
name|FR_ARG_FIRST
operator|+
name|cum
operator|->
name|fp_regs
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|rtx
name|gr_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner_mode
argument_list|,
operator|(
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|fp_reg
argument_list|,
name|gr_reg
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return number of bytes, at the beginning of the argument, that must be    put in registers.  0 is the argument is entirely in registers or entirely    in memory.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|words
init|=
name|ia64_function_arg_words
argument_list|(
name|type
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ia64_function_arg_offset
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
decl_stmt|;
comment|/* If all argument slots are used, then it must go on the stack.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|+
name|offset
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
comment|/* It doesn't matter whether the argument goes in FR or GR regs.  If      it fits within the 8 argument slots, then it goes entirely in      registers.  If it extends past the last argument slot, then the rest      goes on the stack.  */
if|if
condition|(
name|words
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|<=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|MAX_ARGUMENT_SLOTS
operator|-
name|cum
operator|->
name|words
operator|-
name|offset
operator|)
operator|*
name|UNITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Update CUM to point after this argument.  This is patterned after    ia64_function_arg.  */
end_comment

begin_function
name|void
name|ia64_function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|int
name|words
init|=
name|ia64_function_arg_words
argument_list|(
name|type
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ia64_function_arg_offset
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* If all arg slots are already full, then there is nothing to do.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return;
name|cum
operator|->
name|words
operator|+=
name|words
operator|+
name|offset
expr_stmt|;
comment|/* Check for and handle homogeneous FP aggregates.  */
if|if
condition|(
name|type
condition|)
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas      and unprototyped hfas are passed specially.  */
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|!
name|cum
operator|->
name|prototype
operator|||
name|named
operator|)
condition|)
block|{
name|int
name|fp_regs
init|=
name|cum
operator|->
name|fp_regs
decl_stmt|;
comment|/* This is the original value of cum->words + offset.  */
name|int
name|int_regs
init|=
name|cum
operator|->
name|words
operator|-
name|words
decl_stmt|;
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|args_byte_size
decl_stmt|;
comment|/* If prototyped, pass it in FR regs then GR regs. 	 If not prototyped, pass it in both FR and GR regs.  	 If this is an SFmode aggregate, then it is possible to run out of 	 FR regs while GR regs are still left.  In that case, we pass the 	 remaining part in the GR regs.  */
comment|/* Fill the FP regs.  We do this always.  We stop if we reach the end 	 of the argument, the last FP register, or the last argument slot.  */
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|args_byte_size
operator|=
name|int_regs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|offset
operator|<
name|byte_size
operator|&&
name|fp_regs
operator|<
name|MAX_ARGUMENT_SLOTS
operator|&&
name|args_byte_size
operator|<
operator|(
name|MAX_ARGUMENT_SLOTS
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
condition|;
control|)
block|{
name|offset
operator|+=
name|hfa_size
expr_stmt|;
name|args_byte_size
operator|+=
name|hfa_size
expr_stmt|;
name|fp_regs
operator|++
expr_stmt|;
block|}
name|cum
operator|->
name|fp_regs
operator|=
name|fp_regs
expr_stmt|;
block|}
comment|/* Integral and aggregates go in general registers.  So do TFmode FP values.      If we have run out of FR registers, then other FP values must also go in      general registers.  This can happen when we have a SFmode HFA.  */
elseif|else
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|TCmode
operator|||
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|cum
operator|->
name|fp_regs
operator|==
name|MAX_ARGUMENT_SLOTS
operator|)
condition|)
name|cum
operator|->
name|int_regs
operator|=
name|cum
operator|->
name|words
expr_stmt|;
comment|/* If there is a prototype, then FP values go in a FR register when      named, and in a GR register when unnamed.  */
elseif|else
if|if
condition|(
name|cum
operator|->
name|prototype
condition|)
block|{
if|if
condition|(
operator|!
name|named
condition|)
name|cum
operator|->
name|int_regs
operator|=
name|cum
operator|->
name|words
expr_stmt|;
else|else
comment|/* ??? Complex types should not reach here.  */
name|cum
operator|->
name|fp_regs
operator|+=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If there is no prototype, then FP values go in both FR and GR      registers.  */
else|else
block|{
comment|/* ??? Complex types should not reach here.  */
name|cum
operator|->
name|fp_regs
operator|+=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|cum
operator|->
name|int_regs
operator|=
name|cum
operator|->
name|words
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Arguments with alignment larger than 8 bytes start at the next even    boundary.  On ILP32 HPUX, TFmode arguments start on next even boundary    even though their normal alignment is 8 bytes.  See ia64_function_arg.  */
end_comment

begin_function
name|int
name|ia64_function_arg_boundary
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|&&
name|TARGET_HPUX
operator|&&
name|TARGET_ILP32
condition|)
return|return
name|PARM_BOUNDARY
operator|*
literal|2
return|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|PARM_BOUNDARY
condition|)
return|return
name|PARM_BOUNDARY
operator|*
literal|2
return|;
else|else
return|return
name|PARM_BOUNDARY
return|;
block|}
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|PARM_BOUNDARY
condition|)
return|return
name|PARM_BOUNDARY
operator|*
literal|2
return|;
else|else
return|return
name|PARM_BOUNDARY
return|;
block|}
end_function

begin_comment
comment|/* True if it is OK to do sibling call optimization for the specified    call expression EXP.  DECL will be the called function, or NULL if    this is an indirect call.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We can't perform a sibcall if the current function has the syscall_linkage      attribute.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We must always return with our current GP.  This means we can      only sibcall to functions defined in the current module.  */
return|return
name|decl
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
specifier|static
name|tree
name|ia64_gimplify_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
comment|/* Variable sized types are passed by reference.  */
if|if
condition|(
name|pass_by_reference
argument_list|(
name|NULL
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|tree
name|ptrtype
init|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|addr
init|=
name|std_gimplify_va_arg_expr
argument_list|(
name|valist
argument_list|,
name|ptrtype
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
decl_stmt|;
return|return
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
return|;
block|}
comment|/* Aggregate arguments with alignment larger than 8 bytes start at      the next even boundary.  Integer and floating point arguments      do so if they are larger than 8 bytes, whether or not they are      also aligned larger than 8 bytes.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
else|:
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
condition|)
block|{
name|tree
name|t
init|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
return|return
name|std_gimplify_va_arg_expr
argument_list|(
name|valist
argument_list|,
name|type
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if function return value returned in memory.  Return 0 if it is    in a register.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_return_in_memory
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
decl_stmt|;
name|HOST_WIDE_INT
name|byte_size
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|byte_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|byte_size
operator|=
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_size
operator|<
literal|0
condition|)
return|return
name|true
return|;
block|}
comment|/* Hfa's with up to 8 elements are returned in the FP argument registers.  */
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|valtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|byte_size
operator|/
name|hfa_size
operator|>
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|byte_size
operator|>
name|UNITS_PER_WORD
operator|*
name|MAX_INT_RETURN_SLOTS
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return rtx for register that holds the function return value.  */
end_comment

begin_function
name|rtx
name|ia64_function_value
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|func
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|valtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|loc
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hfa_size
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|hfa_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
expr_stmt|;
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|byte_size
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|hfa_mode
argument_list|,
name|FR_ARG_FIRST
operator|+
name|i
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|hfa_size
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
name|mode
operator|!=
name|TFmode
operator|&&
name|mode
operator|!=
name|TCmode
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FR_ARG_FIRST
argument_list|)
return|;
else|else
block|{
name|bool
name|need_parallel
init|=
name|false
decl_stmt|;
comment|/* In big-endian mode, we need to manage the layout of aggregates 	 in the registers so that we get the bits properly aligned in 	 the highpart of the registers.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|valtype
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|)
operator|)
condition|)
name|need_parallel
operator|=
name|true
expr_stmt|;
comment|/* Something like struct S { long double x; char a[0] } is not an 	 HFA structure, and therefore doesn't go in fp registers.  But 	 the middle-end will give it XFmode anyway, and XFmode values 	 don't normally fit in integer registers.  So we need to smuggle 	 the value inside a parallel.  */
elseif|else
if|if
condition|(
name|mode
operator|==
name|XFmode
operator|||
name|mode
operator|==
name|XCmode
operator|||
name|mode
operator|==
name|RFmode
condition|)
name|need_parallel
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|need_parallel
condition|)
block|{
name|rtx
name|loc
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|bytesize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|bytesize
operator|=
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
comment|/* An empty PARALLEL is invalid here, but the return value 	     doesn't matter for empty structs.  */
if|if
condition|(
name|bytesize
operator|==
literal|0
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GR_RET_FIRST
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|bytesize
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|GR_RET_FIRST
operator|+
name|i
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GR_RET_FIRST
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|size
operator|==
literal|4
operator|||
name|size
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|fputs
argument_list|(
literal|"\tdata4.ua\t@dtprel("
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\tdata8.ua\t@dtprel("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a memory address as an operand to reference that memory location.  */
end_comment

begin_comment
comment|/* ??? Do we need this?  It gets used only for 'a' operands.  We could perhaps    also call this from ia64_print_operand for memory addresses.  */
end_comment

begin_function
name|void
name|ia64_print_operand_address
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|address
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Print an operand to an assembler instruction.    C	Swap and print a comparison operator.    D	Print an FP comparison operator.    E    Print 32 - constant, for SImode shifts as extract.    e    Print 64 - constant, for DImode rotates.    F	A floating point constant 0.0 emitted as f0, or 1.0 emitted as f1, or         a floating point register emitted normally.    I	Invert a predicate register by adding 1.    J    Select the proper predicate register for a condition.    j    Select the inverse predicate register for a condition.    O	Append .acq for volatile load.    P	Postincrement of a MEM.    Q	Append .rel for volatile store.    S	Shift amount for shladd instruction.    T	Print an 8-bit sign extended number (K) as a 32-bit unsigned number 	for Intel assembler.    U	Print an 8-bit sign extended number (K) as a 64-bit unsigned number 	for Intel assembler.    X	A pair of floating point registers.    r	Print register name, or constant 0 as r0.  HP compatibility for 	Linux kernel.    v    Print vector constant value as an 8-byte integer value.  */
end_comment

begin_function
name|void
name|ia64_print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* Handled below.  */
break|break;
case|case
literal|'C'
case|:
block|{
name|enum
name|rtx_code
name|c
init|=
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|GET_RTX_NAME
argument_list|(
name|c
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|NE
case|:
name|str
operator|=
literal|"neq"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|str
operator|=
literal|"unord"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|str
operator|=
literal|"ord"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs
argument_list|(
name|str
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'E'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
literal|32
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'e'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|str
operator|=
name|reg_names
index|[
name|FR_REG
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|str
operator|=
name|reg_names
index|[
name|FR_REG
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|str
operator|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
block|}
name|fputs
argument_list|(
name|str
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
case|case
literal|'j'
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
condition|)
name|regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'j'
condition|)
name|regno
operator|^=
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'O'
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|".acq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
default|default:
return|return;
case|case
name|POST_MODIFY
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|value
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|POST_INC
case|:
name|value
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|value
operator|=
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'Q'
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|".rel"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|TARGET_GNU_AS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
operator|!
name|TARGET_GNU_AS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|"0x"
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x80000000
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0xffffffff"
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%x"
argument_list|,
name|prefix
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'X'
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s, %s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as register zero. 	 Any register, zero, or CONST_INT value is OK here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"r0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'v'
case|:
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
argument_list|)
expr_stmt|;
name|x
operator|=
name|simplify_subreg
argument_list|(
name|DImode
argument_list|,
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
block|{
specifier|const
name|char
modifier|*
name|which
decl_stmt|;
comment|/* For conditional branches, returns or calls, substitute 	   sptk, dptk, dpnt, or spnt for %s.  */
name|x
operator|=
name|find_reg_note
argument_list|(
name|current_output_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|int
name|pred_val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Guess top and bottom 10% statically predicted.  */
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|50
operator|&&
name|br_prob_note_reliable_p
argument_list|(
name|x
argument_list|)
condition|)
name|which
operator|=
literal|".spnt"
expr_stmt|;
elseif|else
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
name|which
operator|=
literal|".dpnt"
expr_stmt|;
elseif|else
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
literal|98
operator|||
operator|!
name|br_prob_note_reliable_p
argument_list|(
name|x
argument_list|)
condition|)
name|which
operator|=
literal|".dptk"
expr_stmt|;
else|else
name|which
operator|=
literal|".sptk"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|current_output_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|which
operator|=
literal|".sptk"
expr_stmt|;
else|else
name|which
operator|=
literal|".dptk"
expr_stmt|;
name|fputs
argument_list|(
name|which
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|','
case|:
name|x
operator|=
name|current_insn_predicate
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
condition|)
name|regno
operator|+=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s) "
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"ia64_print_operand: unknown code"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This happens for the spill/restore instructions.  */
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|REG
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|RTX_AUTOINC
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_comment
comment|/* ??? This is incomplete.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
switch|switch
condition|(
name|outer_code
condition|)
block|{
case|case
name|SET
case|:
operator|*
name|total
operator|=
name|CONST_OK_FOR_J
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
literal|0
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_J
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
if|if
condition|(
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|CONST_OK_FOR_L
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
case|case
name|CONST_DOUBLE
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|MULT
case|:
comment|/* For multiplies wider than HImode, we have to go to the FPU,          which normally involves copies.  Plus there's the latency          of the multiply itself, and the latency of the instructions to          transfer integer regs to FP regs.  */
comment|/* ??? Check for FP mode.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|2
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
comment|/* We make divide expensive, so that divide-by-constant will be          optimized to a multiply.  */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|60
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the cost of moving data from a register in class FROM to    one in class TO, using MODE.  */
end_comment

begin_function
name|int
name|ia64_register_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|from
parameter_list|,
name|enum
name|reg_class
name|to
parameter_list|)
block|{
comment|/* ADDL_REGS is the same as GR_REGS for movement purposes.  */
if|if
condition|(
name|to
operator|==
name|ADDL_REGS
condition|)
name|to
operator|=
name|GR_REGS
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|ADDL_REGS
condition|)
name|from
operator|=
name|GR_REGS
expr_stmt|;
comment|/* All costs are symmetric, so reduce cases by putting the      lower number class as the destination.  */
if|if
condition|(
name|from
operator|<
name|to
condition|)
block|{
name|enum
name|reg_class
name|tmp
init|=
name|to
decl_stmt|;
name|to
operator|=
name|from
operator|,
name|from
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Moving from FR<->GR in XFmode must be more expensive than 2,      so that we get secondary memory reloads.  Between FR_REGS,      we have to make this at least as expensive as MEMORY_MOVE_COST      to avoid spectacularly poor register class preferencing.  */
if|if
condition|(
name|mode
operator|==
name|XFmode
operator|||
name|mode
operator|==
name|RFmode
condition|)
block|{
if|if
condition|(
name|to
operator|!=
name|GR_REGS
operator|||
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
literal|3
return|;
block|}
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|PR_REGS
case|:
comment|/* Moving between PR registers takes two insns.  */
if|if
condition|(
name|from
operator|==
name|PR_REGS
condition|)
return|return
literal|3
return|;
comment|/* Moving between PR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|BR_REGS
case|:
comment|/* Moving between BR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
operator|&&
name|from
operator|!=
name|GR_AND_BR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|AR_I_REGS
case|:
case|case
name|AR_M_REGS
case|:
comment|/* Moving between AR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|GR_REGS
case|:
case|case
name|FR_REGS
case|:
case|case
name|FP_REGS
case|:
case|case
name|GR_AND_FR_REGS
case|:
case|case
name|GR_AND_BR_REGS
case|:
case|case
name|ALL_REGS
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Implement PREFERRED_RELOAD_CLASS.  Place additional restrictions on CLASS    to use when copying X into that class.  */
end_comment

begin_function
name|enum
name|reg_class
name|ia64_preferred_reload_class
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|FR_REGS
case|:
case|case
name|FP_REGS
case|:
comment|/* Don't allow volatile mem reloads into floating point registers. 	 This is defined to force reload to choose the r/m case instead 	 of the f/f case when reloading (set (reg fX) (mem/v)).  */
if|if
condition|(
name|MEM_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Force all unrecognized constants into the constant pool.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
break|break;
case|case
name|AR_M_REGS
case|:
case|case
name|AR_I_REGS
case|:
if|if
condition|(
operator|!
name|OBJECT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* This function returns the register class required for a secondary    register when copying between one of the registers in CLASS, and X,    using MODE.  A return value of NO_REGS means that no secondary register    is required.  */
end_comment

begin_function
name|enum
name|reg_class
name|ia64_secondary_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|BR_REGS
case|:
case|case
name|AR_M_REGS
case|:
case|case
name|AR_I_REGS
case|:
comment|/* ??? BR<->BR register copies can happen due to a bad gcse/cse/global 	 interaction.  We end up with two pseudos with overlapping lifetimes 	 both of which are equiv to the same constant, and both which need 	 to be in BR_REGS.  This seems to be a cse bug.  cse_basic_block_end 	 changes depending on the path length, which means the qty_first_reg 	 check in make_regs_eqv can give different answers at different times. 	 At some point I'll probably need a reload_indi pattern to handle 	 this.  	 We can also get GR_AND_FR_REGS to BR_REGS/AR_REGS copies, where we 	 wound up with a FP register from GR_AND_FR_REGS.  Extend that to all 	 non-general registers for good measure.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This is needed if a pseudo used as a call_operand gets spilled to a 	 stack slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|GR_REGS
return|;
break|break;
case|case
name|FR_REGS
case|:
case|case
name|FP_REGS
case|:
comment|/* Need to go through general registers to get to other class regs.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen when a paradoxical subreg is an operand to the 	 muldi3 pattern.  */
comment|/* ??? This shouldn't be necessary after instruction scheduling is 	 enabled, because paradoxical subregs are not accepted by 	 register_operand when INSN_SCHEDULING is defined.  Or alternatively, 	 stop the paradoxical subreg stupidity in the *_operand functions 	 in recog.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|HImode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen because of the ior/and/etc patterns that accept FP 	 registers as operands.  If the third operand is a constant, then it 	 needs to be reloaded into a FP register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen because of register elimination in a muldi3 insn. 	 E.g. `26107 * (unsigned long)&u'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|GR_REGS
return|;
break|break;
case|case
name|PR_REGS
case|:
comment|/* ??? This happens if we cse/gcse a BImode value across a call, 	 and the function has a nonlocal goto.  This is because global 	 does not allocate call crossing pseudos to hard registers when 	 current_function_has_nonlocal_goto is true.  This is relatively 	 common for C++ programs that use exceptions.  To reproduce, 	 return NO_REGS and compile libstdc++.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen when we take a BImode subreg of a DImode value, 	 and that DImode value winds up in some non-GR register.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|PR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GR_REGS
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|NO_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit text to declare externally defined variables and functions, because    the Intel assembler does not support undefined externals.  */
end_comment

begin_function
name|void
name|ia64_asm_output_external
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|save_referenced
decl_stmt|;
comment|/* GNU as does not need anything here, but the HP linker does need      something for external functions.  */
if|if
condition|(
name|TARGET_GNU_AS
operator|&&
operator|(
operator|!
name|TARGET_HPUX_LD
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|strstr
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|)
operator|==
name|name
operator|)
condition|)
return|return;
comment|/* ??? The Intel assembler creates a reference that needs to be satisfied by      the linker when we do this, so we need to be careful not to do this for      builtin functions which have no library equivalent.  Unfortunately, we      can't tell here whether or not a function will actually be called by      expand_expr, so we pull in library functions even if we may not need      them later.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_next_arg"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alloca"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_constant_p"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_args_info"
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TARGET_HPUX_LD
condition|)
name|ia64_hpux_add_extern_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* assemble_name will set TREE_SYMBOL_REFERENCED, so we must save and          restore it.  */
name|save_referenced
operator|=
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ASM_OUTPUT_TYPE_DIRECTIVE
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|save_referenced
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the -mfixed-range= option string.  */
end_comment

begin_function
specifier|static
name|void
name|fix_range
parameter_list|(
specifier|const
name|char
modifier|*
name|const_str
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|dash
decl_stmt|,
modifier|*
name|comma
decl_stmt|;
comment|/* str must be of the form REG1'-'REG2{,REG1'-'REG} where REG1 and      REG2 are either register names or register numbers.  The effect      of this option is to mark the registers in the range from REG1 to      REG2 as ``fixed'' so they won't be used by the compiler.  This is      used, e.g., to ensure that kernel mode code doesn't use f32-f127.  */
name|i
operator|=
name|strlen
argument_list|(
name|const_str
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|const_str
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dash
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dash
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"value of -mfixed-range must have form REG1-REG2"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|dash
operator|=
literal|'\0'
expr_stmt|;
name|comma
operator|=
name|strchr
argument_list|(
name|dash
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
name|first
operator|=
name|decode_reg_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unknown register name: %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|decode_reg_name
argument_list|(
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unknown register name: %s"
argument_list|,
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|dash
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|last
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%s-%s is an empty range"
argument_list|,
name|str
argument_list|,
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|comma
condition|)
break|break;
operator|*
name|comma
operator|=
literal|','
expr_stmt|;
name|str
operator|=
name|comma
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement TARGET_HANDLE_OPTION.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_handle_option
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT_mfixed_range_
case|:
name|fix_range
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_mtls_size_
case|:
if|if
condition|(
name|value
operator|!=
literal|14
operator|&&
name|value
operator|!=
literal|22
operator|&&
name|value
operator|!=
literal|64
condition|)
name|error
argument_list|(
literal|"bad value %<%s%> for -mtls-size= switch"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_mtune_
case|:
block|{
specifier|static
struct|struct
name|pta
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* processor name or nickname.  */
name|enum
name|processor_type
name|processor
decl_stmt|;
block|}
decl|const
name|processor_alias_table
index|[]
init|=
block|{
block|{
literal|"itanium"
block|,
name|PROCESSOR_ITANIUM
block|}
block|,
block|{
literal|"itanium1"
block|,
name|PROCESSOR_ITANIUM
block|}
block|,
block|{
literal|"merced"
block|,
name|PROCESSOR_ITANIUM
block|}
block|,
block|{
literal|"itanium2"
block|,
name|PROCESSOR_ITANIUM2
block|}
block|,
block|{
literal|"mckinley"
block|,
name|PROCESSOR_ITANIUM2
block|}
block|, 	  }
struct|;
name|int
specifier|const
name|pta_size
init|=
name|ARRAY_SIZE
argument_list|(
name|processor_alias_table
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ia64_tune
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value %<%s%> for -mtune= switch"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implement OVERRIDE_OPTIONS.  */
end_comment

begin_function
name|void
name|ia64_override_options
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
name|target_flags
operator||=
name|MASK_CONST_GP
expr_stmt|;
if|if
condition|(
name|TARGET_INLINE_SQRT
operator|==
name|INL_MIN_LAT
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"not yet implemented: latency-optimized inline square root"
argument_list|)
expr_stmt|;
name|TARGET_INLINE_SQRT
operator|=
name|INL_MAX_THR
expr_stmt|;
block|}
name|ia64_flag_schedule_insns2
operator|=
name|flag_schedule_insns_after_reload
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|0
expr_stmt|;
name|ia64_section_threshold
operator|=
name|g_switch_set
condition|?
name|g_switch_value
else|:
name|IA64_DEFAULT_GVALUE
expr_stmt|;
name|init_machine_status
operator|=
name|ia64_init_machine_status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|ia64_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|enum
name|attr_itanium_class
name|ia64_safe_itanium_class
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|attr_type
name|ia64_safe_type
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|enum
name|attr_itanium_class
name|ia64_safe_itanium_class
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_itanium_class
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|ITANIUM_CLASS_UNKNOWN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|attr_type
name|ia64_safe_type
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_type
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|TYPE_UNKNOWN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following collection of routines emit instruction group stop bits as    necessary to avoid dependencies.  */
end_comment

begin_comment
comment|/* Need to track some additional registers as far as serialization is    concerned so we can properly handle br.call and br.ret.  We could    make these registers visible to gcc, but since these registers are    never explicitly used in gcc generated code, it seems wasteful to    do so (plus it would make the call and return patterns needlessly    complex).  */
end_comment

begin_define
define|#
directive|define
name|REG_RP
value|(BR_REG (0))
end_define

begin_define
define|#
directive|define
name|REG_AR_CFM
value|(FIRST_PSEUDO_REGISTER + 1)
end_define

begin_comment
comment|/* This is used for volatile asms which may require a stop bit immediately    before and after them.  */
end_comment

begin_define
define|#
directive|define
name|REG_VOLATILE
value|(FIRST_PSEUDO_REGISTER + 2)
end_define

begin_define
define|#
directive|define
name|AR_UNAT_BIT_0
value|(FIRST_PSEUDO_REGISTER + 3)
end_define

begin_define
define|#
directive|define
name|NUM_REGS
value|(AR_UNAT_BIT_0 + 64)
end_define

begin_comment
comment|/* For each register, we keep track of how it has been written in the    current instruction group.     If a register is written unconditionally (no qualifying predicate),    WRITE_COUNT is set to 2 and FIRST_PRED is ignored.     If a register is written if its qualifying predicate P is true, we    set WRITE_COUNT to 1 and FIRST_PRED to P.  Later on, the same register    may be written again by the complement of P (P^1) and when this happens,    WRITE_COUNT gets set to 2.     The result of this is that whenever an insn attempts to write a register    whose WRITE_COUNT is two, we need to issue an insn group barrier first.     If a predicate register is written by a floating-point insn, we set    WRITTEN_BY_FP to true.     If a predicate register is written by an AND.ORCM we set WRITTEN_BY_AND    to true; if it was written by an OR.ANDCM we set WRITTEN_BY_OR to true.  */
end_comment

begin_struct
struct|struct
name|reg_write_state
block|{
name|unsigned
name|int
name|write_count
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|first_pred
range|:
literal|16
decl_stmt|;
name|unsigned
name|int
name|written_by_fp
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|written_by_and
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|written_by_or
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Cumulative info for the current instruction group.  */
end_comment

begin_decl_stmt
name|struct
name|reg_write_state
name|rws_sum
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info for the current instruction.  This gets copied to rws_sum after a    stop bit is emitted.  */
end_comment

begin_decl_stmt
name|struct
name|reg_write_state
name|rws_insn
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates whether this is the first instruction after a stop bit,    in which case we don't need another stop bit.  Without this,    ia64_variable_issue will die when scheduling an alloc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_instruction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Misc flags needed to compute RAW/WAW dependencies while we are traversing    RTL for one instruction.  */
end_comment

begin_struct
struct|struct
name|reg_flags
block|{
name|unsigned
name|int
name|is_write
range|:
literal|1
decl_stmt|;
comment|/* Is register being written?  */
name|unsigned
name|int
name|is_fp
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of an fp op?  */
name|unsigned
name|int
name|is_branch
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of a branch?  */
name|unsigned
name|int
name|is_and
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of and.orcm?  */
name|unsigned
name|int
name|is_or
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of or.andcm?  */
name|unsigned
name|int
name|is_sibcall
range|:
literal|1
decl_stmt|;
comment|/* Is this a sibling or normal call?  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|rws_update
parameter_list|(
name|struct
name|reg_write_state
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rws_access_regno
parameter_list|(
name|int
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rws_access_reg
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_set_flags
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_src_needs_barrier
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtx_needs_barrier
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_insn_group_barriers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|group_barrier_needed
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_group_barrier_needed
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Update *RWS for REGNO, which is being written by the current instruction,    with predicate PRED, and associated register flags in FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|rws_update
parameter_list|(
name|struct
name|reg_write_state
modifier|*
name|rws
parameter_list|,
name|int
name|regno
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
if|if
condition|(
name|pred
condition|)
name|rws
index|[
name|regno
index|]
operator|.
name|write_count
operator|++
expr_stmt|;
else|else
name|rws
index|[
name|regno
index|]
operator|.
name|write_count
operator|=
literal|2
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_fp
operator||=
name|flags
operator|.
name|is_fp
expr_stmt|;
comment|/* ??? Not tracking and/or across differing predicates.  */
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_and
operator|=
name|flags
operator|.
name|is_and
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_or
operator|=
name|flags
operator|.
name|is_or
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|first_pred
operator|=
name|pred
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an access to register REGNO of type FLAGS using predicate register    PRED.  Update rws_insn and rws_sum arrays.  Return 1 if this access creates    a dependency with an earlier instruction in the same group.  */
end_comment

begin_function
specifier|static
name|int
name|rws_access_regno
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|regno
operator|<
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
name|flags
operator|.
name|is_and
operator|=
name|flags
operator|.
name|is_or
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|is_write
condition|)
block|{
name|int
name|write_count
decl_stmt|;
comment|/* One insn writes same reg multiple times?  */
name|gcc_assert
argument_list|(
operator|!
name|rws_insn
index|[
name|regno
index|]
operator|.
name|write_count
argument_list|)
expr_stmt|;
comment|/* Update info for current instruction.  */
name|rws_update
argument_list|(
name|rws_insn
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|write_count
operator|=
name|rws_sum
index|[
name|regno
index|]
operator|.
name|write_count
expr_stmt|;
switch|switch
condition|(
name|write_count
condition|)
block|{
case|case
literal|0
case|:
comment|/* The register has not been written yet.  */
name|rws_update
argument_list|(
name|rws_sum
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* The register has been written via a predicate.  If this is 	     not a complementary predicate, then we need a barrier.  */
comment|/* ??? This assumes that P and P+1 are always complementary 	     predicates for P even.  */
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|first_pred
operator|^
literal|1
operator|)
operator|!=
name|pred
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
name|rws_update
argument_list|(
name|rws_sum
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* The register has been unconditionally written already.  We 	     need a barrier.  */
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
empty_stmt|;
else|else
name|need_barrier
operator|=
literal|1
expr_stmt|;
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
operator|=
name|flags
operator|.
name|is_and
expr_stmt|;
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
operator|=
name|flags
operator|.
name|is_or
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|is_branch
condition|)
block|{
comment|/* Branches have several RAW exceptions that allow to avoid 	     barriers.  */
if|if
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|==
name|BR_REGS
operator|||
name|regno
operator|==
name|AR_PFS_REGNUM
condition|)
comment|/* RAW dependencies on branch regs are permissible as long 	       as the writer is a non-branch instruction.  Since we 	       never generate code that uses a branch register written 	       by a branch instruction, handling this case is 	       easy.  */
return|return
literal|0
return|;
if|if
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|==
name|PR_REGS
operator|&&
operator|!
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_fp
condition|)
comment|/* The predicates of a branch are available within the 	       same insn group as long as the predicate was written by 	       something other than a floating-point instruction.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|write_count
condition|)
block|{
case|case
literal|0
case|:
comment|/* The register has not been written yet.  */
break|break;
case|case
literal|1
case|:
comment|/* The register has been written via a predicate.  If this is 	     not a complementary predicate, then we need a barrier.  */
comment|/* ??? This assumes that P and P+1 are always complementary 	     predicates for P even.  */
if|if
condition|(
operator|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|first_pred
operator|^
literal|1
operator|)
operator|!=
name|pred
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* The register has been unconditionally written already.  We 	     need a barrier.  */
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rws_access_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|rws_access_regno
argument_list|(
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
else|else
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|regno
operator|+
name|n
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
name|need_barrier
return|;
block|}
block|}
end_function

begin_comment
comment|/* Examine X, which is a SET rtx, and update the flags, the predicate, and    the condition, stored in *PFLAGS, *PPRED and *PCOND.  */
end_comment

begin_function
specifier|static
name|void
name|update_set_flags
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|reg_flags
modifier|*
name|pflags
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|CALL
case|:
return|return;
case|case
name|IF_THEN_ELSE
case|:
comment|/* There are four cases here: 	 (1) The destination is (pc), in which case this is a branch, 	 nothing here applies. 	 (2) The destination is ar.lc, in which case this is a 	 doloop_end_internal, 	 (3) The destination is an fp register, in which case this is 	 an fselect instruction. 	 (4) The condition has (unspec [(reg)] UNSPEC_LDC), in which case  	 this is a check load. 	 In all cases, nothing we do in this function applies.  */
return|return;
default|default:
if|if
condition|(
name|COMPARISON_P
argument_list|(
name|src
argument_list|)
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* Set pflags->is_fp to 1 so that we know we're dealing 	   with a floating point comparison when processing the 	   destination of the SET.  */
name|pflags
operator|->
name|is_fp
operator|=
literal|1
expr_stmt|;
comment|/* Discover if this is a parallel comparison.  We only handle 	 and.orcm and or.andcm at present, since we must retain a 	 strict inverse on the predicate pair.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|AND
condition|)
name|pflags
operator|->
name|is_and
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IOR
condition|)
name|pflags
operator|->
name|is_or
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of rtx_needs_barrier; this function determines whether the    source of a given SET rtx found in X needs a barrier.  FLAGS and PRED    are as in rtx_needs_barrier.  COND is an rtx that holds the condition    for this insn.  */
end_comment

begin_function
specifier|static
name|int
name|set_src_needs_barrier
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
name|rtx
name|dst
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CALL
condition|)
comment|/* We don't need to worry about the result registers that        get written by subroutine call.  */
return|return
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
comment|/* X is a conditional branch.  */
comment|/* ??? This seems redundant, as the caller sets this bit for 	 all JUMP_INSNs.  */
if|if
condition|(
operator|!
name|ia64_spec_check_src_p
argument_list|(
name|src
argument_list|)
condition|)
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
return|return
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
block|}
if|if
condition|(
name|ia64_spec_check_src_p
argument_list|(
name|src
argument_list|)
condition|)
comment|/* Avoid checking one register twice (in condition         and in 'then' section) for ldc pattern.  */
block|{
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* We process MEM below.  */
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Handle an access to rtx X of type FLAGS using predicate register    PRED.  Return 1 if this access creates a dependency with an earlier    instruction in the same group.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_needs_barrier
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|is_complemented
init|=
literal|0
decl_stmt|;
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|struct
name|reg_flags
name|new_flags
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|new_flags
operator|=
name|flags
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|update_set_flags
argument_list|(
name|x
argument_list|,
operator|&
name|new_flags
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|set_src_needs_barrier
argument_list|(
name|x
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CALL
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CALL
case|:
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_EC_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* Avoid multiple register writes, in case this is a pattern with 	 multiple CALL rtx.  This avoids a failure in rws_access_reg.  */
if|if
condition|(
operator|!
name|flags
operator|.
name|is_sibcall
operator|&&
operator|!
name|rws_insn
index|[
name|REG_AR_CFM
index|]
operator|.
name|write_count
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_RP
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COND_EXEC
case|:
comment|/* X is a predicated instruction.  */
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|cond
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|is_complemented
operator|=
literal|1
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
name|PR_REGS
argument_list|)
expr_stmt|;
name|pred
operator|=
name|REGNO
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complemented
condition|)
operator|++
name|pred
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
name|need_barrier
return|;
case|case
name|CLOBBER
case|:
case|case
name|USE
case|:
comment|/* Clobber& use are for earlier compiler-phases only.  */
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
comment|/* We always emit stop bits for traditional asms.  We emit stop bits 	 for volatile extended asms if TARGET_VOL_ASM_STOP is true.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS
operator|||
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|TARGET_VOL_ASM_STOP
operator|)
condition|)
block|{
comment|/* Avoid writing the register multiple times if we have multiple 	     asm outputs.  This avoids a failure in rws_access_reg.  */
if|if
condition|(
operator|!
name|rws_insn
index|[
name|REG_VOLATILE
index|]
operator|.
name|write_count
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|rws_access_regno
argument_list|(
name|REG_VOLATILE
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	 We cannot just fall through here since then we would be confused 	 by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	 traditional asms unlike their normal usage.  */
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|pat
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|update_set_flags
argument_list|(
name|pat
argument_list|,
operator|&
name|new_flags
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|set_src_needs_barrier
argument_list|(
name|pat
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
case|case
name|CALL
case|:
case|case
name|ASM_OPERANDS
case|:
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
case|case
name|RETURN
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|pat
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|CALL
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|RETURN
condition|)
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|AR_UNAT_REGNUM
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_UNAT_BIT_0
operator|+
name|i
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
else|else
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|x
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
comment|/* Find the regs used in memory address computation.  */
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
break|break;
comment|/* Operators with side-effects.  */
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_MODIFY
case|:
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle common unary and binary ops for efficiency.  */
case|case
name|COMPARE
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
case|case
name|POPCOUNT
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|VEC_SELECT
case|:
comment|/* VEC_SELECT's second argument is a PARALLEL with integers that 	 describe the elements selected.  On ia64, those integers are 	 always constants.  Avoid walking the PARALLEL so that we don't 	 get confused with "normal" parallels and then die.  */
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_LTOFF_DTPMOD
case|:
case|case
name|UNSPEC_LTOFF_DTPREL
case|:
case|case
name|UNSPEC_DTPREL
case|:
case|case
name|UNSPEC_LTOFF_TPREL
case|:
case|case
name|UNSPEC_TPREL
case|:
case|case
name|UNSPEC_PRED_REL_MUTEX
case|:
case|case
name|UNSPEC_PIC_CALL
case|:
case|case
name|UNSPEC_MF
case|:
case|case
name|UNSPEC_FETCHADD_ACQ
case|:
case|case
name|UNSPEC_BSP_VALUE
case|:
case|case
name|UNSPEC_FLUSHRS
case|:
case|case
name|UNSPEC_BUNDLE_SELECTOR
case|:
break|break;
case|case
name|UNSPEC_GR_SPILL
case|:
case|case
name|UNSPEC_GR_RESTORE
case|:
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bit
init|=
operator|(
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|63
decl_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GR_SPILL
operator|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_UNAT_BIT_0
operator|+
name|bit
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNSPEC_FR_SPILL
case|:
case|case
name|UNSPEC_FR_RESTORE
case|:
case|case
name|UNSPEC_GETF_EXP
case|:
case|case
name|UNSPEC_SETF_EXP
case|:
case|case
name|UNSPEC_ADDP4
case|:
case|case
name|UNSPEC_FR_SQRT_RECIP_APPROX
case|:
case|case
name|UNSPEC_LDA
case|:
case|case
name|UNSPEC_LDS
case|:
case|case
name|UNSPEC_LDSA
case|:
case|case
name|UNSPEC_CHKACLR
case|:
case|case
name|UNSPEC_CHKS
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_FR_RECIP_APPROX
case|:
case|case
name|UNSPEC_SHRP
case|:
case|case
name|UNSPEC_COPYSIGN
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_CMPXCHG_ACQ
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC_VOLATILE
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPECV_ALLOC
case|:
comment|/* Alloc must always be the first instruction of a group. 	     We force this by always returning true.  */
comment|/* ??? We might get better scheduling if we explicitly check for 	     input/local/output register dependencies, and modify the 	     scheduler so that alloc is always reordered to the start of 	     the current group.  We could then eliminate all of the 	     first_instruction code.  */
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|UNSPECV_SET_BSP
case|:
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNSPECV_BLOCKAGE
case|:
case|case
name|UNSPECV_INSN_GROUP_BARRIER
case|:
case|case
name|UNSPECV_BREAK
case|:
case|case
name|UNSPECV_PSAC_ALL
case|:
case|case
name|UNSPECV_PSAC_NORMAL
case|:
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|RETURN
case|:
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_regno
argument_list|(
name|REG_RP
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_EC_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
default|default:
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* unused field */
case|case
literal|'i'
case|:
comment|/* integer */
case|case
literal|'n'
case|:
comment|/* note */
case|case
literal|'w'
case|:
comment|/* wide integer */
case|case
literal|'s'
case|:
comment|/* pointer to string */
case|case
literal|'S'
case|:
comment|/* optional pointer to string */
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Clear out the state for group_barrier_needed at the start of a    sequence of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_insn_group_barriers
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|rws_sum
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_sum
argument_list|)
argument_list|)
expr_stmt|;
name|first_instruction
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the current state, determine whether a group barrier (a stop bit) is    necessary before INSN.  Return nonzero if so.  This modifies the state to    include the effects of INSN as a side-effect.  */
end_comment

begin_function
specifier|static
name|int
name|group_barrier_needed
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|memset
argument_list|(
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
break|break;
case|case
name|BARRIER
case|:
comment|/* A barrier doesn't imply an instruction group boundary.  */
break|break;
case|case
name|CODE_LABEL
case|:
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CALL_INSN
case|:
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
name|flags
operator|.
name|is_sibcall
operator|=
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't bundle a call following another call.  */
if|if
condition|(
operator|(
name|pat
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
operator|!
name|ia64_spec_check_p
argument_list|(
name|insn
argument_list|)
condition|)
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
comment|/* Don't bundle a jump following a call.  */
if|if
condition|(
operator|(
name|pat
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
comment|/* Don't care about USE and CLOBBER "insns"---those are used to 	   indicate to the optimizer that it shouldn't get rid of 	   certain operations.  */
break|break;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Ug.  Hack hacks hacked elsewhere.  */
switch|switch
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* We play dependency tricks with the epilogue in order 	     to get proper schedules.  Undo this for dv analysis.  */
case|case
name|CODE_FOR_epilogue_deallocate_stack
case|:
case|case
name|CODE_FOR_prologue_allocate_stack
case|:
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* The pattern we use for br.cloop confuses the code above. 	     The second element of the vector is representative.  */
case|case
name|CODE_FOR_doloop_end_internal
case|:
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* Doesn't generate code.  */
case|case
name|CODE_FOR_pred_rel_mutex
case|:
case|case
name|CODE_FOR_prologue_use
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see if the previous instruction was a volatile 	 asm.  */
if|if
condition|(
operator|!
name|need_barrier
condition|)
name|need_barrier
operator|=
name|rws_access_regno
argument_list|(
name|REG_VOLATILE
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|first_instruction
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|need_barrier
operator|=
literal|0
expr_stmt|;
name|first_instruction
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Like group_barrier_needed, but do not clobber the current state.  */
end_comment

begin_function
specifier|static
name|int
name|safe_group_barrier_needed
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|reg_write_state
name|rws_saved
index|[
name|NUM_REGS
index|]
decl_stmt|;
name|int
name|saved_first_instruction
decl_stmt|;
name|int
name|t
decl_stmt|;
name|memcpy
argument_list|(
name|rws_saved
argument_list|,
name|rws_sum
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
expr|*
name|rws_saved
argument_list|)
expr_stmt|;
name|saved_first_instruction
operator|=
name|first_instruction
expr_stmt|;
name|t
operator|=
name|group_barrier_needed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rws_sum
argument_list|,
name|rws_saved
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
expr|*
name|rws_saved
argument_list|)
expr_stmt|;
name|first_instruction
operator|=
name|saved_first_instruction
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Scan the current function and insert stop bits as necessary to    eliminate dependencies.  This function assumes that a final    instruction scheduling pass has been run which has already    inserted most of the necessary stop bits.  This function only    inserts new ones at basic block boundaries, since these are    invisible to the scheduler.  */
end_comment

begin_function
specifier|static
name|void
name|emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last_label
init|=
literal|0
decl_stmt|;
name|int
name|insns_since_last_label
init|=
literal|0
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|insns_since_last_label
condition|)
name|last_label
operator|=
name|insn
expr_stmt|;
name|insns_since_last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
if|if
condition|(
name|insns_since_last_label
condition|)
name|last_label
operator|=
name|insn
expr_stmt|;
name|insns_since_last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_INSN_GROUP_BARRIER
condition|)
block|{
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insns_since_last_label
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|group_barrier_needed
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_label
condition|)
block|{
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"Emitting stop before label %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|last_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last_label
argument_list|)
expr_stmt|;
name|insn
operator|=
name|last_label
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|last_label
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like emit_insn_group_barriers, but run if no final scheduling pass was run.    This function has to emit all necessary group barriers.  */
end_comment

begin_function
specifier|static
name|void
name|emit_all_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|last
init|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
condition|)
name|emit_insn_after
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|group_barrier_needed
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|group_barrier_needed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction scheduling support.  */
end_comment

begin_define
define|#
directive|define
name|NR_BUNDLES
value|10
end_define

begin_comment
comment|/* A list of names of all available bundles.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bundle_name
index|[
name|NR_BUNDLES
index|]
init|=
block|{
literal|".mii"
block|,
literal|".mmi"
block|,
literal|".mfi"
block|,
literal|".mmf"
block|,
if|#
directive|if
name|NR_BUNDLES
operator|==
literal|10
literal|".bbb"
block|,
literal|".mbb"
block|,
endif|#
directive|endif
literal|".mib"
block|,
literal|".mmb"
block|,
literal|".mfb"
block|,
literal|".mlx"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should insert stop bits into the schedule.  */
end_comment

begin_decl_stmt
name|int
name|ia64_final_schedule
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Codes of the corresponding queried units: */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_0mii_
decl_stmt|,
name|_0mmi_
decl_stmt|,
name|_0mfi_
decl_stmt|,
name|_0mmf_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_0bbb_
decl_stmt|,
name|_0mbb_
decl_stmt|,
name|_0mib_
decl_stmt|,
name|_0mmb_
decl_stmt|,
name|_0mfb_
decl_stmt|,
name|_0mlx_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_1mii_
decl_stmt|,
name|_1mmi_
decl_stmt|,
name|_1mfi_
decl_stmt|,
name|_1mmf_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_1bbb_
decl_stmt|,
name|_1mbb_
decl_stmt|,
name|_1mib_
decl_stmt|,
name|_1mmb_
decl_stmt|,
name|_1mfb_
decl_stmt|,
name|_1mlx_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pos_1
decl_stmt|,
name|pos_2
decl_stmt|,
name|pos_3
decl_stmt|,
name|pos_4
decl_stmt|,
name|pos_5
decl_stmt|,
name|pos_6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is an insn group barrier.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dfa_stop_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is the last issued insn.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is size of the DFA state.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|dfa_state_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is pointer to a DFA state used as    temporary variable.  */
end_comment

begin_decl_stmt
specifier|static
name|state_t
name|temp_dfa_state
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is DFA state after issuing the last    insn.  */
end_comment

begin_decl_stmt
specifier|static
name|state_t
name|prev_cycle_state
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array element values are TRUE if the corresponding    insn requires to add stop bits before it.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stops_p
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array element values are ZERO for non-speculative    instructions and hold corresponding speculation check number for    speculative instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|spec_check_no
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of spec_check_no array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable is used to set up the mentioned above array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_before_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is length of the arrays `clocks' and    `add_cycles'. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clocks_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array element values are cycles on which the    corresponding insn will be issued.  The array is used only for    Itanium1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|clocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array element values are numbers of cycles should be    added to improve insn scheduling for MM_insns for Itanium1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|add_cycles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is number of data speculations in progress.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_data_specs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|ia64_single_set
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_emit_insn_before
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Map a bundle number to its pseudo-op.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_bundle_name
parameter_list|(
name|int
name|b
parameter_list|)
block|{
return|return
name|bundle_name
index|[
name|b
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum number of instructions a cpu can issue.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|6
return|;
block|}
end_function

begin_comment
comment|/* Helper function - like single_set, but look inside COND_EXEC.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_single_set
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
return|return
name|x
return|;
comment|/* Special case here prologue_allocate_stack and epilogue_deallocate_stack.      Although they are not classical single set, the second set is there just      to protect it from moving past FP-relative stack accesses.  */
switch|switch
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_FOR_prologue_allocate_stack
case|:
case|case
name|CODE_FOR_epilogue_deallocate_stack
case|:
name|ret
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|single_set_2
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Adjust the cost of a scheduling dependency.    Return the new cost of a dependency of type DEP_TYPE or INSN on DEP_INSN.    COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_adjust_cost_2
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|dep_type1
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|enum
name|reg_note
name|dep_type
init|=
operator|(
expr|enum
name|reg_note
operator|)
name|dep_type1
decl_stmt|;
name|enum
name|attr_itanium_class
name|dep_class
decl_stmt|;
name|enum
name|attr_itanium_class
name|insn_class
decl_stmt|;
if|if
condition|(
name|dep_type
operator|!=
name|REG_DEP_OUTPUT
condition|)
return|return
name|cost
return|;
name|insn_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep_class
operator|==
name|ITANIUM_CLASS_ST
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_STF
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_ST
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_STF
condition|)
return|return
literal|0
return|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Like emit_insn_before, but skip cycle_display notes.    ??? When cycle display notes are implemented, update this.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_emit_insn_before
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
name|emit_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function marks insns who produce addresses for load    and store insns.  Such insns will be placed into M slots because it    decrease latency time for Itanium1 (see function    `ia64_produce_address_p' and the DFA descriptions).  */
end_comment

begin_function
specifier|static
name|void
name|ia64_dependencies_evaluation_hook
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|,
name|next_tail
decl_stmt|;
comment|/* Before reload, which_alternative is not set, which means that      ia64_safe_itanium_class will produce wrong results for (at least)      move instructions.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|->
name|call
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|==
name|ITANIUM_CLASS_IALU
condition|)
block|{
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|enum
name|attr_itanium_class
name|c
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEP_TRUE
condition|)
continue|continue;
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|ITANIUM_CLASS_ST
operator|||
name|c
operator|==
name|ITANIUM_CLASS_STF
operator|)
operator|&&
name|ia64_st_address_bypass_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
name|ITANIUM_CLASS_LD
operator|||
name|c
operator|==
name|ITANIUM_CLASS_FLD
operator|||
name|c
operator|==
name|ITANIUM_CLASS_FLDP
operator|)
operator|&&
name|ia64_ld_address_bypass_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
break|break;
block|}
name|insn
operator|->
name|call
operator|=
name|link
operator|!=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We're beginning a new block.  Initialize data structures as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_init
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|max_ready
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|reload_completed
condition|)
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|current_sched_info
operator|->
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|current_sched_info
operator|->
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|gcc_assert
argument_list|(
operator|!
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_scheduled_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're beginning a scheduling pass.  Check assertion.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_init_global
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|max_ready
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|pending_data_specs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scheduling pass is now finished.  Free/reset static variable.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_finish_global
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|free
argument_list|(
name|spec_check_no
argument_list|)
expr_stmt|;
name|spec_check_no
operator|=
literal|0
expr_stmt|;
name|max_uid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are about to being issuing insns for this clock cycle.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_dfa_sched_reorder
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|pn_ready
parameter_list|,
name|int
name|clock_var
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|reorder_type
parameter_list|)
block|{
name|int
name|n_asms
decl_stmt|;
name|int
name|n_ready
init|=
operator|*
name|pn_ready
decl_stmt|;
name|rtx
modifier|*
name|e_ready
init|=
name|ready
operator|+
name|n_ready
decl_stmt|;
name|rtx
modifier|*
name|insnp
decl_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// ia64_dfa_sched_reorder (type %d):\n"
argument_list|,
name|reorder_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reorder_type
operator|==
literal|0
condition|)
block|{
comment|/* First, move all USEs, CLOBBERs and other crud out of the way.  */
name|n_asms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insnp
operator|=
name|ready
init|;
name|insnp
operator|<
name|e_ready
condition|;
name|insnp
operator|++
control|)
if|if
condition|(
name|insnp
operator|<
name|e_ready
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
name|enum
name|attr_type
name|t
init|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TYPE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|lowest
init|=
name|ready
index|[
name|n_asms
index|]
decl_stmt|;
name|ready
index|[
name|n_asms
index|]
operator|=
name|insn
expr_stmt|;
operator|*
name|insnp
operator|=
name|lowest
expr_stmt|;
name|n_asms
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|highest
init|=
name|ready
index|[
name|n_ready
operator|-
literal|1
index|]
decl_stmt|;
name|ready
index|[
name|n_ready
operator|-
literal|1
index|]
operator|=
name|insn
expr_stmt|;
operator|*
name|insnp
operator|=
name|highest
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|n_asms
operator|<
name|n_ready
condition|)
block|{
comment|/* Some normal insns to process.  Skip the asms.  */
name|ready
operator|+=
name|n_asms
expr_stmt|;
name|n_ready
operator|-=
name|n_asms
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_ready
operator|>
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ia64_final_schedule
condition|)
block|{
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|int
name|nr_need_stop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insnp
operator|=
name|ready
init|;
name|insnp
operator|<
name|e_ready
condition|;
name|insnp
operator|++
control|)
if|if
condition|(
name|safe_group_barrier_needed
argument_list|(
operator|*
name|insnp
argument_list|)
condition|)
name|nr_need_stop
operator|++
expr_stmt|;
if|if
condition|(
name|reorder_type
operator|==
literal|1
operator|&&
name|n_ready
operator|==
name|nr_need_stop
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reorder_type
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|insnp
operator|=
name|e_ready
expr_stmt|;
comment|/* Move down everything that needs a stop bit, preserving 	 relative order.  */
while|while
condition|(
name|insnp
operator|--
operator|>
name|ready
operator|+
name|deleted
condition|)
while|while
condition|(
name|insnp
operator|>=
name|ready
operator|+
name|deleted
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
if|if
condition|(
operator|!
name|safe_group_barrier_needed
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
name|memmove
argument_list|(
name|ready
operator|+
literal|1
argument_list|,
name|ready
argument_list|,
operator|(
name|insnp
operator|-
name|ready
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ready
operator|=
name|insn
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
block|}
name|n_ready
operator|-=
name|deleted
expr_stmt|;
name|ready
operator|+=
name|deleted
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We are about to being issuing insns for this clock cycle.  Override    the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_sched_reorder
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|pn_ready
parameter_list|,
name|int
name|clock_var
parameter_list|)
block|{
return|return
name|ia64_dfa_sched_reorder
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|pn_ready
argument_list|,
name|clock_var
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ia64_sched_reorder, but called after issuing each insn.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_sched_reorder2
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|pn_ready
parameter_list|,
name|int
name|clock_var
parameter_list|)
block|{
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
operator|&&
name|reload_completed
operator|&&
name|last_scheduled_insn
condition|)
name|clocks
index|[
name|INSN_UID
argument_list|(
name|last_scheduled_insn
argument_list|)
index|]
operator|=
name|clock_var
expr_stmt|;
return|return
name|ia64_dfa_sched_reorder
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|pn_ready
argument_list|,
name|clock_var
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We are about to issue INSN.  Return the number of insns left on the    ready queue that can be issued this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_variable_issue
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|can_issue_more
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
comment|/* Modulo scheduling does not extend h_i_d when emitting        new instructions.  Deal with it.  */
block|{
if|if
condition|(
name|DONE_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BEGIN_DATA
condition|)
name|pending_data_specs
operator|++
expr_stmt|;
if|if
condition|(
name|CHECK_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BEGIN_DATA
condition|)
name|pending_data_specs
operator|--
expr_stmt|;
block|}
name|last_scheduled_insn
operator|=
name|insn
expr_stmt|;
name|memcpy
argument_list|(
name|prev_cycle_state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
condition|)
block|{
name|int
name|needed
init|=
name|group_barrier_needed
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|stops_p
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|stop_before_p
expr_stmt|;
name|stop_before_p
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We are choosing insn from the ready queue.  Return nonzero if INSN    can be chosen.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead_guard
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|!
name|reload_completed
operator|||
operator|!
name|safe_group_barrier_needed
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|ia64_first_cycle_multipass_dfa_lookahead_guard_spec
argument_list|(
name|insn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We are choosing insn from the ready queue.  Return nonzero if INSN    can be chosen.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_first_cycle_multipass_dfa_lookahead_guard_spec
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Size of ALAT is 32.  As far as we perform conservative data speculation,      we keep ALAT half-empty.  */
return|return
operator|(
name|pending_data_specs
operator|<
literal|16
operator|||
operator|!
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BEGIN_DATA
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is pseudo-insn used by the DFA insn    scheduler to change the DFA state when the simulated clock is    increased.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dfa_pre_cycle_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We are about to being issuing INSN.  Return nonzero if we cannot    issue it on given cycle CLOCK and return zero if we should not sort    the ready queue on the next clock start.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_dfa_new_cycle
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|verbose
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|last_clock
parameter_list|,
name|int
name|clock
parameter_list|,
name|int
modifier|*
name|sort_p
parameter_list|)
block|{
name|int
name|setup_clocks_p
init|=
name|FALSE
decl_stmt|;
name|gcc_assert
argument_list|(
name|insn
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reload_completed
operator|&&
name|safe_group_barrier_needed
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|last_scheduled_insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|)
condition|)
block|{
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    Stop should be before %d%s\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|last_clock
operator|==
name|clock
condition|?
literal|" + cycle advance"
else|:
literal|""
argument_list|)
expr_stmt|;
name|stop_before_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|last_clock
operator|==
name|clock
condition|)
block|{
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|dfa_stop_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EARLY_STOP_BITS
condition|)
operator|*
name|sort_p
operator|=
operator|(
name|last_scheduled_insn
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|!=
name|CALL_INSN
operator|)
expr_stmt|;
else|else
operator|*
name|sort_p
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|reload_completed
condition|)
name|setup_clocks_p
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|state_reset
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|prev_cycle_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|dfa_stop_insn
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|dfa_pre_cycle_insn
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reload_completed
condition|)
name|setup_clocks_p
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|setup_clocks_p
operator|&&
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|enum
name|attr_itanium_class
name|c
init|=
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|ITANIUM_CLASS_MMMUL
operator|&&
name|c
operator|!=
name|ITANIUM_CLASS_MMSHF
condition|)
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|d
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enum
name|attr_itanium_class
name|dep_class
decl_stmt|;
name|rtx
name|dep_insn
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dep_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dep_class
operator|==
name|ITANIUM_CLASS_MMMUL
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_MMSHF
operator|)
operator|&&
name|last_clock
operator|-
name|clocks
index|[
name|INSN_UID
argument_list|(
name|dep_insn
argument_list|)
index|]
operator|<
literal|4
operator|&&
operator|(
name|d
operator|<
literal|0
operator|||
name|last_clock
operator|-
name|clocks
index|[
name|INSN_UID
argument_list|(
name|dep_insn
argument_list|)
index|]
operator|<
name|d
operator|)
condition|)
name|d
operator|=
name|last_clock
operator|-
name|clocks
index|[
name|INSN_UID
argument_list|(
name|dep_insn
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|>=
literal|0
condition|)
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
literal|3
operator|-
name|d
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implement targetm.sched.h_i_d_extended hook.    Extend internal data structures.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_h_i_d_extended
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
block|{
name|int
name|new_max_uid
init|=
name|get_max_uid
argument_list|()
operator|+
literal|1
decl_stmt|;
name|spec_check_no
operator|=
name|xrecalloc
argument_list|(
name|spec_check_no
argument_list|,
name|new_max_uid
argument_list|,
name|max_uid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spec_check_no
argument_list|)
argument_list|)
expr_stmt|;
name|max_uid
operator|=
name|new_max_uid
expr_stmt|;
block|}
if|if
condition|(
name|stops_p
operator|!=
name|NULL
condition|)
block|{
name|int
name|new_clocks_length
init|=
name|get_max_uid
argument_list|()
operator|+
literal|1
decl_stmt|;
name|stops_p
operator|=
name|xrecalloc
argument_list|(
name|stops_p
argument_list|,
name|new_clocks_length
argument_list|,
name|clocks_length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|)
block|{
name|clocks
operator|=
name|xrecalloc
argument_list|(
name|clocks
argument_list|,
name|new_clocks_length
argument_list|,
name|clocks_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|add_cycles
operator|=
name|xrecalloc
argument_list|(
name|add_cycles
argument_list|,
name|new_clocks_length
argument_list|,
name|clocks_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clocks_length
operator|=
name|new_clocks_length
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Constants that help mapping 'enum machine_mode' to int.  */
end_comment

begin_enum
enum|enum
name|SPEC_MODES
block|{
name|SPEC_MODE_INVALID
init|=
operator|-
literal|1
block|,
name|SPEC_MODE_FIRST
init|=
literal|0
block|,
name|SPEC_MODE_FOR_EXTEND_FIRST
init|=
literal|1
block|,
name|SPEC_MODE_FOR_EXTEND_LAST
init|=
literal|3
block|,
name|SPEC_MODE_LAST
init|=
literal|8
block|}
enum|;
end_enum

begin_comment
comment|/* Return index of the MODE.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_mode_to_int
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|BImode
case|:
return|return
literal|0
return|;
comment|/* SPEC_MODE_FIRST  */
case|case
name|QImode
case|:
return|return
literal|1
return|;
comment|/* SPEC_MODE_FOR_EXTEND_FIRST  */
case|case
name|HImode
case|:
return|return
literal|2
return|;
case|case
name|SImode
case|:
return|return
literal|3
return|;
comment|/* SPEC_MODE_FOR_EXTEND_LAST  */
case|case
name|DImode
case|:
return|return
literal|4
return|;
case|case
name|SFmode
case|:
return|return
literal|5
return|;
case|case
name|DFmode
case|:
return|return
literal|6
return|;
case|case
name|XFmode
case|:
return|return
literal|7
return|;
case|case
name|TImode
case|:
comment|/* ??? This mode needs testing.  Bypasses for ldfp8 instruction are not 	 mentioned in itanium[12].md.  Predicate fp_register_operand also 	 needs to be defined.  Bottom line: better disable for now.  */
return|return
name|SPEC_MODE_INVALID
return|;
default|default:
return|return
name|SPEC_MODE_INVALID
return|;
block|}
block|}
end_function

begin_comment
comment|/* Provide information about speculation capabilities.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_set_sched_flags
parameter_list|(
name|spec_info_t
name|spec_info
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|flags
init|=
operator|&
operator|(
name|current_sched_info
operator|->
name|flags
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|SCHED_RGN
operator|||
operator|*
name|flags
operator|&
name|SCHED_EBB
condition|)
block|{
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|mflag_sched_br_data_spec
operator|&&
operator|!
name|reload_completed
operator|&&
name|optimize
operator|>
literal|0
operator|)
operator|||
operator|(
name|mflag_sched_ar_data_spec
operator|&&
name|reload_completed
operator|)
condition|)
block|{
name|mask
operator||=
name|BEGIN_DATA
expr_stmt|;
if|if
condition|(
operator|(
name|mflag_sched_br_in_data_spec
operator|&&
operator|!
name|reload_completed
operator|)
operator|||
operator|(
name|mflag_sched_ar_in_data_spec
operator|&&
name|reload_completed
operator|)
condition|)
name|mask
operator||=
name|BE_IN_DATA
expr_stmt|;
block|}
if|if
condition|(
name|mflag_sched_control_spec
condition|)
block|{
name|mask
operator||=
name|BEGIN_CONTROL
expr_stmt|;
if|if
condition|(
name|mflag_sched_in_control_spec
condition|)
name|mask
operator||=
name|BE_IN_CONTROL
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|*
name|flags
operator|&
name|USE_GLAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
operator|*
name|flags
operator||=
name|USE_DEPS_LIST
operator||
name|DETACH_LIFE_INFO
operator||
name|DO_SPECULATION
expr_stmt|;
name|spec_info
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|spec_info
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|DATA_SPEC
operator|)
operator|&&
name|mflag_sched_prefer_non_data_spec_insns
condition|)
name|spec_info
operator|->
name|flags
operator||=
name|PREFER_NON_DATA_SPEC
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|CONTROL_SPEC
operator|)
operator|&&
name|mflag_sched_prefer_non_control_spec_insns
condition|)
name|spec_info
operator|->
name|flags
operator||=
name|PREFER_NON_CONTROL_SPEC
expr_stmt|;
if|if
condition|(
name|mflag_sched_spec_verbose
condition|)
block|{
if|if
condition|(
name|sched_verbose
operator|>=
literal|1
condition|)
name|spec_info
operator|->
name|dump
operator|=
name|sched_dump
expr_stmt|;
else|else
name|spec_info
operator|->
name|dump
operator|=
name|stderr
expr_stmt|;
block|}
else|else
name|spec_info
operator|->
name|dump
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mflag_sched_count_spec_in_critical_path
condition|)
name|spec_info
operator|->
name|flags
operator||=
name|COUNT_SPEC_IN_CRITICAL_PATH
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Implement targetm.sched.speculate_insn hook.    Check if the INSN can be TS speculative.    If 'no' - return -1.    If 'yes' - generate speculative pattern in the NEW_PAT and return 1.    If current pattern of the INSN already provides TS speculation, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_speculate_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|ds_t
name|ts
parameter_list|,
name|rtx
modifier|*
name|new_pat
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|,
name|mem_reg
decl_stmt|;
name|int
name|mode_no
decl_stmt|,
name|gen_p
init|=
literal|1
decl_stmt|;
name|bool
name|extend_p
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|ts
operator|&
operator|~
name|BEGIN_SPEC
operator|)
operator|&&
name|ts
argument_list|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|pat
operator|=
name|COND_EXEC_CODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* This should be a SET ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
return|return
operator|-
literal|1
return|;
name|reg
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* ... to the general/fp register ...  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|||
operator|!
operator|(
name|GR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|||
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* ... from the mem ...  */
name|mem
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* ... that can, possibly, be a zero_extend ...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
block|{
name|mem
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|extend_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|extend_p
operator|=
name|false
expr_stmt|;
comment|/* ... or a speculative load.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|XINT
argument_list|(
name|mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|UNSPEC_LDA
operator|&&
name|code
operator|!=
name|UNSPEC_LDS
operator|&&
name|code
operator|!=
name|UNSPEC_LDSA
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|UNSPEC_LDA
operator|&&
operator|!
operator|(
name|ts
operator|&
name|BEGIN_CONTROL
operator|)
operator|)
operator|||
operator|(
name|code
operator|==
name|UNSPEC_LDS
operator|&&
operator|!
operator|(
name|ts
operator|&
name|BEGIN_DATA
operator|)
operator|)
operator|||
name|code
operator|==
name|UNSPEC_LDSA
condition|)
name|gen_p
operator|=
literal|0
expr_stmt|;
name|mem
operator|=
name|XVECEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Source should be a mem ...  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* ... addressed by a register.  */
name|mem_reg
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|mem_reg
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We should use MEM's mode since REG's mode in presence of ZERO_EXTEND      will always be DImode.  */
name|mode_no
operator|=
name|ia64_mode_to_int
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_no
operator|==
name|SPEC_MODE_INVALID
operator|||
operator|(
name|extend_p
operator|&&
operator|!
operator|(
name|SPEC_MODE_FOR_EXTEND_FIRST
operator|<=
name|mode_no
operator|&&
name|mode_no
operator|<=
name|SPEC_MODE_FOR_EXTEND_LAST
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|reg
operator|==
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
operator|&&
name|mem
operator|==
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|new_pat
operator|=
name|ia64_gen_spec_insn
argument_list|(
name|insn
argument_list|,
name|ts
argument_list|,
name|mode_no
argument_list|,
name|gen_p
operator|!=
literal|0
argument_list|,
name|extend_p
argument_list|)
expr_stmt|;
return|return
name|gen_p
return|;
block|}
end_function

begin_enum
enum|enum
block|{
comment|/* Offset to reach ZERO_EXTEND patterns.  */
name|SPEC_GEN_EXTEND_OFFSET
init|=
name|SPEC_MODE_LAST
operator|-
name|SPEC_MODE_FOR_EXTEND_FIRST
operator|+
literal|1
block|,
comment|/* Number of patterns for each speculation mode.  */
name|SPEC_N
init|=
operator|(
name|SPEC_MODE_LAST
operator|+
name|SPEC_MODE_FOR_EXTEND_LAST
operator|-
name|SPEC_MODE_FOR_EXTEND_FIRST
operator|+
literal|2
operator|)
block|}
enum|;
end_enum

begin_enum
enum|enum
name|SPEC_GEN_LD_MAP
block|{
comment|/* Offset to ld.a patterns.  */
name|SPEC_GEN_A
init|=
literal|0
operator|*
name|SPEC_N
block|,
comment|/* Offset to ld.s patterns.  */
name|SPEC_GEN_S
init|=
literal|1
operator|*
name|SPEC_N
block|,
comment|/* Offset to ld.sa patterns.  */
name|SPEC_GEN_SA
init|=
literal|2
operator|*
name|SPEC_N
block|,
comment|/* Offset to ld.sa patterns.  For this patterns corresponding ld.c will        mutate to chk.s.  */
name|SPEC_GEN_SA_FOR_S
init|=
literal|3
operator|*
name|SPEC_N
block|}
enum|;
end_enum

begin_comment
comment|/* These offsets are used to get (4 * SPEC_N).  */
end_comment

begin_enum
enum|enum
name|SPEC_GEN_CHECK_OFFSET
block|{
name|SPEC_GEN_CHKA_FOR_A_OFFSET
init|=
literal|4
operator|*
name|SPEC_N
operator|-
name|SPEC_GEN_A
block|,
name|SPEC_GEN_CHKA_FOR_SA_OFFSET
init|=
literal|4
operator|*
name|SPEC_N
operator|-
name|SPEC_GEN_SA
block|}
enum|;
end_enum

begin_comment
comment|/* If GEN_P is true, calculate the index of needed speculation check and return    speculative pattern for INSN with speculative mode TS, machine mode    MODE_NO and with ZERO_EXTEND (if EXTEND_P is true).    If GEN_P is false, just calculate the index of needed speculation check.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_gen_spec_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|ds_t
name|ts
parameter_list|,
name|int
name|mode_no
parameter_list|,
name|bool
name|gen_p
parameter_list|,
name|bool
name|extend_p
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|new_pat
decl_stmt|;
name|int
name|load_no
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
specifier|static
name|rtx
argument_list|(
operator|*
specifier|const
name|gen_load
index|[]
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|rtx
argument_list|)
operator|=
block|{
name|gen_movbi_advanced
block|,
name|gen_movqi_advanced
block|,
name|gen_movhi_advanced
block|,
name|gen_movsi_advanced
block|,
name|gen_movdi_advanced
block|,
name|gen_movsf_advanced
block|,
name|gen_movdf_advanced
block|,
name|gen_movxf_advanced
block|,
name|gen_movti_advanced
block|,
name|gen_zero_extendqidi2_advanced
block|,
name|gen_zero_extendhidi2_advanced
block|,
name|gen_zero_extendsidi2_advanced
block|,
name|gen_movbi_speculative
block|,
name|gen_movqi_speculative
block|,
name|gen_movhi_speculative
block|,
name|gen_movsi_speculative
block|,
name|gen_movdi_speculative
block|,
name|gen_movsf_speculative
block|,
name|gen_movdf_speculative
block|,
name|gen_movxf_speculative
block|,
name|gen_movti_speculative
block|,
name|gen_zero_extendqidi2_speculative
block|,
name|gen_zero_extendhidi2_speculative
block|,
name|gen_zero_extendsidi2_speculative
block|,
name|gen_movbi_speculative_advanced
block|,
name|gen_movqi_speculative_advanced
block|,
name|gen_movhi_speculative_advanced
block|,
name|gen_movsi_speculative_advanced
block|,
name|gen_movdi_speculative_advanced
block|,
name|gen_movsf_speculative_advanced
block|,
name|gen_movdf_speculative_advanced
block|,
name|gen_movxf_speculative_advanced
block|,
name|gen_movti_speculative_advanced
block|,
name|gen_zero_extendqidi2_speculative_advanced
block|,
name|gen_zero_extendhidi2_speculative_advanced
block|,
name|gen_zero_extendsidi2_speculative_advanced
block|,
name|gen_movbi_speculative_advanced
block|,
name|gen_movqi_speculative_advanced
block|,
name|gen_movhi_speculative_advanced
block|,
name|gen_movsi_speculative_advanced
block|,
name|gen_movdi_speculative_advanced
block|,
name|gen_movsf_speculative_advanced
block|,
name|gen_movdf_speculative_advanced
block|,
name|gen_movxf_speculative_advanced
block|,
name|gen_movti_speculative_advanced
block|,
name|gen_zero_extendqidi2_speculative_advanced
block|,
name|gen_zero_extendhidi2_speculative_advanced
block|,
name|gen_zero_extendsidi2_speculative_advanced
block|}
expr_stmt|;
name|load_no
operator|=
name|extend_p
condition|?
name|mode_no
operator|+
name|SPEC_GEN_EXTEND_OFFSET
else|:
name|mode_no
expr_stmt|;
if|if
condition|(
name|ts
operator|&
name|BEGIN_DATA
condition|)
block|{
comment|/* We don't need recovery because even if this is ld.sa 	 ALAT entry will be allocated only if NAT bit is set to zero.  	 So it is enough to use ld.c here.  */
if|if
condition|(
name|ts
operator|&
name|BEGIN_CONTROL
condition|)
block|{
name|load_no
operator|+=
name|SPEC_GEN_SA
expr_stmt|;
if|if
condition|(
operator|!
name|mflag_sched_ldc
condition|)
name|shift
operator|=
name|SPEC_GEN_CHKA_FOR_SA_OFFSET
expr_stmt|;
block|}
else|else
block|{
name|load_no
operator|+=
name|SPEC_GEN_A
expr_stmt|;
if|if
condition|(
operator|!
name|mflag_sched_ldc
condition|)
name|shift
operator|=
name|SPEC_GEN_CHKA_FOR_A_OFFSET
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ts
operator|&
name|BEGIN_CONTROL
condition|)
block|{
comment|/* ld.sa can be used instead of ld.s to avoid basic block splitting.  */
if|if
condition|(
operator|!
name|mflag_control_ldc
condition|)
name|load_no
operator|+=
name|SPEC_GEN_S
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|mflag_sched_ldc
argument_list|)
expr_stmt|;
name|load_no
operator|+=
name|SPEC_GEN_SA_FOR_S
expr_stmt|;
block|}
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Set the desired check index.  We add '1', because zero element in this      array means, that instruction with such uid is non-speculative.  */
name|spec_check_no
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|load_no
operator|+
name|shift
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|gen_p
condition|)
return|return
literal|0
return|;
name|new_pat
operator|=
name|gen_load
index|[
name|load_no
index|]
operator|(
name|copy_rtx
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
operator|,
name|copy_rtx
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
argument_list|)
operator|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|new_pat
operator|=
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|,
name|new_pat
argument_list|)
expr_stmt|;
return|return
name|new_pat
return|;
block|}
end_function

begin_comment
comment|/* Offset to branchy checks.  */
end_comment

begin_enum
enum|enum
block|{
name|SPEC_GEN_CHECK_MUTATION_OFFSET
init|=
literal|5
operator|*
name|SPEC_N
block|}
enum|;
end_enum

begin_comment
comment|/* Return nonzero, if INSN needs branchy recovery check.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_needs_block_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|check_no
decl_stmt|;
name|check_no
operator|=
name|spec_check_no
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|-
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
literal|0
operator|<=
name|check_no
operator|&&
name|check_no
operator|<
name|SPEC_GEN_CHECK_MUTATION_OFFSET
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|SPEC_GEN_S
operator|<=
name|check_no
operator|&&
name|check_no
operator|<
name|SPEC_GEN_S
operator|+
name|SPEC_N
operator|)
operator|||
operator|(
literal|4
operator|*
name|SPEC_N
operator|<=
name|check_no
operator|&&
name|check_no
operator|<
literal|4
operator|*
name|SPEC_N
operator|+
name|SPEC_N
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate (or regenerate, if (MUTATE_P)) recovery check for INSN.    If (LABEL != 0 || MUTATE_P), generate branchy recovery check.    Otherwise, generate a simple check.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_gen_check
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|label
parameter_list|,
name|bool
name|mutate_p
parameter_list|)
block|{
name|rtx
name|op1
decl_stmt|,
name|pat
decl_stmt|,
name|check_pat
decl_stmt|;
specifier|static
name|rtx
argument_list|(
operator|*
specifier|const
name|gen_check
index|[]
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|rtx
argument_list|)
operator|=
block|{
name|gen_movbi_clr
block|,
name|gen_movqi_clr
block|,
name|gen_movhi_clr
block|,
name|gen_movsi_clr
block|,
name|gen_movdi_clr
block|,
name|gen_movsf_clr
block|,
name|gen_movdf_clr
block|,
name|gen_movxf_clr
block|,
name|gen_movti_clr
block|,
name|gen_zero_extendqidi2_clr
block|,
name|gen_zero_extendhidi2_clr
block|,
name|gen_zero_extendsidi2_clr
block|,
name|gen_speculation_check_bi
block|,
name|gen_speculation_check_qi
block|,
name|gen_speculation_check_hi
block|,
name|gen_speculation_check_si
block|,
name|gen_speculation_check_di
block|,
name|gen_speculation_check_sf
block|,
name|gen_speculation_check_df
block|,
name|gen_speculation_check_xf
block|,
name|gen_speculation_check_ti
block|,
name|gen_speculation_check_di
block|,
name|gen_speculation_check_di
block|,
name|gen_speculation_check_di
block|,
name|gen_movbi_clr
block|,
name|gen_movqi_clr
block|,
name|gen_movhi_clr
block|,
name|gen_movsi_clr
block|,
name|gen_movdi_clr
block|,
name|gen_movsf_clr
block|,
name|gen_movdf_clr
block|,
name|gen_movxf_clr
block|,
name|gen_movti_clr
block|,
name|gen_zero_extendqidi2_clr
block|,
name|gen_zero_extendhidi2_clr
block|,
name|gen_zero_extendsidi2_clr
block|,
name|gen_movbi_clr
block|,
name|gen_movqi_clr
block|,
name|gen_movhi_clr
block|,
name|gen_movsi_clr
block|,
name|gen_movdi_clr
block|,
name|gen_movsf_clr
block|,
name|gen_movdf_clr
block|,
name|gen_movxf_clr
block|,
name|gen_movti_clr
block|,
name|gen_zero_extendqidi2_clr
block|,
name|gen_zero_extendhidi2_clr
block|,
name|gen_zero_extendsidi2_clr
block|,
name|gen_advanced_load_check_clr_bi
block|,
name|gen_advanced_load_check_clr_qi
block|,
name|gen_advanced_load_check_clr_hi
block|,
name|gen_advanced_load_check_clr_si
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_sf
block|,
name|gen_advanced_load_check_clr_df
block|,
name|gen_advanced_load_check_clr_xf
block|,
name|gen_advanced_load_check_clr_ti
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_di
block|,
comment|/* Following checks are generated during mutation.  */
name|gen_advanced_load_check_clr_bi
block|,
name|gen_advanced_load_check_clr_qi
block|,
name|gen_advanced_load_check_clr_hi
block|,
name|gen_advanced_load_check_clr_si
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_sf
block|,
name|gen_advanced_load_check_clr_df
block|,
name|gen_advanced_load_check_clr_xf
block|,
name|gen_advanced_load_check_clr_ti
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_di
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|gen_advanced_load_check_clr_bi
block|,
name|gen_advanced_load_check_clr_qi
block|,
name|gen_advanced_load_check_clr_hi
block|,
name|gen_advanced_load_check_clr_si
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_sf
block|,
name|gen_advanced_load_check_clr_df
block|,
name|gen_advanced_load_check_clr_xf
block|,
name|gen_advanced_load_check_clr_ti
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_advanced_load_check_clr_di
block|,
name|gen_speculation_check_bi
block|,
name|gen_speculation_check_qi
block|,
name|gen_speculation_check_hi
block|,
name|gen_speculation_check_si
block|,
name|gen_speculation_check_di
block|,
name|gen_speculation_check_sf
block|,
name|gen_speculation_check_df
block|,
name|gen_speculation_check_xf
block|,
name|gen_speculation_check_ti
block|,
name|gen_speculation_check_di
block|,
name|gen_speculation_check_di
block|,
name|gen_speculation_check_di
block|}
expr_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|gcc_assert
argument_list|(
name|mutate_p
operator|||
name|ia64_needs_block_p
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|label
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|mutate_p
operator|&&
operator|!
name|ia64_needs_block_p
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|copy_rtx
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mutate_p
condition|)
comment|/* INSN is ld.c.        Find the speculation check number by searching for original        speculative load in the RESOLVED_DEPS list of INSN.        As long as patterns are unique for each instruction, this can be        accomplished by matching ORIG_PAT fields.  */
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|check_no
init|=
literal|0
decl_stmt|;
name|rtx
name|orig_pat
init|=
name|ORIG_PAT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|link
operator|=
name|RESOLVED_DEPS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ORIG_PAT
argument_list|(
name|x
argument_list|)
operator|==
name|orig_pat
condition|)
name|check_no
operator|=
name|spec_check_no
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|check_no
argument_list|)
expr_stmt|;
name|spec_check_no
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
operator|(
name|check_no
operator|+
name|SPEC_GEN_CHECK_MUTATION_OFFSET
operator|)
expr_stmt|;
block|}
name|check_pat
operator|=
operator|(
name|gen_check
index|[
name|spec_check_no
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|-
literal|1
index|]
operator|(
name|copy_rtx
argument_list|(
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
argument_list|)
operator|,
name|op1
operator|)
operator|)
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|check_pat
operator|=
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|,
name|check_pat
argument_list|)
expr_stmt|;
return|return
name|check_pat
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero, if X is branchy recovery check.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_spec_check_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
return|return
name|ia64_spec_check_src_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero, if SRC belongs to recovery check.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_spec_check_src_p
parameter_list|(
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|rtx
name|t
decl_stmt|;
name|t
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NE
condition|)
block|{
name|t
operator|=
name|XEXP
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|XINT
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNSPEC_CHKACLR
operator|||
name|code
operator|==
name|UNSPEC_CHKS
operator|||
name|code
operator|==
name|UNSPEC_LDCCLR
condition|)
block|{
name|gcc_assert
argument_list|(
name|code
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following page contains abstract data `bundle states' which are    used for bundling insns (inserting nops and template generation).  */
end_comment

begin_comment
comment|/* The following describes state of insn bundling.  */
end_comment

begin_struct
struct|struct
name|bundle_state
block|{
comment|/* Unique bundle state number to identify them in the debugging      output  */
name|int
name|unique_num
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* corresponding insn, NULL for the 1st and the last state  */
comment|/* number nops before and after the insn  */
name|short
name|before_nops_num
decl_stmt|,
name|after_nops_num
decl_stmt|;
name|int
name|insn_num
decl_stmt|;
comment|/* insn number (0 - for initial state, 1 - for the 1st                    insn */
name|int
name|cost
decl_stmt|;
comment|/* cost of the state in cycles */
name|int
name|accumulated_insns_num
decl_stmt|;
comment|/* number of all previous insns including 				nops.  L is considered as 2 insns */
name|int
name|branch_deviation
decl_stmt|;
comment|/* deviation of previous branches from 3rd slots  */
name|struct
name|bundle_state
modifier|*
name|next
decl_stmt|;
comment|/* next state with the same insn_num  */
name|struct
name|bundle_state
modifier|*
name|originator
decl_stmt|;
comment|/* originator (previous insn state)  */
comment|/* All bundle states are in the following chain.  */
name|struct
name|bundle_state
modifier|*
name|allocated_states_chain
decl_stmt|;
comment|/* The DFA State after issuing the insn and the nops.  */
name|state_t
name|dfa_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following is map insn number to the corresponding bundle state.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bundle_state
modifier|*
modifier|*
name|index_to_bundle_states
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The unique number of next bundle state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bundle_states_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All allocated bundle states are in the following chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bundle_state
modifier|*
name|allocated_bundle_states_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All allocated but not used bundle states are in the following    chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bundle_state
modifier|*
name|free_bundle_state_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns a free bundle state.  */
end_comment

begin_function
specifier|static
name|struct
name|bundle_state
modifier|*
name|get_free_bundle_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|free_bundle_state_chain
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|free_bundle_state_chain
expr_stmt|;
name|free_bundle_state_chain
operator|=
name|result
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bundle_state
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|dfa_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
name|result
operator|->
name|allocated_states_chain
operator|=
name|allocated_bundle_states_chain
expr_stmt|;
name|allocated_bundle_states_chain
operator|=
name|result
expr_stmt|;
block|}
name|result
operator|->
name|unique_num
operator|=
name|bundle_states_num
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The following function frees given bundle state.  */
end_comment

begin_function
specifier|static
name|void
name|free_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|state
parameter_list|)
block|{
name|state
operator|->
name|next
operator|=
name|free_bundle_state_chain
expr_stmt|;
name|free_bundle_state_chain
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start work with abstract data `bundle states'.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_bundle_states
parameter_list|(
name|void
parameter_list|)
block|{
name|bundle_states_num
operator|=
literal|0
expr_stmt|;
name|free_bundle_state_chain
operator|=
name|NULL
expr_stmt|;
name|allocated_bundle_states_chain
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish work with abstract data `bundle states'.  */
end_comment

begin_function
specifier|static
name|void
name|finish_bundle_states
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|curr_state
decl_stmt|,
modifier|*
name|next_state
decl_stmt|;
for|for
control|(
name|curr_state
operator|=
name|allocated_bundle_states_chain
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|next_state
control|)
block|{
name|next_state
operator|=
name|curr_state
operator|->
name|allocated_states_chain
expr_stmt|;
name|free
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hash table of the bundle states.  The key is dfa_state and insn_num    of the bundle states.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|bundle_state_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function returns hash of BUNDLE_STATE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|bundle_state_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|bundle_state
parameter_list|)
block|{
specifier|const
name|struct
name|bundle_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
name|bundle_state
decl_stmt|;
name|unsigned
name|result
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|result
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa_state_size
condition|;
name|i
operator|++
control|)
name|result
operator|+=
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|state
operator|->
name|dfa_state
operator|)
index|[
name|i
index|]
operator|<<
operator|(
operator|(
name|i
operator|%
name|CHAR_BIT
operator|)
operator|*
literal|3
operator|+
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
return|return
name|result
operator|+
name|state
operator|->
name|insn_num
return|;
block|}
end_function

begin_comment
comment|/* The function returns nonzero if the bundle state keys are equal.  */
end_comment

begin_function
specifier|static
name|int
name|bundle_state_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|bundle_state_1
parameter_list|,
specifier|const
name|void
modifier|*
name|bundle_state_2
parameter_list|)
block|{
specifier|const
name|struct
name|bundle_state
modifier|*
name|state1
init|=
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
name|bundle_state_1
decl_stmt|;
specifier|const
name|struct
name|bundle_state
modifier|*
name|state2
init|=
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
name|bundle_state_2
decl_stmt|;
return|return
operator|(
name|state1
operator|->
name|insn_num
operator|==
name|state2
operator|->
name|insn_num
operator|&&
name|memcmp
argument_list|(
name|state1
operator|->
name|dfa_state
argument_list|,
name|state2
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The function inserts the BUNDLE_STATE into the hash table.  The    function returns nonzero if the bundle has been inserted into the    table.  The table contains the best bundle state with given key.  */
end_comment

begin_function
specifier|static
name|int
name|insert_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|bundle_state
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|bundle_state_table
argument_list|,
name|bundle_state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
block|{
name|bundle_state
operator|->
name|next
operator|=
name|index_to_bundle_states
index|[
name|bundle_state
operator|->
name|insn_num
index|]
expr_stmt|;
name|index_to_bundle_states
index|[
name|bundle_state
operator|->
name|insn_num
index|]
operator|=
name|bundle_state
expr_stmt|;
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|bundle_state
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|bundle_state
operator|->
name|cost
operator|<
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|cost
operator|||
operator|(
name|bundle_state
operator|->
name|cost
operator|==
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|cost
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|accumulated_insns_num
operator|>
name|bundle_state
operator|->
name|accumulated_insns_num
operator|||
operator|(
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|accumulated_insns_num
operator|==
name|bundle_state
operator|->
name|accumulated_insns_num
operator|&&
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|branch_deviation
operator|>
name|bundle_state
operator|->
name|branch_deviation
operator|)
operator|)
operator|)
condition|)
block|{
name|struct
name|bundle_state
name|temp
decl_stmt|;
name|temp
operator|=
operator|*
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
expr_stmt|;
operator|*
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|=
operator|*
name|bundle_state
expr_stmt|;
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|next
operator|=
name|temp
operator|.
name|next
expr_stmt|;
operator|*
name|bundle_state
operator|=
name|temp
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Start work with the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_bundle_state_table
parameter_list|(
name|void
parameter_list|)
block|{
name|bundle_state_table
operator|=
name|htab_create
argument_list|(
literal|50
argument_list|,
name|bundle_state_hash
argument_list|,
name|bundle_state_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish work with the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|finish_bundle_state_table
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|bundle_state_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable is a insn `nop' used to check bundle states    with different number of inserted nops.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|ia64_nop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function tries to issue NOPS_NUM nops for the current    state without advancing processor cycle.  If it failed, the    function returns FALSE and frees the current state.  */
end_comment

begin_function
specifier|static
name|int
name|try_issue_nops
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|curr_state
parameter_list|,
name|int
name|nops_num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|ia64_nop
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The following function tries to issue INSN for the current    state without advancing processor cycle.  If it failed, the    function returns FALSE and frees the current state.  */
end_comment

begin_function
specifier|static
name|int
name|try_issue_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|curr_state
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
operator|&&
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The following function tries to issue BEFORE_NOPS_NUM nops and INSN    starting with ORIGINATOR without advancing processor cycle.  If    TRY_BUNDLE_END_P is TRUE, the function also/only (if    ONLY_BUNDLE_END_P is TRUE) tries to issue nops to fill all bundle.    If it was successful, the function creates new bundle state and    insert into the hash table and into `index_to_bundle_states'.  */
end_comment

begin_function
specifier|static
name|void
name|issue_nops_and_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|originator
parameter_list|,
name|int
name|before_nops_num
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|try_bundle_end_p
parameter_list|,
name|int
name|only_bundle_end_p
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|curr_state
decl_stmt|;
name|curr_state
operator|=
name|get_free_bundle_state
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|originator
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|curr_state
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|curr_state
operator|->
name|insn_num
operator|=
name|originator
operator|->
name|insn_num
operator|+
literal|1
expr_stmt|;
name|curr_state
operator|->
name|cost
operator|=
name|originator
operator|->
name|cost
expr_stmt|;
name|curr_state
operator|->
name|originator
operator|=
name|originator
expr_stmt|;
name|curr_state
operator|->
name|before_nops_num
operator|=
name|before_nops_num
expr_stmt|;
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|=
name|originator
operator|->
name|accumulated_insns_num
operator|+
name|before_nops_num
expr_stmt|;
name|curr_state
operator|->
name|branch_deviation
operator|=
name|originator
operator|->
name|branch_deviation
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|TImode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
name|before_nops_num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|try_issue_insn
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
name|memcpy
argument_list|(
name|temp_dfa_state
argument_list|,
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_transition
argument_list|(
name|temp_dfa_state
argument_list|,
name|dfa_pre_cycle_insn
argument_list|)
operator|>=
literal|0
operator|&&
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|TImode
condition|)
block|{
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
name|before_nops_num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|try_issue_insn
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_L
condition|)
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If this is an insn that must be first in a group, then don't allow 	 nops to be emitted before it.  Currently, alloc is the only such 	 supported instruction.  */
comment|/* ??? The bundling automatons should handle this for us, but they do 	 not yet have support for the first_insn attribute.  */
if|if
condition|(
name|before_nops_num
operator|>
literal|0
operator|&&
name|get_attr_first_insn
argument_list|(
name|insn
argument_list|)
operator|==
name|FIRST_INSN_YES
condition|)
block|{
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return;
block|}
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|dfa_pre_cycle_insn
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curr_state
operator|->
name|cost
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
name|before_nops_num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|try_issue_insn
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Finish bundle containing asm insn.  */
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|+=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_L
condition|)
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_B
condition|)
name|curr_state
operator|->
name|branch_deviation
operator|+=
literal|2
operator|-
operator|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|-
literal|1
operator|)
operator|%
literal|3
expr_stmt|;
if|if
condition|(
name|try_bundle_end_p
operator|&&
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|only_bundle_end_p
operator|&&
name|insert_bundle_state
argument_list|(
name|curr_state
argument_list|)
condition|)
block|{
name|state_t
name|dfa_state
decl_stmt|;
name|struct
name|bundle_state
modifier|*
name|curr_state1
decl_stmt|;
name|struct
name|bundle_state
modifier|*
name|allocated_states_chain
decl_stmt|;
name|curr_state1
operator|=
name|get_free_bundle_state
argument_list|()
expr_stmt|;
name|dfa_state
operator|=
name|curr_state1
operator|->
name|dfa_state
expr_stmt|;
name|allocated_states_chain
operator|=
name|curr_state1
operator|->
name|allocated_states_chain
expr_stmt|;
operator|*
name|curr_state1
operator|=
operator|*
name|curr_state
expr_stmt|;
name|curr_state1
operator|->
name|dfa_state
operator|=
name|dfa_state
expr_stmt|;
name|curr_state1
operator|->
name|allocated_states_chain
operator|=
name|allocated_states_chain
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state1
operator|->
name|dfa_state
argument_list|,
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|curr_state
operator|=
name|curr_state1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
argument_list|)
condition|)
return|return;
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|+=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insert_bundle_state
argument_list|(
name|curr_state
argument_list|)
condition|)
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* The following function returns position in the two window bundle    for given STATE.  */
end_comment

begin_function
specifier|static
name|int
name|get_max_pos
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_6
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_5
argument_list|)
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_4
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_3
argument_list|)
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_2
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_1
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function returns code of a possible template for given position    and state.  The function should be called only with 2 values of    position equal to 3 or 6.  We avoid generating F NOPs by putting    templates containing F insns at the end of the template search    because undocumented anomaly in McKinley derived cores which can    cause stalls if an F-unit insn (including a NOP) is issued within a    six-cycle window after reading certain application registers (such    as ar.bsp).  Furthermore, power-considerations also argue against    the use of F-unit instructions unless they're really needed.  */
end_comment

begin_function
specifier|static
name|int
name|get_template
parameter_list|(
name|state_t
name|state
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mmi_
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mii_
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mmb_
argument_list|)
condition|)
return|return
literal|7
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mib_
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mbb_
argument_list|)
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0bbb_
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mmf_
argument_list|)
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mfi_
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mfb_
argument_list|)
condition|)
return|return
literal|8
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mlx_
argument_list|)
condition|)
return|return
literal|9
return|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
literal|6
case|:
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mmi_
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mii_
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mmb_
argument_list|)
condition|)
return|return
literal|7
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mib_
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mbb_
argument_list|)
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1bbb_
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|_1mmf_
operator|>=
literal|0
operator|&&
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mmf_
argument_list|)
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mfi_
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mfb_
argument_list|)
condition|)
return|return
literal|8
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mlx_
argument_list|)
condition|)
return|return
literal|9
return|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function returns an insn important for insn bundling    followed by INSN and before TAIL.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_next_important_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
for|for
control|(
init|;
name|insn
operator|&&
name|insn
operator|!=
name|tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
name|insn
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Add a bundle selector TEMPLATE0 before INSN.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_add_bundle_selector_before
parameter_list|(
name|int
name|template0
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|b
init|=
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
name|template0
argument_list|)
argument_list|)
decl_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|b
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|#
directive|if
name|NR_BUNDLES
operator|==
literal|10
if|if
condition|(
operator|(
name|template0
operator|==
literal|4
operator|||
name|template0
operator|==
literal|5
operator|)
operator|&&
operator|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|note
init|=
name|NULL_RTX
decl_stmt|;
comment|/* In .mbb and .bbb bundles, check if CALL_INSN isn't in the 	 first or second slot.  If it is and has REG_EH_NOTE set, copy it 	 to following nops, as br.call sets rp to the address of following 	 bundle and therefore an EH region end must be on a bundle 	 boundary.  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
do|do
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|get_attr_empty
argument_list|(
name|insn
argument_list|)
operator|==
name|EMPTY_YES
condition|)
do|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|note
condition|)
block|{
name|int
name|code
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|code
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
name|CODE_FOR_nop
operator|||
name|code
operator|==
name|CODE_FOR_nop_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|note
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EH_REGION
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The following function does insn bundling.  Bundling means    inserting templates and nop insns to fit insn groups into permitted    templates.  Instruction scheduling uses NDFA (non-deterministic    finite automata) encoding informations about the templates and the    inserted nops.  Nondeterminism of the automata permits follows    all possible insn sequences very fast.     Unfortunately it is not possible to get information about inserting    nop insns and used templates from the automata states.  The    automata only says that we can issue an insn possibly inserting    some nops before it and using some template.  Therefore insn    bundling in this function is implemented by using DFA    (deterministic finite automata).  We follow all possible insn    sequences by inserting 0-2 nops (that is what the NDFA describe for    insn scheduling) before/after each insn being bundled.  We know the    start of simulated processor cycle from insn scheduling (insn    starting a new cycle has TImode).     Simple implementation of insn bundling would create enormous    number of possible insn sequences satisfying information about new    cycle ticks taken from the insn scheduling.  To make the algorithm    practical we use dynamic programming.  Each decision (about    inserting nops and implicitly about previous decisions) is described    by structure bundle_state (see above).  If we generate the same    bundle state (key is automaton state after issuing the insns and    nops for it), we reuse already generated one.  As consequence we    reject some decisions which cannot improve the solution and    reduce memory for the algorithm.     When we reach the end of EBB (extended basic block), we choose the    best sequence and then, moving back in EBB, insert templates for    the best alternative.  The templates are taken from querying    automaton state for each insn in chosen bundle states.     So the algorithm makes two (forward and backward) passes through    EBB.  There is an additional forward pass through EBB for Itanium1    processor.  This pass inserts more nops to make dependency between    a producer insn and MMMUL/MMSHF at least 4 cycles long.  */
end_comment

begin_function
specifier|static
name|void
name|bundling
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|verbose
parameter_list|,
name|rtx
name|prev_head_insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|curr_state
decl_stmt|,
modifier|*
name|next_state
decl_stmt|,
modifier|*
name|best_state
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next_insn
decl_stmt|;
name|int
name|insn_num
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bundle_end_p
decl_stmt|,
name|only_bundle_end_p
decl_stmt|,
name|asm_p
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|max_pos
decl_stmt|,
name|template0
decl_stmt|,
name|template1
decl_stmt|;
name|rtx
name|b
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
name|enum
name|attr_type
name|type
decl_stmt|;
name|insn_num
operator|=
literal|0
expr_stmt|;
comment|/* Count insns in the EBB.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn_num
operator|++
expr_stmt|;
if|if
condition|(
name|insn_num
operator|==
literal|0
condition|)
return|return;
name|bundling_p
operator|=
literal|1
expr_stmt|;
name|dfa_clean_insn_cache
argument_list|()
expr_stmt|;
name|initiate_bundle_state_table
argument_list|()
expr_stmt|;
name|index_to_bundle_states
operator|=
name|xmalloc
argument_list|(
operator|(
name|insn_num
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bundle_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First (forward) pass -- generation of bundle states.  */
name|curr_state
operator|=
name|get_free_bundle_state
argument_list|()
expr_stmt|;
name|curr_state
operator|->
name|insn
operator|=
name|NULL
expr_stmt|;
name|curr_state
operator|->
name|before_nops_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|insn_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|branch_deviation
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr_state
operator|->
name|originator
operator|=
name|NULL
expr_stmt|;
name|state_reset
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|)
expr_stmt|;
name|index_to_bundle_states
index|[
literal|0
index|]
operator|=
name|curr_state
expr_stmt|;
name|insn_num
operator|=
literal|0
expr_stmt|;
comment|/* Shift cycle mark if it is put on insn which could be ignored.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
init|;
name|insn
operator|!=
name|tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|==
name|ITANIUM_CLASS_IGNORE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
block|{
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
for|for
control|(
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|next_insn
operator|!=
name|tail
condition|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|next_insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|next_insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|next_insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|PUT_MODE
argument_list|(
name|next_insn
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Forward pass: generation of bundle states.  */
for|for
control|(
name|insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
argument_list|,
name|tail
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
argument_list|)
expr_stmt|;
name|type
operator|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|next_insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|insn_num
operator|++
expr_stmt|;
name|index_to_bundle_states
index|[
name|insn_num
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|index_to_bundle_states
index|[
name|insn_num
operator|-
literal|1
index|]
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|next_state
control|)
block|{
name|pos
operator|=
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
name|next_state
operator|=
name|curr_state
operator|->
name|next
expr_stmt|;
comment|/* We must fill up the current bundle in order to start a 	     subsequent asm insn in a new bundle.  Asm insn is always 	     placed in a separate bundle.  */
name|only_bundle_end_p
operator|=
operator|(
name|next_insn
operator|!=
name|NULL_RTX
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
operator|&&
name|ia64_safe_type
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TYPE_UNKNOWN
operator|)
expr_stmt|;
comment|/* We may fill up the current bundle if it is the cycle end 	     without a group barrier.  */
name|bundle_end_p
operator|=
operator|(
name|only_bundle_end_p
operator|||
name|next_insn
operator|==
name|NULL_RTX
operator|||
operator|(
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TImode
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_F
operator|||
name|type
operator|==
name|TYPE_B
operator|||
name|type
operator|==
name|TYPE_L
operator|||
name|type
operator|==
name|TYPE_S
comment|/* We need to insert 2 nops for cases like M_MII.  To 		 guarantee issuing all insns on the same cycle for 		 Itanium 1, we need to issue 2 nops after the first M 		 insn (MnnMII where n is a nop insn).  */
operator|||
operator|(
operator|(
name|type
operator|==
name|TYPE_M
operator|||
name|type
operator|==
name|TYPE_A
operator|)
operator|&&
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
operator|&&
operator|!
name|bundle_end_p
operator|&&
name|pos
operator|==
literal|1
operator|)
condition|)
name|issue_nops_and_insn
argument_list|(
name|curr_state
argument_list|,
literal|2
argument_list|,
name|insn
argument_list|,
name|bundle_end_p
argument_list|,
name|only_bundle_end_p
argument_list|)
expr_stmt|;
name|issue_nops_and_insn
argument_list|(
name|curr_state
argument_list|,
literal|1
argument_list|,
name|insn
argument_list|,
name|bundle_end_p
argument_list|,
name|only_bundle_end_p
argument_list|)
expr_stmt|;
name|issue_nops_and_insn
argument_list|(
name|curr_state
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|,
name|bundle_end_p
argument_list|,
name|only_bundle_end_p
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|index_to_bundle_states
index|[
name|insn_num
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|index_to_bundle_states
index|[
name|insn_num
index|]
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next
control|)
if|if
condition|(
name|verbose
operator|>=
literal|2
operator|&&
name|dump
condition|)
block|{
comment|/* This structure is taken from generated code of the 	       pipeline hazard recognizer (see file insn-attrtab.c). 	       Please don't forget to change the structure if a new 	       automaton is added to .md file.  */
struct|struct
name|DFA_chip
block|{
name|unsigned
name|short
name|one_automaton_state
decl_stmt|;
name|unsigned
name|short
name|oneb_automaton_state
decl_stmt|;
name|unsigned
name|short
name|two_automaton_state
decl_stmt|;
name|unsigned
name|short
name|twob_automaton_state
decl_stmt|;
block|}
struct|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    Bundle state %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\n"
argument_list|,
name|curr_state
operator|->
name|unique_num
argument_list|,
operator|(
name|curr_state
operator|->
name|originator
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|curr_state
operator|->
name|originator
operator|->
name|unique_num
operator|)
argument_list|,
name|curr_state
operator|->
name|cost
argument_list|,
name|curr_state
operator|->
name|before_nops_num
argument_list|,
name|curr_state
operator|->
name|after_nops_num
argument_list|,
name|curr_state
operator|->
name|accumulated_insns_num
argument_list|,
name|curr_state
operator|->
name|branch_deviation
argument_list|,
operator|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|?
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|oneb_automaton_state
else|:
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|twob_automaton_state
operator|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We should find a solution because the 2nd insn scheduling has      found one.  */
name|gcc_assert
argument_list|(
name|index_to_bundle_states
index|[
name|insn_num
index|]
argument_list|)
expr_stmt|;
comment|/* Find a state corresponding to the best insn sequence.  */
name|best_state
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|index_to_bundle_states
index|[
name|insn_num
index|]
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next
control|)
comment|/* We are just looking at the states with fully filled up last        bundle.  The first we prefer insn sequences with minimal cost        then with minimal inserted nops and finally with branch insns        placed in the 3rd slots.  */
if|if
condition|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
operator|==
literal|0
operator|&&
operator|(
name|best_state
operator|==
name|NULL
operator|||
name|best_state
operator|->
name|cost
operator|>
name|curr_state
operator|->
name|cost
operator|||
operator|(
name|best_state
operator|->
name|cost
operator|==
name|curr_state
operator|->
name|cost
operator|&&
operator|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|<
name|best_state
operator|->
name|accumulated_insns_num
operator|||
operator|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|==
name|best_state
operator|->
name|accumulated_insns_num
operator|&&
name|curr_state
operator|->
name|branch_deviation
operator|<
name|best_state
operator|->
name|branch_deviation
operator|)
operator|)
operator|)
operator|)
condition|)
name|best_state
operator|=
name|curr_state
expr_stmt|;
comment|/* Second (backward) pass: adding nops and templates.  */
name|insn_num
operator|=
name|best_state
operator|->
name|before_nops_num
expr_stmt|;
name|template0
operator|=
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|best_state
init|;
name|curr_state
operator|->
name|originator
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|originator
control|)
block|{
name|insn
operator|=
name|curr_state
operator|->
name|insn
expr_stmt|;
name|asm_p
operator|=
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|insn_num
operator|++
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
operator|&&
name|dump
condition|)
block|{
struct|struct
name|DFA_chip
block|{
name|unsigned
name|short
name|one_automaton_state
decl_stmt|;
name|unsigned
name|short
name|oneb_automaton_state
decl_stmt|;
name|unsigned
name|short
name|two_automaton_state
decl_stmt|;
name|unsigned
name|short
name|twob_automaton_state
decl_stmt|;
block|}
struct|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    Best %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\n"
argument_list|,
name|curr_state
operator|->
name|unique_num
argument_list|,
operator|(
name|curr_state
operator|->
name|originator
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|curr_state
operator|->
name|originator
operator|->
name|unique_num
operator|)
argument_list|,
name|curr_state
operator|->
name|cost
argument_list|,
name|curr_state
operator|->
name|before_nops_num
argument_list|,
name|curr_state
operator|->
name|after_nops_num
argument_list|,
name|curr_state
operator|->
name|accumulated_insns_num
argument_list|,
name|curr_state
operator|->
name|branch_deviation
argument_list|,
operator|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|?
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|oneb_automaton_state
else|:
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|twob_automaton_state
operator|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find the position in the current bundle window.  The window can 	 contain at most two bundles.  Two bundle window means that 	 the processor will make two bundle rotation.  */
name|max_pos
operator|=
name|get_max_pos
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_pos
operator|==
literal|6
comment|/* The following (negative template number) means that the 	     processor did one bundle rotation.  */
operator|||
operator|(
name|max_pos
operator|==
literal|3
operator|&&
name|template0
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* We are at the end of the window -- find template(s) for 	     its bundle(s).  */
name|pos
operator|=
name|max_pos
expr_stmt|;
if|if
condition|(
name|max_pos
operator|==
literal|3
condition|)
name|template0
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
block|{
name|template1
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|template0
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max_pos
operator|>
literal|3
operator|&&
name|template1
operator|<
literal|0
condition|)
comment|/* It may happen when we have the stop inside a bundle.  */
block|{
name|gcc_assert
argument_list|(
name|pos
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|template1
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|asm_p
condition|)
comment|/* Emit nops after the current insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_state
operator|->
name|after_nops_num
condition|;
name|i
operator|++
control|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|nop
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|pos
operator|--
expr_stmt|;
name|gcc_assert
argument_list|(
name|pos
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|%
literal|3
operator|==
literal|0
condition|)
block|{
comment|/* We are at the start of a bundle: emit the template 		   (it should be defined).  */
name|gcc_assert
argument_list|(
name|template0
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ia64_add_bundle_selector_before
argument_list|(
name|template0
argument_list|,
name|nop
argument_list|)
expr_stmt|;
comment|/* If we have two bundle window, we make one bundle 		   rotation.  Otherwise template0 will be undefined 		   (negative value).  */
name|template0
operator|=
name|template1
expr_stmt|;
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Move the position backward in the window.  Group barrier has 	 no slot.  Asm insn takes all bundle.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|pos
operator|--
expr_stmt|;
comment|/* Long insn takes 2 slots.  */
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_L
condition|)
name|pos
operator|--
expr_stmt|;
name|gcc_assert
argument_list|(
name|pos
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|%
literal|3
operator|==
literal|0
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* The current insn is at the bundle start: emit the 	     template.  */
name|gcc_assert
argument_list|(
name|template0
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ia64_add_bundle_selector_before
argument_list|(
name|template0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|b
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|b
expr_stmt|;
comment|/* See comment above in analogous place for emitting nops 	     after the insn.  */
name|template0
operator|=
name|template1
expr_stmt|;
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Emit nops after the current insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_state
operator|->
name|before_nops_num
condition|;
name|i
operator|++
control|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|nop
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|nop
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|nop
expr_stmt|;
name|pos
operator|--
expr_stmt|;
name|gcc_assert
argument_list|(
name|pos
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|%
literal|3
operator|==
literal|0
condition|)
block|{
comment|/* See comment above in analogous place for emitting nops 		 after the insn.  */
name|gcc_assert
argument_list|(
name|template0
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ia64_add_bundle_selector_before
argument_list|(
name|template0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|b
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|b
expr_stmt|;
name|template0
operator|=
name|template1
expr_stmt|;
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|)
comment|/* Insert additional cycles for MM-insns (MMMUL and MMSHF).        Itanium1 has a strange design, if the distance between an insn        and dependent MM-insn is less 4 then we have a 6 additional        cycles stall.  So we make the distance equal to 4 cycles if it        is less.  */
for|for
control|(
name|insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
argument_list|,
name|tail
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
argument_list|)
expr_stmt|;
name|next_insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|clocks_length
operator|&&
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
comment|/* We found a MM-insn which needs additional cycles.  */
block|{
name|rtx
name|last
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|pred_stop_p
decl_stmt|;
comment|/* Now we are searching for a template of the bundle in 	       which the MM-insn is placed and the position of the 	       insn in the bundle (0, 1, 2).  Also we are searching 	       for that there is a stop before the insn.  */
name|last
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|pred_stop_p
operator|=
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
expr_stmt|;
if|if
condition|(
name|pred_stop_p
condition|)
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|==
name|CODE_FOR_bundle_selector
condition|)
block|{
name|template0
operator|=
name|XINT
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|template0
operator|==
literal|9
condition|)
comment|/* The insn is in MLX bundle.  Change the template 		       onto MFI because we will add nops before the 		       insn.  It simplifies subsequent code a lot.  */
name|PATTERN
argument_list|(
name|last
argument_list|)
operator|=
name|gen_bundle_selector
argument_list|(
name|const2_rtx
argument_list|)
expr_stmt|;
comment|/* -> MFI */
break|break;
block|}
elseif|else
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|&&
operator|(
name|ia64_safe_itanium_class
argument_list|(
name|last
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|)
condition|)
name|n
operator|++
expr_stmt|;
comment|/* Some check of correctness: the stop is not at the 	       bundle start, there are no more 3 insns in the bundle, 	       and the MM-insn is not at the start of bundle with 	       template MLX.  */
name|gcc_assert
argument_list|(
operator|(
operator|!
name|pred_stop_p
operator|||
name|n
operator|)
operator|&&
name|n
operator|<=
literal|2
operator|&&
operator|(
name|template0
operator|!=
literal|9
operator|||
operator|!
name|n
operator|)
argument_list|)
expr_stmt|;
comment|/* Put nops after the insn in the bundle.  */
for|for
control|(
name|j
operator|=
literal|3
operator|-
name|n
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* It takes into account that we will add more N nops 	       before the insn lately -- please see code below.  */
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|pred_stop_p
operator|||
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred_stop_p
condition|)
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Insert "MII;" template.  */
name|ia64_emit_insn_before
argument_list|(
name|gen_bundle_selector
argument_list|(
name|const0_rtx
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
comment|/* To decrease code size, we use "MI;I;" 		       template.  */
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Put the MM-insn in the same slot of a bundle with the 	       same template as the original one.  */
name|ia64_add_bundle_selector_before
argument_list|(
name|template0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* To put the insn in the same slot, add necessary number 	       of nops.  */
for|for
control|(
name|j
operator|=
name|n
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Put the stop if the original bundle had it.  */
if|if
condition|(
name|pred_stop_p
condition|)
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|index_to_bundle_states
argument_list|)
expr_stmt|;
name|finish_bundle_state_table
argument_list|()
expr_stmt|;
name|bundling_p
operator|=
literal|0
expr_stmt|;
name|dfa_clean_insn_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function is called at the end of scheduling BB or    EBB.  After reload, it inserts stop bits and does insn bundling.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_finish
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Finishing schedule.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return;
if|if
condition|(
name|reload_completed
condition|)
block|{
name|final_emit_insn_group_barriers
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|bundling
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|,
name|current_sched_info
operator|->
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    finishing %d-%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|NEXT_INSN
argument_list|(
name|current_sched_info
operator|->
name|prev_head
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|PREV_INSN
argument_list|(
name|current_sched_info
operator|->
name|next_tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* The following function inserts stop bits in scheduled BB or EBB.  */
end_comment

begin_function
specifier|static
name|void
name|final_emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|need_barrier_p
init|=
literal|0
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|NULL_RTX
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|current_sched_info
operator|->
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|current_sched_info
operator|->
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|last
init|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
condition|)
name|emit_insn_after
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|need_barrier_p
operator|=
literal|0
expr_stmt|;
name|prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
block|{
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|need_barrier_p
operator|=
literal|0
expr_stmt|;
name|prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_barrier_p
operator|||
name|group_barrier_needed
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_EARLY_STOP_BITS
condition|)
block|{
name|rtx
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
name|insn
init|;
name|last
operator|!=
name|current_sched_info
operator|->
name|prev_head
condition|;
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|last
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|last
argument_list|)
operator|==
name|TImode
operator|&&
name|stops_p
index|[
name|INSN_UID
argument_list|(
name|last
argument_list|)
index|]
condition|)
break|break;
if|if
condition|(
name|last
operator|==
name|current_sched_info
operator|->
name|prev_head
condition|)
name|last
operator|=
name|insn
expr_stmt|;
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
condition|)
name|emit_insn_after
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
init|;
name|last
operator|!=
name|insn
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|last
argument_list|)
condition|)
name|group_barrier_needed
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
block|}
name|group_barrier_needed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
name|prev_insn
operator|=
name|insn
expr_stmt|;
name|need_barrier_p
operator|=
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If the following function returns TRUE, we will use the DFA    insn scheduler.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|reload_completed
condition|?
literal|6
else|:
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following function initiates variable `dfa_pre_cycle_insn'.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_init_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|temp_dfa_state
operator|==
name|NULL
condition|)
block|{
name|dfa_state_size
operator|=
name|state_size
argument_list|()
expr_stmt|;
name|temp_dfa_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
name|prev_cycle_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
name|dfa_pre_cycle_insn
operator|=
name|make_insn_raw
argument_list|(
name|gen_pre_cycle
argument_list|()
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|dfa_pre_cycle_insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|dfa_pre_cycle_insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|recog_memoized
argument_list|(
name|dfa_pre_cycle_insn
argument_list|)
expr_stmt|;
name|dfa_stop_insn
operator|=
name|make_insn_raw
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|dfa_stop_insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|dfa_stop_insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|recog_memoized
argument_list|(
name|dfa_stop_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function returns the pseudo insn DFA_PRE_CYCLE_INSN    used by the DFA insn scheduler.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dfa_pre_cycle_insn
return|;
block|}
end_function

begin_comment
comment|/* The following function returns TRUE if PRODUCER (of type ilog or    ld) produces address for CONSUMER (of type st or stf). */
end_comment

begin_function
name|int
name|ia64_st_address_bypass_p
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|gcc_assert
argument_list|(
name|producer
operator|&&
name|consumer
argument_list|)
expr_stmt|;
name|dest
operator|=
name|ia64_single_set
argument_list|(
name|producer
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SET_DEST
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|dest
operator|=
name|ia64_single_set
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|mem
operator|=
name|SET_DEST
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mem
operator|&&
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
return|return
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following function returns TRUE if PRODUCER (of type ilog or    ld) produces address for CONSUMER (of type ld or fld). */
end_comment

begin_function
name|int
name|ia64_ld_address_bypass_p
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|gcc_assert
argument_list|(
name|producer
operator|&&
name|consumer
argument_list|)
expr_stmt|;
name|dest
operator|=
name|ia64_single_set
argument_list|(
name|producer
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SET_DEST
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|src
operator|=
name|ia64_single_set
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|mem
operator|=
name|SET_SRC
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XVECLEN
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|mem
operator|=
name|XVECEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
comment|/* ??? Is this bypass necessary for ld.c?  */
block|{
name|gcc_assert
argument_list|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_LDCCLR
argument_list|)
expr_stmt|;
name|mem
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
name|mem
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
name|int
name|c
init|=
name|XINT
argument_list|(
name|mem
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|c
operator|==
name|UNSPEC_LDA
operator|||
name|c
operator|==
name|UNSPEC_LDS
operator|||
name|c
operator|==
name|UNSPEC_LDSA
argument_list|)
expr_stmt|;
name|mem
operator|=
name|XVECEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Note that LO_SUM is used for GOT loads.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|LO_SUM
operator|||
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
return|return
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following function returns TRUE if INSN produces address for a    load/store insn.  We will place such insns into M slot because it    decreases its latency time.  */
end_comment

begin_function
name|int
name|ia64_produce_address_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|insn
operator|->
name|call
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit pseudo-ops for the assembler to describe predicate relations.    At present this assumes that we only consider predicate pairs to    be mutex, and that the assembler can deduce proper values from    straight-line code.  */
end_comment

begin_function
specifier|static
name|void
name|emit_predicate_relation_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|r
decl_stmt|;
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* We only need such notes at code labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* Skip p0, which may be thought to be live due to (reg:DI p0) 	 grabbing the entire block of predicate registers.  */
for|for
control|(
name|r
operator|=
name|PR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|r
operator|<
name|PR_REG
argument_list|(
literal|64
argument_list|)
condition|;
name|r
operator|+=
literal|2
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|rtx
name|p
init|=
name|gen_rtx_REG
argument_list|(
name|BImode
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|rtx
name|n
init|=
name|emit_insn_after
argument_list|(
name|gen_pred_rel_mutex
argument_list|(
name|p
argument_list|)
argument_list|,
name|head
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|n
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
block|}
comment|/* Look for conditional calls that do not return, and protect predicate      relations around them.  Otherwise the assembler will assume the call      returns, and complain about uses of call-clobbered predicates after      the call.  */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|rtx
name|b
init|=
name|emit_insn_before
argument_list|(
name|gen_safe_across_calls_all
argument_list|()
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|a
init|=
name|emit_insn_after
argument_list|(
name|gen_safe_across_calls_normal
argument_list|()
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform machine dependent operations on the rtl chain INSNS.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_reorg
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We are freeing block_for_insn in the toplev to keep compatibility      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */
name|compute_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* If optimizing, we'll have split before scheduling.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|split_all_insns
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? update_life_info_in_dirty_blocks fails to terminate during      non-optimizing bootstrap.  */
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|ia64_flag_schedule_insns2
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
name|ia64_final_schedule
operator|=
literal|1
expr_stmt|;
name|initiate_bundle_states
argument_list|()
expr_stmt|;
name|ia64_nop
operator|=
name|make_insn_raw
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|ia64_nop
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|ia64_nop
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|recog_memoized
argument_list|(
name|ia64_nop
argument_list|)
expr_stmt|;
name|clocks_length
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
expr_stmt|;
name|stops_p
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|clocks_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|)
block|{
name|clocks
operator|=
name|xcalloc
argument_list|(
name|clocks_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|add_cycles
operator|=
name|xcalloc
argument_list|(
name|clocks_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM2
condition|)
block|{
name|pos_1
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_1"
argument_list|)
expr_stmt|;
name|pos_2
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_2"
argument_list|)
expr_stmt|;
name|pos_3
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_3"
argument_list|)
expr_stmt|;
name|pos_4
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_4"
argument_list|)
expr_stmt|;
name|pos_5
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_5"
argument_list|)
expr_stmt|;
name|pos_6
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_6"
argument_list|)
expr_stmt|;
name|_0mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mii."
argument_list|)
expr_stmt|;
name|_0mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mmi."
argument_list|)
expr_stmt|;
name|_0mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mfi."
argument_list|)
expr_stmt|;
name|_0mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mmf."
argument_list|)
expr_stmt|;
name|_0bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0bbb."
argument_list|)
expr_stmt|;
name|_0mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mbb."
argument_list|)
expr_stmt|;
name|_0mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mib."
argument_list|)
expr_stmt|;
name|_0mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mmb."
argument_list|)
expr_stmt|;
name|_0mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mfb."
argument_list|)
expr_stmt|;
name|_0mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mlx."
argument_list|)
expr_stmt|;
name|_1mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mii."
argument_list|)
expr_stmt|;
name|_1mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mmi."
argument_list|)
expr_stmt|;
name|_1mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mfi."
argument_list|)
expr_stmt|;
name|_1mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mmf."
argument_list|)
expr_stmt|;
name|_1bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1bbb."
argument_list|)
expr_stmt|;
name|_1mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mbb."
argument_list|)
expr_stmt|;
name|_1mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mib."
argument_list|)
expr_stmt|;
name|_1mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mmb."
argument_list|)
expr_stmt|;
name|_1mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mfb."
argument_list|)
expr_stmt|;
name|_1mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mlx."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pos_1
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_1"
argument_list|)
expr_stmt|;
name|pos_2
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_2"
argument_list|)
expr_stmt|;
name|pos_3
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_3"
argument_list|)
expr_stmt|;
name|pos_4
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_4"
argument_list|)
expr_stmt|;
name|pos_5
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_5"
argument_list|)
expr_stmt|;
name|pos_6
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_6"
argument_list|)
expr_stmt|;
name|_0mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mii."
argument_list|)
expr_stmt|;
name|_0mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mmi."
argument_list|)
expr_stmt|;
name|_0mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mfi."
argument_list|)
expr_stmt|;
name|_0mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mmf."
argument_list|)
expr_stmt|;
name|_0bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0bbb."
argument_list|)
expr_stmt|;
name|_0mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mbb."
argument_list|)
expr_stmt|;
name|_0mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mib."
argument_list|)
expr_stmt|;
name|_0mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mmb."
argument_list|)
expr_stmt|;
name|_0mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mfb."
argument_list|)
expr_stmt|;
name|_0mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mlx."
argument_list|)
expr_stmt|;
name|_1mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mii."
argument_list|)
expr_stmt|;
name|_1mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mmi."
argument_list|)
expr_stmt|;
name|_1mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mfi."
argument_list|)
expr_stmt|;
name|_1mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mmf."
argument_list|)
expr_stmt|;
name|_1bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1bbb."
argument_list|)
expr_stmt|;
name|_1mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mbb."
argument_list|)
expr_stmt|;
name|_1mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mib."
argument_list|)
expr_stmt|;
name|_1mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mmb."
argument_list|)
expr_stmt|;
name|_1mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mfb."
argument_list|)
expr_stmt|;
name|_1mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mlx."
argument_list|)
expr_stmt|;
block|}
name|schedule_ebbs
argument_list|()
expr_stmt|;
name|finish_bundle_states
argument_list|()
expr_stmt|;
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|)
block|{
name|free
argument_list|(
name|add_cycles
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clocks
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|stops_p
argument_list|)
expr_stmt|;
name|stops_p
operator|=
name|NULL
expr_stmt|;
name|emit_insn_group_barriers
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|ia64_final_schedule
operator|=
literal|0
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_all_insn_group_barriers
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
comment|/* A call must not be the last instruction in a function, so that the      return address is still within the function, so that unwinding works      properly.  Note that IA-64 differs from dwarf2 on this point.  */
if|if
condition|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|saw_stop
init|=
literal|0
decl_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Skip over insns that expand to nothing.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|get_attr_empty
argument_list|(
name|insn
argument_list|)
operator|==
name|EMPTY_YES
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_INSN_GROUP_BARRIER
condition|)
name|saw_stop
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|saw_stop
condition|)
name|emit_insn
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_break_f
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_predicate_relation_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|ia64_flag_var_tracking
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_VAR_TRACKING
argument_list|)
expr_stmt|;
name|variable_tracking_main
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_VAR_TRACKING
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if REGNO is used by the epilogue.  */
end_comment

begin_function
name|int
name|ia64_epilogue_uses
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|R_GR
argument_list|(
literal|1
argument_list|)
case|:
comment|/* With a call to a function in another module, we will write a new 	 value to "gp".  After returning from such a call, we need to make 	 sure the function restores the original gp-value, even if the 	 function itself does not use the gp anymore.  */
return|return
operator|!
operator|(
name|TARGET_AUTO_PIC
operator|||
name|TARGET_NO_PIC
operator|)
return|;
case|case
name|IN_REG
argument_list|(
literal|0
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|7
argument_list|)
case|:
comment|/* For functions defined with the syscall_linkage attribute, all 	 input registers are marked as live at all function exits.  This 	 prevents the register allocator from using the input registers, 	 which in turn makes it possible to restart a system call after 	 an interrupt without having to save/restore the input registers. 	 This also prevents kernel data from leaking to application code.  */
return|return
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NULL
return|;
case|case
name|R_BR
argument_list|(
literal|0
argument_list|)
case|:
comment|/* Conditional return patterns can't represent the use of `b0' as          the return address, so we force the value live this way.  */
return|return
literal|1
return|;
case|case
name|AR_PFS_REGNUM
case|:
comment|/* Likewise for ar.pfs, which is used by br.ret.  */
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if REGNO is used by the frame unwinder.  */
end_comment

begin_function
name|int
name|ia64_eh_uses
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if this goes in small data/bss.  */
end_comment

begin_comment
comment|/* ??? We could also support own long data here.  Generating movl/add/ld8    instead of addl,ld8/ld8.  This makes the code bigger, but should make the    code faster because there is one less load.  This also includes incomplete    types which can't go in sdata/sbss.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_in_small_data_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|TARGET_NO_SDATA
condition|)
return|return
name|false
return|;
comment|/* We want to merge strings, so we never consider them small data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|false
return|;
comment|/* Functions are never small data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|section
argument_list|,
literal|".sdata."
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|section
argument_list|,
literal|".gnu.linkonce.s."
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|section
argument_list|,
literal|".sbss."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|section
argument_list|,
literal|".gnu.linkonce.sb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is an incomplete type with size 0, then we can't put it 	 in sdata because it might be too big when completed.  */
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|ia64_section_threshold
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembly directives for prologue regions.  */
end_comment

begin_comment
comment|/* The current basic block number.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|last_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we need a copy_state command at the start of the next block.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|need_copy_state
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_ARTIFICIAL_LABEL_BYTES
end_ifndef

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_LABEL_BYTES
value|30
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Emit a debugging label after a call-frame-related insn.  We'd    rather output the label right away, but we'd have to output it    after, not before, the instruction, and the instruction has not    been output yet.  So we emit the label after the insn, delete it to    avoid introducing basic blocks, and mark it as preserved, such that    it is still output, given that it is referenced in debug info.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ia64_emit_deleted_label_after_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|rtx
name|lb
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|label_insn
init|=
name|emit_label_after
argument_list|(
name|lb
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|lb
argument_list|)
operator|=
literal|1
expr_stmt|;
name|delete_insn
argument_list|(
name|label_insn
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define the CFA after INSN with the steady-state definition.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_dwarf2out_def_steady_cfa
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|fp
init|=
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
decl_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|ia64_emit_deleted_label_after_insn
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|fp
argument_list|)
argument_list|,
name|ia64_initial_elimination_offset
argument_list|(
name|REGNO
argument_list|(
name|arg_pointer_rtx
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|+
name|ARG_POINTER_CFA_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The generic dwarf2 frame debug info generator does not define a    separate region for the very end of the epilogue, so refrain from    doing so in the IA64-specific code as well.  */
end_comment

begin_define
define|#
directive|define
name|IA64_CHANGE_CFA_IN_EPILOGUE
value|0
end_define

begin_comment
comment|/* The function emits unwind directives for the start of an epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|process_epilogue
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|bool
name|unwind
parameter_list|,
name|bool
name|frame
parameter_list|)
block|{
comment|/* If this isn't the last block of the function, then we need to label the      current state, and copy it back in at the start of the next block.  */
if|if
condition|(
operator|!
name|last_block
condition|)
block|{
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.label_state %d\n"
argument_list|,
operator|++
name|cfun
operator|->
name|machine
operator|->
name|state_num
argument_list|)
expr_stmt|;
name|need_copy_state
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.restore sp\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IA64_CHANGE_CFA_IN_EPILOGUE
operator|&&
name|frame
condition|)
name|dwarf2out_def_cfa
argument_list|(
name|ia64_emit_deleted_label_after_insn
argument_list|(
name|insn
argument_list|)
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|INCOMING_FRAME_SP_OFFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function processes a SET pattern looking for specific patterns    which result in emitting an assembly directive required for unwinding.  */
end_comment

begin_function
specifier|static
name|int
name|process_set
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|pat
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|bool
name|unwind
parameter_list|,
name|bool
name|frame
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
comment|/* Look for the ALLOC insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_ALLOC
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If this is the final destination for ar.pfs, then this must 	 be the alloc in the prologue.  */
if|if
condition|(
name|dest_regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
block|{
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.pfs, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This must be an alloc before a sibcall.  We must drop the 	     old frame info.  The easiest way to drop the old frame 	     info is to ensure we had a ".restore sp" directive 	     followed by a new prologue.  If the procedure doesn't 	     have a memory-stack frame, we'll issue a dummy ".restore 	     sp" now.  */
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
operator|&&
operator|!
name|frame_pointer_needed
condition|)
comment|/* if haven't done process_epilogue() yet, do it now */
name|process_epilogue
argument_list|(
name|asm_out_file
argument_list|,
name|insn
argument_list|,
name|unwind
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.prologue\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* Look for SP = ....  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|op0
operator|==
name|dest
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|frame_pointer_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.fframe "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
condition|)
name|ia64_dwarf2out_def_steady_cfa
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|process_epilogue
argument_list|(
name|asm_out_file
argument_list|,
name|insn
argument_list|,
name|unwind
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|process_epilogue
argument_list|(
name|asm_out_file
argument_list|,
name|insn
argument_list|,
name|unwind
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* Register move we need to look at.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_regno
condition|)
block|{
case|case
name|BR_REG
argument_list|(
literal|0
argument_list|)
case|:
comment|/* Saving return address pointer.  */
name|gcc_assert
argument_list|(
name|dest_regno
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save rp, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PR_REG
argument_list|(
literal|0
argument_list|)
case|:
name|gcc_assert
argument_list|(
name|dest_regno
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save pr, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_UNAT_REGNUM
case|:
name|gcc_assert
argument_list|(
name|dest_regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.unat, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_LC_REGNUM
case|:
name|gcc_assert
argument_list|(
name|dest_regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.lc, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
name|gcc_assert
argument_list|(
name|dest_regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.vframe r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
condition|)
name|ia64_dwarf2out_def_steady_cfa
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
comment|/* Everything else should indicate being stored to memory.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Memory store we need to look at.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|long
name|off
decl_stmt|;
name|rtx
name|base
decl_stmt|;
specifier|const
name|char
modifier|*
name|saveop
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
name|saveop
operator|=
literal|".savepsp"
expr_stmt|;
name|off
operator|=
operator|-
name|off
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|base
operator|==
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|saveop
operator|=
literal|".savesp"
expr_stmt|;
block|}
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_regno
condition|)
block|{
case|case
name|BR_REG
argument_list|(
literal|0
argument_list|)
case|:
name|gcc_assert
argument_list|(
operator|!
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s rp, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PR_REG
argument_list|(
literal|0
argument_list|)
case|:
name|gcc_assert
argument_list|(
operator|!
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s pr, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_LC_REGNUM
case|:
name|gcc_assert
argument_list|(
operator|!
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.lc, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_PFS_REGNUM
case|:
name|gcc_assert
argument_list|(
operator|!
name|current_frame_info
operator|.
name|reg_save_ar_pfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.pfs, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_UNAT_REGNUM
case|:
name|gcc_assert
argument_list|(
operator|!
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.unat, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|GR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|7
argument_list|)
case|:
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.g 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|GR_REG
argument_list|(
literal|4
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BR_REG
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|5
argument_list|)
case|:
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.b 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|BR_REG
argument_list|(
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FR_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|5
argument_list|)
case|:
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.f 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|FR_REG
argument_list|(
literal|2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FR_REG
argument_list|(
literal|16
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|17
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|18
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|19
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|20
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|21
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|22
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|23
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|24
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|25
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|26
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|27
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|28
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|29
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|30
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|31
argument_list|)
case|:
if|if
condition|(
name|unwind
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.gf 0x0, 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|FR_REG
argument_list|(
literal|12
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function looks at a single insn and emits any directives    required to unwind this insn.  */
end_comment

begin_function
name|void
name|process_for_unwind_directive
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|bool
name|unwind
init|=
operator|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
operator|)
decl_stmt|;
name|bool
name|frame
init|=
name|dwarf2out_do_frame
argument_list|()
decl_stmt|;
if|if
condition|(
name|unwind
operator|||
name|frame
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
name|last_block
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|insn
argument_list|)
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
expr_stmt|;
comment|/* Restore unwind state from immediately before the epilogue.  */
if|if
condition|(
name|need_copy_state
condition|)
block|{
if|if
condition|(
name|unwind
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.body\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.copy_state %d\n"
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|state_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IA64_CHANGE_CFA_IN_EPILOGUE
operator|&&
name|frame
condition|)
name|ia64_dwarf2out_def_steady_cfa
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|need_copy_state
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|pat
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|pat
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|process_set
argument_list|(
name|asm_out_file
argument_list|,
name|pat
argument_list|,
name|insn
argument_list|,
name|unwind
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
block|{
name|int
name|par_index
decl_stmt|;
name|int
name|limit
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|par_index
operator|=
literal|0
init|;
name|par_index
operator|<
name|limit
condition|;
name|par_index
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|process_set
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|insn
argument_list|,
name|unwind
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|ia64_builtins
block|{
name|IA64_BUILTIN_BSP
block|,
name|IA64_BUILTIN_FLUSHRS
block|}
enum|;
end_enum

begin_function
name|void
name|ia64_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fpreg_type
decl_stmt|;
name|tree
name|float80_type
decl_stmt|;
comment|/* The __fpreg type.  */
name|fpreg_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|fpreg_type
argument_list|)
operator|=
literal|82
expr_stmt|;
name|layout_type
argument_list|(
name|fpreg_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|fpreg_type
argument_list|,
literal|"__fpreg"
argument_list|)
expr_stmt|;
comment|/* The __float80 type.  */
name|float80_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float80_type
argument_list|)
operator|=
literal|80
expr_stmt|;
name|layout_type
argument_list|(
name|float80_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float80_type
argument_list|,
literal|"__float80"
argument_list|)
expr_stmt|;
comment|/* The __float128 type.  */
if|if
condition|(
operator|!
name|TARGET_HPUX
condition|)
block|{
name|tree
name|float128_type
init|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float128_type
argument_list|)
operator|=
literal|128
expr_stmt|;
name|layout_type
argument_list|(
name|float128_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float128_type
argument_list|,
literal|"__float128"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Under HPUX, this is a synonym for "long double".  */
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|long_double_type_node
argument_list|,
literal|"__float128"
argument_list|)
expr_stmt|;
define|#
directive|define
name|def_builtin
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|)
define|\
value|lang_hooks.builtin_function ((name), (type), (code), BUILT_IN_MD,	\ 			       NULL, NULL_TREE)
name|def_builtin
argument_list|(
literal|"__builtin_ia64_bsp"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|IA64_BUILTIN_BSP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_ia64_flushrs"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|IA64_BUILTIN_FLUSHRS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|def_builtin
block|}
end_function

begin_function
name|rtx
name|ia64_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IA64_BUILTIN_BSP
case|:
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|DImode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_bsp_value
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|target
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|target
return|;
case|case
name|IA64_BUILTIN_FLUSHRS
case|:
name|emit_insn
argument_list|(
name|gen_flushrs
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
default|default:
break|break;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* For the HP-UX IA64 aggregate parameters are passed stored in the    most significant bits of the stack slot.  */
end_comment

begin_function
name|enum
name|direction
name|ia64_hpux_function_arg_padding
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Exception to normal case for structures/unions/etc.  */
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
return|return
name|upward
return|;
comment|/* Fall back to the default.  */
return|return
name|DEFAULT_FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Linked list of all external functions that are to be emitted by GCC.    We output the name if and only if TREE_SYMBOL_REFERENCED is set in    order to avoid putting out names that are never really used.  */
end_comment

begin_decl_stmt
name|struct
name|extern_func_list
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|extern_func_list
modifier|*
name|next
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|extern_func_list
operator|*
name|extern_func_head
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ia64_hpux_add_extern_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|extern_func_list
modifier|*
name|p
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extern_func_list
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_func_head
expr_stmt|;
name|extern_func_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the list of used global functions.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_hpux_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|extern_func_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extern_func_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|tree
name|decl
init|=
name|p
operator|->
name|decl
decl_stmt|;
name|tree
name|id
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|TYPE_ASM_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|","
name|TYPE_OPERAND_FMT
literal|"\n"
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
block|}
block|}
name|extern_func_head
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set SImode div/mod functions, init_integral_libfuncs only initializes    modes of word_mode and larger.  Rename the TFmode libfuncs using the    HPUX conventions. __divtf3 is used for XFmode. We need to keep it for    backward compatibility. */
end_comment

begin_function
specifier|static
name|void
name|ia64_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"__divsi3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"__udivsi3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|"__modsi3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
literal|"__umodsi3"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfsub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfmpy"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfdiv"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfneg"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|SFmode
argument_list|,
literal|"_U_Qfcnvff_sgl_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|DFmode
argument_list|,
literal|"_U_Qfcnvff_dbl_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|XFmode
argument_list|,
literal|"_U_Qfcnvff_f80_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvff_quad_to_sgl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|DFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvff_quad_to_dbl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|XFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvff_quad_to_f80"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxt_quad_to_sgl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxt_quad_to_dbl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|TImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxt_quad_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxut_quad_to_sgl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxut_quad_to_dbl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"_U_Qfcnvxf_sgl_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|DImode
argument_list|,
literal|"_U_Qfcnvxf_dbl_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|TImode
argument_list|,
literal|"_U_Qfcnvxf_quad_to_quad"
argument_list|)
expr_stmt|;
comment|/* HP-UX 11.23 libc does not have a function for unsigned      SImode-to-TFmode conversion.  */
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|TFmode
argument_list|,
name|DImode
argument_list|,
literal|"_U_Qfcnvxuf_dbl_to_quad"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rename all the TFmode libfuncs using the HPUX conventions.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_hpux_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
name|ia64_init_libfuncs
argument_list|()
expr_stmt|;
comment|/* The HP SI millicode division and mod functions expect DI arguments.      By turning them off completely we avoid using both libgcc and the      non-standard millicode routines and use the HP DI millicode routines      instead.  */
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"__milli_divI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"__milli_divU"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|DImode
argument_list|,
literal|"__milli_remI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|DImode
argument_list|,
literal|"__milli_remU"
argument_list|)
expr_stmt|;
comment|/* HP-UX libc has TF min/max/abs routines in it.  */
name|set_optab_libfunc
argument_list|(
name|smin_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfmin"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smax_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfmax"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|abs_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfabs"
argument_list|)
expr_stmt|;
comment|/* ia64_expand_compare uses this.  */
name|cmptf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"_U_Qfcmp"
argument_list|)
expr_stmt|;
comment|/* These should never be used.  */
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rename the division and modulus functions in VMS.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_vms_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$DIV_I"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$DIV_L"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$DIV_UI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$DIV_UL"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$REM_I"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$REM_L"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$REM_UI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$REM_UL"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rename the TFmode libfuncs available from soft-fp in glibc using    the HPUX conventions.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sysv4_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
name|ia64_init_libfuncs
argument_list|()
expr_stmt|;
comment|/* These functions are not part of the HPUX TFmode interface.  We      use them instead of _U_Qfcmp, which doesn't work the way we      expect.  */
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfeq"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfne"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfgt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfge"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qflt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfle"
argument_list|)
expr_stmt|;
comment|/* We leave out _U_Qfmin, _U_Qfmax and _U_Qfabs since soft-fp in      glibc doesn't have them.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For HPUX, it is illegal to have relocations in shared segments.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_hpux_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|3
return|;
block|}
end_function

begin_comment
comment|/* For others, relax this so that relocations to local data goes in    read-only segments, but we still cannot allow global relocations    in read-only segments.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_pic
condition|?
literal|3
else|:
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return the section to use for X.  The only special thing we do here    is to honor small data.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|ia64_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|ia64_section_threshold
operator|&&
operator|!
name|TARGET_NO_SDATA
condition|)
return|return
name|sdata_section
return|;
else|else
return|return
name|default_elf_select_rtx_section
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|ia64_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sdata."
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.s."
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sdata2."
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.s2."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss."
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.sb."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator|=
name|SECTION_SMALL
expr_stmt|;
name|flags
operator||=
name|default_section_type_flags
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Returns true if FNTYPE (a FUNCTION_TYPE or a METHOD_TYPE) returns a    structure type and that the address of that type should be passed    in out0, rather than in r8.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_struct_retval_addr_is_first_parm_p
parameter_list|(
name|tree
name|fntype
parameter_list|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
comment|/* The Itanium C++ ABI requires that out0, rather than r8, be used      as the structure return address parameter, if the return value      type has a non-trivial copy constructor or destructor.  It is not      clear if this same convention should be used for other      programming languages.  Until G++ 3.4, we incorrectly used r8 for      these return values.  */
return|return
operator|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|ret_type
operator|&&
name|TYPE_MODE
argument_list|(
name|ret_type
argument_list|)
operator|==
name|BLKmode
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|ret_type
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output the assembler code for a thunk function.  THUNK_DECL is the    declaration for the thunk function itself, FUNCTION is the decl for    the target function.  DELTA is an immediate constant offset to be    added to THIS.  If VCALL_OFFSET is nonzero, the word at    *(*this + vcall_offset) should be added to THIS.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|this
decl_stmt|,
name|insn
decl_stmt|,
name|funexp
decl_stmt|;
name|unsigned
name|int
name|this_parmno
decl_stmt|;
name|unsigned
name|int
name|this_regno
decl_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
name|reset_block_changes
argument_list|()
expr_stmt|;
comment|/* Set things up as ia64_expand_prologue might.  */
name|last_scratch_gr_reg
operator|=
literal|15
expr_stmt|;
name|memset
argument_list|(
operator|&
name|current_frame_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|current_frame_info
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|spill_cfa_off
operator|=
operator|-
literal|16
expr_stmt|;
name|current_frame_info
operator|.
name|n_input_regs
operator|=
literal|1
expr_stmt|;
name|current_frame_info
operator|.
name|need_regstk
operator|=
operator|(
name|TARGET_REG_NAMES
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Mark the end of the (empty) prologue.  */
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
comment|/* Figure out whether "this" will be the first parameter (the      typical case) or the second parameter (as happens when the      virtual function returns certain class objects).  */
name|this_parmno
operator|=
operator|(
name|ia64_struct_retval_addr_is_first_parm_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|thunk
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|this_regno
operator|=
name|IN_REG
argument_list|(
name|this_parmno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
name|reg_names
index|[
name|this_regno
index|]
operator|=
name|ia64_reg_numbers
index|[
name|this_parmno
index|]
expr_stmt|;
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|this_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ILP32
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
name|this_regno
argument_list|)
decl_stmt|;
name|REG_POINTER
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|&&
name|CONST_OK_FOR_I
argument_list|(
name|delta
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_ptr_extend_plus_imm
argument_list|(
name|this
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|delta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_ptr_extend
argument_list|(
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the constant offset, if required.  */
if|if
condition|(
name|delta
condition|)
block|{
name|rtx
name|delta_rtx
init|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|delta
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|delta_rtx
argument_list|)
expr_stmt|;
name|delta_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the offset from the vtable, if required.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
name|rtx
name|vcall_offset_rtx
init|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
decl_stmt|;
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_ILP32
condition|)
block|{
name|rtx
name|t
init|=
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|REG_POINTER
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|t
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|ptr_mode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_ptr_extend_plus_imm
argument_list|(
name|tmp
argument_list|,
name|t
argument_list|,
name|vcall_offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|vcall_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_ptr_extend
argument_list|(
name|tmp
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OK_FOR_J
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|rtx
name|tmp2
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|vcall_offset_rtx
argument_list|)
expr_stmt|;
name|vcall_offset_rtx
operator|=
name|tmp2
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ILP32
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|ptr_mode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate a tail call to the target function.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funexp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
name|ia64_expand_call
argument_list|(
name|NULL_RTX
argument_list|,
name|funexp
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Code generation for calls relies on splitting.  */
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Run just enough of rest_of_compilation to get the insns emitted.      There's not really enough bulk here to make other passes such as      instruction scheduling worth while.  Note that use_thunk calls      assemble_start_function and assemble_end_function.  */
name|insn_locators_initialize
argument_list|()
expr_stmt|;
name|emit_all_insn_group_barriers
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|epilogue_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker function for TARGET_STRUCT_VALUE_RTX.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_struct_value_rtx
parameter_list|(
name|tree
name|fntype
parameter_list|,
name|int
name|incoming
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|fntype
operator|&&
name|ia64_struct_retval_addr_is_first_parm_p
argument_list|(
name|fntype
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GR_REG
argument_list|(
literal|8
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ia64_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
case|case
name|DImode
case|:
case|case
name|TImode
case|:
return|return
name|true
return|;
case|case
name|SFmode
case|:
case|case
name|DFmode
case|:
case|case
name|XFmode
case|:
case|case
name|RFmode
case|:
return|return
name|true
return|;
case|case
name|TFmode
case|:
return|return
name|TARGET_HPUX
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|ia64_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V8QImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
return|return
name|true
return|;
case|case
name|V2SFmode
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Implement the FUNCTION_PROFILER macro.  */
end_comment

begin_function
name|void
name|ia64_output_function_profiler
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|labelno
parameter_list|)
block|{
name|bool
name|indirect_call
decl_stmt|;
comment|/* If the function needs a static chain and the static chain      register is r15, we use an indirect call so as to bypass      the PLT stub in case the executable is dynamically linked,      because the stub clobbers r15 as per 5.3.6 of the psABI.      We don't need to do that in non canonical PIC mode.  */
if|if
condition|(
name|cfun
operator|->
name|static_chain_decl
operator|&&
operator|!
name|TARGET_NO_PIC
operator|&&
operator|!
name|TARGET_AUTO_PIC
condition|)
block|{
name|gcc_assert
argument_list|(
name|STATIC_CHAIN_REGNUM
operator|==
literal|15
argument_list|)
expr_stmt|;
name|indirect_call
operator|=
name|true
expr_stmt|;
block|}
else|else
name|indirect_call
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TARGET_GNU_AS
condition|)
name|fputs
argument_list|(
literal|"\t.prologue 4, r40\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t.prologue\n\t.save ar.pfs, r40\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\talloc out0 = ar.pfs, 8, 0, 4, 0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|NO_PROFILE_COUNTERS
condition|)
name|fputs
argument_list|(
literal|"\tmov out3 = r0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
name|fputs
argument_list|(
literal|"\tmovl out3 = @gprel("
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\taddl out3 = @ltoff("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"), r1\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirect_call
condition|)
name|fputs
argument_list|(
literal|"\taddl r14 = @ltoff(@fptr(_mcount)), r1\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t;;\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.save rp, r42\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tmov out2 = b0\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_call
condition|)
name|fputs
argument_list|(
literal|"\tld8 r14 = [r14]\n\t;;\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.body\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tmov out1 = r1\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_call
condition|)
block|{
name|fputs
argument_list|(
literal|"\tld8 r16 = [r14], 8\n\t;;\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tmov b6 = r16\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tld8 r1 = [r14]\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tbr.call.sptk.many b0 = b6\n\t;;\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"\tbr.call.sptk.many b0 = _mcount\n\t;;\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|mcount_func_rtx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|gen_mcount_func_rtx
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mcount_func_rtx
condition|)
name|mcount_func_rtx
operator|=
name|init_one_libfunc
argument_list|(
literal|"_mcount"
argument_list|)
expr_stmt|;
return|return
name|mcount_func_rtx
return|;
block|}
end_function

begin_function
name|void
name|ia64_profile_hook
parameter_list|(
name|int
name|labelno
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|,
name|ip
decl_stmt|;
if|if
condition|(
name|NO_PROFILE_COUNTERS
condition|)
name|label
operator|=
name|const0_rtx
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|label_name
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|label_name
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|ggc_strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|label_name
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|label
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
block|}
name|ip
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ip_value
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|emit_library_call
argument_list|(
name|gen_mcount_func_rtx
argument_list|()
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|ip
argument_list|,
name|Pmode
argument_list|,
name|label
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the mangling of TYPE if it is an extended fundamental type.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ia64_mangle_fundamental_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* On HP-UX, "long double" is mangled as "e" so __float128 is      mangled as "e".  */
if|if
condition|(
operator|!
name|TARGET_HPUX
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
condition|)
return|return
literal|"g"
return|;
comment|/* On HP-UX, "e" is not available as a mangling of __float80 so use      an extended mangling.  Elsewhere, "e" is available since long      double is 80 bits.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|XFmode
condition|)
return|return
name|TARGET_HPUX
condition|?
literal|"u9__float80"
else|:
literal|"e"
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|RFmode
condition|)
return|return
literal|"u7__fpreg"
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the diagnostic message string if conversion from FROMTYPE to    TOTYPE is not allowed, NULL otherwise.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ia64_invalid_conversion
parameter_list|(
name|tree
name|fromtype
parameter_list|,
name|tree
name|totype
parameter_list|)
block|{
comment|/* Reject nontrivial conversion to or from __fpreg.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|fromtype
argument_list|)
operator|==
name|RFmode
operator|&&
name|TYPE_MODE
argument_list|(
name|totype
argument_list|)
operator|!=
name|RFmode
operator|&&
name|TYPE_MODE
argument_list|(
name|totype
argument_list|)
operator|!=
name|VOIDmode
condition|)
return|return
name|N_
argument_list|(
literal|"invalid conversion from %<__fpreg%>"
argument_list|)
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|totype
argument_list|)
operator|==
name|RFmode
operator|&&
name|TYPE_MODE
argument_list|(
name|fromtype
argument_list|)
operator|!=
name|RFmode
condition|)
return|return
name|N_
argument_list|(
literal|"invalid conversion to %<__fpreg%>"
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the diagnostic message string if the unary operation OP is    not permitted on TYPE, NULL otherwise.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ia64_invalid_unary_op
parameter_list|(
name|int
name|op
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Reject operations on __fpreg other than unary + or&.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|RFmode
operator|&&
name|op
operator|!=
name|CONVERT_EXPR
operator|&&
name|op
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|N_
argument_list|(
literal|"invalid operation on %<__fpreg%>"
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the diagnostic message string if the binary operation OP is    not permitted on TYPE1 and TYPE2, NULL otherwise.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ia64_invalid_binary_op
parameter_list|(
name|int
name|op
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
comment|/* Reject operations on __fpreg.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type1
argument_list|)
operator|==
name|RFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type2
argument_list|)
operator|==
name|RFmode
condition|)
return|return
name|N_
argument_list|(
literal|"invalid operation on %<__fpreg%>"
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Implement overriding of the optimization options.  */
end_comment

begin_function
name|void
name|ia64_optimization_options
parameter_list|(
name|int
name|level
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Let the scheduler form additional regions.  */
name|set_param_value
argument_list|(
literal|"max-sched-extend-regions-iters"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-ia64.h"
end_include

end_unit

