begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 EH unwinding support for IA64 Linux.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     In addition to the permissions in the GNU General Public License,    the Free Software Foundation gives you unlimited permission to link    the compiled version of this file with other programs, and to    distribute those programs without any restriction coming from the    use of this file.  (The General Public License restrictions do    apply in other respects; for example, they cover modification of    the file, and distribution when not linked into another program.)     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Do code reading to identify a signal frame, and set the frame    state data appropriately.  See unwind-dw2.c for the structs.  */
end_comment

begin_comment
comment|/* This works only for glibc-2.3 and later, because sigcontext is different    in glibc-2.2.4.  */
end_comment

begin_if
if|#
directive|if
name|__GLIBC__
operator|>
literal|2
operator|||
operator|(
name|__GLIBC__
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|>=
literal|3
operator|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucontext.h>
end_include

begin_define
define|#
directive|define
name|IA64_GATE_AREA_START
value|0xa000000000000100LL
end_define

begin_define
define|#
directive|define
name|IA64_GATE_AREA_END
value|0xa000000000030000LL
end_define

begin_define
define|#
directive|define
name|MD_FALLBACK_FRAME_STATE_FOR
value|ia64_fallback_frame_state
end_define

begin_function
specifier|static
name|_Unwind_Reason_Code
name|ia64_fallback_frame_state
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|rp
operator|>=
name|IA64_GATE_AREA_START
operator|&&
name|context
operator|->
name|rp
operator|<
name|IA64_GATE_AREA_END
condition|)
block|{
struct|struct
name|sigframe
block|{
name|char
name|scratch
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|long
name|sig_number
decl_stmt|;
name|struct
name|siginfo
modifier|*
name|info
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|}
modifier|*
name|frame_
init|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
name|context
operator|->
name|psp
struct|;
name|struct
name|sigcontext
modifier|*
name|sc
init|=
name|frame_
operator|->
name|sc
decl_stmt|;
comment|/* Restore scratch registers in case the unwinder needs to 	 refer to a value stored in one of them.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|ireg
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|loc
operator|=
operator|&
name|sc
operator|->
name|sc_gr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|ireg
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|loc
operator|=
operator|&
name|sc
operator|->
name|sc_gr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|ireg
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|loc
operator|=
operator|&
name|sc
operator|->
name|sc_gr
index|[
name|i
index|]
expr_stmt|;
block|}
name|context
operator|->
name|fpsr_loc
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ar_fpsr
operator|)
expr_stmt|;
name|context
operator|->
name|pfs_loc
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ar_pfs
operator|)
expr_stmt|;
name|context
operator|->
name|lc_loc
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ar_lc
operator|)
expr_stmt|;
name|context
operator|->
name|unat_loc
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ar_unat
operator|)
expr_stmt|;
name|context
operator|->
name|br_loc
index|[
literal|0
index|]
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_br
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|context
operator|->
name|br_loc
index|[
literal|6
index|]
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_br
index|[
literal|6
index|]
operator|)
expr_stmt|;
name|context
operator|->
name|br_loc
index|[
literal|7
index|]
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_br
index|[
literal|7
index|]
operator|)
expr_stmt|;
name|context
operator|->
name|pr
operator|=
name|sc
operator|->
name|sc_pr
expr_stmt|;
name|context
operator|->
name|psp
operator|=
name|sc
operator|->
name|sc_gr
index|[
literal|12
index|]
expr_stmt|;
name|context
operator|->
name|gp
operator|=
name|sc
operator|->
name|sc_gr
index|[
literal|1
index|]
expr_stmt|;
comment|/* Signal frame doesn't have an associated reg. stack frame          other than what we adjust for below.	  */
name|fs
operator|->
name|no_reg_stack_frame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rbs_base
condition|)
block|{
comment|/* Need to switch from alternate register backing store.  */
name|long
name|ndirty
decl_stmt|,
name|loadrs
init|=
name|sc
operator|->
name|sc_loadrs
operator|>>
literal|16
decl_stmt|;
name|unsigned
name|long
name|alt_bspstore
init|=
name|context
operator|->
name|bsp
operator|-
name|loadrs
decl_stmt|;
name|unsigned
name|long
name|bspstore
decl_stmt|;
name|unsigned
name|long
modifier|*
name|ar_bsp
init|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_ar_bsp
operator|)
decl_stmt|;
name|ndirty
operator|=
name|ia64_rse_num_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|alt_bspstore
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|context
operator|->
name|bsp
argument_list|)
expr_stmt|;
name|bspstore
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ia64_rse_skip_regs
argument_list|(
name|ar_bsp
argument_list|,
operator|-
name|ndirty
argument_list|)
expr_stmt|;
name|ia64_copy_rbs
argument_list|(
name|context
argument_list|,
name|bspstore
argument_list|,
name|alt_bspstore
argument_list|,
name|loadrs
argument_list|,
name|sc
operator|->
name|sc_ar_rnat
argument_list|)
expr_stmt|;
block|}
comment|/* Don't touch the branch registers o.t. b0, b6 and b7. 	 The kernel doesn't pass the preserved branch registers 	 in the sigcontext but leaves them intact, so there's no 	 need to do anything with them here.  */
block|{
name|unsigned
name|long
name|sof
init|=
name|sc
operator|->
name|sc_cfm
operator|&
literal|0x7f
decl_stmt|;
name|context
operator|->
name|bsp
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ia64_rse_skip_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_ar_bsp
operator|)
argument_list|,
operator|-
name|sof
argument_list|)
expr_stmt|;
block|}
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|where
operator|=
name|UNW_WHERE_SPREL
expr_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|val
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
operator|(
name|sc
operator|->
name|sc_ip
operator|)
operator|-
name|context
operator|->
name|psp
expr_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|when
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
return|return
name|_URC_END_OF_STACK
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MD_HANDLE_UNWABI
value|ia64_handle_unwabi
end_define

begin_function
specifier|static
name|void
name|ia64_handle_unwabi
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
if|if
condition|(
name|fs
operator|->
name|unwabi
operator|==
operator|(
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
literal|'s'
operator|)
operator|||
name|fs
operator|->
name|unwabi
operator|==
operator|(
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
literal|'s'
operator|)
condition|)
block|{
struct|struct
name|sigframe
block|{
name|char
name|scratch
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|long
name|sig_number
decl_stmt|;
name|struct
name|siginfo
modifier|*
name|info
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|}
modifier|*
name|frame
init|=
operator|(
expr|struct
name|sigframe
operator|*
operator|)
name|context
operator|->
name|psp
struct|;
name|struct
name|sigcontext
modifier|*
name|sc
init|=
name|frame
operator|->
name|sc
decl_stmt|;
comment|/* Restore scratch registers in case the unwinder needs to 	 refer to a value stored in one of them.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|ireg
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|loc
operator|=
operator|&
name|sc
operator|->
name|sc_gr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|ireg
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|loc
operator|=
operator|&
name|sc
operator|->
name|sc_gr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|ireg
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|loc
operator|=
operator|&
name|sc
operator|->
name|sc_gr
index|[
name|i
index|]
expr_stmt|;
block|}
name|context
operator|->
name|pfs_loc
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ar_pfs
operator|)
expr_stmt|;
name|context
operator|->
name|lc_loc
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ar_lc
operator|)
expr_stmt|;
name|context
operator|->
name|unat_loc
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_ar_unat
operator|)
expr_stmt|;
name|context
operator|->
name|br_loc
index|[
literal|0
index|]
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_br
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|context
operator|->
name|br_loc
index|[
literal|6
index|]
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_br
index|[
literal|6
index|]
operator|)
expr_stmt|;
name|context
operator|->
name|br_loc
index|[
literal|7
index|]
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_br
index|[
literal|7
index|]
operator|)
expr_stmt|;
name|context
operator|->
name|pr
operator|=
name|sc
operator|->
name|sc_pr
expr_stmt|;
name|context
operator|->
name|gp
operator|=
name|sc
operator|->
name|sc_gr
index|[
literal|1
index|]
expr_stmt|;
comment|/* Signal frame doesn't have an associated reg. stack frame          other than what we adjust for below.	  */
name|fs
operator|->
name|no_reg_stack_frame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rbs_base
condition|)
block|{
comment|/* Need to switch from alternate register backing store.  */
name|long
name|ndirty
decl_stmt|,
name|loadrs
init|=
name|sc
operator|->
name|sc_loadrs
operator|>>
literal|16
decl_stmt|;
name|unsigned
name|long
name|alt_bspstore
init|=
name|context
operator|->
name|bsp
operator|-
name|loadrs
decl_stmt|;
name|unsigned
name|long
name|bspstore
decl_stmt|;
name|unsigned
name|long
modifier|*
name|ar_bsp
init|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_ar_bsp
operator|)
decl_stmt|;
name|ndirty
operator|=
name|ia64_rse_num_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|alt_bspstore
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|context
operator|->
name|bsp
argument_list|)
expr_stmt|;
name|bspstore
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ia64_rse_skip_regs
argument_list|(
name|ar_bsp
argument_list|,
operator|-
name|ndirty
argument_list|)
expr_stmt|;
name|ia64_copy_rbs
argument_list|(
name|context
argument_list|,
name|bspstore
argument_list|,
name|alt_bspstore
argument_list|,
name|loadrs
argument_list|,
name|sc
operator|->
name|sc_ar_rnat
argument_list|)
expr_stmt|;
block|}
comment|/* Don't touch the branch registers o.t. b0, b6 and b7. 	 The kernel doesn't pass the preserved branch registers 	 in the sigcontext but leaves them intact, so there's no 	 need to do anything with them here.  */
block|{
name|unsigned
name|long
name|sof
init|=
name|sc
operator|->
name|sc_cfm
operator|&
literal|0x7f
decl_stmt|;
name|context
operator|->
name|bsp
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ia64_rse_skip_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_ar_bsp
operator|)
argument_list|,
operator|-
name|sof
argument_list|)
expr_stmt|;
block|}
comment|/* pfs_loc already set above.  Without this pfs_loc would point 	 incorrectly to sc_cfm instead of sc_ar_pfs.  */
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PFS
index|]
operator|.
name|where
operator|=
name|UNW_WHERE_NONE
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* glibc-2.3 or better */
end_comment

end_unit

