begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Callgraph based analysis of static variables.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.    Contributed by Kenneth Zadeck<zadeck@naturalbridge.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file mark functions as being either const (TREE_READONLY) or    pure (DECL_IS_PURE).     This must be run after inlining decisions have been made since    otherwise, the local sets will not contain information that is    consistent with post inlined state.  The global sets are not prone    to this problem since they are by definition transitive.  */
end_comment

begin_comment
comment|/* The code in this module is called by the ipa pass manager. It    should be one of the later passes since it's information is used by    the rest of the compilation. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"ipa-utils.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|pointer_set_t
modifier|*
name|visited_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lattice values for const and pure functions.  Everything starts out    being const, then may drop to pure and then neither depending on    what is found.  */
end_comment

begin_enum
enum|enum
name|pure_const_state_e
block|{
name|IPA_CONST
block|,
name|IPA_PURE
block|,
name|IPA_NEITHER
block|}
enum|;
end_enum

begin_comment
comment|/* Holder inserted into the ipa_dfs_info aux field to hold the    const_state.  */
end_comment

begin_struct
struct|struct
name|funct_state_d
block|{
name|enum
name|pure_const_state_e
name|pure_const_state
decl_stmt|;
name|bool
name|state_set_in_source
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|funct_state_d
modifier|*
name|funct_state
typedef|;
end_typedef

begin_comment
comment|/* Return the function state from NODE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|funct_state
name|get_function_state
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|ipa_dfs_info
modifier|*
name|info
init|=
name|node
operator|->
name|aux
decl_stmt|;
return|return
name|info
operator|->
name|aux
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the use (or definition when CHECHING_WRITE is true)     variable T is legal in a function that is either pure or const.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|check_decl
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|t
parameter_list|,
name|bool
name|checking_write
parameter_list|)
block|{
comment|/* If the variable has the "used" attribute, treat it as if it had a      been touched by the devil.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
return|return;
block|}
comment|/* Do not want to do anything with volatile except mark any      function that uses one to be not const or pure.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
return|return;
block|}
comment|/* Do not care about a local automatic that is not static.  */
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
return|return;
comment|/* Since we have dealt with the locals and params cases above, if we      are CHECKING_WRITE, this cannot be a pure or constant      function.  */
if|if
condition|(
name|checking_write
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* If the front end set the variable to be READONLY and 	 constant, we can allow this variable in pure or const 	 functions but the scope is too large for our analysis to set 	 these bits ourselves.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Read of a constant, do not change the function state.  */
else|else
block|{
comment|/* Just a regular read.  */
if|if
condition|(
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
block|}
block|}
comment|/* Compilation level statics can be read if they are readonly      variables.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
return|return;
comment|/* Just a regular read.  */
if|if
condition|(
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If T is a VAR_DECL check to see if it is an allowed reference.  */
end_comment

begin_function
specifier|static
name|void
name|check_operand
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|t
parameter_list|,
name|bool
name|checking_write
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|check_decl
argument_list|(
name|local
argument_list|,
name|t
argument_list|,
name|checking_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Examine tree T for references.  */
end_comment

begin_function
specifier|static
name|void
name|check_tree
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|t
parameter_list|,
name|bool
name|checking_write
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|EXC_PTR_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FILTER_EXPR
operator|)
condition|)
return|return;
comment|/* Any tree which is volatile disqualifies thie function from being      const or pure. */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|||
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|check_operand
argument_list|(
name|local
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The bottom of an indirect reference can only be read, not      written.  */
if|if
condition|(
name|INDIRECT_REF_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|check_tree
argument_list|(
name|local
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Any indirect reference that occurs on the lhs 	 disqualifies the function from being pure or const. Any 	 indirect reference that occurs on the rhs disqualifies the 	 function from being const.  */
if|if
condition|(
name|checking_write
condition|)
block|{
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
block|}
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|t
argument_list|)
condition|)
name|check_operand
argument_list|(
name|local
argument_list|,
name|t
argument_list|,
name|checking_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan tree T to see if there are any addresses taken in within T.  */
end_comment

begin_function
specifier|static
name|void
name|look_for_address_of
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|x
init|=
name|get_base_var
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|check_decl
argument_list|(
name|local
argument_list|,
name|x
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Taking the address of something appears to be reasonable 	     in PURE code.  Not allowed in const.  */
if|if
condition|(
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check to see if T is a read or address of operation on a var we are    interested in analyzing.  LOCAL is passed in to get access to its    bit vectors.  */
end_comment

begin_function
specifier|static
name|void
name|check_rhs_var
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|look_for_address_of
argument_list|(
name|local
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Memcmp and strlen can both trap and they are declared pure.  */
if|if
condition|(
name|tree_could_trap_p
argument_list|(
name|t
argument_list|)
operator|&&
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
name|check_tree
argument_list|(
name|local
argument_list|,
name|t
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see if T is an assignment to a var we are interested in    analyzing.  LOCAL is passed in to get access to its bit vectors. */
end_comment

begin_function
specifier|static
name|void
name|check_lhs_var
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
comment|/* Memcmp and strlen can both trap and they are declared pure.      Which seems to imply that we can apply the same rule here.  */
if|if
condition|(
name|tree_could_trap_p
argument_list|(
name|t
argument_list|)
operator|&&
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
name|check_tree
argument_list|(
name|local
argument_list|,
name|t
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a scaled down version of get_asm_expr_operands from    tree_ssa_operands.c.  The version there runs much later and assumes    that aliasing information is already available. Here we are just    trying to find if the set of inputs and outputs contain references    or address of operations to local static variables.  STMT is the    actual asm statement.  */
end_comment

begin_function
specifier|static
name|void
name|get_asm_expr_operands
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|noutputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|link
operator|=
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
expr_stmt|;
name|check_lhs_var
argument_list|(
name|local
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|ASM_CLOBBERS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|memory_identifier_string
argument_list|)
operator|==
literal|1
condition|)
comment|/* Abandon all hope, ye who enter here. */
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
if|if
condition|(
name|ASM_VOLATILE_P
argument_list|(
name|stmt
argument_list|)
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check the parameters of a function call to CALL_EXPR to see if    there are any references in the parameters that are not allowed for    pure or const functions.  Also check to see if this is either an    indirect call, a call outside the compilation unit, or has special    attributes that may also effect the purity.  The CALL_EXPR node for    the entire call expression.  */
end_comment

begin_function
specifier|static
name|void
name|check_call
parameter_list|(
name|funct_state
name|local
parameter_list|,
name|tree
name|call_expr
parameter_list|)
block|{
name|int
name|flags
init|=
name|call_expr_flags
argument_list|(
name|call_expr
argument_list|)
decl_stmt|;
name|tree
name|operand_list
init|=
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|operand
decl_stmt|;
name|tree
name|callee_t
init|=
name|get_callee_fndecl
argument_list|(
name|call_expr
argument_list|)
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|callee
decl_stmt|;
name|enum
name|availability
name|avail
init|=
name|AVAIL_NOT_AVAILABLE
decl_stmt|;
for|for
control|(
name|operand
operator|=
name|operand_list
init|;
name|operand
operator|!=
name|NULL_TREE
condition|;
name|operand
operator|=
name|TREE_CHAIN
argument_list|(
name|operand
argument_list|)
control|)
block|{
name|tree
name|argument
init|=
name|TREE_VALUE
argument_list|(
name|operand
argument_list|)
decl_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|argument
argument_list|)
expr_stmt|;
block|}
comment|/* The const and pure flags are set by a variety of places in the      compiler (including here).  If someone has already set the flags      for the callee, (such as for some of the builtins) we will use      them, otherwise we will compute our own information.          Const and pure functions have less clobber effects than other      functions so we process these first.  Otherwise if it is a call      outside the compilation unit or an indirect call we punt.  This      leaves local calls which will be processed by following the call      graph.  */
if|if
condition|(
name|callee_t
condition|)
block|{
name|callee
operator|=
name|cgraph_node
argument_list|(
name|callee_t
argument_list|)
expr_stmt|;
name|avail
operator|=
name|cgraph_function_body_availability
argument_list|(
name|callee
argument_list|)
expr_stmt|;
comment|/* When bad things happen to bad functions, they cannot be const 	 or pure.  */
if|if
condition|(
name|setjmp_call_p
argument_list|(
name|callee_t
argument_list|)
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|callee_t
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|callee_t
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_LONGJMP
case|:
case|case
name|BUILT_IN_NONLOCAL_GOTO
case|:
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* The callee is either unknown (indirect call) or there is just no      scannable code for it (external call) .  We look to see if there      are any bits available for the callee (such as by declaration or      because it is builtin) and process solely on the basis of those      bits. */
if|if
condition|(
name|avail
operator|==
name|AVAIL_NOT_AVAILABLE
operator|||
name|avail
operator|==
name|AVAIL_OVERWRITABLE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ECF_PURE
condition|)
block|{
if|if
condition|(
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
block|}
else|else
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
block|}
else|else
block|{
comment|/* We have the code and we will scan it for the effects. */
if|if
condition|(
name|flags
operator|&
name|ECF_PURE
condition|)
block|{
if|if
condition|(
name|local
operator|->
name|pure_const_state
operator|==
name|IPA_CONST
condition|)
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* TP is the part of the tree currently under the microscope.    WALK_SUBTREES is part of the walk_tree api but is unused here.    DATA is cgraph_node of the function being walked.  */
end_comment

begin_comment
comment|/* FIXME: When this is converted to run over SSA form, this code    should be converted to use the operand scanner.  */
end_comment

begin_function
specifier|static
name|tree
name|scan_function
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|fn
init|=
name|data
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|funct_state
name|local
init|=
name|get_function_state
argument_list|(
name|fn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|scan_function
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
block|{
comment|/* First look on the lhs and see what variable is stored to */
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|check_lhs_var
argument_list|(
name|local
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
comment|/* For the purposes of figuring out what the cast affects */
comment|/* Next check the operands on the rhs to see if they are ok. */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_binary
case|:
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tcc_unary
case|:
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tcc_reference
case|:
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_declaration
case|:
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|check_call
argument_list|(
name|local
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* This case is here to find addresses on rhs of constructors in 	 decl_initial of static variables. */
name|check_rhs_var
argument_list|(
name|local
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* Target of long jump. */
name|local
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|check_call
argument_list|(
name|local
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|get_asm_expr_operands
argument_list|(
name|local
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This is the main routine for finding the reference patterns for    global variables within a function FN.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|fn
parameter_list|)
block|{
name|funct_state
name|l
init|=
name|XCNEW
argument_list|(
expr|struct
name|funct_state_d
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|fn
operator|->
name|decl
decl_stmt|;
name|struct
name|ipa_dfs_info
modifier|*
name|w_info
init|=
name|fn
operator|->
name|aux
decl_stmt|;
name|w_info
operator|->
name|aux
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|pure_const_state
operator|=
name|IPA_CONST
expr_stmt|;
name|l
operator|->
name|state_set_in_source
operator|=
name|false
expr_stmt|;
comment|/* If this function does not return normally or does not bind local,      do not touch this unless it has been marked as const or pure by the      front end.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|l
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|l
operator|->
name|pure_const_state
operator|=
name|IPA_CONST
expr_stmt|;
name|l
operator|->
name|state_set_in_source
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|DECL_IS_PURE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|l
operator|->
name|pure_const_state
operator|=
name|IPA_PURE
expr_stmt|;
name|l
operator|->
name|state_set_in_source
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n local analysis of %s with initial value = %d\n "
argument_list|,
name|cgraph_node_name
argument_list|(
name|fn
argument_list|)
argument_list|,
name|l
operator|->
name|pure_const_state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|l
operator|->
name|state_set_in_source
condition|)
block|{
name|struct
name|function
modifier|*
name|this_cfun
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|basic_block
name|this_block
decl_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|this_block
argument_list|,
argument|this_cfun
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|this_block
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|scan_function
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|pure_const_state
operator|==
name|IPA_NEITHER
condition|)
goto|goto
name|end
goto|;
block|}
block|}
if|if
condition|(
name|l
operator|->
name|pure_const_state
operator|!=
name|IPA_NEITHER
condition|)
block|{
name|tree
name|old_decl
init|=
name|current_function_decl
decl_stmt|;
comment|/* Const functions cannot have back edges (an 	     indication of possible infinite loop side 	     effect.  */
name|current_function_decl
operator|=
name|fn
operator|->
name|decl
expr_stmt|;
comment|/* The C++ front end, has a tendency to some times jerk away 	     a function after it has created it.  This should have 	     been fixed.  */
name|gcc_assert
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|push_cfun
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_dfs_back_edges
argument_list|()
condition|)
name|l
operator|->
name|pure_const_state
operator|=
name|IPA_NEITHER
expr_stmt|;
name|current_function_decl
operator|=
name|old_decl
expr_stmt|;
name|pop_cfun
argument_list|()
expr_stmt|;
block|}
block|}
name|end
label|:
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"after local analysis of %s with initial value = %d\n "
argument_list|,
name|cgraph_node_name
argument_list|(
name|fn
argument_list|)
argument_list|,
name|l
operator|->
name|pure_const_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Produce the global information by preforming a transitive closure    on the local information that was produced by ipa_analyze_function    and ipa_analyze_variable.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|static_execute
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|w
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
init|=
name|XCNEWVEC
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|,
name|cgraph_n_nodes
argument_list|)
decl_stmt|;
name|int
name|order_pos
init|=
name|order_pos
operator|=
name|ipa_utils_reduced_inorder
argument_list|(
name|order
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ipa_dfs_info
modifier|*
name|w_info
decl_stmt|;
if|if
condition|(
operator|!
name|memory_identifier_string
condition|)
name|memory_identifier_string
operator|=
name|build_string
argument_list|(
literal|7
argument_list|,
literal|"memory"
argument_list|)
expr_stmt|;
comment|/* There are some shared nodes, in particular the initializers on      static declarations.  We do not need to scan them more than once      since all we would be interested in are the addressof      operations.  */
name|visited_nodes
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
comment|/* Process all of the functions.        We do not want to process any of the clones so we check that this      is a master clone.  However, we do NOT process any      AVAIL_OVERWRITABLE functions (these are never clones) we cannot      guarantee that what we learn about the one we see will be true      for the one that overriders it.   */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
name|cgraph_is_master_clone
argument_list|(
name|node
argument_list|)
condition|)
name|analyze_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_cgraph
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|ipa_utils_print_order
argument_list|(
name|dump_file
argument_list|,
literal|"reduced"
argument_list|,
name|order
argument_list|,
name|order_pos
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate the local information thru the call graph to produce      the global information.  All the nodes within a cycle will have      the same info so we collapse cycles first.  Then we can do the      propagation in one pass from the leaves to the roots.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|order_pos
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|pure_const_state_e
name|pure_const_state
init|=
name|IPA_CONST
decl_stmt|;
name|node
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
comment|/* Find the worst state for any node in the cycle.  */
name|w
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|funct_state
name|w_l
init|=
name|get_function_state
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|pure_const_state
operator|<
name|w_l
operator|->
name|pure_const_state
condition|)
name|pure_const_state
operator|=
name|w_l
operator|->
name|pure_const_state
expr_stmt|;
if|if
condition|(
name|pure_const_state
operator|==
name|IPA_NEITHER
condition|)
break|break;
if|if
condition|(
operator|!
name|w_l
operator|->
name|state_set_in_source
condition|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|w
operator|->
name|callees
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next_callee
control|)
block|{
name|struct
name|cgraph_node
modifier|*
name|y
init|=
name|e
operator|->
name|callee
decl_stmt|;
comment|/* Only look at the master nodes and skip external nodes.  */
name|y
operator|=
name|cgraph_master_clone
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
condition|)
block|{
name|funct_state
name|y_l
init|=
name|get_function_state
argument_list|(
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|pure_const_state
operator|<
name|y_l
operator|->
name|pure_const_state
condition|)
name|pure_const_state
operator|=
name|y_l
operator|->
name|pure_const_state
expr_stmt|;
if|if
condition|(
name|pure_const_state
operator|==
name|IPA_NEITHER
condition|)
break|break;
block|}
block|}
block|}
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
block|}
comment|/* Copy back the region's pure_const_state which is shared by 	 all nodes in the region.  */
name|w
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|funct_state
name|w_l
init|=
name|get_function_state
argument_list|(
name|w
argument_list|)
decl_stmt|;
comment|/* All nodes within a cycle share the same info.  */
if|if
condition|(
operator|!
name|w_l
operator|->
name|state_set_in_source
condition|)
block|{
name|w_l
operator|->
name|pure_const_state
operator|=
name|pure_const_state
expr_stmt|;
switch|switch
condition|(
name|pure_const_state
condition|)
block|{
case|case
name|IPA_CONST
case|:
name|TREE_READONLY
argument_list|(
name|w
operator|->
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Function found to be const: %s\n"
argument_list|,
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|w
operator|->
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPA_PURE
case|:
name|DECL_IS_PURE
argument_list|(
name|w
operator|->
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Function found to be pure: %s\n"
argument_list|,
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|w
operator|->
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
name|w
operator|=
name|w_info
operator|->
name|next_cycle
expr_stmt|;
block|}
block|}
comment|/* Cleanup. */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
comment|/* Get rid of the aux information.  */
if|if
condition|(
name|node
operator|->
name|aux
condition|)
block|{
name|w_info
operator|=
name|node
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|w_info
operator|->
name|aux
condition|)
name|free
argument_list|(
name|w_info
operator|->
name|aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|aux
argument_list|)
expr_stmt|;
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|order
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_pure_const
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|flag_unit_at_a_time
operator|!=
literal|0
operator|&&
name|flag_ipa_pure_const
comment|/* Don't bother doing anything if the program has errors.  */
operator|&&
operator|!
operator|(
name|errorcount
operator|||
name|sorrycount
operator|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ipa_pure_const
init|=
block|{
literal|"pure-const"
block|,
comment|/* name */
name|gate_pure_const
block|,
comment|/* gate */
name|static_execute
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IPA_PURE_CONST
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

