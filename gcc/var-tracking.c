begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Variable tracking routines for the GNU compiler.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains the variable tracking pass.  It computes where    variables are located (which registers or where in memory) at each position    in instruction stream and emits notes describing the locations.    Debug information (DWARF2 location lists) is finally generated from    these notes.    With this debug information, it is possible to show variables    even when debugging optimized code.     How does the variable tracking pass work?     First, it scans RTL code for uses, stores and clobbers (register/memory    references in instructions), for call insns and for stack adjustments    separately for each basic block and saves them to an array of micro    operations.    The micro operations of one instruction are ordered so that    pre-modifying stack adjustment< use< use with no var< call insn<< set< clobber< post-modifying stack adjustment     Then, a forward dataflow analysis is performed to find out how locations    of variables change through code and to propagate the variable locations    along control flow graph.    The IN set for basic block BB is computed as a union of OUT sets of BB's    predecessors, the OUT set for BB is copied from the IN set for BB and    is changed according to micro operations in BB.     The IN and OUT sets for basic blocks consist of a current stack adjustment    (used for adjusting offset of variables addressed using stack pointer),    the table of structures describing the locations of parts of a variable    and for each physical register a linked list for each physical register.    The linked list is a list of variable parts stored in the register,    i.e. it is a list of triplets (reg, decl, offset) where decl is    REG_EXPR (reg) and offset is REG_OFFSET (reg).  The linked list is used for    effective deleting appropriate variable parts when we set or clobber the    register.     There may be more than one variable part in a register.  The linked lists    should be pretty short so it is a good data structure here.    For example in the following code, register allocator may assign same    register to variables A and B, and both of them are stored in the same    register in CODE:       if (cond)        set A;      else        set B;      CODE;      if (cond)        use A;      else        use B;     Finally, the NOTE_INSN_VAR_LOCATION notes describing the variable locations    are emitted to appropriate positions in RTL code.  Each such a note describes    the location of one variable at the point in instruction stream where the    note is.  There is no need to emit a note for each variable before each    instruction, we only emit these notes where the location of variable changes    (this means that we also emit notes for changes between the OUT set of the    previous block and the IN set of the current block).     The notes consist of two parts:    1. the declaration (from REG_EXPR or MEM_EXPR)    2. the location of a variable - it is either a simple register/memory       reference (for simple variables, for example int),       or a parallel of register/memory references (for a large variables       which consist of several parts, for example long long).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* Type of micro operation.  */
end_comment

begin_enum
enum|enum
name|micro_operation_type
block|{
name|MO_USE
block|,
comment|/* Use location (REG or MEM).  */
name|MO_USE_NO_VAR
block|,
comment|/* Use location which is not associated with a variable 		   or the variable is not trackable.  */
name|MO_SET
block|,
comment|/* Set location.  */
name|MO_COPY
block|,
comment|/* Copy the same portion of a variable from one 		   location to another.  */
name|MO_CLOBBER
block|,
comment|/* Clobber location.  */
name|MO_CALL
block|,
comment|/* Call insn.  */
name|MO_ADJUST
comment|/* Adjust stack pointer.  */
block|}
enum|;
end_enum

begin_comment
comment|/* Where shall the note be emitted?  BEFORE or AFTER the instruction.  */
end_comment

begin_enum
enum|enum
name|emit_note_where
block|{
name|EMIT_NOTE_BEFORE_INSN
block|,
name|EMIT_NOTE_AFTER_INSN
block|}
enum|;
end_enum

begin_comment
comment|/* Structure holding information about micro operation.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|micro_operation_def
block|{
comment|/* Type of micro operation.  */
name|enum
name|micro_operation_type
name|type
decl_stmt|;
union|union
block|{
comment|/* Location.  */
name|rtx
name|loc
decl_stmt|;
comment|/* Stack adjustment.  */
name|HOST_WIDE_INT
name|adjust
decl_stmt|;
block|}
name|u
union|;
comment|/* The instruction which the micro operation is in, for MO_USE,      MO_USE_NO_VAR, MO_CALL and MO_ADJUST, or the subsequent      instruction or note in the original flow (before any var-tracking      notes are inserted, to simplify emission of notes), for MO_SET      and MO_CLOBBER.  */
name|rtx
name|insn
decl_stmt|;
block|}
name|micro_operation
typedef|;
end_typedef

begin_comment
comment|/* Structure for passing some other parameters to function    emit_note_insn_var_location.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|emit_note_data_def
block|{
comment|/* The instruction which the note will be emitted before/after.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Where the note will be emitted (before/after insn)?  */
name|enum
name|emit_note_where
name|where
decl_stmt|;
block|}
name|emit_note_data
typedef|;
end_typedef

begin_comment
comment|/* Description of location of a part of a variable.  The content of a physical    register is described by a chain of these structures.    The chains are pretty short (usually 1 or 2 elements) and thus    chain is the best data structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|attrs_def
block|{
comment|/* Pointer to next member of the list.  */
name|struct
name|attrs_def
modifier|*
name|next
decl_stmt|;
comment|/* The rtx of register.  */
name|rtx
name|loc
decl_stmt|;
comment|/* The declaration corresponding to LOC.  */
name|tree
name|decl
decl_stmt|;
comment|/* Offset from start of DECL.  */
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
typedef|*
name|attrs
typedef|;
end_typedef

begin_comment
comment|/* Structure holding the IN or OUT set for a basic block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dataflow_set_def
block|{
comment|/* Adjustment of stack offset.  */
name|HOST_WIDE_INT
name|stack_adjust
decl_stmt|;
comment|/* Attributes for registers (lists of attrs).  */
name|attrs
name|regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
comment|/* Variable locations.  */
name|htab_t
name|vars
decl_stmt|;
block|}
name|dataflow_set
typedef|;
end_typedef

begin_comment
comment|/* The structure (one for each basic block) containing the information    needed for variable tracking.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|variable_tracking_info_def
block|{
comment|/* Number of micro operations stored in the MOS array.  */
name|int
name|n_mos
decl_stmt|;
comment|/* The array of micro operations.  */
name|micro_operation
modifier|*
name|mos
decl_stmt|;
comment|/* The IN and OUT set for dataflow analysis.  */
name|dataflow_set
name|in
decl_stmt|;
name|dataflow_set
name|out
decl_stmt|;
comment|/* Has the block been visited in DFS?  */
name|bool
name|visited
decl_stmt|;
block|}
typedef|*
name|variable_tracking_info
typedef|;
end_typedef

begin_comment
comment|/* Structure for chaining the locations.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|location_chain_def
block|{
comment|/* Next element in the chain.  */
name|struct
name|location_chain_def
modifier|*
name|next
decl_stmt|;
comment|/* The location (REG or MEM).  */
name|rtx
name|loc
decl_stmt|;
block|}
typedef|*
name|location_chain
typedef|;
end_typedef

begin_comment
comment|/* Structure describing one part of variable.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|variable_part_def
block|{
comment|/* Chain of locations of the part.  */
name|location_chain
name|loc_chain
decl_stmt|;
comment|/* Location which was last emitted to location list.  */
name|rtx
name|cur_loc
decl_stmt|;
comment|/* The offset in the variable.  */
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
name|variable_part
typedef|;
end_typedef

begin_comment
comment|/* Maximum number of location parts.  */
end_comment

begin_define
define|#
directive|define
name|MAX_VAR_PARTS
value|16
end_define

begin_comment
comment|/* Structure describing where the variable is located.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|variable_def
block|{
comment|/* The declaration of the variable.  */
name|tree
name|decl
decl_stmt|;
comment|/* Reference count.  */
name|int
name|refcount
decl_stmt|;
comment|/* Number of variable parts.  */
name|int
name|n_var_parts
decl_stmt|;
comment|/* The variable parts.  */
name|variable_part
name|var_part
index|[
name|MAX_VAR_PARTS
index|]
decl_stmt|;
block|}
typedef|*
name|variable
typedef|;
end_typedef

begin_comment
comment|/* Hash function for DECL for VARIABLE_HTAB.  */
end_comment

begin_define
define|#
directive|define
name|VARIABLE_HASH_VAL
parameter_list|(
name|decl
parameter_list|)
value|(DECL_UID (decl))
end_define

begin_comment
comment|/* Pointer to the BB's information specific to variable tracking pass.  */
end_comment

begin_define
define|#
directive|define
name|VTI
parameter_list|(
name|BB
parameter_list|)
value|((variable_tracking_info) (BB)->aux)
end_define

begin_comment
comment|/* Alloc pool for struct attrs_def.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|attrs_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alloc pool for struct variable_def.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|var_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alloc pool for struct location_chain_def.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|loc_chain_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Changed variables, notes will be emitted for them.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|changed_variables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Shall notes be emitted?  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|emit_notes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|stack_adjust_offset_pre_post
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insn_stack_adjust_offset_pre_post
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bb_stack_adjust_offset
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vt_stack_adjustments
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|adjust_stack_reference
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|variable_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|variable_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|variable_htab_free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_attrs_list_set
parameter_list|(
name|attrs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attrs_list_clear
parameter_list|(
name|attrs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|attrs
name|attrs_list_member
parameter_list|(
name|attrs
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attrs_list_insert
parameter_list|(
name|attrs
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attrs_list_copy
parameter_list|(
name|attrs
modifier|*
parameter_list|,
name|attrs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attrs_list_union
parameter_list|(
name|attrs
modifier|*
parameter_list|,
name|attrs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vars_clear
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|variable
name|unshare_variable
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|variable
name|var
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vars_copy_1
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vars_copy
parameter_list|(
name|htab_t
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|var_debug_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|var_reg_set
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|var_reg_delete_and_set
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|var_reg_delete
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|var_regno_delete
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|var_mem_set
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|var_mem_delete_and_set
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|var_mem_delete
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dataflow_set_init
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dataflow_set_clear
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dataflow_set_copy
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|dataflow_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|variable_union_info_cmp_pos
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|variable_union
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dataflow_set_union
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|dataflow_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|variable_part_different_p
parameter_list|(
name|variable_part
modifier|*
parameter_list|,
name|variable_part
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|variable_different_p
parameter_list|(
name|variable
parameter_list|,
name|variable
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dataflow_set_different_1
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dataflow_set_different_2
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|dataflow_set_different
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|dataflow_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dataflow_set_destroy
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|contains_symbol_ref
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|track_expr_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|same_variable_part_p
parameter_list|(
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_uses
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|count_uses_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|count_stores
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_uses
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_uses_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_stores
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|compute_bb_dataflow
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vt_find_locations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_attrs_list
parameter_list|(
name|attrs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_variable
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_vars
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dataflow_set
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_dataflow_sets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|variable_was_changed
parameter_list|(
name|variable
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_variable_part
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clobber_variable_part
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_variable_part
parameter_list|(
name|dataflow_set
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emit_note_insn_var_location
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_notes_for_changes
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|emit_note_where
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emit_notes_for_differences_1
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emit_notes_for_differences_2
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_notes_for_differences
parameter_list|(
name|rtx
parameter_list|,
name|dataflow_set
modifier|*
parameter_list|,
name|dataflow_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_notes_in_bb
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vt_emit_notes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vt_get_decl_and_offset
parameter_list|(
name|rtx
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vt_add_function_parameters
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vt_initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vt_finalize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Given a SET, calculate the amount of stack adjustment it contains    PRE- and POST-modifying stack pointer.    This function is similar to stack_adjust_offset.  */
end_comment

begin_function
specifier|static
name|void
name|stack_adjust_offset_pre_post
parameter_list|(
name|rtx
name|pattern
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pre
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|post
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* (set (reg sp) (plus (reg sp) (const_int))) */
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
operator|*
name|post
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|post
operator|-=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* (set (mem (pre_dec (reg sp))) (foo)) */
name|src
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|rtx
name|val
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We handle only adjustments by constant amount.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PRE_MODIFY
condition|)
operator|*
name|pre
operator|-=
name|INTVAL
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
operator|*
name|post
operator|-=
name|INTVAL
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
name|PRE_DEC
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
operator|*
name|pre
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
name|POST_DEC
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
operator|*
name|post
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
name|PRE_INC
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
operator|*
name|pre
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
name|POST_INC
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
operator|*
name|post
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
default|default:
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given an INSN, calculate the amount of stack adjustment it contains    PRE- and POST-modifying stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|insn_stack_adjust_offset_pre_post
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|pre
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|post
parameter_list|)
block|{
operator|*
name|pre
operator|=
literal|0
expr_stmt|;
operator|*
name|post
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|stack_adjust_offset_pre_post
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pre
argument_list|,
name|post
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* There may be stack adjustments inside compound insns.  Search 	 for them.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|stack_adjust_offset_pre_post
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|pre
argument_list|,
name|post
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute stack adjustment in basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|bb_stack_adjust_offset
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
operator|.
name|stack_adjust
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|type
operator|==
name|MO_ADJUST
condition|)
name|offset
operator|+=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|adjust
expr_stmt|;
elseif|else
if|if
condition|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|MO_CALL
condition|)
block|{
if|if
condition|(
name|MEM_P
argument_list|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
argument_list|)
condition|)
block|{
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
operator|=
name|adjust_stack_reference
argument_list|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|out
operator|.
name|stack_adjust
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute stack adjustments for all blocks by traversing DFS tree.    Return true when the adjustments on all incoming edges are consistent.    Heavily borrowed from pre_and_rev_post_order_compute.  */
end_comment

begin_function
specifier|static
name|bool
name|vt_stack_adjustments
parameter_list|(
name|void
parameter_list|)
block|{
name|edge_iterator
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
comment|/* Initialize entry block.  */
name|VTI
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|visited
operator|=
name|true
expr_stmt|;
name|VTI
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|out
operator|.
name|stack_adjust
operator|=
name|INCOMING_FRAME_SP_OFFSET
expr_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|edge_iterator
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|ei
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|dest
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
operator|!
name|VTI
argument_list|(
name|dest
argument_list|)
operator|->
name|visited
condition|)
block|{
name|VTI
argument_list|(
name|dest
argument_list|)
operator|->
name|visited
operator|=
name|true
expr_stmt|;
name|VTI
argument_list|(
name|dest
argument_list|)
operator|->
name|in
operator|.
name|stack_adjust
operator|=
name|VTI
argument_list|(
name|src
argument_list|)
operator|->
name|out
operator|.
name|stack_adjust
expr_stmt|;
name|bb_stack_adjust_offset
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
comment|/* Since the DEST node has been visited for the first 	       time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check whether the adjustments on the edges are the same.  */
if|if
condition|(
name|VTI
argument_list|(
name|dest
argument_list|)
operator|->
name|in
operator|.
name|stack_adjust
operator|!=
name|VTI
argument_list|(
name|src
argument_list|)
operator|->
name|out
operator|.
name|stack_adjust
condition|)
block|{
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ei_one_before_end_p
argument_list|(
name|ei
argument_list|)
condition|)
comment|/* Go to the next edge.  */
name|ei_next
argument_list|(
operator|&
name|stack
index|[
name|sp
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* Return to previous level if there are no more edges.  */
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust stack reference MEM by ADJUSTMENT bytes and make it relative    to the argument pointer.  Return the new rtx.  */
end_comment

begin_function
specifier|static
name|rtx
name|adjust_stack_reference
parameter_list|(
name|rtx
name|mem
parameter_list|,
name|HOST_WIDE_INT
name|adjustment
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|cfa
decl_stmt|,
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAME_POINTER_CFA_OFFSET
name|adjustment
operator|-=
name|FRAME_POINTER_CFA_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|cfa
operator|=
name|plus_constant
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|adjustment
argument_list|)
expr_stmt|;
else|#
directive|else
name|adjustment
operator|-=
name|ARG_POINTER_CFA_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|cfa
operator|=
name|plus_constant
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|adjustment
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|replace_rtx
argument_list|(
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|cfa
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|simplify_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|addr
operator|=
name|tmp
expr_stmt|;
return|return
name|replace_equiv_address_nv
argument_list|(
name|mem
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The hash function for variable_htab, computes the hash value    from the declaration of variable X.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|variable_htab_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|variable
name|v
init|=
operator|(
specifier|const
name|variable
operator|)
name|x
decl_stmt|;
return|return
operator|(
name|VARIABLE_HASH_VAL
argument_list|(
name|v
operator|->
name|decl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the declaration of variable X with declaration Y.  */
end_comment

begin_function
specifier|static
name|int
name|variable_htab_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
specifier|const
name|variable
name|v
init|=
operator|(
specifier|const
name|variable
operator|)
name|x
decl_stmt|;
specifier|const
name|tree
name|decl
init|=
operator|(
specifier|const
name|tree
operator|)
name|y
decl_stmt|;
return|return
operator|(
name|VARIABLE_HASH_VAL
argument_list|(
name|v
operator|->
name|decl
argument_list|)
operator|==
name|VARIABLE_HASH_VAL
argument_list|(
name|decl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free the element of VARIABLE_HTAB (its type is struct variable_def).  */
end_comment

begin_function
specifier|static
name|void
name|variable_htab_free
parameter_list|(
name|void
modifier|*
name|elem
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|variable
name|var
init|=
operator|(
name|variable
operator|)
name|elem
decl_stmt|;
name|location_chain
name|node
decl_stmt|,
name|next
decl_stmt|;
name|gcc_assert
argument_list|(
name|var
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|var
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|refcount
operator|>
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var
operator|->
name|n_var_parts
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|node
operator|=
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|pool_free
argument_list|(
name|loc_chain_pool
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
operator|=
name|NULL
expr_stmt|;
block|}
name|pool_free
argument_list|(
name|var_pool
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the set (array) SET of attrs to empty lists.  */
end_comment

begin_function
specifier|static
name|void
name|init_attrs_list_set
parameter_list|(
name|attrs
modifier|*
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|set
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the list *LISTP empty.  */
end_comment

begin_function
specifier|static
name|void
name|attrs_list_clear
parameter_list|(
name|attrs
modifier|*
name|listp
parameter_list|)
block|{
name|attrs
name|list
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|list
operator|=
operator|*
name|listp
init|;
name|list
condition|;
name|list
operator|=
name|next
control|)
block|{
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|pool_free
argument_list|(
name|attrs_pool
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
operator|*
name|listp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the pair of DECL and OFFSET is the member of the LIST.  */
end_comment

begin_function
specifier|static
name|attrs
name|attrs_list_member
parameter_list|(
name|attrs
name|list
parameter_list|,
name|tree
name|decl
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
name|list
operator|->
name|decl
operator|==
name|decl
operator|&&
name|list
operator|->
name|offset
operator|==
name|offset
condition|)
return|return
name|list
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert the triplet DECL, OFFSET, LOC to the list *LISTP.  */
end_comment

begin_function
specifier|static
name|void
name|attrs_list_insert
parameter_list|(
name|attrs
modifier|*
name|listp
parameter_list|,
name|tree
name|decl
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|rtx
name|loc
parameter_list|)
block|{
name|attrs
name|list
decl_stmt|;
name|list
operator|=
name|pool_alloc
argument_list|(
name|attrs_pool
argument_list|)
expr_stmt|;
name|list
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|list
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|list
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|list
operator|->
name|next
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
name|list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy all nodes from SRC and create a list *DSTP of the copies.  */
end_comment

begin_function
specifier|static
name|void
name|attrs_list_copy
parameter_list|(
name|attrs
modifier|*
name|dstp
parameter_list|,
name|attrs
name|src
parameter_list|)
block|{
name|attrs
name|n
decl_stmt|;
name|attrs_list_clear
argument_list|(
name|dstp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
name|n
operator|=
name|pool_alloc
argument_list|(
name|attrs_pool
argument_list|)
expr_stmt|;
name|n
operator|->
name|loc
operator|=
name|src
operator|->
name|loc
expr_stmt|;
name|n
operator|->
name|decl
operator|=
name|src
operator|->
name|decl
expr_stmt|;
name|n
operator|->
name|offset
operator|=
name|src
operator|->
name|offset
expr_stmt|;
name|n
operator|->
name|next
operator|=
operator|*
name|dstp
expr_stmt|;
operator|*
name|dstp
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add all nodes from SRC which are not in *DSTP to *DSTP.  */
end_comment

begin_function
specifier|static
name|void
name|attrs_list_union
parameter_list|(
name|attrs
modifier|*
name|dstp
parameter_list|,
name|attrs
name|src
parameter_list|)
block|{
for|for
control|(
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|attrs_list_member
argument_list|(
operator|*
name|dstp
argument_list|,
name|src
operator|->
name|decl
argument_list|,
name|src
operator|->
name|offset
argument_list|)
condition|)
name|attrs_list_insert
argument_list|(
name|dstp
argument_list|,
name|src
operator|->
name|decl
argument_list|,
name|src
operator|->
name|offset
argument_list|,
name|src
operator|->
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all variables from hash table VARS.  */
end_comment

begin_function
specifier|static
name|void
name|vars_clear
parameter_list|(
name|htab_t
name|vars
parameter_list|)
block|{
name|htab_empty
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a copy of a variable VAR and insert it to dataflow set SET.  */
end_comment

begin_function
specifier|static
name|variable
name|unshare_variable
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|variable
name|var
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|variable
name|new_var
decl_stmt|;
name|int
name|i
decl_stmt|;
name|new_var
operator|=
name|pool_alloc
argument_list|(
name|var_pool
argument_list|)
expr_stmt|;
name|new_var
operator|->
name|decl
operator|=
name|var
operator|->
name|decl
expr_stmt|;
name|new_var
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|var
operator|->
name|refcount
operator|--
expr_stmt|;
name|new_var
operator|->
name|n_var_parts
operator|=
name|var
operator|->
name|n_var_parts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var
operator|->
name|n_var_parts
condition|;
name|i
operator|++
control|)
block|{
name|location_chain
name|node
decl_stmt|;
name|location_chain
modifier|*
name|nextp
decl_stmt|;
name|new_var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|nextp
operator|=
operator|&
name|new_var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
expr_stmt|;
for|for
control|(
name|node
operator|=
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|location_chain
name|new_lc
decl_stmt|;
name|new_lc
operator|=
name|pool_alloc
argument_list|(
name|loc_chain_pool
argument_list|)
expr_stmt|;
name|new_lc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_lc
operator|->
name|loc
operator|=
name|node
operator|->
name|loc
expr_stmt|;
operator|*
name|nextp
operator|=
name|new_lc
expr_stmt|;
name|nextp
operator|=
operator|&
name|new_lc
operator|->
name|next
expr_stmt|;
block|}
comment|/* We are at the basic block boundary when copying variable description 	 so set the CUR_LOC to be the first element of the chain.  */
if|if
condition|(
name|new_var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
condition|)
name|new_var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
operator|=
name|new_var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
operator|->
name|loc
expr_stmt|;
else|else
name|new_var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
operator|=
name|NULL
expr_stmt|;
block|}
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|set
operator|->
name|vars
argument_list|,
name|new_var
operator|->
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|new_var
operator|->
name|decl
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|new_var
expr_stmt|;
return|return
name|new_var
return|;
block|}
end_function

begin_comment
comment|/* Add a variable from *SLOT to hash table DATA and increase its reference    count.  */
end_comment

begin_function
specifier|static
name|int
name|vars_copy_1
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|htab_t
name|dst
init|=
operator|(
name|htab_t
operator|)
name|data
decl_stmt|;
name|variable
name|src
decl_stmt|,
modifier|*
name|dstp
decl_stmt|;
name|src
operator|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|slot
expr_stmt|;
name|src
operator|->
name|refcount
operator|++
expr_stmt|;
name|dstp
operator|=
operator|(
name|variable
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|dst
argument_list|,
name|src
operator|->
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|src
operator|->
name|decl
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|dstp
operator|=
name|src
expr_stmt|;
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copy all variables from hash table SRC to hash table DST.  */
end_comment

begin_function
specifier|static
name|void
name|vars_copy
parameter_list|(
name|htab_t
name|dst
parameter_list|,
name|htab_t
name|src
parameter_list|)
block|{
name|vars_clear
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|src
argument_list|,
name|vars_copy_1
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map a decl to its main debug decl.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|var_debug_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|DECL_DEBUG_EXPR
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|decl
operator|=
name|DECL_DEBUG_EXPR
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */
end_comment

begin_function
specifier|static
name|void
name|var_reg_set
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|)
block|{
name|tree
name|decl
init|=
name|REG_EXPR
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|REG_OFFSET
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|attrs
name|node
decl_stmt|;
name|decl
operator|=
name|var_debug_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|set
operator|->
name|regs
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|decl
operator|==
name|decl
operator|&&
name|node
operator|->
name|offset
operator|==
name|offset
condition|)
break|break;
if|if
condition|(
operator|!
name|node
condition|)
name|attrs_list_insert
argument_list|(
operator|&
name|set
operator|->
name|regs
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|set_variable_part
argument_list|(
name|set
argument_list|,
name|loc
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete current content of register LOC in dataflow set SET and set    the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  If    MODIFY is true, any other live copies of the same variable part are    also deleted from the dataflow set, otherwise the variable part is    assumed to be copied from another location holding the same    part.  */
end_comment

begin_function
specifier|static
name|void
name|var_reg_delete_and_set
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|,
name|bool
name|modify
parameter_list|)
block|{
name|tree
name|decl
init|=
name|REG_EXPR
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|REG_OFFSET
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|attrs
name|node
decl_stmt|,
name|next
decl_stmt|;
name|attrs
modifier|*
name|nextp
decl_stmt|;
name|decl
operator|=
name|var_debug_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|nextp
operator|=
operator|&
name|set
operator|->
name|regs
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|node
operator|=
operator|*
name|nextp
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|decl
operator|!=
name|decl
operator|||
name|node
operator|->
name|offset
operator|!=
name|offset
condition|)
block|{
name|delete_variable_part
argument_list|(
name|set
argument_list|,
name|node
operator|->
name|loc
argument_list|,
name|node
operator|->
name|decl
argument_list|,
name|node
operator|->
name|offset
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|attrs_pool
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nextp
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|nextp
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|modify
condition|)
name|clobber_variable_part
argument_list|(
name|set
argument_list|,
name|loc
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|var_reg_set
argument_list|(
name|set
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete current content of register LOC in dataflow set SET.  If    CLOBBER is true, also delete any other live copies of the same    variable part.  */
end_comment

begin_function
specifier|static
name|void
name|var_reg_delete
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|,
name|bool
name|clobber
parameter_list|)
block|{
name|attrs
modifier|*
name|reg
init|=
operator|&
name|set
operator|->
name|regs
index|[
name|REGNO
argument_list|(
name|loc
argument_list|)
index|]
decl_stmt|;
name|attrs
name|node
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|clobber
condition|)
block|{
name|tree
name|decl
init|=
name|REG_EXPR
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|REG_OFFSET
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|decl
operator|=
name|var_debug_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|clobber_variable_part
argument_list|(
name|set
argument_list|,
name|NULL
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|node
operator|=
operator|*
name|reg
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|delete_variable_part
argument_list|(
name|set
argument_list|,
name|node
operator|->
name|loc
argument_list|,
name|node
operator|->
name|decl
argument_list|,
name|node
operator|->
name|offset
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|attrs_pool
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
operator|*
name|reg
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete content of register with number REGNO in dataflow set SET.  */
end_comment

begin_function
specifier|static
name|void
name|var_regno_delete
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|attrs
modifier|*
name|reg
init|=
operator|&
name|set
operator|->
name|regs
index|[
name|regno
index|]
decl_stmt|;
name|attrs
name|node
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|node
operator|=
operator|*
name|reg
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|delete_variable_part
argument_list|(
name|set
argument_list|,
name|node
operator|->
name|loc
argument_list|,
name|node
operator|->
name|decl
argument_list|,
name|node
operator|->
name|offset
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|attrs_pool
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
operator|*
name|reg
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the location part of variable MEM_EXPR (LOC) in dataflow set    SET to LOC.    Adjust the address first if it is stack pointer based.  */
end_comment

begin_function
specifier|static
name|void
name|var_mem_set
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|)
block|{
name|tree
name|decl
init|=
name|MEM_EXPR
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
argument_list|)
else|:
literal|0
decl_stmt|;
name|decl
operator|=
name|var_debug_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|set_variable_part
argument_list|(
name|set
argument_list|,
name|loc
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete and set the location part of variable MEM_EXPR (LOC) in    dataflow set SET to LOC.  If MODIFY is true, any other live copies    of the same variable part are also deleted from the dataflow set,    otherwise the variable part is assumed to be copied from another    location holding the same part.    Adjust the address first if it is stack pointer based.  */
end_comment

begin_function
specifier|static
name|void
name|var_mem_delete_and_set
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|,
name|bool
name|modify
parameter_list|)
block|{
name|tree
name|decl
init|=
name|MEM_EXPR
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
argument_list|)
else|:
literal|0
decl_stmt|;
name|decl
operator|=
name|var_debug_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|modify
condition|)
name|clobber_variable_part
argument_list|(
name|set
argument_list|,
name|NULL
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|var_mem_set
argument_list|(
name|set
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the location part LOC from dataflow set SET.  If CLOBBER is    true, also delete any other live copies of the same variable part.    Adjust the address first if it is stack pointer based.  */
end_comment

begin_function
specifier|static
name|void
name|var_mem_delete
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|,
name|bool
name|clobber
parameter_list|)
block|{
name|tree
name|decl
init|=
name|MEM_EXPR
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
argument_list|)
else|:
literal|0
decl_stmt|;
name|decl
operator|=
name|var_debug_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber
condition|)
name|clobber_variable_part
argument_list|(
name|set
argument_list|,
name|NULL
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|delete_variable_part
argument_list|(
name|set
argument_list|,
name|loc
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize dataflow set SET to be empty.     VARS_SIZE is the initial size of hash table VARS.  */
end_comment

begin_function
specifier|static
name|void
name|dataflow_set_init
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|int
name|vars_size
parameter_list|)
block|{
name|init_attrs_list_set
argument_list|(
name|set
operator|->
name|regs
argument_list|)
expr_stmt|;
name|set
operator|->
name|vars
operator|=
name|htab_create
argument_list|(
name|vars_size
argument_list|,
name|variable_htab_hash
argument_list|,
name|variable_htab_eq
argument_list|,
name|variable_htab_free
argument_list|)
expr_stmt|;
name|set
operator|->
name|stack_adjust
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the contents of dataflow set SET.  */
end_comment

begin_function
specifier|static
name|void
name|dataflow_set_clear
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|attrs_list_clear
argument_list|(
operator|&
name|set
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vars_clear
argument_list|(
name|set
operator|->
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the contents of dataflow set SRC to DST.  */
end_comment

begin_function
specifier|static
name|void
name|dataflow_set_copy
parameter_list|(
name|dataflow_set
modifier|*
name|dst
parameter_list|,
name|dataflow_set
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|attrs_list_copy
argument_list|(
operator|&
name|dst
operator|->
name|regs
index|[
name|i
index|]
argument_list|,
name|src
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vars_copy
argument_list|(
name|dst
operator|->
name|vars
argument_list|,
name|src
operator|->
name|vars
argument_list|)
expr_stmt|;
name|dst
operator|->
name|stack_adjust
operator|=
name|src
operator|->
name|stack_adjust
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Information for merging lists of locations for a given offset of variable.  */
end_comment

begin_struct
struct|struct
name|variable_union_info
block|{
comment|/* Node of the location chain.  */
name|location_chain
name|lc
decl_stmt|;
comment|/* The sum of positions in the input chains.  */
name|int
name|pos
decl_stmt|;
comment|/* The position in the chains of SRC and DST dataflow sets.  */
name|int
name|pos_src
decl_stmt|;
name|int
name|pos_dst
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compare function for qsort, order the structures by POS element.  */
end_comment

begin_function
specifier|static
name|int
name|variable_union_info_cmp_pos
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|variable_union_info
modifier|*
name|i1
init|=
name|n1
decl_stmt|;
specifier|const
name|struct
name|variable_union_info
modifier|*
name|i2
init|=
name|n2
decl_stmt|;
if|if
condition|(
name|i1
operator|->
name|pos
operator|!=
name|i2
operator|->
name|pos
condition|)
return|return
name|i1
operator|->
name|pos
operator|-
name|i2
operator|->
name|pos
return|;
return|return
operator|(
name|i1
operator|->
name|pos_dst
operator|-
name|i2
operator|->
name|pos_dst
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute union of location parts of variable *SLOT and the same variable    from hash table DATA.  Compute "sorted" union of the location chains    for common offsets, i.e. the locations of a variable part are sorted by    a priority where the priority is the sum of the positions in the 2 chains    (if a location is only in one list the position in the second list is    defined to be larger than the length of the chains).    When we are updating the location parts the newest location is in the    beginning of the chain, so when we do the described "sorted" union    we keep the newest locations in the beginning.  */
end_comment

begin_function
specifier|static
name|int
name|variable_union
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|variable
name|src
decl_stmt|,
name|dst
decl_stmt|,
modifier|*
name|dstp
decl_stmt|;
name|dataflow_set
modifier|*
name|set
init|=
operator|(
name|dataflow_set
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|src
operator|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|slot
expr_stmt|;
name|dstp
operator|=
operator|(
name|variable
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|set
operator|->
name|vars
argument_list|,
name|src
operator|->
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|src
operator|->
name|decl
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|dstp
condition|)
block|{
name|src
operator|->
name|refcount
operator|++
expr_stmt|;
comment|/* If CUR_LOC of some variable part is not the first element of 	 the location chain we are going to change it so we have to make 	 a copy of the variable.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|src
operator|->
name|n_var_parts
condition|;
name|k
operator|++
control|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|src
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|loc_chain
operator|==
operator|!
name|src
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|cur_loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|loc_chain
condition|)
block|{
name|gcc_assert
argument_list|(
name|src
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|cur_loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|cur_loc
operator|!=
name|src
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|loc_chain
operator|->
name|loc
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|k
operator|<
name|src
operator|->
name|n_var_parts
condition|)
name|unshare_variable
argument_list|(
name|set
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
operator|*
name|dstp
operator|=
name|src
expr_stmt|;
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
else|else
name|dst
operator|=
operator|*
name|dstp
expr_stmt|;
name|gcc_assert
argument_list|(
name|src
operator|->
name|n_var_parts
argument_list|)
expr_stmt|;
comment|/* Count the number of location parts, result is K.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|n_var_parts
operator|&&
name|j
operator|<
name|dst
operator|->
name|n_var_parts
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
operator|==
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
operator|<
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
condition|)
name|i
operator|++
expr_stmt|;
else|else
name|j
operator|++
expr_stmt|;
block|}
name|k
operator|+=
name|src
operator|->
name|n_var_parts
operator|-
name|i
expr_stmt|;
name|k
operator|+=
name|dst
operator|->
name|n_var_parts
operator|-
name|j
expr_stmt|;
comment|/* We track only variables whose size is<= MAX_VAR_PARTS bytes      thus there are at most MAX_VAR_PARTS different offsets.  */
name|gcc_assert
argument_list|(
name|k
operator|<=
name|MAX_VAR_PARTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|refcount
operator|>
literal|1
operator|&&
name|dst
operator|->
name|n_var_parts
operator|!=
name|k
condition|)
name|dst
operator|=
name|unshare_variable
argument_list|(
name|set
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|i
operator|=
name|src
operator|->
name|n_var_parts
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|dst
operator|->
name|n_var_parts
operator|-
literal|1
expr_stmt|;
name|dst
operator|->
name|n_var_parts
operator|=
name|k
expr_stmt|;
for|for
control|(
name|k
operator|--
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
block|{
name|location_chain
name|node
decl_stmt|,
name|node2
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|j
operator|>=
literal|0
operator|&&
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
operator|==
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
condition|)
block|{
comment|/* Compute the "sorted" union of the chains, i.e. the locations which 	     are in both chains go first, they are sorted by the sum of 	     positions in the chains.  */
name|int
name|dst_l
decl_stmt|,
name|src_l
decl_stmt|;
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|variable_union_info
modifier|*
name|vui
decl_stmt|;
comment|/* If DST is shared compare the location chains. 	     If they are different we will modify the chain in DST with 	     high probability so make a copy of DST.  */
if|if
condition|(
name|dst
operator|->
name|refcount
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|node
operator|=
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
operator|,
name|node2
operator|=
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|loc_chain
init|;
name|node
operator|&&
name|node2
condition|;
name|node
operator|=
name|node
operator|->
name|next
operator|,
name|node2
operator|=
name|node2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|REG_P
argument_list|(
name|node2
operator|->
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|node2
operator|->
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|node2
operator|->
name|loc
argument_list|,
name|node
operator|->
name|loc
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|node
operator|||
name|node2
condition|)
name|dst
operator|=
name|unshare_variable
argument_list|(
name|set
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
name|src_l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|node
operator|=
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|src_l
operator|++
expr_stmt|;
name|dst_l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|node
operator|=
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|dst_l
operator|++
expr_stmt|;
name|vui
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|variable_union_info
argument_list|,
name|src_l
operator|+
name|dst_l
argument_list|)
expr_stmt|;
comment|/* Fill in the locations from DST.  */
for|for
control|(
name|node
operator|=
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|loc_chain
operator|,
name|jj
operator|=
literal|0
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
operator|,
name|jj
operator|++
control|)
block|{
name|vui
index|[
name|jj
index|]
operator|.
name|lc
operator|=
name|node
expr_stmt|;
name|vui
index|[
name|jj
index|]
operator|.
name|pos_dst
operator|=
name|jj
expr_stmt|;
comment|/* Value larger than a sum of 2 valid positions.  */
name|vui
index|[
name|jj
index|]
operator|.
name|pos_src
operator|=
name|src_l
operator|+
name|dst_l
expr_stmt|;
block|}
comment|/* Fill in the locations from SRC.  */
name|n
operator|=
name|dst_l
expr_stmt|;
for|for
control|(
name|node
operator|=
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
operator|,
name|ii
operator|=
literal|0
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
operator|,
name|ii
operator|++
control|)
block|{
comment|/* Find location from NODE.  */
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|dst_l
condition|;
name|jj
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|vui
index|[
name|jj
index|]
operator|.
name|lc
operator|->
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|vui
index|[
name|jj
index|]
operator|.
name|lc
operator|->
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|vui
index|[
name|jj
index|]
operator|.
name|lc
operator|->
name|loc
argument_list|,
name|node
operator|->
name|loc
argument_list|)
condition|)
block|{
name|vui
index|[
name|jj
index|]
operator|.
name|pos_src
operator|=
name|ii
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|jj
operator|>=
name|dst_l
condition|)
comment|/* The location has not been found.  */
block|{
name|location_chain
name|new_node
decl_stmt|;
comment|/* Copy the location from SRC.  */
name|new_node
operator|=
name|pool_alloc
argument_list|(
name|loc_chain_pool
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|loc
operator|=
name|node
operator|->
name|loc
expr_stmt|;
name|vui
index|[
name|n
index|]
operator|.
name|lc
operator|=
name|new_node
expr_stmt|;
name|vui
index|[
name|n
index|]
operator|.
name|pos_src
operator|=
name|ii
expr_stmt|;
name|vui
index|[
name|n
index|]
operator|.
name|pos_dst
operator|=
name|src_l
operator|+
name|dst_l
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|src_l
operator|+
name|dst_l
condition|;
name|ii
operator|++
control|)
name|vui
index|[
name|ii
index|]
operator|.
name|pos
operator|=
name|vui
index|[
name|ii
index|]
operator|.
name|pos_src
operator|+
name|vui
index|[
name|ii
index|]
operator|.
name|pos_dst
expr_stmt|;
name|qsort
argument_list|(
name|vui
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|variable_union_info
argument_list|)
argument_list|,
name|variable_union_info_cmp_pos
argument_list|)
expr_stmt|;
comment|/* Reconnect the nodes in sorted order.  */
for|for
control|(
name|ii
operator|=
literal|1
init|;
name|ii
operator|<
name|n
condition|;
name|ii
operator|++
control|)
name|vui
index|[
name|ii
operator|-
literal|1
index|]
operator|.
name|lc
operator|->
name|next
operator|=
name|vui
index|[
name|ii
index|]
operator|.
name|lc
expr_stmt|;
name|vui
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|lc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|loc_chain
operator|=
name|vui
index|[
literal|0
index|]
operator|.
name|lc
expr_stmt|;
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|offset
operator|=
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
expr_stmt|;
name|free
argument_list|(
name|vui
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|&&
name|j
operator|>=
literal|0
operator|&&
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
operator|<
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
operator|)
operator|||
name|i
operator|<
literal|0
condition|)
block|{
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|=
name|dst
operator|->
name|var_part
index|[
name|j
index|]
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|&&
name|j
operator|>=
literal|0
operator|&&
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
operator|>
name|dst
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
operator|)
operator|||
name|j
operator|<
literal|0
condition|)
block|{
name|location_chain
modifier|*
name|nextp
decl_stmt|;
comment|/* Copy the chain from SRC.  */
name|nextp
operator|=
operator|&
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|loc_chain
expr_stmt|;
for|for
control|(
name|node
operator|=
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|location_chain
name|new_lc
decl_stmt|;
name|new_lc
operator|=
name|pool_alloc
argument_list|(
name|loc_chain_pool
argument_list|)
expr_stmt|;
name|new_lc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_lc
operator|->
name|loc
operator|=
name|node
operator|->
name|loc
expr_stmt|;
operator|*
name|nextp
operator|=
name|new_lc
expr_stmt|;
name|nextp
operator|=
operator|&
name|new_lc
operator|->
name|next
expr_stmt|;
block|}
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|offset
operator|=
name|src
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
comment|/* We are at the basic block boundary when computing union 	 so set the CUR_LOC to be the first element of the chain.  */
if|if
condition|(
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|loc_chain
condition|)
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|cur_loc
operator|=
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|loc_chain
operator|->
name|loc
expr_stmt|;
else|else
name|dst
operator|->
name|var_part
index|[
name|k
index|]
operator|.
name|cur_loc
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compute union of dataflow sets SRC and DST and store it to DST.  */
end_comment

begin_function
specifier|static
name|void
name|dataflow_set_union
parameter_list|(
name|dataflow_set
modifier|*
name|dst
parameter_list|,
name|dataflow_set
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|attrs_list_union
argument_list|(
operator|&
name|dst
operator|->
name|regs
index|[
name|i
index|]
argument_list|,
name|src
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|src
operator|->
name|vars
argument_list|,
name|variable_union
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flag whether two dataflow sets being compared contain different data.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|dataflow_set_different_value
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|variable_part_different_p
parameter_list|(
name|variable_part
modifier|*
name|vp1
parameter_list|,
name|variable_part
modifier|*
name|vp2
parameter_list|)
block|{
name|location_chain
name|lc1
decl_stmt|,
name|lc2
decl_stmt|;
for|for
control|(
name|lc1
operator|=
name|vp1
operator|->
name|loc_chain
init|;
name|lc1
condition|;
name|lc1
operator|=
name|lc1
operator|->
name|next
control|)
block|{
for|for
control|(
name|lc2
operator|=
name|vp2
operator|->
name|loc_chain
init|;
name|lc2
condition|;
name|lc2
operator|=
name|lc2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|lc1
operator|->
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|lc2
operator|->
name|loc
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|lc1
operator|->
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|lc2
operator|->
name|loc
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|lc1
operator|->
name|loc
argument_list|,
name|lc2
operator|->
name|loc
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|lc2
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if variables VAR1 and VAR2 are different.    If COMPARE_CURRENT_LOCATION is true compare also the cur_loc of each    variable part.  */
end_comment

begin_function
specifier|static
name|bool
name|variable_different_p
parameter_list|(
name|variable
name|var1
parameter_list|,
name|variable
name|var2
parameter_list|,
name|bool
name|compare_current_location
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|var1
operator|==
name|var2
condition|)
return|return
name|false
return|;
if|if
condition|(
name|var1
operator|->
name|n_var_parts
operator|!=
name|var2
operator|->
name|n_var_parts
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var1
operator|->
name|n_var_parts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|var1
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
operator|!=
name|var2
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
condition|)
return|return
name|true
return|;
if|if
condition|(
name|compare_current_location
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|REG_P
argument_list|(
name|var1
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|var2
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|var1
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|var2
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
argument_list|)
operator|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|var1
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
argument_list|,
name|var2
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|cur_loc
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|variable_part_different_p
argument_list|(
operator|&
name|var1
operator|->
name|var_part
index|[
name|i
index|]
argument_list|,
operator|&
name|var2
operator|->
name|var_part
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|variable_part_different_p
argument_list|(
operator|&
name|var2
operator|->
name|var_part
index|[
name|i
index|]
argument_list|,
operator|&
name|var1
operator|->
name|var_part
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Compare variable *SLOT with the same variable in hash table DATA    and set DATAFLOW_SET_DIFFERENT_VALUE if they are different.  */
end_comment

begin_function
specifier|static
name|int
name|dataflow_set_different_1
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|htab_t
name|htab
init|=
operator|(
name|htab_t
operator|)
name|data
decl_stmt|;
name|variable
name|var1
decl_stmt|,
name|var2
decl_stmt|;
name|var1
operator|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|slot
expr_stmt|;
name|var2
operator|=
name|htab_find_with_hash
argument_list|(
name|htab
argument_list|,
name|var1
operator|->
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|var1
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|var2
condition|)
block|{
name|dataflow_set_different_value
operator|=
name|true
expr_stmt|;
comment|/* Stop traversing the hash table.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|variable_different_p
argument_list|(
name|var1
argument_list|,
name|var2
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|dataflow_set_different_value
operator|=
name|true
expr_stmt|;
comment|/* Stop traversing the hash table.  */
return|return
literal|0
return|;
block|}
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare variable *SLOT with the same variable in hash table DATA    and set DATAFLOW_SET_DIFFERENT_VALUE if they are different.  */
end_comment

begin_function
specifier|static
name|int
name|dataflow_set_different_2
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|htab_t
name|htab
init|=
operator|(
name|htab_t
operator|)
name|data
decl_stmt|;
name|variable
name|var1
decl_stmt|,
name|var2
decl_stmt|;
name|var1
operator|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|slot
expr_stmt|;
name|var2
operator|=
name|htab_find_with_hash
argument_list|(
name|htab
argument_list|,
name|var1
operator|->
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|var1
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|var2
condition|)
block|{
name|dataflow_set_different_value
operator|=
name|true
expr_stmt|;
comment|/* Stop traversing the hash table.  */
return|return
literal|0
return|;
block|}
comment|/* If both variables are defined they have been already checked for      equivalence.  */
name|gcc_assert
argument_list|(
operator|!
name|variable_different_p
argument_list|(
name|var1
argument_list|,
name|var2
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if dataflow sets OLD_SET and NEW_SET differ.  */
end_comment

begin_function
specifier|static
name|bool
name|dataflow_set_different
parameter_list|(
name|dataflow_set
modifier|*
name|old_set
parameter_list|,
name|dataflow_set
modifier|*
name|new_set
parameter_list|)
block|{
name|dataflow_set_different_value
operator|=
name|false
expr_stmt|;
name|htab_traverse
argument_list|(
name|old_set
operator|->
name|vars
argument_list|,
name|dataflow_set_different_1
argument_list|,
name|new_set
operator|->
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dataflow_set_different_value
condition|)
block|{
comment|/* We have compared the variables which are in both hash tables 	 so now only check whether there are some variables in NEW_SET->VARS 	 which are not in OLD_SET->VARS.  */
name|htab_traverse
argument_list|(
name|new_set
operator|->
name|vars
argument_list|,
name|dataflow_set_different_2
argument_list|,
name|old_set
operator|->
name|vars
argument_list|)
expr_stmt|;
block|}
return|return
name|dataflow_set_different_value
return|;
block|}
end_function

begin_comment
comment|/* Free the contents of dataflow set SET.  */
end_comment

begin_function
specifier|static
name|void
name|dataflow_set_destroy
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|attrs_list_clear
argument_list|(
operator|&
name|set
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|set
operator|->
name|vars
argument_list|)
expr_stmt|;
name|set
operator|->
name|vars
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if RTL X contains a SYMBOL_REF.  */
end_comment

begin_function
specifier|static
name|bool
name|contains_symbol_ref
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
name|false
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|true
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|contains_symbol_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|contains_symbol_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Shall EXPR be tracked?  */
end_comment

begin_function
specifier|static
name|bool
name|track_expr_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|rtx
name|decl_rtl
decl_stmt|;
name|tree
name|realdecl
decl_stmt|;
comment|/* If EXPR is not a parameter or a variable do not track it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|PARM_DECL
condition|)
return|return
literal|0
return|;
comment|/* It also must have a name...  */
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ... and a RTL assigned to it.  */
name|decl_rtl
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl_rtl
condition|)
return|return
literal|0
return|;
comment|/* If this expression is really a debug alias of some other declaration, we       don't need to track this expression if the ultimate declaration is      ignored.  */
name|realdecl
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|realdecl
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR
argument_list|(
name|realdecl
argument_list|)
condition|)
block|{
name|realdecl
operator|=
name|DECL_DEBUG_EXPR
argument_list|(
name|realdecl
argument_list|)
expr_stmt|;
comment|/* ??? We don't yet know how to emit DW_OP_piece for variable 	 that has been SRA'ed.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|realdecl
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Do not track EXPR if REALDECL it should be ignored for debugging      purposes.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|realdecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Do not track global variables until we are able to emit correct location      list for them.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|realdecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* When the EXPR is a DECL for alias of some variable (see example)      the TREE_STATIC flag is not used.  Disable tracking all DECLs whose      DECL_RTL contains SYMBOL_REF.       Example:      extern char **_dl_argv_internal __attribute__ ((alias ("_dl_argv")));      char **_dl_argv;   */
if|if
condition|(
name|MEM_P
argument_list|(
name|decl_rtl
argument_list|)
operator|&&
name|contains_symbol_ref
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If RTX is a memory it should not be very large (because it would be      an array or struct).  */
if|if
condition|(
name|MEM_P
argument_list|(
name|decl_rtl
argument_list|)
condition|)
block|{
comment|/* Do not track structures and arrays.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
operator|==
name|BLKmode
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|realdecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_SIZE
argument_list|(
name|decl_rtl
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|decl_rtl
argument_list|)
argument_list|)
operator|>
name|MAX_VAR_PARTS
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a given LOC refers to the same variable part as    EXPR+OFFSET.  */
end_comment

begin_function
specifier|static
name|bool
name|same_variable_part_p
parameter_list|(
name|rtx
name|loc
parameter_list|,
name|tree
name|expr
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|tree
name|expr2
decl_stmt|;
name|HOST_WIDE_INT
name|offset2
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|expr2
operator|=
name|REG_EXPR
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|offset2
operator|=
name|REG_OFFSET
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|expr2
operator|=
name|MEM_EXPR
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|offset2
operator|=
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
if|if
condition|(
operator|!
name|expr2
operator|||
operator|!
name|DECL_P
argument_list|(
name|expr2
argument_list|)
condition|)
return|return
name|false
return|;
name|expr
operator|=
name|var_debug_decl
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr2
operator|=
name|var_debug_decl
argument_list|(
name|expr2
argument_list|)
expr_stmt|;
return|return
operator|(
name|expr
operator|==
name|expr2
operator|&&
name|offset
operator|==
name|offset2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Count uses (register and memory references) LOC which will be tracked.    INSN is instruction which the LOC is part of.  */
end_comment

begin_function
specifier|static
name|int
name|count_uses
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|insn
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
operator|(
name|rtx
operator|)
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
operator|*
name|loc
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
operator|*
name|loc
argument_list|)
operator|&&
name|MEM_EXPR
argument_list|(
operator|*
name|loc
argument_list|)
operator|&&
name|track_expr_p
argument_list|(
name|MEM_EXPR
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
condition|)
block|{
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper function for finding all uses of REG/MEM in X in insn INSN.  */
end_comment

begin_function
specifier|static
name|void
name|count_uses_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|insn
parameter_list|)
block|{
name|for_each_rtx
argument_list|(
name|x
argument_list|,
name|count_uses
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count stores (register and memory references) LOC which will be tracked.    INSN is instruction which the LOC is part of.  */
end_comment

begin_function
specifier|static
name|void
name|count_stores
parameter_list|(
name|rtx
name|loc
parameter_list|,
name|rtx
name|expr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|insn
parameter_list|)
block|{
name|count_uses
argument_list|(
operator|&
name|loc
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add uses (register and memory references) LOC which will be tracked    to VTI (bb)->mos.  INSN is instruction which the LOC is part of.  */
end_comment

begin_function
specifier|static
name|int
name|add_uses
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|insn
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
operator|(
name|rtx
operator|)
name|insn
argument_list|)
decl_stmt|;
name|micro_operation
modifier|*
name|mo
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|+
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
decl_stmt|;
name|mo
operator|->
name|type
operator|=
operator|(
operator|(
name|REG_EXPR
argument_list|(
operator|*
name|loc
argument_list|)
operator|&&
name|track_expr_p
argument_list|(
name|REG_EXPR
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|)
condition|?
name|MO_USE
else|:
name|MO_USE_NO_VAR
operator|)
expr_stmt|;
name|mo
operator|->
name|u
operator|.
name|loc
operator|=
operator|*
name|loc
expr_stmt|;
name|mo
operator|->
name|insn
operator|=
operator|(
name|rtx
operator|)
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
operator|*
name|loc
argument_list|)
operator|&&
name|MEM_EXPR
argument_list|(
operator|*
name|loc
argument_list|)
operator|&&
name|track_expr_p
argument_list|(
name|MEM_EXPR
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
operator|(
name|rtx
operator|)
name|insn
argument_list|)
decl_stmt|;
name|micro_operation
modifier|*
name|mo
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|+
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
decl_stmt|;
name|mo
operator|->
name|type
operator|=
name|MO_USE
expr_stmt|;
name|mo
operator|->
name|u
operator|.
name|loc
operator|=
operator|*
name|loc
expr_stmt|;
name|mo
operator|->
name|insn
operator|=
operator|(
name|rtx
operator|)
name|insn
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper function for finding all uses of REG/MEM in X in insn INSN.  */
end_comment

begin_function
specifier|static
name|void
name|add_uses_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|insn
parameter_list|)
block|{
name|for_each_rtx
argument_list|(
name|x
argument_list|,
name|add_uses
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add stores (register and memory references) LOC which will be tracked    to VTI (bb)->mos. EXPR is the RTL expression containing the store.    INSN is instruction which the LOC is part of.  */
end_comment

begin_function
specifier|static
name|void
name|add_stores
parameter_list|(
name|rtx
name|loc
parameter_list|,
name|rtx
name|expr
parameter_list|,
name|void
modifier|*
name|insn
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
operator|(
name|rtx
operator|)
name|insn
argument_list|)
decl_stmt|;
name|micro_operation
modifier|*
name|mo
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|+
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|!
name|REG_EXPR
argument_list|(
name|loc
argument_list|)
operator|||
operator|!
name|track_expr_p
argument_list|(
name|REG_EXPR
argument_list|(
name|loc
argument_list|)
argument_list|)
condition|)
name|mo
operator|->
name|type
operator|=
name|MO_CLOBBER
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|expr
argument_list|)
operator|==
name|loc
operator|&&
name|same_variable_part_p
argument_list|(
name|SET_SRC
argument_list|(
name|expr
argument_list|)
argument_list|,
name|REG_EXPR
argument_list|(
name|loc
argument_list|)
argument_list|,
name|REG_OFFSET
argument_list|(
name|loc
argument_list|)
argument_list|)
condition|)
name|mo
operator|->
name|type
operator|=
name|MO_COPY
expr_stmt|;
else|else
name|mo
operator|->
name|type
operator|=
name|MO_SET
expr_stmt|;
name|mo
operator|->
name|u
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|mo
operator|->
name|insn
operator|=
name|NEXT_INSN
argument_list|(
operator|(
name|rtx
operator|)
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
argument_list|)
operator|&&
name|MEM_EXPR
argument_list|(
name|loc
argument_list|)
operator|&&
name|track_expr_p
argument_list|(
name|MEM_EXPR
argument_list|(
name|loc
argument_list|)
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
operator|(
name|rtx
operator|)
name|insn
argument_list|)
decl_stmt|;
name|micro_operation
modifier|*
name|mo
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|+
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mo
operator|->
name|type
operator|=
name|MO_CLOBBER
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|expr
argument_list|)
operator|==
name|loc
operator|&&
name|same_variable_part_p
argument_list|(
name|SET_SRC
argument_list|(
name|expr
argument_list|)
argument_list|,
name|MEM_EXPR
argument_list|(
name|loc
argument_list|)
argument_list|,
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|loc
argument_list|)
argument_list|)
else|:
literal|0
argument_list|)
condition|)
name|mo
operator|->
name|type
operator|=
name|MO_COPY
expr_stmt|;
else|else
name|mo
operator|->
name|type
operator|=
name|MO_SET
expr_stmt|;
name|mo
operator|->
name|u
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|mo
operator|->
name|insn
operator|=
name|NEXT_INSN
argument_list|(
operator|(
name|rtx
operator|)
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the changes of variable locations in the basic block BB.  */
end_comment

begin_function
specifier|static
name|bool
name|compute_bb_dataflow
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|r
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|dataflow_set
name|old_out
decl_stmt|;
name|dataflow_set
modifier|*
name|in
init|=
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
decl_stmt|;
name|dataflow_set
modifier|*
name|out
init|=
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|out
decl_stmt|;
name|dataflow_set_init
argument_list|(
operator|&
name|old_out
argument_list|,
name|htab_elements
argument_list|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|out
operator|.
name|vars
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|dataflow_set_copy
argument_list|(
operator|&
name|old_out
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|dataflow_set_copy
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|n
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|MO_CALL
case|:
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|r
argument_list|)
condition|)
name|var_regno_delete
argument_list|(
name|out
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|MO_USE
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
name|var_reg_set
argument_list|(
name|out
argument_list|,
name|loc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
name|var_mem_set
argument_list|(
name|out
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_SET
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete_and_set
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_mem_delete_and_set
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_COPY
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete_and_set
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_mem_delete_and_set
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_USE_NO_VAR
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_mem_delete
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_CLOBBER
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_mem_delete
argument_list|(
name|out
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_ADJUST
case|:
name|out
operator|->
name|stack_adjust
operator|+=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|adjust
expr_stmt|;
break|break;
block|}
block|}
name|changed
operator|=
name|dataflow_set_different
argument_list|(
operator|&
name|old_out
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|dataflow_set_destroy
argument_list|(
operator|&
name|old_out
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Find the locations of variables in the whole function.  */
end_comment

begin_function
specifier|static
name|void
name|vt_find_locations
parameter_list|(
name|void
parameter_list|)
block|{
name|fibheap_t
name|worklist
decl_stmt|,
name|pending
decl_stmt|,
name|fibheap_swap
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|,
name|in_worklist
decl_stmt|,
name|in_pending
decl_stmt|,
name|sbitmap_swap
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
modifier|*
name|bb_order
decl_stmt|;
name|int
modifier|*
name|rc_order
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute reverse completion order of depth first search of the CFG      so that the data-flow runs faster.  */
name|rc_order
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
name|bb_order
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|pre_and_rev_post_order_compute
argument_list|(
name|NULL
argument_list|,
name|rc_order
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
condition|;
name|i
operator|++
control|)
name|bb_order
index|[
name|rc_order
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|rc_order
argument_list|)
expr_stmt|;
name|worklist
operator|=
name|fibheap_new
argument_list|()
expr_stmt|;
name|pending
operator|=
name|fibheap_new
argument_list|()
expr_stmt|;
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|in_worklist
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|in_pending
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_worklist
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|fibheap_insert
argument_list|(
name|pending
argument_list|,
name|bb_order
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|in_pending
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
name|pending
argument_list|)
condition|)
block|{
name|fibheap_swap
operator|=
name|pending
expr_stmt|;
name|pending
operator|=
name|worklist
expr_stmt|;
name|worklist
operator|=
name|fibheap_swap
expr_stmt|;
name|sbitmap_swap
operator|=
name|in_pending
expr_stmt|;
name|in_pending
operator|=
name|in_worklist
expr_stmt|;
name|in_worklist
operator|=
name|sbitmap_swap
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
name|worklist
argument_list|)
condition|)
block|{
name|bb
operator|=
name|fibheap_extract_min
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|in_worklist
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|bool
name|changed
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Calculate the IN set as union of predecessor OUT sets.  */
name|dataflow_set_clear
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|dataflow_set_union
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
argument_list|,
operator|&
name|VTI
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
name|compute_bb_dataflow
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|bb
condition|)
continue|continue;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|in_pending
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Send E->DEST to next round.  */
name|SET_BIT
argument_list|(
name|in_pending
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fibheap_insert
argument_list|(
name|pending
argument_list|,
name|bb_order
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|in_worklist
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Add E->DEST to current round.  */
name|SET_BIT
argument_list|(
name|in_worklist
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fibheap_insert
argument_list|(
name|worklist
argument_list|,
name|bb_order
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|bb_order
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|in_worklist
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|in_pending
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the content of the LIST to dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_attrs_list
parameter_list|(
name|attrs
name|list
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|print_mem_expr
argument_list|(
name|dump_file
argument_list|,
name|list
operator|->
name|decl
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"+"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|list
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the information about variable *SLOT to dump file.  */
end_comment

begin_function
specifier|static
name|int
name|dump_variable
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|variable
name|var
init|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|slot
decl_stmt|;
name|int
name|i
decl_stmt|;
name|location_chain
name|node
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  name: %s\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|var
operator|->
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var
operator|->
name|n_var_parts
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"    offset %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|node
operator|->
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print the information about variables from hash table VARS to dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_vars
parameter_list|(
name|htab_t
name|vars
parameter_list|)
block|{
if|if
condition|(
name|htab_elements
argument_list|(
name|vars
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Variables:\n"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|vars
argument_list|,
name|dump_variable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the dataflow set SET to dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_dataflow_set
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Stack adjustment: "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|set
operator|->
name|stack_adjust
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|set
operator|->
name|regs
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Reg %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_attrs_list
argument_list|(
name|set
operator|->
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|dump_vars
argument_list|(
name|set
operator|->
name|vars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the IN and OUT sets for each basic block to dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_dataflow_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nBasic block %d:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"IN:\n"
argument_list|)
expr_stmt|;
name|dump_dataflow_set
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"OUT:\n"
argument_list|)
expr_stmt|;
name|dump_dataflow_set
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add variable VAR to the hash table of changed variables and    if it has no locations delete it from hash table HTAB.  */
end_comment

begin_function
specifier|static
name|void
name|variable_was_changed
parameter_list|(
name|variable
name|var
parameter_list|,
name|htab_t
name|htab
parameter_list|)
block|{
name|hashval_t
name|hash
init|=
name|VARIABLE_HASH_VAL
argument_list|(
name|var
operator|->
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|emit_notes
condition|)
block|{
name|variable
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
operator|(
name|variable
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|changed_variables
argument_list|,
name|var
operator|->
name|decl
argument_list|,
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|&&
name|var
operator|->
name|n_var_parts
operator|==
literal|0
condition|)
block|{
name|variable
name|empty_var
decl_stmt|;
name|void
modifier|*
modifier|*
name|old
decl_stmt|;
name|empty_var
operator|=
name|pool_alloc
argument_list|(
name|var_pool
argument_list|)
expr_stmt|;
name|empty_var
operator|->
name|decl
operator|=
name|var
operator|->
name|decl
expr_stmt|;
name|empty_var
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|empty_var
operator|->
name|n_var_parts
operator|=
literal|0
expr_stmt|;
operator|*
name|slot
operator|=
name|empty_var
expr_stmt|;
name|old
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|htab
argument_list|,
name|var
operator|->
name|decl
argument_list|,
name|hash
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
name|htab_clear_slot
argument_list|(
name|htab
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|slot
operator|=
name|var
expr_stmt|;
block|}
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|n_var_parts
operator|==
literal|0
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
init|=
name|htab_find_slot_with_hash
argument_list|(
name|htab
argument_list|,
name|var
operator|->
name|decl
argument_list|,
name|hash
argument_list|,
name|NO_INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
condition|)
name|htab_clear_slot
argument_list|(
name|htab
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look for the index in VAR->var_part corresponding to OFFSET.    Return -1 if not found.  If INSERTION_POINT is non-NULL, the    referenced int will be set to the index that the part has or should    have, if it should be inserted.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|find_variable_location_part
parameter_list|(
name|variable
name|var
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|int
modifier|*
name|insertion_point
parameter_list|)
block|{
name|int
name|pos
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* Find the location part.  */
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|var
operator|->
name|n_var_parts
expr_stmt|;
while|while
condition|(
name|low
operator|!=
name|high
condition|)
block|{
name|pos
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|offset
operator|<
name|offset
condition|)
name|low
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|pos
expr_stmt|;
block|}
name|pos
operator|=
name|low
expr_stmt|;
if|if
condition|(
name|insertion_point
condition|)
operator|*
name|insertion_point
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|var
operator|->
name|n_var_parts
operator|&&
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|offset
operator|==
name|offset
condition|)
return|return
name|pos
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the part of variable's location in the dataflow set SET.  The variable    part is specified by variable's declaration DECL and offset OFFSET and the    part's location by LOC.  */
end_comment

begin_function
specifier|static
name|void
name|set_variable_part
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|,
name|tree
name|decl
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|location_chain
name|node
decl_stmt|,
name|next
decl_stmt|;
name|location_chain
modifier|*
name|nextp
decl_stmt|;
name|variable
name|var
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|set
operator|->
name|vars
argument_list|,
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
block|{
comment|/* Create new variable information.  */
name|var
operator|=
name|pool_alloc
argument_list|(
name|var_pool
argument_list|)
expr_stmt|;
name|var
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|var
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|var
operator|->
name|n_var_parts
operator|=
literal|1
expr_stmt|;
name|var
operator|->
name|var_part
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|var
operator|->
name|var_part
index|[
literal|0
index|]
operator|.
name|loc_chain
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|var_part
index|[
literal|0
index|]
operator|.
name|cur_loc
operator|=
name|NULL
expr_stmt|;
operator|*
name|slot
operator|=
name|var
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|inspos
init|=
literal|0
decl_stmt|;
name|var
operator|=
operator|(
name|variable
operator|)
operator|*
name|slot
expr_stmt|;
name|pos
operator|=
name|find_variable_location_part
argument_list|(
name|var
argument_list|,
name|offset
argument_list|,
operator|&
name|inspos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|node
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
expr_stmt|;
if|if
condition|(
name|node
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|loc
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|loc
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|node
operator|->
name|loc
argument_list|,
name|loc
argument_list|)
operator|)
condition|)
block|{
comment|/* LOC is in the beginning of the chain so we have nothing 		 to do.  */
return|return;
block|}
else|else
block|{
comment|/* We have to make a copy of a shared variable.  */
if|if
condition|(
name|var
operator|->
name|refcount
operator|>
literal|1
condition|)
name|var
operator|=
name|unshare_variable
argument_list|(
name|set
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have not found the location part, new one will be created.  */
comment|/* We have to make a copy of the shared variable.  */
if|if
condition|(
name|var
operator|->
name|refcount
operator|>
literal|1
condition|)
name|var
operator|=
name|unshare_variable
argument_list|(
name|set
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* We track only variables whose size is<= MAX_VAR_PARTS bytes 	     thus there are at most MAX_VAR_PARTS different offsets.  */
name|gcc_assert
argument_list|(
name|var
operator|->
name|n_var_parts
operator|<
name|MAX_VAR_PARTS
argument_list|)
expr_stmt|;
comment|/* We have to move the elements of array starting at index 	     inspos to the next position.  */
for|for
control|(
name|pos
operator|=
name|var
operator|->
name|n_var_parts
init|;
name|pos
operator|>
name|inspos
condition|;
name|pos
operator|--
control|)
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
operator|-
literal|1
index|]
expr_stmt|;
name|var
operator|->
name|n_var_parts
operator|++
expr_stmt|;
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Delete the location from the list.  */
name|nextp
operator|=
operator|&
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
expr_stmt|;
for|for
control|(
name|node
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|loc
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|loc
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|node
operator|->
name|loc
argument_list|,
name|loc
argument_list|)
condition|)
block|{
name|pool_free
argument_list|(
name|loc_chain_pool
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nextp
operator|=
name|next
expr_stmt|;
break|break;
block|}
else|else
name|nextp
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
block|}
comment|/* Add the location to the beginning.  */
name|node
operator|=
name|pool_alloc
argument_list|(
name|loc_chain_pool
argument_list|)
expr_stmt|;
name|node
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
expr_stmt|;
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
operator|=
name|node
expr_stmt|;
comment|/* If no location was emitted do so.  */
if|if
condition|(
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
operator|==
name|NULL
condition|)
block|{
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
operator|=
name|loc
expr_stmt|;
name|variable_was_changed
argument_list|(
name|var
argument_list|,
name|set
operator|->
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove all recorded register locations for the given variable part    from dataflow set SET, except for those that are identical to loc.    The variable part is specified by variable's declaration DECL and    offset OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|clobber_variable_part
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|,
name|tree
name|decl
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|decl
operator|||
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|set
operator|->
name|vars
argument_list|,
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
block|{
name|variable
name|var
init|=
operator|(
name|variable
operator|)
operator|*
name|slot
decl_stmt|;
name|int
name|pos
init|=
name|find_variable_location_part
argument_list|(
name|var
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|location_chain
name|node
decl_stmt|,
name|next
decl_stmt|;
comment|/* Remove the register locations from the dataflow set.  */
name|next
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
expr_stmt|;
for|for
control|(
name|node
operator|=
name|next
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|loc
operator|!=
name|loc
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|node
operator|->
name|loc
argument_list|)
condition|)
block|{
name|attrs
name|anode
decl_stmt|,
name|anext
decl_stmt|;
name|attrs
modifier|*
name|anextp
decl_stmt|;
comment|/* Remove the variable part from the register's 			 list, but preserve any other variable parts 			 that might be regarded as live in that same 			 register.  */
name|anextp
operator|=
operator|&
name|set
operator|->
name|regs
index|[
name|REGNO
argument_list|(
name|node
operator|->
name|loc
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|anode
operator|=
operator|*
name|anextp
init|;
name|anode
condition|;
name|anode
operator|=
name|anext
control|)
block|{
name|anext
operator|=
name|anode
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|anode
operator|->
name|decl
operator|==
name|decl
operator|&&
name|anode
operator|->
name|offset
operator|==
name|offset
condition|)
block|{
name|pool_free
argument_list|(
name|attrs_pool
argument_list|,
name|anode
argument_list|)
expr_stmt|;
operator|*
name|anextp
operator|=
name|anext
expr_stmt|;
block|}
block|}
block|}
name|delete_variable_part
argument_list|(
name|set
argument_list|,
name|node
operator|->
name|loc
argument_list|,
name|decl
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete the part of variable's location from dataflow set SET.  The variable    part is specified by variable's declaration DECL and offset OFFSET and the    part's location by LOC.  */
end_comment

begin_function
specifier|static
name|void
name|delete_variable_part
parameter_list|(
name|dataflow_set
modifier|*
name|set
parameter_list|,
name|rtx
name|loc
parameter_list|,
name|tree
name|decl
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|set
operator|->
name|vars
argument_list|,
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
condition|)
block|{
name|variable
name|var
init|=
operator|(
name|variable
operator|)
operator|*
name|slot
decl_stmt|;
name|int
name|pos
init|=
name|find_variable_location_part
argument_list|(
name|var
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|location_chain
name|node
decl_stmt|,
name|next
decl_stmt|;
name|location_chain
modifier|*
name|nextp
decl_stmt|;
name|bool
name|changed
decl_stmt|;
if|if
condition|(
name|var
operator|->
name|refcount
operator|>
literal|1
condition|)
block|{
comment|/* If the variable contains the location part we have to 		 make a copy of the variable.  */
for|for
control|(
name|node
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|loc
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|loc
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|node
operator|->
name|loc
argument_list|,
name|loc
argument_list|)
condition|)
block|{
name|var
operator|=
name|unshare_variable
argument_list|(
name|set
argument_list|,
name|var
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Delete the location part.  */
name|nextp
operator|=
operator|&
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
expr_stmt|;
for|for
control|(
name|node
operator|=
operator|*
name|nextp
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|loc
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|node
operator|->
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|loc
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|node
operator|->
name|loc
argument_list|,
name|loc
argument_list|)
condition|)
block|{
name|pool_free
argument_list|(
name|loc_chain_pool
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nextp
operator|=
name|next
expr_stmt|;
break|break;
block|}
else|else
name|nextp
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
block|}
comment|/* If we have deleted the location which was last emitted 	     we have to emit new location so add the variable to set 	     of changed variables.  */
if|if
condition|(
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|loc
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|loc
argument_list|)
operator|==
name|REGNO
argument_list|(
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
argument_list|)
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|loc
argument_list|,
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
argument_list|)
operator|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
condition|)
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|cur_loc
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
operator|->
name|loc
expr_stmt|;
block|}
else|else
name|changed
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|.
name|loc_chain
operator|==
name|NULL
condition|)
block|{
name|var
operator|->
name|n_var_parts
operator|--
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|var
operator|->
name|n_var_parts
condition|)
block|{
name|var
operator|->
name|var_part
index|[
name|pos
index|]
operator|=
name|var
operator|->
name|var_part
index|[
name|pos
operator|+
literal|1
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
name|variable_was_changed
argument_list|(
name|var
argument_list|,
name|set
operator|->
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Emit the NOTE_INSN_VAR_LOCATION for variable *VARP.  DATA contains    additional parameters: WHERE specifies whether the note shall be emitted    before of after instruction INSN.  */
end_comment

begin_function
specifier|static
name|int
name|emit_note_insn_var_location
parameter_list|(
name|void
modifier|*
modifier|*
name|varp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|variable
name|var
init|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|varp
decl_stmt|;
name|rtx
name|insn
init|=
operator|(
operator|(
name|emit_note_data
operator|*
operator|)
name|data
operator|)
operator|->
name|insn
decl_stmt|;
name|enum
name|emit_note_where
name|where
init|=
operator|(
operator|(
name|emit_note_data
operator|*
operator|)
name|data
operator|)
operator|->
name|where
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n_var_parts
decl_stmt|;
name|bool
name|complete
decl_stmt|;
name|HOST_WIDE_INT
name|last_limit
decl_stmt|;
name|tree
name|type_size_unit
decl_stmt|;
name|HOST_WIDE_INT
name|offsets
index|[
name|MAX_VAR_PARTS
index|]
decl_stmt|;
name|rtx
name|loc
index|[
name|MAX_VAR_PARTS
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|var
operator|->
name|decl
argument_list|)
expr_stmt|;
name|complete
operator|=
name|true
expr_stmt|;
name|last_limit
operator|=
literal|0
expr_stmt|;
name|n_var_parts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|var
operator|->
name|n_var_parts
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|wider_mode
decl_stmt|;
if|if
condition|(
name|last_limit
operator|<
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
condition|)
block|{
name|complete
operator|=
name|false
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|last_limit
operator|>
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
condition|)
continue|continue;
name|offsets
index|[
name|n_var_parts
index|]
operator|=
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|loc
index|[
name|n_var_parts
index|]
operator|=
name|var
operator|->
name|var_part
index|[
name|i
index|]
operator|.
name|loc_chain
operator|->
name|loc
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
expr_stmt|;
name|last_limit
operator|=
name|offsets
index|[
name|n_var_parts
index|]
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Attempt to merge adjacent registers or memory.  */
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|var
operator|->
name|n_var_parts
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|last_limit
operator|<=
name|var
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|var
operator|->
name|n_var_parts
operator|&&
name|wider_mode
operator|!=
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|var
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|loc_chain
operator|->
name|loc
argument_list|)
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|var
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|loc_chain
operator|->
name|loc
argument_list|)
operator|&&
name|last_limit
operator|==
name|var
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|offset
condition|)
block|{
name|rtx
name|new_loc
init|=
name|NULL
decl_stmt|;
name|rtx
name|loc2
init|=
name|var
operator|->
name|var_part
index|[
name|j
index|]
operator|.
name|loc_chain
operator|->
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
operator|&&
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
index|]
index|[
name|mode
index|]
operator|*
literal|2
operator|==
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
index|]
index|[
name|wider_mode
index|]
operator|&&
name|REGNO
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
operator|+
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
index|]
index|[
name|mode
index|]
operator|==
name|REGNO
argument_list|(
name|loc2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|WORDS_BIG_ENDIAN
operator|&&
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|new_loc
operator|=
name|simplify_subreg
argument_list|(
name|wider_mode
argument_list|,
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|BYTES_BIG_ENDIAN
condition|)
name|new_loc
operator|=
name|simplify_subreg
argument_list|(
name|wider_mode
argument_list|,
name|loc2
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_loc
condition|)
block|{
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|new_loc
argument_list|)
operator|||
name|REGNO
argument_list|(
name|new_loc
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
condition|)
name|new_loc
operator|=
name|NULL
expr_stmt|;
else|else
name|REG_ATTRS
argument_list|(
name|new_loc
argument_list|)
operator|=
name|REG_ATTRS
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loc2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|new_loc
operator|=
name|adjust_address_nv
argument_list|(
name|loc
index|[
name|n_var_parts
index|]
argument_list|,
name|wider_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_loc
condition|)
block|{
name|loc
index|[
name|n_var_parts
index|]
operator|=
name|new_loc
expr_stmt|;
name|mode
operator|=
name|wider_mode
expr_stmt|;
name|last_limit
operator|=
name|offsets
index|[
name|n_var_parts
index|]
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
operator|++
name|n_var_parts
expr_stmt|;
block|}
name|type_size_unit
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|last_limit
operator|<
name|TREE_INT_CST_LOW
argument_list|(
name|type_size_unit
argument_list|)
condition|)
name|complete
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|where
operator|==
name|EMIT_NOTE_AFTER_INSN
condition|)
name|note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_VAR_LOCATION
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_VAR_LOCATION
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|complete
condition|)
block|{
name|NOTE_VAR_LOCATION
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_VAR_LOCATION
argument_list|(
name|VOIDmode
argument_list|,
name|var
operator|->
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_var_parts
operator|==
literal|1
condition|)
block|{
name|rtx
name|expr_list
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|loc
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|offsets
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|NOTE_VAR_LOCATION
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_VAR_LOCATION
argument_list|(
name|VOIDmode
argument_list|,
name|var
operator|->
name|decl
argument_list|,
name|expr_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_var_parts
condition|)
block|{
name|rtx
name|parallel
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_var_parts
condition|;
name|i
operator|++
control|)
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|loc
index|[
name|i
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|offsets
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|parallel
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|n_var_parts
argument_list|,
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|NOTE_VAR_LOCATION
argument_list|(
name|note
argument_list|)
operator|=
name|gen_rtx_VAR_LOCATION
argument_list|(
name|VOIDmode
argument_list|,
name|var
operator|->
name|decl
argument_list|,
name|parallel
argument_list|)
expr_stmt|;
block|}
name|htab_clear_slot
argument_list|(
name|changed_variables
argument_list|,
name|varp
argument_list|)
expr_stmt|;
comment|/* When there are no location parts the variable has been already      removed from hash table and a new empty variable was created.      Free the empty variable.  */
if|if
condition|(
name|var
operator|->
name|n_var_parts
operator|==
literal|0
condition|)
block|{
name|pool_free
argument_list|(
name|var_pool
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Emit NOTE_INSN_VAR_LOCATION note for each variable from a chain    CHANGED_VARIABLES and delete this chain.  WHERE specifies whether the notes    shall be emitted before of after instruction INSN.  */
end_comment

begin_function
specifier|static
name|void
name|emit_notes_for_changes
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|emit_note_where
name|where
parameter_list|)
block|{
name|emit_note_data
name|data
decl_stmt|;
name|data
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|data
operator|.
name|where
operator|=
name|where
expr_stmt|;
name|htab_traverse
argument_list|(
name|changed_variables
argument_list|,
name|emit_note_insn_var_location
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add variable *SLOT to the chain CHANGED_VARIABLES if it differs from the    same variable in hash table DATA or is not there at all.  */
end_comment

begin_function
specifier|static
name|int
name|emit_notes_for_differences_1
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|htab_t
name|new_vars
init|=
operator|(
name|htab_t
operator|)
name|data
decl_stmt|;
name|variable
name|old_var
decl_stmt|,
name|new_var
decl_stmt|;
name|old_var
operator|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|slot
expr_stmt|;
name|new_var
operator|=
name|htab_find_with_hash
argument_list|(
name|new_vars
argument_list|,
name|old_var
operator|->
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|old_var
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_var
condition|)
block|{
comment|/* Variable has disappeared.  */
name|variable
name|empty_var
decl_stmt|;
name|empty_var
operator|=
name|pool_alloc
argument_list|(
name|var_pool
argument_list|)
expr_stmt|;
name|empty_var
operator|->
name|decl
operator|=
name|old_var
operator|->
name|decl
expr_stmt|;
name|empty_var
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|empty_var
operator|->
name|n_var_parts
operator|=
literal|0
expr_stmt|;
name|variable_was_changed
argument_list|(
name|empty_var
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|variable_different_p
argument_list|(
name|old_var
argument_list|,
name|new_var
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|variable_was_changed
argument_list|(
name|new_var
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add variable *SLOT to the chain CHANGED_VARIABLES if it is not in hash    table DATA.  */
end_comment

begin_function
specifier|static
name|int
name|emit_notes_for_differences_2
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|htab_t
name|old_vars
init|=
operator|(
name|htab_t
operator|)
name|data
decl_stmt|;
name|variable
name|old_var
decl_stmt|,
name|new_var
decl_stmt|;
name|new_var
operator|=
operator|*
operator|(
name|variable
operator|*
operator|)
name|slot
expr_stmt|;
name|old_var
operator|=
name|htab_find_with_hash
argument_list|(
name|old_vars
argument_list|,
name|new_var
operator|->
name|decl
argument_list|,
name|VARIABLE_HASH_VAL
argument_list|(
name|new_var
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_var
condition|)
block|{
comment|/* Variable has appeared.  */
name|variable_was_changed
argument_list|(
name|new_var
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Emit notes before INSN for differences between dataflow sets OLD_SET and    NEW_SET.  */
end_comment

begin_function
specifier|static
name|void
name|emit_notes_for_differences
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|dataflow_set
modifier|*
name|old_set
parameter_list|,
name|dataflow_set
modifier|*
name|new_set
parameter_list|)
block|{
name|htab_traverse
argument_list|(
name|old_set
operator|->
name|vars
argument_list|,
name|emit_notes_for_differences_1
argument_list|,
name|new_set
operator|->
name|vars
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|new_set
operator|->
name|vars
argument_list|,
name|emit_notes_for_differences_2
argument_list|,
name|old_set
operator|->
name|vars
argument_list|)
expr_stmt|;
name|emit_notes_for_changes
argument_list|(
name|insn
argument_list|,
name|EMIT_NOTE_BEFORE_INSN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the notes for changes of location parts in the basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|emit_notes_in_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dataflow_set
name|set
decl_stmt|;
name|dataflow_set_init
argument_list|(
operator|&
name|set
argument_list|,
name|htab_elements
argument_list|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
operator|.
name|vars
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|dataflow_set_copy
argument_list|(
operator|&
name|set
argument_list|,
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|insn
decl_stmt|;
switch|switch
condition|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|MO_CALL
case|:
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|var_regno_delete
argument_list|(
operator|&
name|set
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|emit_notes_for_changes
argument_list|(
name|insn
argument_list|,
name|EMIT_NOTE_AFTER_INSN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_USE
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|REG
condition|)
name|var_reg_set
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|)
expr_stmt|;
else|else
name|var_mem_set
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_notes_for_changes
argument_list|(
name|insn
argument_list|,
name|EMIT_NOTE_AFTER_INSN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_SET
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete_and_set
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|var_mem_delete_and_set
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|emit_notes_for_changes
argument_list|(
name|insn
argument_list|,
name|EMIT_NOTE_BEFORE_INSN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_COPY
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete_and_set
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|var_mem_delete_and_set
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|emit_notes_for_changes
argument_list|(
name|insn
argument_list|,
name|EMIT_NOTE_BEFORE_INSN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_USE_NO_VAR
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|var_mem_delete
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|emit_notes_for_changes
argument_list|(
name|insn
argument_list|,
name|EMIT_NOTE_AFTER_INSN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_CLOBBER
case|:
block|{
name|rtx
name|loc
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|loc
argument_list|)
condition|)
name|var_reg_delete
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|var_mem_delete
argument_list|(
operator|&
name|set
argument_list|,
name|loc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|emit_notes_for_changes
argument_list|(
name|insn
argument_list|,
name|EMIT_NOTE_BEFORE_INSN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MO_ADJUST
case|:
name|set
operator|.
name|stack_adjust
operator|+=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|i
index|]
operator|.
name|u
operator|.
name|adjust
expr_stmt|;
break|break;
block|}
block|}
name|dataflow_set_destroy
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit notes for the whole function.  */
end_comment

begin_function
specifier|static
name|void
name|vt_emit_notes
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|dataflow_set
modifier|*
name|last_out
decl_stmt|;
name|dataflow_set
name|empty
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|htab_elements
argument_list|(
name|changed_variables
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable emitting notes by functions (mainly by set_variable_part and      delete_variable_part).  */
name|emit_notes
operator|=
name|true
expr_stmt|;
name|dataflow_set_init
argument_list|(
operator|&
name|empty
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|last_out
operator|=
operator|&
name|empty
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Emit the notes for changes of variable locations between two 	 subsequent basic blocks.  */
name|emit_notes_for_differences
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|,
name|last_out
argument_list|,
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
argument_list|)
expr_stmt|;
comment|/* Emit the notes for the changes in the basic block itself.  */
name|emit_notes_in_bb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|last_out
operator|=
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|out
expr_stmt|;
block|}
name|dataflow_set_destroy
argument_list|(
operator|&
name|empty
argument_list|)
expr_stmt|;
name|emit_notes
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If there is a declaration and offset associated with register/memory RTL    assign declaration to *DECLP and offset to *OFFSETP, and return true.  */
end_comment

begin_function
specifier|static
name|bool
name|vt_get_decl_and_offset
parameter_list|(
name|rtx
name|rtl
parameter_list|,
name|tree
modifier|*
name|declp
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|offsetp
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
if|if
condition|(
name|REG_ATTRS
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
operator|*
name|declp
operator|=
name|REG_EXPR
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
operator|*
name|offsetp
operator|=
name|REG_OFFSET
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
if|if
condition|(
name|MEM_ATTRS
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
operator|*
name|declp
operator|=
name|MEM_EXPR
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
operator|*
name|offsetp
operator|=
name|MEM_OFFSET
argument_list|(
name|rtl
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|rtl
argument_list|)
argument_list|)
else|:
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Insert function parameters to IN and OUT sets of ENTRY_BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|vt_add_function_parameters
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|rtx
name|decl_rtl
init|=
name|DECL_RTL_IF_SET
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|rtx
name|incoming
init|=
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|dataflow_set
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|decl_rtl
operator|||
operator|!
name|incoming
condition|)
continue|continue;
if|if
condition|(
name|GET_MODE
argument_list|(
name|decl_rtl
argument_list|)
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|incoming
argument_list|)
operator|==
name|BLKmode
condition|)
continue|continue;
if|if
condition|(
operator|!
name|vt_get_decl_and_offset
argument_list|(
name|incoming
argument_list|,
operator|&
name|decl
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
if|if
condition|(
operator|!
name|vt_get_decl_and_offset
argument_list|(
name|decl_rtl
argument_list|,
operator|&
name|decl
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|decl
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|parm
operator|==
name|decl
argument_list|)
expr_stmt|;
name|out
operator|=
operator|&
name|VTI
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|out
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|incoming
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|incoming
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|attrs_list_insert
argument_list|(
operator|&
name|out
operator|->
name|regs
index|[
name|REGNO
argument_list|(
name|incoming
argument_list|)
index|]
argument_list|,
name|parm
argument_list|,
name|offset
argument_list|,
name|incoming
argument_list|)
expr_stmt|;
name|set_variable_part
argument_list|(
name|out
argument_list|,
name|incoming
argument_list|,
name|parm
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|incoming
argument_list|)
condition|)
name|set_variable_part
argument_list|(
name|out
argument_list|,
name|incoming
argument_list|,
name|parm
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate and initialize the data structures for variable tracking    and parse the RTL to get the micro operations.  */
end_comment

begin_function
specifier|static
name|void
name|vt_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|variable_tracking_info_def
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|pre
decl_stmt|,
name|post
init|=
literal|0
decl_stmt|;
comment|/* Count the number of micro operations.  */
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
name|insn_stack_adjust_offset_pre_post
argument_list|(
name|insn
argument_list|,
operator|&
name|pre
argument_list|,
operator|&
name|post
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
expr_stmt|;
if|if
condition|(
name|post
condition|)
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
expr_stmt|;
block|}
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|count_uses_1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|count_stores
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
expr_stmt|;
block|}
block|}
comment|/* Add the micro-operations to the array.  */
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|=
name|XNEWVEC
argument_list|(
name|micro_operation
argument_list|,
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
argument_list|)
expr_stmt|;
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
name|insn_stack_adjust_offset_pre_post
argument_list|(
name|insn
argument_list|,
operator|&
name|pre
argument_list|,
operator|&
name|post
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
block|{
name|micro_operation
modifier|*
name|mo
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|+
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
decl_stmt|;
name|mo
operator|->
name|type
operator|=
name|MO_ADJUST
expr_stmt|;
name|mo
operator|->
name|u
operator|.
name|adjust
operator|=
name|pre
expr_stmt|;
name|mo
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
block|}
block|}
name|n1
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|add_uses_1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|n2
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|-
literal|1
expr_stmt|;
comment|/* Order the MO_USEs to be before MO_USE_NO_VARs.  */
while|while
condition|(
name|n1
operator|<
name|n2
condition|)
block|{
while|while
condition|(
name|n1
operator|<
name|n2
operator|&&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n1
index|]
operator|.
name|type
operator|==
name|MO_USE
condition|)
name|n1
operator|++
expr_stmt|;
while|while
condition|(
name|n1
operator|<
name|n2
operator|&&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n2
index|]
operator|.
name|type
operator|==
name|MO_USE_NO_VAR
condition|)
name|n2
operator|--
expr_stmt|;
if|if
condition|(
name|n1
operator|<
name|n2
condition|)
block|{
name|micro_operation
name|sw
decl_stmt|;
name|sw
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n1
index|]
expr_stmt|;
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n1
index|]
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n2
index|]
expr_stmt|;
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n2
index|]
operator|=
name|sw
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|micro_operation
modifier|*
name|mo
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|+
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
decl_stmt|;
name|mo
operator|->
name|type
operator|=
name|MO_CALL
expr_stmt|;
name|mo
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
block|}
name|n1
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
expr_stmt|;
comment|/* This will record NEXT_INSN (insn), such that we can 		 insert notes before it without worrying about any 		 notes that MO_USEs might emit after the insn.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|add_stores
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|n2
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|-
literal|1
expr_stmt|;
comment|/* Order the MO_CLOBBERs to be before MO_SETs.  */
while|while
condition|(
name|n1
operator|<
name|n2
condition|)
block|{
while|while
condition|(
name|n1
operator|<
name|n2
operator|&&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n1
index|]
operator|.
name|type
operator|==
name|MO_CLOBBER
condition|)
name|n1
operator|++
expr_stmt|;
while|while
condition|(
name|n1
operator|<
name|n2
operator|&&
operator|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n2
index|]
operator|.
name|type
operator|==
name|MO_SET
operator|||
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n2
index|]
operator|.
name|type
operator|==
name|MO_COPY
operator|)
condition|)
name|n2
operator|--
expr_stmt|;
if|if
condition|(
name|n1
operator|<
name|n2
condition|)
block|{
name|micro_operation
name|sw
decl_stmt|;
name|sw
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n1
index|]
expr_stmt|;
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n1
index|]
operator|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n2
index|]
expr_stmt|;
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
index|[
name|n2
index|]
operator|=
name|sw
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|&&
name|post
condition|)
block|{
name|micro_operation
modifier|*
name|mo
init|=
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
operator|+
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|n_mos
operator|++
decl_stmt|;
name|mo
operator|->
name|type
operator|=
name|MO_ADJUST
expr_stmt|;
name|mo
operator|->
name|u
operator|.
name|adjust
operator|=
name|post
expr_stmt|;
name|mo
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Init the IN and OUT sets.  */
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|visited
operator|=
name|false
expr_stmt|;
name|dataflow_set_init
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|dataflow_set_init
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|out
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|attrs_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"attrs_def pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|attrs_def
argument_list|)
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|var_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"variable_def pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|variable_def
argument_list|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|loc_chain_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"location_chain_def pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|location_chain_def
argument_list|)
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|changed_variables
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|variable_htab_hash
argument_list|,
name|variable_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vt_add_function_parameters
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the data structures needed for variable tracking.  */
end_comment

begin_function
specifier|static
name|void
name|vt_finalize
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|free
argument_list|(
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|mos
argument_list|)
expr_stmt|;
block|}
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|dataflow_set_destroy
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|in
argument_list|)
expr_stmt|;
name|dataflow_set_destroy
argument_list|(
operator|&
name|VTI
argument_list|(
name|bb
argument_list|)
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|attrs_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|var_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|loc_chain_pool
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|changed_variables
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The entry point to variable tracking pass.  */
end_comment

begin_function
name|unsigned
name|int
name|variable_tracking_main
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|n_basic_blocks
operator|>
literal|500
operator|&&
name|n_edges
operator|/
name|n_basic_blocks
operator|>=
literal|20
condition|)
return|return
literal|0
return|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
name|vt_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
operator|!
name|vt_stack_adjustments
argument_list|()
condition|)
block|{
name|vt_finalize
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|vt_find_locations
argument_list|()
expr_stmt|;
name|vt_emit_notes
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|dump_dataflow_sets
argument_list|()
expr_stmt|;
name|dump_flow_info
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
name|vt_finalize
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_var_tracking
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|flag_var_tracking
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_variable_tracking
init|=
block|{
literal|"vartrack"
block|,
comment|/* name */
name|gate_handle_var_tracking
block|,
comment|/* gate */
name|variable_tracking_main
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_VAR_TRACKING
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'V'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

