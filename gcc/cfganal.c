begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph analysis code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains various simple utilities to analyze the CFG.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* Store the data structures necessary for depth-first search.  */
end_comment

begin_struct
struct|struct
name|depth_first_search_dsS
block|{
comment|/* stack for backtracking during the algorithm */
name|basic_block
modifier|*
name|stack
decl_stmt|;
comment|/* number of edges in the stack.  That is, positions 0, ..., sp-1      have edges.  */
name|unsigned
name|int
name|sp
decl_stmt|;
comment|/* record of basic blocks already seen by depth-first search */
name|sbitmap
name|visited_blocks
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|depth_first_search_dsS
modifier|*
name|depth_first_search_ds
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|flow_dfs_compute_reverse_init
parameter_list|(
name|depth_first_search_ds
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flow_dfs_compute_reverse_add_bb
parameter_list|(
name|depth_first_search_ds
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|flow_dfs_compute_reverse_execute
parameter_list|(
name|depth_first_search_ds
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flow_dfs_compute_reverse_finish
parameter_list|(
name|depth_first_search_ds
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|flow_active_insn_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Like active_insn_p, except keep the return value clobber around    even after reload.  */
end_comment

begin_function
specifier|static
name|bool
name|flow_active_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* A clobber of the function return value exists for buggy      programs that fail to return a value.  Its effect is to      keep the return value from being live across the entire      function.  If we allow it to be skipped, we introduce the      possibility for register lifetime confusion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if the block has no effect and only forwards control flow to    its single destination.  */
end_comment

begin_function
name|bool
name|forwarder_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|bb
operator|==
name|ENTRY_BLOCK_PTR
operator|||
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|flow_active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|!
name|flow_active_insn_p
argument_list|(
name|insn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if we can reach target from src by falling through.  */
end_comment

begin_function
name|bool
name|can_fallthru
parameter_list|(
name|basic_block
name|src
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|rtx
name|insn2
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|true
return|;
if|if
condition|(
name|src
operator|->
name|next_bb
operator|!=
name|target
condition|)
return|return
literal|0
return|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|src->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
return|return
literal|0
return|;
name|insn2
operator|=
name|BB_HEAD
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn2
operator|&&
operator|!
name|active_insn_p
argument_list|(
name|insn2
argument_list|)
condition|)
name|insn2
operator|=
name|next_active_insn
argument_list|(
name|insn2
argument_list|)
expr_stmt|;
comment|/* ??? Later we may add code to move jump tables offline.  */
return|return
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|==
name|insn2
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if we could reach target from src by falling through,    if the target was made adjacent.  If we already have a fall-through    edge to the exit block, we can't do that.  */
end_comment

begin_function
name|bool
name|could_fall_through
parameter_list|(
name|basic_block
name|src
parameter_list|,
name|basic_block
name|target
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|true
return|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|src->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
return|return
literal|0
return|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark the back edges in DFS traversal.    Return nonzero if a loop (natural or otherwise) is present.    Inspired by Depth_First_Search_PP described in:       Advanced Compiler Design and Implementation      Steven Muchnick      Morgan Kaufmann, 1997     and heavily borrowed from pre_and_rev_post_order_compute.  */
end_comment

begin_function
name|bool
name|mark_dfs_back_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|edge_iterator
modifier|*
name|stack
decl_stmt|;
name|int
modifier|*
name|pre
decl_stmt|;
name|int
modifier|*
name|post
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|prenum
init|=
literal|1
decl_stmt|;
name|int
name|postnum
init|=
literal|1
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
comment|/* Allocate the preorder and postorder number arrays.  */
name|pre
operator|=
name|XCNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|post
operator|=
name|XCNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|edge_iterator
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|ei
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|dest
expr_stmt|;
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|EDGE_DFS_BACK
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Mark that we have visited the destination.  */
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|pre
index|[
name|dest
operator|->
name|index
index|]
operator|=
name|prenum
operator|++
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Since the DEST node has been visited for the first 		 time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
expr_stmt|;
block|}
else|else
name|post
index|[
name|dest
operator|->
name|index
index|]
operator|=
name|postnum
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|pre
index|[
name|src
operator|->
name|index
index|]
operator|>=
name|pre
index|[
name|dest
operator|->
name|index
index|]
operator|&&
name|post
index|[
name|dest
operator|->
name|index
index|]
operator|==
literal|0
condition|)
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_DFS_BACK
operator|,
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|ei_one_before_end_p
argument_list|(
name|ei
argument_list|)
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|post
index|[
name|src
operator|->
name|index
index|]
operator|=
name|postnum
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ei_one_before_end_p
argument_list|(
name|ei
argument_list|)
condition|)
name|ei_next
argument_list|(
operator|&
name|stack
index|[
name|sp
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pre
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|post
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Set the flag EDGE_CAN_FALLTHRU for edges that can be fallthru.  */
end_comment

begin_function
name|void
name|set_edge_can_fallthru_flag
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_CAN_FALLTHRU
expr_stmt|;
comment|/* The FALLTHRU edge is also CAN_FALLTHRU edge.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_CAN_FALLTHRU
expr_stmt|;
block|}
comment|/* If the BB ends with an invertible condjump all (2) edges are 	 CAN_FALLTHRU edges.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|invert_jump
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|invert_jump
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_CAN_FALLTHRU
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_CAN_FALLTHRU
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find unreachable blocks.  An unreachable block will have 0 in    the reachable bit in block->flags.  A nonzero value indicates the    block is reachable.  */
end_comment

begin_function
name|void
name|find_unreachable_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
modifier|*
name|tos
decl_stmt|,
modifier|*
name|worklist
decl_stmt|,
name|bb
decl_stmt|;
name|tos
operator|=
name|worklist
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Clear all the reachability flags.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|bb
operator|->
name|flags
operator|&=
operator|~
name|BB_REACHABLE
expr_stmt|;
comment|/* Add our starting points to the worklist.  Almost always there will      be only one.  It isn't inconceivable that we might one day directly      support Fortran alternate entry points.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
block|{
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Mark the block reachable.  */
name|e
operator|->
name|dest
operator|->
name|flags
operator||=
name|BB_REACHABLE
expr_stmt|;
block|}
comment|/* Iterate: find everything reachable from what we've already seen.  */
while|while
condition|(
name|tos
operator|!=
name|worklist
condition|)
block|{
name|basic_block
name|b
init|=
operator|*
operator|--
name|tos
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|b->succs
argument_list|)
block|{
name|basic_block
name|dest
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dest
operator|->
name|flags
operator|&
name|BB_REACHABLE
operator|)
condition|)
block|{
operator|*
name|tos
operator|++
operator|=
name|dest
expr_stmt|;
name|dest
operator|->
name|flags
operator||=
name|BB_REACHABLE
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to access an edge list with a vector representation.    Enough data is kept such that given an index number, the    pred and succ that edge represents can be determined, or    given a pred and a succ, its index number can be returned.    This allows algorithms which consume a lot of memory to    represent the normally full matrix of edge (pred,succ) with a    single indexed vector,  edge (EDGE_INDEX (pred, succ)), with no    wasted space in the client code due to sparse flow graphs.  */
end_comment

begin_comment
comment|/* This functions initializes the edge list. Basically the entire    flowgraph is processed, and all edges are assigned a number,    and the data structure is filled in.  */
end_comment

begin_function
name|struct
name|edge_list
modifier|*
name|create_edge_list
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|edge_list
modifier|*
name|elist
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|num_edges
decl_stmt|;
name|int
name|block_count
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|block_count
operator|=
name|n_basic_blocks
expr_stmt|;
comment|/* Include the entry and exit blocks.  */
name|num_edges
operator|=
literal|0
expr_stmt|;
comment|/* Determine the number of edges in the flow graph by counting successor      edges on each basic block.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|num_edges
operator|+=
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
expr_stmt|;
block|}
name|elist
operator|=
name|XNEW
argument_list|(
expr|struct
name|edge_list
argument_list|)
expr_stmt|;
name|elist
operator|->
name|num_blocks
operator|=
name|block_count
expr_stmt|;
name|elist
operator|->
name|num_edges
operator|=
name|num_edges
expr_stmt|;
name|elist
operator|->
name|index_to_edge
operator|=
name|XNEWVEC
argument_list|(
name|edge
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
name|num_edges
operator|=
literal|0
expr_stmt|;
comment|/* Follow successors of blocks, and register these edges.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|elist
operator|->
name|index_to_edge
index|[
name|num_edges
operator|++
index|]
operator|=
name|e
expr_stmt|;
return|return
name|elist
return|;
block|}
end_function

begin_comment
comment|/* This function free's memory associated with an edge list.  */
end_comment

begin_function
name|void
name|free_edge_list
parameter_list|(
name|struct
name|edge_list
modifier|*
name|elist
parameter_list|)
block|{
if|if
condition|(
name|elist
condition|)
block|{
name|free
argument_list|(
name|elist
operator|->
name|index_to_edge
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function provides debug output showing an edge list.  */
end_comment

begin_function
name|void
name|print_edge_list
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|edge_list
modifier|*
name|elist
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Compressed edge list, %d BBs + entry& exit, and %d edges\n"
argument_list|,
name|elist
operator|->
name|num_blocks
argument_list|,
name|elist
operator|->
name|num_edges
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|elist
operator|->
name|num_edges
condition|;
name|x
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %-4d - edge("
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"entry,"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d,"
argument_list|,
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"exit)\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d)\n"
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|x
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function provides an internal consistency check of an edge list,    verifying that all edges are present, and that there are no    extra edges.  */
end_comment

begin_function
name|void
name|verify_edge_list
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|edge_list
modifier|*
name|elist
parameter_list|)
block|{
name|int
name|pred
decl_stmt|,
name|succ
decl_stmt|,
name|index
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|p
decl_stmt|,
name|s
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|pred
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
name|succ
operator|=
name|e
operator|->
name|dest
operator|->
name|index
expr_stmt|;
name|index
operator|=
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|EDGE_INDEX_NO_EDGE
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* No index for edge from %d to %d\n"
argument_list|,
name|pred
argument_list|,
name|succ
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
operator|!=
name|pred
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* Pred for index %d should be %d not %d\n"
argument_list|,
name|index
argument_list|,
name|pred
argument_list|,
name|INDEX_EDGE_PRED_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
operator|!=
name|succ
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*p* Succ for index %d should be %d not %d\n"
argument_list|,
name|index
argument_list|,
name|succ
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|elist
argument_list|,
name|index
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We've verified that all the edges are in the list, now lets make sure      there are no spurious edges in the list.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|p
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
name|FOR_BB_BETWEEN
argument_list|(
argument|s
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|int
name|found_edge
init|=
literal|0
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|p->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|s
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|s->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|p
condition|)
block|{
name|found_edge
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
operator|==
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (%d, %d) appears to not have an index\n"
argument_list|,
name|p
operator|->
name|index
argument_list|,
name|s
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
operator|!=
name|EDGE_INDEX_NO_EDGE
operator|&&
name|found_edge
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*** Edge (%d, %d) has index %d, but there is no edge\n"
argument_list|,
name|p
operator|->
name|index
argument_list|,
name|s
operator|->
name|index
argument_list|,
name|EDGE_INDEX
argument_list|(
name|elist
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given PRED and SUCC blocks, return the edge which connects the blocks.    If no such edge exists, return NULL.  */
end_comment

begin_function
name|edge
name|find_edge
parameter_list|(
name|basic_block
name|pred
parameter_list|,
name|basic_block
name|succ
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|pred
operator|->
name|succs
argument_list|)
operator|<=
name|EDGE_COUNT
argument_list|(
name|succ
operator|->
name|preds
argument_list|)
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|pred->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|succ
condition|)
return|return
name|e
return|;
block|}
else|else
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|succ->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|pred
condition|)
return|return
name|e
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This routine will determine what, if any, edge there is between    a specified predecessor and successor.  */
end_comment

begin_function
name|int
name|find_edge_index
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|basic_block
name|pred
parameter_list|,
name|basic_block
name|succ
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
operator|==
name|pred
operator|&&
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
operator|==
name|succ
condition|)
return|return
name|x
return|;
return|return
operator|(
name|EDGE_INDEX_NO_EDGE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Dump the list of basic blocks in the bitmap NODES.  */
end_comment

begin_function
name|void
name|flow_nodes_print
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|sbitmap
name|nodes
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|int
name|node
init|=
literal|0
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s { "
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|nodes
argument_list|,
literal|0
argument_list|,
argument|node
argument_list|,
argument|sbi
argument_list|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the list of edges in the array EDGE_LIST.  */
end_comment

begin_function
name|void
name|flow_edge_list_print
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|edge
modifier|*
name|edge_list
parameter_list|,
name|int
name|num_edges
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|edge_list
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s { "
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_edges
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d->%d "
argument_list|,
name|edge_list
index|[
name|i
index|]
operator|->
name|src
operator|->
name|index
argument_list|,
name|edge_list
index|[
name|i
index|]
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine will remove any fake predecessor edges for a basic block.    When the edge is removed, it is also removed from whatever successor    list it is in.  */
end_comment

begin_function
specifier|static
name|void
name|remove_fake_predecessors
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|==
name|EDGE_FAKE
condition|)
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will remove all fake edges from the flow graph.  If    we remove all fake successors, it will automatically remove all    fake predecessors.  */
end_comment

begin_function
name|void
name|remove_fake_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|remove_fake_predecessors
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine will remove all fake edges to the EXIT_BLOCK.  */
end_comment

begin_function
name|void
name|remove_fake_exit_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|remove_fake_predecessors
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will add a fake edge between any block which has no    successors, and the exit block. Some data flow equations require these    edges to exist.  */
end_comment

begin_function
name|void
name|add_noreturn_fake_exit_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|==
literal|0
condition|)
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function adds a fake edge between any infinite loops to the    exit block.  Some optimizations require a path from each node to    the exit node.     See also Morgan, Figure 3.10, pp. 82-83.     The current implementation is ugly, not attempting to minimize the    number of inserted fake edges.  To reduce the number of fake edges    to insert, add fake edges from _innermost_ loops containing only    nodes not reachable from the exit block.  */
end_comment

begin_function
name|void
name|connect_infinite_loops_to_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|unvisited_block
init|=
name|EXIT_BLOCK_PTR
decl_stmt|;
name|struct
name|depth_first_search_dsS
name|dfs_ds
decl_stmt|;
comment|/* Perform depth-first search in the reverse graph to find nodes      reachable from the exit block.  */
name|flow_dfs_compute_reverse_init
argument_list|(
operator|&
name|dfs_ds
argument_list|)
expr_stmt|;
name|flow_dfs_compute_reverse_add_bb
argument_list|(
operator|&
name|dfs_ds
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Repeatedly add fake edges, updating the unreachable nodes.  */
while|while
condition|(
literal|1
condition|)
block|{
name|unvisited_block
operator|=
name|flow_dfs_compute_reverse_execute
argument_list|(
operator|&
name|dfs_ds
argument_list|,
name|unvisited_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unvisited_block
condition|)
break|break;
name|make_edge
argument_list|(
name|unvisited_block
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FAKE
argument_list|)
expr_stmt|;
name|flow_dfs_compute_reverse_add_bb
argument_list|(
operator|&
name|dfs_ds
argument_list|,
name|unvisited_block
argument_list|)
expr_stmt|;
block|}
name|flow_dfs_compute_reverse_finish
argument_list|(
operator|&
name|dfs_ds
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute reverse top sort order.      This is computing a post order numbering of the graph.  */
end_comment

begin_function
name|int
name|post_order_compute
parameter_list|(
name|int
modifier|*
name|post_order
parameter_list|,
name|bool
name|include_entry_exit
parameter_list|)
block|{
name|edge_iterator
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|post_order_num
init|=
literal|0
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
if|if
condition|(
name|include_entry_exit
condition|)
name|post_order
index|[
name|post_order_num
operator|++
index|]
operator|=
name|EXIT_BLOCK
expr_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|edge_iterator
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|ei
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|dest
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Mark that we have visited the destination.  */
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
comment|/* Since the DEST node has been visited for the first 	       time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
expr_stmt|;
else|else
name|post_order
index|[
name|post_order_num
operator|++
index|]
operator|=
name|dest
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ei_one_before_end_p
argument_list|(
name|ei
argument_list|)
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|post_order
index|[
name|post_order_num
operator|++
index|]
operator|=
name|src
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|ei_one_before_end_p
argument_list|(
name|ei
argument_list|)
condition|)
name|ei_next
argument_list|(
operator|&
name|stack
index|[
name|sp
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|include_entry_exit
condition|)
name|post_order
index|[
name|post_order_num
operator|++
index|]
operator|=
name|ENTRY_BLOCK
expr_stmt|;
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|post_order_num
return|;
block|}
end_function

begin_comment
comment|/* Compute the depth first search order and store in the array   PRE_ORDER if nonzero, marking the nodes visited in VISITED.  If   REV_POST_ORDER is nonzero, return the reverse completion number for each   node.  Returns the number of nodes visited.  A depth first search   tries to get as far away from the starting point as quickly as   possible.     pre_order is a really a preorder numbering of the graph.   rev_post_order is really a reverse postorder numbering of the graph.  */
end_comment

begin_function
name|int
name|pre_and_rev_post_order_compute
parameter_list|(
name|int
modifier|*
name|pre_order
parameter_list|,
name|int
modifier|*
name|rev_post_order
parameter_list|,
name|bool
name|include_entry_exit
parameter_list|)
block|{
name|edge_iterator
modifier|*
name|stack
decl_stmt|;
name|int
name|sp
decl_stmt|;
name|int
name|pre_order_num
init|=
literal|0
decl_stmt|;
name|int
name|rev_post_order_num
init|=
name|n_basic_blocks
operator|-
literal|1
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
comment|/* Allocate stack for back-tracking up CFG.  */
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|edge_iterator
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|include_entry_exit
condition|)
block|{
if|if
condition|(
name|pre_order
condition|)
name|pre_order
index|[
name|pre_order_num
index|]
operator|=
name|ENTRY_BLOCK
expr_stmt|;
name|pre_order_num
operator|++
expr_stmt|;
if|if
condition|(
name|rev_post_order
condition|)
name|rev_post_order
index|[
name|rev_post_order_num
operator|--
index|]
operator|=
name|ENTRY_BLOCK
expr_stmt|;
block|}
else|else
name|rev_post_order_num
operator|-=
name|NUM_FIXED_BLOCKS
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* Push the first edge on to the stack.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|src
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
comment|/* Look at the edge on the top of the stack.  */
name|ei
operator|=
name|stack
index|[
name|sp
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|ei_edge
argument_list|(
name|ei
argument_list|)
operator|->
name|dest
expr_stmt|;
comment|/* Check if the edge destination has been visited yet.  */
if|if
condition|(
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Mark that we have visited the destination.  */
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_order
condition|)
name|pre_order
index|[
name|pre_order_num
index|]
operator|=
name|dest
operator|->
name|index
expr_stmt|;
name|pre_order_num
operator|++
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
comment|/* Since the DEST node has been visited for the first 	       time, check its successors.  */
name|stack
index|[
name|sp
operator|++
index|]
operator|=
name|ei_start
argument_list|(
name|dest
operator|->
name|succs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rev_post_order
condition|)
comment|/* There are no successors for the DEST node so assign 	       its reverse completion number.  */
name|rev_post_order
index|[
name|rev_post_order_num
operator|--
index|]
operator|=
name|dest
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ei_one_before_end_p
argument_list|(
name|ei
argument_list|)
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|rev_post_order
condition|)
comment|/* There are no more successors for the SRC node 	       so assign its reverse completion number.  */
name|rev_post_order
index|[
name|rev_post_order_num
operator|--
index|]
operator|=
name|src
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|ei_one_before_end_p
argument_list|(
name|ei
argument_list|)
condition|)
name|ei_next
argument_list|(
operator|&
name|stack
index|[
name|sp
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_entry_exit
condition|)
block|{
if|if
condition|(
name|pre_order
condition|)
name|pre_order
index|[
name|pre_order_num
index|]
operator|=
name|EXIT_BLOCK
expr_stmt|;
name|pre_order_num
operator|++
expr_stmt|;
if|if
condition|(
name|rev_post_order
condition|)
name|rev_post_order
index|[
name|rev_post_order_num
operator|--
index|]
operator|=
name|EXIT_BLOCK
expr_stmt|;
comment|/* The number of nodes visited should be the number of blocks.  */
name|gcc_assert
argument_list|(
name|pre_order_num
operator|==
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The number of nodes visited should be the number of blocks minus        the entry and exit blocks which are not visited here.  */
name|gcc_assert
argument_list|(
name|pre_order_num
operator|==
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
return|return
name|pre_order_num
return|;
block|}
end_function

begin_comment
comment|/* Compute the depth first search order on the _reverse_ graph and    store in the array DFS_ORDER, marking the nodes visited in VISITED.    Returns the number of nodes visited.     The computation is split into three pieces:     flow_dfs_compute_reverse_init () creates the necessary data    structures.     flow_dfs_compute_reverse_add_bb () adds a basic block to the data    structures.  The block will start the search.     flow_dfs_compute_reverse_execute () continues (or starts) the    search using the block on the top of the stack, stopping when the    stack is empty.     flow_dfs_compute_reverse_finish () destroys the necessary data    structures.     Thus, the user will probably call ..._init(), call ..._add_bb() to    add a beginning basic block to the stack, call ..._execute(),    possibly add another bb to the stack and again call ..._execute(),    ..., and finally call _finish().  */
end_comment

begin_comment
comment|/* Initialize the data structures used for depth-first search on the    reverse graph.  If INITIALIZE_STACK is nonzero, the exit block is    added to the basic block stack.  DATA is the current depth-first    search context.  If INITIALIZE_STACK is nonzero, there is an    element on the stack.  */
end_comment

begin_function
specifier|static
name|void
name|flow_dfs_compute_reverse_init
parameter_list|(
name|depth_first_search_ds
name|data
parameter_list|)
block|{
comment|/* Allocate stack for back-tracking up CFG.  */
name|data
operator|->
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|data
operator|->
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bitmap to track nodes that have been visited.  */
name|data
operator|->
name|visited_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* None of the nodes in the CFG have been visited yet.  */
name|sbitmap_zero
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Add the specified basic block to the top of the dfs data    structures.  When the search continues, it will start at the    block.  */
end_comment

begin_function
specifier|static
name|void
name|flow_dfs_compute_reverse_add_bb
parameter_list|(
name|depth_first_search_ds
name|data
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|data
operator|->
name|stack
index|[
name|data
operator|->
name|sp
operator|++
index|]
operator|=
name|bb
expr_stmt|;
name|SET_BIT
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Continue the depth-first search through the reverse graph starting with the    block at the stack's top and ending when the stack is empty.  Visited nodes    are marked.  Returns an unvisited basic block, or NULL if there is none    available.  */
end_comment

begin_function
specifier|static
name|basic_block
name|flow_dfs_compute_reverse_execute
parameter_list|(
name|depth_first_search_ds
name|data
parameter_list|,
name|basic_block
name|last_unvisited
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
while|while
condition|(
name|data
operator|->
name|sp
operator|>
literal|0
condition|)
block|{
name|bb
operator|=
name|data
operator|->
name|stack
index|[
operator|--
name|data
operator|->
name|sp
index|]
expr_stmt|;
comment|/* Perform depth-first search on adjacent vertices.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
name|flow_dfs_compute_reverse_add_bb
argument_list|(
name|data
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Determine if there are unvisited basic blocks.  */
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|last_unvisited
argument_list|,
argument|NULL
argument_list|,
argument|prev_bb
argument_list|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
return|return
name|bb
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Destroy the data structures needed for depth-first search on the    reverse graph.  */
end_comment

begin_function
specifier|static
name|void
name|flow_dfs_compute_reverse_finish
parameter_list|(
name|depth_first_search_ds
name|data
parameter_list|)
block|{
name|free
argument_list|(
name|data
operator|->
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|data
operator|->
name|visited_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Performs dfs search from BB over vertices satisfying PREDICATE;    if REVERSE, go against direction of edges.  Returns number of blocks    found and their list in RSLT.  RSLT can contain at most RSLT_MAX items.  */
end_comment

begin_function
name|int
name|dfs_enumerate_from
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|reverse
parameter_list|,
name|bool
function_decl|(
modifier|*
name|predicate
function_decl|)
parameter_list|(
name|basic_block
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|basic_block
modifier|*
name|rslt
parameter_list|,
name|int
name|rslt_max
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|basic_block
modifier|*
name|st
decl_stmt|,
name|lbb
decl_stmt|;
name|int
name|sp
init|=
literal|0
decl_stmt|,
name|tv
init|=
literal|0
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
comment|/* A bitmap to keep track of visited blocks.  Allocating it each time      this function is called is not possible, since dfs_enumerate_from      is often used on small (almost) disjoint parts of cfg (bodies of      loops), and allocating a large sbitmap would lead to quadratic      behavior.  */
specifier|static
name|sbitmap
name|visited
decl_stmt|;
specifier|static
name|unsigned
name|v_size
decl_stmt|;
define|#
directive|define
name|MARK_VISITED
parameter_list|(
name|BB
parameter_list|)
value|(SET_BIT (visited, (BB)->index))
define|#
directive|define
name|UNMARK_VISITED
parameter_list|(
name|BB
parameter_list|)
value|(RESET_BIT (visited, (BB)->index))
define|#
directive|define
name|VISITED_P
parameter_list|(
name|BB
parameter_list|)
value|(TEST_BIT (visited, (BB)->index))
comment|/* Resize the VISITED sbitmap if necessary.  */
name|size
operator|=
name|last_basic_block
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|10
condition|)
name|size
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|!
name|visited
condition|)
block|{
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|v_size
operator|=
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v_size
operator|<
name|size
condition|)
block|{
comment|/* Ensure that we increase the size of the sbitmap exponentially.  */
if|if
condition|(
literal|2
operator|*
name|v_size
operator|>
name|size
condition|)
name|size
operator|=
literal|2
operator|*
name|v_size
expr_stmt|;
name|visited
operator|=
name|sbitmap_resize
argument_list|(
name|visited
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v_size
operator|=
name|size
expr_stmt|;
block|}
name|st
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|rslt_max
argument_list|)
expr_stmt|;
name|rslt
index|[
name|tv
operator|++
index|]
operator|=
name|st
index|[
name|sp
operator|++
index|]
operator|=
name|bb
expr_stmt|;
name|MARK_VISITED
argument_list|(
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|lbb
operator|=
name|st
index|[
operator|--
name|sp
index|]
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|lbb->preds
argument_list|)
if|if
condition|(
operator|!
name|VISITED_P
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|&&
name|predicate
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|tv
operator|!=
name|rslt_max
argument_list|)
expr_stmt|;
name|rslt
index|[
name|tv
operator|++
index|]
operator|=
name|st
index|[
name|sp
operator|++
index|]
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|MARK_VISITED
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|lbb->succs
argument_list|)
if|if
condition|(
operator|!
name|VISITED_P
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|&&
name|predicate
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|tv
operator|!=
name|rslt_max
argument_list|)
expr_stmt|;
name|rslt
index|[
name|tv
operator|++
index|]
operator|=
name|st
index|[
name|sp
operator|++
index|]
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|MARK_VISITED
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
literal|0
init|;
name|sp
operator|<
name|tv
condition|;
name|sp
operator|++
control|)
name|UNMARK_VISITED
argument_list|(
name|rslt
index|[
name|sp
index|]
argument_list|)
expr_stmt|;
return|return
name|tv
return|;
undef|#
directive|undef
name|MARK_VISITED
undef|#
directive|undef
name|UNMARK_VISITED
undef|#
directive|undef
name|VISITED_P
block|}
end_function

begin_comment
comment|/* Compute dominance frontiers, ala Harvey, Ferrante, et al.     This algorithm can be found in Timothy Harvey's PhD thesis, at    http://www.cs.rice.edu/~harv/dissertation.pdf in the section on iterative    dominance algorithms.     First, we identify each join point, j (any node with more than one    incoming edge is a join point).     We then examine each predecessor, p, of j and walk up the dominator tree    starting at p.     We stop the walk when we reach j's immediate dominator - j is in the    dominance frontier of each of  the nodes in the walk, except for j's    immediate dominator. Intuitively, all of the rest of j's dominators are    shared by j's predecessors as well.    Since they dominate j, they will not have j in their dominance frontiers.     The number of nodes touched by this algorithm is equal to the size    of the dominance frontiers, no more, no less. */
end_comment

begin_function
specifier|static
name|void
name|compute_dominance_frontiers_1
parameter_list|(
name|bitmap
modifier|*
name|frontiers
parameter_list|)
block|{
name|edge
name|p
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
block|{
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|b
operator|->
name|preds
argument_list|)
operator|>=
literal|2
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|p
argument_list|,
argument|ei
argument_list|,
argument|b->preds
argument_list|)
block|{
name|basic_block
name|runner
init|=
name|p
operator|->
name|src
decl_stmt|;
name|basic_block
name|domsb
decl_stmt|;
if|if
condition|(
name|runner
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
name|domsb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|runner
operator|!=
name|domsb
condition|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|frontiers
index|[
name|runner
operator|->
name|index
index|]
argument_list|,
name|b
operator|->
name|index
argument_list|)
condition|)
break|break;
name|bitmap_set_bit
argument_list|(
name|frontiers
index|[
name|runner
operator|->
name|index
index|]
argument_list|,
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
name|runner
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|runner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|compute_dominance_frontiers
parameter_list|(
name|bitmap
modifier|*
name|frontiers
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_DOM_FRONTIERS
argument_list|)
expr_stmt|;
name|compute_dominance_frontiers_1
argument_list|(
name|frontiers
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DOM_FRONTIERS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

