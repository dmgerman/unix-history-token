begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocation for dataflow support routines.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Originally contributed by Michael P. Hayes               (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)              and Kenneth Zadeck (zadeck@naturalbridge.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   */
end_comment

begin_comment
comment|/* OVERVIEW:  The files in this collection (df*.c,df.h) provide a general framework for solving dataflow problems.  The global dataflow is performed using a good implementation of iterative dataflow analysis.  The file df-problems.c provides problem instance for the most common dataflow problems: reaching defs, upward exposed uses, live variables, uninitialized variables, def-use chains, and use-def chains.  However, the interface allows other dataflow problems to be defined as well.   USAGE:  Here is an example of using the dataflow routines.        struct df *df;        df = df_init (init_flags);              df_add_problem (df, problem, flags);        df_set_blocks (df, blocks);        df_rescan_blocks (df, blocks);        df_analyze (df);        df_dump (df, stderr);        df_finish (df);    DF_INIT simply creates a poor man's object (df) that needs to be passed to all the dataflow routines.  df_finish destroys this object and frees up any allocated memory.  There are three flags that can be passed to df_init, each of these flags controls the scanning of the rtl:  DF_HARD_REGS means that the scanning is to build information about both pseudo registers and hardware registers.  Without this information, the problems will be solved only on pseudo registers. DF_EQUIV_NOTES marks the uses present in EQUIV/EQUAL notes. DF_SUBREGS return subregs rather than the inner reg.   DF_ADD_PROBLEM adds a problem, defined by an instance to struct df_problem, to the set of problems solved in this instance of df.  All calls to add a problem for a given instance of df must occur before the first call to DF_RESCAN_BLOCKS, DF_SET_BLOCKS or DF_ANALYZE.  For all of the problems defined in df-problems.c, there are convenience functions named DF_*_ADD_PROBLEM.   Problems can be dependent on other problems.  For instance, solving def-use or use-def chains is dependent on solving reaching definitions. As long as these dependencies are listed in the problem definition, the order of adding the problems is not material. Otherwise, the problems will be solved in the order of calls to df_add_problem.  Note that it is not necessary to have a problem.  In that case, df will just be used to do the scanning.    DF_SET_BLOCKS is an optional call used to define a region of the function on which the analysis will be performed.  The normal case is to analyze the entire function and no call to df_set_blocks is made.  When a subset is given, the analysis behaves as if the function only contains those blocks and any edges that occur directly between the blocks in the set.  Care should be taken to call df_set_blocks right before the call to analyze in order to eliminate the possibility that optimizations that reorder blocks invalidate the bitvector.    DF_RESCAN_BLOCKS is an optional call that causes the scanner to be  (re)run over the set of blocks passed in.  If blocks is NULL, the entire function (or all of the blocks defined in df_set_blocks) is rescanned. If blocks contains blocks that were not defined in the call to df_set_blocks, these blocks are added to the set of blocks.   DF_ANALYZE causes all of the defined problems to be (re)solved.  It does not cause blocks to be (re)scanned at the rtl level unless no prior call is made to df_rescan_blocks.  When DF_ANALYZE is completes, the IN and OUT sets for each basic block contain the computer information.  The DF_*_BB_INFO macros can be used to access these bitvectors.   DF_DUMP can then be called to dump the information produce to some file.    DF_FINISH causes all of the datastructures to be cleaned up and freed. The df_instance is also freed and its pointer should be NULLed.     Scanning produces a `struct df_ref' data structure (ref) is allocated for every register reference (def or use) and this records the insn and bb the ref is found within.  The refs are linked together in chains of uses and defs for each insn and for each register.  Each ref also has a chain field that links all the use refs for a def or all the def refs for a use.  This is used to create use-def or def-use chains.  Different optimizations have different needs.  Ultimately, only register allocation and schedulers should be using the bitmaps produced for the live register and uninitialized register problems. The rest of the backend should be upgraded to using and maintaining the linked information such as def use or use def chains.    PHILOSOPHY:  While incremental bitmaps are not worthwhile to maintain, incremental chains may be perfectly reasonable.  The fastest way to build chains from scratch or after significant modifications is to build reaching definitions (RD) and build the chains from this.  However, general algorithms for maintaining use-def or def-use chains are not practical.  The amount of work to recompute the chain any chain after an arbitrary change is large.  However, with a modest amount of work it is generally possible to have the application that uses the chains keep them up to date.  The high level knowledge of what is really happening is essential to crafting efficient incremental algorithms.  As for the bit vector problems, there is no interface to give a set of blocks over with to resolve the iteration.  In general, restarting a dataflow iteration is difficult and expensive.  Again, the best way to keep the dataflow information up to data (if this is really what is needed) it to formulate a problem specific solution.  There are fine grained calls for creating and deleting references from instructions in df-scan.c.  However, these are not currently connected to the engine that resolves the dataflow equations.   DATA STRUCTURES:  The basic object is a DF_REF (reference) and this may either be a  DEF (definition) or a USE of a register.  These are linked into a variety of lists; namely reg-def, reg-use, insn-def, insn-use, def-use, and use-def lists.  For example, the reg-def lists contain all the locations that define a given register while the insn-use lists contain all the locations that use a register.  Note that the reg-def and reg-use chains are generally short for pseudos and long for the hard registers.  ACCESSING REFS:  There are 4 ways to obtain access to refs:  1) References are divided into two categories, REAL and ARTIFICIAL.     REAL refs are associated with instructions.  They are linked into    either in the insn's defs list (accessed by the DF_INSN_DEFS or    DF_INSN_UID_DEFS macros) or the insn's uses list (accessed by the    DF_INSN_USES or DF_INSN_UID_USES macros).  These macros produce a    ref (or NULL), the rest of the list can be obtained by traversal of    the NEXT_REF field (accessed by the DF_REF_NEXT_REF macro.)  There    is no significance to the ordering of the uses or refs in an    instruction.     ARTIFICIAL refs are associated with basic blocks.  The heads of    these lists can be accessed by calling get_artificial_defs or    get_artificial_uses for the particular basic block.  Artificial    defs and uses are only there if DF_HARD_REGS was specified when the    df instance was created.      Artificial defs and uses occur both at the beginning and ends of blocks.       For blocks that area at the destination of eh edges, the      artificial uses and defs occur at the beginning.  The defs relate      to the registers specified in EH_RETURN_DATA_REGNO and the uses      relate to the registers specified in ED_USES.  Logically these      defs and uses should really occur along the eh edge, but there is      no convenient way to do this.  Artificial edges that occur at the      beginning of the block have the DF_REF_AT_TOP flag set.       Artificial uses occur at the end of all blocks.  These arise from      the hard registers that are always live, such as the stack      register and are put there to keep the code from forgetting about      them.       Artificial defs occur at the end of the entry block.  These arise      from registers that are live at entry to the function.  2) All of the uses and defs associated with each pseudo or hard    register are linked in a bidirectional chain.  These are called    reg-use or reg_def chains.     The first use (or def) for a register can be obtained using the    DF_REG_USE_GET macro (or DF_REG_DEF_GET macro).  Subsequent uses    for the same regno can be obtained by following the next_reg field    of the ref.     In previous versions of this code, these chains were ordered.  It    has not been practical to continue this practice.  3) If def-use or use-def chains are built, these can be traversed to    get to other refs.  4) An array of all of the uses (and an array of all of the defs) can    be built.  These arrays are indexed by the value in the id    structure.  These arrays are only lazily kept up to date, and that    process can be expensive.  To have these arrays built, call    df_reorganize_refs.   Note that the values in the id field of a ref    may change across calls to df_analyze or df_reorganize refs.     If the only use of this array is to find all of the refs, it is    better to traverse all of the registers and then traverse all of    reg-use or reg-def chains.    NOTES:   Embedded addressing side-effects, such as POST_INC or PRE_INC, generate both a use and a def.  These are both marked read/write to show that they are dependent. For example, (set (reg 40) (mem (post_inc (reg 42)))) will generate a use of reg 42 followed by a def of reg 42 (both marked read/write).  Similarly, (set (reg 40) (mem (pre_dec (reg 41)))) generates a use of reg 41 then a def of reg 41 (both marked read/write), even though reg 41 is decremented before it is used for the memory address in this second example.  A set to a REG inside a ZERO_EXTRACT, or a set to a non-paradoxical SUBREG for which the number of word_mode units covered by the outer mode is smaller than that covered by the inner mode, invokes a read-modify-write. operation.  We generate both a use and a def and again mark them read/write.  Paradoxical subreg writes do not leave a trace of the old content, so they are write-only operations.   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|df
modifier|*
name|ddf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|df
modifier|*
name|shared_df
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
modifier|*
name|df_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|df_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*----------------------------------------------------------------------------   Functions to create, destroy and manipulate an instance of df. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Initialize dataflow analysis and allocate and initialize dataflow    memory.  */
end_comment

begin_function
name|struct
name|df
modifier|*
name|df_init
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|XCNEW
argument_list|(
expr|struct
name|df
argument_list|)
decl_stmt|;
comment|/* This is executed once per compilation to initialize platform      specific data structures. */
name|df_hard_reg_init
argument_list|()
expr_stmt|;
comment|/* All df instance must define the scanning problem.  */
name|df_scan_add_problem
argument_list|(
name|df
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ddf
operator|=
name|df
expr_stmt|;
return|return
name|df
return|;
block|}
end_function

begin_comment
comment|/* Add PROBLEM to the DF instance.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|struct
name|df_problem
modifier|*
name|problem
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
decl_stmt|;
comment|/* First try to add the dependent problem. */
if|if
condition|(
name|problem
operator|->
name|dependent_problem_fun
condition|)
call|(
name|problem
operator|->
name|dependent_problem_fun
call|)
argument_list|(
name|df
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see if this problem has already been defined.  If it      has, just return that instance, if not, add it to the end of the      vector.  */
name|dflow
operator|=
name|df
operator|->
name|problems_by_index
index|[
name|problem
operator|->
name|id
index|]
expr_stmt|;
if|if
condition|(
name|dflow
condition|)
return|return
name|dflow
return|;
comment|/* Make a new one and add it to the end.  */
name|dflow
operator|=
name|XCNEW
argument_list|(
expr|struct
name|dataflow
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|dflow
operator|->
name|df
operator|=
name|df
expr_stmt|;
name|dflow
operator|->
name|problem
operator|=
name|problem
expr_stmt|;
name|df
operator|->
name|problems_in_order
index|[
name|df
operator|->
name|num_problems_defined
operator|++
index|]
operator|=
name|dflow
expr_stmt|;
name|df
operator|->
name|problems_by_index
index|[
name|dflow
operator|->
name|problem
operator|->
name|id
index|]
operator|=
name|dflow
expr_stmt|;
return|return
name|dflow
return|;
block|}
end_function

begin_comment
comment|/* Set the MASK flags in the DFLOW problem.  The old flags are    returned.  If a flag is not allowed to be changed this will fail if    checking is enabled.  */
end_comment

begin_function
name|int
name|df_set_flags
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|int
name|old_flags
init|=
name|dflow
operator|->
name|flags
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|(
operator|~
name|dflow
operator|->
name|problem
operator|->
name|changeable_flags
operator|)
operator|)
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|flags
operator||=
name|mask
expr_stmt|;
return|return
name|old_flags
return|;
block|}
end_function

begin_comment
comment|/* Clear the MASK flags in the DFLOW problem.  The old flags are    returned.  If a flag is not allowed to be changed this will fail if    checking is enabled.  */
end_comment

begin_function
name|int
name|df_clear_flags
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|int
name|old_flags
init|=
name|dflow
operator|->
name|flags
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|mask
operator|&
operator|(
operator|~
name|dflow
operator|->
name|problem
operator|->
name|changeable_flags
operator|)
operator|)
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|flags
operator|&=
operator|!
name|mask
expr_stmt|;
return|return
name|old_flags
return|;
block|}
end_function

begin_comment
comment|/* Set the blocks that are to be considered for analysis.  If this is    not called or is called with null, the entire function in    analyzed.  */
end_comment

begin_function
name|void
name|df_set_blocks
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|bitmap
name|blocks
parameter_list|)
block|{
if|if
condition|(
name|blocks
condition|)
block|{
if|if
condition|(
name|df
operator|->
name|blocks_to_analyze
condition|)
block|{
name|int
name|p
decl_stmt|;
name|bitmap
name|diff
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_and_compl
argument_list|(
name|diff
argument_list|,
name|df
operator|->
name|blocks_to_analyze
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|df
operator|->
name|num_problems_defined
operator|-
literal|1
init|;
name|p
operator|>=
literal|0
condition|;
name|p
operator|--
control|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_in_order
index|[
name|p
index|]
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|reset_fun
condition|)
name|dflow
operator|->
name|problem
operator|->
name|reset_fun
argument_list|(
name|dflow
argument_list|,
name|df
operator|->
name|blocks_to_analyze
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|free_bb_fun
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|diff
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb
condition|)
block|{
name|dflow
operator|->
name|problem
operator|->
name|free_bb_fun
argument_list|(
name|dflow
argument_list|,
name|bb
argument_list|,
name|df_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
argument_list|)
expr_stmt|;
name|df_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we have not actually run scanning before, do not try 	     to clear anything.  */
name|struct
name|dataflow
modifier|*
name|scan_dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_SCAN
index|]
decl_stmt|;
if|if
condition|(
name|scan_dflow
operator|->
name|problem_data
condition|)
block|{
name|bitmap
name|blocks_to_reset
init|=
name|NULL
decl_stmt|;
name|int
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|df
operator|->
name|num_problems_defined
operator|-
literal|1
init|;
name|p
operator|>=
literal|0
condition|;
name|p
operator|--
control|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_in_order
index|[
name|p
index|]
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|reset_fun
condition|)
block|{
if|if
condition|(
operator|!
name|blocks_to_reset
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|blocks_to_reset
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bitmap_set_bit
argument_list|(
name|blocks_to_reset
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|dflow
operator|->
name|problem
operator|->
name|reset_fun
argument_list|(
name|dflow
argument_list|,
name|blocks_to_reset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blocks_to_reset
condition|)
name|BITMAP_FREE
argument_list|(
name|blocks_to_reset
argument_list|)
expr_stmt|;
block|}
name|df
operator|->
name|blocks_to_analyze
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|bitmap_copy
argument_list|(
name|df
operator|->
name|blocks_to_analyze
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|df
operator|->
name|blocks_to_analyze
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|blocks_to_analyze
argument_list|)
expr_stmt|;
name|df
operator|->
name|blocks_to_analyze
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free all of the per basic block dataflow from all of the problems.    This is typically called before a basic block is deleted and the    problem will be reanalyzed.  */
end_comment

begin_function
name|void
name|df_delete_basic_block
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|bb_index
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|num_problems_defined
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_in_order
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|free_bb_fun
condition|)
name|dflow
operator|->
name|problem
operator|->
name|free_bb_fun
argument_list|(
name|dflow
argument_list|,
name|bb
argument_list|,
name|df_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free all the dataflow info and the DF structure.  This should be    called from the df_finish macro which also NULLs the parm.  */
end_comment

begin_function
name|void
name|df_finish1
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|num_problems_defined
condition|;
name|i
operator|++
control|)
name|df
operator|->
name|problems_in_order
index|[
name|i
index|]
operator|->
name|problem
operator|->
name|free_fun
argument_list|(
name|df
operator|->
name|problems_in_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    The general data flow analysis engine. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Hybrid search algorithm from "Implementation Techniques for    Efficient Data-Flow Analysis of Large Programs".  */
end_comment

begin_function
specifier|static
name|void
name|df_hybrid_search_forward
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|dataflow
modifier|*
name|dataflow
parameter_list|,
name|bool
name|single_pass
parameter_list|)
block|{
name|int
name|result_changed
decl_stmt|;
name|int
name|i
init|=
name|bb
operator|->
name|index
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|SET_BIT
argument_list|(
name|dataflow
operator|->
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|pending
argument_list|,
name|bb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|dataflow
operator|->
name|pending
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*  Calculate<conf_op> of predecessor_outs.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|>
literal|0
condition|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|considered
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|dataflow
operator|->
name|problem
operator|->
name|con_fun_n
argument_list|(
name|dataflow
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dataflow
operator|->
name|problem
operator|->
name|con_fun_0
condition|)
name|dataflow
operator|->
name|problem
operator|->
name|con_fun_0
argument_list|(
name|dataflow
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|result_changed
operator|=
name|dataflow
operator|->
name|problem
operator|->
name|trans_fun
argument_list|(
name|dataflow
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result_changed
operator|||
name|single_pass
condition|)
return|return;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|considered
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|dataflow
operator|->
name|pending
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|considered
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
name|df_hybrid_search_forward
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|dataflow
argument_list|,
name|single_pass
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|df_hybrid_search_backward
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|dataflow
modifier|*
name|dataflow
parameter_list|,
name|bool
name|single_pass
parameter_list|)
block|{
name|int
name|result_changed
decl_stmt|;
name|int
name|i
init|=
name|bb
operator|->
name|index
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|SET_BIT
argument_list|(
name|dataflow
operator|->
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|pending
argument_list|,
name|bb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|dataflow
operator|->
name|pending
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*  Calculate<conf_op> of predecessor_outs.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|considered
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|dataflow
operator|->
name|problem
operator|->
name|con_fun_n
argument_list|(
name|dataflow
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dataflow
operator|->
name|problem
operator|->
name|con_fun_0
condition|)
name|dataflow
operator|->
name|problem
operator|->
name|con_fun_0
argument_list|(
name|dataflow
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|result_changed
operator|=
name|dataflow
operator|->
name|problem
operator|->
name|trans_fun
argument_list|(
name|dataflow
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result_changed
operator|||
name|single_pass
condition|)
return|return;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|considered
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|dataflow
operator|->
name|pending
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|considered
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dataflow
operator|->
name|visited
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
name|df_hybrid_search_backward
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|dataflow
argument_list|,
name|single_pass
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function will perform iterative bitvector dataflow described    by DATAFLOW, producing the in and out sets.  Only the part of the    cfg induced by blocks in DATAFLOW->order is taken into account.     SINGLE_PASS is true if you just want to make one pass over the    blocks.  */
end_comment

begin_function
name|void
name|df_iterative_dataflow
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dataflow
parameter_list|,
name|bitmap
name|blocks_to_consider
parameter_list|,
name|bitmap
name|blocks_to_init
parameter_list|,
name|int
modifier|*
name|blocks_in_postorder
parameter_list|,
name|int
name|n_blocks
parameter_list|,
name|bool
name|single_pass
parameter_list|)
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sbitmap
name|visited
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
name|sbitmap
name|pending
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
name|sbitmap
name|considered
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|dataflow
operator|->
name|visited
operator|=
name|visited
expr_stmt|;
name|dataflow
operator|->
name|pending
operator|=
name|pending
expr_stmt|;
name|dataflow
operator|->
name|considered
operator|=
name|considered
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|considered
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dataflow
operator|->
name|problem
operator|->
name|dir
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_consider
argument_list|,
literal|0
argument_list|,
argument|idx
argument_list|,
argument|bi
argument_list|)
block|{
name|SET_BIT
argument_list|(
name|considered
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_blocks
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|blocks_in_postorder
index|[
name|i
index|]
expr_stmt|;
name|SET_BIT
argument_list|(
name|pending
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|dataflow
operator|->
name|problem
operator|->
name|init_fun
argument_list|(
name|dataflow
argument_list|,
name|blocks_to_init
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* For forward problems, you want to pass in reverse postorder          and for backward problems you want postorder.  This has been          shown to be as good as you can do by several people, the          first being Mathew Hecht in his phd dissertation.  	 The nodes are passed into this function in postorder.  */
if|if
condition|(
name|dataflow
operator|->
name|problem
operator|->
name|dir
operator|==
name|DF_FORWARD
condition|)
block|{
for|for
control|(
name|i
operator|=
name|n_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|=
name|blocks_in_postorder
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pending
argument_list|,
name|idx
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|idx
argument_list|)
condition|)
name|df_hybrid_search_forward
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|idx
argument_list|)
argument_list|,
name|dataflow
argument_list|,
name|single_pass
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_blocks
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|blocks_in_postorder
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pending
argument_list|,
name|idx
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|idx
argument_list|)
condition|)
name|df_hybrid_search_backward
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|idx
argument_list|)
argument_list|,
name|dataflow
argument_list|,
name|single_pass
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|pending
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|considered
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the entries not in BLOCKS from the LIST of length LEN, preserving    the order of the remaining entries.  Returns the length of the resulting    list.  */
end_comment

begin_function
specifier|static
name|unsigned
name|df_prune_to_subcfg
parameter_list|(
name|int
name|list
index|[]
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|bitmap
name|blocks
parameter_list|)
block|{
name|unsigned
name|act
decl_stmt|,
name|last
decl_stmt|;
for|for
control|(
name|act
operator|=
literal|0
operator|,
name|last
operator|=
literal|0
init|;
name|act
operator|<
name|len
condition|;
name|act
operator|++
control|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|blocks
argument_list|,
name|list
index|[
name|act
index|]
argument_list|)
condition|)
name|list
index|[
name|last
operator|++
index|]
operator|=
name|list
index|[
name|act
index|]
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Execute dataflow analysis on a single dataflow problem.      There are three sets of blocks passed in:      BLOCKS_TO_CONSIDER are the blocks whose solution can either be    examined or will be computed.  For calls from DF_ANALYZE, this is    the set of blocks that has been passed to DF_SET_BLOCKS.  For calls    from DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS, this is the set of    blocks in the fringe (the set of blocks passed in plus the set of    immed preds and succs of those blocks).     BLOCKS_TO_INIT are the blocks whose solution will be changed by    this iteration.  For calls from DF_ANALYZE, this is the set of    blocks that has been passed to DF_SET_BLOCKS.  For calls from    DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS, this is the set of blocks    passed in.     BLOCKS_TO_SCAN are the set of blocks that need to be rescanned.    For calls from DF_ANALYZE, this is the accumulated set of blocks    that has been passed to DF_RESCAN_BLOCKS since the last call to    DF_ANALYZE.  For calls from DF_ANALYZE_SIMPLE_CHANGE_SOME_BLOCKS,    this is the set of blocks passed in.                      blocks_to_consider    blocks_to_init    blocks_to_scan    full redo       all                   all               all    partial redo    all                   all               sub    small fixup     fringe                sub               sub */
end_comment

begin_function
name|void
name|df_analyze_problem
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_consider
parameter_list|,
name|bitmap
name|blocks_to_init
parameter_list|,
name|bitmap
name|blocks_to_scan
parameter_list|,
name|int
modifier|*
name|postorder
parameter_list|,
name|int
name|n_blocks
parameter_list|,
name|bool
name|single_pass
parameter_list|)
block|{
comment|/* (Re)Allocate the datastructures necessary to solve the problem.  */
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|alloc_fun
condition|)
name|dflow
operator|->
name|problem
operator|->
name|alloc_fun
argument_list|(
name|dflow
argument_list|,
name|blocks_to_scan
argument_list|,
name|blocks_to_init
argument_list|)
expr_stmt|;
comment|/* Set up the problem and compute the local information.  This      function is passed both the blocks_to_consider and the      blocks_to_scan because the RD and RU problems require the entire      function to be rescanned if they are going to be updated.  */
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|local_compute_fun
condition|)
name|dflow
operator|->
name|problem
operator|->
name|local_compute_fun
argument_list|(
name|dflow
argument_list|,
name|blocks_to_consider
argument_list|,
name|blocks_to_scan
argument_list|)
expr_stmt|;
comment|/* Solve the equations.  */
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|dataflow_fun
condition|)
name|dflow
operator|->
name|problem
operator|->
name|dataflow_fun
argument_list|(
name|dflow
argument_list|,
name|blocks_to_consider
argument_list|,
name|blocks_to_init
argument_list|,
name|postorder
argument_list|,
name|n_blocks
argument_list|,
name|single_pass
argument_list|)
expr_stmt|;
comment|/* Massage the solution.  */
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|finalize_fun
condition|)
name|dflow
operator|->
name|problem
operator|->
name|finalize_fun
argument_list|(
name|dflow
argument_list|,
name|blocks_to_consider
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze dataflow info for the basic blocks specified by the bitmap    BLOCKS, or for the whole CFG if BLOCKS is zero.  */
end_comment

begin_function
name|void
name|df_analyze
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|int
modifier|*
name|postorder
init|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
decl_stmt|;
name|bitmap
name|current_all_blocks
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|n_blocks
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|everything
decl_stmt|;
name|n_blocks
operator|=
name|post_order_compute
argument_list|(
name|postorder
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_blocks
operator|!=
name|n_basic_blocks
condition|)
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_blocks
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|current_all_blocks
argument_list|,
name|postorder
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* No one called df_rescan_blocks, so do it.  */
if|if
condition|(
operator|!
name|df
operator|->
name|blocks_to_scan
condition|)
name|df_rescan_blocks
argument_list|(
name|df
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure that we have pruned any unreachable blocks from these      sets.  */
name|bitmap_and_into
argument_list|(
name|df
operator|->
name|blocks_to_scan
argument_list|,
name|current_all_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|blocks_to_analyze
condition|)
block|{
name|everything
operator|=
name|false
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|df
operator|->
name|blocks_to_analyze
argument_list|,
name|current_all_blocks
argument_list|)
expr_stmt|;
name|n_blocks
operator|=
name|df_prune_to_subcfg
argument_list|(
name|postorder
argument_list|,
name|n_blocks
argument_list|,
name|df
operator|->
name|blocks_to_analyze
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|current_all_blocks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|everything
operator|=
name|true
expr_stmt|;
name|df
operator|->
name|blocks_to_analyze
operator|=
name|current_all_blocks
expr_stmt|;
name|current_all_blocks
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Skip over the DF_SCAN problem. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|df
operator|->
name|num_problems_defined
condition|;
name|i
operator|++
control|)
name|df_analyze_problem
argument_list|(
name|df
operator|->
name|problems_in_order
index|[
name|i
index|]
argument_list|,
name|df
operator|->
name|blocks_to_analyze
argument_list|,
name|df
operator|->
name|blocks_to_analyze
argument_list|,
name|df
operator|->
name|blocks_to_scan
argument_list|,
name|postorder
argument_list|,
name|n_blocks
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|everything
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|blocks_to_analyze
argument_list|)
expr_stmt|;
name|df
operator|->
name|blocks_to_analyze
operator|=
name|NULL
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|df
operator|->
name|blocks_to_scan
argument_list|)
expr_stmt|;
name|df
operator|->
name|blocks_to_scan
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|postorder
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    Functions to support limited incremental change. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Get basic block info.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|df_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|df_scan_bb_info
operator|*
operator|)
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|void
modifier|*
name|bb_info
parameter_list|)
block|{
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
operator|=
name|bb_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from the rtl_compact_blocks to reorganize the problems basic    block info.  */
end_comment

begin_function
name|void
name|df_compact_blocks
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|void
modifier|*
modifier|*
name|problem_temps
decl_stmt|;
name|int
name|size
init|=
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|problem_temps
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|df
operator|->
name|num_problems_defined
condition|;
name|p
operator|++
control|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_in_order
index|[
name|p
index|]
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem
operator|->
name|free_bb_fun
condition|)
block|{
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|problem_temps
argument_list|,
name|dflow
operator|->
name|block_info
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Copy the bb info from the problem tmps to the proper 	     place in the block_info vector.  Null out the copied 	     item.  */
name|i
operator|=
name|NUM_FIXED_BLOCKS
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|df_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|i
argument_list|,
name|problem_temps
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|problem_temps
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|memset
argument_list|(
name|dflow
operator|->
name|block_info
operator|+
name|i
argument_list|,
literal|0
argument_list|,
operator|(
name|last_basic_block
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free any block infos that were not copied (and NULLed). 	     These are from orphaned blocks.  */
for|for
control|(
name|i
operator|=
name|NUM_FIXED_BLOCKS
init|;
name|i
operator|<
name|last_basic_block
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|problem_temps
index|[
name|i
index|]
operator|&&
name|bb
condition|)
name|dflow
operator|->
name|problem
operator|->
name|free_bb_fun
argument_list|(
name|dflow
argument_list|,
name|bb
argument_list|,
name|problem_temps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|problem_temps
argument_list|)
expr_stmt|;
name|i
operator|=
name|NUM_FIXED_BLOCKS
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|SET_BASIC_BLOCK
argument_list|(
name|i
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|i
operator|==
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|last_basic_block
condition|;
name|i
operator|++
control|)
name|SET_BASIC_BLOCK
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shove NEW_BLOCK in at OLD_INDEX.  Called from if-cvt to hack a    block.  There is no excuse for people to do this kind of thing.  */
end_comment

begin_function
name|void
name|df_bb_replace
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|old_index
parameter_list|,
name|basic_block
name|new_block
parameter_list|)
block|{
name|int
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|df
operator|->
name|num_problems_defined
condition|;
name|p
operator|++
control|)
block|{
name|struct
name|dataflow
modifier|*
name|dflow
init|=
name|df
operator|->
name|problems_in_order
index|[
name|p
index|]
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|block_info
condition|)
block|{
name|void
modifier|*
name|temp
decl_stmt|;
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
comment|/* The old switcheroo.  */
name|temp
operator|=
name|df_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|old_index
argument_list|)
expr_stmt|;
name|df_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|old_index
argument_list|,
name|df_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|new_block
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|df_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|new_block
operator|->
name|index
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_BASIC_BLOCK
argument_list|(
name|old_index
argument_list|,
name|new_block
argument_list|)
expr_stmt|;
name|new_block
operator|->
name|index
operator|=
name|old_index
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------    PUBLIC INTERFACES TO QUERY INFORMATION. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Return last use of REGNO within BB.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_bb_regno_last_use_find
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
name|unsigned
name|int
name|uid
decl_stmt|;
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|use
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
operator|->
name|uses
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
if|if
condition|(
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
operator|==
name|regno
condition|)
return|return
name|use
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return first def of REGNO within BB.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_bb_regno_first_def_find
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|unsigned
name|int
name|uid
decl_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
operator|->
name|defs
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
operator|==
name|regno
condition|)
return|return
name|def
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return last def of REGNO within BB.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_bb_regno_last_def_find
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|unsigned
name|int
name|uid
decl_stmt|;
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
operator|->
name|defs
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
operator|==
name|regno
condition|)
return|return
name|def
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN defines REGNO.  */
end_comment

begin_function
name|bool
name|df_insn_regno_def_p
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
operator|->
name|defs
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
operator|==
name|regno
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Finds the reference corresponding to the definition of REG in INSN.    DF is the dataflow object.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_find_def
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
operator|->
name|defs
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|DF_REF_REAL_REG
argument_list|(
name|def
argument_list|)
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|def
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if REG is defined in INSN, zero otherwise.  */
end_comment

begin_function
name|bool
name|df_reg_defined
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
return|return
name|df_find_def
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|reg
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Finds the reference corresponding to the use of REG in INSN.    DF is the dataflow object.  */
end_comment

begin_function
name|struct
name|df_ref
modifier|*
name|df_find_use
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|use
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
operator|->
name|uses
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|DF_REF_REAL_REG
argument_list|(
name|use
argument_list|)
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|use
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if REG is referenced in INSN, zero otherwise.  */
end_comment

begin_function
name|bool
name|df_reg_used
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
return|return
name|df_find_use
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|reg
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    Debugging and printing functions. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Dump dataflow info.  */
end_comment

begin_function
name|void
name|df_dump
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|df
operator|||
operator|!
name|file
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n%s\n"
argument_list|,
name|current_function_name
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nDataflow summary:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"def_info->bitmap_size = %d, use_info->bitmap_size = %d\n"
argument_list|,
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
argument_list|,
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|num_problems_defined
condition|;
name|i
operator|++
control|)
name|df
operator|->
name|problems_in_order
index|[
name|i
index|]
operator|->
name|problem
operator|->
name|dump_fun
argument_list|(
name|df
operator|->
name|problems_in_order
index|[
name|i
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|df_refs_chain_dump
parameter_list|(
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|,
name|bool
name|follow_chain
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d(%d) "
argument_list|,
name|DF_REF_REG_DEF_P
argument_list|(
name|ref
argument_list|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|follow_chain
condition|)
name|df_chain_dump
argument_list|(
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next_ref
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump either a ref-def or reg-use chain.  */
end_comment

begin_function
name|void
name|df_regs_chain_dump
parameter_list|(
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d(%d) "
argument_list|,
name|DF_REF_REG_DEF_P
argument_list|(
name|ref
argument_list|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next_reg
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_mws_dump
parameter_list|(
name|struct
name|df_mw_hardreg
modifier|*
name|mws
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
while|while
condition|(
name|mws
condition|)
block|{
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d("
argument_list|,
operator|(
name|mws
operator|->
name|type
operator|==
name|DF_REF_REG_DEF
operator|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|regs
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|regs
operator|=
name|regs
operator|->
name|next
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|mws
operator|=
name|mws
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|df_insn_uid_debug
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|unsigned
name|int
name|uid
parameter_list|,
name|bool
name|follow_chain
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|bbi
decl_stmt|;
if|if
condition|(
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bbi
operator|=
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"insn %d bb %d luid %d"
argument_list|,
name|uid
argument_list|,
name|bbi
argument_list|,
name|DF_INSN_UID_LUID
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" defs "
argument_list|)
expr_stmt|;
name|df_refs_chain_dump
argument_list|(
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
name|follow_chain
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" uses "
argument_list|)
expr_stmt|;
name|df_refs_chain_dump
argument_list|(
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
name|follow_chain
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DF_INSN_UID_MWS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" mws "
argument_list|)
expr_stmt|;
name|df_mws_dump
argument_list|(
name|DF_INSN_UID_MWS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|df_insn_debug
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|bool
name|follow_chain
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|df_insn_uid_debug
argument_list|(
name|df
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|follow_chain
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|df_insn_debug_regno
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|int
name|bbi
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bbi
operator|=
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"insn %d bb %d luid %d defs "
argument_list|,
name|uid
argument_list|,
name|bbi
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|df_regs_chain_dump
argument_list|(
name|df
argument_list|,
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" uses "
argument_list|)
expr_stmt|;
name|df_regs_chain_dump
argument_list|(
name|df
argument_list|,
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|df_regno_debug
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"reg %d defs "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|df_regs_chain_dump
argument_list|(
name|df
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|reg_chain
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" uses "
argument_list|)
expr_stmt|;
name|df_regs_chain_dump
argument_list|(
name|df
argument_list|,
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|reg_chain
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|df_ref_debug
parameter_list|(
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d "
argument_list|,
name|DF_REF_REG_DEF_P
argument_list|(
name|ref
argument_list|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"reg %d bb %d insn %d flag %x chain "
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
condition|?
name|INSN_UID
argument_list|(
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|DF_REF_FLAGS
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for debugging from GDB.  */
end_comment

begin_function
name|void
name|debug_df_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|df_insn_debug
argument_list|(
name|ddf
argument_list|,
name|insn
argument_list|,
name|true
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_reg
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|df_regno_debug
argument_list|(
name|ddf
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_regno
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|df_regno_debug
argument_list|(
name|ddf
argument_list|,
name|regno
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_ref
parameter_list|(
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|)
block|{
name|df_ref_debug
argument_list|(
name|ref
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_defno
parameter_list|(
name|unsigned
name|int
name|defno
parameter_list|)
block|{
name|df_ref_debug
argument_list|(
name|DF_DEFS_GET
argument_list|(
name|ddf
argument_list|,
name|defno
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_useno
parameter_list|(
name|unsigned
name|int
name|defno
parameter_list|)
block|{
name|df_ref_debug
argument_list|(
name|DF_USES_GET
argument_list|(
name|ddf
argument_list|,
name|defno
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_chain
parameter_list|(
name|struct
name|df_link
modifier|*
name|link
parameter_list|)
block|{
name|df_chain_dump
argument_list|(
name|link
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

