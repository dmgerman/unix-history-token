begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RunTime Type Identification    Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,    2005, 2006    Free Software Foundation, Inc.    Mostly written by Jason Merrill (jason@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_comment
comment|/* C++ returns type information to the user in struct type_info    objects. We also use type information to implement dynamic_cast and    exception handlers. Type information for a particular type is    indicated with an ABI defined structure derived from type_info.    This would all be very straight forward, but for the fact that the    runtime library provides the definitions of the type_info structure    and the ABI defined derived classes. We cannot build declarations    of them directly in the compiler, but we need to layout objects of    their type.  Somewhere we have to lie.     We define layout compatible POD-structs with compiler-defined names    and generate the appropriate initializations for them (complete    with explicit mention of their vtable). When we have to provide a    type_info to the user we reinterpret_cast the internal compiler    type to type_info.  A well formed program can only explicitly refer    to the type_infos of complete types (& cv void).  However, we chain    pointer type_infos to the pointed-to-type, and that can be    incomplete.  We only need the addresses of such incomplete    type_info objects for static initialization.     The type information VAR_DECL of a type is held on the    IDENTIFIER_GLOBAL_VALUE of the type's mangled name. That VAR_DECL    will be the internal type.  It will usually have the correct    internal type reflecting the kind of type it represents (pointer,    array, function, class, inherited class, etc).  When the type it    represents is incomplete, it will have the internal type    corresponding to type_info.  That will only happen at the end of    translation, when we are emitting the type info objects.  */
end_comment

begin_comment
comment|/* Auxiliary data we hold for each type_info derived object we need.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|tinfo_s
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|type
block|;
comment|/* The RECORD_TYPE for this type_info object */
name|tree
name|vtable
block|;
comment|/* The VAR_DECL of the vtable.  Only filled at end of 		  translation.  */
name|tree
name|name
block|;
comment|/* IDENTIFIER_NODE for the ABI specified name of 		 the type_info derived type.  */
block|}
end_typedef

begin_expr_stmt
name|tinfo_s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_O
argument_list|(
name|tinfo_s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_O
argument_list|(
name|tinfo_s
argument_list|,
name|gc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
enum|enum
name|tinfo_kind
block|{
name|TK_TYPE_INFO_TYPE
block|,
comment|/* std::type_info */
name|TK_BASE_TYPE
block|,
comment|/* abi::__base_class_type_info */
name|TK_BUILTIN_TYPE
block|,
comment|/* abi::__fundamental_type_info */
name|TK_ARRAY_TYPE
block|,
comment|/* abi::__array_type_info */
name|TK_FUNCTION_TYPE
block|,
comment|/* abi::__function_type_info */
name|TK_ENUMERAL_TYPE
block|,
comment|/* abi::__enum_type_info */
name|TK_POINTER_TYPE
block|,
comment|/* abi::__pointer_type_info */
name|TK_POINTER_MEMBER_TYPE
block|,
comment|/* abi::__pointer_to_member_type_info */
name|TK_CLASS_TYPE
block|,
comment|/* abi::__class_type_info */
name|TK_SI_CLASS_TYPE
block|,
comment|/* abi::__si_class_type_info */
name|TK_FIXED
comment|/* end of fixed descriptors. */
comment|/* ...		   abi::__vmi_type_info<I> */
block|}
name|tinfo_kind
typedef|;
end_typedef

begin_comment
comment|/* A vector of all tinfo decls that haven't yet been emitted.  */
end_comment

begin_expr_stmt
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|unemitted_tinfo_decls
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A vector of all type_info derived types we need.  The first few are    fixed and created early. The remainder are for multiple inheritance    and are generated as needed. */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tinfo_s
argument_list|,
name|gc
argument_list|)
operator|*
name|tinfo_descs
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|tree
name|build_headof
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ifnonnull
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tinfo_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_dynamic_cast_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|throw_bad_cast
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|throw_bad_typeid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_tinfo_decl_dynamic
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_tinfo_ptr
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|typeid_ok_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qualifier_flags
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|target_incomplete_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tinfo_base_init
parameter_list|(
name|tinfo_s
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|generic_initializer
parameter_list|(
name|tinfo_s
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ptr_initializer
parameter_list|(
name|tinfo_s
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ptm_initializer
parameter_list|(
name|tinfo_s
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|class_initializer
parameter_list|(
name|tinfo_s
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_pseudo_type_info
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_pseudo_ti_init
parameter_list|(
name|tree
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|get_pseudo_ti_index
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_tinfo_types
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|typeinfo_in_lib_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|doing_runtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Declare language defined type_info type and a pointer to const    type_info.  This is incomplete here, and will be completed when    the user #includes<typeinfo>.  There are language defined    restrictions on what can be done until that is included.  Create    the internal versions of the ABI types.  */
end_comment

begin_function
name|void
name|init_rtti_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|type_info_type
decl_stmt|;
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|type_info_type
operator|=
name|xref_tag
argument_list|(
name|class_type
argument_list|,
name|get_identifier
argument_list|(
literal|"type_info"
argument_list|)
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
name|const_type_info_type_node
operator|=
name|build_qualified_type
argument_list|(
name|type_info_type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|type_info_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|const_type_info_type_node
argument_list|)
expr_stmt|;
name|unemitted_tinfo_decls
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|124
argument_list|)
expr_stmt|;
name|create_tinfo_types
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the expression EXP of type `class *', return the head of the    object pointed to by EXP with type cv void*, if the class has any    virtual functions (TYPE_POLYMORPHIC_P), else just return the    expression.  */
end_comment

begin_function
specifier|static
name|tree
name|build_headof
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|index
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|exp
return|;
comment|/* We use this a couple of times below, protect it.  */
name|exp
operator|=
name|save_expr
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* The offset-to-top field is at index -2 from the vptr.  */
name|index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|2
operator|*
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|build_vtbl_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|exp
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_qualified_type
argument_list|(
name|ptr_type_node
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|convert_to_integer
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a bad_cast node for the program to throw...     See libstdc++/exception.cc for __throw_bad_cast */
end_comment

begin_function
specifier|static
name|tree
name|throw_bad_cast
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
literal|"__cxa_bad_cast"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|get_global_value_if_present
argument_list|(
name|fn
argument_list|,
operator|&
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|push_throw_library_fn
argument_list|(
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_cxx_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an expression for "__cxa_bad_typeid()".  The expression    returned is an lvalue of type "const std::type_info".  */
end_comment

begin_function
specifier|static
name|tree
name|throw_bad_typeid
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
literal|"__cxa_bad_typeid"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|get_global_value_if_present
argument_list|(
name|fn
argument_list|,
operator|&
name|fn
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_reference_type
argument_list|(
name|const_type_info_type_node
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_function_type
argument_list|(
name|t
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|fn
operator|=
name|push_throw_library_fn
argument_list|(
name|fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|build_cxx_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an lvalue expression whose type is "const std::type_info"    and whose value indicates the type of the expression EXP.  If EXP    is a reference to a polymorphic class, return the dynamic type;    otherwise return the static type of the expression.  */
end_comment

begin_function
specifier|static
name|tree
name|get_tinfo_decl_dynamic
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* peel back references, so they match.  */
name|type
operator|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|error_mark_node
return|;
comment|/* If exp is a reference to polymorphic type, get the real type_info.  */
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* build reference to type_info from vtable.  */
name|tree
name|index
decl_stmt|;
comment|/* The RTTI information is at index -1.  */
name|index
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
literal|1
operator|*
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_vtbl_ref
argument_list|(
name|exp
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|type_info_ptr_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Otherwise return the type_info for the static type of the expr.  */
name|t
operator|=
name|get_tinfo_ptr
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|typeid_ok_p
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_rtti
condition|)
block|{
name|error
argument_list|(
literal|"cannot use typeid with -fno-rtti"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|const_type_info_type_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"must #include<typeinfo> before using typeid"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return an expression for "typeid(EXP)".  The expression returned is    an lvalue of type "const std::type_info".  */
end_comment

begin_function
name|tree
name|build_typeid
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|cond
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|nonnull
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
operator|||
operator|!
name|typeid_ok_p
argument_list|()
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|TYPEID_EXPR
argument_list|,
name|const_type_info_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|exp
argument_list|,
operator|&
name|nonnull
argument_list|)
operator|&&
operator|!
name|nonnull
condition|)
block|{
name|exp
operator|=
name|stabilize_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|cond
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|get_tinfo_decl_dynamic
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|cond
condition|)
block|{
name|tree
name|bad
init|=
name|throw_bad_typeid
argument_list|()
decl_stmt|;
name|exp
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cond
argument_list|,
name|exp
argument_list|,
name|bad
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Generate the NTBS name of a type.  */
end_comment

begin_function
specifier|static
name|tree
name|tinfo_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|name_string
decl_stmt|;
name|name
operator|=
name|mangle_type_string
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name_string
operator|=
name|fix_string_type
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name_string
return|;
block|}
end_function

begin_comment
comment|/* Return a VAR_DECL for the internal ABI defined type_info object for    TYPE. You must arrange that the decl is mark_used, if actually use    it --- decls in vtables are only used if the vtable is output.  */
end_comment

begin_function
name|tree
name|get_tinfo_decl
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
comment|/*fn=*/
name|NULL_TREE
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot create type information for type %qT because "
literal|"it involves types of variable size"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a class type, the variable is cached in the type node      itself.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|d
operator|=
name|CLASSTYPE_TYPEINFO_VAR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
return|return
name|d
return|;
block|}
name|name
operator|=
name|mangle_typeinfo_for_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|d
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|int
name|ix
init|=
name|get_pseudo_ti_index
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tinfo_s
modifier|*
name|ti
init|=
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|d
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|ti
operator|->
name|type
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Remember the type it is for.  */
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_TINFO_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark the variable as undefined -- but remember that we can 	 define it later if we need to do so.  */
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_TYPEINFO_VAR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|d
expr_stmt|;
name|set_linkage_according_to_type
argument_list|(
name|type
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|pushdecl_top_level_and_finish
argument_list|(
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Add decl to the global array of tinfo decls.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|unemitted_tinfo_decls
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a type_info object describing TYPE, suitably    cast to the language defined type.  */
end_comment

begin_function
specifier|static
name|tree
name|get_tinfo_ptr
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
init|=
name|get_tinfo_decl
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|build_nop
argument_list|(
name|type_info_ptr_type
argument_list|,
name|build_address
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the type_info object for TYPE.  */
end_comment

begin_function
name|tree
name|get_typeid
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|typeid_ok_p
argument_list|()
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|TYPEID_EXPR
argument_list|,
name|const_type_info_type_node
argument_list|,
name|type
argument_list|)
return|;
comment|/* If the type of the type-id is a reference type, the result of the      typeid expression refers to a type_info object representing the      referenced type.  */
name|type
operator|=
name|non_reference
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The top-level cv-qualifiers of the lvalue expression or the type-id      that is the operand of typeid are always ignored.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_indirect_ref
argument_list|(
name|get_tinfo_ptr
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether TEST is null before returning RESULT.  If TEST is used in    RESULT, it must have previously had a save_expr applied to it.  */
end_comment

begin_function
specifier|static
name|tree
name|ifnonnull
parameter_list|(
name|tree
name|test
parameter_list|,
name|tree
name|result
parameter_list|)
block|{
return|return
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|test
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|test
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working    paper.  */
end_comment

begin_function
specifier|static
name|tree
name|build_dynamic_cast_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|tc
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|exprtype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|dcast_fn
decl_stmt|;
name|tree
name|old_expr
init|=
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
init|=
name|NULL
decl_stmt|;
comment|/* Save casted types in the function's used types hash table.  */
name|used_types_insert
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* T shall be a pointer or reference to a complete class type, or      `pointer to cv void''.  */
switch|switch
condition|(
name|tc
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"target is not pointer or reference to class"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"target is not pointer or reference to complete type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
default|default:
name|errstr
operator|=
literal|"target is not pointer or reference"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* If T is a pointer type, v shall be an rvalue of a pointer to 	 complete class type, and the result is an rvalue of type T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|errstr
operator|=
literal|"source is not a pointer"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is not a pointer to class"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is a pointer to incomplete type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
else|else
block|{
name|exprtype
operator|=
name|build_reference_type
argument_list|(
name|exprtype
argument_list|)
expr_stmt|;
comment|/* T is a reference type, v shall be an lvalue of a complete class 	 type, and the result is an lvalue of the type referred to by T.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is not of class type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"source is of incomplete class type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Apply trivial conversion T -> T& for dereferenced ptrs.  */
name|expr
operator|=
name|convert_to_reference
argument_list|(
name|exprtype
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* The dynamic_cast operator shall not cast away constness.  */
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|errstr
operator|=
literal|"conversion casts away constness"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* If *type is an unambiguous accessible base class of *exprtype,      convert statically.  */
block|{
name|tree
name|binfo
decl_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|expr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|expr
operator|=
name|rvalue
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
comment|/* Otherwise *exprtype must be a polymorphic class (have a vtbl).  */
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|expr1
decl_stmt|;
comment|/* if TYPE is `void *', return pointer to complete object.  */
if|if
condition|(
name|tc
operator|==
name|POINTER_TYPE
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* Since expr is used twice below, save it.  */
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr1
operator|=
name|build_headof
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr1
argument_list|)
operator|!=
name|type
condition|)
name|expr1
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr1
argument_list|)
expr_stmt|;
return|return
name|ifnonnull
argument_list|(
name|expr
argument_list|,
name|expr1
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|retval
decl_stmt|;
name|tree
name|result
decl_stmt|,
name|td2
decl_stmt|,
name|td3
decl_stmt|,
name|elems
decl_stmt|;
name|tree
name|static_type
decl_stmt|,
name|target_type
decl_stmt|,
name|boff
decl_stmt|;
comment|/* If we got here, we can't convert statically.  Therefore, 	     dynamic_cast<D&>(b) (b an object) cannot succeed.  */
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_expr
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_expr
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|expr
init|=
name|throw_bad_cast
argument_list|()
decl_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"dynamic_cast of %q#D to %q#T can never succeed"
argument_list|,
name|old_expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Bash it to the expected type.  */
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
comment|/* Ditto for dynamic_cast<D*>(&b).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"dynamic_cast of %q#D to %q#T can never succeed"
argument_list|,
name|op
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
comment|/* Use of dynamic_cast when -fno-rtti is prohibited.  */
if|if
condition|(
operator|!
name|flag_rtti
condition|)
block|{
name|error
argument_list|(
literal|"%<dynamic_cast%> not permitted with -fno-rtti"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|target_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|static_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exprtype
argument_list|)
argument_list|)
expr_stmt|;
name|td2
operator|=
name|get_tinfo_decl
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|td2
argument_list|)
expr_stmt|;
name|td2
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|td2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|td3
operator|=
name|get_tinfo_decl
argument_list|(
name|static_type
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|td3
argument_list|)
expr_stmt|;
name|td3
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|td3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine how T and V are related.  */
name|boff
operator|=
name|dcast_base_hint
argument_list|(
name|static_type
argument_list|,
name|target_type
argument_list|)
expr_stmt|;
comment|/* Since expr is used twice below, save it.  */
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr1
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
name|expr1
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr1
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td3
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|td2
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|boff
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dcast_fn
operator|=
name|dynamic_cast_node
expr_stmt|;
if|if
condition|(
operator|!
name|dcast_fn
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|tinfo_ptr
decl_stmt|;
name|tree
name|ns
init|=
name|abi_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|tinfo_ptr
operator|=
name|xref_tag
argument_list|(
name|class_type
argument_list|,
name|get_identifier
argument_list|(
literal|"__class_type_info"
argument_list|)
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|tinfo_ptr
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|tinfo_ptr
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"__dynamic_cast"
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dcast_fn
operator|=
name|build_library_fn_ptr
argument_list|(
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_IS_PURE
argument_list|(
name|dcast_fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|dynamic_cast_node
operator|=
name|dcast_fn
expr_stmt|;
block|}
name|result
operator|=
name|build_cxx_call
argument_list|(
name|dcast_fn
argument_list|,
name|elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|bad
init|=
name|throw_bad_cast
argument_list|()
decl_stmt|;
name|tree
name|neq
decl_stmt|;
name|result
operator|=
name|save_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|neq
operator|=
name|c_common_truthvalue_conversion
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|neq
argument_list|,
name|result
argument_list|,
name|bad
argument_list|)
return|;
block|}
comment|/* Now back to the type we want from a void*.  */
name|result
operator|=
name|cp_convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|ifnonnull
argument_list|(
name|expr
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
else|else
name|errstr
operator|=
literal|"source type is not polymorphic"
expr_stmt|;
name|fail
label|:
name|error
argument_list|(
literal|"cannot dynamic_cast %qE (of type %q#T) to type %q#T (%s)"
argument_list|,
name|expr
argument_list|,
name|exprtype
argument_list|,
name|type
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_dynamic_cast
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|expr
operator|=
name|build_min
argument_list|(
name|DYNAMIC_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|expr
return|;
block|}
return|return
name|convert_from_reference
argument_list|(
name|build_dynamic_cast_1
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the runtime bit mask encoding the qualifiers of TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|qualifier_flags
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|quals
init|=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_CONST
condition|)
name|flags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|flags
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
name|flags
operator||=
literal|4
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Return true, if the pointer chain TYPE ends at an incomplete type, or    contains a pointer to member of an incomplete class.  */
end_comment

begin_function
specifier|static
name|bool
name|target_incomplete_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|type
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
return|return
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if TYPE involves an incomplete class type; in that    case, typeinfo variables for TYPE should be emitted with internal    linkage.  */
end_comment

begin_function
specifier|static
name|bool
name|involves_incomplete_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
return|return
name|target_incomplete_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
name|ptrmem
label|:
return|return
operator|(
name|target_incomplete_p
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|ptrmem
goto|;
comment|/* Fall through.  */
case|case
name|UNION_TYPE
case|:
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
default|default:
comment|/* All other types do not involve incomplete class types.  */
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a CONSTRUCTOR for the common part of the type_info objects. This    is the vtable pointer and NTBS name.  The NTBS name is emitted as a    comdat const char array, so it becomes a unique key for the type. Generate    and emit that VAR_DECL here.  (We can't always emit the type_info itself    as comdat, because of pointers to incomplete.) */
end_comment

begin_function
specifier|static
name|tree
name|tinfo_base_init
parameter_list|(
name|tinfo_s
modifier|*
name|ti
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name_decl
decl_stmt|;
name|tree
name|vtable_ptr
decl_stmt|;
block|{
name|tree
name|name_name
decl_stmt|;
comment|/* Generate the NTBS array variable.  */
name|tree
name|name_type
init|=
name|build_cplus_array_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|name_string
init|=
name|tinfo_name
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|/* Determine the name of the variable -- and remember with which        type it is associated.  */
name|name_name
operator|=
name|mangle_typeinfo_string_for_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|name_name
argument_list|)
operator|=
name|target
expr_stmt|;
name|name_decl
operator|=
name|build_lang_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name_name
argument_list|,
name|name_type
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|name_decl
argument_list|,
name|name_name
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TINFO_P
argument_list|(
name|name_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_linkage_according_to_type
argument_list|(
name|target
argument_list|,
name|name_decl
argument_list|)
expr_stmt|;
name|import_export_decl
argument_list|(
name|name_decl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|name_decl
argument_list|)
operator|=
name|name_string
expr_stmt|;
name|mark_used
argument_list|(
name|name_decl
argument_list|)
expr_stmt|;
name|pushdecl_top_level_and_finish
argument_list|(
name|name_decl
argument_list|,
name|name_string
argument_list|)
expr_stmt|;
block|}
name|vtable_ptr
operator|=
name|ti
operator|->
name|vtable
expr_stmt|;
if|if
condition|(
operator|!
name|vtable_ptr
condition|)
block|{
name|tree
name|real_type
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
name|real_type
operator|=
name|xref_tag
argument_list|(
name|class_type
argument_list|,
name|ti
operator|->
name|name
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|real_type
argument_list|)
condition|)
block|{
comment|/* We never saw a definition of this type, so we need to 	     tell the compiler that this is an exported class, as 	     indeed all of the __*_type_info classes are.  */
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|real_type
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|real_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|vtable_ptr
operator|=
name|get_vtable_decl
argument_list|(
name|real_type
argument_list|,
comment|/*complete=*/
literal|1
argument_list|)
expr_stmt|;
name|vtable_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtable_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need to point into the middle of the vtable.  */
name|vtable_ptr
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtable_ptr
argument_list|)
argument_list|,
name|vtable_ptr
argument_list|,
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_int
argument_list|(
literal|2
operator|*
name|TARGET_VTABLE_DATA_ENTRY_DISTANCE
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|vtable
operator|=
name|vtable_ptr
expr_stmt|;
block|}
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vtable_ptr
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decay_conversion
argument_list|(
name|name_decl
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of TYPE. TI provides the    information about the particular type_info derivation, which adds no    additional fields to the type_info base.  */
end_comment

begin_function
specifier|static
name|tree
name|generic_initializer
parameter_list|(
name|tinfo_s
modifier|*
name|ti
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|ti
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of pointer TYPE.    TI provides information about the particular type_info derivation,    which adds target type and qualifier flags members to the type_info base.  */
end_comment

begin_function
specifier|static
name|tree
name|ptr_initializer
parameter_list|(
name|tinfo_s
modifier|*
name|ti
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|ti
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|tree
name|to
init|=
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|qualifier_flags
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|bool
name|incomplete
init|=
name|target_incomplete_p
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|incomplete
condition|)
name|flags
operator||=
literal|8
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_tinfo_ptr
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of pointer to member data TYPE.    TI provides information about the particular type_info derivation,    which adds class, target type and qualifier flags members to the type_info    base.  */
end_comment

begin_function
specifier|static
name|tree
name|ptm_initializer
parameter_list|(
name|tinfo_s
modifier|*
name|ti
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|ti
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|tree
name|to
init|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|tree
name|klass
init|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|qualifier_flags
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|bool
name|incomplete
init|=
name|target_incomplete_p
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|incomplete
condition|)
name|flags
operator||=
literal|0x8
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|klass
argument_list|)
condition|)
name|flags
operator||=
literal|0x10
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_tinfo_ptr
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_tinfo_ptr
argument_list|(
name|klass
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Return the CONSTRUCTOR expr for a type_info of class TYPE.    TI provides information about the particular __class_type_info derivation,    which adds hint flags and TRAIL initializers to the type_info base.  */
end_comment

begin_function
specifier|static
name|tree
name|class_initializer
parameter_list|(
name|tinfo_s
modifier|*
name|ti
parameter_list|,
name|tree
name|target
parameter_list|,
name|tree
name|trail
parameter_list|)
block|{
name|tree
name|init
init|=
name|tinfo_base_init
argument_list|(
name|ti
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|=
name|trail
expr_stmt|;
name|init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the typeinfo for type should be placed in    the runtime library.  */
end_comment

begin_function
specifier|static
name|bool
name|typeinfo_in_lib_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* The typeinfo objects for `T*' and `const T*' are in the runtime      library for simple types T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_QUAL_CONST
operator|||
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_UNQUALIFIED
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the initializer for the type info describing TYPE.  TK_INDEX is    the index of the descriptor in the tinfo_desc vector. */
end_comment

begin_function
specifier|static
name|tree
name|get_pseudo_ti_init
parameter_list|(
name|tree
name|type
parameter_list|,
name|unsigned
name|tk_index
parameter_list|)
block|{
name|tinfo_s
modifier|*
name|ti
init|=
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|tk_index
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|at_eof
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tk_index
condition|)
block|{
case|case
name|TK_POINTER_MEMBER_TYPE
case|:
return|return
name|ptm_initializer
argument_list|(
name|ti
argument_list|,
name|type
argument_list|)
return|;
case|case
name|TK_POINTER_TYPE
case|:
return|return
name|ptr_initializer
argument_list|(
name|ti
argument_list|,
name|type
argument_list|)
return|;
case|case
name|TK_BUILTIN_TYPE
case|:
case|case
name|TK_ENUMERAL_TYPE
case|:
case|case
name|TK_FUNCTION_TYPE
case|:
case|case
name|TK_ARRAY_TYPE
case|:
return|return
name|generic_initializer
argument_list|(
name|ti
argument_list|,
name|type
argument_list|)
return|;
case|case
name|TK_CLASS_TYPE
case|:
return|return
name|class_initializer
argument_list|(
name|ti
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|TK_SI_CLASS_TYPE
case|:
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASE_BINFO
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|tinfo
init|=
name|get_tinfo_ptr
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_inits
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */
name|ti
operator|=
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|tk_index
argument_list|)
expr_stmt|;
return|return
name|class_initializer
argument_list|(
name|ti
argument_list|,
name|type
argument_list|,
name|base_inits
argument_list|)
return|;
block|}
default|default:
block|{
name|int
name|hint
init|=
operator|(
operator|(
name|CLASSTYPE_REPEATED_BASE_P
argument_list|(
name|type
argument_list|)
operator|<<
literal|0
operator|)
operator||
operator|(
name|CLASSTYPE_DIAMOND_SHAPED_P
argument_list|(
name|type
argument_list|)
operator|<<
literal|1
operator|)
operator|)
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|nbases
init|=
name|BINFO_N_BASE_BINFOS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|base_accesses
operator|=
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|tree
name|base_inits
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|gcc_assert
argument_list|(
name|tk_index
operator|>=
name|TK_FIXED
argument_list|)
expr_stmt|;
comment|/* Generate the base information initializer.  */
for|for
control|(
name|ix
operator|=
name|nbases
init|;
name|ix
operator|--
condition|;
control|)
block|{
name|tree
name|base_binfo
init|=
name|BINFO_BASE_BINFO
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|tree
name|base_init
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|tree
name|tinfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
if|if
condition|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|base_accesses
argument_list|,
name|ix
argument_list|)
operator|==
name|access_public_node
condition|)
name|flags
operator||=
literal|2
expr_stmt|;
name|tinfo
operator|=
name|get_tinfo_ptr
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
comment|/* We store the vtable offset at which the virtual 		   base offset can be found.  */
name|offset
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|offset
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|flags
operator||=
literal|1
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* Combine offset and flags into one field.  */
name|offset
operator|=
name|cp_build_binary_op
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|offset
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cp_build_binary_op
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|offset
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|base_init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|offset
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
name|base_init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tinfo
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
name|base_init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_init
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
block|}
name|base_inits
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_inits
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Prepend the number of bases.  */
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|nbases
argument_list|)
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
comment|/* Prepend the hint flags.  */
name|base_inits
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|hint
argument_list|)
argument_list|,
name|base_inits
argument_list|)
expr_stmt|;
comment|/* get_tinfo_ptr might have reallocated the tinfo_descs vector.  */
name|ti
operator|=
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|tk_index
argument_list|)
expr_stmt|;
return|return
name|class_initializer
argument_list|(
name|ti
argument_list|,
name|type
argument_list|,
name|base_inits
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the RECORD_TYPE containing the data layout of a type_info    derivative as used by the runtime. This layout must be consistent with    that defined in the runtime support. Also generate the VAR_DECL for the    type's vtable. We explicitly manage the vtable member, and name it for    real type as used in the runtime. The RECORD type has a different name,    to avoid collisions.  Return a TREE_LIST who's TINFO_PSEUDO_TYPE    is the generated type and TINFO_VTABLE_NAME is the name of the    vtable.  We have to delay generating the VAR_DECL of the vtable    until the end of the translation, when we'll have seen the library    definition, if there was one.     REAL_NAME is the runtime's name of the type. Trailing arguments are    additional FIELD_DECL's for the structure. The final argument must be    NULL.  */
end_comment

begin_function
specifier|static
name|void
name|create_pseudo_type_info
parameter_list|(
name|int
name|tk
parameter_list|,
specifier|const
name|char
modifier|*
name|real_name
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tinfo_s
modifier|*
name|ti
decl_stmt|;
name|tree
name|pseudo_type
decl_stmt|;
name|char
modifier|*
name|pseudo_name
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|tree
name|field_decl
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
comment|/* Generate the pseudo type name.  */
name|pseudo_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|real_name
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pseudo_name
argument_list|,
name|real_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pseudo_name
argument_list|,
literal|"_pseudo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|>=
name|TK_FIXED
condition|)
name|sprintf
argument_list|(
name|pseudo_name
operator|+
name|strlen
argument_list|(
name|pseudo_name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|tk
operator|-
name|TK_FIXED
argument_list|)
expr_stmt|;
comment|/* First field is the pseudo type_info base class.  */
name|fields
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|TK_TYPE_INFO_TYPE
argument_list|)
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Now add the derived fields.  */
while|while
condition|(
operator|(
name|field_decl
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|)
operator|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field_decl
expr_stmt|;
block|}
comment|/* Create the pseudo type.  */
name|pseudo_type
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|finish_builtin_struct
argument_list|(
name|pseudo_type
argument_list|,
name|pseudo_name
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CLASSTYPE_AS_BASE
argument_list|(
name|pseudo_type
argument_list|)
operator|=
name|pseudo_type
expr_stmt|;
name|ti
operator|=
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|tk
argument_list|)
expr_stmt|;
name|ti
operator|->
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|pseudo_type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|ti
operator|->
name|name
operator|=
name|get_identifier
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
name|ti
operator|->
name|vtable
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Pretend this is public so determine_visibility doesn't give vtables      internal linkage.  */
name|TREE_PUBLIC
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|ti
operator|->
name|type
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the index of a pseudo type info type node used to describe    TYPE.  TYPE must be a complete type (or cv void), except at the end    of the translation unit.  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_pseudo_ti_index
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|OFFSET_TYPE
case|:
name|ix
operator|=
name|TK_POINTER_MEMBER_TYPE
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|ix
operator|=
name|TK_POINTER_TYPE
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|ix
operator|=
name|TK_ENUMERAL_TYPE
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|ix
operator|=
name|TK_FUNCTION_TYPE
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|ix
operator|=
name|TK_ARRAY_TYPE
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|ix
operator|=
name|TK_POINTER_MEMBER_TYPE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|at_eof
condition|)
name|cxx_incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ix
operator|=
name|TK_CLASS_TYPE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|BINFO_N_BASE_BINFOS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|ix
operator|=
name|TK_CLASS_TYPE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|base_accesses
operator|=
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|tree
name|base_binfo
init|=
name|BINFO_BASE_BINFO
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_bases
init|=
name|BINFO_N_BASE_BINFOS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|num_bases
operator|==
literal|1
operator|&&
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|base_accesses
argument_list|,
literal|0
argument_list|)
operator|==
name|access_public_node
operator|&&
operator|!
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
comment|/* single non-virtual public.  */
name|ix
operator|=
name|TK_SI_CLASS_TYPE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tinfo_s
modifier|*
name|ti
decl_stmt|;
name|tree
name|array_domain
decl_stmt|,
name|base_array
decl_stmt|;
name|ix
operator|=
name|TK_FIXED
operator|+
name|num_bases
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|)
operator|<=
name|ix
condition|)
block|{
comment|/* too short, extend.  */
name|unsigned
name|len
init|=
name|VEC_length
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|)
decl_stmt|;
name|VEC_safe_grow
argument_list|(
name|tinfo_s
argument_list|,
name|gc
argument_list|,
name|tinfo_descs
argument_list|,
name|ix
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_iterate
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|len
operator|++
argument_list|,
name|ti
argument_list|)
condition|)
name|ti
operator|->
name|type
operator|=
name|ti
operator|->
name|vtable
operator|=
name|ti
operator|->
name|name
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|ix
argument_list|)
operator|->
name|type
condition|)
comment|/* already created.  */
break|break;
comment|/* Create the array of __base_class_type_info entries. 		 G++ 3.2 allocated an array that had one too many 		 entries, and then filled that extra entries with 		 zeros.  */
if|if
condition|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
name|array_domain
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|num_bases
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|array_domain
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|num_bases
argument_list|)
argument_list|)
expr_stmt|;
name|base_array
operator|=
name|build_array_type
argument_list|(
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|TK_BASE_TYPE
argument_list|)
operator|->
name|type
argument_list|,
name|array_domain
argument_list|)
expr_stmt|;
name|push_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
name|create_pseudo_type_info
argument_list|(
name|ix
argument_list|,
literal|"__vmi_class_type_info"
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|base_array
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
default|default:
name|ix
operator|=
name|TK_BUILTIN_TYPE
expr_stmt|;
break|break;
block|}
return|return
name|ix
return|;
block|}
end_function

begin_comment
comment|/* Make sure the required builtin types exist for generating the type_info    variable definitions.  */
end_comment

begin_function
specifier|static
name|void
name|create_tinfo_types
parameter_list|(
name|void
parameter_list|)
block|{
name|tinfo_s
modifier|*
name|ti
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|tinfo_descs
argument_list|)
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|tinfo_s
argument_list|,
name|gc
argument_list|,
name|tinfo_descs
argument_list|,
name|TK_FIXED
argument_list|)
expr_stmt|;
name|push_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
comment|/* Create the internal type_info structure. This is used as a base for      the other structures.  */
block|{
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|)
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|ti
operator|=
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|TK_TYPE_INFO_TYPE
argument_list|)
expr_stmt|;
name|ti
operator|->
name|type
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|ti
operator|->
name|vtable
operator|=
name|NULL_TREE
expr_stmt|;
name|ti
operator|->
name|name
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_builtin_struct
argument_list|(
name|ti
operator|->
name|type
argument_list|,
literal|"__type_info_pseudo"
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ti
operator|->
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Fundamental type_info */
name|create_pseudo_type_info
argument_list|(
name|TK_BUILTIN_TYPE
argument_list|,
literal|"__fundamental_type_info"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Array, function and enum type_info. No additional fields.  */
name|create_pseudo_type_info
argument_list|(
name|TK_ARRAY_TYPE
argument_list|,
literal|"__array_type_info"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|create_pseudo_type_info
argument_list|(
name|TK_FUNCTION_TYPE
argument_list|,
literal|"__function_type_info"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|create_pseudo_type_info
argument_list|(
name|TK_ENUMERAL_TYPE
argument_list|,
literal|"__enum_type_info"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Class type_info.  No additional fields.  */
name|create_pseudo_type_info
argument_list|(
name|TK_CLASS_TYPE
argument_list|,
literal|"__class_type_info"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Single public non-virtual base class. Add pointer to base class.      This is really a descendant of __class_type_info.  */
name|create_pseudo_type_info
argument_list|(
name|TK_SI_CLASS_TYPE
argument_list|,
literal|"__si_class_type_info"
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type_info_ptr_type
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Base class internal helper. Pointer to base type, offset to base,      flags.  */
block|{
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type_info_ptr_type
argument_list|)
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_types
index|[
name|itk_long
index|]
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|field
expr_stmt|;
name|ti
operator|=
name|VEC_index
argument_list|(
name|tinfo_s
argument_list|,
name|tinfo_descs
argument_list|,
name|TK_BASE_TYPE
argument_list|)
expr_stmt|;
name|ti
operator|->
name|type
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|ti
operator|->
name|vtable
operator|=
name|NULL_TREE
expr_stmt|;
name|ti
operator|->
name|name
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_builtin_struct
argument_list|(
name|ti
operator|->
name|type
argument_list|,
literal|"__base_class_type_info_pseudo"
argument_list|,
name|fields
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ti
operator|->
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Pointer type_info. Adds two fields, qualification mask      and pointer to the pointed to type.  This is really a descendant of      __pbase_type_info.  */
name|create_pseudo_type_info
argument_list|(
name|TK_POINTER_TYPE
argument_list|,
literal|"__pointer_type_info"
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type_info_ptr_type
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pointer to member data type_info.  Add qualifications flags,      pointer to the member's type info and pointer to the class.      This is really a descendant of __pbase_type_info.  */
name|create_pseudo_type_info
argument_list|(
name|TK_POINTER_MEMBER_TYPE
argument_list|,
literal|"__pointer_to_member_type_info"
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type_info_ptr_type
argument_list|)
argument_list|,
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type_info_ptr_type
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the type_info descriptors which are guaranteed to be in the runtime    support.  Generating them here guarantees consistency with the other    structures.  We use the following heuristic to determine when the runtime    is being generated.  If std::__fundamental_type_info is defined, and its    destructor is defined, then the runtime is being built.  */
end_comment

begin_function
name|void
name|emit_support_tinfos
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|tree
modifier|*
specifier|const
name|fundamentals
index|[]
init|=
block|{
operator|&
name|void_type_node
block|,
operator|&
name|boolean_type_node
block|,
operator|&
name|wchar_type_node
block|,
operator|&
name|char_type_node
block|,
operator|&
name|signed_char_type_node
block|,
operator|&
name|unsigned_char_type_node
block|,
operator|&
name|short_integer_type_node
block|,
operator|&
name|short_unsigned_type_node
block|,
operator|&
name|integer_type_node
block|,
operator|&
name|unsigned_type_node
block|,
operator|&
name|long_integer_type_node
block|,
operator|&
name|long_unsigned_type_node
block|,
operator|&
name|long_long_integer_type_node
block|,
operator|&
name|long_long_unsigned_type_node
block|,
operator|&
name|float_type_node
block|,
operator|&
name|double_type_node
block|,
operator|&
name|long_double_type_node
block|,
literal|0
block|}
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|tree
name|bltn_type
decl_stmt|,
name|dtor
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
name|bltn_type
operator|=
name|xref_tag
argument_list|(
name|class_type
argument_list|,
name|get_identifier
argument_list|(
literal|"__fundamental_type_info"
argument_list|)
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|abi_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|bltn_type
argument_list|)
condition|)
return|return;
name|dtor
operator|=
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|bltn_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtor
operator|||
name|DECL_EXTERNAL
argument_list|(
name|dtor
argument_list|)
condition|)
return|return;
name|doing_runtime
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fundamentals
index|[
name|ix
index|]
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|bltn
init|=
operator|*
name|fundamentals
index|[
name|ix
index|]
decl_stmt|;
name|tree
name|types
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|types
index|[
literal|0
index|]
operator|=
name|bltn
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
name|build_pointer_type
argument_list|(
name|bltn
argument_list|)
expr_stmt|;
name|types
index|[
literal|2
index|]
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|bltn
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tinfo
decl_stmt|;
name|tinfo
operator|=
name|get_tinfo_decl
argument_list|(
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|tinfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_needed
argument_list|(
name|tinfo
argument_list|)
expr_stmt|;
comment|/* The C++ ABI requires that these objects be COMDAT.  But, 	     On systems without weak symbols, initialized COMDAT 	     objects are emitted with internal linkage.  (See 	     comdat_linkage for details.)  Since we want these objects 	     to have external linkage so that copies do not have to be 	     emitted in code outside the runtime library, we make them 	     non-COMDAT here.  */
if|if
condition|(
operator|!
name|flag_weak
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|tinfo
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|tinfo
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|tinfo
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Finish a type info decl. DECL_PTR is a pointer to an unemitted    tinfo decl.  Determine whether it needs emitting, and if so    generate the initializer.  */
end_comment

begin_function
name|bool
name|emit_tinfo_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|in_library
init|=
name|typeinfo_in_lib_p
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_library
condition|)
block|{
if|if
condition|(
name|doing_runtime
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* If we're not in the runtime, then DECL (which is already 	     DECL_EXTERNAL) will not be defined here.  */
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|involves_incomplete_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|decl_needed_p
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If TYPE involves an incomplete class type, then the typeinfo 	 object will be emitted with internal linkage.  There is no 	 way to know whether or not types are incomplete until the end 	 of the compilation, so this determination must be deferred 	 until this point.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|import_export_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_needed_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|init
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|init
operator|=
name|get_pseudo_ti_init
argument_list|(
name|type
argument_list|,
name|get_pseudo_ti_index
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-rtti.h"
end_include

end_unit

