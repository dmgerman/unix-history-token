begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Protoize program - Original version by Ron Guilmette (rfg@segfault.us.com).    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"cppdefault.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGCLD
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_comment
comment|/* Include getopt.h for the sake of getopt_long.  */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* Macro to see if the path elements match.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
end_ifdef

begin_define
define|#
directive|define
name|IS_SAME_PATH_CHAR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(TOUPPER (a) == TOUPPER (b))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_SAME_PATH_CHAR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) == (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro to see if the paths match.  */
end_comment

begin_define
define|#
directive|define
name|IS_SAME_PATH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(FILENAME_CMP (a, b) == 0)
end_define

begin_comment
comment|/* Suffix for aux-info files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_define
define|#
directive|define
name|AUX_INFO_SUFFIX
value|"X"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AUX_INFO_SUFFIX
value|".X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Suffix for saved files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_define
define|#
directive|define
name|SAVE_SUFFIX
value|"sav"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SAVE_SUFFIX
value|".save"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Suffix for renamed C++ files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
end_ifdef

begin_define
define|#
directive|define
name|CPLUS_FILE_SUFFIX
value|"cc"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CPLUS_FILE_SUFFIX
value|"C"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aux_info_corrupted
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|declare_source_confusing
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|shortpath
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|notice
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|savestring
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dupnstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_read
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_write
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_pointers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restore_pointers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_id_char
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in_system_include_dir
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|directory_specified_p
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_excluded_p
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|unexpand_if_needed
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|abspath
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_aux_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|find_corresponding_lparen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|referenced_file_is_newer
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_def_or_dec
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|munge_compile_params
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gen_aux_info_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_aux_info_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|identify_lineno
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_source
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|seek_to_line
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|forward_to_next_token_char
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_bytes
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_up_to
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|other_variable_style_function
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|find_rightmost_formals_list
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_cleaning
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|careful_find_l_paren
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_processing
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Look for these where the `const' qualifier is intentionally cast aside.  */
end_comment

begin_define
define|#
directive|define
name|NONCONST
end_define

begin_comment
comment|/* Define a default place to find the SYSCALLS.X file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNPROTOIZE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_EXEC_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_EXEC_PREFIX
value|"/usr/local/lib/gcc-lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined STANDARD_EXEC_PREFIX */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|standard_exec_prefix
init|=
name|STANDARD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|target_machine
init|=
name|DEFAULT_TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|target_version
init|=
name|DEFAULT_TARGET_VERSION
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_comment
comment|/* Suffix of aux_info files.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|aux_info_suffix
init|=
name|AUX_INFO_SUFFIX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to attach to filenames for saved versions of original files.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|save_suffix
init|=
name|SAVE_SUFFIX
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|UNPROTOIZE
end_ifndef

begin_comment
comment|/* String to attach to C filenames renamed to C++.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cplus_suffix
init|=
name|CPLUS_FILE_SUFFIX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name of the file which contains descriptions of standard system    routines.  Note that we never actually do anything with this file per se,    but we do read in its corresponding aux_info file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|syscalls_filename
index|[]
init|=
literal|"SYSCALLS.c"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default place to find the above file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_syscalls_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable to hold the complete absolutized filename of the SYSCALLS.c.X    file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|syscalls_absolute_filename
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_comment
comment|/* Type of the structure that holds information about macro unexpansions.  */
end_comment

begin_struct
struct|struct
name|unexpansion_struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|expanded
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|contracted
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|unexpansion_struct
name|unexpansion
typedef|;
end_typedef

begin_comment
comment|/* A table of conversions that may need to be made for some (stupid) older    operating systems where these types are preprocessor macros rather than    typedefs (as they really ought to be).     WARNING: The contracted forms must be as small (or smaller) as the    expanded forms, or else havoc will ensue.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unexpansion
name|unexpansions
index|[]
init|=
block|{
block|{
literal|"struct _iobuf"
block|,
literal|"FILE"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of "primary" slots in the hash tables for filenames and for    function names.  This can be as big or as small as you like, except that    it must be a power of two.  */
end_comment

begin_define
define|#
directive|define
name|HASH_TABLE_SIZE
value|(1<< 9)
end_define

begin_comment
comment|/* Bit mask to use when computing hash values.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|hash_mask
init|=
operator|(
name|HASH_TABLE_SIZE
operator|-
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Datatype for lists of directories or filenames.  */
end_comment

begin_struct
struct|struct
name|string_list
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|string_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_cons
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|string_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* List of directories in which files should be converted.  */
end_comment

begin_decl_stmt
name|struct
name|string_list
modifier|*
name|directory_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of file names which should not be converted.    A file is excluded if the end of its name, following a /,    matches one of the names in this list.  */
end_comment

begin_decl_stmt
name|struct
name|string_list
modifier|*
name|exclude_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the other style of variable-number-of-parameters functions    (i.e. the style that we want to leave unconverted because we don't yet    know how to convert them to this style.  This string is used in warning    messages.  */
end_comment

begin_comment
comment|/* Also define here the string that we can search for in the parameter lists    taken from the .X files which will unambiguously indicate that we have    found a varargs style function.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNPROTOIZE
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|other_var_style
init|=
literal|"stdarg"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|other_var_style
init|=
literal|"varargs"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|varargs_style_indicator
init|=
literal|"va_alist"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_comment
comment|/* The following two types are used to create hash tables.  In this program,    there are two hash tables which are used to store and quickly lookup two    different classes of strings.  The first type of strings stored in the    first hash table are absolute filenames of files which protoize needs to    know about.  The second type of strings (stored in the second hash table)    are function names.  It is this second class of strings which really    inspired the use of the hash tables, because there may be a lot of them.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|hash_table_entry_struct
name|hash_table_entry
typedef|;
end_typedef

begin_comment
comment|/* Do some typedefs so that we don't have to write "struct" so often.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|def_dec_info_struct
name|def_dec_info
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|file_info_struct
name|file_info
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|f_list_chain_item_struct
name|f_list_chain_item
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|UNPROTOIZE
end_ifndef

begin_function_decl
specifier|static
name|int
name|is_syscalls_file
parameter_list|(
specifier|const
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rename_c_file
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|def_dec_info
modifier|*
name|find_extern_def
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
parameter_list|,
specifier|const
name|def_dec_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|def_dec_info
modifier|*
name|find_static_definition
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_defs_and_decs
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_local_decl
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_global_decls
parameter_list|(
specifier|const
name|file_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! UNPROTOIZE */
end_comment

begin_function_decl
specifier|static
name|int
name|needs_to_be_converted
parameter_list|(
specifier|const
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|visit_each_hash_node
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hash_table_entry
modifier|*
name|add_symbol
parameter_list|(
name|hash_table_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hash_table_entry
modifier|*
name|lookup
parameter_list|(
name|hash_table_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_def_dec
parameter_list|(
name|def_dec_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|file_info
modifier|*
name|find_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reverse_def_dec_list
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|edit_fn_declaration
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|edit_formals_lists
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
specifier|const
name|def_dec_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|edit_fn_definition
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_for_missed_items
parameter_list|(
specifier|const
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|edit_file
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* In the struct below, note that the "_info" field has two different uses    depending on the type of hash table we are in (i.e. either the filenames    hash table or the function names hash table).  In the filenames hash table    the info fields of the entries point to the file_info struct which is    associated with each filename (1 per filename).  In the function names    hash table, the info field points to the head of a singly linked list of    def_dec_info entries which are all defs or decs of the function whose    name is pointed to by the "symbol" field.  Keeping all of the defs/decs    for a given function name on a special list specifically for that function    name makes it quick and easy to find out all of the important information    about a given (named) function.  */
end_comment

begin_struct
struct|struct
name|hash_table_entry_struct
block|{
name|hash_table_entry
modifier|*
name|hash_next
decl_stmt|;
comment|/* -> to secondary entries */
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
comment|/* -> to the hashed string */
union|union
block|{
specifier|const
name|def_dec_info
modifier|*
name|_ddip
decl_stmt|;
name|file_info
modifier|*
name|_fip
decl_stmt|;
block|}
name|_info
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ddip
value|_info._ddip
end_define

begin_define
define|#
directive|define
name|fip
value|_info._fip
end_define

begin_comment
comment|/* Define a type specifically for our two hash tables.  */
end_comment

begin_typedef
typedef|typedef
name|hash_table_entry
name|hash_table
index|[
name|HASH_TABLE_SIZE
index|]
typedef|;
end_typedef

begin_comment
comment|/* The following struct holds all of the important information about any    single filename (e.g. file) which we need to know about.  */
end_comment

begin_struct
struct|struct
name|file_info_struct
block|{
specifier|const
name|hash_table_entry
modifier|*
name|hash_entry
decl_stmt|;
comment|/* -> to associated hash entry */
specifier|const
name|def_dec_info
modifier|*
name|defs_decs
decl_stmt|;
comment|/* -> to chain of defs/decs */
name|time_t
name|mtime
decl_stmt|;
comment|/* Time of last modification.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Due to the possibility that functions may return pointers to functions,    (which may themselves have their own parameter lists) and due to the    fact that returned pointers-to-functions may be of type "pointer-to-    function-returning-pointer-to-function" (ad nauseum) we have to keep    an entire chain of ANSI style formal parameter lists for each function.     Normally, for any given function, there will only be one formals list    on the chain, but you never know.     Note that the head of each chain of formals lists is pointed to by the    `f_list_chain' field of the corresponding def_dec_info record.     For any given chain, the item at the head of the chain is the *leftmost*    parameter list seen in the actual C language function declaration.  If    there are other members of the chain, then these are linked in left-to-right    order from the head of the chain.  */
end_comment

begin_struct
struct|struct
name|f_list_chain_item_struct
block|{
specifier|const
name|f_list_chain_item
modifier|*
name|chain_next
decl_stmt|;
comment|/* -> to next item on chain */
specifier|const
name|char
modifier|*
name|formals_list
decl_stmt|;
comment|/* -> to formals list string */
block|}
struct|;
end_struct

begin_comment
comment|/* The following struct holds all of the important information about any    single function definition or declaration which we need to know about.    Note that for unprotoize we don't need to know very much because we    never even create records for stuff that we don't intend to convert    (like for instance defs and decs which are already in old K&R format    and "implicit" function declarations).  */
end_comment

begin_struct
struct|struct
name|def_dec_info_struct
block|{
specifier|const
name|def_dec_info
modifier|*
name|next_in_file
decl_stmt|;
comment|/* -> to rest of chain for file */
name|file_info
modifier|*
name|file
decl_stmt|;
comment|/* -> file_info for containing file */
name|int
name|line
decl_stmt|;
comment|/* source line number of def/dec */
specifier|const
name|char
modifier|*
name|ansi_decl
decl_stmt|;
comment|/* -> left end of ansi decl */
name|hash_table_entry
modifier|*
name|hash_entry
decl_stmt|;
comment|/* -> hash entry for function name */
name|unsigned
name|int
name|is_func_def
decl_stmt|;
comment|/* = 0 means this is a declaration */
specifier|const
name|def_dec_info
modifier|*
name|next_for_func
decl_stmt|;
comment|/* -> to rest of chain for func name */
name|unsigned
name|int
name|f_list_count
decl_stmt|;
comment|/* count of formals lists we expect */
name|char
name|prototyped
decl_stmt|;
comment|/* = 0 means already prototyped */
ifndef|#
directive|ifndef
name|UNPROTOIZE
specifier|const
name|f_list_chain_item
modifier|*
name|f_list_chain
decl_stmt|;
comment|/* -> chain of formals lists */
specifier|const
name|def_dec_info
modifier|*
name|definition
decl_stmt|;
comment|/* -> def/dec containing related def */
name|char
name|is_static
decl_stmt|;
comment|/* = 0 means visibility is "extern"  */
name|char
name|is_implicit
decl_stmt|;
comment|/* != 0 for implicit func decl's */
name|char
name|written
decl_stmt|;
comment|/* != 0 means written for implicit */
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
specifier|const
name|char
modifier|*
name|formal_names
decl_stmt|;
comment|/* -> to list of names of formals */
specifier|const
name|char
modifier|*
name|formal_decls
decl_stmt|;
comment|/* -> to string of formal declarations */
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
block|}
struct|;
end_struct

begin_comment
comment|/* Pointer to the tail component of the filename by which this program was    invoked.  Used everywhere in error and warning messages.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error counter.  Will be nonzero if we should give up at the next convenient    stopping point.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Option flags.  */
end_comment

begin_comment
comment|/* ??? The variables are not marked static because some of them have    the same names as gcc variables declared in options.h.  */
end_comment

begin_comment
comment|/* ??? These comments should say what the flag mean as well as the options    that set them.  */
end_comment

begin_comment
comment|/* File name to use for running gcc.  Allows GCC 2 to be named    something other than gcc.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|compiler_file_name
init|=
literal|"gcc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|version_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print our version number.  */
end_comment

begin_decl_stmt
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't print messages normally.  */
end_comment

begin_decl_stmt
name|int
name|nochange_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't convert, just say what files 				   we would have converted.  */
end_comment

begin_decl_stmt
name|int
name|nosave_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't save the old version.  */
end_comment

begin_decl_stmt
name|int
name|keep_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't delete the .X files.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|compile_params
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Option string for gcc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNPROTOIZE
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|indent_string
init|=
literal|"     "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indentation for newly 						   inserted parm decls.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_decl_stmt
name|int
name|local_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert new local decls (when?).  */
end_comment

begin_decl_stmt
name|int
name|global_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set by -g option */
end_comment

begin_decl_stmt
name|int
name|cplusplus_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rename converted files to *.C.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|nondefault_syscalls_dir
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dir to look for 						   SYSCALLS.c.X in.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_comment
comment|/* An index into the compile_params array where we should insert the source    file name when we are ready to exec the C compiler.  A zero value indicates    that we have not yet called munge_compile_params.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_file_name_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An index into the compile_params array where we should insert the filename    for the aux info file, when we run the C compiler.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aux_info_file_name_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of command line arguments which were "filename" arguments.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_base_source_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to a malloc'ed list of pointers to all of the filenames of base    source files which were specified on the command line.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|base_source_filenames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of the line within the current aux_info file that we    are currently processing.  Used for error messages in case the prototypes    info file is corrupted somehow.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_aux_info_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the name of the source file currently being converted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|convert_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to relative root string (taken from aux_info file) which indicates    where directory the user was in when he did the compilation step that    produced the containing aux_info file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|invocation_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the base of the input buffer that holds the original text for the    source file currently being converted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|orig_text_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the byte just beyond the end of the input buffer that holds the    original text for the source file currently being converted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|orig_text_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the base of the input buffer that holds the cleaned text for the    source file currently being converted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|clean_text_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the byte just beyond the end of the input buffer that holds the    cleaned text for the source file currently being converted.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|clean_text_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last byte in the cleaned text buffer that we have already    (virtually) copied to the output buffer (or decided to ignore).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|clean_read_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the base of the output buffer that holds the replacement text    for the source file currently being converted.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repl_text_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the byte just beyond the end of the output buffer that holds the    replacement text for the source file currently being converted.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repl_text_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last byte which has been stored into the output buffer.    The next byte to be stored should be stored just past where this points    to.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repl_write_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer into the cleaned text buffer for the source file we are currently    converting.  This points to the first character of the line that we last    did a "seek_to_line" to (see below).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|last_known_line_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of the line (in the cleaned text buffer) that we last did a    "seek_to_line" to.  Will be one if we just read a new source file    into the cleaned text buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_known_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The filenames hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|hash_table
name|filename_primary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function names hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|hash_table
name|function_name_primary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The place to keep the recovery address which is used only in cases where    we get hopelessly confused by something in the cleaned original text.  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|source_confusion_recovery
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the current directory filename (used by abspath).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cwd_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A place to save the read pointer until we are sure that an individual    attempt at editing will succeed.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|saved_clean_read_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A place to save the write pointer until we are sure that an individual    attempt at editing will succeed.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_repl_write_ptr
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Translate and output an error message.  */
end_comment

begin_function
specifier|static
name|void
name|notice
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of a string INPUT with size SIZE.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|savestring
parameter_list|(
specifier|const
name|char
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a duplicate of the first N bytes of a given string in a newly    allocated area.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dupnstr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
modifier|*
name|ret_val
init|=
name|xmalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|ret_val
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ret_val
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,    retrying if necessary.  Return the actual number of bytes read.  */
end_comment

begin_function
specifier|static
name|int
name|safe_read
parameter_list|(
name|int
name|desc
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|left
init|=
name|len
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|int
name|nchars
init|=
name|read
argument_list|(
name|desc
argument_list|,
name|ptr
argument_list|,
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|nchars
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
name|nchars
return|;
block|}
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
break|break;
comment|/* Arithmetic on void pointers is a gcc extension.  */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|nchars
expr_stmt|;
name|left
operator|-=
name|nchars
expr_stmt|;
block|}
return|return
name|len
operator|-
name|left
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes at PTR to descriptor DESC,    retrying if necessary, and treating any real error as fatal.  */
end_comment

begin_function
specifier|static
name|void
name|safe_write
parameter_list|(
name|int
name|desc
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|out_fname
parameter_list|)
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|written
init|=
name|write
argument_list|(
name|desc
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno_val
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
name|notice
argument_list|(
literal|"%s: error writing file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|out_fname
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Arithmetic on void pointers is a gcc extension.  */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|written
expr_stmt|;
name|len
operator|-=
name|written
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get setup to recover in case the edit we are about to do goes awry.  */
end_comment

begin_function
specifier|static
name|void
name|save_pointers
parameter_list|(
name|void
parameter_list|)
block|{
name|saved_clean_read_ptr
operator|=
name|clean_read_ptr
expr_stmt|;
name|saved_repl_write_ptr
operator|=
name|repl_write_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this routine to recover our previous state whenever something looks    too confusing in the source code we are trying to edit.  */
end_comment

begin_function
specifier|static
name|void
name|restore_pointers
parameter_list|(
name|void
parameter_list|)
block|{
name|clean_read_ptr
operator|=
name|saved_clean_read_ptr
expr_stmt|;
name|repl_write_ptr
operator|=
name|saved_repl_write_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the given character is a valid identifier character.  */
end_comment

begin_function
specifier|static
name|int
name|is_id_char
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ISIDNUM
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'$'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Give a message indicating the proper way to invoke this program and then    exit with nonzero status.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UNPROTOIZE
name|notice
argument_list|(
literal|"%s: usage '%s [ -VqfnkN ] [ -i<istring> ] [ filename ... ]'\n"
argument_list|,
name|pname
argument_list|,
name|pname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
name|notice
argument_list|(
literal|"%s: usage '%s [ -VqfnkNlgC ] [ -B<dirname> ] [ filename ... ]'\n"
argument_list|,
name|pname
argument_list|,
name|pname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the given filename (assumed to be an absolute filename)    designates a file residing anywhere beneath any one of the "system"    include directories.  */
end_comment

begin_function
specifier|static
name|int
name|in_system_include_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
specifier|const
name|struct
name|default_include
modifier|*
name|p
decl_stmt|;
name|gcc_assert
argument_list|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cpp_include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|path
argument_list|,
name|p
operator|->
name|fname
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
argument_list|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|path
index|[
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return true if the given filename designates a file that the user has    read access to and for which the user has write access to the containing    directory.  */
end_comment

begin_ifdef
unit|static int file_could_be_converted (const char *path) {   char *const dir_name = alloca (strlen (path) + 1);    if (access (path, R_OK))     return 0;    {     char *dir_last_slash;      strcpy (dir_name, path);     dir_last_slash = strrchr (dir_name, DIR_SEPARATOR);
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
end_ifdef

begin_endif
unit|{       char *slash;        slash = strrchr (dir_last_slash ? dir_last_slash : dir_name, 		       DIR_SEPARATOR_2);       if (slash) 	dir_last_slash = slash;     }
endif|#
directive|endif
end_endif

begin_comment
unit|gcc_assert (dir_last_slash);     *dir_last_slash = '\0';   }    if (access (path, W_OK))     return 0;    return 1; }
comment|/* Return true if the given filename designates a file that we are allowed    to modify.  Files which we should not attempt to modify are (a) "system"    include files, and (b) files which the user doesn't have write access to,    and (c) files which reside in directories which the user doesn't have    write access to.  Unless requested to be quiet, give warnings about    files that we will not try to convert for one reason or another.  An    exception is made for "system" include files, which we never try to    convert and for which we don't issue the usual warnings.  */
end_comment

begin_ifdef
unit|static int file_normally_convertible (const char *path) {   char *const dir_name = alloca (strlen (path) + 1);    if (in_system_include_dir (path))     return 0;    {     char *dir_last_slash;      strcpy (dir_name, path);     dir_last_slash = strrchr (dir_name, DIR_SEPARATOR);
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
end_ifdef

begin_endif
unit|{       char *slash;        slash = strrchr (dir_last_slash ? dir_last_slash : dir_name, 		       DIR_SEPARATOR_2);       if (slash) 	dir_last_slash = slash;     }
endif|#
directive|endif
end_endif

begin_endif
unit|gcc_assert (dir_last_slash);     *dir_last_slash = '\0';   }    if (access (path, R_OK))     {       if (!quiet_flag) 	notice ("%s: warning: no read access for file '%s'\n", 		pname, shortpath (NULL, path));       return 0;     }    if (access (path, W_OK))     {       if (!quiet_flag) 	notice ("%s: warning: no write access for file '%s'\n", 		pname, shortpath (NULL, path));       return 0;     }    if (access (dir_name, W_OK))     {       if (!quiet_flag) 	notice ("%s: warning: no write access for dir containing '%s'\n", 		pname, shortpath (NULL, path));       return 0;     }    return 1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|UNPROTOIZE
end_ifndef

begin_comment
comment|/* Return true if the given file_info struct refers to the special SYSCALLS.c.X    file.  Return false otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|is_syscalls_file
parameter_list|(
specifier|const
name|file_info
modifier|*
name|fi_p
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|f
init|=
name|fi_p
operator|->
name|hash_entry
operator|->
name|symbol
decl_stmt|;
name|size_t
name|fl
init|=
name|strlen
argument_list|(
name|f
argument_list|)
decl_stmt|,
name|sysl
init|=
sizeof|sizeof
argument_list|(
name|syscalls_filename
argument_list|)
operator|-
literal|1
decl_stmt|;
return|return
name|sysl
operator|<=
name|fl
operator|&&
name|strcmp
argument_list|(
name|f
operator|+
name|fl
operator|-
name|sysl
argument_list|,
name|syscalls_filename
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_comment
comment|/* Check to see if this file will need to have anything done to it on this    run.  If there is nothing in the given file which both needs conversion    and for which we have the necessary stuff to do the conversion, return    false.  Otherwise, return true.     Note that (for protoize) it is only valid to call this function *after*    the connections between declarations and definitions have all been made    by connect_defs_and_decs.  */
end_comment

begin_function
specifier|static
name|int
name|needs_to_be_converted
parameter_list|(
specifier|const
name|file_info
modifier|*
name|file_p
parameter_list|)
block|{
specifier|const
name|def_dec_info
modifier|*
name|ddp
decl_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
if|if
condition|(
name|is_syscalls_file
argument_list|(
name|file_p
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
for|for
control|(
name|ddp
operator|=
name|file_p
operator|->
name|defs_decs
init|;
name|ddp
condition|;
name|ddp
operator|=
name|ddp
operator|->
name|next_in_file
control|)
if|if
condition|(
ifndef|#
directive|ifndef
name|UNPROTOIZE
comment|/* ... and if we a protoizing and this function is in old style ...  */
operator|!
name|ddp
operator|->
name|prototyped
comment|/* ... and if this a definition or is a decl with an associated def ...  */
operator|&&
operator|(
name|ddp
operator|->
name|is_func_def
operator|||
operator|(
operator|!
name|ddp
operator|->
name|is_func_def
operator|&&
name|ddp
operator|->
name|definition
operator|)
operator|)
else|#
directive|else
comment|/* defined (UNPROTOIZE) */
comment|/* ... and if we are unprotoizing and this function is in new style ...  */
name|ddp
operator|->
name|prototyped
endif|#
directive|endif
comment|/* defined (UNPROTOIZE) */
condition|)
comment|/* ... then the containing file needs converting.  */
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the file name NAME is in a directory    that should be converted.  */
end_comment

begin_function
specifier|static
name|int
name|directory_specified_p
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|directory_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
argument_list|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
index|]
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|name
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* If there are more slashes, it's in a subdir, so 	   this match doesn't count.  */
while|while
condition|(
operator|*
name|q
operator|++
condition|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
argument_list|)
condition|)
goto|goto
name|lose
goto|;
return|return
literal|1
return|;
name|lose
label|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the file named NAME should be excluded from conversion.  */
end_comment

begin_function
specifier|static
name|int
name|file_excluded_p
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|exclude_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|len
operator|-
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|name
index|[
name|len
operator|-
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Construct a new element of a string_list.    STRING is the new element value, and REST holds the remaining elements.  */
end_comment

begin_function
specifier|static
name|struct
name|string_list
modifier|*
name|string_list_cons
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|struct
name|string_list
modifier|*
name|rest
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|next
operator|=
name|rest
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|string
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ??? The GNU convention for mentioning function args in its comments    is to capitalize them.  So change "hash_tab_p" to HASH_TAB_P below.    Likewise for all the other functions.  */
end_comment

begin_comment
comment|/* Given a hash table, apply some function to each node in the table. The    table to traverse is given as the "hash_tab_p" argument, and the    function to be applied to each node in the table is given as "func"    argument.  */
end_comment

begin_function
specifier|static
name|void
name|visit_each_hash_node
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
name|hash_tab_p
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
parameter_list|)
parameter_list|)
block|{
specifier|const
name|hash_table_entry
modifier|*
name|primary
decl_stmt|;
for|for
control|(
name|primary
operator|=
name|hash_tab_p
init|;
name|primary
operator|<
operator|&
name|hash_tab_p
index|[
name|HASH_TABLE_SIZE
index|]
condition|;
name|primary
operator|++
control|)
if|if
condition|(
name|primary
operator|->
name|symbol
condition|)
block|{
name|hash_table_entry
modifier|*
name|second
decl_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|primary
argument_list|)
expr_stmt|;
for|for
control|(
name|second
operator|=
name|primary
operator|->
name|hash_next
init|;
name|second
condition|;
name|second
operator|=
name|second
operator|->
name|hash_next
control|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|second
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize all of the fields of a new hash table entry, pointed    to by the "p" parameter.  Note that the space to hold the entry    is assumed to have already been allocated before this routine is    called.  */
end_comment

begin_function
specifier|static
name|hash_table_entry
modifier|*
name|add_symbol
parameter_list|(
name|hash_table_entry
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|p
operator|->
name|hash_next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|symbol
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|->
name|ddip
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|fip
operator|=
name|NULL
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Look for a particular function name or filename in the particular    hash table indicated by "hash_tab_p".  If the name is not in the    given hash table, add it.  Either way, return a pointer to the    hash table entry for the given name.  */
end_comment

begin_function
specifier|static
name|hash_table_entry
modifier|*
name|lookup
parameter_list|(
name|hash_table_entry
modifier|*
name|hash_tab_p
parameter_list|,
specifier|const
name|char
modifier|*
name|search_symbol
parameter_list|)
block|{
name|int
name|hash_value
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|search_symbol_char_p
init|=
name|search_symbol
decl_stmt|;
name|hash_table_entry
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|search_symbol_char_p
condition|)
name|hash_value
operator|+=
operator|*
name|search_symbol_char_p
operator|++
expr_stmt|;
name|hash_value
operator|&=
name|hash_mask
expr_stmt|;
name|p
operator|=
operator|&
name|hash_tab_p
index|[
name|hash_value
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|symbol
condition|)
return|return
name|add_symbol
argument_list|(
name|p
argument_list|,
name|search_symbol
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|symbol
argument_list|,
name|search_symbol
argument_list|)
condition|)
return|return
name|p
return|;
while|while
condition|(
name|p
operator|->
name|hash_next
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|symbol
argument_list|,
name|search_symbol
argument_list|)
condition|)
return|return
name|p
return|;
block|}
name|p
operator|->
name|hash_next
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hash_table_entry
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|hash_next
expr_stmt|;
return|return
name|add_symbol
argument_list|(
name|p
argument_list|,
name|search_symbol
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throw a def/dec record on the junk heap.     Also, since we are not using this record anymore, free up all of the    stuff it pointed to.  */
end_comment

begin_function
specifier|static
name|void
name|free_def_dec
parameter_list|(
name|def_dec_info
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|NONCONST
name|void
operator|*
operator|)
name|p
operator|->
name|ansi_decl
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
block|{
specifier|const
name|f_list_chain_item
modifier|*
name|curr
decl_stmt|;
specifier|const
name|f_list_chain_item
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|p
operator|->
name|f_list_chain
init|;
name|curr
condition|;
name|curr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|curr
operator|->
name|chain_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|NONCONST
name|void
operator|*
operator|)
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unexpand as many macro symbols as we can find.     If the given line must be unexpanded, make a copy of it in the heap and    return a pointer to the unexpanded copy.  Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|unexpand_if_needed
parameter_list|(
specifier|const
name|char
modifier|*
name|aux_info_line
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|line_buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|line_buf_size
init|=
literal|0
decl_stmt|;
specifier|const
name|unexpansion
modifier|*
name|unexp_p
decl_stmt|;
name|int
name|got_unexpanded
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|copy_p
init|=
name|line_buf
decl_stmt|;
if|if
condition|(
name|line_buf
operator|==
literal|0
condition|)
block|{
name|line_buf_size
operator|=
literal|1024
expr_stmt|;
name|line_buf
operator|=
name|xmalloc
argument_list|(
name|line_buf_size
argument_list|)
expr_stmt|;
block|}
name|copy_p
operator|=
name|line_buf
expr_stmt|;
comment|/* Make a copy of the input string in line_buf, expanding as necessary.  */
for|for
control|(
name|s
operator|=
name|aux_info_line
init|;
operator|*
name|s
operator|!=
literal|'\n'
condition|;
control|)
block|{
for|for
control|(
name|unexp_p
operator|=
name|unexpansions
init|;
name|unexp_p
operator|->
name|expanded
condition|;
name|unexp_p
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|in_p
init|=
name|unexp_p
operator|->
name|expanded
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|in_p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|in_p
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|in_p
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|is_id_char
argument_list|(
name|s
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|strlen
argument_list|(
name|unexp_p
operator|->
name|contracted
argument_list|)
decl_stmt|;
name|got_unexpanded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|copy_p
operator|+
name|size
operator|-
name|line_buf
operator|>=
name|line_buf_size
condition|)
block|{
name|int
name|offset
init|=
name|copy_p
operator|-
name|line_buf
decl_stmt|;
name|line_buf_size
operator|*=
literal|2
expr_stmt|;
name|line_buf_size
operator|+=
name|size
expr_stmt|;
name|line_buf
operator|=
name|xrealloc
argument_list|(
name|line_buf
argument_list|,
name|line_buf_size
argument_list|)
expr_stmt|;
name|copy_p
operator|=
name|line_buf
operator|+
name|offset
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|copy_p
argument_list|,
name|unexp_p
operator|->
name|contracted
argument_list|)
expr_stmt|;
name|copy_p
operator|+=
name|size
expr_stmt|;
comment|/* Assume that there will not be another replacement required 	         within the text just replaced.  */
name|s
operator|+=
name|len
expr_stmt|;
goto|goto
name|continue_outer
goto|;
block|}
block|}
if|if
condition|(
name|copy_p
operator|-
name|line_buf
operator|==
name|line_buf_size
condition|)
block|{
name|int
name|offset
init|=
name|copy_p
operator|-
name|line_buf
decl_stmt|;
name|line_buf_size
operator|*=
literal|2
expr_stmt|;
name|line_buf
operator|=
name|xrealloc
argument_list|(
name|line_buf
argument_list|,
name|line_buf_size
argument_list|)
expr_stmt|;
name|copy_p
operator|=
name|line_buf
operator|+
name|offset
expr_stmt|;
block|}
operator|*
name|copy_p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|continue_outer
label|:
empty_stmt|;
block|}
if|if
condition|(
name|copy_p
operator|+
literal|2
operator|-
name|line_buf
operator|>=
name|line_buf_size
condition|)
block|{
name|int
name|offset
init|=
name|copy_p
operator|-
name|line_buf
decl_stmt|;
name|line_buf_size
operator|*=
literal|2
expr_stmt|;
name|line_buf
operator|=
name|xrealloc
argument_list|(
name|line_buf
argument_list|,
name|line_buf_size
argument_list|)
expr_stmt|;
name|copy_p
operator|=
name|line_buf
operator|+
name|offset
expr_stmt|;
block|}
operator|*
name|copy_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|copy_p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|got_unexpanded
condition|?
name|savestring
argument_list|(
name|line_buf
argument_list|,
name|copy_p
operator|-
name|line_buf
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the absolutized filename for the given relative    filename.  Note that if that filename is already absolute, it may    still be returned in a modified form because this routine also    eliminates redundant slashes and single dots and eliminates double    dots to get a shortest possible filename from the given input    filename.  The absolutization of relative filenames is made by    assuming that the given filename is to be taken as relative to    the first argument (cwd) or to the current directory if cwd is    NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|abspath
parameter_list|(
specifier|const
name|char
modifier|*
name|cwd
parameter_list|,
specifier|const
name|char
modifier|*
name|rel_filename
parameter_list|)
block|{
comment|/* Setup the current working directory as needed.  */
specifier|const
name|char
modifier|*
specifier|const
name|cwd2
init|=
operator|(
name|cwd
operator|)
condition|?
name|cwd
else|:
name|cwd_buffer
decl_stmt|;
name|char
modifier|*
specifier|const
name|abs_buffer
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|cwd2
argument_list|)
operator|+
name|strlen
argument_list|(
name|rel_filename
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|endp
init|=
name|abs_buffer
decl_stmt|;
name|char
modifier|*
name|outp
decl_stmt|,
modifier|*
name|inp
decl_stmt|;
comment|/* Copy the  filename (possibly preceded by the current working      directory name) into the absolutization buffer.  */
block|{
specifier|const
name|char
modifier|*
name|src_p
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|rel_filename
argument_list|)
condition|)
block|{
name|src_p
operator|=
name|cwd2
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|endp
operator|++
operator|=
operator|*
name|src_p
operator|++
operator|)
condition|)
continue|continue;
operator|*
operator|(
name|endp
operator|-
literal|1
operator|)
operator|=
name|DIR_SEPARATOR
expr_stmt|;
comment|/* overwrite null */
block|}
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
elseif|else
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|rel_filename
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* A path starting with a directory separator is considered absolute 	   for dos based filesystems, but it's really not -- it's just the 	   convention used throughout GCC and it works. However, in this 	   case, we still need to prepend the drive spec from cwd_buffer.  */
operator|*
name|endp
operator|++
operator|=
name|cwd2
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|endp
operator|++
operator|=
name|cwd2
index|[
literal|1
index|]
expr_stmt|;
block|}
endif|#
directive|endif
name|src_p
operator|=
name|rel_filename
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|endp
operator|++
operator|=
operator|*
name|src_p
operator|++
operator|)
condition|)
continue|continue;
block|}
comment|/* Now make a copy of abs_buffer into abs_buffer, shortening the      filename (by taking out slashes and dots) as we go.  */
name|outp
operator|=
name|inp
operator|=
name|abs_buffer
expr_stmt|;
operator|*
name|outp
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
comment|/* copy first slash */
if|#
directive|if
name|defined
argument_list|(
name|apollo
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__INTERIX
argument_list|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|inp
index|[
literal|0
index|]
argument_list|)
condition|)
operator|*
name|outp
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
comment|/* copy second slash */
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|inp
index|[
literal|0
index|]
condition|)
break|break;
elseif|else
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|inp
index|[
literal|0
index|]
argument_list|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|outp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|inp
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inp
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|outp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inp
index|[
literal|1
index|]
condition|)
break|break;
elseif|else
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|inp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|inp
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|inp
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|inp
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|IS_DIR_SEPARATOR
argument_list|(
name|inp
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|inp
operator|+=
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
name|inp
index|[
literal|2
index|]
argument_list|)
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
name|outp
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|outp
operator|>=
name|abs_buffer
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|outp
argument_list|)
condition|)
name|outp
operator|--
expr_stmt|;
if|if
condition|(
name|outp
operator|<
name|abs_buffer
condition|)
block|{
comment|/* Catch cases like /.. where we try to backup to a 		     point above the absolute root of the logical file 		     system.  */
name|notice
argument_list|(
literal|"%s: invalid file name: %s\n"
argument_list|,
name|pname
argument_list|,
name|rel_filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
operator|*
operator|++
name|outp
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|outp
operator|++
operator|=
operator|*
name|inp
operator|++
expr_stmt|;
block|}
comment|/* On exit, make sure that there is a trailing null, and make sure that      the last character of the returned string is *not* a slash.  */
operator|*
name|outp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|outp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
operator|--
name|outp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make a copy (in the heap) of the stuff left in the absolutization      buffer and return a pointer to the copy.  */
return|return
name|savestring
argument_list|(
name|abs_buffer
argument_list|,
name|outp
operator|-
name|abs_buffer
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a filename (and possibly a directory name from which the filename    is relative) return a string which is the shortest possible    equivalent for the corresponding full (absolutized) filename.  The    shortest possible equivalent may be constructed by converting the    absolutized filename to be a relative filename (i.e. relative to    the actual current working directory).  However if a relative filename    is longer, then the full absolute filename is returned.     KNOWN BUG:     Note that "simple-minded" conversion of any given type of filename (either    relative or absolute) may not result in a valid equivalent filename if any    subpart of the original filename is actually a symbolic link.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|shortpath
parameter_list|(
specifier|const
name|char
modifier|*
name|cwd
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|rel_buffer
decl_stmt|;
name|char
modifier|*
name|rel_buf_p
decl_stmt|;
name|char
modifier|*
name|cwd_p
init|=
name|cwd_buffer
decl_stmt|;
name|char
modifier|*
name|path_p
decl_stmt|;
name|int
name|unmatched_slash_count
init|=
literal|0
decl_stmt|;
name|size_t
name|filename_len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|path_p
operator|=
name|abspath
argument_list|(
name|cwd
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|rel_buf_p
operator|=
name|rel_buffer
operator|=
name|xmalloc
argument_list|(
name|filename_len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cwd_p
operator|&&
name|IS_SAME_PATH_CHAR
argument_list|(
operator|*
name|cwd_p
argument_list|,
operator|*
name|path_p
argument_list|)
condition|)
block|{
name|cwd_p
operator|++
expr_stmt|;
name|path_p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|cwd_p
operator|&&
operator|(
operator|!
operator|*
name|path_p
operator|||
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|path_p
argument_list|)
operator|)
condition|)
block|{
comment|/* whole pwd matched */
if|if
condition|(
operator|!
operator|*
name|path_p
condition|)
comment|/* input *is* the current path! */
return|return
literal|"."
return|;
else|else
return|return
operator|++
name|path_p
return|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|path_p
condition|)
block|{
operator|--
name|cwd_p
expr_stmt|;
operator|--
name|path_p
expr_stmt|;
while|while
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|cwd_p
argument_list|)
condition|)
comment|/* backup to last slash */
block|{
operator|--
name|cwd_p
expr_stmt|;
operator|--
name|path_p
expr_stmt|;
block|}
name|cwd_p
operator|++
expr_stmt|;
name|path_p
operator|++
expr_stmt|;
name|unmatched_slash_count
operator|++
expr_stmt|;
block|}
comment|/* Find out how many directory levels in cwd were *not* matched.  */
while|while
condition|(
operator|*
name|cwd_p
operator|++
condition|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|cwd_p
operator|-
literal|1
operator|)
argument_list|)
condition|)
name|unmatched_slash_count
operator|++
expr_stmt|;
comment|/* Now we know how long the "short name" will be. 	 Reject it if longer than the input.  */
if|if
condition|(
name|unmatched_slash_count
operator|*
literal|3
operator|+
name|strlen
argument_list|(
name|path_p
argument_list|)
operator|>=
name|filename_len
condition|)
return|return
name|filename
return|;
comment|/* For each of them, put a `../' at the beginning of the short name.  */
while|while
condition|(
name|unmatched_slash_count
operator|--
condition|)
block|{
comment|/* Give up if the result gets to be longer 	     than the absolute path name.  */
if|if
condition|(
name|rel_buffer
operator|+
name|filename_len
operator|<=
name|rel_buf_p
operator|+
literal|3
condition|)
return|return
name|filename
return|;
operator|*
name|rel_buf_p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|rel_buf_p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|rel_buf_p
operator|++
operator|=
name|DIR_SEPARATOR
expr_stmt|;
block|}
comment|/* Then tack on the unmatched part of the desired file's name.  */
do|do
block|{
if|if
condition|(
name|rel_buffer
operator|+
name|filename_len
operator|<=
name|rel_buf_p
condition|)
return|return
name|filename
return|;
block|}
do|while
condition|(
operator|(
operator|*
name|rel_buf_p
operator|++
operator|=
operator|*
name|path_p
operator|++
operator|)
condition|)
do|;
operator|--
name|rel_buf_p
expr_stmt|;
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|rel_buf_p
operator|-
literal|1
operator|)
argument_list|)
condition|)
operator|*
operator|--
name|rel_buf_p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rel_buffer
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lookup the given filename in the hash table for filenames.  If it is a    new one, then the hash table info pointer will be null.  In this case,    we create a new file_info record to go with the filename, and we initialize    that record with some reasonable values.  */
end_comment

begin_comment
comment|/* FILENAME was const, but that causes a warning on AIX when calling stat.    That is probably a bug in AIX, but might as well avoid the warning.  */
end_comment

begin_function
specifier|static
name|file_info
modifier|*
name|find_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|do_not_stat
parameter_list|)
block|{
name|hash_table_entry
modifier|*
name|hash_entry_p
decl_stmt|;
name|hash_entry_p
operator|=
name|lookup
argument_list|(
name|filename_primary
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_entry_p
operator|->
name|fip
condition|)
return|return
name|hash_entry_p
operator|->
name|fip
return|;
else|else
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|file_info
modifier|*
name|file_p
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|file_info
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we cannot get status on any given source file, give a warning 	 and then just set its time of last modification to infinity.  */
if|if
condition|(
name|do_not_stat
condition|)
name|stat_buf
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: %s: can't get status: %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|stat_buf
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|hash_entry_p
operator|->
name|fip
operator|=
name|file_p
expr_stmt|;
name|file_p
operator|->
name|hash_entry
operator|=
name|hash_entry_p
expr_stmt|;
name|file_p
operator|->
name|defs_decs
operator|=
name|NULL
expr_stmt|;
name|file_p
operator|->
name|mtime
operator|=
name|stat_buf
operator|.
name|st_mtime
expr_stmt|;
return|return
name|file_p
return|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a fatal error because some part of the aux_info file is    messed up.  */
end_comment

begin_function
specifier|static
name|void
name|aux_info_corrupted
parameter_list|(
name|void
parameter_list|)
block|{
name|notice
argument_list|(
literal|"\n%s: fatal error: aux info file corrupted at line %d\n"
argument_list|,
name|pname
argument_list|,
name|current_aux_info_lineno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ??? This comment is vague.  Say what the condition is for.  */
end_comment

begin_comment
comment|/* Check to see that a condition is true.  This is kind of like an assert.  */
end_comment

begin_function
specifier|static
name|void
name|check_aux_info
parameter_list|(
name|int
name|cond
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cond
condition|)
name|aux_info_corrupted
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to the closing right parenthesis for a particular formals    list (in an aux_info file) find the corresponding left parenthesis and    return a pointer to it.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_corresponding_lparen
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|paren_depth
decl_stmt|;
for|for
control|(
name|paren_depth
operator|=
literal|1
operator|,
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|paren_depth
condition|;
name|q
operator|--
control|)
block|{
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|')'
case|:
name|paren_depth
operator|++
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|paren_depth
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|++
name|q
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a line from  an aux info file, and a time at which the aux info    file it came from was created, check to see if the item described in    the line comes from a file which has been modified since the aux info    file was created.  If so, return nonzero, else return zero.  */
end_comment

begin_function
specifier|static
name|int
name|referenced_file_is_newer
parameter_list|(
specifier|const
name|char
modifier|*
name|l
parameter_list|,
name|time_t
name|aux_info_mtime
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|file_info
modifier|*
name|fi_p
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|check_aux_info
argument_list|(
name|l
index|[
literal|0
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
name|l
index|[
literal|1
index|]
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
name|l
index|[
literal|2
index|]
operator|==
literal|' '
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename_start
init|=
name|p
operator|=
name|l
operator|+
literal|3
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|||
operator|(
operator|*
name|p
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|p
operator|++
expr_stmt|;
name|filename
operator|=
name|alloca
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|filename_start
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|filename
argument_list|,
name|filename_start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|filename_start
argument_list|)
argument_list|)
expr_stmt|;
name|filename
index|[
name|p
operator|-
name|filename_start
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Call find_file to find the file_info record associated with the file      which contained this particular def or dec item.  Note that this call      may cause a new file_info record to be created if this is the first time      that we have ever known about this particular file.  */
name|fi_p
operator|=
name|find_file
argument_list|(
name|abspath
argument_list|(
name|invocation_filename
argument_list|,
name|filename
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|fi_p
operator|->
name|mtime
operator|>
name|aux_info_mtime
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a line of info from the aux_info file, create a new    def_dec_info record to remember all of the important information about    a function definition or declaration.     Link this record onto the list of such records for the particular file in    which it occurred in proper (descending) line number order (for now).     If there is an identical record already on the list for the file, throw    this one away.  Doing so takes care of the (useless and troublesome)    duplicates which are bound to crop up due to multiple inclusions of any    given individual header file.     Finally, link the new def_dec record onto the list of such records    pertaining to this particular function name.  */
end_comment

begin_function
specifier|static
name|void
name|save_def_or_dec
parameter_list|(
specifier|const
name|char
modifier|*
name|l
parameter_list|,
name|int
name|is_syscalls
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|semicolon_p
decl_stmt|;
name|def_dec_info
modifier|*
name|def_dec_p
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|def_dec_info
argument_list|)
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
name|def_dec_p
operator|->
name|written
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
comment|/* Start processing the line by picking off 5 pieces of information from      the left hand end of the line.  These are filename, line number,      new/old/implicit flag (new = ANSI prototype format), definition or      declaration flag, and extern/static flag).  */
name|check_aux_info
argument_list|(
name|l
index|[
literal|0
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
name|l
index|[
literal|1
index|]
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
name|l
index|[
literal|2
index|]
operator|==
literal|' '
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename_start
init|=
name|p
operator|=
name|l
operator|+
literal|3
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|||
operator|(
operator|*
name|p
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|p
operator|++
expr_stmt|;
name|filename
operator|=
name|alloca
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|filename_start
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|filename
argument_list|,
name|filename_start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|filename_start
argument_list|)
argument_list|)
expr_stmt|;
name|filename
index|[
name|p
operator|-
name|filename_start
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Call find_file to find the file_info record associated with the file        which contained this particular def or dec item.  Note that this call        may cause a new file_info record to be created if this is the first time        that we have ever known about this particular file.         Note that we started out by forcing all of the base source file names        (i.e. the names of the aux_info files with the .X stripped off) into the        filenames hash table, and we simultaneously setup file_info records for        all of these base file names (even if they may be useless later).        The file_info records for all of these "base" file names (properly)        act as file_info records for the "original" (i.e. un-included) files        which were submitted to gcc for compilation (when the -aux-info        option was used).  */
name|def_dec_p
operator|->
name|file
operator|=
name|find_file
argument_list|(
name|abspath
argument_list|(
name|invocation_filename
argument_list|,
name|filename
argument_list|)
argument_list|,
name|is_syscalls
argument_list|)
expr_stmt|;
block|}
block|{
specifier|const
name|char
modifier|*
name|line_number_start
init|=
operator|++
name|p
decl_stmt|;
name|char
name|line_number
index|[
literal|10
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|||
operator|(
operator|*
name|p
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|p
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|line_number
argument_list|,
name|line_number_start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|line_number_start
argument_list|)
argument_list|)
expr_stmt|;
name|line_number
index|[
name|p
operator|-
name|line_number_start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|def_dec_p
operator|->
name|line
operator|=
name|atoi
argument_list|(
name|line_number
argument_list|)
expr_stmt|;
block|}
comment|/* Check that this record describes a new-style, old-style, or implicit      definition or declaration.  */
name|p
operator|++
expr_stmt|;
comment|/* Skip over the `:'.  */
name|check_aux_info
argument_list|(
operator|(
operator|*
name|p
operator|==
literal|'N'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'O'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'I'
operator|)
argument_list|)
expr_stmt|;
comment|/* Is this a new style (ANSI prototyped) definition or declaration? */
name|def_dec_p
operator|->
name|prototyped
operator|=
operator|(
operator|*
name|p
operator|==
literal|'N'
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
comment|/* Is this an implicit declaration? */
name|def_dec_p
operator|->
name|is_implicit
operator|=
operator|(
operator|*
name|p
operator|==
literal|'I'
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|p
operator|++
expr_stmt|;
name|check_aux_info
argument_list|(
operator|(
operator|*
name|p
operator|==
literal|'C'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'F'
operator|)
argument_list|)
expr_stmt|;
comment|/* Is this item a function definition (F) or a declaration (C).  Note that      we treat item taken from the syscalls file as though they were function      definitions regardless of what the stuff in the file says.  */
name|def_dec_p
operator|->
name|is_func_def
operator|=
operator|(
operator|(
operator|*
name|p
operator|++
operator|==
literal|'F'
operator|)
operator|||
name|is_syscalls
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
name|def_dec_p
operator|->
name|definition
operator|=
literal|0
expr_stmt|;
comment|/* Fill this in later if protoizing.  */
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|check_aux_info
argument_list|(
operator|*
name|p
operator|++
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
name|p
operator|++
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
name|p
operator|++
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
name|p
operator|++
operator|==
literal|' '
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNPROTOIZE
name|check_aux_info
argument_list|(
operator|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"static"
argument_list|,
literal|6
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"extern"
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"static"
argument_list|,
literal|6
argument_list|)
condition|)
name|def_dec_p
operator|->
name|is_static
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"extern"
argument_list|,
literal|6
argument_list|)
condition|)
name|def_dec_p
operator|->
name|is_static
operator|=
literal|0
expr_stmt|;
else|else
name|check_aux_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Didn't find either `extern' or `static'.  */
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
block|{
specifier|const
name|char
modifier|*
name|ansi_start
init|=
name|p
decl_stmt|;
name|p
operator|+=
literal|6
expr_stmt|;
comment|/* Pass over the "static" or "extern".  */
comment|/* We are now past the initial stuff.  Search forward from here to find        the terminating semicolon that should immediately follow the entire        ANSI format function declaration.  */
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|';'
condition|)
continue|continue;
name|semicolon_p
operator|=
name|p
expr_stmt|;
comment|/* Make a copy of the ansi declaration part of the line from the aux_info        file.  */
name|def_dec_p
operator|->
name|ansi_decl
operator|=
name|dupnstr
argument_list|(
name|ansi_start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|semicolon_p
operator|+
literal|1
operator|)
operator|-
name|ansi_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Backup and point at the final right paren of the final argument list.  */
name|p
operator|--
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
name|def_dec_p
operator|->
name|f_list_chain
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
while|while
condition|(
name|p
operator|!=
name|ansi_start
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
block|{
name|free_def_dec
argument_list|(
name|def_dec_p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Now isolate a whole set of formal argument lists, one-by-one.  Normally,      there will only be one list to isolate, but there could be more.  */
name|def_dec_p
operator|->
name|f_list_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|left_paren_p
init|=
name|find_corresponding_lparen
argument_list|(
name|p
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
block|{
name|f_list_chain_item
modifier|*
name|cip
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|f_list_chain_item
argument_list|)
argument_list|)
decl_stmt|;
name|cip
operator|->
name|formals_list
operator|=
name|dupnstr
argument_list|(
name|left_paren_p
operator|+
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
operator|(
name|left_paren_p
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the new chain item at the head of the current list.  */
name|cip
operator|->
name|chain_next
operator|=
name|def_dec_p
operator|->
name|f_list_chain
expr_stmt|;
name|def_dec_p
operator|->
name|f_list_chain
operator|=
name|cip
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|def_dec_p
operator|->
name|f_list_count
operator|++
expr_stmt|;
name|p
operator|=
name|left_paren_p
operator|-
literal|2
expr_stmt|;
comment|/* p must now point either to another right paren, or to the last 	 character of the name of the function that was declared/defined. 	 If p points to another right paren, then this indicates that we 	 are dealing with multiple formals lists.  In that case, there 	 really should be another right paren preceding this right paren.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
break|break;
else|else
name|check_aux_info
argument_list|(
operator|*
operator|--
name|p
operator|==
literal|')'
argument_list|)
expr_stmt|;
block|}
block|{
specifier|const
name|char
modifier|*
name|past_fn
init|=
name|p
operator|+
literal|1
decl_stmt|;
name|check_aux_info
argument_list|(
operator|*
name|past_fn
operator|==
literal|' '
argument_list|)
expr_stmt|;
comment|/* Scan leftwards over the identifier that names the function.  */
while|while
condition|(
name|is_id_char
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* p now points to the leftmost character of the function name.  */
block|{
name|char
modifier|*
name|fn_string
init|=
name|alloca
argument_list|(
name|past_fn
operator|-
name|p
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|fn_string
argument_list|,
name|p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|past_fn
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|fn_string
index|[
name|past_fn
operator|-
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
name|def_dec_p
operator|->
name|hash_entry
operator|=
name|lookup
argument_list|(
name|function_name_primary
argument_list|,
name|fn_string
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Look at all of the defs and decs for this function name that we have      collected so far.  If there is already one which is at the same      line number in the same file, then we can discard this new def_dec_info      record.       As an extra assurance that any such pair of (nominally) identical      function declarations are in fact identical, we also compare the      ansi_decl parts of the lines from the aux_info files just to be on      the safe side.       This comparison will fail if (for instance) the user was playing      messy games with the preprocessor which ultimately causes one      function declaration in one header file to look differently when      that file is included by two (or more) other files.  */
block|{
specifier|const
name|def_dec_info
modifier|*
name|other
decl_stmt|;
for|for
control|(
name|other
operator|=
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|ddip
init|;
name|other
condition|;
name|other
operator|=
name|other
operator|->
name|next_for_func
control|)
block|{
if|if
condition|(
name|def_dec_p
operator|->
name|line
operator|==
name|other
operator|->
name|line
operator|&&
name|def_dec_p
operator|->
name|file
operator|==
name|other
operator|->
name|file
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|def_dec_p
operator|->
name|ansi_decl
argument_list|,
name|other
operator|->
name|ansi_decl
argument_list|)
condition|)
block|{
name|notice
argument_list|(
literal|"%s:%d: declaration of function '%s' takes different forms\n"
argument_list|,
name|def_dec_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|,
name|def_dec_p
operator|->
name|line
argument_list|,
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|free_def_dec
argument_list|(
name|def_dec_p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|UNPROTOIZE
comment|/* If we are doing unprotoizing, we must now setup the pointers that will      point to the K&R name list and to the K&R argument declarations list.       Note that if this is only a function declaration, then we should not      expect to find any K&R style formals list following the ANSI-style      formals list.  This is because GCC knows that such information is      useless in the case of function declarations (function definitions      are a different story however).       Since we are unprotoizing, we don't need any such lists anyway.      All we plan to do is to delete all characters between ()'s in any      case.  */
name|def_dec_p
operator|->
name|formal_names
operator|=
name|NULL
expr_stmt|;
name|def_dec_p
operator|->
name|formal_decls
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|def_dec_p
operator|->
name|is_func_def
condition|)
block|{
name|p
operator|=
name|semicolon_p
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
operator|++
name|p
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
operator|++
name|p
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
operator|++
name|p
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
operator|++
name|p
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
operator|++
name|p
operator|==
literal|'('
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|kr_names_start
init|=
operator|++
name|p
decl_stmt|;
comment|/* Point just inside '('.  */
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|')'
condition|)
continue|continue;
name|p
operator|--
expr_stmt|;
comment|/* point to closing right paren */
comment|/* Make a copy of the K&R parameter names list.  */
name|def_dec_p
operator|->
name|formal_names
operator|=
name|dupnstr
argument_list|(
name|kr_names_start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|kr_names_start
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|check_aux_info
argument_list|(
operator|*
operator|++
name|p
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* p now points to the first character of the K&R style declarations 	 list (if there is one) or to the star-slash combination that ends 	 the comment in which such lists get embedded.  */
comment|/* Make a copy of the K&R formal decls list and set the def_dec record 	 to point to it.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
comment|/* Are there no K&R declarations? */
block|{
name|check_aux_info
argument_list|(
operator|*
operator|++
name|p
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|def_dec_p
operator|->
name|formal_decls
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|kr_decls_start
init|=
name|p
decl_stmt|;
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|--
expr_stmt|;
name|check_aux_info
argument_list|(
operator|*
name|p
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|def_dec_p
operator|->
name|formal_decls
operator|=
name|dupnstr
argument_list|(
name|kr_decls_start
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|kr_decls_start
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a special case.  If we have a function definition marked as 	 being in "old" style, and if its formal names list is empty, then 	 it may actually have the string "void" in its real formals list 	 in the original source code.  Just to make sure, we will get setup 	 to convert such things anyway.  	 This kludge only needs to be here because of an insurmountable 	 problem with generating .X files.  */
if|if
condition|(
operator|!
name|def_dec_p
operator|->
name|prototyped
operator|&&
operator|!
operator|*
name|def_dec_p
operator|->
name|formal_names
condition|)
name|def_dec_p
operator|->
name|prototyped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Since we are unprotoizing, if this item is already in old (K&R) style,      we can just ignore it.  If that is true, throw away the itme now.  */
if|if
condition|(
operator|!
name|def_dec_p
operator|->
name|prototyped
condition|)
block|{
name|free_def_dec
argument_list|(
name|def_dec_p
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* defined (UNPROTOIZE) */
comment|/* Add this record to the head of the list of records pertaining to this      particular function name.  */
name|def_dec_p
operator|->
name|next_for_func
operator|=
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|ddip
expr_stmt|;
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|ddip
operator|=
name|def_dec_p
expr_stmt|;
comment|/* Add this new def_dec_info record to the sorted list of def_dec_info      records for this file.  Note that we don't have to worry about duplicates      (caused by multiple inclusions of header files) here because we have      already eliminated duplicates above.  */
if|if
condition|(
operator|!
name|def_dec_p
operator|->
name|file
operator|->
name|defs_decs
condition|)
block|{
name|def_dec_p
operator|->
name|file
operator|->
name|defs_decs
operator|=
name|def_dec_p
expr_stmt|;
name|def_dec_p
operator|->
name|next_in_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|line
init|=
name|def_dec_p
operator|->
name|line
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|curr
init|=
name|def_dec_p
operator|->
name|file
operator|->
name|defs_decs
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|next
init|=
name|curr
operator|->
name|next_in_file
decl_stmt|;
while|while
condition|(
name|next
operator|&&
operator|(
name|line
operator|<
name|curr
operator|->
name|line
operator|)
condition|)
block|{
name|prev
operator|=
name|curr
expr_stmt|;
name|curr
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next_in_file
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>=
name|curr
operator|->
name|line
condition|)
block|{
name|def_dec_p
operator|->
name|next_in_file
operator|=
name|curr
expr_stmt|;
if|if
condition|(
name|prev
condition|)
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|prev
operator|)
operator|->
name|next_in_file
operator|=
name|def_dec_p
expr_stmt|;
else|else
name|def_dec_p
operator|->
name|file
operator|->
name|defs_decs
operator|=
name|def_dec_p
expr_stmt|;
block|}
else|else
comment|/* assert (next == NULL); */
block|{
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|curr
operator|)
operator|->
name|next_in_file
operator|=
name|def_dec_p
expr_stmt|;
comment|/* assert (next == NULL); */
name|def_dec_p
operator|->
name|next_in_file
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the vector COMPILE_PARAMS which is the argument list for running GCC.    Also set input_file_name_index and aux_info_file_name_index    to the indices of the slots where the file names should go.  */
end_comment

begin_comment
comment|/* We initialize the vector by  removing -g, -O, -S, -c, and -o options,    and adding '-aux-info AUXFILE -S  -o /dev/null INFILE' at the end.  */
end_comment

begin_function
specifier|static
name|void
name|munge_compile_params
parameter_list|(
specifier|const
name|char
modifier|*
name|params_list
parameter_list|)
block|{
comment|/* Build up the contents in a temporary vector      that is so big that to has to be big enough.  */
specifier|const
name|char
modifier|*
modifier|*
name|temp_params
init|=
name|alloca
argument_list|(
operator|(
name|strlen
argument_list|(
name|params_list
argument_list|)
operator|+
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|param_count
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|param
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
name|compiler_file_name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|params_list
argument_list|)
condition|)
name|params_list
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|params_list
condition|)
break|break;
name|param
operator|=
name|params_list
expr_stmt|;
while|while
condition|(
operator|*
name|params_list
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|params_list
argument_list|)
condition|)
name|params_list
operator|++
expr_stmt|;
if|if
condition|(
name|param
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
name|dupnstr
argument_list|(
name|param
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|params_list
operator|-
name|param
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|param
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'g'
case|:
case|case
literal|'O'
case|:
case|case
literal|'S'
case|:
case|case
literal|'c'
case|:
break|break;
comment|/* Don't copy these.  */
case|case
literal|'o'
case|:
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|params_list
argument_list|)
condition|)
name|params_list
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|params_list
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|params_list
argument_list|)
condition|)
name|params_list
operator|++
expr_stmt|;
break|break;
default|default:
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
name|dupnstr
argument_list|(
name|param
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|params_list
operator|-
name|param
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|params_list
condition|)
break|break;
block|}
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
literal|"-aux-info"
expr_stmt|;
comment|/* Leave room for the aux-info file name argument.  */
name|aux_info_file_name_index
operator|=
name|param_count
expr_stmt|;
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
literal|"-S"
expr_stmt|;
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
literal|"-o"
expr_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|HOST_BIT_BUCKET
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|)
operator|&&
operator|(
name|access
argument_list|(
name|HOST_BIT_BUCKET
argument_list|,
name|W_OK
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
name|HOST_BIT_BUCKET
expr_stmt|;
else|else
comment|/* FIXME: This is hardly likely to be right, if HOST_BIT_BUCKET is not        writable.  But until this is rejigged to use make_temp_file(), this        is the best we can do.  */
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
literal|"/dev/null"
expr_stmt|;
comment|/* Leave room for the input file name argument.  */
name|input_file_name_index
operator|=
name|param_count
expr_stmt|;
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Terminate the list.  */
name|temp_params
index|[
name|param_count
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Make a copy of the compile_params in heap space.  */
name|compile_params
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|param_count
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|compile_params
argument_list|,
name|temp_params
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|param_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a recompilation for the express purpose of generating a new aux_info    file to go with a specific base source file.     The result is a boolean indicating success.  */
end_comment

begin_function
specifier|static
name|int
name|gen_aux_info_file
parameter_list|(
specifier|const
name|char
modifier|*
name|base_filename
parameter_list|)
block|{
if|if
condition|(
operator|!
name|input_file_name_index
condition|)
name|munge_compile_params
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Store the full source file name in the argument vector.  */
name|compile_params
index|[
name|input_file_name_index
index|]
operator|=
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|base_filename
argument_list|)
expr_stmt|;
comment|/* Add .X to source file name to get aux-info file name.  */
name|compile_params
index|[
name|aux_info_file_name_index
index|]
operator|=
name|concat
argument_list|(
name|compile_params
index|[
name|input_file_name_index
index|]
argument_list|,
name|aux_info_suffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"%s: compiling '%s'\n"
argument_list|,
name|pname
argument_list|,
name|compile_params
index|[
name|input_file_name_index
index|]
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|errmsg_fmt
decl_stmt|,
modifier|*
name|errmsg_arg
decl_stmt|;
name|int
name|wait_status
decl_stmt|,
name|pid
decl_stmt|;
name|pid
operator|=
name|pexecute
argument_list|(
name|compile_params
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|compile_params
argument_list|,
name|pname
argument_list|,
name|NULL
argument_list|,
operator|&
name|errmsg_fmt
argument_list|,
operator|&
name|errmsg_arg
argument_list|,
name|PEXECUTE_FIRST
operator||
name|PEXECUTE_LAST
operator||
name|PEXECUTE_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|errmsg_fmt
argument_list|,
name|errmsg_arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pid
operator|=
name|pwait
argument_list|(
name|pid
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|notice
argument_list|(
literal|"%s: wait: %s\n"
argument_list|,
name|pname
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
name|notice
argument_list|(
literal|"%s: subprocess got fatal signal %d\n"
argument_list|,
name|pname
argument_list|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|notice
argument_list|(
literal|"%s: %s exited with status %d\n"
argument_list|,
name|pname
argument_list|,
name|compile_params
index|[
literal|0
index|]
argument_list|,
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in all of the information contained in a single aux_info file.    Save all of the important stuff for later.  */
end_comment

begin_function
specifier|static
name|void
name|process_aux_info_file
parameter_list|(
specifier|const
name|char
modifier|*
name|base_source_filename
parameter_list|,
name|int
name|keep_it
parameter_list|,
name|int
name|is_syscalls
parameter_list|)
block|{
name|size_t
name|base_len
init|=
name|strlen
argument_list|(
name|base_source_filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|aux_info_filename
init|=
name|alloca
argument_list|(
name|base_len
operator|+
name|strlen
argument_list|(
name|aux_info_suffix
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|aux_info_base
decl_stmt|;
name|char
modifier|*
name|aux_info_limit
decl_stmt|;
name|char
modifier|*
name|aux_info_relocated_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|aux_info_second_line
decl_stmt|;
name|time_t
name|aux_info_mtime
decl_stmt|;
name|size_t
name|aux_info_size
decl_stmt|;
name|int
name|must_create
decl_stmt|;
comment|/* Construct the aux_info filename from the base source filename.  */
name|strcpy
argument_list|(
name|aux_info_filename
argument_list|,
name|base_source_filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|aux_info_filename
argument_list|,
name|aux_info_suffix
argument_list|)
expr_stmt|;
comment|/* Check that the aux_info file exists and is readable.  If it does not      exist, try to create it (once only).  */
comment|/* If file doesn't exist, set must_create.      Likewise if it exists and we can read it but it is obsolete.      Otherwise, report an error.  */
name|must_create
operator|=
literal|0
expr_stmt|;
comment|/* Come here with must_create set to 1 if file is out of date.  */
name|start_over
label|:
empty_stmt|;
if|if
condition|(
name|access
argument_list|(
name|aux_info_filename
argument_list|,
name|R_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
name|is_syscalls
condition|)
block|{
name|notice
argument_list|(
literal|"%s: warning: missing SYSCALLS file '%s'\n"
argument_list|,
name|pname
argument_list|,
name|aux_info_filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|must_create
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't read aux info file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
literal|0
comment|/* There is code farther down to take care of this.  */
block|else     {       struct stat s1, s2;       stat (aux_info_file_name,&s1);       stat (base_source_file_name,&s2);       if (s2.st_mtime> s1.st_mtime) 	must_create = 1;     }
endif|#
directive|endif
comment|/* 0 */
comment|/* If we need a .X file, create it, and verify we can read it.  */
if|if
condition|(
name|must_create
condition|)
block|{
if|if
condition|(
operator|!
name|gen_aux_info_file
argument_list|(
name|base_source_filename
argument_list|)
condition|)
block|{
name|errors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|access
argument_list|(
name|aux_info_filename
argument_list|,
name|R_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't read aux info file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
comment|/* Get some status information about this aux_info file.  */
if|if
condition|(
name|stat
argument_list|(
name|aux_info_filename
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't get status of aux info file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Check on whether or not this aux_info file is zero length.  If it is,        then just ignore it and return.  */
if|if
condition|(
operator|(
name|aux_info_size
operator|=
name|stat_buf
operator|.
name|st_size
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Get the date/time of last modification for this aux_info file and        remember it.  We will have to check that any source files that it        contains information about are at least this old or older.  */
name|aux_info_mtime
operator|=
name|stat_buf
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
operator|!
name|is_syscalls
condition|)
block|{
comment|/* Compare mod time with the .c file; update .X file if obsolete. 	   The code later on can fail to check the .c file 	   if it did not directly define any functions.  */
if|if
condition|(
name|stat
argument_list|(
name|base_source_filename
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't get status of aux info file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|base_source_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat_buf
operator|.
name|st_mtime
operator|>
name|aux_info_mtime
condition|)
block|{
name|must_create
operator|=
literal|1
expr_stmt|;
goto|goto
name|start_over
goto|;
block|}
block|}
block|}
block|{
name|int
name|aux_info_file
decl_stmt|;
name|int
name|fd_flags
decl_stmt|;
comment|/* Open the aux_info file.  */
name|fd_flags
operator|=
name|O_RDONLY
expr_stmt|;
ifdef|#
directive|ifdef
name|O_BINARY
comment|/* Use binary mode to avoid having to deal with different EOL characters.  */
name|fd_flags
operator||=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|aux_info_file
operator|=
name|open
argument_list|(
name|aux_info_filename
argument_list|,
name|fd_flags
argument_list|,
literal|0444
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't open aux info file '%s' for reading: %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate space to hold the aux_info file in memory.  */
name|aux_info_base
operator|=
name|xmalloc
argument_list|(
name|aux_info_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aux_info_limit
operator|=
name|aux_info_base
operator|+
name|aux_info_size
expr_stmt|;
operator|*
name|aux_info_limit
operator|=
literal|'\0'
expr_stmt|;
comment|/* Read the aux_info file into memory.  */
if|if
condition|(
name|safe_read
argument_list|(
name|aux_info_file
argument_list|,
name|aux_info_base
argument_list|,
name|aux_info_size
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|aux_info_size
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: error reading aux info file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aux_info_base
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Close the aux info file.  */
if|if
condition|(
name|close
argument_list|(
name|aux_info_file
argument_list|)
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: error closing aux info file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aux_info_base
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Delete the aux_info file (unless requested not to).  If the deletion      fails for some reason, don't even worry about it.  */
if|if
condition|(
name|must_create
operator|&&
operator|!
name|keep_it
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|aux_info_filename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't delete aux info file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save a pointer into the first line of the aux_info file which      contains the filename of the directory from which the compiler      was invoked when the associated source file was compiled.      This information is used later to help create complete      filenames out of the (potentially) relative filenames in      the aux_info file.  */
block|{
name|char
modifier|*
name|p
init|=
name|aux_info_base
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|||
operator|(
operator|*
name|p
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
name|invocation_filename
operator|=
name|p
expr_stmt|;
comment|/* Save a pointer to first byte of path.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|DIR_SEPARATOR
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
continue|continue;
name|aux_info_second_line
operator|=
name|p
expr_stmt|;
name|aux_info_relocated_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|invocation_filename
argument_list|)
condition|)
block|{
comment|/* INVOCATION_FILENAME is relative; 	   append it to BASE_SOURCE_FILENAME's dir.  */
name|char
modifier|*
name|dir_end
decl_stmt|;
name|aux_info_relocated_name
operator|=
name|xmalloc
argument_list|(
name|base_len
operator|+
operator|(
name|p
operator|-
name|invocation_filename
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|aux_info_relocated_name
argument_list|,
name|base_source_filename
argument_list|)
expr_stmt|;
name|dir_end
operator|=
name|strrchr
argument_list|(
name|aux_info_relocated_name
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|dir_end
condition|?
name|dir_end
else|:
name|aux_info_relocated_name
argument_list|,
name|DIR_SEPARATOR_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|dir_end
operator|=
name|slash
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dir_end
condition|)
name|dir_end
operator|++
expr_stmt|;
else|else
name|dir_end
operator|=
name|aux_info_relocated_name
expr_stmt|;
name|strcpy
argument_list|(
name|dir_end
argument_list|,
name|invocation_filename
argument_list|)
expr_stmt|;
name|invocation_filename
operator|=
name|aux_info_relocated_name
expr_stmt|;
block|}
block|}
block|{
specifier|const
name|char
modifier|*
name|aux_info_p
decl_stmt|;
comment|/* Do a pre-pass on the lines in the aux_info file, making sure that all        of the source files referenced in there are at least as old as this        aux_info file itself.  If not, go back and regenerate the aux_info        file anew.  Don't do any of this for the syscalls file.  */
if|if
condition|(
operator|!
name|is_syscalls
condition|)
block|{
name|current_aux_info_lineno
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|aux_info_p
operator|=
name|aux_info_second_line
init|;
operator|*
name|aux_info_p
condition|;
control|)
block|{
if|if
condition|(
name|referenced_file_is_newer
argument_list|(
name|aux_info_p
argument_list|,
name|aux_info_mtime
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|aux_info_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aux_info_relocated_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_it
operator|&&
name|unlink
argument_list|(
name|aux_info_filename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't delete file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|aux_info_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|must_create
operator|=
literal|1
expr_stmt|;
goto|goto
name|start_over
goto|;
block|}
comment|/* Skip over the rest of this line to start of next line.  */
while|while
condition|(
operator|*
name|aux_info_p
operator|!=
literal|'\n'
condition|)
name|aux_info_p
operator|++
expr_stmt|;
name|aux_info_p
operator|++
expr_stmt|;
name|current_aux_info_lineno
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now do the real pass on the aux_info lines.  Save their information in        the in-core data base.  */
name|current_aux_info_lineno
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|aux_info_p
operator|=
name|aux_info_second_line
init|;
operator|*
name|aux_info_p
condition|;
control|)
block|{
name|char
modifier|*
name|unexpanded_line
init|=
name|unexpand_if_needed
argument_list|(
name|aux_info_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|unexpanded_line
condition|)
block|{
name|save_def_or_dec
argument_list|(
name|unexpanded_line
argument_list|,
name|is_syscalls
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unexpanded_line
argument_list|)
expr_stmt|;
block|}
else|else
name|save_def_or_dec
argument_list|(
name|aux_info_p
argument_list|,
name|is_syscalls
argument_list|)
expr_stmt|;
comment|/* Skip over the rest of this line and get to start of next line.  */
while|while
condition|(
operator|*
name|aux_info_p
operator|!=
literal|'\n'
condition|)
name|aux_info_p
operator|++
expr_stmt|;
name|aux_info_p
operator|++
expr_stmt|;
name|current_aux_info_lineno
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|aux_info_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aux_info_relocated_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|UNPROTOIZE
end_ifndef

begin_comment
comment|/* Check an individual filename for a .c suffix.  If the filename has this    suffix, rename the file such that its suffix is changed to .C.  This    function implements the -C option.  */
end_comment

begin_function
specifier|static
name|void
name|rename_c_file
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
name|hp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|hp
operator|->
name|symbol
decl_stmt|;
name|int
name|last_char_index
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
specifier|const
name|new_filename
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|cplus_suffix
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Note that we don't care here if the given file was converted or not.  It      is possible that the given file was *not* converted, simply because there      was nothing in it which actually required conversion.  Even in this case,      we want to do the renaming.  Note that we only rename files with the .c      suffix (except for the syscalls file, which is left alone).  */
if|if
condition|(
name|filename
index|[
name|last_char_index
index|]
operator|!=
literal|'c'
operator|||
name|filename
index|[
name|last_char_index
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|IS_SAME_PATH
argument_list|(
name|syscalls_absolute_filename
argument_list|,
name|filename
argument_list|)
condition|)
return|return;
name|strcpy
argument_list|(
name|new_filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|new_filename
index|[
name|last_char_index
index|]
argument_list|,
name|cplus_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|filename
argument_list|,
name|new_filename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: warning: can't rename file '%s' to '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|filename
argument_list|)
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|new_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Take the list of definitions and declarations attached to a particular    file_info node and reverse the order of the list.  This should get the    list into an order such that the item with the lowest associated line    number is nearest the head of the list.  When these lists are originally    built, they are in the opposite order.  We want to traverse them in    normal line number order later (i.e. lowest to highest) so reverse the    order here.  */
end_comment

begin_function
specifier|static
name|void
name|reverse_def_dec_list
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
name|hp
parameter_list|)
block|{
name|file_info
modifier|*
name|file_p
init|=
name|hp
operator|->
name|fip
decl_stmt|;
name|def_dec_info
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|def_dec_info
modifier|*
name|current
init|=
operator|(
name|def_dec_info
operator|*
operator|)
name|file_p
operator|->
name|defs_decs
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return;
comment|/* no list to reverse */
name|prev
operator|=
name|current
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|current
operator|=
operator|(
name|def_dec_info
operator|*
operator|)
name|current
operator|->
name|next_in_file
operator|)
condition|)
return|return;
comment|/* can't reverse a single list element */
name|prev
operator|->
name|next_in_file
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|def_dec_info
modifier|*
name|next
init|=
operator|(
name|def_dec_info
operator|*
operator|)
name|current
operator|->
name|next_in_file
decl_stmt|;
name|current
operator|->
name|next_in_file
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|next
expr_stmt|;
block|}
name|file_p
operator|->
name|defs_decs
operator|=
name|prev
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|UNPROTOIZE
end_ifndef

begin_comment
comment|/* Find the (only?) extern definition for a particular function name, starting    from the head of the linked list of entries for the given name.  If we    cannot find an extern definition for the given function name, issue a    warning and scrounge around for the next best thing, i.e. an extern    function declaration with a prototype attached to it.  Note that we only    allow such substitutions for extern declarations and never for static    declarations.  That's because the only reason we allow them at all is    to let un-prototyped function declarations for system-supplied library    functions get their prototypes from our own extra SYSCALLS.c.X file which    contains all of the correct prototypes for system functions.  */
end_comment

begin_function
specifier|static
specifier|const
name|def_dec_info
modifier|*
name|find_extern_def
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
name|head
parameter_list|,
specifier|const
name|def_dec_info
modifier|*
name|user
parameter_list|)
block|{
specifier|const
name|def_dec_info
modifier|*
name|dd_p
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|extern_def_p
init|=
name|NULL
decl_stmt|;
name|int
name|conflict_noted
init|=
literal|0
decl_stmt|;
comment|/* Don't act too stupid here.  Somebody may try to convert an entire system      in one swell fwoop (rather than one program at a time, as should be done)      and in that case, we may find that there are multiple extern definitions      of a given function name in the entire set of source files that we are      converting.  If however one of these definitions resides in exactly the      same source file as the reference we are trying to satisfy then in that      case it would be stupid for us to fail to realize that this one definition      *must* be the precise one we are looking for.       To make sure that we don't miss an opportunity to make this "same file"      leap of faith, we do a prescan of the list of records relating to the      given function name, and we look (on this first scan) *only* for a      definition of the function which is in the same file as the reference      we are currently trying to satisfy.  */
for|for
control|(
name|dd_p
operator|=
name|head
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
name|dd_p
operator|->
name|is_func_def
operator|&&
operator|!
name|dd_p
operator|->
name|is_static
operator|&&
name|dd_p
operator|->
name|file
operator|==
name|user
operator|->
name|file
condition|)
return|return
name|dd_p
return|;
comment|/* Now, since we have not found a definition in the same file as the      reference, we scan the list again and consider all possibilities from      all files.  Here we may get conflicts with the things listed in the      SYSCALLS.c.X file, but if that happens it only means that the source      code being converted contains its own definition of a function which      could have been supplied by libc.a.  In such cases, we should avoid      issuing the normal warning, and defer to the definition given in the      user's own code.  */
for|for
control|(
name|dd_p
operator|=
name|head
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
name|dd_p
operator|->
name|is_func_def
operator|&&
operator|!
name|dd_p
operator|->
name|is_static
condition|)
block|{
if|if
condition|(
operator|!
name|extern_def_p
condition|)
comment|/* Previous definition? */
name|extern_def_p
operator|=
name|dd_p
expr_stmt|;
comment|/* Remember the first definition found.  */
else|else
block|{
comment|/* Ignore definition just found if it came from SYSCALLS.c.X.  */
if|if
condition|(
name|is_syscalls_file
argument_list|(
name|dd_p
operator|->
name|file
argument_list|)
condition|)
continue|continue;
comment|/* Quietly replace the definition previously found with the one 	       just found if the previous one was from SYSCALLS.c.X.  */
if|if
condition|(
name|is_syscalls_file
argument_list|(
name|extern_def_p
operator|->
name|file
argument_list|)
condition|)
block|{
name|extern_def_p
operator|=
name|dd_p
expr_stmt|;
continue|continue;
block|}
comment|/* If we get here, then there is a conflict between two function 	       declarations for the same function, both of which came from the 	       user's own code.  */
if|if
condition|(
operator|!
name|conflict_noted
condition|)
comment|/* first time we noticed? */
block|{
name|conflict_noted
operator|=
literal|1
expr_stmt|;
name|notice
argument_list|(
literal|"%s: conflicting extern definitions of '%s'\n"
argument_list|,
name|pname
argument_list|,
name|head
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
name|notice
argument_list|(
literal|"%s: declarations of '%s' will not be converted\n"
argument_list|,
name|pname
argument_list|,
name|head
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"%s: conflict list for '%s' follows:\n"
argument_list|,
name|pname
argument_list|,
name|head
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:     %s(%d): %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|extern_def_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|,
name|extern_def_p
operator|->
name|line
argument_list|,
name|extern_def_p
operator|->
name|ansi_decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:     %s(%d): %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|dd_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|,
name|dd_p
operator|->
name|line
argument_list|,
name|dd_p
operator|->
name|ansi_decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We want to err on the side of caution, so if we found multiple conflicting      definitions for the same function, treat this as being that same as if we      had found no definitions (i.e. return NULL).  */
if|if
condition|(
name|conflict_noted
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|extern_def_p
condition|)
block|{
comment|/* We have no definitions for this function so do the next best thing. 	 Search for an extern declaration already in prototype form.  */
for|for
control|(
name|dd_p
operator|=
name|head
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
operator|!
name|dd_p
operator|->
name|is_func_def
operator|&&
operator|!
name|dd_p
operator|->
name|is_static
operator|&&
name|dd_p
operator|->
name|prototyped
condition|)
block|{
name|extern_def_p
operator|=
name|dd_p
expr_stmt|;
comment|/* save a pointer to the definition */
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"%s: warning: using formals list from %s(%d) for function '%s'\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|dd_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|,
name|dd_p
operator|->
name|line
argument_list|,
name|dd_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Gripe about unprototyped function declarations that we found no 	 corresponding definition (or other source of prototype information) 	 for.  	 Gripe even if the unprototyped declaration we are worried about 	 exists in a file in one of the "system" include directories.  We 	 can gripe about these because we should have at least found a 	 corresponding (pseudo) definition in the SYSCALLS.c.X file.  If we 	 didn't, then that means that the SYSCALLS.c.X file is missing some 	 needed prototypes for this particular system.  That is worth telling 	 the user about!  */
if|if
condition|(
operator|!
name|extern_def_p
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|user
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
decl_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
if|if
condition|(
name|in_system_include_dir
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|/* Why copy this string into `needed' at all? 		   Why not just use user->ansi_decl without copying?  */
name|char
modifier|*
name|needed
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|user
operator|->
name|ansi_decl
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|needed
argument_list|,
name|user
operator|->
name|ansi_decl
argument_list|)
expr_stmt|;
name|p
operator|=
name|strstr
argument_list|(
name|needed
argument_list|,
name|user
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
operator|+
name|strlen
argument_list|(
name|user
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Avoid having ??? in the string.  */
operator|*
name|p
operator|++
operator|=
literal|'?'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'?'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'?'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|");"
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"%s: %d: '%s' used but missing from SYSCALLS\n"
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|)
argument_list|,
name|user
operator|->
name|line
argument_list|,
name|needed
operator|+
literal|7
argument_list|)
expr_stmt|;
comment|/* Don't print "extern " */
block|}
if|#
directive|if
literal|0
block|else 	      notice ("%s: %d: warning: no extern definition for '%s'\n", 		      shortpath (NULL, file), user->line, 		      user->hash_entry->symbol);
endif|#
directive|endif
block|}
block|}
return|return
name|extern_def_p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the (only?) static definition for a particular function name in a    given file.  Here we get the function-name and the file info indirectly    from the def_dec_info record pointer which is passed in.  */
end_comment

begin_function
specifier|static
specifier|const
name|def_dec_info
modifier|*
name|find_static_definition
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
name|user
parameter_list|)
block|{
specifier|const
name|def_dec_info
modifier|*
name|head
init|=
name|user
operator|->
name|hash_entry
operator|->
name|ddip
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|dd_p
decl_stmt|;
name|int
name|num_static_defs
init|=
literal|0
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|static_def_p
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|dd_p
operator|=
name|head
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
name|dd_p
operator|->
name|is_func_def
operator|&&
name|dd_p
operator|->
name|is_static
operator|&&
operator|(
name|dd_p
operator|->
name|file
operator|==
name|user
operator|->
name|file
operator|)
condition|)
block|{
name|static_def_p
operator|=
name|dd_p
expr_stmt|;
comment|/* save a pointer to the definition */
name|num_static_defs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num_static_defs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"%s: warning: no static definition for '%s' in file '%s'\n"
argument_list|,
name|pname
argument_list|,
name|head
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|user
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_static_defs
operator|>
literal|1
condition|)
block|{
name|notice
argument_list|(
literal|"%s: multiple static defs of '%s' in file '%s'\n"
argument_list|,
name|pname
argument_list|,
name|head
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|user
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|static_def_p
return|;
block|}
end_function

begin_comment
comment|/* Find good prototype style formal argument lists for all of the function    declarations which didn't have them before now.     To do this we consider each function name one at a time.  For each function    name, we look at the items on the linked list of def_dec_info records for    that particular name.     Somewhere on this list we should find one (and only one) def_dec_info    record which represents the actual function definition, and this record    should have a nice formal argument list already associated with it.     Thus, all we have to do is to connect up all of the other def_dec_info    records for this particular function name to the special one which has    the full-blown formals list.     Of course it is a little more complicated than just that.  See below for    more details.  */
end_comment

begin_function
specifier|static
name|void
name|connect_defs_and_decs
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
name|hp
parameter_list|)
block|{
specifier|const
name|def_dec_info
modifier|*
name|dd_p
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|extern_def_p
init|=
name|NULL
decl_stmt|;
name|int
name|first_extern_reference
init|=
literal|1
decl_stmt|;
comment|/* Traverse the list of definitions and declarations for this particular      function name.  For each item on the list, if it is a function      definition (either old style or new style) then GCC has already been      kind enough to produce a prototype for us, and it is associated with      the item already, so declare the item as its own associated "definition".       Also, for each item which is only a function declaration, but which      nonetheless has its own prototype already (obviously supplied by the user)      declare the item as its own definition.       Note that when/if there are multiple user-supplied prototypes already      present for multiple declarations of any given function, these multiple      prototypes *should* all match exactly with one another and with the      prototype for the actual function definition.  We don't check for this      here however, since we assume that the compiler must have already done      this consistency checking when it was creating the .X files.  */
for|for
control|(
name|dd_p
operator|=
name|hp
operator|->
name|ddip
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
name|dd_p
operator|->
name|prototyped
condition|)
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|dd_p
operator|)
operator|->
name|definition
operator|=
name|dd_p
expr_stmt|;
comment|/* Traverse the list of definitions and declarations for this particular      function name.  For each item on the list, if it is an extern function      declaration and if it has no associated definition yet, go try to find      the matching extern definition for the declaration.       When looking for the matching function definition, warn the user if we      fail to find one.       If we find more that one function definition also issue a warning.       Do the search for the matching definition only once per unique function      name (and only when absolutely needed) so that we can avoid putting out      redundant warning messages, and so that we will only put out warning      messages when there is actually a reference (i.e. a declaration) for      which we need to find a matching definition.  */
for|for
control|(
name|dd_p
operator|=
name|hp
operator|->
name|ddip
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
operator|!
name|dd_p
operator|->
name|is_func_def
operator|&&
operator|!
name|dd_p
operator|->
name|is_static
operator|&&
operator|!
name|dd_p
operator|->
name|definition
condition|)
block|{
if|if
condition|(
name|first_extern_reference
condition|)
block|{
name|extern_def_p
operator|=
name|find_extern_def
argument_list|(
name|hp
operator|->
name|ddip
argument_list|,
name|dd_p
argument_list|)
expr_stmt|;
name|first_extern_reference
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|dd_p
operator|)
operator|->
name|definition
operator|=
name|extern_def_p
expr_stmt|;
block|}
comment|/* Traverse the list of definitions and declarations for this particular      function name.  For each item on the list, if it is a static function      declaration and if it has no associated definition yet, go try to find      the matching static definition for the declaration within the same file.       When looking for the matching function definition, warn the user if we      fail to find one in the same file with the declaration, and refuse to      convert this kind of cross-file static function declaration.  After all,      this is stupid practice and should be discouraged.       We don't have to worry about the possibility that there is more than one      matching function definition in the given file because that would have      been flagged as an error by the compiler.       Do the search for the matching definition only once per unique      function-name/source-file pair (and only when absolutely needed) so that      we can avoid putting out redundant warning messages, and so that we will      only put out warning messages when there is actually a reference (i.e. a      declaration) for which we actually need to find a matching definition.  */
for|for
control|(
name|dd_p
operator|=
name|hp
operator|->
name|ddip
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
operator|!
name|dd_p
operator|->
name|is_func_def
operator|&&
name|dd_p
operator|->
name|is_static
operator|&&
operator|!
name|dd_p
operator|->
name|definition
condition|)
block|{
specifier|const
name|def_dec_info
modifier|*
name|dd_p2
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|static_def
decl_stmt|;
comment|/* We have now found a single static declaration for which we need to 	   find a matching definition.  We want to minimize the work (and the 	   number of warnings), so we will find an appropriate (matching) 	   static definition for this declaration, and then distribute it 	   (as the definition for) any and all other static declarations 	   for this function name which occur within the same file, and which 	   do not already have definitions.  	   Note that a trick is used here to prevent subsequent attempts to 	   call find_static_definition for a given function-name& file 	   if the first such call returns NULL.  Essentially, we convert 	   these NULL return values to -1, and put the -1 into the definition 	   field for each other static declaration from the same file which 	   does not already have an associated definition. 	   This makes these other static declarations look like they are 	   actually defined already when the outer loop here revisits them 	   later on.  Thus, the outer loop will skip over them.  Later, we 	   turn the -1's back to NULL's.  */
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|dd_p
operator|)
operator|->
name|definition
operator|=
operator|(
name|static_def
operator|=
name|find_static_definition
argument_list|(
name|dd_p
argument_list|)
operator|)
condition|?
name|static_def
else|:
operator|(
specifier|const
name|def_dec_info
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|dd_p2
operator|=
name|dd_p
operator|->
name|next_for_func
init|;
name|dd_p2
condition|;
name|dd_p2
operator|=
name|dd_p2
operator|->
name|next_for_func
control|)
if|if
condition|(
operator|!
name|dd_p2
operator|->
name|is_func_def
operator|&&
name|dd_p2
operator|->
name|is_static
operator|&&
operator|!
name|dd_p2
operator|->
name|definition
operator|&&
operator|(
name|dd_p2
operator|->
name|file
operator|==
name|dd_p
operator|->
name|file
operator|)
condition|)
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|dd_p2
operator|)
operator|->
name|definition
operator|=
name|dd_p
operator|->
name|definition
expr_stmt|;
block|}
comment|/* Convert any dummy (-1) definitions we created in the step above back to      NULL's (as they should be).  */
for|for
control|(
name|dd_p
operator|=
name|hp
operator|->
name|ddip
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_for_func
control|)
if|if
condition|(
name|dd_p
operator|->
name|definition
operator|==
operator|(
name|def_dec_info
operator|*
operator|)
operator|-
literal|1
condition|)
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|dd_p
operator|)
operator|->
name|definition
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_comment
comment|/* Give a pointer into the clean text buffer, return a number which is the    original source line number that the given pointer points into.  */
end_comment

begin_function
specifier|static
name|int
name|identify_lineno
parameter_list|(
specifier|const
name|char
modifier|*
name|clean_p
parameter_list|)
block|{
name|int
name|line_num
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan_p
decl_stmt|;
for|for
control|(
name|scan_p
operator|=
name|clean_text_base
init|;
name|scan_p
operator|<=
name|clean_p
condition|;
name|scan_p
operator|++
control|)
if|if
condition|(
operator|*
name|scan_p
operator|==
literal|'\n'
condition|)
name|line_num
operator|++
expr_stmt|;
return|return
name|line_num
return|;
block|}
end_function

begin_comment
comment|/* Issue an error message and give up on doing this particular edit.  */
end_comment

begin_function
specifier|static
name|void
name|declare_source_confusing
parameter_list|(
specifier|const
name|char
modifier|*
name|clean_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
if|if
condition|(
name|clean_p
operator|==
literal|0
condition|)
name|notice
argument_list|(
literal|"%s: %d: warning: source too confusing\n"
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|last_known_line_number
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"%s: %d: warning: source too confusing\n"
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|identify_lineno
argument_list|(
name|clean_p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|source_confusion_recovery
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that a condition which is expected to be true in the original source    code is in fact true.  If not, issue an error message and give up on    converting this particular source file.  */
end_comment

begin_function
specifier|static
name|void
name|check_source
parameter_list|(
name|int
name|cond
parameter_list|,
specifier|const
name|char
modifier|*
name|clean_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cond
condition|)
name|declare_source_confusing
argument_list|(
name|clean_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we think of the in-core cleaned text buffer as a memory mapped    file (with the variable last_known_line_start acting as sort of a    file pointer) then we can imagine doing "seeks" on the buffer.  The    following routine implements a kind of "seek" operation for the in-core    (cleaned) copy of the source file.  When finished, it returns a pointer to    the start of a given (numbered) line in the cleaned text buffer.     Note that protoize only has to "seek" in the forward direction on the    in-core cleaned text file buffers, and it never needs to back up.     This routine is made a little bit faster by remembering the line number    (and pointer value) supplied (and returned) from the previous "seek".    This prevents us from always having to start all over back at the top    of the in-core cleaned buffer again.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|seek_to_line
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|n
operator|>=
name|last_known_line_number
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
name|last_known_line_number
condition|)
block|{
while|while
condition|(
operator|*
name|last_known_line_start
operator|!=
literal|'\n'
condition|)
name|check_source
argument_list|(
operator|++
name|last_known_line_start
operator|<
name|clean_text_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_known_line_start
operator|++
expr_stmt|;
name|last_known_line_number
operator|++
expr_stmt|;
block|}
return|return
name|last_known_line_start
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a character in the cleaned text buffer, return a pointer    to the next non-whitespace character which follows it.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|forward_to_next_token_char
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
for|for
control|(
operator|++
name|ptr
init|;
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|ptr
argument_list|)
condition|;
name|check_source
argument_list|(
operator|++
name|ptr
operator|<
name|clean_text_limit
argument_list|,
literal|0
argument_list|)
control|)
continue|continue;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Copy a chunk of text of length `len' and starting at `str' to the current    output buffer.  Note that all attempts to add stuff to the current output    buffer ultimately go through here.  */
end_comment

begin_function
specifier|static
name|void
name|output_bytes
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|repl_write_ptr
operator|+
literal|1
operator|)
operator|+
name|len
operator|>=
name|repl_text_limit
condition|)
block|{
name|size_t
name|new_size
init|=
operator|(
name|repl_text_limit
operator|-
name|repl_text_base
operator|)
operator|<<
literal|1
decl_stmt|;
name|char
modifier|*
name|new_buf
init|=
name|xrealloc
argument_list|(
name|repl_text_base
argument_list|,
name|new_size
argument_list|)
decl_stmt|;
name|repl_write_ptr
operator|=
name|new_buf
operator|+
operator|(
name|repl_write_ptr
operator|-
name|repl_text_base
operator|)
expr_stmt|;
name|repl_text_base
operator|=
name|new_buf
expr_stmt|;
name|repl_text_limit
operator|=
name|new_buf
operator|+
name|new_size
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|repl_write_ptr
operator|+
literal|1
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|repl_write_ptr
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy all bytes (except the trailing null) of a null terminated string to    the current output buffer.  */
end_comment

begin_function
specifier|static
name|void
name|output_string
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|output_bytes
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy some characters from the original text buffer to the current output    buffer.     This routine takes a pointer argument `p' which is assumed to be a pointer    into the cleaned text buffer.  The bytes which are copied are the `original'    equivalents for the set of bytes between the last value of `clean_read_ptr'    and the argument value `p'.     The set of bytes copied however, comes *not* from the cleaned text buffer,    but rather from the direct counterparts of these bytes within the original    text buffer.     Thus, when this function is called, some bytes from the original text    buffer (which may include original comments and preprocessing directives)    will be copied into the  output buffer.     Note that the request implied when this routine is called includes the    byte pointed to by the argument pointer `p'.  */
end_comment

begin_function
specifier|static
name|void
name|output_up_to
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|copy_length
init|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|clean_read_ptr
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_start
init|=
name|orig_text_base
operator|+
operator|(
name|clean_read_ptr
operator|-
name|clean_text_base
operator|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|copy_length
operator|==
literal|0
condition|)
return|return;
name|output_bytes
argument_list|(
name|copy_start
argument_list|,
name|copy_length
argument_list|)
expr_stmt|;
name|clean_read_ptr
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a def_dec_info record which represents some form of    definition of a function (perhaps a real definition, or in lieu of that    perhaps just a declaration with a full prototype) return true if this    function is one which we should avoid converting.  Return false    otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|other_variable_style_function
parameter_list|(
specifier|const
name|char
modifier|*
name|ansi_header
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UNPROTOIZE
comment|/* See if we have a stdarg function, or a function which has stdarg style      parameters or a stdarg style return type.  */
return|return
name|strstr
argument_list|(
name|ansi_header
argument_list|,
literal|"..."
argument_list|)
operator|!=
literal|0
return|;
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
comment|/* See if we have a varargs function, or a function which has varargs style      parameters or a varargs style return type.  */
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|varargs_style_indicator
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ansi_header
init|;
name|p
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|candidate
decl_stmt|;
if|if
condition|(
operator|(
name|candidate
operator|=
name|strstr
argument_list|(
name|p
argument_list|,
name|varargs_style_indicator
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|is_id_char
argument_list|(
name|candidate
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|is_id_char
argument_list|(
name|candidate
index|[
name|len
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
name|p
operator|=
name|candidate
operator|+
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
block|}
end_function

begin_comment
comment|/* Do the editing operation specifically for a function "declaration".  Note    that editing for function "definitions" are handled in a separate routine    below.  */
end_comment

begin_function
specifier|static
name|void
name|edit_fn_declaration
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
name|def_dec_p
parameter_list|,
specifier|const
name|char
modifier|*
specifier|volatile
name|clean_text_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start_formals
decl_stmt|;
specifier|const
name|char
modifier|*
name|end_formals
decl_stmt|;
specifier|const
name|char
modifier|*
name|function_to_edit
init|=
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
decl_stmt|;
name|size_t
name|func_name_len
init|=
name|strlen
argument_list|(
name|function_to_edit
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|end_of_fn_name
decl_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
specifier|const
name|f_list_chain_item
modifier|*
name|this_f_list_chain_item
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|definition
init|=
name|def_dec_p
operator|->
name|definition
decl_stmt|;
comment|/* If we are protoizing, and if we found no corresponding definition for      this particular function declaration, then just leave this declaration      exactly as it is.  */
if|if
condition|(
operator|!
name|definition
condition|)
return|return;
comment|/* If we are protoizing, and if the corresponding definition that we found      for this particular function declaration defined an old style varargs      function, then we want to issue a warning and just leave this function      declaration unconverted.  */
if|if
condition|(
name|other_variable_style_function
argument_list|(
name|definition
operator|->
name|ansi_decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"%s: %d: warning: varargs function declaration not converted\n"
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|def_dec_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|,
name|def_dec_p
operator|->
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
comment|/* Setup here to recover from confusing source code detected during this      particular "edit".  */
name|save_pointers
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|source_confusion_recovery
argument_list|)
condition|)
block|{
name|restore_pointers
argument_list|()
expr_stmt|;
name|notice
argument_list|(
literal|"%s: declaration of function '%s' not converted\n"
argument_list|,
name|pname
argument_list|,
name|function_to_edit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We are editing a function declaration.  The line number we did a seek to      contains the comma or semicolon which follows the declaration.  Our job      now is to scan backwards looking for the function name.  This name *must*      be followed by open paren (ignoring whitespace, of course).  We need to      replace everything between that open paren and the corresponding closing      paren.  If we are protoizing, we need to insert the prototype-style      formals lists.  If we are unprotoizing, we need to just delete everything      between the pairs of opening and closing parens.  */
comment|/* First move up to the end of the line.  */
while|while
condition|(
operator|*
name|clean_text_p
operator|!=
literal|'\n'
condition|)
name|check_source
argument_list|(
operator|++
name|clean_text_p
operator|<
name|clean_text_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clean_text_p
operator|--
expr_stmt|;
comment|/* Point to just before the newline character.  */
comment|/* Now we can scan backwards for the function name.  */
do|do
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Scan leftwards until we find some character which can be 	     part of an identifier.  */
while|while
condition|(
operator|!
name|is_id_char
argument_list|(
operator|*
name|clean_text_p
argument_list|)
condition|)
name|check_source
argument_list|(
operator|--
name|clean_text_p
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Scan backwards until we find a char that cannot be part of an 	     identifier.  */
while|while
condition|(
name|is_id_char
argument_list|(
operator|*
name|clean_text_p
argument_list|)
condition|)
name|check_source
argument_list|(
operator|--
name|clean_text_p
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Having found an "id break", see if the following id is the one 	     that we are looking for.  If so, then exit from this loop.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|clean_text_p
operator|+
literal|1
argument_list|,
name|function_to_edit
argument_list|,
name|func_name_len
argument_list|)
condition|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|clean_text_p
operator|+
literal|1
operator|+
name|func_name_len
operator|)
decl_stmt|;
comment|/* Must also check to see that the name in the source text 	         ends where it should (in order to prevent bogus matches 	         on similar but longer identifiers.  */
if|if
condition|(
operator|!
name|is_id_char
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
comment|/* exit from loop */
block|}
block|}
comment|/* We have now found the first perfect match for the function name in 	 our backward search.  This may or may not be the actual function 	 name at the start of the actual function declaration (i.e. we could 	 have easily been mislead).  We will try to avoid getting fooled too 	 often by looking forward for the open paren which should follow the 	 identifier we just found.  We ignore whitespace while hunting.  If 	 the next non-whitespace byte we see is *not* an open left paren, 	 then we must assume that we have been fooled and we start over 	 again accordingly.  Note that there is no guarantee, that even if 	 we do see the open paren, that we are in the right place. 	 Programmers do the strangest things sometimes!  */
name|end_of_fn_name
operator|=
name|clean_text_p
operator|+
name|strlen
argument_list|(
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|start_formals
operator|=
name|forward_to_next_token_char
argument_list|(
name|end_of_fn_name
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|start_formals
operator|!=
literal|'('
condition|)
do|;
comment|/* start_of_formals now points to the opening left paren which immediately      follows the name of the function.  */
comment|/* Note that there may be several formals lists which need to be modified      due to the possibility that the return type of this function is a      pointer-to-function type.  If there are several formals lists, we      convert them in left-to-right order here.  */
ifndef|#
directive|ifndef
name|UNPROTOIZE
name|this_f_list_chain_item
operator|=
name|definition
operator|->
name|f_list_chain
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
for|for
control|(
init|;
condition|;
control|)
block|{
block|{
name|int
name|depth
decl_stmt|;
name|end_formals
operator|=
name|start_formals
operator|+
literal|1
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|depth
condition|;
name|check_source
argument_list|(
operator|++
name|end_formals
operator|<
name|clean_text_limit
argument_list|,
literal|0
argument_list|)
control|)
block|{
switch|switch
condition|(
operator|*
name|end_formals
condition|)
block|{
case|case
literal|'('
case|:
name|depth
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|depth
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|end_formals
operator|--
expr_stmt|;
block|}
comment|/* end_formals now points to the closing right paren of the formals 	 list whose left paren is pointed to by start_formals.  */
comment|/* Now, if we are protoizing, we insert the new ANSI-style formals list 	 attached to the associated definition of this function.  If however 	 we are unprotoizing, then we simply delete any formals list which 	 may be present.  */
name|output_up_to
argument_list|(
name|start_formals
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
if|if
condition|(
name|this_f_list_chain_item
condition|)
block|{
name|output_string
argument_list|(
name|this_f_list_chain_item
operator|->
name|formals_list
argument_list|)
expr_stmt|;
name|this_f_list_chain_item
operator|=
name|this_f_list_chain_item
operator|->
name|chain_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"%s: warning: too many parameter lists in declaration of '%s'\n"
argument_list|,
name|pname
argument_list|,
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|check_source
argument_list|(
literal|0
argument_list|,
name|end_formals
argument_list|)
expr_stmt|;
comment|/* leave the declaration intact */
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|clean_read_ptr
operator|=
name|end_formals
operator|-
literal|1
expr_stmt|;
comment|/* Now see if it looks like there may be another formals list associated 	 with the function declaration that we are converting (following the 	 formals list that we just converted.  */
block|{
specifier|const
name|char
modifier|*
name|another_r_paren
init|=
name|forward_to_next_token_char
argument_list|(
name|end_formals
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|another_r_paren
operator|!=
literal|')'
operator|)
operator|||
operator|(
operator|*
operator|(
name|start_formals
operator|=
name|forward_to_next_token_char
argument_list|(
name|another_r_paren
argument_list|)
operator|)
operator|!=
literal|'('
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|UNPROTOIZE
if|if
condition|(
name|this_f_list_chain_item
condition|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"\n%s: warning: too few parameter lists in declaration of '%s'\n"
argument_list|,
name|pname
argument_list|,
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|check_source
argument_list|(
literal|0
argument_list|,
name|start_formals
argument_list|)
expr_stmt|;
comment|/* leave the decl intact */
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
break|break;
block|}
block|}
comment|/* There does appear to be yet another formals list, so loop around 	 again, and convert it also.  */
block|}
block|}
end_function

begin_comment
comment|/* Edit a whole group of formals lists, starting with the rightmost one    from some set of formals lists.  This routine is called once (from the    outside) for each function declaration which is converted.  It is    recursive however, and it calls itself once for each remaining formal    list that lies to the left of the one it was originally called to work    on.  Thus, a whole set gets done in right-to-left order.     This routine returns nonzero if it thinks that it should not be trying    to convert this particular function definition (because the name of the    function doesn't match the one expected).  */
end_comment

begin_function
specifier|static
name|int
name|edit_formals_lists
parameter_list|(
specifier|const
name|char
modifier|*
name|end_formals
parameter_list|,
name|unsigned
name|int
name|f_list_count
parameter_list|,
specifier|const
name|def_dec_info
modifier|*
name|def_dec_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start_formals
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|start_formals
operator|=
name|end_formals
operator|-
literal|1
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|depth
condition|;
name|check_source
argument_list|(
operator|--
name|start_formals
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
control|)
block|{
switch|switch
condition|(
operator|*
name|start_formals
condition|)
block|{
case|case
literal|'('
case|:
name|depth
operator|--
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|depth
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|start_formals
operator|++
expr_stmt|;
comment|/* start_formals now points to the opening left paren of the formals list.  */
name|f_list_count
operator|--
expr_stmt|;
if|if
condition|(
name|f_list_count
condition|)
block|{
specifier|const
name|char
modifier|*
name|next_end
decl_stmt|;
comment|/* There should be more formal lists to the left of here.  */
name|next_end
operator|=
name|start_formals
operator|-
literal|1
expr_stmt|;
name|check_source
argument_list|(
name|next_end
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|next_end
argument_list|)
condition|)
name|check_source
argument_list|(
operator|--
name|next_end
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_source
argument_list|(
operator|*
name|next_end
operator|==
literal|')'
argument_list|,
name|next_end
argument_list|)
expr_stmt|;
name|check_source
argument_list|(
operator|--
name|next_end
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_source
argument_list|(
operator|*
name|next_end
operator|==
literal|')'
argument_list|,
name|next_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_formals_lists
argument_list|(
name|next_end
argument_list|,
name|f_list_count
argument_list|,
name|def_dec_p
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Check that the function name in the header we are working on is the same      as the one we would expect to find.  If not, issue a warning and return      nonzero.  */
if|if
condition|(
name|f_list_count
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|expected
init|=
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
decl_stmt|;
specifier|const
name|char
modifier|*
name|func_name_start
decl_stmt|;
specifier|const
name|char
modifier|*
name|func_name_limit
decl_stmt|;
name|size_t
name|func_name_len
decl_stmt|;
for|for
control|(
name|func_name_limit
operator|=
name|start_formals
operator|-
literal|1
init|;
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|func_name_limit
argument_list|)
condition|;
control|)
name|check_source
argument_list|(
operator|--
name|func_name_limit
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|func_name_start
operator|=
name|func_name_limit
operator|++
init|;
name|is_id_char
argument_list|(
operator|*
name|func_name_start
argument_list|)
condition|;
name|func_name_start
operator|--
control|)
name|check_source
argument_list|(
name|func_name_start
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|func_name_start
operator|++
expr_stmt|;
name|func_name_len
operator|=
name|func_name_limit
operator|-
name|func_name_start
expr_stmt|;
if|if
condition|(
name|func_name_len
operator|==
literal|0
condition|)
name|check_source
argument_list|(
literal|0
argument_list|,
name|func_name_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_name_len
operator|!=
name|strlen
argument_list|(
name|expected
argument_list|)
operator|||
name|strncmp
argument_list|(
name|func_name_start
argument_list|,
name|expected
argument_list|,
name|func_name_len
argument_list|)
condition|)
block|{
name|notice
argument_list|(
literal|"%s: %d: warning: found '%s' but expected '%s'\n"
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|def_dec_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|,
name|identify_lineno
argument_list|(
name|func_name_start
argument_list|)
argument_list|,
name|dupnstr
argument_list|(
name|func_name_start
argument_list|,
name|func_name_len
argument_list|)
argument_list|,
name|expected
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|output_up_to
argument_list|(
name|start_formals
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNPROTOIZE
if|if
condition|(
name|f_list_count
operator|==
literal|0
condition|)
name|output_string
argument_list|(
name|def_dec_p
operator|->
name|formal_names
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
block|{
name|unsigned
name|f_list_depth
decl_stmt|;
specifier|const
name|f_list_chain_item
modifier|*
name|flci_p
init|=
name|def_dec_p
operator|->
name|f_list_chain
decl_stmt|;
comment|/* At this point, the current value of f_list count says how many        links we have to follow through the f_list_chain to get to the        particular formals list that we need to output next.  */
for|for
control|(
name|f_list_depth
operator|=
literal|0
init|;
name|f_list_depth
operator|<
name|f_list_count
condition|;
name|f_list_depth
operator|++
control|)
name|flci_p
operator|=
name|flci_p
operator|->
name|chain_next
expr_stmt|;
name|output_string
argument_list|(
name|flci_p
operator|->
name|formals_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|clean_read_ptr
operator|=
name|end_formals
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a byte in the clean text buffer which points to    the beginning of a line that contains a "follower" token for a    function definition header, do whatever is necessary to find the    right closing paren for the rightmost formals list of the function    definition header.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_rightmost_formals_list
parameter_list|(
specifier|const
name|char
modifier|*
name|clean_text_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end_formals
decl_stmt|;
comment|/* We are editing a function definition.  The line number we did a seek      to contains the first token which immediately follows the entire set of      formals lists which are part of this particular function definition      header.       Our job now is to scan leftwards in the clean text looking for the      right-paren which is at the end of the function header's rightmost      formals list.       If we ignore whitespace, this right paren should be the first one we      see which is (ignoring whitespace) immediately followed either by the      open curly-brace beginning the function body or by an alphabetic      character (in the case where the function definition is in old (K&R)      style and there are some declarations of formal parameters).  */
comment|/* It is possible that the right paren we are looking for is on the       current line (together with its following token).  Just in case that       might be true, we start out here by skipping down to the right end of       the current line before starting our scan.  */
for|for
control|(
name|end_formals
operator|=
name|clean_text_p
init|;
operator|*
name|end_formals
operator|!=
literal|'\n'
condition|;
name|end_formals
operator|++
control|)
continue|continue;
name|end_formals
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|UNPROTOIZE
comment|/* Now scan backwards while looking for the right end of the rightmost      formals list associated with this function definition.  */
block|{
name|char
name|ch
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_brace_p
decl_stmt|;
comment|/* Look leftward and try to find a right-paren.  */
while|while
condition|(
operator|*
name|end_formals
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end_formals
argument_list|)
condition|)
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end_formals
argument_list|)
condition|)
name|check_source
argument_list|(
operator|--
name|end_formals
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|check_source
argument_list|(
operator|--
name|end_formals
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
operator|*
operator|(
name|l_brace_p
operator|=
name|forward_to_next_token_char
argument_list|(
name|end_formals
argument_list|)
operator|)
expr_stmt|;
comment|/* Since we are unprotoizing an ANSI-style (prototyped) function        definition, there had better not be anything (except whitespace)        between the end of the ANSI formals list and the beginning of the        function body (i.e. the '{').  */
name|check_source
argument_list|(
name|ch
operator|==
literal|'{'
argument_list|,
name|l_brace_p
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
comment|/* Now scan backwards while looking for the right end of the rightmost      formals list associated with this function definition.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|ch
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_brace_p
decl_stmt|;
comment|/* Look leftward and try to find a right-paren.  */
while|while
condition|(
operator|*
name|end_formals
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|end_formals
argument_list|)
condition|)
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|end_formals
argument_list|)
condition|)
name|check_source
argument_list|(
operator|--
name|end_formals
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|check_source
argument_list|(
operator|--
name|end_formals
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
operator|*
operator|(
name|l_brace_p
operator|=
name|forward_to_next_token_char
argument_list|(
name|end_formals
argument_list|)
operator|)
expr_stmt|;
comment|/* Since it is possible that we found a right paren before the starting 	 '{' of the body which IS NOT the one at the end of the real K&R 	 formals list (say for instance, we found one embedded inside one of 	 the old K&R formal parameter declarations) we have to check to be 	 sure that this is in fact the right paren that we were looking for.  	 The one we were looking for *must* be followed by either a '{' or 	 by an alphabetic character, while others *cannot* validly be followed 	 by such characters.  */
if|if
condition|(
operator|(
name|ch
operator|==
literal|'{'
operator|)
operator|||
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
break|break;
comment|/* At this point, we have found a right paren, but we know that it is 	 not the one we were looking for, so backup one character and keep 	 looking.  */
name|check_source
argument_list|(
operator|--
name|end_formals
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
return|return
name|end_formals
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|UNPROTOIZE
end_ifndef

begin_comment
comment|/* Insert into the output file a totally new declaration for a function    which (up until now) was being called from within the current block    without having been declared at any point such that the declaration    was visible (i.e. in scope) at the point of the call.     We need to add in explicit declarations for all such function calls    in order to get the full benefit of prototype-based function call    parameter type checking.  */
end_comment

begin_function
specifier|static
name|void
name|add_local_decl
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
name|def_dec_p
parameter_list|,
specifier|const
name|char
modifier|*
name|clean_text_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start_of_block
decl_stmt|;
specifier|const
name|char
modifier|*
name|function_to_edit
init|=
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
decl_stmt|;
comment|/* Don't insert new local explicit declarations unless explicitly requested      to do so.  */
if|if
condition|(
operator|!
name|local_flag
condition|)
return|return;
comment|/* Setup here to recover from confusing source code detected during this      particular "edit".  */
name|save_pointers
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|source_confusion_recovery
argument_list|)
condition|)
block|{
name|restore_pointers
argument_list|()
expr_stmt|;
name|notice
argument_list|(
literal|"%s: local declaration for function '%s' not inserted\n"
argument_list|,
name|pname
argument_list|,
name|function_to_edit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We have already done a seek to the start of the line which should      contain *the* open curly brace which begins the block in which we need      to insert an explicit function declaration (to replace the implicit one).       Now we scan that line, starting from the left, until we find the      open curly brace we are looking for.  Note that there may actually be      multiple open curly braces on the given line, but we will be happy      with the leftmost one no matter what.  */
name|start_of_block
operator|=
name|clean_text_p
expr_stmt|;
while|while
condition|(
operator|*
name|start_of_block
operator|!=
literal|'{'
operator|&&
operator|*
name|start_of_block
operator|!=
literal|'\n'
condition|)
name|check_source
argument_list|(
operator|++
name|start_of_block
operator|<
name|clean_text_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Note that the line from the original source could possibly      contain *no* open curly braces!  This happens if the line contains      a macro call which expands into a chunk of text which includes a      block (and that block's associated open and close curly braces).      In cases like this, we give up, issue a warning, and do nothing.  */
if|if
condition|(
operator|*
name|start_of_block
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"\n%s: %d: warning: can't add declaration of '%s' into macro call\n"
argument_list|,
name|def_dec_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|,
name|def_dec_p
operator|->
name|line
argument_list|,
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Figure out what a nice (pretty) indentation would be for the new      declaration we are adding.  In order to do this, we must scan forward      from the '{' until we find the first line which starts with some      non-whitespace characters (i.e. real "token" material).  */
block|{
specifier|const
name|char
modifier|*
name|ep
init|=
name|forward_to_next_token_char
argument_list|(
name|start_of_block
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* Now we have ep pointing at the rightmost byte of some existing indent        stuff.  At least that is the hope.         We can now just scan backwards and find the left end of the existing        indentation string, and then copy it to the output buffer.  */
for|for
control|(
name|sp
operator|=
name|ep
init|;
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|sp
argument_list|)
operator|&&
operator|*
name|sp
operator|!=
literal|'\n'
condition|;
name|sp
operator|--
control|)
continue|continue;
comment|/* Now write out the open { which began this block, and any following        trash up to and including the last byte of the existing indent that        we just found.  */
name|output_up_to
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* Now we go ahead and insert the new declaration at this point.         If the definition of the given function is in the same file that we        are currently editing, and if its full ANSI declaration normally        would start with the keyword `extern', suppress the `extern'.  */
block|{
specifier|const
name|char
modifier|*
name|decl
init|=
name|def_dec_p
operator|->
name|definition
operator|->
name|ansi_decl
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|decl
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|def_dec_p
operator|->
name|file
operator|==
name|def_dec_p
operator|->
name|definition
operator|->
name|file
operator|)
condition|)
name|decl
operator|+=
literal|7
expr_stmt|;
name|output_string
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, write out a new indent string, just like the preceding one        that we found.  This will typically include a newline as the first        character of the indent string.  */
name|output_bytes
argument_list|(
name|sp
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|ep
operator|-
name|sp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to a file_info record, and a pointer to the beginning    of a line (in the clean text buffer) which is assumed to contain the    first "follower" token for the first function definition header in the    given file, find a good place to insert some new global function    declarations (which will replace scattered and imprecise implicit ones)    and then insert the new explicit declaration at that point in the file.  */
end_comment

begin_function
specifier|static
name|void
name|add_global_decls
parameter_list|(
specifier|const
name|file_info
modifier|*
name|file_p
parameter_list|,
specifier|const
name|char
modifier|*
name|clean_text_p
parameter_list|)
block|{
specifier|const
name|def_dec_info
modifier|*
name|dd_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan_p
decl_stmt|;
comment|/* Setup here to recover from confusing source code detected during this      particular "edit".  */
name|save_pointers
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|source_confusion_recovery
argument_list|)
condition|)
block|{
name|restore_pointers
argument_list|()
expr_stmt|;
name|notice
argument_list|(
literal|"%s: global declarations for file '%s' not inserted\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|file_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Start by finding a good location for adding the new explicit function      declarations.  To do this, we scan backwards, ignoring whitespace      and comments and other junk until we find either a semicolon, or until      we hit the beginning of the file.  */
name|scan_p
operator|=
name|find_rightmost_formals_list
argument_list|(
name|clean_text_p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|--
name|scan_p
control|)
block|{
if|if
condition|(
name|scan_p
operator|<
name|clean_text_base
condition|)
break|break;
name|check_source
argument_list|(
name|scan_p
operator|>
name|clean_read_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|scan_p
operator|==
literal|';'
condition|)
break|break;
block|}
comment|/* scan_p now points either to a semicolon, or to just before the start      of the whole file.  */
comment|/* Now scan forward for the first non-whitespace character.  In theory,      this should be the first character of the following function definition      header.  We will put in the added declarations just prior to that.  */
name|scan_p
operator|++
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|scan_p
argument_list|)
condition|)
name|scan_p
operator|++
expr_stmt|;
name|scan_p
operator|--
expr_stmt|;
name|output_up_to
argument_list|(
name|scan_p
argument_list|)
expr_stmt|;
comment|/* Now write out full prototypes for all of the things that had been      implicitly declared in this file (but only those for which we were      actually able to find unique matching definitions).  Avoid duplicates      by marking things that we write out as we go.  */
block|{
name|int
name|some_decls_added
init|=
literal|0
decl_stmt|;
for|for
control|(
name|dd_p
operator|=
name|file_p
operator|->
name|defs_decs
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_in_file
control|)
if|if
condition|(
name|dd_p
operator|->
name|is_implicit
operator|&&
name|dd_p
operator|->
name|definition
operator|&&
operator|!
name|dd_p
operator|->
name|definition
operator|->
name|written
condition|)
block|{
specifier|const
name|char
modifier|*
name|decl
init|=
name|dd_p
operator|->
name|definition
operator|->
name|ansi_decl
decl_stmt|;
comment|/* If the function for which we are inserting a declaration is 	     actually defined later in the same file, then suppress the 	     leading `extern' keyword (if there is one).  */
if|if
condition|(
operator|*
name|decl
operator|==
literal|'e'
operator|&&
operator|(
name|dd_p
operator|->
name|file
operator|==
name|dd_p
operator|->
name|definition
operator|->
name|file
operator|)
condition|)
name|decl
operator|+=
literal|7
expr_stmt|;
name|output_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|output_string
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|some_decls_added
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|dd_p
operator|->
name|definition
operator|)
operator|->
name|written
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|some_decls_added
condition|)
name|output_string
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Unmark all of the definitions that we just marked.  */
for|for
control|(
name|dd_p
operator|=
name|file_p
operator|->
name|defs_decs
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_in_file
control|)
if|if
condition|(
name|dd_p
operator|->
name|definition
condition|)
operator|(
operator|(
name|NONCONST
name|def_dec_info
operator|*
operator|)
name|dd_p
operator|->
name|definition
operator|)
operator|->
name|written
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (UNPROTOIZE) */
end_comment

begin_comment
comment|/* Do the editing operation specifically for a function "definition".  Note    that editing operations for function "declarations" are handled by a    separate routine above.  */
end_comment

begin_function
specifier|static
name|void
name|edit_fn_definition
parameter_list|(
specifier|const
name|def_dec_info
modifier|*
name|def_dec_p
parameter_list|,
specifier|const
name|char
modifier|*
specifier|volatile
name|clean_text_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end_formals
decl_stmt|;
specifier|const
name|char
modifier|*
name|function_to_edit
init|=
name|def_dec_p
operator|->
name|hash_entry
operator|->
name|symbol
decl_stmt|;
comment|/* Setup here to recover from confusing source code detected during this      particular "edit".  */
name|save_pointers
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|source_confusion_recovery
argument_list|)
condition|)
block|{
name|restore_pointers
argument_list|()
expr_stmt|;
name|notice
argument_list|(
literal|"%s: definition of function '%s' not converted\n"
argument_list|,
name|pname
argument_list|,
name|function_to_edit
argument_list|)
expr_stmt|;
return|return;
block|}
name|end_formals
operator|=
name|find_rightmost_formals_list
argument_list|(
name|clean_text_p
argument_list|)
expr_stmt|;
comment|/* end_of_formals now points to the closing right paren of the rightmost      formals list which is actually part of the `header' of the function      definition that we are converting.  */
comment|/* If the header of this function definition looks like it declares a      function with a variable number of arguments, and if the way it does      that is different from that way we would like it (i.e. varargs vs.      stdarg) then issue a warning and leave the header unconverted.  */
if|if
condition|(
name|other_variable_style_function
argument_list|(
name|def_dec_p
operator|->
name|ansi_decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"%s: %d: warning: definition of %s not converted\n"
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|def_dec_p
operator|->
name|file
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|,
name|identify_lineno
argument_list|(
name|end_formals
argument_list|)
argument_list|,
name|other_var_style
argument_list|)
expr_stmt|;
name|output_up_to
argument_list|(
name|end_formals
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|edit_formals_lists
argument_list|(
name|end_formals
argument_list|,
name|def_dec_p
operator|->
name|f_list_count
argument_list|,
name|def_dec_p
argument_list|)
condition|)
block|{
name|restore_pointers
argument_list|()
expr_stmt|;
name|notice
argument_list|(
literal|"%s: definition of function '%s' not converted\n"
argument_list|,
name|pname
argument_list|,
name|function_to_edit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Have to output the last right paren because this never gets flushed by      edit_formals_list.  */
name|output_up_to
argument_list|(
name|end_formals
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNPROTOIZE
block|{
specifier|const
name|char
modifier|*
name|decl_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|semicolon_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|limit_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan_p
decl_stmt|;
name|int
name|had_newlines
init|=
literal|0
decl_stmt|;
comment|/* Now write out the K&R style formal declarations, one per line.  */
name|decl_p
operator|=
name|def_dec_p
operator|->
name|formal_decls
expr_stmt|;
name|limit_p
operator|=
name|decl_p
operator|+
name|strlen
argument_list|(
name|decl_p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|decl_p
operator|<
name|limit_p
condition|;
name|decl_p
operator|=
name|semicolon_p
operator|+
literal|2
control|)
block|{
for|for
control|(
name|semicolon_p
operator|=
name|decl_p
init|;
operator|*
name|semicolon_p
operator|!=
literal|';'
condition|;
name|semicolon_p
operator|++
control|)
continue|continue;
name|output_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|output_string
argument_list|(
name|indent_string
argument_list|)
expr_stmt|;
name|output_bytes
argument_list|(
name|decl_p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|semicolon_p
operator|+
literal|1
operator|)
operator|-
name|decl_p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no newlines between the end of the formals list and the        start of the body, we should insert one now.  */
for|for
control|(
name|scan_p
operator|=
name|end_formals
operator|+
literal|1
init|;
operator|*
name|scan_p
operator|!=
literal|'{'
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|scan_p
operator|==
literal|'\n'
condition|)
block|{
name|had_newlines
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|check_source
argument_list|(
operator|++
name|scan_p
operator|<
name|clean_text_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|had_newlines
condition|)
name|output_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
comment|/* If we are protoizing, there may be some flotsam& jetsam (like comments      and preprocessing directives) after the old formals list but before      the following { and we would like to preserve that stuff while effectively      deleting the existing K&R formal parameter declarations.  We do so here      in a rather tricky way.  Basically, we white out any stuff *except*      the comments/pp-directives in the original text buffer, then, if there      is anything in this area *other* than whitespace, we output it.  */
block|{
specifier|const
name|char
modifier|*
name|end_formals_orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_body
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_body_orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan_orig
decl_stmt|;
name|int
name|have_flotsam
init|=
literal|0
decl_stmt|;
name|int
name|have_newlines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|start_body
operator|=
name|end_formals
operator|+
literal|1
init|;
operator|*
name|start_body
operator|!=
literal|'{'
condition|;
control|)
name|check_source
argument_list|(
operator|++
name|start_body
operator|<
name|clean_text_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end_formals_orig
operator|=
name|orig_text_base
operator|+
operator|(
name|end_formals
operator|-
name|clean_text_base
operator|)
expr_stmt|;
name|start_body_orig
operator|=
name|orig_text_base
operator|+
operator|(
name|start_body
operator|-
name|clean_text_base
operator|)
expr_stmt|;
name|scan
operator|=
name|end_formals
operator|+
literal|1
expr_stmt|;
name|scan_orig
operator|=
name|end_formals_orig
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|scan
operator|<
name|start_body
condition|;
name|scan
operator|++
operator|,
name|scan_orig
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
operator|*
name|scan_orig
condition|)
block|{
name|have_newlines
operator||=
operator|(
operator|*
name|scan_orig
operator|==
literal|'\n'
operator|)
expr_stmt|;
comment|/* Leave identical whitespace alone.  */
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|scan_orig
argument_list|)
condition|)
operator|*
operator|(
operator|(
name|NONCONST
name|char
operator|*
operator|)
name|scan_orig
operator|)
operator|=
literal|' '
expr_stmt|;
comment|/* identical - so whiteout */
block|}
else|else
name|have_flotsam
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|have_flotsam
condition|)
name|output_bytes
argument_list|(
name|end_formals_orig
operator|+
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|start_body_orig
operator|-
name|end_formals_orig
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|have_newlines
condition|)
name|output_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|output_string
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|clean_read_ptr
operator|=
name|start_body
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
block|}
end_function

begin_comment
comment|/* Clean up the clean text buffer.  Do this by converting comments and    preprocessing directives into spaces.   Also convert line continuations    into whitespace.  Also, whiteout string and character literals.  */
end_comment

begin_function
specifier|static
name|void
name|do_cleaning
parameter_list|(
name|char
modifier|*
name|new_clean_text_base
parameter_list|,
specifier|const
name|char
modifier|*
name|new_clean_text_limit
parameter_list|)
block|{
name|char
modifier|*
name|scan_p
decl_stmt|;
name|int
name|non_whitespace_since_newline
init|=
literal|0
decl_stmt|;
for|for
control|(
name|scan_p
operator|=
name|new_clean_text_base
init|;
name|scan_p
operator|<
name|new_clean_text_limit
condition|;
name|scan_p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|scan_p
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* Handle comments.  */
if|if
condition|(
name|scan_p
index|[
literal|1
index|]
operator|!=
literal|'*'
condition|)
goto|goto
name|regular
goto|;
name|non_whitespace_since_newline
operator|=
literal|1
expr_stmt|;
name|scan_p
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|scan_p
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|scan_p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|scan_p
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|||
name|scan_p
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
block|{
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|scan_p
argument_list|)
condition|)
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
operator|++
name|scan_p
expr_stmt|;
name|gcc_assert
argument_list|(
name|scan_p
operator|<
name|new_clean_text_limit
argument_list|)
expr_stmt|;
block|}
operator|*
name|scan_p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Handle pp directives.  */
if|if
condition|(
name|non_whitespace_since_newline
condition|)
goto|goto
name|regular
goto|;
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|scan_p
index|[
literal|1
index|]
operator|!=
literal|'\n'
operator|||
name|scan_p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|scan_p
argument_list|)
condition|)
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
operator|++
name|scan_p
expr_stmt|;
name|gcc_assert
argument_list|(
name|scan_p
operator|<
name|new_clean_text_limit
argument_list|)
expr_stmt|;
block|}
operator|*
name|scan_p
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* Handle character literals.  */
name|non_whitespace_since_newline
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|scan_p
index|[
literal|1
index|]
operator|!=
literal|'\''
operator|||
name|scan_p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|scan_p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
name|scan_p
index|[
literal|1
index|]
argument_list|)
condition|)
name|scan_p
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|scan_p
argument_list|)
condition|)
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
operator|++
name|scan_p
expr_stmt|;
name|gcc_assert
argument_list|(
name|scan_p
operator|<
name|new_clean_text_limit
argument_list|)
expr_stmt|;
block|}
operator|*
name|scan_p
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
comment|/* Handle string literals.  */
name|non_whitespace_since_newline
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|scan_p
index|[
literal|1
index|]
operator|!=
literal|'"'
operator|||
name|scan_p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|scan_p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
name|scan_p
index|[
literal|1
index|]
argument_list|)
condition|)
name|scan_p
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|scan_p
argument_list|)
condition|)
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
operator|++
name|scan_p
expr_stmt|;
name|gcc_assert
argument_list|(
name|scan_p
operator|<
name|new_clean_text_limit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|scan_p
argument_list|)
condition|)
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
name|scan_p
operator|++
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Handle line continuations.  */
if|if
condition|(
name|scan_p
index|[
literal|1
index|]
operator|!=
literal|'\n'
condition|)
goto|goto
name|regular
goto|;
operator|*
name|scan_p
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|non_whitespace_since_newline
operator|=
literal|0
expr_stmt|;
comment|/* Reset.  */
break|break;
case|case
literal|' '
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\b'
case|:
break|break;
comment|/* Whitespace characters.  */
default|default:
name|regular
label|:
name|non_whitespace_since_newline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to the closing right parenthesis for a particular formals    list (in the clean text buffer) find the corresponding left parenthesis    and return a pointer to it.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|careful_find_l_paren
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|paren_depth
decl_stmt|;
for|for
control|(
name|paren_depth
operator|=
literal|1
operator|,
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|paren_depth
condition|;
name|check_source
argument_list|(
operator|--
name|q
operator|>=
name|clean_text_base
argument_list|,
literal|0
argument_list|)
control|)
block|{
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|')'
case|:
name|paren_depth
operator|++
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|paren_depth
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|++
name|q
return|;
block|}
end_function

begin_comment
comment|/* Scan the clean text buffer for cases of function definitions that we    don't really know about because they were preprocessed out when the    aux info files were created.     In this version of protoize/unprotoize we just give a warning for each    one found.  A later version may be able to at least unprotoize such    missed items.     Note that we may easily find all function definitions simply by    looking for places where there is a left paren which is (ignoring    whitespace) immediately followed by either a left-brace or by an    upper or lower case letter.  Whenever we find this combination, we    have also found a function definition header.     Finding function *declarations* using syntactic clues is much harder.    I will probably try to do this in a later version though.  */
end_comment

begin_function
specifier|static
name|void
name|scan_for_missed_items
parameter_list|(
specifier|const
name|file_info
modifier|*
name|file_p
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|scan_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|limit
init|=
name|clean_text_limit
operator|-
literal|3
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|backup_limit
decl_stmt|;
name|backup_limit
operator|=
name|clean_text_base
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|scan_p
operator|=
name|clean_text_base
init|;
name|scan_p
operator|<
name|limit
condition|;
name|scan_p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|scan_p
operator|==
literal|')'
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|last_r_paren
decl_stmt|;
specifier|const
name|char
modifier|*
name|ahead_p
decl_stmt|;
name|last_r_paren
operator|=
name|scan_p
expr_stmt|;
for|for
control|(
name|ahead_p
operator|=
name|scan_p
operator|+
literal|1
init|;
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|ahead_p
argument_list|)
condition|;
control|)
name|check_source
argument_list|(
operator|++
name|ahead_p
operator|<
name|limit
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|scan_p
operator|=
name|ahead_p
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|ahead_p
argument_list|)
operator|||
operator|*
name|ahead_p
operator|==
literal|'{'
condition|)
block|{
specifier|const
name|char
modifier|*
name|last_l_paren
decl_stmt|;
specifier|const
name|int
name|lineno
init|=
name|identify_lineno
argument_list|(
name|ahead_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|source_confusion_recovery
argument_list|)
condition|)
continue|continue;
comment|/* We know we have a function definition header.  Now skip 	         leftwards over all of its associated formals lists.  */
do|do
block|{
name|last_l_paren
operator|=
name|careful_find_l_paren
argument_list|(
name|last_r_paren
argument_list|)
expr_stmt|;
for|for
control|(
name|last_r_paren
operator|=
name|last_l_paren
operator|-
literal|1
init|;
name|ISSPACE
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|)
operator|*
name|last_r_paren
argument_list|)
condition|;
control|)
name|check_source
argument_list|(
operator|--
name|last_r_paren
operator|>=
name|backup_limit
argument_list|,
name|backup_limit
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|last_r_paren
operator|==
literal|')'
condition|)
do|;
if|if
condition|(
name|is_id_char
argument_list|(
operator|*
name|last_r_paren
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|id_limit
init|=
name|last_r_paren
operator|+
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|id_start
decl_stmt|;
name|size_t
name|id_length
decl_stmt|;
specifier|const
name|def_dec_info
modifier|*
name|dd_p
decl_stmt|;
for|for
control|(
name|id_start
operator|=
name|id_limit
operator|-
literal|1
init|;
name|is_id_char
argument_list|(
operator|*
name|id_start
argument_list|)
condition|;
control|)
name|check_source
argument_list|(
operator|--
name|id_start
operator|>=
name|backup_limit
argument_list|,
name|backup_limit
argument_list|)
expr_stmt|;
name|id_start
operator|++
expr_stmt|;
name|backup_limit
operator|=
name|id_start
expr_stmt|;
if|if
condition|(
operator|(
name|id_length
operator|=
call|(
name|size_t
call|)
argument_list|(
name|id_limit
operator|-
name|id_start
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|not_missed
goto|;
block|{
name|char
modifier|*
name|func_name
init|=
name|alloca
argument_list|(
name|id_length
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|stmt_keywords
index|[]
init|=
block|{
literal|"if"
block|,
literal|"else"
block|,
literal|"do"
block|,
literal|"while"
block|,
literal|"for"
block|,
literal|"switch"
block|,
literal|"case"
block|,
literal|"return"
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|stmt_keyword
decl_stmt|;
name|strncpy
argument_list|(
name|func_name
argument_list|,
name|id_start
argument_list|,
name|id_length
argument_list|)
expr_stmt|;
name|func_name
index|[
name|id_length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We must check here to see if we are actually looking at 		       a statement rather than an actual function call.  */
for|for
control|(
name|stmt_keyword
operator|=
name|stmt_keywords
init|;
operator|*
name|stmt_keyword
condition|;
name|stmt_keyword
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|func_name
argument_list|,
operator|*
name|stmt_keyword
argument_list|)
condition|)
goto|goto
name|not_missed
goto|;
if|#
directive|if
literal|0
block|notice ("%s: found definition of '%s' at %s(%d)\n", 			    pname, 			    func_name, 			    shortpath (NULL, file_p->hash_entry->symbol), 			    identify_lineno (id_start));
endif|#
directive|endif
comment|/* 0 */
comment|/* We really should check for a match of the function name 		       here also, but why bother.  */
for|for
control|(
name|dd_p
operator|=
name|file_p
operator|->
name|defs_decs
init|;
name|dd_p
condition|;
name|dd_p
operator|=
name|dd_p
operator|->
name|next_in_file
control|)
if|if
condition|(
name|dd_p
operator|->
name|is_func_def
operator|&&
name|dd_p
operator|->
name|line
operator|==
name|lineno
condition|)
goto|goto
name|not_missed
goto|;
comment|/* If we make it here, then we did not know about this 		       function definition.  */
name|notice
argument_list|(
literal|"%s: %d: warning: '%s' excluded by preprocessing\n"
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|file_p
operator|->
name|hash_entry
operator|->
name|symbol
argument_list|)
argument_list|,
name|identify_lineno
argument_list|(
name|id_start
argument_list|)
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"%s: function definition not converted\n"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
name|not_missed
label|:
empty_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do all editing operations for a single source file (either a "base" file    or an "include" file).  To do this we read the file into memory, keep a    virgin copy there, make another cleaned in-core copy of the original file    (i.e. one in which all of the comments and preprocessing directives have    been replaced with whitespace), then use these two in-core copies of the    file to make a new edited in-core copy of the file.  Finally, rename the    original file (as a way of saving it), and then write the edited version    of the file from core to a disk file of the same name as the original.     Note that the trick of making a copy of the original sans comments&    preprocessing directives make the editing a whole lot easier.  */
end_comment

begin_function
specifier|static
name|void
name|edit_file
parameter_list|(
specifier|const
name|hash_table_entry
modifier|*
name|hp
parameter_list|)
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
specifier|const
name|file_info
modifier|*
name|file_p
init|=
name|hp
operator|->
name|fip
decl_stmt|;
name|char
modifier|*
name|new_orig_text_base
decl_stmt|;
name|char
modifier|*
name|new_orig_text_limit
decl_stmt|;
name|char
modifier|*
name|new_clean_text_base
decl_stmt|;
name|char
modifier|*
name|new_clean_text_limit
decl_stmt|;
name|size_t
name|orig_size
decl_stmt|;
name|size_t
name|repl_size
decl_stmt|;
name|int
name|first_definition_in_file
decl_stmt|;
comment|/* If we are not supposed to be converting this file, or if there is      nothing in there which needs converting, just skip this file.  */
if|if
condition|(
operator|!
name|needs_to_be_converted
argument_list|(
name|file_p
argument_list|)
condition|)
return|return;
name|convert_filename
operator|=
name|file_p
operator|->
name|hash_entry
operator|->
name|symbol
expr_stmt|;
comment|/* Convert a file if it is in a directory where we want conversion      and the file is not excluded.  */
if|if
condition|(
operator|!
name|directory_specified_p
argument_list|(
name|convert_filename
argument_list|)
operator|||
name|file_excluded_p
argument_list|(
name|convert_filename
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
ifdef|#
directive|ifdef
name|UNPROTOIZE
comment|/* Don't even mention "system" include files unless we are 	     protoizing.  If we are protoizing, we mention these as a 	     gentle way of prodding the user to convert his "system" 	     include files to prototype format.  */
operator|&&
operator|!
name|in_system_include_dir
argument_list|(
name|convert_filename
argument_list|)
endif|#
directive|endif
comment|/* defined (UNPROTOIZE) */
condition|)
name|notice
argument_list|(
literal|"%s: '%s' not converted\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Let the user know what we are up to.  */
if|if
condition|(
name|nochange_flag
condition|)
name|notice
argument_list|(
literal|"%s: would convert file '%s'\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"%s: converting file '%s'\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Find out the size (in bytes) of the original file.  */
comment|/* The cast avoids an erroneous warning on AIX.  */
if|if
condition|(
name|stat
argument_list|(
name|convert_filename
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't get status for file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|orig_size
operator|=
name|stat_buf
operator|.
name|st_size
expr_stmt|;
comment|/* Allocate a buffer to hold the original text.  */
name|orig_text_base
operator|=
name|new_orig_text_base
operator|=
name|xmalloc
argument_list|(
name|orig_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|orig_text_limit
operator|=
name|new_orig_text_limit
operator|=
name|new_orig_text_base
operator|+
name|orig_size
expr_stmt|;
comment|/* Allocate a buffer to hold the cleaned-up version of the original text.  */
name|clean_text_base
operator|=
name|new_clean_text_base
operator|=
name|xmalloc
argument_list|(
name|orig_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|clean_text_limit
operator|=
name|new_clean_text_limit
operator|=
name|new_clean_text_base
operator|+
name|orig_size
expr_stmt|;
name|clean_read_ptr
operator|=
name|clean_text_base
operator|-
literal|1
expr_stmt|;
comment|/* Allocate a buffer that will hopefully be large enough to hold the entire      converted output text.  As an initial guess for the maximum size of the      output buffer, use 125% of the size of the original + some extra.  This      buffer can be expanded later as needed.  */
name|repl_size
operator|=
name|orig_size
operator|+
operator|(
name|orig_size
operator|>>
literal|2
operator|)
operator|+
literal|4096
expr_stmt|;
name|repl_text_base
operator|=
name|xmalloc
argument_list|(
name|repl_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|repl_text_limit
operator|=
name|repl_text_base
operator|+
name|repl_size
operator|-
literal|1
expr_stmt|;
name|repl_write_ptr
operator|=
name|repl_text_base
operator|-
literal|1
expr_stmt|;
block|{
name|int
name|input_file
decl_stmt|;
name|int
name|fd_flags
decl_stmt|;
comment|/* Open the file to be converted in READ ONLY mode.  */
name|fd_flags
operator|=
name|O_RDONLY
expr_stmt|;
ifdef|#
directive|ifdef
name|O_BINARY
comment|/* Use binary mode to avoid having to deal with different EOL characters.  */
name|fd_flags
operator||=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|input_file
operator|=
name|open
argument_list|(
name|convert_filename
argument_list|,
name|fd_flags
argument_list|,
literal|0444
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't open file '%s' for reading: %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read the entire original source text file into the original text buffer        in one swell fwoop.  Then figure out where the end of the text is and        make sure that it ends with a newline followed by a null.  */
if|if
condition|(
name|safe_read
argument_list|(
name|input_file
argument_list|,
name|new_orig_text_base
argument_list|,
name|orig_size
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|orig_size
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|close
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"\n%s: error reading input file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|close
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|orig_size
operator|==
literal|0
operator|||
name|orig_text_limit
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|new_orig_text_limit
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|orig_text_limit
operator|++
expr_stmt|;
block|}
comment|/* Create the cleaned up copy of the original text.  */
name|memcpy
argument_list|(
name|new_clean_text_base
argument_list|,
name|orig_text_base
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|orig_text_limit
operator|-
name|orig_text_base
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleaning
argument_list|(
name|new_clean_text_base
argument_list|,
name|new_clean_text_limit
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{     int clean_file;     size_t clean_size = orig_text_limit - orig_text_base;     char *const clean_filename = alloca (strlen (convert_filename) + 6 + 1);
comment|/* Open (and create) the clean file.  */
block|strcpy (clean_filename, convert_filename);     strcat (clean_filename, ".clean");     if ((clean_file = creat (clean_filename, 0666)) == -1)       { 	int errno_val = errno; 	notice ("%s: can't create/open clean file '%s': %s\n", 		pname, shortpath (NULL, clean_filename), 		xstrerror (errno_val)); 	return;       }
comment|/* Write the clean file.  */
block|safe_write (clean_file, new_clean_text_base, clean_size, clean_filename);      close (clean_file);   }
endif|#
directive|endif
comment|/* 0 */
comment|/* Do a simplified scan of the input looking for things that were not      mentioned in the aux info files because of the fact that they were      in a region of the source which was preprocessed-out (via #if or      via #ifdef).  */
name|scan_for_missed_items
argument_list|(
name|file_p
argument_list|)
expr_stmt|;
comment|/* Setup to do line-oriented forward seeking in the clean text buffer.  */
name|last_known_line_number
operator|=
literal|1
expr_stmt|;
name|last_known_line_start
operator|=
name|clean_text_base
expr_stmt|;
comment|/* Now get down to business and make all of the necessary edits.  */
block|{
specifier|const
name|def_dec_info
modifier|*
name|def_dec_p
decl_stmt|;
name|first_definition_in_file
operator|=
literal|1
expr_stmt|;
name|def_dec_p
operator|=
name|file_p
operator|->
name|defs_decs
expr_stmt|;
for|for
control|(
init|;
name|def_dec_p
condition|;
name|def_dec_p
operator|=
name|def_dec_p
operator|->
name|next_in_file
control|)
block|{
specifier|const
name|char
modifier|*
name|clean_text_p
init|=
name|seek_to_line
argument_list|(
name|def_dec_p
operator|->
name|line
argument_list|)
decl_stmt|;
comment|/* clean_text_p now points to the first character of the line which 	   contains the `terminator' for the declaration or definition that 	   we are about to process.  */
ifndef|#
directive|ifndef
name|UNPROTOIZE
if|if
condition|(
name|global_flag
operator|&&
name|def_dec_p
operator|->
name|is_func_def
operator|&&
name|first_definition_in_file
condition|)
block|{
name|add_global_decls
argument_list|(
name|def_dec_p
operator|->
name|file
argument_list|,
name|clean_text_p
argument_list|)
expr_stmt|;
name|first_definition_in_file
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't edit this item if it is already in prototype format or if it 	   is a function declaration and we have found no corresponding 	   definition.  */
if|if
condition|(
name|def_dec_p
operator|->
name|prototyped
operator|||
operator|(
operator|!
name|def_dec_p
operator|->
name|is_func_def
operator|&&
operator|!
name|def_dec_p
operator|->
name|definition
operator|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
if|if
condition|(
name|def_dec_p
operator|->
name|is_func_def
condition|)
name|edit_fn_definition
argument_list|(
name|def_dec_p
argument_list|,
name|clean_text_p
argument_list|)
expr_stmt|;
elseif|else
ifndef|#
directive|ifndef
name|UNPROTOIZE
if|if
condition|(
name|def_dec_p
operator|->
name|is_implicit
condition|)
name|add_local_decl
argument_list|(
name|def_dec_p
argument_list|,
name|clean_text_p
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
name|edit_fn_declaration
argument_list|(
name|def_dec_p
argument_list|,
name|clean_text_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finalize things.  Output the last trailing part of the original text.  */
name|output_up_to
argument_list|(
name|clean_text_limit
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is just a test run, stop now and just deallocate the buffers.  */
if|if
condition|(
name|nochange_flag
condition|)
block|{
name|free
argument_list|(
name|new_orig_text_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_clean_text_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repl_text_base
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Change the name of the original input file.  This is just a quick way of      saving the original file.  */
if|if
condition|(
operator|!
name|nosave_flag
condition|)
block|{
name|char
modifier|*
name|new_filename
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|convert_filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|save_suffix
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|new_filename
argument_list|,
name|convert_filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
comment|/* MSDOS filenames are restricted to 8.3 format, so we save `foo.c' 	 as `foo.<save_suffix>'.  */
name|new_filename
index|[
operator|(
name|strlen
argument_list|(
name|convert_filename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|new_filename
argument_list|,
name|save_suffix
argument_list|)
expr_stmt|;
comment|/* Don't overwrite existing file.  */
if|if
condition|(
name|access
argument_list|(
name|new_filename
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|notice
argument_list|(
literal|"%s: warning: file '%s' already saved in '%s'\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|new_filename
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rename
argument_list|(
name|convert_filename
argument_list|,
name|new_filename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't link file '%s' to '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|new_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|unlink
argument_list|(
name|convert_filename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
comment|/* The file may have already been renamed.  */
if|if
condition|(
name|errno_val
operator|!=
name|ENOENT
condition|)
block|{
name|notice
argument_list|(
literal|"%s: can't delete file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|{
name|int
name|output_file
decl_stmt|;
comment|/* Open (and create) the output file.  */
if|if
condition|(
operator|(
name|output_file
operator|=
name|creat
argument_list|(
name|convert_filename
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't create/open output file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|O_BINARY
comment|/* Use binary mode to avoid changing the existing EOL character.  */
name|setmode
argument_list|(
name|output_file
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Write the output file.  */
block|{
name|unsigned
name|int
name|out_size
init|=
operator|(
name|repl_write_ptr
operator|+
literal|1
operator|)
operator|-
name|repl_text_base
decl_stmt|;
name|safe_write
argument_list|(
name|output_file
argument_list|,
name|repl_text_base
argument_list|,
name|out_size
argument_list|,
name|convert_filename
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
block|}
comment|/* Deallocate the conversion buffers.  */
name|free
argument_list|(
name|new_orig_text_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_clean_text_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repl_text_base
argument_list|)
expr_stmt|;
comment|/* Change the mode of the output file to match the original file.  */
comment|/* The cast avoids an erroneous warning on AIX.  */
if|if
condition|(
name|chmod
argument_list|(
name|convert_filename
argument_list|,
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|errno_val
init|=
name|errno
decl_stmt|;
name|notice
argument_list|(
literal|"%s: can't change mode of file '%s': %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|convert_filename
argument_list|)
argument_list|,
name|xstrerror
argument_list|(
name|errno_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Note:  We would try to change the owner and group of the output file      to match those of the input file here, except that may not be a good      thing to do because it might be misleading.  Also, it might not even      be possible to do that (on BSD systems with quotas for instance).  */
block|}
end_function

begin_comment
comment|/* Do all of the individual steps needed to do the protoization (or    unprotoization) of the files referenced in the aux_info files given    in the command line.  */
end_comment

begin_function
specifier|static
name|void
name|do_processing
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|base_pp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
specifier|const
name|end_pps
init|=
operator|&
name|base_source_filenames
index|[
name|n_base_source_files
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
name|int
name|syscalls_len
decl_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
comment|/* One-by-one, check (and create if necessary), open, and read all of the      stuff in each aux_info file.  After reading each aux_info file, the      aux_info_file just read will be automatically deleted unless the      keep_flag is set.  */
for|for
control|(
name|base_pp
operator|=
name|base_source_filenames
init|;
name|base_pp
operator|<
name|end_pps
condition|;
name|base_pp
operator|++
control|)
name|process_aux_info_file
argument_list|(
operator|*
name|base_pp
argument_list|,
name|keep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
comment|/* Also open and read the special SYSCALLS.c aux_info file which gives us      the prototypes for all of the standard system-supplied functions.  */
if|if
condition|(
name|nondefault_syscalls_dir
condition|)
block|{
name|syscalls_absolute_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|nondefault_syscalls_dir
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|syscalls_filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|syscalls_absolute_filename
argument_list|,
name|nondefault_syscalls_dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_ENVIRONMENT
argument_list|(
name|default_syscalls_dir
argument_list|,
literal|"GCC_EXEC_PREFIX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|default_syscalls_dir
condition|)
block|{
name|default_syscalls_dir
operator|=
name|standard_exec_prefix
expr_stmt|;
block|}
name|syscalls_absolute_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|default_syscalls_dir
argument_list|)
operator|+
literal|0
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|target_version
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|syscalls_filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|syscalls_absolute_filename
argument_list|,
name|default_syscalls_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|syscalls_absolute_filename
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|syscalls_absolute_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|syscalls_absolute_filename
argument_list|,
name|target_version
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|syscalls_absolute_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|syscalls_len
operator|=
name|strlen
argument_list|(
name|syscalls_absolute_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
operator|(
name|syscalls_absolute_filename
operator|+
name|syscalls_len
operator|-
literal|1
operator|)
argument_list|)
condition|)
block|{
operator|*
operator|(
name|syscalls_absolute_filename
operator|+
name|syscalls_len
operator|++
operator|)
operator|=
name|DIR_SEPARATOR
expr_stmt|;
operator|*
operator|(
name|syscalls_absolute_filename
operator|+
name|syscalls_len
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcat
argument_list|(
name|syscalls_absolute_filename
argument_list|,
name|syscalls_filename
argument_list|)
expr_stmt|;
comment|/* Call process_aux_info_file in such a way that it does not try to      delete the SYSCALLS aux_info file.  */
name|process_aux_info_file
argument_list|(
name|syscalls_absolute_filename
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
comment|/* When we first read in all of the information from the aux_info files      we saved in it descending line number order, because that was likely to      be faster.  Now however, we want the chains of def& dec records to      appear in ascending line number order as we get further away from the      file_info record that they hang from.  The following line causes all of      these lists to be rearranged into ascending line number order.  */
name|visit_each_hash_node
argument_list|(
name|filename_primary
argument_list|,
name|reverse_def_dec_list
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
comment|/* Now do the "real" work.  The following line causes each declaration record      to be "visited".  For each of these nodes, an attempt is made to match      up the function declaration with a corresponding function definition,      which should have a full prototype-format formals list with it.  Once      these match-ups are made, the conversion of the function declarations      to prototype format can be made.  */
name|visit_each_hash_node
argument_list|(
name|function_name_primary
argument_list|,
name|connect_defs_and_decs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
comment|/* Now convert each file that can be converted (and needs to be).  */
name|visit_each_hash_node
argument_list|(
name|filename_primary
argument_list|,
name|edit_file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNPROTOIZE
comment|/* If we are working in cplusplus mode, try to rename all .c files to .C      files.  Don't panic if some of the renames don't work.  */
if|if
condition|(
name|cplusplus_flag
operator|&&
operator|!
name|nochange_flag
condition|)
name|visit_each_hash_node
argument_list|(
name|filename_primary
argument_list|,
name|rename_c_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"file_name"
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
block|{
literal|"silent"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
block|{
literal|"force"
block|,
literal|0
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"keep"
block|,
literal|0
block|,
literal|0
block|,
literal|'k'
block|}
block|,
block|{
literal|"nosave"
block|,
literal|0
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"nochange"
block|,
literal|0
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"compiler-options"
block|,
literal|1
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"exclude"
block|,
literal|1
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"directory"
block|,
literal|1
block|,
literal|0
block|,
literal|'d'
block|}
block|,
ifdef|#
directive|ifdef
name|UNPROTOIZE
block|{
literal|"indent"
block|,
literal|1
block|,
literal|0
block|,
literal|'i'
block|}
block|,
else|#
directive|else
block|{
literal|"local"
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"global"
block|,
literal|0
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"c++"
block|,
literal|0
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"syscalls-dir"
block|,
literal|1
block|,
literal|0
block|,
literal|'B'
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
specifier|const
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
specifier|const
name|argv
parameter_list|)
block|{
name|int
name|longind
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|params
init|=
literal|""
decl_stmt|;
name|pname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|pname
condition|?
name|pname
else|:
name|argv
index|[
literal|0
index|]
argument_list|,
name|DIR_SEPARATOR_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|pname
operator|=
name|slash
expr_stmt|;
block|}
endif|#
directive|endif
name|pname
operator|=
name|pname
condition|?
name|pname
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* We *MUST* set SIGCHLD to SIG_DFL so that the wait4() call will      receive the signal.  A different setting is inheritable */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Unlock the stdio streams.  */
name|unlock_std_streams
argument_list|()
expr_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
name|cwd_buffer
operator|=
name|getpwd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cwd_buffer
condition|)
block|{
name|notice
argument_list|(
literal|"%s: cannot get working directory: %s\n"
argument_list|,
name|pname
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
block|}
comment|/* By default, convert the files in the current directory.  */
name|directory_list
operator|=
name|string_list_cons
argument_list|(
name|cwd_buffer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
ifdef|#
directive|ifdef
name|UNPROTOIZE
literal|"c:d:i:knNp:qvVx:"
argument_list|,
else|#
directive|else
literal|"B:c:Cd:gklnNp:qvVx:"
argument_list|,
endif|#
directive|endif
name|longopts
argument_list|,
operator|&
name|longind
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|/* Long option.  */
name|c
operator|=
name|longopts
index|[
name|longind
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|compiler_file_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|directory_list
operator|=
name|string_list_cons
argument_list|(
name|abspath
argument_list|(
name|NULL
argument_list|,
name|optarg
argument_list|)
argument_list|,
name|directory_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|exclude_list
operator|=
name|string_list_cons
argument_list|(
name|optarg
argument_list|,
name|exclude_list
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|version_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet_flag
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 'f': 	  force_flag = 1; 	  break;
endif|#
directive|endif
case|case
literal|'n'
case|:
name|nochange_flag
operator|=
literal|1
expr_stmt|;
name|keep_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|nosave_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keep_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|params
operator|=
name|optarg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|UNPROTOIZE
case|case
literal|'i'
case|:
name|indent_string
operator|=
name|optarg
expr_stmt|;
break|break;
else|#
directive|else
comment|/* !defined (UNPROTOIZE) */
case|case
literal|'l'
case|:
name|local_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|global_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|cplusplus_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|nondefault_syscalls_dir
operator|=
name|optarg
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Set up compile_params based on -p and -c options.  */
name|munge_compile_params
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|n_base_source_files
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
comment|/* Now actually make a list of the base source filenames.  */
name|base_source_filenames
operator|=
name|xmalloc
argument_list|(
operator|(
name|n_base_source_files
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|n_base_source_files
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|abspath
argument_list|(
name|NULL
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|path
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
name|base_source_filenames
index|[
name|n_base_source_files
operator|++
index|]
operator|=
name|path
expr_stmt|;
else|else
block|{
name|notice
argument_list|(
literal|"%s: input file names must have .c suffixes: %s\n"
argument_list|,
name|pname
argument_list|,
name|shortpath
argument_list|(
name|NULL
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|UNPROTOIZE
comment|/* We are only interested in the very first identifier token in the      definition of `va_list', so if there is more junk after that first      identifier token, delete it from the `varargs_style_indicator'.  */
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|varargs_style_indicator
init|;
name|ISIDNUM
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0
condition|)
name|varargs_style_indicator
operator|=
name|savestring
argument_list|(
name|varargs_style_indicator
argument_list|,
name|cp
operator|-
name|varargs_style_indicator
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined (UNPROTOIZE) */
if|if
condition|(
name|errors
condition|)
name|usage
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|version_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|pname
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|do_processing
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

