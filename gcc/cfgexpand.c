begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A pass for lowering trees to RTL.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* Verify that there is exactly single jump instruction since last and attach    REG_BR_PROB note specifying probability.    ??? We really ought to pass the probability down to RTL expanders and let it    re-distribute it when the conditional expands into multiple conditionals.    This is however difficult to do.  */
end_comment

begin_function
specifier|static
name|void
name|add_reg_br_prob_note
parameter_list|(
name|rtx
name|last
parameter_list|,
name|int
name|probability
parameter_list|)
block|{
if|if
condition|(
name|profile_status
operator|==
name|PROFILE_ABSENT
condition|)
return|return;
for|for
control|(
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
init|;
name|last
operator|&&
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|JUMP_P
argument_list|(
name|last
argument_list|)
condition|)
block|{
comment|/* It is common to emit condjump-around-jump sequence when we don't know 	   how to reverse the conditional.  Special case this.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|last
argument_list|)
operator|||
operator|!
name|JUMP_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|||
operator|!
name|simplejump_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|||
operator|!
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|||
operator|!
name|BARRIER_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|!
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|!
name|LABEL_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|||
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|gcc_assert
argument_list|(
operator|!
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|last
operator|||
operator|!
name|JUMP_P
argument_list|(
name|last
argument_list|)
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|last
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|gcc_assert
argument_list|(
operator|!
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|failed
label|:
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Failed to add probability note\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|LOCAL_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|LOCAL_ALIGNMENT
parameter_list|(
name|TYPE
parameter_list|,
name|ALIGNMENT
parameter_list|)
value|ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_ALIGNMENT_NEEDED
end_ifndef

begin_define
define|#
directive|define
name|STACK_ALIGNMENT_NEEDED
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure holds data relevant to one variable that will be    placed in a stack slot.  */
end_comment

begin_struct
struct|struct
name|stack_var
block|{
comment|/* The Variable.  */
name|tree
name|decl
decl_stmt|;
comment|/* The offset of the variable.  During partitioning, this is the      offset relative to the partition.  After partitioning, this      is relative to the stack frame.  */
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* Initially, the size of the variable.  Later, the size of the partition,      if this variable becomes it's partition's representative.  */
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* The *byte* alignment required for this variable.  Or as, with the      size, the alignment for this partition.  */
name|unsigned
name|int
name|alignb
decl_stmt|;
comment|/* The partition representative.  */
name|size_t
name|representative
decl_stmt|;
comment|/* The next stack variable in the partition, or EOC.  */
name|size_t
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EOC
value|((size_t)-1)
end_define

begin_comment
comment|/* We have an array of such objects while deciding allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stack_var
modifier|*
name|stack_vars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|stack_vars_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|stack_vars_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of indicies such that stack_vars[stack_vars_sorted[i]].size    is non-decreasing.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
modifier|*
name|stack_vars_sorted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We have an interference graph between such objects.  This graph    is lower triangular.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
modifier|*
name|stack_vars_conflict
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|stack_vars_conflict_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The phase of the stack frame.  This is the known misalignment of    virtual_stack_vars_rtx from PREFERRED_STACK_BOUNDARY.  That is,    (frame_offset+frame_phase) % PREFERRED_STACK_BOUNDARY == 0.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frame_phase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used during expand_used_vars to remember if we saw any decls for    which we'd like to enable stack smashing protection.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|has_protected_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used during expand_used_vars.  Remember if we say a character buffer    smaller than our cutoff threshold.  Used for -Wstack-protector.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|has_short_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Discover the byte alignment to use for DECL.  Ignore alignment    we can't do with expected alignment of the stack boundary.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_decl_align_unit
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|align
operator|=
name|LOCAL_ALIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|PREFERRED_STACK_BOUNDARY
condition|)
name|align
operator|=
name|PREFERRED_STACK_BOUNDARY
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|stack_alignment_needed
operator|<
name|align
condition|)
name|cfun
operator|->
name|stack_alignment_needed
operator|=
name|align
expr_stmt|;
return|return
name|align
operator|/
name|BITS_PER_UNIT
return|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes at byte alignment ALIGN from the stack frame.    Return the frame offset.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|alloc_stack_frame_space
parameter_list|(
name|HOST_WIDE_INT
name|size
parameter_list|,
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|new_frame_offset
decl_stmt|;
name|new_frame_offset
operator|=
name|frame_offset
expr_stmt|;
if|if
condition|(
name|FRAME_GROWS_DOWNWARD
condition|)
block|{
name|new_frame_offset
operator|-=
name|size
operator|+
name|frame_phase
expr_stmt|;
name|new_frame_offset
operator|&=
operator|-
name|align
expr_stmt|;
name|new_frame_offset
operator|+=
name|frame_phase
expr_stmt|;
name|offset
operator|=
name|new_frame_offset
expr_stmt|;
block|}
else|else
block|{
name|new_frame_offset
operator|-=
name|frame_phase
expr_stmt|;
name|new_frame_offset
operator|+=
name|align
operator|-
literal|1
expr_stmt|;
name|new_frame_offset
operator|&=
operator|-
name|align
expr_stmt|;
name|new_frame_offset
operator|+=
name|frame_phase
expr_stmt|;
name|offset
operator|=
name|new_frame_offset
expr_stmt|;
name|new_frame_offset
operator|+=
name|size
expr_stmt|;
block|}
name|frame_offset
operator|=
name|new_frame_offset
expr_stmt|;
if|if
condition|(
name|frame_offset_overflow
argument_list|(
name|frame_offset
argument_list|,
name|cfun
operator|->
name|decl
argument_list|)
condition|)
name|frame_offset
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Accumulate DECL into STACK_VARS.  */
end_comment

begin_function
specifier|static
name|void
name|add_stack_var
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|stack_vars_num
operator|>=
name|stack_vars_alloc
condition|)
block|{
if|if
condition|(
name|stack_vars_alloc
condition|)
name|stack_vars_alloc
operator|=
name|stack_vars_alloc
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
else|else
name|stack_vars_alloc
operator|=
literal|32
expr_stmt|;
name|stack_vars
operator|=
name|XRESIZEVEC
argument_list|(
expr|struct
name|stack_var
argument_list|,
name|stack_vars
argument_list|,
name|stack_vars_alloc
argument_list|)
expr_stmt|;
block|}
name|stack_vars
index|[
name|stack_vars_num
index|]
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
name|stack_vars
index|[
name|stack_vars_num
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|stack_vars
index|[
name|stack_vars_num
index|]
operator|.
name|size
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stack_vars
index|[
name|stack_vars_num
index|]
operator|.
name|alignb
operator|=
name|get_decl_align_unit
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* All variables are initially in their own partition.  */
name|stack_vars
index|[
name|stack_vars_num
index|]
operator|.
name|representative
operator|=
name|stack_vars_num
expr_stmt|;
name|stack_vars
index|[
name|stack_vars_num
index|]
operator|.
name|next
operator|=
name|EOC
expr_stmt|;
comment|/* Ensure that this decl doesn't get put onto the list twice.  */
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|stack_vars_num
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the linear index of a lower-triangular coordinate (I, J).  */
end_comment

begin_function
specifier|static
name|size_t
name|triangular_index
parameter_list|(
name|size_t
name|i
parameter_list|,
name|size_t
name|j
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|j
condition|)
block|{
name|size_t
name|t
decl_stmt|;
name|t
operator|=
name|i
operator|,
name|i
operator|=
name|j
operator|,
name|j
operator|=
name|t
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
operator|/
literal|2
operator|+
name|j
return|;
block|}
end_function

begin_comment
comment|/* Ensure that STACK_VARS_CONFLICT is large enough for N objects.  */
end_comment

begin_function
specifier|static
name|void
name|resize_stack_vars_conflict
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|size
init|=
name|triangular_index
argument_list|(
name|n
operator|-
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|size
operator|<=
name|stack_vars_conflict_alloc
condition|)
return|return;
name|stack_vars_conflict
operator|=
name|XRESIZEVEC
argument_list|(
name|bool
argument_list|,
name|stack_vars_conflict
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stack_vars_conflict
operator|+
name|stack_vars_conflict_alloc
argument_list|,
literal|0
argument_list|,
operator|(
name|size
operator|-
name|stack_vars_conflict_alloc
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
name|stack_vars_conflict_alloc
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the decls associated with luid's X and Y conflict.  */
end_comment

begin_function
specifier|static
name|void
name|add_stack_var_conflict
parameter_list|(
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|)
block|{
name|size_t
name|index
init|=
name|triangular_index
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|index
operator|<
name|stack_vars_conflict_alloc
argument_list|)
expr_stmt|;
name|stack_vars_conflict
index|[
name|index
index|]
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether the decls associated with luid's X and Y conflict.  */
end_comment

begin_function
specifier|static
name|bool
name|stack_var_conflict_p
parameter_list|(
name|size_t
name|x
parameter_list|,
name|size_t
name|y
parameter_list|)
block|{
name|size_t
name|index
init|=
name|triangular_index
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|index
operator|<
name|stack_vars_conflict_alloc
argument_list|)
expr_stmt|;
return|return
name|stack_vars_conflict
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Returns true if TYPE is or contains a union type.  */
end_comment

begin_function
specifier|static
name|bool
name|aggregate_contains_union_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|aggregate_contains_union_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
name|false
return|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
if|if
condition|(
name|aggregate_contains_union_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_used_vars.  If two variables X and Y have alias    sets that do not conflict, then do add a conflict for these variables    in the interference graph.  We also need to make sure to add conflicts    for union containing structures.  Else RTL alias analysis comes along    and due to type based aliasing rules decides that for two overlapping    union temporaries { short s; int i; } accesses to the same mem through    different types may not alias and happily reorders stores across    life-time boundaries of the temporaries (See PR25654).    We also have to mind MEM_IN_STRUCT_P and MEM_SCALAR_P.  */
end_comment

begin_function
specifier|static
name|void
name|add_alias_set_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
name|stack_vars_num
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|type_i
init|=
name|TREE_TYPE
argument_list|(
name|stack_vars
index|[
name|i
index|]
operator|.
name|decl
argument_list|)
decl_stmt|;
name|bool
name|aggr_i
init|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type_i
argument_list|)
decl_stmt|;
name|bool
name|contains_union
decl_stmt|;
name|contains_union
operator|=
name|aggregate_contains_union_type
argument_list|(
name|type_i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
name|tree
name|type_j
init|=
name|TREE_TYPE
argument_list|(
name|stack_vars
index|[
name|j
index|]
operator|.
name|decl
argument_list|)
decl_stmt|;
name|bool
name|aggr_j
init|=
name|AGGREGATE_TYPE_P
argument_list|(
name|type_j
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggr_i
operator|!=
name|aggr_j
comment|/* Either the objects conflict by means of type based 		 aliasing rules, or we need to add a conflict.  */
operator|||
operator|!
name|objects_must_conflict_p
argument_list|(
name|type_i
argument_list|,
name|type_j
argument_list|)
comment|/* In case the types do not conflict ensure that access 		 to elements will conflict.  In case of unions we have 		 to be careful as type based aliasing rules may say 		 access to the same memory does not conflict.  So play 		 safe and add a conflict in this case.  */
operator|||
name|contains_union
condition|)
name|add_stack_var_conflict
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of partition_stack_vars.  A comparison function for qsort,    sorting an array of indicies by the size of the object.  */
end_comment

begin_function
specifier|static
name|int
name|stack_var_size_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|HOST_WIDE_INT
name|sa
init|=
name|stack_vars
index|[
operator|*
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|a
index|]
operator|.
name|size
decl_stmt|;
name|HOST_WIDE_INT
name|sb
init|=
name|stack_vars
index|[
operator|*
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|b
index|]
operator|.
name|size
decl_stmt|;
name|unsigned
name|int
name|uida
init|=
name|DECL_UID
argument_list|(
name|stack_vars
index|[
operator|*
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|a
index|]
operator|.
name|decl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|uidb
init|=
name|DECL_UID
argument_list|(
name|stack_vars
index|[
operator|*
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|b
index|]
operator|.
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|sa
operator|<
name|sb
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sa
operator|>
name|sb
condition|)
return|return
literal|1
return|;
comment|/* For stack variables of the same size use the uid of the decl      to make the sort stable.  */
if|if
condition|(
name|uida
operator|<
name|uidb
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|uida
operator|>
name|uidb
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of partition_stack_vars.  The UNION portion of a UNION/FIND    partitioning algorithm.  Partitions A and B are known to be non-conflicting.    Merge them into a single partition A.     At the same time, add OFFSET to all variables in partition B.  At the end    of the partitioning process we've have a nice block easy to lay out within    the stack frame.  */
end_comment

begin_function
specifier|static
name|void
name|union_stack_vars
parameter_list|(
name|size_t
name|a
parameter_list|,
name|size_t
name|b
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|last
decl_stmt|;
comment|/* Update each element of partition B with the given offset,      and merge them into partition A.  */
for|for
control|(
name|last
operator|=
name|i
operator|=
name|b
init|;
name|i
operator|!=
name|EOC
condition|;
name|last
operator|=
name|i
operator|,
name|i
operator|=
name|stack_vars
index|[
name|i
index|]
operator|.
name|next
control|)
block|{
name|stack_vars
index|[
name|i
index|]
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
name|stack_vars
index|[
name|i
index|]
operator|.
name|representative
operator|=
name|a
expr_stmt|;
block|}
name|stack_vars
index|[
name|last
index|]
operator|.
name|next
operator|=
name|stack_vars
index|[
name|a
index|]
operator|.
name|next
expr_stmt|;
name|stack_vars
index|[
name|a
index|]
operator|.
name|next
operator|=
name|b
expr_stmt|;
comment|/* Update the required alignment of partition A to account for B.  */
if|if
condition|(
name|stack_vars
index|[
name|a
index|]
operator|.
name|alignb
operator|<
name|stack_vars
index|[
name|b
index|]
operator|.
name|alignb
condition|)
name|stack_vars
index|[
name|a
index|]
operator|.
name|alignb
operator|=
name|stack_vars
index|[
name|b
index|]
operator|.
name|alignb
expr_stmt|;
comment|/* Update the interference graph and merge the conflicts.  */
for|for
control|(
name|last
operator|=
name|stack_vars_num
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|stack_var_conflict_p
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
condition|)
name|add_stack_var_conflict
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_used_vars.  Binpack the variables into    partitions constrained by the interference graph.  The overall    algorithm used is as follows:  	Sort the objects by size. 	For each object A { 	  S = size(A) 	  O = 0 	  loop { 	    Look for the largest non-conflicting object B with size<= S. 	    UNION (A, B) 	    offset(B) = O 	    O += size(B) 	    S -= size(B) 	  } 	} */
end_comment

begin_function
specifier|static
name|void
name|partition_stack_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|si
decl_stmt|,
name|sj
decl_stmt|,
name|n
init|=
name|stack_vars_num
decl_stmt|;
name|stack_vars_sorted
operator|=
name|XNEWVEC
argument_list|(
name|size_t
argument_list|,
name|stack_vars_num
argument_list|)
expr_stmt|;
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|n
condition|;
operator|++
name|si
control|)
name|stack_vars_sorted
index|[
name|si
index|]
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return;
name|qsort
argument_list|(
name|stack_vars_sorted
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|stack_var_size_cmp
argument_list|)
expr_stmt|;
comment|/* Special case: detect when all variables conflict, and thus we can't      do anything during the partitioning loop.  It isn't uncommon (with      C code at least) to declare all variables at the top of the function,      and if we're not inlining, then all variables will be in the same scope.      Take advantage of very fast libc routines for this scan.  */
name|gcc_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memchr
argument_list|(
name|stack_vars_conflict
argument_list|,
name|false
argument_list|,
name|stack_vars_conflict_alloc
argument_list|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|n
condition|;
operator|++
name|si
control|)
block|{
name|size_t
name|i
init|=
name|stack_vars_sorted
index|[
name|si
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|isize
init|=
name|stack_vars
index|[
name|i
index|]
operator|.
name|size
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sj
operator|=
name|si
init|;
name|sj
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|size_t
name|j
init|=
name|stack_vars_sorted
index|[
name|sj
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|jsize
init|=
name|stack_vars
index|[
name|j
index|]
operator|.
name|size
decl_stmt|;
name|unsigned
name|int
name|jalign
init|=
name|stack_vars
index|[
name|j
index|]
operator|.
name|alignb
decl_stmt|;
comment|/* Ignore objects that aren't partition representatives.  */
if|if
condition|(
name|stack_vars
index|[
name|j
index|]
operator|.
name|representative
operator|!=
name|j
condition|)
continue|continue;
comment|/* Ignore objects too large for the remaining space.  */
if|if
condition|(
name|isize
operator|<
name|jsize
condition|)
continue|continue;
comment|/* Ignore conflicting objects.  */
if|if
condition|(
name|stack_var_conflict_p
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
condition|)
continue|continue;
comment|/* Refine the remaining space check to include alignment.  */
if|if
condition|(
name|offset
operator|&
operator|(
name|jalign
operator|-
literal|1
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|toff
init|=
name|offset
decl_stmt|;
name|toff
operator|+=
name|jalign
operator|-
literal|1
expr_stmt|;
name|toff
operator|&=
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|jalign
expr_stmt|;
if|if
condition|(
name|isize
operator|-
operator|(
name|toff
operator|-
name|offset
operator|)
operator|<
name|jsize
condition|)
continue|continue;
name|isize
operator|-=
name|toff
operator|-
name|offset
expr_stmt|;
name|offset
operator|=
name|toff
expr_stmt|;
block|}
comment|/* UNION the objects, placing J at OFFSET.  */
name|union_stack_vars
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|isize
operator|-=
name|jsize
expr_stmt|;
if|if
condition|(
name|isize
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A debugging aid for expand_used_vars.  Dump the generated partitions.  */
end_comment

begin_function
specifier|static
name|void
name|dump_stack_var_partition
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|si
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
name|stack_vars_num
decl_stmt|;
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|n
condition|;
operator|++
name|si
control|)
block|{
name|i
operator|=
name|stack_vars_sorted
index|[
name|si
index|]
expr_stmt|;
comment|/* Skip variables that aren't partition representatives, for now.  */
if|if
condition|(
name|stack_vars
index|[
name|i
index|]
operator|.
name|representative
operator|!=
name|i
condition|)
continue|continue;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Partition %lu: size "
name|HOST_WIDE_INT_PRINT_DEC
literal|" align %u\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
argument_list|,
name|stack_vars
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|stack_vars
index|[
name|i
index|]
operator|.
name|alignb
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|!=
name|EOC
condition|;
name|j
operator|=
name|stack_vars
index|[
name|j
index|]
operator|.
name|next
control|)
block|{
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|stack_vars
index|[
name|j
index|]
operator|.
name|decl
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|", offset "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
name|stack_vars
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Assign rtl to DECL at frame offset OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|expand_one_stack_var_at
parameter_list|(
name|tree
name|decl
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|HOST_WIDE_INT
name|align
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* If this fails, we've overflowed the stack frame.  Error nicely?  */
name|gcc_assert
argument_list|(
name|offset
operator|==
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|plus_constant
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Set alignment we actually gave this decl.  */
name|offset
operator|-=
name|frame_phase
expr_stmt|;
name|align
operator|=
name|offset
operator|&
operator|-
name|offset
expr_stmt|;
name|align
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|STACK_BOUNDARY
operator|||
name|align
operator|==
literal|0
condition|)
name|align
operator|=
name|STACK_BOUNDARY
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_mem_attributes
argument_list|(
name|x
argument_list|,
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_used_vars.  Give each partition representative    a unique location within the stack frame.  Update each partition member    with that location.  */
end_comment

begin_function
specifier|static
name|void
name|expand_stack_vars
parameter_list|(
name|bool
function_decl|(
modifier|*
name|pred
function_decl|)
parameter_list|(
name|tree
parameter_list|)
parameter_list|)
block|{
name|size_t
name|si
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
name|stack_vars_num
decl_stmt|;
for|for
control|(
name|si
operator|=
literal|0
init|;
name|si
operator|<
name|n
condition|;
operator|++
name|si
control|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|i
operator|=
name|stack_vars_sorted
index|[
name|si
index|]
expr_stmt|;
comment|/* Skip variables that aren't partition representatives, for now.  */
if|if
condition|(
name|stack_vars
index|[
name|i
index|]
operator|.
name|representative
operator|!=
name|i
condition|)
continue|continue;
comment|/* Skip variables that have already had rtl assigned.  See also 	 add_stack_var where we perpetrate this pc_rtx hack.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|stack_vars
index|[
name|i
index|]
operator|.
name|decl
argument_list|)
operator|!=
name|pc_rtx
condition|)
continue|continue;
comment|/* Check the predicate to see whether this variable should be 	 allocated in this pass.  */
if|if
condition|(
name|pred
operator|&&
operator|!
name|pred
argument_list|(
name|stack_vars
index|[
name|i
index|]
operator|.
name|decl
argument_list|)
condition|)
continue|continue;
name|offset
operator|=
name|alloc_stack_frame_space
argument_list|(
name|stack_vars
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|stack_vars
index|[
name|i
index|]
operator|.
name|alignb
argument_list|)
expr_stmt|;
comment|/* Create rtl for each variable based on their location within the 	 partition.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|!=
name|EOC
condition|;
name|j
operator|=
name|stack_vars
index|[
name|j
index|]
operator|.
name|next
control|)
name|expand_one_stack_var_at
argument_list|(
name|stack_vars
index|[
name|j
index|]
operator|.
name|decl
argument_list|,
name|stack_vars
index|[
name|j
index|]
operator|.
name|offset
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of expand_one_var.  Called to immediately assign rtl    to a variable to be allocated in the stack frame.  */
end_comment

begin_function
specifier|static
name|void
name|expand_one_stack_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|,
name|offset
decl_stmt|,
name|align
decl_stmt|;
name|size
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|var
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|align
operator|=
name|get_decl_align_unit
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|offset
operator|=
name|alloc_stack_frame_space
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|expand_one_stack_var_at
argument_list|(
name|var
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_one_var.  Called to assign rtl    to a TREE_STATIC VAR_DECL.  */
end_comment

begin_function
specifier|static
name|void
name|expand_one_static_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
comment|/* In unit-at-a-time all the static variables are expanded at the end      of compilation process.  */
if|if
condition|(
name|flag_unit_at_a_time
condition|)
return|return;
comment|/* If this is an inlined copy of a static local variable,      look up the original.  */
name|var
operator|=
name|DECL_ORIGIN
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* If we've already processed this variable because of that, do nothing.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|var
argument_list|)
condition|)
return|return;
comment|/* Give the front end a chance to do whatever.  In practice, this is      resolving duplicate names for IMA in C.  */
if|if
condition|(
name|lang_hooks
operator|.
name|expand_decl
argument_list|(
name|var
argument_list|)
condition|)
return|return;
comment|/* Otherwise, just emit the variable.  */
name|rest_of_decl_compilation
argument_list|(
name|var
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL    that will reside in a hard register.  */
end_comment

begin_function
specifier|static
name|void
name|expand_one_hard_reg_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|rest_of_decl_compilation
argument_list|(
name|var
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL    that will reside in a pseudo register.  */
end_comment

begin_function
specifier|static
name|void
name|expand_one_register_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|reg_mode
init|=
name|promote_mode
argument_list|(
name|type
argument_list|,
name|DECL_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
operator|&
name|unsignedp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|gen_reg_rtx
argument_list|(
name|reg_mode
argument_list|)
decl_stmt|;
name|SET_DECL_RTL
argument_list|(
name|var
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Note if the object is a user variable.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|mark_user_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Trust user variables which have a pointer type to really 	 be pointers.  Do not trust compiler generated temporaries 	 as our type system is totally busted as it relates to 	 pointer arithmetic which translates into lots of compiler 	 generated objects with pointer types, but which are not really 	 pointers.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|x
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL that    has some associated error, e.g. its type is error-mark.  We just need    to pick something that won't crash the rest of the compiler.  */
end_comment

begin_function
specifier|static
name|void
name|expand_one_error_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|DECL_MODE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|x
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|x
operator|=
name|const0_rtx
expr_stmt|;
else|else
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|var
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_one_var.  VAR is a variable that will be    allocated to the local stack frame.  Return true if we wish to    add VAR to STACK_VARS so that it will be coalesced with other    variables.  Return false to allocate VAR immediately.     This function is used to reduce the number of variables considered    for coalescing, which reduces the size of the quadratic problem.  */
end_comment

begin_function
specifier|static
name|bool
name|defer_stack_allocation
parameter_list|(
name|tree
name|var
parameter_list|,
name|bool
name|toplevel
parameter_list|)
block|{
comment|/* If stack protection is enabled, *all* stack variables must be deferred,      so that we can re-order the strings to the top of the frame.  */
if|if
condition|(
name|flag_stack_protect
condition|)
return|return
name|true
return|;
comment|/* Variables in the outermost scope automatically conflict with      every other variable.  The only reason to want to defer them      at all is that, after sorting, we can more efficiently pack      small variables in the stack frame.  Continue to defer at -O2.  */
if|if
condition|(
name|toplevel
operator|&&
name|optimize
operator|<
literal|2
condition|)
return|return
name|false
return|;
comment|/* Without optimization, *most* variables are allocated from the      stack, which makes the quadratic problem large exactly when we      want compilation to proceed as quickly as possible.  On the      other hand, we don't want the function's stack frame size to      get completely out of hand.  So we avoid adding scalars and      "small" aggregates to the list at all.  */
if|if
condition|(
name|optimize
operator|==
literal|0
operator|&&
name|tree_low_cst
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|var
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|<
literal|32
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_used_vars.  Expand one variable according to    its flavor.  Variables to be placed on the stack are not actually    expanded yet, merely recorded.  */
end_comment

begin_function
specifier|static
name|void
name|expand_one_var
parameter_list|(
name|tree
name|var
parameter_list|,
name|bool
name|toplevel
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|lang_hooks
operator|.
name|expand_decl
argument_list|(
name|var
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|var
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|)
name|expand_one_static_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|var
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
operator|==
name|error_mark_node
condition|)
name|expand_one_error_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_HARD_REGISTER
argument_list|(
name|var
argument_list|)
condition|)
name|expand_one_hard_reg_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|use_register_for_decl
argument_list|(
name|var
argument_list|)
condition|)
name|expand_one_register_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defer_stack_allocation
argument_list|(
name|var
argument_list|,
name|toplevel
argument_list|)
condition|)
name|add_stack_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
else|else
name|expand_one_stack_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_used_vars.  Walk down through the BLOCK tree    expanding variables.  Those variables that can be put into registers    are allocated pseudos; those that can't are put on the stack.     TOPLEVEL is true if this is the outermost BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|expand_used_vars_for_block
parameter_list|(
name|tree
name|block
parameter_list|,
name|bool
name|toplevel
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|old_sv_num
decl_stmt|,
name|this_sv_num
decl_stmt|,
name|new_sv_num
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|old_sv_num
operator|=
name|toplevel
condition|?
literal|0
else|:
name|stack_vars_num
expr_stmt|;
comment|/* Expand all variables at this level.  */
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_USED
argument_list|(
name|t
argument_list|)
comment|/* Force local static variables to be output when marked by 	   used attribute.  For unit-at-a-time, cgraph code already takes 	   care of this.  */
operator|||
operator|(
operator|!
name|flag_unit_at_a_time
operator|&&
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_PRESERVE_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|expand_one_var
argument_list|(
name|t
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
name|this_sv_num
operator|=
name|stack_vars_num
expr_stmt|;
comment|/* Expand all variables at containing levels.  */
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|BLOCK_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|expand_used_vars_for_block
argument_list|(
name|t
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Since we do not track exact variable lifetimes (which is not even      possible for variables whose address escapes), we mirror the block      tree in the interference graph.  Here we cause all variables at this      level, and all sublevels, to conflict.  Do make certain that a      variable conflicts with itself.  */
if|if
condition|(
name|old_sv_num
operator|<
name|this_sv_num
condition|)
block|{
name|new_sv_num
operator|=
name|stack_vars_num
expr_stmt|;
name|resize_stack_vars_conflict
argument_list|(
name|new_sv_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|old_sv_num
init|;
name|i
operator|<
name|new_sv_num
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
name|i
operator|<
name|this_sv_num
condition|?
name|i
operator|+
literal|1
else|:
name|this_sv_num
init|;
name|j
operator|--
operator|>
name|old_sv_num
condition|;
control|)
name|add_stack_var_conflict
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of expand_used_vars.  Walk down through the BLOCK tree    and clear TREE_USED on all local variables.  */
end_comment

begin_function
specifier|static
name|void
name|clear_tree_used
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
comment|/* if (!TREE_STATIC (t)&& !DECL_EXTERNAL (t)) */
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|BLOCK_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|clear_tree_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Examine TYPE and determine a bit mask of the following features.  */
end_comment

begin_define
define|#
directive|define
name|SPCT_HAS_LARGE_CHAR_ARRAY
value|1
end_define

begin_define
define|#
directive|define
name|SPCT_HAS_SMALL_CHAR_ARRAY
value|2
end_define

begin_define
define|#
directive|define
name|SPCT_HAS_ARRAY
value|4
end_define

begin_define
define|#
directive|define
name|SPCT_HAS_AGGREGATE
value|8
end_define

begin_function
specifier|static
name|unsigned
name|int
name|stack_protect_classify_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|char_type_node
operator|||
name|t
operator|==
name|signed_char_type_node
operator|||
name|t
operator|==
name|unsigned_char_type_node
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|max
init|=
name|PARAM_VALUE
argument_list|(
name|PARAM_SSP_BUFFER_SIZE
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|len
operator|=
name|max
expr_stmt|;
else|else
name|len
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|max
condition|)
name|ret
operator|=
name|SPCT_HAS_SMALL_CHAR_ARRAY
operator||
name|SPCT_HAS_ARRAY
expr_stmt|;
else|else
name|ret
operator|=
name|SPCT_HAS_LARGE_CHAR_ARRAY
operator||
name|SPCT_HAS_ARRAY
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|SPCT_HAS_ARRAY
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
name|ret
operator|=
name|SPCT_HAS_AGGREGATE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|ret
operator||=
name|stack_protect_classify_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if DECL should be segregated into the "vulnerable" upper    part of the local stack frame.  Remember if we ever return nonzero for    any variable in this function.  The return value is the phase number in    which the variable should be allocated.  */
end_comment

begin_function
specifier|static
name|int
name|stack_protect_decl_phase
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|unsigned
name|int
name|bits
init|=
name|stack_protect_classify_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bits
operator|&
name|SPCT_HAS_SMALL_CHAR_ARRAY
condition|)
name|has_short_buffer
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|flag_stack_protect
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|bits
operator|&
operator|(
name|SPCT_HAS_SMALL_CHAR_ARRAY
operator||
name|SPCT_HAS_LARGE_CHAR_ARRAY
operator|)
operator|)
operator|&&
operator|!
operator|(
name|bits
operator|&
name|SPCT_HAS_AGGREGATE
operator|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bits
operator|&
name|SPCT_HAS_ARRAY
condition|)
name|ret
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|(
name|bits
operator|&
name|SPCT_HAS_LARGE_CHAR_ARRAY
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|has_protected_decls
operator|=
name|true
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Two helper routines that check for phase 1 and phase 2.  These are used    as callbacks for expand_stack_vars.  */
end_comment

begin_function
specifier|static
name|bool
name|stack_protect_decl_phase_1
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|stack_protect_decl_phase
argument_list|(
name|decl
argument_list|)
operator|==
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|stack_protect_decl_phase_2
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|stack_protect_decl_phase
argument_list|(
name|decl
argument_list|)
operator|==
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Ensure that variables in different stack protection phases conflict    so that they are not merged and share the same stack slot.  */
end_comment

begin_function
specifier|static
name|void
name|add_stack_protection_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
init|=
name|stack_vars_num
decl_stmt|;
name|unsigned
name|char
modifier|*
name|phase
decl_stmt|;
name|phase
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned char
argument_list|,
argument|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|phase
index|[
name|i
index|]
operator|=
name|stack_protect_decl_phase
argument_list|(
name|stack_vars
index|[
name|i
index|]
operator|.
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|char
name|ph_i
init|=
name|phase
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|ph_i
operator|!=
name|phase
index|[
name|j
index|]
condition|)
name|add_stack_var_conflict
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|XDELETEVEC
argument_list|(
name|phase
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a decl for the guard at the top of the stack frame.  */
end_comment

begin_function
specifier|static
name|void
name|create_stack_guard
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|guard
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL
argument_list|,
name|ptr_type_node
argument_list|)
decl_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|guard
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|guard
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_one_stack_var
argument_list|(
name|guard
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|stack_protect_guard
operator|=
name|guard
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand all variables used in the function.  */
end_comment

begin_function
specifier|static
name|void
name|expand_used_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|outer_block
init|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
comment|/* Compute the phase of the stack frame for this function.  */
block|{
name|int
name|align
init|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|off
init|=
name|STARTING_FRAME_OFFSET
operator|%
name|align
decl_stmt|;
name|frame_phase
operator|=
name|off
condition|?
name|align
operator|-
name|off
else|:
literal|0
expr_stmt|;
block|}
comment|/* Set TREE_USED on all variables in the unexpanded_var_list.  */
for|for
control|(
name|t
operator|=
name|cfun
operator|->
name|unexpanded_var_list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Clear TREE_USED on all variables associated with a block scope.  */
name|clear_tree_used
argument_list|(
name|outer_block
argument_list|)
expr_stmt|;
comment|/* Initialize local stack smashing state.  */
name|has_protected_decls
operator|=
name|false
expr_stmt|;
name|has_short_buffer
operator|=
name|false
expr_stmt|;
comment|/* At this point all variables on the unexpanded_var_list with TREE_USED      set are not associated with any block scope.  Lay them out.  */
for|for
control|(
name|t
operator|=
name|cfun
operator|->
name|unexpanded_var_list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bool
name|expand_now
init|=
name|false
decl_stmt|;
comment|/* We didn't set a block for static or extern because it's hard 	 to tell the difference between a global variable (re)declared 	 in a local scope, and one that's really declared there to 	 begin with.  And it doesn't really matter much, since we're 	 not giving them stack space.  Expand them now.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
condition|)
name|expand_now
operator|=
name|true
expr_stmt|;
comment|/* Any variable that could have been hoisted into an SSA_NAME 	 will have been propagated anywhere the optimizers chose, 	 i.e. not confined to their original block.  Allocate them 	 as if they were defined in the outermost scope.  */
elseif|else
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|var
argument_list|)
condition|)
name|expand_now
operator|=
name|true
expr_stmt|;
comment|/* If the variable is not associated with any block, then it 	 was created by the optimizers, and could be live anywhere 	 in the function.  */
elseif|else
if|if
condition|(
name|TREE_USED
argument_list|(
name|var
argument_list|)
condition|)
name|expand_now
operator|=
name|true
expr_stmt|;
comment|/* Finally, mark all variables on the list as used.  We'll use 	 this in a moment when we expand those associated with scopes.  */
name|TREE_USED
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|expand_now
condition|)
name|expand_one_var
argument_list|(
name|var
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* At this point, all variables within the block tree with TREE_USED      set are actually used by the optimized function.  Lay them out.  */
name|expand_used_vars_for_block
argument_list|(
name|outer_block
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_vars_num
operator|>
literal|0
condition|)
block|{
comment|/* Due to the way alias sets work, no variables with non-conflicting 	 alias sets may be assigned the same address.  Add conflicts to 	 reflect this.  */
name|add_alias_set_conflicts
argument_list|()
expr_stmt|;
comment|/* If stack protection is enabled, we don't share space between 	 vulnerable data and non-vulnerable data.  */
if|if
condition|(
name|flag_stack_protect
condition|)
name|add_stack_protection_conflicts
argument_list|()
expr_stmt|;
comment|/* Now that we have collected all stack variables, and have computed a 	 minimal interference graph, attempt to save some stack space.  */
name|partition_stack_vars
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_stack_var_partition
argument_list|()
expr_stmt|;
block|}
comment|/* There are several conditions under which we should create a      stack guard: protect-all, alloca used, protected decls present.  */
if|if
condition|(
name|flag_stack_protect
operator|==
literal|2
operator|||
operator|(
name|flag_stack_protect
operator|&&
operator|(
name|current_function_calls_alloca
operator|||
name|has_protected_decls
operator|)
operator|)
condition|)
name|create_stack_guard
argument_list|()
expr_stmt|;
comment|/* Assign rtl to each variable based on these partitions.  */
if|if
condition|(
name|stack_vars_num
operator|>
literal|0
condition|)
block|{
comment|/* Reorder decls to be protected by iterating over the variables 	 array multiple times, and allocating out of each phase in turn.  */
comment|/* ??? We could probably integrate this into the qsort we did 	 earlier, such that we naturally see these variables first, 	 and thus naturally allocate things in the right order.  */
if|if
condition|(
name|has_protected_decls
condition|)
block|{
comment|/* Phase 1 contains only character arrays.  */
name|expand_stack_vars
argument_list|(
name|stack_protect_decl_phase_1
argument_list|)
expr_stmt|;
comment|/* Phase 2 contains other kinds of arrays.  */
if|if
condition|(
name|flag_stack_protect
operator|==
literal|2
condition|)
name|expand_stack_vars
argument_list|(
name|stack_protect_decl_phase_2
argument_list|)
expr_stmt|;
block|}
name|expand_stack_vars
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Free up stack variable graph data.  */
name|XDELETEVEC
argument_list|(
name|stack_vars
argument_list|)
expr_stmt|;
name|XDELETEVEC
argument_list|(
name|stack_vars_sorted
argument_list|)
expr_stmt|;
name|XDELETEVEC
argument_list|(
name|stack_vars_conflict
argument_list|)
expr_stmt|;
name|stack_vars
operator|=
name|NULL
expr_stmt|;
name|stack_vars_alloc
operator|=
name|stack_vars_num
operator|=
literal|0
expr_stmt|;
name|stack_vars_conflict
operator|=
name|NULL
expr_stmt|;
name|stack_vars_conflict_alloc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the target requires that FRAME_OFFSET be aligned, do it.  */
if|if
condition|(
name|STACK_ALIGNMENT_NEEDED
condition|)
block|{
name|HOST_WIDE_INT
name|align
init|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
operator|!
name|FRAME_GROWS_DOWNWARD
condition|)
name|frame_offset
operator|+=
name|align
operator|-
literal|1
expr_stmt|;
name|frame_offset
operator|&=
operator|-
name|align
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If we need to produce a detailed dump, print the tree representation    for STMT to the dump file.  SINCE is the last RTX after which the RTL    generated for STMT should have been appended.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_dump_rtl_for_tree_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|rtx
name|since
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|since
condition|?
name|NEXT_INSN
argument_list|(
name|since
argument_list|)
else|:
name|since
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of expand_gimple_basic_block.  Expand one COND_EXPR.    Returns a new basic block if we've terminated the current basic    block and created a new one.  */
end_comment

begin_function
specifier|static
name|basic_block
name|expand_gimple_cond_expr
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|,
name|dest
decl_stmt|;
name|edge
name|new_edge
decl_stmt|;
name|edge
name|true_edge
decl_stmt|;
name|edge
name|false_edge
decl_stmt|;
name|tree
name|pred
init|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|then_exp
init|=
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|else_exp
init|=
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|rtx
name|last2
decl_stmt|,
name|last
decl_stmt|;
name|last2
operator|=
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|extract_true_false_edges_from_block
argument_list|(
name|bb
argument_list|,
operator|&
name|true_edge
argument_list|,
operator|&
name|false_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|emit_line_note
argument_list|(
operator|*
operator|(
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|record_block_change
argument_list|(
name|TREE_BLOCK
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* These flags have no purpose in RTL land.  */
name|true_edge
operator|->
name|flags
operator|&=
operator|~
name|EDGE_TRUE_VALUE
expr_stmt|;
name|false_edge
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALSE_VALUE
expr_stmt|;
comment|/* We can either have a pure conditional jump with one fallthru edge or      two-way jump that needs to be decomposed into two basic blocks.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|then_exp
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|IS_EMPTY_STMT
argument_list|(
name|else_exp
argument_list|)
condition|)
block|{
name|jumpif
argument_list|(
name|pred
argument_list|,
name|label_rtx
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|then_exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_reg_br_prob_note
argument_list|(
name|last
argument_list|,
name|true_edge
operator|->
name|probability
argument_list|)
expr_stmt|;
name|maybe_dump_rtl_for_tree_stmt
argument_list|(
name|stmt
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_LOCUS
argument_list|(
name|then_exp
argument_list|)
condition|)
name|emit_line_note
argument_list|(
operator|*
operator|(
name|EXPR_LOCUS
argument_list|(
name|then_exp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|else_exp
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|IS_EMPTY_STMT
argument_list|(
name|then_exp
argument_list|)
condition|)
block|{
name|jumpifnot
argument_list|(
name|pred
argument_list|,
name|label_rtx
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|else_exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_reg_br_prob_note
argument_list|(
name|last
argument_list|,
name|false_edge
operator|->
name|probability
argument_list|)
expr_stmt|;
name|maybe_dump_rtl_for_tree_stmt
argument_list|(
name|stmt
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_LOCUS
argument_list|(
name|else_exp
argument_list|)
condition|)
name|emit_line_note
argument_list|(
operator|*
operator|(
name|EXPR_LOCUS
argument_list|(
name|else_exp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|then_exp
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|else_exp
argument_list|)
operator|==
name|GOTO_EXPR
argument_list|)
expr_stmt|;
name|jumpif
argument_list|(
name|pred
argument_list|,
name|label_rtx
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|then_exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_reg_br_prob_note
argument_list|(
name|last
argument_list|,
name|true_edge
operator|->
name|probability
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|expand_expr
argument_list|(
name|else_exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|BARRIER_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|create_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|dest
operator|=
name|false_edge
operator|->
name|dest
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|false_edge
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
name|false_edge
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
name|new_bb
operator|->
name|count
operator|=
name|false_edge
operator|->
name|count
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|false_edge
argument_list|)
expr_stmt|;
name|new_edge
operator|=
name|make_edge
argument_list|(
name|new_bb
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_edge
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|new_edge
operator|->
name|count
operator|=
name|new_bb
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|BARRIER_P
argument_list|(
name|BB_END
argument_list|(
name|new_bb
argument_list|)
argument_list|)
condition|)
name|BB_END
argument_list|(
name|new_bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|BB_END
argument_list|(
name|new_bb
argument_list|)
argument_list|)
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|new_bb
argument_list|)
expr_stmt|;
name|maybe_dump_rtl_for_tree_stmt
argument_list|(
name|stmt
argument_list|,
name|last2
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_LOCUS
argument_list|(
name|else_exp
argument_list|)
condition|)
name|emit_line_note
argument_list|(
operator|*
operator|(
name|EXPR_LOCUS
argument_list|(
name|else_exp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of expand_gimple_basic_block.  Expand one CALL_EXPR    that has CALL_EXPR_TAILCALL set.  Returns non-null if we actually    generated a tail call (something that might be denied by the ABI    rules governing the call; see calls.c).     Sets CAN_FALLTHRU if we generated a *conditional* tail call, and    can still reach the rest of BB.  The case here is __builtin_sqrt,    where the NaN result goes through the external function (with a    tailcall) and the normal result happens via a sqrt instruction.  */
end_comment

begin_function
specifier|static
name|basic_block
name|expand_gimple_tailcall
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bool
modifier|*
name|can_fallthru
parameter_list|)
block|{
name|rtx
name|last2
decl_stmt|,
name|last
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|probability
decl_stmt|;
name|gcov_type
name|count
decl_stmt|;
name|last2
operator|=
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
for|for
control|(
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
init|;
name|last
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|CALL_P
argument_list|(
name|last
argument_list|)
operator|&&
name|SIBLING_CALL_P
argument_list|(
name|last
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|maybe_dump_rtl_for_tree_stmt
argument_list|(
name|stmt
argument_list|,
name|last2
argument_list|)
expr_stmt|;
operator|*
name|can_fallthru
operator|=
name|true
expr_stmt|;
return|return
name|NULL
return|;
name|found
label|:
comment|/* ??? Wouldn't it be better to just reset any pending stack adjust?      Any instructions emitted here are about to be deleted.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Remove any non-eh, non-abnormal edges that don't go to exit.  */
comment|/* ??? I.e. the fallthrough edge.  HOWEVER!  If there were to be      EH or abnormal edges, we shouldn't have created a tail call in      the first place.  So it seems to me we should just be removing      all edges here, or redirecting the existing fallthru edge to      the exit block.  */
name|probability
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_EH
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|e
operator|->
name|dest
operator|->
name|count
operator|-=
name|e
operator|->
name|count
expr_stmt|;
name|e
operator|->
name|dest
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|count
operator|<
literal|0
condition|)
name|e
operator|->
name|dest
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|frequency
operator|<
literal|0
condition|)
name|e
operator|->
name|dest
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
block|}
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|probability
operator|+=
name|e
operator|->
name|probability
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
comment|/* This is somewhat ugly: the call_expr expander often emits instructions      after the sibcall (to perform the function return).  These confuse the      find_many_sub_basic_blocks code, so we need to get rid of these.  */
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|BARRIER_P
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|can_fallthru
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|)
block|{
comment|/* For instance an sqrt builtin expander expands if with 	 sibcall in the then and label for `else`.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|can_fallthru
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_SIBCALL
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|+=
name|probability
expr_stmt|;
name|e
operator|->
name|count
operator|+=
name|count
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|last
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|bb
operator|=
name|create_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|last
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|BARRIER_P
argument_list|(
name|last
argument_list|)
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
name|maybe_dump_rtl_for_tree_stmt
argument_list|(
name|stmt
argument_list|,
name|last2
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Expand basic block BB from GIMPLE trees to RTL.  */
end_comment

begin_function
specifier|static
name|basic_block
name|expand_gimple_basic_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|tree
name|stmt
init|=
name|NULL
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|last
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Generating RTL for tree basic block %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|init_rtl_bb_info
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|->
name|flags
operator||=
name|BB_RTL
expr_stmt|;
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Java emits line number notes in the top of labels. 	 ??? Make this go away once line number notes are obsoleted.  */
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|maybe_dump_rtl_for_tree_stmt
argument_list|(
name|stmt
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
else|else
name|note
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|emit_note
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|)
expr_stmt|;
name|NOTE_BASIC_BLOCK
argument_list|(
name|note
argument_list|)
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
comment|/* Clear EDGE_EXECUTABLE.  This flag is never used in the backend.  */
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_EXECUTABLE
expr_stmt|;
comment|/* At the moment not all abnormal edges match the RTL representation. 	 It is safe to remove them here as find_many_sub_basic_blocks will 	 rediscover them.  In the future we should get this fixed properly.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
if|if
condition|(
operator|!
name|stmt
condition|)
continue|continue;
comment|/* Expand this statement, then evaluate the resulting RTL and 	 fixup the CFG accordingly.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|new_bb
operator|=
name|expand_gimple_cond_expr
argument_list|(
name|bb
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bb
condition|)
return|return
name|new_bb
return|;
block|}
else|else
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|&&
name|CALL_EXPR_TAILCALL
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|bool
name|can_fallthru
decl_stmt|;
name|new_bb
operator|=
name|expand_gimple_tailcall
argument_list|(
name|bb
argument_list|,
name|stmt
argument_list|,
operator|&
name|can_fallthru
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bb
condition|)
block|{
if|if
condition|(
name|can_fallthru
condition|)
name|bb
operator|=
name|new_bb
expr_stmt|;
else|else
return|return
name|new_bb
return|;
block|}
block|}
else|else
block|{
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|maybe_dump_rtl_for_tree_stmt
argument_list|(
name|stmt
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Find the block tail.  The last insn in the block is the insn      before a barrier and/or table jump insn.  */
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|BARRIER_P
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_TABLE_DATA_P
argument_list|(
name|last
argument_list|)
condition|)
name|last
operator|=
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|last
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Create a basic block for initialization code.  */
end_comment

begin_function
specifier|static
name|basic_block
name|construct_init_block
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|init_block
decl_stmt|,
name|first_block
decl_stmt|;
name|edge
name|e
init|=
name|NULL
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Multiple entry points not supported yet.  */
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|init_rtl_bb_info
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|init_rtl_bb_info
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|flags
operator||=
name|BB_RTL
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|flags
operator||=
name|BB_RTL
expr_stmt|;
name|e
operator|=
name|EDGE_SUCC
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When entry edge points to first basic block, we don't need jump,      otherwise we have to jump into proper target.  */
if|if
condition|(
name|e
operator|&&
name|e
operator|->
name|dest
operator|!=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
condition|)
block|{
name|tree
name|label
init|=
name|tree_block_label
argument_list|(
name|e
operator|->
name|dest
argument_list|)
decl_stmt|;
name|emit_jump
argument_list|(
name|label_rtx
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
name|init_block
operator|=
name|create_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|get_insns
argument_list|()
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|init_block
operator|->
name|frequency
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
expr_stmt|;
name|init_block
operator|->
name|count
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|first_block
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|init_block
argument_list|)
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|init_block
argument_list|,
name|first_block
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
name|e
operator|=
name|make_edge
argument_list|(
name|init_block
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|count
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|init_block
argument_list|)
expr_stmt|;
return|return
name|init_block
return|;
block|}
end_function

begin_comment
comment|/* Create a block containing landing pads and similar stuff.  */
end_comment

begin_function
specifier|static
name|void
name|construct_exit_block
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|head
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|basic_block
name|exit_block
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|e2
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Make sure the locus is set to the end of the function, so that      epilogue line numbers and warnings are set properly.  */
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
if|if
condition|(
name|cfun
operator|->
name|function_end_locus
operator|!=
name|UNKNOWN_LOCATION
condition|)
else|#
directive|else
if|if
condition|(
name|cfun
operator|->
name|function_end_locus
operator|.
name|file
condition|)
endif|#
directive|endif
name|input_location
operator|=
name|cfun
operator|->
name|function_end_locus
expr_stmt|;
comment|/* The following insns belong to the top scope.  */
name|record_block_change
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|()
expr_stmt|;
name|end
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|end
condition|)
return|return;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
operator|&&
name|NOTE_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|exit_block
operator|=
name|create_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|,
name|end
argument_list|,
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|exit_block
operator|->
name|frequency
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|frequency
expr_stmt|;
name|exit_block
operator|->
name|count
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|count
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ix
operator|<
name|EDGE_COUNT
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|)
condition|)
block|{
name|e
operator|=
name|EDGE_PRED
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|exit_block
argument_list|)
expr_stmt|;
else|else
name|ix
operator|++
expr_stmt|;
block|}
name|e
operator|=
name|make_edge
argument_list|(
name|exit_block
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|count
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e2
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
if|if
condition|(
name|e2
operator|!=
name|e
condition|)
block|{
name|e
operator|->
name|count
operator|-=
name|e2
operator|->
name|count
expr_stmt|;
name|exit_block
operator|->
name|count
operator|-=
name|e2
operator|->
name|count
expr_stmt|;
name|exit_block
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|e2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
condition|)
name|e
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exit_block
operator|->
name|count
operator|<
literal|0
condition|)
name|exit_block
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exit_block
operator|->
name|frequency
operator|<
literal|0
condition|)
name|exit_block
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|exit_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for discover_nonconstant_array_refs.    Look for ARRAY_REF nodes with non-constant indexes and mark them    addressable.  */
end_comment

begin_function
specifier|static
name|tree
name|discover_nonconstant_array_refs_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
operator|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
operator|!
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|t
operator|=
name|get_base_address
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* RTL expansion is not able to compile array references with variable    offsets for arrays stored in single register.  Discover such    expressions and mark variables as addressable to avoid this    scenario.  */
end_comment

begin_function
specifier|static
name|void
name|discover_nonconstant_array_refs
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|discover_nonconstant_array_refs_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Translate the intermediate representation contained in the CFG    from GIMPLE trees to RTL.     We do conversion per basic block and preserve/update the tree CFG.    This implies we have to do some magic as the CFG can simultaneously    consist of basic blocks containing RTL and GIMPLE trees.  This can    confuse the CFG hooks, so be careful to not manipulate CFG during    the expansion.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_expand_cfg
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|init_block
decl_stmt|;
name|sbitmap
name|blocks
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Some backends want to know that we are expanding to RTL.  */
name|currently_expanding_to_rtl
operator|=
literal|1
expr_stmt|;
comment|/* Prepare the rtl middle end to start recording block changes.  */
name|reset_block_changes
argument_list|()
expr_stmt|;
comment|/* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */
name|discover_nonconstant_array_refs
argument_list|()
expr_stmt|;
comment|/* Expand the variables recorded during gimple lowering.  */
name|expand_used_vars
argument_list|()
expr_stmt|;
comment|/* Honor stack protection warnings.  */
if|if
condition|(
name|warn_stack_protect
condition|)
block|{
if|if
condition|(
name|current_function_calls_alloca
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"not protecting local variables: variable length buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_short_buffer
operator|&&
operator|!
name|cfun
operator|->
name|stack_protect_guard
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"not protecting function: no buffer at least %d bytes long"
argument_list|,
operator|(
name|int
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_SSP_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up parameters and prepare for return, for the function.  */
name|expand_function_start
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* If this function is `main', emit a call to `__main'      to run global initializers, etc.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|&&
name|DECL_FILE_SCOPE_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|expand_main_function
argument_list|()
expr_stmt|;
comment|/* Initialize the stack_protect_guard field.  This must happen after the      call to __main (if any) so that the external decl is initialized.  */
if|if
condition|(
name|cfun
operator|->
name|stack_protect_guard
condition|)
name|stack_protect_prologue
argument_list|()
expr_stmt|;
comment|/* Register rtl specific functions for cfg.  */
name|rtl_register_cfg_hooks
argument_list|()
expr_stmt|;
name|init_block
operator|=
name|construct_init_block
argument_list|()
expr_stmt|;
comment|/* Clear EDGE_EXECUTABLE on the entry edge(s).  It is cleaned from the      remaining edges in expand_gimple_basic_block.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_EXECUTABLE
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|init_block->next_bb
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|=
name|expand_gimple_basic_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|construct_exit_block
argument_list|()
expr_stmt|;
comment|/* We're done expanding trees to RTL.  */
name|currently_expanding_to_rtl
operator|=
literal|0
expr_stmt|;
comment|/* Convert tree EH labels to RTL EH labels, and clean out any unreachable      EH regions.  */
name|convert_from_eh_region_ranges
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|find_many_sub_basic_blocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|purge_all_dead_edges
argument_list|()
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|compact_blocks
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* There's no need to defer outputting this function any more; we      know we want to output it.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now that we're done expanding trees to RTL, we shouldn't have any      more CONCATs anywhere.  */
name|generating_concat_p
operator|=
literal|0
expr_stmt|;
name|finalize_block_changes
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n;;\n;; Full RTL generated for this function:\n;;\n"
argument_list|)
expr_stmt|;
comment|/* And the pass manager will dump RTL for us.  */
block|}
comment|/* If we're emitting a nested function, make sure its parent gets      emitted as well.  Doing otherwise confuses debug info.  */
block|{
name|tree
name|parent
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|parent
operator|!=
name|NULL_TREE
condition|;
name|parent
operator|=
name|get_containing_scope
argument_list|(
name|parent
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We are now committed to emitting code for this function.  Do any      preparation, such as emitting abstract debug info for the inline      before it gets mangled by optimization.  */
if|if
condition|(
name|cgraph_function_possibly_inlined_p
argument_list|(
name|current_function_decl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|outlining_inline_function
call|)
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* After expanding, the return labels are no longer needed. */
name|return_label
operator|=
name|NULL
expr_stmt|;
name|naked_return_label
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_expand
init|=
block|{
literal|"expand"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|tree_expand_cfg
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_EXPAND
block|,
comment|/* tv_id */
comment|/* ??? If TER is enabled, we actually receive GENERIC.  */
name|PROP_gimple_leh
operator||
name|PROP_cfg
block|,
comment|/* properties_required */
name|PROP_rtl
block|,
comment|/* properties_provided */
name|PROP_trees
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'r'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

