begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C/ObjC/C++ command line option handling.    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Contributed by Neil Booth.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"cppdefault.h"
end_include

begin_include
include|#
directive|include
file|"c-incpath.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_comment
comment|/* For debug_hooks.  */
end_comment

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_SYSTEM_ROOT
end_ifndef

begin_define
define|#
directive|define
name|TARGET_SYSTEM_ROOT
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_OPTF
end_ifndef

begin_define
define|#
directive|define
name|TARGET_OPTF
parameter_list|(
name|ARG
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPP's options.  */
end_comment

begin_decl_stmt
specifier|static
name|cpp_options
modifier|*
name|cpp_opts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input filename.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|this_input_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename and stream for preprocessed output.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|out_fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|out_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Append dependencies to deps_file.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|deps_append
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If dependency switches (-MF etc.) have been given.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|deps_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If -v seen.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If -lang-fortran seen.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|lang_fortran
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dependency output file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|deps_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The prefix given by -iprefix, if any.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|iprefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The multilib directory given by -imultilib, if any.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|imultilib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The system root, if any.  Overridden by -isysroot.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sysroot
init|=
name|TARGET_SYSTEM_ROOT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero disables all standard directories for headers.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|std_inc
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero disables the C++-specific standard directories for headers.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|std_cxx_inc
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the quote chain has been split by -I-.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|quote_chain_split
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If -Wunused-macros.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|warn_unused_macros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If -Wvariadic-macros.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|warn_variadic_macros
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of deferred options.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|deferred_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of deferred options scanned for -include.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|include_cursor
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_Wimplicit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_OPT_d
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_std_cxx98
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_std_c89
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_std_c99
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_deps_environment_vars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_deferred_opts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sanitize_cpp_opts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_prefixed_path
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_command_line_include
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_file_change
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_dir_change
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_0_IN_SYSTEM_HEADERS
end_ifndef

begin_define
define|#
directive|define
name|STDC_0_IN_SYSTEM_HEADERS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Holds switches parsed by c_common_handle_option (), but whose    handling is deferred to c_common_post_options ().  */
end_comment

begin_function_decl
specifier|static
name|void
name|defer_opt
parameter_list|(
name|enum
name|opt_code
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
name|deferred_opt
block|{
name|enum
name|opt_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|}
modifier|*
name|deferred_opts
struct|;
end_struct

begin_comment
comment|/* Complain that switch CODE expects an argument but none was    provided.  OPT was the command-line option.  Return FALSE to get    the default message in opts.c, TRUE if we provide a specialized    one.  */
end_comment

begin_function
name|bool
name|c_common_missing_argument
parameter_list|(
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|size_t
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
comment|/* Pick up the default message.  */
return|return
name|false
return|;
case|case
name|OPT_fconstant_string_class_
case|:
name|error
argument_list|(
literal|"no class name specified with %qs"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_A
case|:
name|error
argument_list|(
literal|"assertion missing after %qs"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_D
case|:
case|case
name|OPT_U
case|:
name|error
argument_list|(
literal|"macro name missing after %qs"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_F
case|:
case|case
name|OPT_I
case|:
case|case
name|OPT_idirafter
case|:
case|case
name|OPT_isysroot
case|:
case|case
name|OPT_isystem
case|:
case|case
name|OPT_iquote
case|:
name|error
argument_list|(
literal|"missing path after %qs"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_MF
case|:
case|case
name|OPT_MD
case|:
case|case
name|OPT_MMD
case|:
case|case
name|OPT_include
case|:
case|case
name|OPT_imacros
case|:
case|case
name|OPT_o
case|:
name|error
argument_list|(
literal|"missing filename after %qs"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_MQ
case|:
case|case
name|OPT_MT
case|:
name|error
argument_list|(
literal|"missing makefile target after %qs"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Defer option CODE with argument ARG.  */
end_comment

begin_function
specifier|static
name|void
name|defer_opt
parameter_list|(
name|enum
name|opt_code
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|deferred_opts
index|[
name|deferred_count
index|]
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|deferred_opts
index|[
name|deferred_count
index|]
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|deferred_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Common initialization before parsing options.  */
end_comment

begin_function
name|unsigned
name|int
name|c_common_init_options
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|int
name|lang_flags
index|[]
init|=
block|{
name|CL_C
block|,
name|CL_ObjC
block|,
name|CL_CXX
block|,
name|CL_ObjCXX
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
comment|/* This is conditionalized only because that is the way the front      ends used to do it.  Maybe this should be unconditional?  */
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
block|{
comment|/* By default wrap lines at 80 characters.  Is getenv 	 ("COLUMNS") preferable?  */
name|diagnostic_line_cutoff
argument_list|(
name|global_dc
argument_list|)
operator|=
literal|80
expr_stmt|;
comment|/* By default, emit location information once for every 	 diagnostic message.  */
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
block|}
name|parse_in
operator|=
name|cpp_create_reader
argument_list|(
name|c_dialect_cxx
argument_list|()
condition|?
name|CLK_GNUCXX
else|:
name|CLK_GNUC89
argument_list|,
name|ident_hash
argument_list|,
operator|&
name|line_table
argument_list|)
expr_stmt|;
name|cpp_opts
operator|=
name|cpp_get_options
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|cpp_opts
operator|->
name|dollars_in_ident
operator|=
name|DOLLARS_IN_IDENTIFIERS
expr_stmt|;
name|cpp_opts
operator|->
name|objc
operator|=
name|c_dialect_objc
argument_list|()
expr_stmt|;
comment|/* Reset to avoid warnings on internal definitions.  We set it just      before passing on command-line options to cpplib.  */
name|cpp_opts
operator|->
name|warn_dollars
operator|=
literal|0
expr_stmt|;
name|flag_exceptions
operator|=
name|c_dialect_cxx
argument_list|()
expr_stmt|;
name|warn_pointer_arith
operator|=
name|c_dialect_cxx
argument_list|()
expr_stmt|;
name|warn_write_strings
operator|=
name|c_dialect_cxx
argument_list|()
expr_stmt|;
name|deferred_opts
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|deferred_opt
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|result
operator|=
name|lang_flags
index|[
name|c_language
index|]
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_c
condition|)
block|{
comment|/* If preprocessing assembly language, accept any of the C-family 	 front end options since the driver may pass them through.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-asm"
argument_list|)
condition|)
block|{
name|result
operator||=
name|CL_C
operator||
name|CL_ObjC
operator||
name|CL_CXX
operator||
name|CL_ObjCXX
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|CL_Fortran
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-fortran"
argument_list|)
condition|)
block|{
name|result
operator||=
name|CL_Fortran
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Handle switch SCODE with argument ARG.  VALUE is true, unless no-    form of an -f or -W option was given.  Returns 0 if the switch was    invalid, a negative number to prevent language-independent    processing in toplev.c (a hack necessary for the short-term).  */
end_comment

begin_function
name|int
name|c_common_handle_option
parameter_list|(
name|size_t
name|scode
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
specifier|const
name|struct
name|cl_option
modifier|*
name|option
init|=
operator|&
name|cl_options
index|[
name|scode
index|]
decl_stmt|;
name|enum
name|opt_code
name|code
init|=
operator|(
expr|enum
name|opt_code
operator|)
name|scode
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
comment|/* Prevent resetting the language standard to a C dialect when the driver      has already determined that we're looking at assembler input.  */
name|bool
name|preprocessing_asm_p
init|=
operator|(
name|cpp_get_options
argument_list|(
name|parse_in
argument_list|)
operator|->
name|lang
operator|==
name|CLK_ASM
operator|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
if|if
condition|(
name|cl_options
index|[
name|code
index|]
operator|.
name|flags
operator|&
operator|(
name|CL_C
operator||
name|CL_CXX
operator||
name|CL_ObjC
operator||
name|CL_ObjCXX
operator|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|CL_Fortran
if|if
condition|(
name|lang_fortran
operator|&&
operator|(
name|cl_options
index|[
name|code
index|]
operator|.
name|flags
operator|&
operator|(
name|CL_Fortran
operator|)
operator|)
condition|)
break|break;
endif|#
directive|endif
name|result
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT__output_pch_
case|:
name|pch_file
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_A
case|:
name|defer_opt
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_C
case|:
name|cpp_opts
operator|->
name|discard_comments
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_CC
case|:
name|cpp_opts
operator|->
name|discard_comments
operator|=
literal|0
expr_stmt|;
name|cpp_opts
operator|->
name|discard_comments_in_macro_exp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_D
case|:
name|defer_opt
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_E
case|:
name|flag_preprocess_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_H
case|:
name|cpp_opts
operator|->
name|print_include_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_F
case|:
name|TARGET_OPTF
argument_list|(
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_I
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
name|add_path
argument_list|(
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|BRACKET
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|quote_chain_split
condition|)
name|error
argument_list|(
literal|"-I- specified twice"
argument_list|)
expr_stmt|;
name|quote_chain_split
operator|=
name|true
expr_stmt|;
name|split_quote_chain
argument_list|()
expr_stmt|;
name|inform
argument_list|(
literal|"obsolete option -I- used, please use -iquote instead"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_M
case|:
case|case
name|OPT_MM
case|:
comment|/* When doing dependencies with -M or -MM, suppress normal 	 preprocessed output, but still do -dM etc. as software 	 depends on this.  Preprocessed output does occur if -MD, -MMD 	 or environment var dependency generation is used.  */
name|cpp_opts
operator|->
name|deps
operator|.
name|style
operator|=
operator|(
name|code
operator|==
name|OPT_M
condition|?
name|DEPS_SYSTEM
else|:
name|DEPS_USER
operator|)
expr_stmt|;
name|flag_no_output
operator|=
literal|1
expr_stmt|;
name|cpp_opts
operator|->
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_MD
case|:
case|case
name|OPT_MMD
case|:
name|cpp_opts
operator|->
name|deps
operator|.
name|style
operator|=
operator|(
name|code
operator|==
name|OPT_MD
condition|?
name|DEPS_SYSTEM
else|:
name|DEPS_USER
operator|)
expr_stmt|;
name|deps_file
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_MF
case|:
name|deps_seen
operator|=
name|true
expr_stmt|;
name|deps_file
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_MG
case|:
name|deps_seen
operator|=
name|true
expr_stmt|;
name|cpp_opts
operator|->
name|deps
operator|.
name|missing_files
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_MP
case|:
name|deps_seen
operator|=
name|true
expr_stmt|;
name|cpp_opts
operator|->
name|deps
operator|.
name|phony_targets
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_MQ
case|:
case|case
name|OPT_MT
case|:
name|deps_seen
operator|=
name|true
expr_stmt|;
name|defer_opt
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_P
case|:
name|flag_no_line_commands
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_fworking_directory
case|:
name|flag_working_directory
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_U
case|:
name|defer_opt
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wall
case|:
name|set_Wunused
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|set_Wformat
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|set_Wimplicit
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|warn_char_subscripts
operator|=
name|value
expr_stmt|;
name|warn_missing_braces
operator|=
name|value
expr_stmt|;
name|warn_parentheses
operator|=
name|value
expr_stmt|;
name|warn_return_type
operator|=
name|value
expr_stmt|;
name|warn_sequence_point
operator|=
name|value
expr_stmt|;
comment|/* Was C only.  */
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|warn_sign_compare
operator|=
name|value
expr_stmt|;
name|warn_switch
operator|=
name|value
expr_stmt|;
name|warn_strict_aliasing
operator|=
name|value
expr_stmt|;
name|warn_strict_overflow
operator|=
name|value
expr_stmt|;
name|warn_address
operator|=
name|value
expr_stmt|;
comment|/* Only warn about unknown pragmas that are not in system 	 headers.  */
name|warn_unknown_pragmas
operator|=
name|value
expr_stmt|;
comment|/* We save the value of warn_uninitialized, since if they put 	 -Wuninitialized on the command line, we need to generate a 	 warning about not using it without also specifying -O.  */
if|if
condition|(
name|warn_uninitialized
operator|!=
literal|1
condition|)
name|warn_uninitialized
operator|=
operator|(
name|value
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_dialect_cxx
argument_list|()
condition|)
comment|/* We set this to 2 here, but 1 in -Wmain, so -ffreestanding 	   can turn it off only if it's not explicit.  */
name|warn_main
operator|=
name|value
operator|*
literal|2
expr_stmt|;
else|else
block|{
comment|/* C++-specific warnings.  */
name|warn_reorder
operator|=
name|value
expr_stmt|;
name|warn_nontemplate_friend
operator|=
name|value
expr_stmt|;
block|}
name|cpp_opts
operator|->
name|warn_trigraphs
operator|=
name|value
expr_stmt|;
name|cpp_opts
operator|->
name|warn_comments
operator|=
name|value
expr_stmt|;
name|cpp_opts
operator|->
name|warn_num_sign_change
operator|=
name|value
expr_stmt|;
name|cpp_opts
operator|->
name|warn_multichar
operator|=
name|value
expr_stmt|;
comment|/* Was C++ only.  */
if|if
condition|(
name|warn_pointer_sign
operator|==
operator|-
literal|1
condition|)
name|warn_pointer_sign
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_Wcomment
case|:
case|case
name|OPT_Wcomments
case|:
name|cpp_opts
operator|->
name|warn_comments
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wdeprecated
case|:
name|cpp_opts
operator|->
name|warn_deprecated
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wendif_labels
case|:
name|cpp_opts
operator|->
name|warn_endif_labels
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Werror
case|:
name|cpp_opts
operator|->
name|warnings_are_errors
operator|=
name|value
expr_stmt|;
name|global_dc
operator|->
name|warning_as_error_requested
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Werror_implicit_function_declaration
case|:
name|mesg_implicit_function_declaration
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|OPT_Wformat
case|:
name|set_Wformat
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wformat_
case|:
name|set_Wformat
argument_list|(
name|atoi
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wimplicit
case|:
name|set_Wimplicit
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wimport
case|:
comment|/* Silently ignore for now.  */
break|break;
case|case
name|OPT_Winvalid_pch
case|:
name|cpp_opts
operator|->
name|warn_invalid_pch
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wmain
case|:
if|if
condition|(
name|value
condition|)
name|warn_main
operator|=
literal|1
expr_stmt|;
else|else
name|warn_main
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_Wmissing_include_dirs
case|:
name|cpp_opts
operator|->
name|warn_missing_include_dirs
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wmultichar
case|:
name|cpp_opts
operator|->
name|warn_multichar
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wnormalized_
case|:
if|if
condition|(
operator|!
name|value
operator|||
operator|(
name|arg
operator|&&
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|cpp_opts
operator|->
name|warn_normalize
operator|=
name|normalized_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|arg
operator|||
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"nfkc"
argument_list|)
operator|==
literal|0
condition|)
name|cpp_opts
operator|->
name|warn_normalize
operator|=
name|normalized_KC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"id"
argument_list|)
operator|==
literal|0
condition|)
name|cpp_opts
operator|->
name|warn_normalize
operator|=
name|normalized_identifier_C
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
argument_list|,
literal|"nfc"
argument_list|)
operator|==
literal|0
condition|)
name|cpp_opts
operator|->
name|warn_normalize
operator|=
name|normalized_C
expr_stmt|;
else|else
name|error
argument_list|(
literal|"argument %qs to %<-Wnormalized%> not recognized"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_Wreturn_type
case|:
name|warn_return_type
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wstrict_null_sentinel
case|:
name|warn_strict_null_sentinel
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wsystem_headers
case|:
name|cpp_opts
operator|->
name|warn_system_headers
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wtraditional
case|:
name|cpp_opts
operator|->
name|warn_traditional
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wtrigraphs
case|:
name|cpp_opts
operator|->
name|warn_trigraphs
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wundef
case|:
name|cpp_opts
operator|->
name|warn_undef
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wunknown_pragmas
case|:
comment|/* Set to greater than 1, so that even unknown pragmas in 	 system headers will be warned about.  */
name|warn_unknown_pragmas
operator|=
name|value
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|OPT_Wunused_macros
case|:
name|warn_unused_macros
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wvariadic_macros
case|:
name|warn_variadic_macros
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Wwrite_strings
case|:
name|warn_write_strings
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_Weffc__
case|:
name|warn_ecpp
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|warn_nonvdtor
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_ansi
case|:
if|if
condition|(
operator|!
name|c_dialect_cxx
argument_list|()
condition|)
name|set_std_c89
argument_list|(
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|set_std_cxx98
argument_list|(
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_d
case|:
name|handle_OPT_d
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fcond_mismatch
case|:
if|if
condition|(
operator|!
name|c_dialect_cxx
argument_list|()
condition|)
block|{
name|flag_cond_mismatch
operator|=
name|value
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|OPT_fall_virtual
case|:
case|case
name|OPT_falt_external_templates
case|:
case|case
name|OPT_fenum_int_equiv
case|:
case|case
name|OPT_fexternal_templates
case|:
case|case
name|OPT_fguiding_decls
case|:
case|case
name|OPT_fhonor_std
case|:
case|case
name|OPT_fhuge_objects
case|:
case|case
name|OPT_flabels_ok
case|:
case|case
name|OPT_fname_mangling_version_
case|:
case|case
name|OPT_fnew_abi
case|:
case|case
name|OPT_fnonnull_objects
case|:
case|case
name|OPT_fsquangle
case|:
case|case
name|OPT_fstrict_prototype
case|:
case|case
name|OPT_fthis_is_variable
case|:
case|case
name|OPT_fvtable_thunks
case|:
case|case
name|OPT_fxref
case|:
case|case
name|OPT_fvtable_gc
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"switch %qs is no longer supported"
argument_list|,
name|option
operator|->
name|opt_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_faccess_control
case|:
name|flag_access_control
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fasm
case|:
name|flag_no_asm
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbuiltin
case|:
name|flag_no_builtin
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fbuiltin_
case|:
if|if
condition|(
name|value
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|disable_builtin_function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_fdollars_in_identifiers
case|:
name|cpp_opts
operator|->
name|dollars_in_ident
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ffreestanding
case|:
name|value
operator|=
operator|!
name|value
expr_stmt|;
comment|/* Fall through....  */
case|case
name|OPT_fhosted
case|:
name|flag_hosted
operator|=
name|value
expr_stmt|;
name|flag_no_builtin
operator|=
operator|!
name|value
expr_stmt|;
comment|/* warn_main will be 2 if set by -Wall, 1 if set by -Wmain */
if|if
condition|(
operator|!
name|value
operator|&&
name|warn_main
operator|==
literal|2
condition|)
name|warn_main
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_fshort_double
case|:
name|flag_short_double
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fshort_enums
case|:
name|flag_short_enums
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fshort_wchar
case|:
name|flag_short_wchar
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsigned_bitfields
case|:
name|flag_signed_bitfields
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fsigned_char
case|:
name|flag_signed_char
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funsigned_bitfields
case|:
name|flag_signed_bitfields
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_funsigned_char
case|:
name|flag_signed_char
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fcheck_new
case|:
name|flag_check_new
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fconserve_space
case|:
name|flag_conserve_space
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fconstant_string_class_
case|:
name|constant_string_class_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_fdefault_inline
case|:
name|flag_default_inline
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_felide_constructors
case|:
name|flag_elide_constructors
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fenforce_eh_specs
case|:
name|flag_enforce_eh_specs
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fextended_identifiers
case|:
name|cpp_opts
operator|->
name|extended_identifiers
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ffor_scope
case|:
name|flag_new_for_scope
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fgnu_keywords
case|:
name|flag_no_gnu_keywords
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fgnu_runtime
case|:
name|flag_next_runtime
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fhandle_exceptions
case|:
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-fhandle-exceptions has been renamed -fexceptions (and is now on by default)"
argument_list|)
expr_stmt|;
name|flag_exceptions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fimplement_inlines
case|:
name|flag_implement_inlines
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fimplicit_inline_templates
case|:
name|flag_implicit_inline_templates
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fimplicit_templates
case|:
name|flag_implicit_templates
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fms_extensions
case|:
name|flag_ms_extensions
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fnext_runtime
case|:
name|flag_next_runtime
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fnil_receivers
case|:
name|flag_nil_receivers
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fnonansi_builtins
case|:
name|flag_no_nonansi_builtin
operator|=
operator|!
name|value
expr_stmt|;
break|break;
case|case
name|OPT_foperator_names
case|:
name|cpp_opts
operator|->
name|operator_names
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_foptional_diags
case|:
name|flag_optional_diags
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpch_deps
case|:
name|cpp_opts
operator|->
name|restore_pch_deps
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpch_preprocess
case|:
name|flag_pch_preprocess
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpermissive
case|:
name|flag_permissive
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fpreprocessed
case|:
name|cpp_opts
operator|->
name|preprocessed
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_freplace_objc_classes
case|:
name|flag_replace_objc_classes
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_frepo
case|:
name|flag_use_repository
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|flag_implicit_templates
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPT_frtti
case|:
name|flag_rtti
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fshow_column
case|:
name|cpp_opts
operator|->
name|show_column
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fstats
case|:
name|flag_detailed_statistics
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_ftabstop_
case|:
comment|/* It is documented that we silently ignore silly values.  */
if|if
condition|(
name|value
operator|>=
literal|1
operator|&&
name|value
operator|<=
literal|100
condition|)
name|cpp_opts
operator|->
name|tabstop
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fexec_charset_
case|:
name|cpp_opts
operator|->
name|narrow_charset
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_fwide_exec_charset_
case|:
name|cpp_opts
operator|->
name|wide_charset
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_finput_charset_
case|:
name|cpp_opts
operator|->
name|input_charset
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_ftemplate_depth_
case|:
name|max_tinst_depth
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fuse_cxa_atexit
case|:
name|flag_use_cxa_atexit
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fuse_cxa_get_exception_ptr
case|:
name|flag_use_cxa_get_exception_ptr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fvisibility_inlines_hidden
case|:
name|visibility_options
operator|.
name|inlines_hidden
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fweak
case|:
name|flag_weak
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fthreadsafe_statics
case|:
name|flag_threadsafe_statics
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_fzero_link
case|:
name|flag_zero_link
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_gen_decls
case|:
name|flag_gen_declaration
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_idirafter
case|:
name|add_path
argument_list|(
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|AFTER
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_imacros
case|:
case|case
name|OPT_include
case|:
name|defer_opt
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_imultilib
case|:
name|imultilib
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_iprefix
case|:
name|iprefix
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_iquote
case|:
name|add_path
argument_list|(
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|QUOTE
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_isysroot
case|:
name|sysroot
operator|=
name|arg
expr_stmt|;
break|break;
case|case
name|OPT_isystem
case|:
name|add_path
argument_list|(
name|xstrdup
argument_list|(
name|arg
argument_list|)
argument_list|,
name|SYSTEM
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_iwithprefix
case|:
name|add_prefixed_path
argument_list|(
name|arg
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_iwithprefixbefore
case|:
name|add_prefixed_path
argument_list|(
name|arg
argument_list|,
name|BRACKET
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_lang_asm
case|:
name|cpp_set_lang
argument_list|(
name|parse_in
argument_list|,
name|CLK_ASM
argument_list|)
expr_stmt|;
name|cpp_opts
operator|->
name|dollars_in_ident
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_lang_fortran
case|:
name|lang_fortran
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_lang_objc
case|:
name|cpp_opts
operator|->
name|objc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_nostdinc
case|:
name|std_inc
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_nostdinc__
case|:
name|std_cxx_inc
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPT_o
case|:
if|if
condition|(
operator|!
name|out_fname
condition|)
name|out_fname
operator|=
name|arg
expr_stmt|;
else|else
name|error
argument_list|(
literal|"output filename specified twice"
argument_list|)
expr_stmt|;
break|break;
comment|/* We need to handle the -pedantic switches here, rather than in 	 c_common_post_options, so that a subsequent -Wno-endif-labels 	 is not overridden.  */
case|case
name|OPT_pedantic_errors
case|:
name|cpp_opts
operator|->
name|pedantic_errors
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
name|OPT_pedantic
case|:
name|cpp_opts
operator|->
name|pedantic
operator|=
literal|1
expr_stmt|;
name|cpp_opts
operator|->
name|warn_endif_labels
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn_pointer_sign
operator|==
operator|-
literal|1
condition|)
name|warn_pointer_sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn_overlength_strings
operator|==
operator|-
literal|1
condition|)
name|warn_overlength_strings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_print_objc_runtime_info
case|:
name|print_struct_values
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_print_pch_checksum
case|:
name|c_common_print_pch_checksum
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit_after_options
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPT_remap
case|:
name|cpp_opts
operator|->
name|remap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_std_c__98
case|:
case|case
name|OPT_std_gnu__98
case|:
if|if
condition|(
operator|!
name|preprocessing_asm_p
condition|)
name|set_std_cxx98
argument_list|(
name|code
operator|==
name|OPT_std_c__98
comment|/* ISO */
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_c89
case|:
case|case
name|OPT_std_iso9899_1990
case|:
case|case
name|OPT_std_iso9899_199409
case|:
if|if
condition|(
operator|!
name|preprocessing_asm_p
condition|)
name|set_std_c89
argument_list|(
name|code
operator|==
name|OPT_std_iso9899_199409
comment|/* c94 */
argument_list|,
name|true
comment|/* ISO */
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_gnu89
case|:
if|if
condition|(
operator|!
name|preprocessing_asm_p
condition|)
name|set_std_c89
argument_list|(
name|false
comment|/* c94 */
argument_list|,
name|false
comment|/* ISO */
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_c99
case|:
case|case
name|OPT_std_c9x
case|:
case|case
name|OPT_std_iso9899_1999
case|:
case|case
name|OPT_std_iso9899_199x
case|:
if|if
condition|(
operator|!
name|preprocessing_asm_p
condition|)
name|set_std_c99
argument_list|(
name|true
comment|/* ISO */
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_std_gnu99
case|:
case|case
name|OPT_std_gnu9x
case|:
if|if
condition|(
operator|!
name|preprocessing_asm_p
condition|)
name|set_std_c99
argument_list|(
name|false
comment|/* ISO */
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_trigraphs
case|:
name|cpp_opts
operator|->
name|trigraphs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_traditional_cpp
case|:
name|cpp_opts
operator|->
name|traditional
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_undef
case|:
name|flag_undef
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_w
case|:
name|cpp_opts
operator|->
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_v
case|:
name|verbose
operator|=
name|true
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Post-switch processing.  */
end_comment

begin_function
name|bool
name|c_common_post_options
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pfilename
parameter_list|)
block|{
name|struct
name|cpp_callbacks
modifier|*
name|cb
decl_stmt|;
comment|/* Canonicalize the input and output filenames.  */
if|if
condition|(
name|in_fnames
operator|==
name|NULL
condition|)
block|{
name|in_fnames
operator|=
name|XNEWVEC
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|in_fnames
index|[
literal|0
index|]
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|in_fnames
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|in_fnames
index|[
literal|0
index|]
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|out_fname
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|out_fname
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|cpp_opts
operator|->
name|deps
operator|.
name|style
operator|==
name|DEPS_NONE
condition|)
name|check_deps_environment_vars
argument_list|()
expr_stmt|;
name|handle_deferred_opts
argument_list|()
expr_stmt|;
name|sanitize_cpp_opts
argument_list|()
expr_stmt|;
name|register_include_chains
argument_list|(
name|parse_in
argument_list|,
name|sysroot
argument_list|,
name|iprefix
argument_list|,
name|imultilib
argument_list|,
name|std_inc
argument_list|,
name|std_cxx_inc
operator|&&
name|c_dialect_cxx
argument_list|()
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|C_COMMON_OVERRIDE_OPTIONS
comment|/* Some machines may reject certain combinations of C      language-specific options.  */
name|C_COMMON_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
name|flag_inline_trees
operator|=
literal|1
expr_stmt|;
comment|/* Use tree inlining.  */
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_inline_functions
condition|)
name|flag_inline_trees
operator|=
literal|2
expr_stmt|;
comment|/* We recognize -fgnu89-inline in preparation for 4.3 where the      option will be meaningful.  Here we just reject      -fno-gnu89-inline, since we don't support it.  */
if|if
condition|(
operator|!
name|flag_gnu89_inline
condition|)
name|error
argument_list|(
literal|"-fno-gnu89-inline is not supported"
argument_list|)
expr_stmt|;
comment|/* If we are given more than one input file, we must use      unit-at-a-time mode.  */
if|if
condition|(
name|num_in_fnames
operator|>
literal|1
condition|)
name|flag_unit_at_a_time
operator|=
literal|1
expr_stmt|;
comment|/* Default to ObjC sjlj exception handling if NeXT runtime.  */
if|if
condition|(
name|flag_objc_sjlj_exceptions
operator|<
literal|0
condition|)
name|flag_objc_sjlj_exceptions
operator|=
name|flag_next_runtime
expr_stmt|;
if|if
condition|(
name|flag_objc_exceptions
operator|&&
operator|!
name|flag_objc_sjlj_exceptions
condition|)
name|flag_exceptions
operator|=
literal|1
expr_stmt|;
comment|/* -Wextra implies -Wsign-compare, -Wmissing-field-initializers and      -Woverride-init, but not if explicitly overridden.  */
if|if
condition|(
name|warn_sign_compare
operator|==
operator|-
literal|1
condition|)
name|warn_sign_compare
operator|=
name|extra_warnings
expr_stmt|;
if|if
condition|(
name|warn_missing_field_initializers
operator|==
operator|-
literal|1
condition|)
name|warn_missing_field_initializers
operator|=
name|extra_warnings
expr_stmt|;
if|if
condition|(
name|warn_override_init
operator|==
operator|-
literal|1
condition|)
name|warn_override_init
operator|=
name|extra_warnings
expr_stmt|;
comment|/* -Wpointer_sign is disabled by default, but it is enabled if any      of -Wall or -pedantic are given.  */
if|if
condition|(
name|warn_pointer_sign
operator|==
operator|-
literal|1
condition|)
name|warn_pointer_sign
operator|=
literal|0
expr_stmt|;
comment|/* -Woverlength-strings is off by default, but is enabled by -pedantic.      It is never enabled in C++, as the minimum limit is not normative      in that standard.  */
if|if
condition|(
name|warn_overlength_strings
operator|==
operator|-
literal|1
operator|||
name|c_dialect_cxx
argument_list|()
condition|)
name|warn_overlength_strings
operator|=
literal|0
expr_stmt|;
comment|/* Special format checking options don't work without -Wformat; warn if      they are used.  */
if|if
condition|(
operator|!
name|warn_format
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat_y2k
argument_list|,
literal|"-Wformat-y2k ignored without -Wformat"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wformat_extra_args
argument_list|,
literal|"-Wformat-extra-args ignored without -Wformat"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wformat_zero_length
argument_list|,
literal|"-Wformat-zero-length ignored without -Wformat"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wformat_nonliteral
argument_list|,
literal|"-Wformat-nonliteral ignored without -Wformat"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wformat_security
argument_list|,
literal|"-Wformat-security ignored without -Wformat"
argument_list|)
expr_stmt|;
block|}
comment|/* C99 requires special handling of complex multiplication and division;      -ffast-math and -fcx-limited-range are handled in process_options.  */
if|if
condition|(
name|flag_isoc99
condition|)
name|flag_complex_method
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|flag_preprocess_only
condition|)
block|{
comment|/* Open the output now.  We must do so even if flag_no_output is 	 on, because there may be other output than from the actual 	 preprocessing (e.g. from -dM).  */
if|if
condition|(
name|out_fname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|out_stream
operator|=
name|stdout
expr_stmt|;
else|else
name|out_stream
operator|=
name|fopen
argument_list|(
name|out_fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_stream
operator|==
name|NULL
condition|)
block|{
name|fatal_error
argument_list|(
literal|"opening output file %s: %m"
argument_list|,
name|out_fname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|num_in_fnames
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"too many filenames given.  Type %s --help for usage"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|init_pp_output
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init_c_lex
argument_list|()
expr_stmt|;
comment|/* Yuk.  WTF is this?  I do know ObjC relies on it somewhere.  */
name|input_location
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
block|}
name|cb
operator|=
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|cb
operator|->
name|file_change
operator|=
name|cb_file_change
expr_stmt|;
name|cb
operator|->
name|dir_change
operator|=
name|cb_dir_change
expr_stmt|;
name|cpp_post_options
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
comment|/* If an error has occurred in cpplib, note it so we fail      immediately.  */
name|errorcount
operator|+=
name|cpp_errors
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
operator|*
name|pfilename
operator|=
name|this_input_filename
operator|=
name|cpp_read_main_file
argument_list|(
name|parse_in
argument_list|,
name|in_fnames
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Don't do any compilation or preprocessing if there is no input file.  */
if|if
condition|(
name|this_input_filename
operator|==
name|NULL
condition|)
block|{
name|errorcount
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|flag_working_directory
operator|&&
name|flag_preprocess_only
operator|&&
operator|!
name|flag_no_line_commands
condition|)
name|pp_dir_change
argument_list|(
name|parse_in
argument_list|,
name|get_src_pwd
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|flag_preprocess_only
return|;
block|}
end_function

begin_comment
comment|/* Front end initialization common to C, ObjC and C++.  */
end_comment

begin_function
name|bool
name|c_common_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set up preprocessor arithmetic.  Must be done after call to      c_common_nodes_and_builtins for type nodes to be good.  */
name|cpp_opts
operator|->
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|intmax_type_node
argument_list|)
expr_stmt|;
name|cpp_opts
operator|->
name|char_precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|cpp_opts
operator|->
name|int_precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|cpp_opts
operator|->
name|wchar_precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|cpp_opts
operator|->
name|unsigned_wchar
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|cpp_opts
operator|->
name|bytes_big_endian
operator|=
name|BYTES_BIG_ENDIAN
expr_stmt|;
comment|/* This can't happen until after wchar_precision and bytes_big_endian      are known.  */
name|cpp_init_iconv
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_flag
condition|)
name|c_common_print_pch_checksum
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_preprocess_only
condition|)
block|{
name|finish_options
argument_list|()
expr_stmt|;
name|preprocess_file
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Has to wait until now so that cpplib has its hash table.  */
name|init_pragma
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Initialize the integrated preprocessor after debug output has been    initialized; loop over each input file.  */
end_comment

begin_function
name|void
name|c_common_parse_file
parameter_list|(
name|int
name|set_yydebug
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Enable parser debugging, if requested and we can.  If requested      and we can't, notify the user.  */
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|yydebug
operator|=
name|set_yydebug
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|set_yydebug
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"YYDEBUG was not defined at build time, -dy ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Start the main input file, if the debug writer wants it. */
if|if
condition|(
name|debug_hooks
operator|->
name|start_end_main_source_file
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|start_source_file
call|)
argument_list|(
literal|0
argument_list|,
name|this_input_filename
argument_list|)
expr_stmt|;
name|finish_options
argument_list|()
expr_stmt|;
name|pch_init
argument_list|()
expr_stmt|;
name|push_file_scope
argument_list|()
expr_stmt|;
name|c_parse_file
argument_list|()
expr_stmt|;
name|finish_file
argument_list|()
expr_stmt|;
name|pop_file_scope
argument_list|()
expr_stmt|;
comment|/* And end the main input file, if the debug writer wants it  */
if|if
condition|(
name|debug_hooks
operator|->
name|start_end_main_source_file
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|end_source_file
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|num_in_fnames
condition|)
break|break;
name|cpp_undef_all
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
name|this_input_filename
operator|=
name|cpp_read_main_file
argument_list|(
name|parse_in
argument_list|,
name|in_fnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* If an input file is missing, abandon further compilation. 	 cpplib has issued a diagnostic.  */
if|if
condition|(
operator|!
name|this_input_filename
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Common finish hook for the C, ObjC and C++ front ends.  */
end_comment

begin_function
name|void
name|c_common_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|deps_stream
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cpp_opts
operator|->
name|deps
operator|.
name|style
operator|!=
name|DEPS_NONE
condition|)
block|{
comment|/* If -M or -MM was seen without -MF, default output to the 	 output stream.  */
if|if
condition|(
operator|!
name|deps_file
condition|)
name|deps_stream
operator|=
name|out_stream
expr_stmt|;
else|else
block|{
name|deps_stream
operator|=
name|fopen
argument_list|(
name|deps_file
argument_list|,
name|deps_append
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deps_stream
condition|)
name|fatal_error
argument_list|(
literal|"opening dependency file %s: %m"
argument_list|,
name|deps_file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For performance, avoid tearing down cpplib's internal structures      with cpp_destroy ().  */
name|errorcount
operator|+=
name|cpp_finish
argument_list|(
name|parse_in
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_stream
operator|&&
name|deps_stream
operator|!=
name|out_stream
operator|&&
operator|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|deps_stream
argument_list|)
operator|)
condition|)
name|fatal_error
argument_list|(
literal|"closing dependency file %s: %m"
argument_list|,
name|deps_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_stream
operator|&&
operator|(
name|ferror
argument_list|(
name|out_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|out_stream
argument_list|)
operator|)
condition|)
name|fatal_error
argument_list|(
literal|"when writing output to %s: %m"
argument_list|,
name|out_fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Either of two environment variables can specify output of    dependencies.  Their value is either "OUTPUT_FILE" or "OUTPUT_FILE    DEPS_TARGET", where OUTPUT_FILE is the file to write deps info to    and DEPS_TARGET is the target to mention in the deps.  They also    result in dependency information being appended to the output file    rather than overwriting it, and like Sun's compiler    SUNPRO_DEPENDENCIES suppresses the dependency on the main file.  */
end_comment

begin_function
specifier|static
name|void
name|check_deps_environment_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|spec
decl_stmt|;
name|GET_ENVIRONMENT
argument_list|(
name|spec
argument_list|,
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
name|cpp_opts
operator|->
name|deps
operator|.
name|style
operator|=
name|DEPS_USER
expr_stmt|;
else|else
block|{
name|GET_ENVIRONMENT
argument_list|(
name|spec
argument_list|,
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
block|{
name|cpp_opts
operator|->
name|deps
operator|.
name|style
operator|=
name|DEPS_SYSTEM
expr_stmt|;
name|cpp_opts
operator|->
name|deps
operator|.
name|ignore_main_file
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spec
condition|)
block|{
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
name|char
modifier|*
name|s
init|=
name|strchr
argument_list|(
name|spec
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* Let the caller perform MAKE quoting.  */
name|defer_opt
argument_list|(
name|OPT_MT
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Command line -MF overrides environment variables and default.  */
if|if
condition|(
operator|!
name|deps_file
condition|)
name|deps_file
operator|=
name|spec
expr_stmt|;
name|deps_append
operator|=
literal|1
expr_stmt|;
name|deps_seen
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle deferred command line switches.  */
end_comment

begin_function
specifier|static
name|void
name|handle_deferred_opts
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|deps
modifier|*
name|deps
decl_stmt|;
comment|/* Avoid allocating the deps buffer if we don't need it.      (This flag may be true without there having been -MT or -MQ      options, but we'll still need the deps buffer.)  */
if|if
condition|(
operator|!
name|deps_seen
condition|)
return|return;
name|deps
operator|=
name|cpp_get_deps
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|deferred_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|deferred_opt
modifier|*
name|opt
init|=
operator|&
name|deferred_opts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|code
operator|==
name|OPT_MT
operator|||
name|opt
operator|->
name|code
operator|==
name|OPT_MQ
condition|)
name|deps_add_target
argument_list|(
name|deps
argument_list|,
name|opt
operator|->
name|arg
argument_list|,
name|opt
operator|->
name|code
operator|==
name|OPT_MQ
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These settings are appropriate for GCC, but not necessarily so for    cpplib as a library.  */
end_comment

begin_function
specifier|static
name|void
name|sanitize_cpp_opts
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If we don't know what style of dependencies to output, complain      if any other dependency switches have been given.  */
if|if
condition|(
name|deps_seen
operator|&&
name|cpp_opts
operator|->
name|deps
operator|.
name|style
operator|==
name|DEPS_NONE
condition|)
name|error
argument_list|(
literal|"to generate dependencies you must specify either -M or -MM"
argument_list|)
expr_stmt|;
comment|/* -dM and dependencies suppress normal output; do it here so that      the last -d[MDN] switch overrides earlier ones.  */
if|if
condition|(
name|flag_dump_macros
operator|==
literal|'M'
condition|)
name|flag_no_output
operator|=
literal|1
expr_stmt|;
comment|/* Disable -dD, -dN and -dI if normal output is suppressed.  Allow      -dM since at least glibc relies on -M -dM to work.  */
comment|/* Also, flag_no_output implies flag_no_line_commands, always.  */
if|if
condition|(
name|flag_no_output
condition|)
block|{
if|if
condition|(
name|flag_dump_macros
operator|!=
literal|'M'
condition|)
name|flag_dump_macros
operator|=
literal|0
expr_stmt|;
name|flag_dump_includes
operator|=
literal|0
expr_stmt|;
name|flag_no_line_commands
operator|=
literal|1
expr_stmt|;
block|}
name|cpp_opts
operator|->
name|unsigned_char
operator|=
operator|!
name|flag_signed_char
expr_stmt|;
name|cpp_opts
operator|->
name|stdc_0_in_system_headers
operator|=
name|STDC_0_IN_SYSTEM_HEADERS
expr_stmt|;
comment|/* We want -Wno-long-long to override -pedantic -std=non-c99      and/or -Wtraditional, whatever the ordering.  */
name|cpp_opts
operator|->
name|warn_long_long
operator|=
name|warn_long_long
operator|&&
operator|(
operator|(
operator|!
name|flag_isoc99
operator|&&
name|pedantic
operator|)
operator|||
name|warn_traditional
operator|)
expr_stmt|;
comment|/* Similarly with -Wno-variadic-macros.  No check for c99 here, since      this also turns off warnings about GCCs extension.  */
name|cpp_opts
operator|->
name|warn_variadic_macros
operator|=
name|warn_variadic_macros
operator|&&
operator|(
name|pedantic
operator|||
name|warn_traditional
operator|)
expr_stmt|;
comment|/* If we're generating preprocessor output, emit current directory      if explicitly requested or if debugging information is enabled.      ??? Maybe we should only do it for debugging formats that      actually output the current directory?  */
if|if
condition|(
name|flag_working_directory
operator|==
operator|-
literal|1
condition|)
name|flag_working_directory
operator|=
operator|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_NONE
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add include path with a prefix at the front of its name.  */
end_comment

begin_function
specifier|static
name|void
name|add_prefixed_path
parameter_list|(
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|size_t
name|chain
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|size_t
name|prefix_len
decl_stmt|,
name|suffix_len
decl_stmt|;
name|suffix_len
operator|=
name|strlen
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|iprefix
condition|?
name|iprefix
else|:
name|cpp_GCC_INCLUDE_DIR
expr_stmt|;
name|prefix_len
operator|=
name|iprefix
condition|?
name|strlen
argument_list|(
name|iprefix
argument_list|)
else|:
name|cpp_GCC_INCLUDE_DIR_len
expr_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|prefix_len
operator|+
name|suffix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|prefix_len
argument_list|,
name|suffix
argument_list|,
name|suffix_len
argument_list|)
expr_stmt|;
name|path
index|[
name|prefix_len
operator|+
name|suffix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add_path
argument_list|(
name|path
argument_list|,
name|chain
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle -D, -U, -A, -imacros, and the first -include.  */
end_comment

begin_function
specifier|static
name|void
name|finish_options
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cpp_opts
operator|->
name|preprocessed
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|cb_file_change
argument_list|(
name|parse_in
argument_list|,
name|linemap_add
argument_list|(
operator|&
name|line_table
argument_list|,
name|LC_RENAME
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"<built-in>"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cpp_init_builtins
argument_list|(
name|parse_in
argument_list|,
name|flag_hosted
argument_list|)
expr_stmt|;
name|c_cpp_builtins
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
comment|/* We're about to send user input to cpplib, so make it warn for 	 things that we previously (when we sent it internal definitions) 	 told it to not warn.  	 C99 permits implementation-defined characters in identifiers. 	 The documented meaning of -std= is to turn off extensions that 	 conflict with the specified standard, and since a strictly 	 conforming program cannot contain a '$', we do not condition 	 their acceptance on the -std= setting.  */
name|cpp_opts
operator|->
name|warn_dollars
operator|=
operator|(
name|cpp_opts
operator|->
name|pedantic
operator|&&
operator|!
name|cpp_opts
operator|->
name|c99
operator|)
expr_stmt|;
name|cb_file_change
argument_list|(
name|parse_in
argument_list|,
name|linemap_add
argument_list|(
operator|&
name|line_table
argument_list|,
name|LC_RENAME
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"<command-line>"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|deferred_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|deferred_opt
modifier|*
name|opt
init|=
operator|&
name|deferred_opts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|code
operator|==
name|OPT_D
condition|)
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|opt
operator|->
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|code
operator|==
name|OPT_U
condition|)
name|cpp_undef
argument_list|(
name|parse_in
argument_list|,
name|opt
operator|->
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|code
operator|==
name|OPT_A
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|cpp_unassert
argument_list|(
name|parse_in
argument_list|,
name|opt
operator|->
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|cpp_assert
argument_list|(
name|parse_in
argument_list|,
name|opt
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle -imacros after -D and -U.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|deferred_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|deferred_opt
modifier|*
name|opt
init|=
operator|&
name|deferred_opts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|code
operator|==
name|OPT_imacros
operator|&&
name|cpp_push_include
argument_list|(
name|parse_in
argument_list|,
name|opt
operator|->
name|arg
argument_list|)
condition|)
block|{
comment|/* Disable push_command_line_include callback for now.  */
name|include_cursor
operator|=
name|deferred_count
operator|+
literal|1
expr_stmt|;
name|cpp_scan_nooutput
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|include_cursor
operator|=
literal|0
expr_stmt|;
name|push_command_line_include
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Give CPP the next file given by -include, if any.  */
end_comment

begin_function
specifier|static
name|void
name|push_command_line_include
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|include_cursor
operator|<
name|deferred_count
condition|)
block|{
name|struct
name|deferred_opt
modifier|*
name|opt
init|=
operator|&
name|deferred_opts
index|[
name|include_cursor
operator|++
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cpp_opts
operator|->
name|preprocessed
operator|&&
name|opt
operator|->
name|code
operator|==
name|OPT_include
operator|&&
name|cpp_push_include
argument_list|(
name|parse_in
argument_list|,
name|opt
operator|->
name|arg
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|include_cursor
operator|==
name|deferred_count
condition|)
block|{
name|include_cursor
operator|++
expr_stmt|;
comment|/* -Wunused-macros should only warn about macros defined hereafter.  */
name|cpp_opts
operator|->
name|warn_unused_macros
operator|=
name|warn_unused_macros
expr_stmt|;
comment|/* Restore the line map from<command line>.  */
if|if
condition|(
operator|!
name|cpp_opts
operator|->
name|preprocessed
condition|)
name|cpp_change_file
argument_list|(
name|parse_in
argument_list|,
name|LC_RENAME
argument_list|,
name|this_input_filename
argument_list|)
expr_stmt|;
comment|/* Set this here so the client can change the option if it wishes, 	 and after stacking the main file so we don't trace the main file.  */
name|line_table
operator|.
name|trace_includes
operator|=
name|cpp_opts
operator|->
name|print_include_names
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* File change callback.  Has to handle -include files.  */
end_comment

begin_function
specifier|static
name|void
name|cb_file_change
parameter_list|(
name|cpp_reader
modifier|*
name|ARG_UNUSED
parameter_list|(
name|pfile
parameter_list|)
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
name|new_map
parameter_list|)
block|{
if|if
condition|(
name|flag_preprocess_only
condition|)
name|pp_file_change
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
else|else
name|fe_file_change
argument_list|(
name|new_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_map
operator|==
literal|0
operator|||
operator|(
name|new_map
operator|->
name|reason
operator|==
name|LC_LEAVE
operator|&&
name|MAIN_FILE_P
argument_list|(
name|new_map
argument_list|)
operator|)
condition|)
name|push_command_line_include
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cb_dir_change
parameter_list|(
name|cpp_reader
modifier|*
name|ARG_UNUSED
parameter_list|(
name|pfile
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
if|if
condition|(
operator|!
name|set_src_pwd
argument_list|(
name|dir
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"too late for # directive to set debug directory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the C 89 standard (with 1994 amendments if C94, without GNU    extensions if ISO).  There is no concept of gnu94.  */
end_comment

begin_function
specifier|static
name|void
name|set_std_c89
parameter_list|(
name|int
name|c94
parameter_list|,
name|int
name|iso
parameter_list|)
block|{
name|cpp_set_lang
argument_list|(
name|parse_in
argument_list|,
name|c94
condition|?
name|CLK_STDC94
else|:
name|iso
condition|?
name|CLK_STDC89
else|:
name|CLK_GNUC89
argument_list|)
expr_stmt|;
name|flag_iso
operator|=
name|iso
expr_stmt|;
name|flag_no_asm
operator|=
name|iso
expr_stmt|;
name|flag_no_gnu_keywords
operator|=
name|iso
expr_stmt|;
name|flag_no_nonansi_builtin
operator|=
name|iso
expr_stmt|;
name|flag_isoc94
operator|=
name|c94
expr_stmt|;
name|flag_isoc99
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the C 99 standard (without GNU extensions if ISO).  */
end_comment

begin_function
specifier|static
name|void
name|set_std_c99
parameter_list|(
name|int
name|iso
parameter_list|)
block|{
name|cpp_set_lang
argument_list|(
name|parse_in
argument_list|,
name|iso
condition|?
name|CLK_STDC99
else|:
name|CLK_GNUC99
argument_list|)
expr_stmt|;
name|flag_no_asm
operator|=
name|iso
expr_stmt|;
name|flag_no_nonansi_builtin
operator|=
name|iso
expr_stmt|;
name|flag_iso
operator|=
name|iso
expr_stmt|;
name|flag_isoc99
operator|=
literal|1
expr_stmt|;
name|flag_isoc94
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the C++ 98 standard (without GNU extensions if ISO).  */
end_comment

begin_function
specifier|static
name|void
name|set_std_cxx98
parameter_list|(
name|int
name|iso
parameter_list|)
block|{
name|cpp_set_lang
argument_list|(
name|parse_in
argument_list|,
name|iso
condition|?
name|CLK_CXX98
else|:
name|CLK_GNUCXX
argument_list|)
expr_stmt|;
name|flag_no_gnu_keywords
operator|=
name|iso
expr_stmt|;
name|flag_no_nonansi_builtin
operator|=
name|iso
expr_stmt|;
name|flag_iso
operator|=
name|iso
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle setting implicit to ON.  */
end_comment

begin_function
specifier|static
name|void
name|set_Wimplicit
parameter_list|(
name|int
name|on
parameter_list|)
block|{
name|warn_implicit
operator|=
name|on
expr_stmt|;
name|warn_implicit_int
operator|=
name|on
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|mesg_implicit_function_declaration
operator|!=
literal|2
condition|)
name|mesg_implicit_function_declaration
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|mesg_implicit_function_declaration
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Args to -d specify what to dump.  Silently ignore    unrecognized options; they may be aimed at toplev.c.  */
end_comment

begin_function
specifier|static
name|void
name|handle_OPT_d
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|arg
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
comment|/* Dump macros only.  */
case|case
literal|'N'
case|:
comment|/* Dump names.  */
case|case
literal|'D'
case|:
comment|/* Dump definitions.  */
name|flag_dump_macros
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|flag_dump_includes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

