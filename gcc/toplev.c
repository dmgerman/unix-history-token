begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level of GCC compilers (cc1, cc1plus, etc.)    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This is the top level of cc1/c++.    It parses command args, opens files, invokes the various passes    in the proper order, and counts the time used by each.    Error messages and low-level interface to malloc also handled here.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"line-map.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"graph.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|general_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_compile
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|backend_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lang_dependent_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_asm_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finalize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|crash_signal
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|setup_core_dumping
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compile_file
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_single_switch
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_switch_values
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero to dump debug info whilst parsing (-dy option).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|set_yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we don't need a backend (e.g. preprocessing only).  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|no_backend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of line when printing switch values.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LINE
value|75
end_define

begin_comment
comment|/* Name of program invoked, sans directories.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of argument vector to toplev_main.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|save_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of top-level original source file (what was input to cpp).    This comes from the #-command at the beginning of the actual input.    If there isn't any there, then this is the cc1 input file name.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|main_input_filename
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MAPPED_LOCATION
end_ifndef

begin_decl_stmt
name|location_t
name|unknown_location
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used to enable -fvar-tracking, -fweb and -frename-registers according    to optimize and default_debug_hooks in process_options ().  */
end_comment

begin_define
define|#
directive|define
name|AUTODETECT_VALUE
value|2
end_define

begin_comment
comment|/* Current position in real source file.  */
end_comment

begin_decl_stmt
name|location_t
name|input_location
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|line_maps
name|line_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if it is unsafe to create any new pseudo registers.  */
end_comment

begin_decl_stmt
name|int
name|no_new_pseudos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of currently pending input files.  */
end_comment

begin_decl_stmt
name|struct
name|file_stack
modifier|*
name|input_file_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented on each change to input_file_stack.  */
end_comment

begin_decl_stmt
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record of input_file_stack at each tick.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|file_stack
modifier|*
name|fs_p
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|fs_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|fs_p
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|fs_p
argument_list|,
name|heap
argument_list|)
operator|*
name|input_file_stack_history
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Whether input_file_stack has been restored to a previous state (in    which case there should be no more pushing).  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|input_file_stack_restored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as base of names for dump output files.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name to use as a base for auxiliary output files.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|aux_base_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit flags that specify the machine subtype we are compiling for.    Bits are tested using macros TARGET_... defined in the tm.h file    and set by `-m...' switches.  Must be defined in rtlanal.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|target_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A mask of target_flags that includes bit X if X was set or cleared    on the command line.  */
end_comment

begin_decl_stmt
name|int
name|target_flags_explicit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug hooks - dependent upon command line options.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
modifier|*
name|debug_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug hooks - target default.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|gcc_debug_hooks
modifier|*
name|default_debug_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other flags saying which kinds of debugging dump have been requested.  */
end_comment

begin_decl_stmt
name|int
name|rtl_dump_and_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_print_asm_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|graph_dump_types
name|graph_dump_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name for output file of assembly code, specified with -o.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|asm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do optimizations.  -O.    Particular numeric values stand for particular amounts of optimization;    thus, -O2 stores 2 here.  However, the optimizations beyond the basic    ones are not controlled directly by this variable.  Instead, they are    controlled by individual `flag_...' variables that are defaulted    based on this variable.  */
end_comment

begin_decl_stmt
name|int
name|optimize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means optimize for size.  -Os.    The only valid values are zero and nonzero. When optimize_size is    nonzero, optimize defaults to 2, but certain individual code    bloating optimizations are disabled.  */
end_comment

begin_decl_stmt
name|int
name|optimize_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to the FUNC_BEGIN label of the current function, or NULL    if none.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|current_function_func_begin_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporarily suppress certain warnings.    This is set while reading code from a system header file.  */
end_comment

begin_decl_stmt
name|int
name|in_system_header
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to collect statistics which might be expensive    and to print them when we are done.  */
end_comment

begin_decl_stmt
name|int
name|flag_detailed_statistics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A random sequence of characters, unless overridden by user.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|flag_random_seed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A local time stamp derived from the time of compilation. It will be    zero if the system cannot provide a time.  It will be -1u, if the    user has specified a particular random seed.  */
end_comment

begin_decl_stmt
name|unsigned
name|local_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -f flags.  */
end_comment

begin_comment
comment|/* Nonzero means `char' should be signed.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give an enum type only as many bytes as it needs.  A value    of 2 means it has not yet been initialized.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_enums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if structures and unions should be returned in memory.     This should only be defined if compatibility with another compiler or    with an ABI is needed, because it results in slower code.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PCC_STRUCT_RETURN
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PCC_STRUCT_RETURN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_pcc_struct_return
init|=
name|DEFAULT_PCC_STRUCT_RETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means straightforward implementation of complex divide acceptable.    1 means wide ranges of inputs must work for complex divide.    2 means C99-like requirements for complex multiply and divide.  */
end_comment

begin_decl_stmt
name|int
name|flag_complex_method
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we don't want inlining by virtue of -fno-inline,    not just because the tree inliner turned us off.  */
end_comment

begin_decl_stmt
name|int
name|flag_really_no_inline
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should be saving declaration info into a .X file.  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_aux_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Specified name of aux-info file.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|aux_info_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are compiling code for a shared library, zero for    executable.  */
end_comment

begin_decl_stmt
name|int
name|flag_shlib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate code for GNU or NeXT Objective-C runtime environment.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEXT_OBJC_RUNTIME
end_ifdef

begin_decl_stmt
name|int
name|flag_next_runtime
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|flag_next_runtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set to the default thread-local storage (tls) model to use.  */
end_comment

begin_decl_stmt
name|enum
name|tls_model
name|flag_tls_default
init|=
name|TLS_MODEL_GLOBAL_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means change certain warnings into errors.    Usually these are warnings about failure to conform to some standard.  */
end_comment

begin_decl_stmt
name|int
name|flag_pedantic_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dA causes debug commentary information to be produced in    the generated assembly code (to make it more readable).  This option    is generally only of use to those who actually need to read the    generated assembly code (perhaps while debugging the compiler itself).    Currently, this switch is only used by dwarfout.c; however, it is intended    to be a catchall for printing debug information in the assembler file.  */
end_comment

begin_decl_stmt
name|int
name|flag_debug_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dP causes the rtl to be emitted as a comment in assembly.  */
end_comment

begin_decl_stmt
name|int
name|flag_dump_rtl_in_asm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-NULL, indicates that whenever space is allocated on the    stack, the resulting stack pointer must not pass this    address---that is, for stacks that grow downward, the stack pointer    must always be greater than or equal to this address; for stacks    that grow upward, the stack pointer must be less than this address.    At present, the rtx may be either a REG or a SYMBOL_REF, although    the support provided depends on the backend.  */
end_comment

begin_decl_stmt
name|rtx
name|stack_limit_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If one, renumber instruction UIDs to reduce the number of    unused UIDs if there are a lot of instructions.  If greater than    one, unconditionally renumber instruction UIDs.  */
end_comment

begin_decl_stmt
name|int
name|flag_renumber_insns
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should track variables.  When    flag_var_tracking == AUTODETECT_VALUE it will be set according    to optimize, debug_info_level and debug_hooks in process_options ().  */
end_comment

begin_decl_stmt
name|int
name|flag_var_tracking
init|=
name|AUTODETECT_VALUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if the user has tagged the function with the 'section'    attribute.  */
end_comment

begin_decl_stmt
name|bool
name|user_defined_section_attribute
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values of the -falign-* flags: how much to align labels in code.    0 means `use default', 1 means `don't align'.    For each variable, there is an _log variant which is the power    of two not less than the variable, for .align output.  */
end_comment

begin_decl_stmt
name|int
name|align_loops_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_loops_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_jumps_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_labels_max_skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|align_functions_log
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like align_functions_log above, but used by front-ends to force the    minimum function alignment.  Zero means no alignment is forced.  */
end_comment

begin_decl_stmt
name|int
name|force_align_functions_log
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
name|int
modifier|*
specifier|const
name|variable
decl_stmt|;
specifier|const
name|int
name|on_value
decl_stmt|;
block|}
name|lang_independent_options
typedef|;
end_typedef

begin_comment
comment|/* Nonzero if subexpressions must be evaluated from left-to-right.  */
end_comment

begin_decl_stmt
name|int
name|flag_evaluation_order
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user symbol prefix after having resolved same.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|user_label_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|param_info
name|lang_independent_params
index|[]
init|=
block|{
define|#
directive|define
name|DEFPARAM
parameter_list|(
name|ENUM
parameter_list|,
name|OPTION
parameter_list|,
name|HELP
parameter_list|,
name|DEFAULT
parameter_list|,
name|MIN
parameter_list|,
name|MAX
parameter_list|)
define|\
value|{ OPTION, DEFAULT, MIN, MAX, HELP },
include|#
directive|include
file|"params.def"
undef|#
directive|undef
name|DEFPARAM
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output files for assembler code (real compiler output)    and debugging dumps.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|aux_info_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dump_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dump_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current working directory of a translation.  It's generally the    directory from which compilation was initiated, but a preprocessed    file may specify the original directory in which it was    created.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|src_pwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize src_pwd with the given string, and return true.  If it    was already initialized, return false.  As a special case, it may    be called with a NULL argument to test whether src_pwd has NOT been    initialized yet.  */
end_comment

begin_function
name|bool
name|set_src_pwd
parameter_list|(
specifier|const
name|char
modifier|*
name|pwd
parameter_list|)
block|{
if|if
condition|(
name|src_pwd
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|src_pwd
argument_list|,
name|pwd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
name|src_pwd
operator|=
name|xstrdup
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the directory from which the translation unit was initiated,    in case set_src_pwd() was not called before to assign it a    different value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_src_pwd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|src_pwd
condition|)
block|{
name|src_pwd
operator|=
name|getpwd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|src_pwd
condition|)
name|src_pwd
operator|=
literal|"."
expr_stmt|;
block|}
return|return
name|src_pwd
return|;
block|}
end_function

begin_comment
comment|/* Called when the start of a function definition is parsed,    this function prints on stderr the name of the function.  */
end_comment

begin_function
name|void
name|announce_function
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
if|if
condition|(
name|rtl_dump_and_exit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|)
operator|=
name|true
expr_stmt|;
name|diagnostic_set_last_function
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up a default flag_random_seed and local_tick, unless the user    already specified one.  */
end_comment

begin_function
specifier|static
name|void
name|randomize
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_random_seed
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
specifier|static
name|char
name|random_seed
index|[
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|4
operator|+
literal|3
index|]
decl_stmt|;
comment|/* Get some more or less random data.  */
ifdef|#
directive|ifdef
name|HAVE_GETTIMEOFDAY
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|local_tick
operator|=
name|tv
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
block|}
else|#
directive|else
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|now
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|local_tick
operator|=
operator|(
name|unsigned
operator|)
name|now
expr_stmt|;
block|}
endif|#
directive|endif
name|value
operator|=
name|local_tick
operator|^
name|getpid
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|random_seed
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|flag_random_seed
operator|=
name|random_seed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|local_tick
condition|)
name|local_tick
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the string P as an integral parameter.    If the string is indeed an integer return its numeric value else    issue an Invalid Option error for the option PNAME and return DEFVAL.    If PNAME is zero just return DEFVAL, do not call error.  */
end_comment

begin_function
name|int
name|read_integral_parameter
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|int
name|defval
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|endp
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|endp
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|endp
argument_list|)
condition|)
name|endp
operator|++
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|endp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pname
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"invalid option argument %qs"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
name|defval
return|;
block|}
return|return
name|atoi
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* When compiling with a recent enough GCC, we use the GNU C "extern inline"    for floor_log2 and exact_log2; see toplev.h.  That construct, however,    conflicts with the ISO C++ One Definition Rule.   */
end_comment

begin_if
if|#
directive|if
name|GCC_VERSION
operator|<
literal|3004
operator|||
operator|!
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_comment
comment|/* Given X, an unsigned number, return the largest int Y such that 2**Y<= X.    If X is 0, return -1.  */
end_comment

begin_function
name|int
name|floor_log2
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|x
parameter_list|)
block|{
name|int
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|CLZ_HWI
name|t
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|-
operator|(
name|int
operator|)
name|CLZ_HWI
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|64
condition|)
if|if
condition|(
name|x
operator|>=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|t
operator|+
literal|64
operator|)
condition|)
name|t
operator|+=
literal|64
expr_stmt|;
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
condition|)
if|if
condition|(
name|x
operator|>=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|t
operator|+
literal|32
operator|)
condition|)
name|t
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|t
operator|+
literal|16
operator|)
condition|)
name|t
operator|+=
literal|16
expr_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|t
operator|+
literal|8
operator|)
condition|)
name|t
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|t
operator|+
literal|4
operator|)
condition|)
name|t
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|t
operator|+
literal|2
operator|)
condition|)
name|t
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|t
operator|+
literal|1
operator|)
condition|)
name|t
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned,    if X is a power of 2.  Otherwise, returns -1.  */
end_comment

begin_function
name|int
name|exact_log2
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|!=
operator|(
name|x
operator|&
operator|-
name|x
operator|)
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|CTZ_HWI
return|return
name|x
condition|?
name|CTZ_HWI
argument_list|(
name|x
argument_list|)
else|:
operator|-
literal|1
return|;
else|#
directive|else
return|return
name|floor_log2
argument_list|(
name|x
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  GCC_VERSION< 3004 || !defined (__cplusplus)  */
end_comment

begin_comment
comment|/* Handler for fatal signals, such as SIGSEGV.  These are transformed    into ICE messages, which is much more user friendly.  In case the    error printer crashes, reset the signal to prevent infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|crash_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* If we crashed while processing an ASM statement, then be a little more      graceful.  It's most likely the user's fault.  */
if|if
condition|(
name|this_is_asm_operands
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"unrecoverable error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|internal_error
argument_list|(
literal|"%s"
argument_list|,
name|strsignal
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Arrange to dump core on error.  (The regular error message is still    printed first, except in the case of abort().)  */
end_comment

begin_function
specifier|static
name|void
name|setup_core_dumping
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"getting core file size maximum limit: %m"
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|rlim
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"setting core file size limit to maximum: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|diagnostic_abort_on_error
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip off a legitimate source ending from the input string NAME of    length LEN.  Rather than having to know the names used by all of    our front ends, we strip off an ending of a period followed by    up to five characters.  (Java uses ".class".)  */
end_comment

begin_function
name|void
name|strip_off_ending
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|6
operator|&&
name|len
operator|>
name|i
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
operator|-
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|name
index|[
name|len
operator|-
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output a quoted string.  */
end_comment

begin_function
name|void
name|output_quoted_string
parameter_list|(
name|FILE
modifier|*
name|asm_file
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OUTPUT_QUOTED_STRING
name|OUTPUT_QUOTED_STRING
argument_list|(
name|asm_file
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|c
decl_stmt|;
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\"'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output a file name in the form wanted by System V.  */
end_comment

begin_function
name|void
name|output_file_directive
parameter_list|(
name|FILE
modifier|*
name|asm_file
parameter_list|,
specifier|const
name|char
modifier|*
name|input_name
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|na
decl_stmt|;
if|if
condition|(
name|input_name
operator|==
name|NULL
condition|)
name|input_name
operator|=
literal|"<stdin>"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
name|na
operator|=
name|input_name
operator|+
name|len
expr_stmt|;
comment|/* NA gets INPUT_NAME sans directory names.  */
while|while
condition|(
name|na
operator|>
name|input_name
condition|)
block|{
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|na
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
name|na
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\t.file\t"
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A subroutine of wrapup_global_declarations.  We've come to the end of    the compilation unit.  All deferred variables should be undeferred,    and all incomplete decls should be finalized.  */
end_comment

begin_function
name|void
name|wrapup_global_declaration_1
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* We're not deferring this any longer.  Assignment is conditional to      avoid needlessly dirtying PCH pages.  */
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TS_DECL_WITH_VIS
argument_list|)
operator|&&
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|lang_hooks
operator|.
name|finish_incomplete_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of wrapup_global_declarations.  Decide whether or not DECL    needs to be output.  Return true if it is output.  */
end_comment

begin_function
name|bool
name|wrapup_global_declaration_2
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Don't write out static consts, unless we still need them.       We also keep static consts if not optimizing (for debugging),      unless the user specified -fno-keep-static-consts.      ??? They might be better written into the debug information.      This is possible when using DWARF.       A language processor that wants static constants to be always      written out (even if it is not used) is responsible for      calling rest_of_decl_compilation itself.  E.g. the C front-end      calls rest_of_decl_compilation from finish_decl.      One motivation for this is that is conventional in some      environments to write things like:      static const char rcsid[] = "... version string ...";      intending to force the string to be in the executable.       A language processor that would prefer to have unneeded      static constants "optimized away" would just defer writing      them out until here.  E.g. C++ does this, because static      constants are often defined in header files.       ??? A tempting alternative (for both C and C++) would be      to force a constant to be written if and only if it is      defined in a main file, as opposed to an include file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
decl_stmt|;
name|bool
name|needed
init|=
name|true
decl_stmt|;
name|node
operator|=
name|cgraph_varpool_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|finalized
condition|)
name|needed
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|alias
condition|)
name|needed
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cgraph_global_info_ready
operator|&&
operator|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* needed */
empty_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|needed
condition|)
comment|/* needed */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
name|needed
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|optimize
operator|||
operator|!
name|flag_keep_static_consts
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|needed
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|needed
condition|)
block|{
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Do any final processing required for the declarations in VEC, of    which there are LEN.  We write out inline functions and variables    that have been deferred until this point, but which are required.    Returns nonzero if anything was put out.  */
end_comment

begin_function
name|bool
name|wrapup_global_declarations
parameter_list|(
name|tree
modifier|*
name|vec
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|bool
name|reconsider
decl_stmt|,
name|output_something
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|wrapup_global_declaration_1
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Now emit any global variables or functions that we have been      putting off.  We need to loop in case one of the things emitted      here references another one which comes earlier in the list.  */
do|do
block|{
name|reconsider
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|reconsider
operator||=
name|wrapup_global_declaration_2
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reconsider
condition|)
name|output_something
operator|=
name|true
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
return|return
name|output_something
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of check_global_declarations.  Issue appropriate warnings    for the global declaration DECL.  */
end_comment

begin_function
name|void
name|check_global_declaration_1
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Warn about any function declared static but not defined.  We don't      warn about variables, because many programs have static variables      that exist only to get some text into the object file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|warn_unused_function
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%q+F used but never defined"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q+F declared %<static%> but never defined"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* This symbol is effectively an "extern" declaration now.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about static fns or vars defined but not used.  */
if|if
condition|(
operator|(
operator|(
name|warn_unused_function
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
comment|/* We don't warn about "static const" variables because the 	  "rcs_id" idiom uses that construction.  */
operator|||
operator|(
name|warn_unused_variable
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
comment|/* The TREE_USED bit for file-scope decls is kept in the identifier, 	 to handle multiple external decls in different scopes.  */
operator|&&
operator|!
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
comment|/* A volatile variable might be used in some non-obvious way.  */
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
comment|/* Global register variables must be declared to reserve them.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* Otherwise, ask the language.  */
operator|&&
name|lang_hooks
operator|.
name|decls
operator|.
name|warn_unused_global
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q+D defined but not used"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue appropriate warnings for the global declarations in VEC (of    which there are LEN).  */
end_comment

begin_function
name|void
name|check_global_declarations
parameter_list|(
name|tree
modifier|*
name|vec
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|check_global_declaration_1
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit debugging information for all global declarations in VEC.  */
end_comment

begin_function
name|void
name|emit_debug_global_declarations
parameter_list|(
name|tree
modifier|*
name|vec
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Avoid confusing the debug information machinery when there are errors.  */
if|if
condition|(
name|errorcount
operator|!=
literal|0
operator|||
name|sorrycount
operator|!=
literal|0
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|debug_hooks
operator|->
name|global_decl
argument_list|(
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn about a use of an identifier which was marked deprecated.  */
end_comment

begin_function
name|void
name|warn_deprecated_use
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|warn_deprecated_decl
condition|)
return|return;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|warning
argument_list|(
name|OPT_Wdeprecated_declarations
argument_list|,
literal|"%qs is deprecated (declared at %s:%d)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
name|tree
name|decl
init|=
name|TYPE_STUB_DECL
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
condition|)
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
name|OPT_Wdeprecated_declarations
argument_list|,
literal|"%qs is deprecated (declared at %s:%d)"
argument_list|,
name|what
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wdeprecated_declarations
argument_list|,
literal|"type is deprecated (declared at %s:%d)"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
name|OPT_Wdeprecated_declarations
argument_list|,
literal|"%qs is deprecated"
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wdeprecated_declarations
argument_list|,
literal|"type is deprecated"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Save the current INPUT_LOCATION on the top entry in the    INPUT_FILE_STACK.  Push a new entry for FILE and LINE, and set the    INPUT_LOCATION accordingly.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|push_srcloc
parameter_list|(
name|location_t
name|fline
parameter_list|)
else|#
directive|else
function|push_srcloc
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|file_stack
modifier|*
name|fs
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|input_file_stack_restored
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file_stack_tick
operator|==
call|(
name|int
call|)
argument_list|(
operator|(
literal|1U
operator|<<
name|INPUT_FILE_STACK_BITS
operator|)
operator|-
literal|1
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"GCC supports only %d input file changes"
argument_list|,
name|input_file_stack_tick
argument_list|)
expr_stmt|;
name|fs
operator|=
name|XNEW
argument_list|(
expr|struct
name|file_stack
argument_list|)
expr_stmt|;
name|fs
operator|->
name|location
operator|=
name|input_location
expr_stmt|;
name|fs
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|input_location
operator|=
name|fline
expr_stmt|;
else|#
directive|else
name|input_filename
operator|=
name|file
expr_stmt|;
name|input_line
operator|=
name|line
expr_stmt|;
endif|#
directive|endif
name|input_file_stack
operator|=
name|fs
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|fs_p
argument_list|,
name|heap
argument_list|,
name|input_file_stack_history
argument_list|,
name|input_file_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the top entry off the stack of presently open source files.    Restore the INPUT_LOCATION from the new topmost entry on the    stack.  */
end_comment

begin_function
name|void
name|pop_srcloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|file_stack
modifier|*
name|fs
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|input_file_stack_restored
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file_stack_tick
operator|==
call|(
name|int
call|)
argument_list|(
operator|(
literal|1U
operator|<<
name|INPUT_FILE_STACK_BITS
operator|)
operator|-
literal|1
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"GCC supports only %d input file changes"
argument_list|,
name|input_file_stack_tick
argument_list|)
expr_stmt|;
name|fs
operator|=
name|input_file_stack
expr_stmt|;
name|input_location
operator|=
name|fs
operator|->
name|location
expr_stmt|;
name|input_file_stack
operator|=
name|fs
operator|->
name|next
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|fs_p
argument_list|,
name|heap
argument_list|,
name|input_file_stack_history
argument_list|,
name|input_file_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the input file stack to its state as of TICK, for the sake    of diagnostics after processing the whole input.  Once this has    been called, push_srcloc and pop_srcloc may no longer be    called.  */
end_comment

begin_function
name|void
name|restore_input_file_stack
parameter_list|(
name|int
name|tick
parameter_list|)
block|{
if|if
condition|(
name|tick
operator|==
literal|0
condition|)
name|input_file_stack
operator|=
name|NULL
expr_stmt|;
else|else
name|input_file_stack
operator|=
name|VEC_index
argument_list|(
name|fs_p
argument_list|,
name|input_file_stack_history
argument_list|,
name|tick
operator|-
literal|1
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|=
name|tick
expr_stmt|;
name|input_file_stack_restored
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compile an entire translation unit.  Write a file of assembly    output and various debugging dumps.  */
end_comment

begin_function
specifier|static
name|void
name|compile_file
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize yet another pass.  */
name|init_cgraph
argument_list|()
expr_stmt|;
name|init_final
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|coverage_init
argument_list|(
name|aux_base_name
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
comment|/* Call the parser, which parses the entire file (calling      rest_of_compilation for each function).  */
name|lang_hooks
operator|.
name|parse_file
argument_list|(
name|set_yydebug
argument_list|)
expr_stmt|;
comment|/* In case there were missing block closers,      get us back to the global binding level.  */
name|lang_hooks
operator|.
name|clear_binding_stack
argument_list|()
expr_stmt|;
comment|/* Compilation is now finished except for writing      what's left of the symbol table output.  */
name|timevar_pop
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
operator|||
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
name|lang_hooks
operator|.
name|decls
operator|.
name|final_write_globals
argument_list|()
expr_stmt|;
name|cgraph_varpool_assemble_pending_decls
argument_list|()
expr_stmt|;
name|finish_aliases_2
argument_list|()
expr_stmt|;
comment|/* This must occur after the loop to output deferred functions.      Else the coverage initializer would not be emitted if all the      functions in this compilation unit were deferred.  */
name|coverage_finish
argument_list|()
expr_stmt|;
comment|/* Likewise for mudflap static object registrations.  */
if|if
condition|(
name|flag_mudflap
condition|)
name|mudflap_finish_file
argument_list|()
expr_stmt|;
name|output_shared_constant_pool
argument_list|()
expr_stmt|;
name|output_object_blocks
argument_list|()
expr_stmt|;
comment|/* Write out any pending weak symbol declarations.  */
name|weak_finish
argument_list|()
expr_stmt|;
comment|/* Do dbx symbols.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|DWARF2_DEBUGGING_INFO
operator|||
name|defined
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_finish
argument_list|()
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|debug_hooks
operator|->
name|finish
call|)
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
comment|/* Output some stuff at end of file if nec.  */
name|dw2_output_indirect_constants
argument_list|()
expr_stmt|;
comment|/* Flush any pending external directives.  cgraph did this for      assemble_external calls from the front end, but the RTL      expander can also generate them.  */
name|process_pending_assemble_externals
argument_list|()
expr_stmt|;
comment|/* Attach a special .ident directive to the end of the file to identify      the version of GCC which compiled this code.  The format of the .ident      string is patterned after the ones produced by native SVR4 compilers.  */
ifdef|#
directive|ifdef
name|IDENT_ASM_OP
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\"GCC: (GNU) %s\"\n"
argument_list|,
name|IDENT_ASM_OP
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This must be at the end.  Some target ports emit end of file directives      into the assembly file here, and hence we can not output anything to the      assembly file after this point.  */
name|targetm
operator|.
name|asm_out
operator|.
name|file_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a -d... command line switch.  */
end_comment

begin_function
name|void
name|decode_d_option
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|arg
operator|++
condition|)
block|{
case|case
literal|'A'
case|:
name|flag_debug_asm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|flag_dump_rtl_in_asm
operator|=
literal|1
expr_stmt|;
name|flag_print_asm_name
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|graph_dump_format
operator|=
name|vcg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|rtl_dump_and_exit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|set_yydebug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* These are handled by the preprocessor.  */
case|case
literal|'I'
case|:
break|break;
case|case
literal|'H'
case|:
name|setup_core_dumping
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
default|default:
if|if
condition|(
operator|!
name|enable_rtl_dump_file
argument_list|(
name|c
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unrecognized gcc debugging option: %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Indexed by enum debug_info_type.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|debug_type_names
index|[]
init|=
block|{
literal|"none"
block|,
literal|"stabs"
block|,
literal|"coff"
block|,
literal|"dwarf-2"
block|,
literal|"xcoff"
block|,
literal|"vms"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print version information to FILE.    Each line begins with INDENT (for the case where FILE is the    assembler output file).  */
end_comment

begin_function
name|void
name|print_version
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|fmt1
index|[]
init|=
ifdef|#
directive|ifdef
name|__GNUC__
name|N_
argument_list|(
literal|"%s%s%s version %s (%s)\n%s\tcompiled by GNU C version %s.\n"
argument_list|)
else|#
directive|else
name|N_
argument_list|(
literal|"%s%s%s version %s (%s) compiled by CC.\n"
argument_list|)
endif|#
directive|endif
decl_stmt|;
specifier|static
specifier|const
name|char
name|fmt2
index|[]
init|=
name|N_
argument_list|(
literal|"%s%sGGC heuristics: --param ggc-min-expand=%d --param ggc-min-heapsize=%d\n"
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|__VERSION__
define|#
directive|define
name|__VERSION__
value|"[?]"
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
name|file
operator|==
name|stderr
condition|?
name|_
argument_list|(
name|fmt1
argument_list|)
else|:
name|fmt1
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|lang_hooks
operator|.
name|name
argument_list|,
name|version_string
argument_list|,
name|TARGET_NAME
argument_list|,
name|indent
argument_list|,
name|__VERSION__
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|file
operator|==
name|stderr
condition|?
name|_
argument_list|(
name|fmt2
argument_list|)
else|:
name|fmt2
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_EXPAND
argument_list|)
argument_list|,
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_HEAPSIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an option value and return the adjusted position in the line.    ??? We don't handle error returns from fprintf (disk full); presumably    other code will catch a disk full though.  */
end_comment

begin_function
specifier|static
name|int
name|print_single_switch
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|term
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* The ultrix fprintf returns 0 on success, so compute the result we want      here since we need it for the following test.  */
name|int
name|len
init|=
name|strlen
argument_list|(
name|sep
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|0
operator|&&
name|pos
operator|+
name|len
operator|>
name|max
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|pos
operator|=
name|strlen
argument_list|(
name|indent
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%s"
argument_list|,
name|sep
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_comment
comment|/* Print active target switches to FILE.    POS is the current cursor position and MAX is the size of a "line".    Each line begins with INDENT and ends with TERM.    Each switch is separated from the next by SEP.  */
end_comment

begin_function
specifier|static
name|void
name|print_switch_values
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|term
parameter_list|)
block|{
name|size_t
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* Fill in the -frandom-seed option, if the user didn't pass it, so      that it can be printed below.  This helps reproducibility.  */
name|randomize
argument_list|()
expr_stmt|;
comment|/* Print the options as passed.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options passed: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|save_argv
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Ignore these.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-quiet"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|p
operator|)
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
continue|continue;
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
operator|*
name|p
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
comment|/* Print the -f and -m options that have been enabled.      We don't handle language specific options but printing argv      should suffice.  */
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
operator|*
name|indent
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|term
argument_list|,
name|_
argument_list|(
literal|"options enabled: "
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cl_options_count
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|cl_options
index|[
name|j
index|]
operator|.
name|flags
operator|&
name|CL_REPORT
operator|)
operator|&&
name|option_enabled
argument_list|(
name|j
argument_list|)
operator|>
literal|0
condition|)
name|pos
operator|=
name|print_single_switch
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|max
argument_list|,
name|indent
argument_list|,
name|sep
argument_list|,
name|term
argument_list|,
literal|""
argument_list|,
name|cl_options
index|[
name|j
index|]
operator|.
name|opt_text
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open assembly code output file.  Do this even if -fsyntax-only is    on, because then the driver will have provided the name of a    temporary file or bit bucket for us.  NAME is the file specified on    the command line, possibly NULL.  */
end_comment

begin_function
specifier|static
name|void
name|init_asm_output
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|asm_file_name
operator|==
literal|0
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
block|{
if|if
condition|(
name|asm_file_name
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dumpname
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|dumpname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".s"
argument_list|)
expr_stmt|;
name|asm_file_name
operator|=
name|dumpname
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asm_file_name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|asm_out_file
operator|=
name|stdout
expr_stmt|;
else|else
name|asm_out_file
operator|=
name|fopen
argument_list|(
name|asm_file_name
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_out_file
operator|==
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can%'t open %s for writing: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|file_start
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_COMMENT_START
if|if
condition|(
name|flag_verbose_asm
condition|)
block|{
comment|/* Print the list of options in effect.  */
name|print_version
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|print_switch_values
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
name|ASM_COMMENT_START
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Add a blank line here so it appears in assembler output but not 	     screen output.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Return true if the state of option OPTION should be stored in PCH files    and checked by default_pch_valid_p.  Store the option's current state    in STATE if so.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|option_affects_pch_p
parameter_list|(
name|int
name|option
parameter_list|,
name|struct
name|cl_option_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cl_options
index|[
name|option
index|]
operator|.
name|flags
operator|&
name|CL_TARGET
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|cl_options
index|[
name|option
index|]
operator|.
name|flag_var
operator|==
operator|&
name|target_flags
condition|)
if|if
condition|(
name|targetm
operator|.
name|check_pch_target_flags
condition|)
return|return
name|false
return|;
return|return
name|get_option_state
argument_list|(
name|option
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Default version of get_pch_validity.    By default, every flag difference is fatal; that will be mostly right for    most targets, but completely right for very few.  */
end_comment

begin_function
name|void
modifier|*
name|default_get_pch_validity
parameter_list|(
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|cl_option_state
name|state
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|r
decl_stmt|;
operator|*
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|check_pch_target_flags
condition|)
operator|*
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|option_affects_pch_p
argument_list|(
name|i
argument_list|,
operator|&
name|state
argument_list|)
condition|)
operator|*
name|len
operator|+=
name|state
operator|.
name|size
expr_stmt|;
name|result
operator|=
name|r
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
name|flag_pic
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|=
name|flag_pie
expr_stmt|;
name|r
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|check_pch_target_flags
condition|)
block|{
name|memcpy
argument_list|(
name|r
argument_list|,
operator|&
name|target_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|+=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|option_affects_pch_p
argument_list|(
name|i
argument_list|,
operator|&
name|state
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|r
argument_list|,
name|state
operator|.
name|data
argument_list|,
name|state
operator|.
name|size
argument_list|)
expr_stmt|;
name|r
operator|+=
name|state
operator|.
name|size
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a message which says that a PCH file was created with a different    setting of OPTION.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pch_option_mismatch
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|)
block|{
name|char
modifier|*
name|r
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|r
argument_list|,
name|_
argument_list|(
literal|"created and used with differing settings of '%s'"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|_
argument_list|(
literal|"out of memory"
argument_list|)
return|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Default version of pch_valid_p.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|default_pch_valid_p
parameter_list|(
specifier|const
name|void
modifier|*
name|data_p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|cl_option_state
name|state
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data_p
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* -fpic and -fpie also usually make a PCH invalid.  */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|!=
name|flag_pic
condition|)
return|return
name|_
argument_list|(
literal|"created and used with different settings of -fpic"
argument_list|)
return|;
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|!=
name|flag_pie
condition|)
return|return
name|_
argument_list|(
literal|"created and used with different settings of -fpie"
argument_list|)
return|;
name|data
operator|+=
literal|2
expr_stmt|;
comment|/* Check target_flags.  */
if|if
condition|(
name|targetm
operator|.
name|check_pch_target_flags
condition|)
block|{
name|int
name|tf
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|target_flags
argument_list|)
expr_stmt|;
name|r
operator|=
name|targetm
operator|.
name|check_pch_target_flags
argument_list|(
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
return|return
name|r
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_options_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|option_affects_pch_p
argument_list|(
name|i
argument_list|,
operator|&
name|state
argument_list|)
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|data
argument_list|,
name|state
operator|.
name|data
argument_list|,
name|state
operator|.
name|size
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|pch_option_mismatch
argument_list|(
name|cl_options
index|[
name|i
index|]
operator|.
name|opt_text
argument_list|)
return|;
name|data
operator|+=
name|state
operator|.
name|size
expr_stmt|;
name|len
operator|-=
name|state
operator|.
name|size
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Default tree printer.   Handles declarations only.  */
end_comment

begin_function
specifier|static
name|bool
name|default_tree_printer
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|,
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|int
name|precision
parameter_list|,
name|bool
name|wide
parameter_list|,
name|bool
name|set_locus
parameter_list|,
name|bool
name|hash
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* FUTURE: %+x should set the locus.  */
if|if
condition|(
name|precision
operator|!=
literal|0
operator|||
name|wide
operator|||
name|hash
condition|)
return|return
name|false
return|;
switch|switch
condition|(
operator|*
name|spec
condition|)
block|{
case|case
literal|'D'
case|:
name|t
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_DEBUG_EXPR
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|DECL_DEBUG_EXPR
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
case|case
literal|'T'
case|:
name|t
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|tree
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
name|set_locus
operator|&&
name|text
operator|->
name|locus
condition|)
operator|*
name|text
operator|->
name|locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|n
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|?
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
else|:
literal|"<anonymous>"
decl_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_generic_node
argument_list|(
name|pp
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Initialization of the front end environment, before command line    options are parsed.  Signal handlers, internationalization etc.    ARGV0 is main's argv[0].  */
end_comment

begin_function
specifier|static
name|void
name|general_init
parameter_list|(
specifier|const
name|char
modifier|*
name|argv0
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argv0
operator|+
name|strlen
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv0
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|progname
argument_list|)
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
comment|/* Unlock the stdio streams.  */
name|unlock_std_streams
argument_list|()
expr_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
comment|/* Initialize the diagnostics reporting machinery, so option parsing      can give warnings and errors.  */
name|diagnostic_initialize
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
comment|/* Set a default printer.  Language specific initializations will      override it later.  */
name|pp_format_decoder
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|)
operator|=
operator|&
name|default_tree_printer
expr_stmt|;
comment|/* Trap fatal signals, e.g. SIGSEGV, and convert them to ICE messages.  */
ifdef|#
directive|ifdef
name|SIGSEGV
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGABRT
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|SIGIOT
operator|&&
operator|(
operator|!
name|defined
name|SIGABRT
operator|||
name|SIGABRT
operator|!=
name|SIGIOT
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGFPE
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|crash_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Other host-specific signal setup.  */
call|(
modifier|*
name|host_hooks
operator|.
name|extra_signals
call|)
argument_list|()
expr_stmt|;
comment|/* Initialize the garbage-collector, string pools and tree type hash      table.  */
name|init_ggc
argument_list|()
expr_stmt|;
name|init_stringpool
argument_list|()
expr_stmt|;
name|linemap_init
argument_list|(
operator|&
name|line_table
argument_list|)
expr_stmt|;
name|init_ttree
argument_list|()
expr_stmt|;
comment|/* Initialize register usage now so switches may override.  */
name|init_reg_sets
argument_list|()
expr_stmt|;
comment|/* Register the language-independent parameters.  */
name|add_params
argument_list|(
name|lang_independent_params
argument_list|,
name|LAST_PARAM
argument_list|)
expr_stmt|;
comment|/* This must be done after add_params but before argument processing.  */
name|init_ggc_heuristics
argument_list|()
expr_stmt|;
name|init_optimization_passes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the current target supports -fsection-anchors.  */
end_comment

begin_function
specifier|static
name|bool
name|target_supports_section_anchors_p
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|targetm
operator|.
name|min_anchor_offset
operator|==
literal|0
operator|&&
name|targetm
operator|.
name|max_anchor_offset
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|targetm
operator|.
name|asm_out
operator|.
name|output_anchor
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Process the options that have been parsed.  */
end_comment

begin_function
specifier|static
name|void
name|process_options
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Just in case lang_hooks.post_options ends up calling a debug_hook.      This can happen with incorrect pre-processed input. */
name|debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
comment|/* Allow the front end to perform consistency checks and do further      initialization based on the command line options.  This hook also      sets the original filename if appropriate (e.g. foo.i -> foo.c)      so we can correctly initialize debug output.  */
name|no_backend
operator|=
name|lang_hooks
operator|.
name|post_options
argument_list|(
operator|&
name|main_input_filename
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MAPPED_LOCATION
name|input_filename
operator|=
name|main_input_filename
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OVERRIDE_OPTIONS
comment|/* Some machines may reject certain combinations of options.  */
name|OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_section_anchors
operator|&&
operator|!
name|target_supports_section_anchors_p
argument_list|()
condition|)
block|{
name|warning
argument_list|(
name|OPT_fsection_anchors
argument_list|,
literal|"this target does not support %qs"
argument_list|,
literal|"-fsection-anchors"
argument_list|)
expr_stmt|;
name|flag_section_anchors
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_short_enums
operator|==
literal|2
condition|)
name|flag_short_enums
operator|=
name|targetm
operator|.
name|default_short_enums
argument_list|()
expr_stmt|;
comment|/* Set aux_base_name if not already set.  */
if|if
condition|(
name|aux_base_name
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|main_input_filename
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|xstrdup
argument_list|(
name|lbasename
argument_list|(
name|main_input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|strip_off_ending
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|aux_base_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|aux_base_name
operator|=
literal|"gccaux"
expr_stmt|;
comment|/* Set up the align_*_log variables, defaulting them to 1 if they      were still unset.  */
if|if
condition|(
name|align_loops
operator|<=
literal|0
condition|)
name|align_loops
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align_loops_max_skip
operator|>
name|align_loops
operator|||
operator|!
name|align_loops
condition|)
name|align_loops_max_skip
operator|=
name|align_loops
operator|-
literal|1
expr_stmt|;
name|align_loops_log
operator|=
name|floor_log2
argument_list|(
name|align_loops
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|<=
literal|0
condition|)
name|align_jumps
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|align_jumps_max_skip
operator|>
name|align_jumps
operator|||
operator|!
name|align_jumps
condition|)
name|align_jumps_max_skip
operator|=
name|align_jumps
operator|-
literal|1
expr_stmt|;
name|align_jumps_log
operator|=
name|floor_log2
argument_list|(
name|align_jumps
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_labels
operator|<=
literal|0
condition|)
name|align_labels
operator|=
literal|1
expr_stmt|;
name|align_labels_log
operator|=
name|floor_log2
argument_list|(
name|align_labels
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_labels_max_skip
operator|>
name|align_labels
operator|||
operator|!
name|align_labels
condition|)
name|align_labels_max_skip
operator|=
name|align_labels
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|align_functions
operator|<=
literal|0
condition|)
name|align_functions
operator|=
literal|1
expr_stmt|;
name|align_functions_log
operator|=
name|floor_log2
argument_list|(
name|align_functions
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Unrolling all loops implies that standard loop unrolling must also      be done.  */
if|if
condition|(
name|flag_unroll_all_loops
condition|)
name|flag_unroll_loops
operator|=
literal|1
expr_stmt|;
comment|/* The loop unrolling code assumes that cse will be run after loop.      web and rename-registers also help when run after loop unrolling.  */
if|if
condition|(
name|flag_rerun_cse_after_loop
operator|==
name|AUTODETECT_VALUE
condition|)
name|flag_rerun_cse_after_loop
operator|=
name|flag_unroll_loops
operator|||
name|flag_peel_loops
expr_stmt|;
if|if
condition|(
name|flag_web
operator|==
name|AUTODETECT_VALUE
condition|)
name|flag_web
operator|=
name|flag_unroll_loops
operator|||
name|flag_peel_loops
expr_stmt|;
if|if
condition|(
name|flag_rename_registers
operator|==
name|AUTODETECT_VALUE
condition|)
name|flag_rename_registers
operator|=
name|flag_unroll_loops
operator|||
name|flag_peel_loops
expr_stmt|;
if|if
condition|(
name|flag_non_call_exceptions
condition|)
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
condition|)
name|flag_unwind_tables
operator|=
literal|1
expr_stmt|;
comment|/* Disable unit-at-a-time mode for frontends not supporting callgraph      interface.  */
if|if
condition|(
name|flag_unit_at_a_time
operator|&&
operator|!
name|lang_hooks
operator|.
name|callgraph
operator|.
name|expand_function
condition|)
name|flag_unit_at_a_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
name|flag_section_anchors
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_value_profile_transformations
condition|)
name|flag_profile_values
operator|=
literal|1
expr_stmt|;
comment|/* Warn about options that are not supported on this machine.  */
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
if|if
condition|(
name|flag_schedule_insns
operator|||
name|flag_schedule_insns_after_reload
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"instruction scheduling not supported on this target machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DELAY_SLOTS
if|if
condition|(
name|flag_delayed_branch
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"this target machine does not have delayed branches"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|user_label_prefix
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
if|if
condition|(
name|flag_leading_underscore
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If the default prefix is more complicated than "" or "_", 	 issue a warning and ignore this option.  */
if|if
condition|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|user_label_prefix
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|user_label_prefix
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|user_label_prefix
operator|=
name|flag_leading_underscore
condition|?
literal|"_"
else|:
literal|""
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-f%sleading-underscore not supported on this target machine"
argument_list|,
name|flag_leading_underscore
condition|?
literal|""
else|:
literal|"no-"
argument_list|)
expr_stmt|;
block|}
comment|/* If we are in verbose mode, write out the version and maybe all the      option flags in use.  */
if|if
condition|(
name|version_flag
condition|)
block|{
name|print_version
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|print_switch_values
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|,
name|MAX_LINE
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_syntax_only
condition|)
block|{
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
name|profile_flag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* A lot of code assumes write_symbols == NO_DEBUG if the debugging      level is 0.  */
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NONE
condition|)
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
comment|/* Now we know write_symbols, set up the debug hooks based on it.      By default we do nothing for debug output.  */
if|if
condition|(
name|PREFERRED_DEBUGGING_TYPE
operator|==
name|NO_DEBUG
condition|)
name|default_debug_hooks
operator|=
operator|&
name|do_nothing_debug_hooks
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
name|PREFERRED_DEBUGGING_TYPE
operator|==
name|DBX_DEBUG
condition|)
name|default_debug_hooks
operator|=
operator|&
name|dbx_debug_hooks
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
name|PREFERRED_DEBUGGING_TYPE
operator|==
name|XCOFF_DEBUG
condition|)
name|default_debug_hooks
operator|=
operator|&
name|xcoff_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|PREFERRED_DEBUGGING_TYPE
operator|==
name|SDB_DEBUG
condition|)
name|default_debug_hooks
operator|=
operator|&
name|sdb_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|PREFERRED_DEBUGGING_TYPE
operator|==
name|DWARF2_DEBUG
condition|)
name|default_debug_hooks
operator|=
operator|&
name|dwarf2_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|PREFERRED_DEBUGGING_TYPE
operator|==
name|VMS_DEBUG
operator|||
name|PREFERRED_DEBUGGING_TYPE
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
name|default_debug_hooks
operator|=
operator|&
name|vmsdbg_debug_hooks
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
empty_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|dbx_debug_hooks
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|xcoff_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|sdb_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|dwarf2_debug_hooks
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
elseif|else
if|if
condition|(
name|write_symbols
operator|==
name|VMS_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
name|debug_hooks
operator|=
operator|&
name|vmsdbg_debug_hooks
expr_stmt|;
endif|#
directive|endif
else|else
name|error
argument_list|(
literal|"target system does not support the \"%s\" debug format"
argument_list|,
name|debug_type_names
index|[
name|write_symbols
index|]
argument_list|)
expr_stmt|;
comment|/* Now we know which debug output will be used so we can set      flag_var_tracking, flag_rename_registers if the user has      not specified them.  */
if|if
condition|(
name|debug_info_level
operator|<
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_hooks
operator|->
name|var_location
operator|==
name|do_nothing_debug_hooks
operator|.
name|var_location
condition|)
block|{
if|if
condition|(
name|flag_var_tracking
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|debug_info_level
operator|<
name|DINFO_LEVEL_NORMAL
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"variable tracking requested, but useless unless "
literal|"producing debug info"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"variable tracking requested, but not supported "
literal|"by this debug format"
argument_list|)
expr_stmt|;
block|}
name|flag_var_tracking
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_rename_registers
operator|==
name|AUTODETECT_VALUE
condition|)
name|flag_rename_registers
operator|=
name|default_debug_hooks
operator|->
name|var_location
operator|!=
name|do_nothing_debug_hooks
operator|.
name|var_location
expr_stmt|;
if|if
condition|(
name|flag_var_tracking
operator|==
name|AUTODETECT_VALUE
condition|)
name|flag_var_tracking
operator|=
name|optimize
operator|>=
literal|1
expr_stmt|;
comment|/* If auxiliary info generation is desired, open the output file.      This goes in the same directory as the source file--unlike      all the other output files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|aux_info_file
operator|=
name|fopen
argument_list|(
name|aux_info_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_info_file
operator|==
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can%'t open %s: %m"
argument_list|,
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
if|if
condition|(
name|flag_function_sections
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-ffunction-sections not supported for this target"
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag_data_sections
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-fdata-sections not supported for this target"
argument_list|)
expr_stmt|;
name|flag_data_sections
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_function_sections
operator|&&
name|profile_flag
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-ffunction-sections disabled; it makes profiling impossible"
argument_list|)
expr_stmt|;
name|flag_function_sections
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|HAVE_prefetch
if|if
condition|(
name|flag_prefetch_loop_arrays
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-fprefetch-loop-arrays not supported for this target"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|flag_prefetch_loop_arrays
operator|&&
operator|!
name|HAVE_prefetch
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-fprefetch-loop-arrays not supported for this target (try -march switches)"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* This combination of options isn't handled for i386 targets and doesn't      make much sense anyway, so don't allow it.  */
if|if
condition|(
name|flag_prefetch_loop_arrays
operator|&&
name|optimize_size
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-fprefetch-loop-arrays is not supported with -Os"
argument_list|)
expr_stmt|;
name|flag_prefetch_loop_arrays
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_ELF
ifndef|#
directive|ifndef
name|OBJECT_FORMAT_MACHO
if|if
condition|(
name|flag_function_sections
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-ffunction-sections may affect debugging on some targets"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* The presence of IEEE signaling NaNs, implies all math can trap.  */
if|if
condition|(
name|flag_signaling_nans
condition|)
name|flag_trapping_math
operator|=
literal|1
expr_stmt|;
comment|/* With -fcx-limited-range, we do cheap and quick complex arithmetic.  */
if|if
condition|(
name|flag_cx_limited_range
condition|)
name|flag_complex_method
operator|=
literal|0
expr_stmt|;
comment|/* Targets must be able to place spill slots at lower addresses.  If the      target already uses a soft frame pointer, the transition is trivial.  */
if|if
condition|(
operator|!
name|FRAME_GROWS_DOWNWARD
operator|&&
name|flag_stack_protect
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-fstack-protector not supported for this target"
argument_list|)
expr_stmt|;
name|flag_stack_protect
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_stack_protect
condition|)
name|warn_stack_protect
operator|=
literal|0
expr_stmt|;
comment|/* ??? Unwind info is not correct around the CFG unless either a frame      pointer is present or A_O_A is set.  Fixing this requires rewriting      unwind info generation to be aware of the CFG and propagating states      around edges.  */
if|if
condition|(
name|flag_unwind_tables
operator|&&
operator|!
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
name|flag_omit_frame_pointer
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unwind tables currently requires a frame pointer "
literal|"for correctness"
argument_list|)
expr_stmt|;
name|flag_omit_frame_pointer
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the compiler back end.  */
end_comment

begin_function
specifier|static
name|void
name|backend_init
parameter_list|(
name|void
parameter_list|)
block|{
name|init_emit_once
argument_list|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
comment|/* Enable line number info for traceback.  */
operator|||
name|debug_info_level
operator|>
name|DINFO_LEVEL_NONE
endif|#
directive|endif
operator|||
name|flag_test_coverage
argument_list|)
expr_stmt|;
name|init_rtlanal
argument_list|()
expr_stmt|;
name|init_regs
argument_list|()
expr_stmt|;
name|init_fake_stack_mems
argument_list|()
expr_stmt|;
name|init_alias_once
argument_list|()
expr_stmt|;
name|init_reload
argument_list|()
expr_stmt|;
name|init_varasm_once
argument_list|()
expr_stmt|;
comment|/* The following initialization functions need to generate rtl, so      provide a dummy function context for them.  */
name|init_dummy_function_start
argument_list|()
expr_stmt|;
name|init_expmed
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_caller_saves
condition|)
name|init_caller_save
argument_list|()
expr_stmt|;
name|expand_dummy_function_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Language-dependent initialization.  Returns nonzero on success.  */
end_comment

begin_function
specifier|static
name|int
name|lang_dependent_init
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|location_t
name|save_loc
init|=
name|input_location
decl_stmt|;
if|if
condition|(
name|dump_base_name
operator|==
literal|0
condition|)
name|dump_base_name
operator|=
name|name
operator|&&
name|name
index|[
literal|0
index|]
condition|?
name|name
else|:
literal|"gccdump"
expr_stmt|;
comment|/* Other front-end initialization.  */
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|input_location
operator|=
name|BUILTINS_LOCATION
expr_stmt|;
else|#
directive|else
name|input_filename
operator|=
literal|"<built-in>"
expr_stmt|;
name|input_line
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lang_hooks
operator|.
name|init
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|input_location
operator|=
name|save_loc
expr_stmt|;
name|init_asm_output
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* These create various _DECL nodes, so need to be called after the      front end is initialized.  */
name|init_eh
argument_list|()
expr_stmt|;
name|init_optabs
argument_list|()
expr_stmt|;
comment|/* The following initialization functions need to generate rtl, so      provide a dummy function context for them.  */
name|init_dummy_function_start
argument_list|()
expr_stmt|;
name|init_expr_once
argument_list|()
expr_stmt|;
name|expand_dummy_function_end
argument_list|()
expr_stmt|;
comment|/* If dbx symbol table desired, initialize writing it and output the      predefined types.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|DWARF2_DEBUGGING_INFO
operator|||
name|defined
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now we have the correct original filename, we can initialize      debug output.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|init
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Clean up: close opened files, etc.  */
end_comment

begin_function
specifier|static
name|void
name|finalize
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Close the dump files.  */
if|if
condition|(
name|flag_gen_aux_info
condition|)
block|{
name|fclose
argument_list|(
name|aux_info_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcount
condition|)
name|unlink
argument_list|(
name|aux_info_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Close non-debugging input and output files.  Take special care to note      whether fclose returns an error, since the pages might still be on the      buffer chain while the file is open.  */
if|if
condition|(
name|asm_out_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"error writing to %s: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|asm_out_file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"error closing %s: %m"
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
block|}
name|finish_optimization_passes
argument_list|()
expr_stmt|;
if|if
condition|(
name|mem_report
condition|)
block|{
name|ggc_print_statistics
argument_list|()
expr_stmt|;
name|stringpool_statistics
argument_list|()
expr_stmt|;
name|dump_tree_statistics
argument_list|()
expr_stmt|;
name|dump_rtx_statistics
argument_list|()
expr_stmt|;
name|dump_varray_statistics
argument_list|()
expr_stmt|;
name|dump_alloc_pool_statistics
argument_list|()
expr_stmt|;
name|dump_ggc_loc_statistics
argument_list|()
expr_stmt|;
block|}
comment|/* Free up memory for the benefit of leak detectors.  */
name|free_reg_info
argument_list|()
expr_stmt|;
comment|/* Language-specific end of compilation actions.  */
name|lang_hooks
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the compiler, and compile the input file.  */
end_comment

begin_function
specifier|static
name|void
name|do_compile
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize timing first.  The C front ends read the main file in      the post_options hook, and C++ does file timings.  */
if|if
condition|(
name|time_report
operator|||
operator|!
name|quiet_flag
operator|||
name|flag_detailed_statistics
condition|)
name|timevar_init
argument_list|()
expr_stmt|;
name|timevar_start
argument_list|(
name|TV_TOTAL
argument_list|)
expr_stmt|;
name|process_options
argument_list|()
expr_stmt|;
comment|/* Don't do any more if an error has already occurred.  */
if|if
condition|(
operator|!
name|errorcount
condition|)
block|{
comment|/* This must be run always, because it is needed to compute the FP 	 predefined macros, such as __LDBL_MAX__, for targets using non 	 default FP formats.  */
name|init_adjust_machine_modes
argument_list|()
expr_stmt|;
comment|/* Set up the back-end if requested.  */
if|if
condition|(
operator|!
name|no_backend
condition|)
name|backend_init
argument_list|()
expr_stmt|;
comment|/* Language-dependent initialization.  Returns true on success.  */
if|if
condition|(
name|lang_dependent_init
argument_list|(
name|main_input_filename
argument_list|)
condition|)
name|compile_file
argument_list|()
expr_stmt|;
name|finalize
argument_list|()
expr_stmt|;
block|}
comment|/* Stop timing and print the times.  */
name|timevar_stop
argument_list|(
name|TV_TOTAL
argument_list|)
expr_stmt|;
name|timevar_print
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point of cc1, cc1plus, jc1, f771, etc.    Exit code is FATAL_EXIT_CODE if can't open files or if there were    any errors, or SUCCESS_EXIT_CODE if compilation succeeded.     It is not safe to call this function more than once.  */
end_comment

begin_function
name|int
name|toplev_main
parameter_list|(
name|unsigned
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|save_argv
operator|=
name|argv
expr_stmt|;
comment|/* Initialization of GCC's environment, and diagnostics.  */
name|general_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Parse the options and do minimal processing; basically just      enough to default flags appropriately.  */
name|decode_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|randomize
argument_list|()
expr_stmt|;
comment|/* Exit early if we can (e.g. -help).  */
if|if
condition|(
operator|!
name|exit_after_options
condition|)
name|do_compile
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
return|return
operator|(
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

end_unit

