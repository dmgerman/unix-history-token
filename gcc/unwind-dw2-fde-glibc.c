begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Jakub Jelinek<jakub@redhat.com>.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* Locate the FDE entry for a given address, using PT_GNU_EH_FRAME ELF    segment and dl_iterate_phdr to avoid register/deregister calls at    DSO load/unload.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_define
define|#
directive|define
name|NO_BASE_OF_ENCODED_VALUE
end_define

begin_include
include|#
directive|include
file|"unwind-pe.h"
end_include

begin_include
include|#
directive|include
file|"unwind-dw2-fde.h"
end_include

begin_include
include|#
directive|include
file|"unwind-compat.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|inhibit_libc
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LD_EH_FRAME_HDR
argument_list|)
expr|\
operator|&&
operator|(
name|__GLIBC__
operator|>
literal|2
operator|||
operator|(
name|__GLIBC__
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|>
literal|2
operator|)
expr|\
operator|||
operator|(
name|__GLIBC__
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|==
literal|2
operator|&&
name|defined
argument_list|(
name|DT_CONFIG
argument_list|)
operator|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|__RELOC_POINTER
end_ifndef

begin_define
define|#
directive|define
name|__RELOC_POINTER
parameter_list|(
name|ptr
parameter_list|,
name|base
parameter_list|)
value|((ptr) + (base))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|fde
modifier|*
name|_Unwind_Find_registered_FDE
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
name|bases
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|_Unwind_Find_FDE
value|_Unwind_Find_registered_FDE
end_define

begin_include
include|#
directive|include
file|"unwind-dw2-fde.c"
end_include

begin_undef
undef|#
directive|undef
name|_Unwind_Find_FDE
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|PT_GNU_EH_FRAME
end_ifndef

begin_define
define|#
directive|define
name|PT_GNU_EH_FRAME
value|(PT_LOOS + 0x474e550)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|unw_eh_callback_data
block|{
name|_Unwind_Ptr
name|pc
decl_stmt|;
name|void
modifier|*
name|tbase
decl_stmt|;
name|void
modifier|*
name|dbase
decl_stmt|;
name|void
modifier|*
name|func
decl_stmt|;
specifier|const
name|fde
modifier|*
name|ret
decl_stmt|;
name|int
name|check_cache
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|unw_eh_frame_hdr
block|{
name|unsigned
name|char
name|version
decl_stmt|;
name|unsigned
name|char
name|eh_frame_ptr_enc
decl_stmt|;
name|unsigned
name|char
name|fde_count_enc
decl_stmt|;
name|unsigned
name|char
name|table_enc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FRAME_HDR_CACHE_SIZE
value|8
end_define

begin_struct
specifier|static
struct|struct
name|frame_hdr_cache_element
block|{
name|_Unwind_Ptr
name|pc_low
decl_stmt|;
name|_Unwind_Ptr
name|pc_high
decl_stmt|;
name|_Unwind_Ptr
name|load_base
decl_stmt|;
specifier|const
name|ElfW
argument_list|(
name|Phdr
argument_list|)
operator|*
name|p_eh_frame_hdr
expr_stmt|;
specifier|const
name|ElfW
argument_list|(
name|Phdr
argument_list|)
operator|*
name|p_dynamic
expr_stmt|;
name|struct
name|frame_hdr_cache_element
modifier|*
name|link
decl_stmt|;
block|}
name|frame_hdr_cache
index|[
name|FRAME_HDR_CACHE_SIZE
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|frame_hdr_cache_element
modifier|*
name|frame_hdr_cache_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like base_of_encoded_value, but take the base from a struct    unw_eh_callback_data instead of an _Unwind_Context.  */
end_comment

begin_function
specifier|static
name|_Unwind_Ptr
name|base_from_cb_data
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|,
name|struct
name|unw_eh_callback_data
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|encoding
operator|==
name|DW_EH_PE_omit
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x70
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
case|case
name|DW_EH_PE_pcrel
case|:
case|case
name|DW_EH_PE_aligned
case|:
return|return
literal|0
return|;
case|case
name|DW_EH_PE_textrel
case|:
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|data
operator|->
name|tbase
return|;
case|case
name|DW_EH_PE_datarel
case|:
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|data
operator|->
name|dbase
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_Unwind_IteratePhdrCallback
parameter_list|(
name|struct
name|dl_phdr_info
modifier|*
name|info
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|unw_eh_callback_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|unw_eh_callback_data
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|const
name|ElfW
argument_list|(
name|Phdr
argument_list|)
operator|*
name|phdr
operator|,
operator|*
name|p_eh_frame_hdr
operator|,
operator|*
name|p_dynamic
expr_stmt|;
name|long
name|n
decl_stmt|,
name|match
decl_stmt|;
ifdef|#
directive|ifdef
name|__FRV_FDPIC__
name|struct
name|elf32_fdpic_loadaddr
name|load_base
decl_stmt|;
else|#
directive|else
name|_Unwind_Ptr
name|load_base
decl_stmt|;
endif|#
directive|endif
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|unw_eh_frame_hdr
modifier|*
name|hdr
decl_stmt|;
name|_Unwind_Ptr
name|eh_frame
decl_stmt|;
name|struct
name|object
name|ob
decl_stmt|;
struct|struct
name|ext_dl_phdr_info
block|{
name|ElfW
argument_list|(
argument|Addr
argument_list|)
name|dlpi_addr
expr_stmt|;
specifier|const
name|char
modifier|*
name|dlpi_name
decl_stmt|;
specifier|const
name|ElfW
argument_list|(
name|Phdr
argument_list|)
operator|*
name|dlpi_phdr
expr_stmt|;
name|ElfW
argument_list|(
argument|Half
argument_list|)
name|dlpi_phnum
expr_stmt|;
name|unsigned
name|long
name|long
name|int
name|dlpi_adds
decl_stmt|;
name|unsigned
name|long
name|long
name|int
name|dlpi_subs
decl_stmt|;
block|}
struct|;
name|match
operator|=
literal|0
expr_stmt|;
name|phdr
operator|=
name|info
operator|->
name|dlpi_phdr
expr_stmt|;
name|load_base
operator|=
name|info
operator|->
name|dlpi_addr
expr_stmt|;
name|p_eh_frame_hdr
operator|=
name|NULL
expr_stmt|;
name|p_dynamic
operator|=
name|NULL
expr_stmt|;
name|struct
name|frame_hdr_cache_element
modifier|*
name|prev_cache_entry
init|=
name|NULL
decl_stmt|,
modifier|*
name|last_cache_entry
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|check_cache
operator|&&
name|size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ext_dl_phdr_info
argument_list|)
condition|)
block|{
specifier|static
name|unsigned
name|long
name|long
name|adds
init|=
operator|-
literal|1ULL
decl_stmt|,
name|subs
decl_stmt|;
name|struct
name|ext_dl_phdr_info
modifier|*
name|einfo
init|=
operator|(
expr|struct
name|ext_dl_phdr_info
operator|*
operator|)
name|info
decl_stmt|;
comment|/* We use a least recently used cache replacement policy.  Also, 	 the most recently used cache entries are placed at the head 	 of the search chain.  */
if|if
condition|(
name|einfo
operator|->
name|dlpi_adds
operator|==
name|adds
operator|&&
name|einfo
operator|->
name|dlpi_subs
operator|==
name|subs
condition|)
block|{
comment|/* Find data->pc in shared library cache. 	     Set load_base, p_eh_frame_hdr and p_dynamic 	     plus match from the cache and goto 	     "Read .eh_frame_hdr header." below.  */
name|struct
name|frame_hdr_cache_element
modifier|*
name|cache_entry
decl_stmt|;
for|for
control|(
name|cache_entry
operator|=
name|frame_hdr_cache_head
init|;
name|cache_entry
condition|;
name|cache_entry
operator|=
name|cache_entry
operator|->
name|link
control|)
block|{
if|if
condition|(
name|data
operator|->
name|pc
operator|>=
name|cache_entry
operator|->
name|pc_low
operator|&&
name|data
operator|->
name|pc
operator|<
name|cache_entry
operator|->
name|pc_high
condition|)
block|{
name|load_base
operator|=
name|cache_entry
operator|->
name|load_base
expr_stmt|;
name|p_eh_frame_hdr
operator|=
name|cache_entry
operator|->
name|p_eh_frame_hdr
expr_stmt|;
name|p_dynamic
operator|=
name|cache_entry
operator|->
name|p_dynamic
expr_stmt|;
comment|/* And move the entry we're using to the head.  */
if|if
condition|(
name|cache_entry
operator|!=
name|frame_hdr_cache_head
condition|)
block|{
name|prev_cache_entry
operator|->
name|link
operator|=
name|cache_entry
operator|->
name|link
expr_stmt|;
name|cache_entry
operator|->
name|link
operator|=
name|frame_hdr_cache_head
expr_stmt|;
name|frame_hdr_cache_head
operator|=
name|cache_entry
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
name|last_cache_entry
operator|=
name|cache_entry
expr_stmt|;
comment|/* Exit early if we found an unused entry.  */
if|if
condition|(
operator|(
name|cache_entry
operator|->
name|pc_low
operator||
name|cache_entry
operator|->
name|pc_high
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cache_entry
operator|->
name|link
operator|!=
name|NULL
condition|)
name|prev_cache_entry
operator|=
name|cache_entry
expr_stmt|;
block|}
block|}
else|else
block|{
name|adds
operator|=
name|einfo
operator|->
name|dlpi_adds
expr_stmt|;
name|subs
operator|=
name|einfo
operator|->
name|dlpi_subs
expr_stmt|;
comment|/* Initialize the cache.  Create a chain of cache entries, 	     with the final one terminated by a NULL link.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FRAME_HDR_CACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|frame_hdr_cache
index|[
name|i
index|]
operator|.
name|pc_low
operator|=
literal|0
expr_stmt|;
name|frame_hdr_cache
index|[
name|i
index|]
operator|.
name|pc_high
operator|=
literal|0
expr_stmt|;
name|frame_hdr_cache
index|[
name|i
index|]
operator|.
name|link
operator|=
operator|&
name|frame_hdr_cache
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|frame_hdr_cache
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|link
operator|=
name|NULL
expr_stmt|;
name|frame_hdr_cache_head
operator|=
operator|&
name|frame_hdr_cache
index|[
literal|0
index|]
expr_stmt|;
name|data
operator|->
name|check_cache
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Make sure struct dl_phdr_info is at least as big as we need.  */
if|if
condition|(
name|size
operator|<
name|offsetof
argument_list|(
expr|struct
name|dl_phdr_info
argument_list|,
name|dlpi_phnum
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|info
operator|->
name|dlpi_phnum
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|_Unwind_Ptr
name|pc_low
init|=
literal|0
decl_stmt|,
name|pc_high
init|=
literal|0
decl_stmt|;
comment|/* See if PC falls into one of the loaded segments.  Find the eh_frame      segment at the same time.  */
for|for
control|(
name|n
operator|=
name|info
operator|->
name|dlpi_phnum
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|phdr
operator|++
control|)
block|{
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|_Unwind_Ptr
name|vaddr
init|=
operator|(
name|_Unwind_Ptr
operator|)
name|__RELOC_POINTER
argument_list|(
name|phdr
operator|->
name|p_vaddr
argument_list|,
name|load_base
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|pc
operator|>=
name|vaddr
operator|&&
name|data
operator|->
name|pc
operator|<
name|vaddr
operator|+
name|phdr
operator|->
name|p_memsz
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
name|pc_low
operator|=
name|vaddr
expr_stmt|;
name|pc_high
operator|=
name|vaddr
operator|+
name|phdr
operator|->
name|p_memsz
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_GNU_EH_FRAME
condition|)
name|p_eh_frame_hdr
operator|=
name|phdr
expr_stmt|;
elseif|else
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_DYNAMIC
condition|)
name|p_dynamic
operator|=
name|phdr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ext_dl_phdr_info
argument_list|)
condition|)
block|{
comment|/* Move the cache entry we're about to overwrite to the head of 	 the list.  If either last_cache_entry or prev_cache_entry are 	 NULL, that cache entry is already at the head.  */
if|if
condition|(
name|last_cache_entry
operator|!=
name|NULL
operator|&&
name|prev_cache_entry
operator|!=
name|NULL
condition|)
block|{
name|prev_cache_entry
operator|->
name|link
operator|=
name|last_cache_entry
operator|->
name|link
expr_stmt|;
name|last_cache_entry
operator|->
name|link
operator|=
name|frame_hdr_cache_head
expr_stmt|;
name|frame_hdr_cache_head
operator|=
name|last_cache_entry
expr_stmt|;
block|}
name|frame_hdr_cache_head
operator|->
name|load_base
operator|=
name|load_base
expr_stmt|;
name|frame_hdr_cache_head
operator|->
name|p_eh_frame_hdr
operator|=
name|p_eh_frame_hdr
expr_stmt|;
name|frame_hdr_cache_head
operator|->
name|p_dynamic
operator|=
name|p_dynamic
expr_stmt|;
name|frame_hdr_cache_head
operator|->
name|pc_low
operator|=
name|pc_low
expr_stmt|;
name|frame_hdr_cache_head
operator|->
name|pc_high
operator|=
name|pc_high
expr_stmt|;
block|}
name|found
label|:
if|if
condition|(
operator|!
name|p_eh_frame_hdr
condition|)
return|return
literal|0
return|;
comment|/* Read .eh_frame_hdr header.  */
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|unw_eh_frame_hdr
operator|*
operator|)
name|__RELOC_POINTER
argument_list|(
name|p_eh_frame_hdr
operator|->
name|p_vaddr
argument_list|,
name|load_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|version
operator|!=
literal|1
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|CRT_GET_RFIB_DATA
ifdef|#
directive|ifdef
name|__i386__
name|data
operator|->
name|dbase
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p_dynamic
condition|)
block|{
comment|/* For dynamically linked executables and shared libraries, 	 DT_PLTGOT is the gp value for that object.  */
name|ElfW
argument_list|(
name|Dyn
argument_list|)
operator|*
name|dyn
operator|=
operator|(
name|ElfW
argument_list|(
name|Dyn
argument_list|)
operator|*
operator|)
name|__RELOC_POINTER
argument_list|(
name|p_dynamic
operator|->
name|p_vaddr
argument_list|,
name|load_base
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dyn
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dyn
operator|++
control|)
if|if
condition|(
name|dyn
operator|->
name|d_tag
operator|==
name|DT_PLTGOT
condition|)
block|{
comment|/* On IA-32, _DYNAMIC is writable and GLIBC has relocated it.  */
name|data
operator|->
name|dbase
operator|=
operator|(
name|void
operator|*
operator|)
name|dyn
operator|->
name|d_un
operator|.
name|d_ptr
expr_stmt|;
break|break;
block|}
block|}
elif|#
directive|elif
name|defined
name|__FRV_FDPIC__
operator|&&
name|defined
name|__linux__
name|data
operator|->
name|dbase
operator|=
name|load_base
operator|.
name|got_value
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|What is DW_EH_PE_datarel base on this platform?
endif|#
directive|endif
endif|#
directive|endif
name|p
operator|=
name|read_encoded_value_with_base
argument_list|(
name|hdr
operator|->
name|eh_frame_ptr_enc
argument_list|,
name|base_from_cb_data
argument_list|(
name|hdr
operator|->
name|eh_frame_ptr_enc
argument_list|,
name|data
argument_list|)
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
argument_list|,
operator|&
name|eh_frame
argument_list|)
expr_stmt|;
comment|/* We require here specific table encoding to speed things up.      Also, DW_EH_PE_datarel here means using PT_GNU_EH_FRAME start      as base, not the processor specific DW_EH_PE_datarel.  */
if|if
condition|(
name|hdr
operator|->
name|fde_count_enc
operator|!=
name|DW_EH_PE_omit
operator|&&
name|hdr
operator|->
name|table_enc
operator|==
operator|(
name|DW_EH_PE_datarel
operator||
name|DW_EH_PE_sdata4
operator|)
condition|)
block|{
name|_Unwind_Ptr
name|fde_count
decl_stmt|;
name|p
operator|=
name|read_encoded_value_with_base
argument_list|(
name|hdr
operator|->
name|fde_count_enc
argument_list|,
name|base_from_cb_data
argument_list|(
name|hdr
operator|->
name|fde_count_enc
argument_list|,
name|data
argument_list|)
argument_list|,
name|p
argument_list|,
operator|&
name|fde_count
argument_list|)
expr_stmt|;
comment|/* Shouldn't happen.  */
if|if
condition|(
name|fde_count
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
operator|(
operator|(
name|_Unwind_Ptr
operator|)
name|p
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
struct|struct
name|fde_table
block|{
name|signed
name|initial_loc
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|fde
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
block|}
struct|;
specifier|const
name|struct
name|fde_table
modifier|*
name|table
init|=
operator|(
specifier|const
expr|struct
name|fde_table
operator|*
operator|)
name|p
decl_stmt|;
name|size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|mid
decl_stmt|;
name|_Unwind_Ptr
name|data_base
init|=
operator|(
name|_Unwind_Ptr
operator|)
name|hdr
decl_stmt|;
name|fde
modifier|*
name|f
decl_stmt|;
name|unsigned
name|int
name|f_enc
decl_stmt|,
name|f_enc_size
decl_stmt|;
name|_Unwind_Ptr
name|range
decl_stmt|;
name|mid
operator|=
name|fde_count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|pc
operator|<
name|table
index|[
literal|0
index|]
operator|.
name|initial_loc
operator|+
name|data_base
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|data
operator|->
name|pc
operator|<
name|table
index|[
name|mid
index|]
operator|.
name|initial_loc
operator|+
name|data_base
condition|)
block|{
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|mid
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|pc
operator|<
name|table
index|[
name|mid
index|]
operator|.
name|initial_loc
operator|+
name|data_base
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|data
operator|->
name|pc
operator|>=
name|table
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|initial_loc
operator|+
name|data_base
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
name|gcc_assert
argument_list|(
name|lo
operator|<
name|hi
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
operator|(
name|fde
operator|*
operator|)
operator|(
name|table
index|[
name|mid
index|]
operator|.
name|fde
operator|+
name|data_base
operator|)
expr_stmt|;
name|f_enc
operator|=
name|get_fde_encoding
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f_enc_size
operator|=
name|size_of_encoded_value
argument_list|(
name|f_enc
argument_list|)
expr_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|f_enc
operator|&
literal|0x0f
argument_list|,
literal|0
argument_list|,
operator|&
name|f
operator|->
name|pc_begin
index|[
name|f_enc_size
index|]
argument_list|,
operator|&
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|pc
operator|<
name|table
index|[
name|mid
index|]
operator|.
name|initial_loc
operator|+
name|data_base
operator|+
name|range
condition|)
name|data
operator|->
name|ret
operator|=
name|f
expr_stmt|;
name|data
operator|->
name|func
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|table
index|[
name|mid
index|]
operator|.
name|initial_loc
operator|+
name|data_base
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* We have no sorted search table, so need to go the slow way.      As soon as GLIBC will provide API so to notify that a library has been      removed, we could cache this (and thus use search_object).  */
name|ob
operator|.
name|pc_begin
operator|=
name|NULL
expr_stmt|;
name|ob
operator|.
name|tbase
operator|=
name|data
operator|->
name|tbase
expr_stmt|;
name|ob
operator|.
name|dbase
operator|=
name|data
operator|->
name|dbase
expr_stmt|;
name|ob
operator|.
name|u
operator|.
name|single
operator|=
operator|(
name|fde
operator|*
operator|)
name|eh_frame
expr_stmt|;
name|ob
operator|.
name|s
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|ob
operator|.
name|s
operator|.
name|b
operator|.
name|mixed_encoding
operator|=
literal|1
expr_stmt|;
comment|/* Need to assume worst case.  */
name|data
operator|->
name|ret
operator|=
name|linear_search_fdes
argument_list|(
operator|&
name|ob
argument_list|,
operator|(
name|fde
operator|*
operator|)
name|eh_frame
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ret
operator|!=
name|NULL
condition|)
block|{
name|_Unwind_Ptr
name|func
decl_stmt|;
name|unsigned
name|int
name|encoding
init|=
name|get_fde_encoding
argument_list|(
name|data
operator|->
name|ret
argument_list|)
decl_stmt|;
name|read_encoded_value_with_base
argument_list|(
name|encoding
argument_list|,
name|base_from_cb_data
argument_list|(
name|encoding
argument_list|,
name|data
argument_list|)
argument_list|,
name|data
operator|->
name|ret
operator|->
name|pc_begin
argument_list|,
operator|&
name|func
argument_list|)
expr_stmt|;
name|data
operator|->
name|func
operator|=
operator|(
name|void
operator|*
operator|)
name|func
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|fde
modifier|*
name|_Unwind_Find_FDE
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|struct
name|dwarf_eh_bases
modifier|*
name|bases
parameter_list|)
block|{
name|struct
name|unw_eh_callback_data
name|data
decl_stmt|;
specifier|const
name|fde
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|_Unwind_Find_registered_FDE
argument_list|(
name|pc
argument_list|,
name|bases
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
name|ret
return|;
name|data
operator|.
name|pc
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|pc
expr_stmt|;
name|data
operator|.
name|tbase
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|dbase
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|func
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|ret
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|check_cache
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dl_iterate_phdr
argument_list|(
name|_Unwind_IteratePhdrCallback
argument_list|,
operator|&
name|data
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|data
operator|.
name|ret
condition|)
block|{
name|bases
operator|->
name|tbase
operator|=
name|data
operator|.
name|tbase
expr_stmt|;
name|bases
operator|->
name|dbase
operator|=
name|data
operator|.
name|dbase
expr_stmt|;
name|bases
operator|->
name|func
operator|=
name|data
operator|.
name|func
expr_stmt|;
block|}
return|return
name|data
operator|.
name|ret
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Prevent multiple include of header files.  */
end_comment

begin_define
define|#
directive|define
name|_Unwind_Find_FDE
value|_Unwind_Find_FDE
end_define

begin_include
include|#
directive|include
file|"unwind-dw2-fde.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_GAS_SYMVER
argument_list|)
operator|&&
name|defined
argument_list|(
name|SHARED
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LIBUNWIND_EXCEPTIONS
argument_list|)
end_if

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_Find_FDE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

