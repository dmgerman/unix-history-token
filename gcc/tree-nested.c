begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Nested function decomposition for trees.    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* The object of this pass is to lower the representation of a set of nested    functions in order to expose all of the gory details of the various    nonlocal references.  We want to do this sooner rather than later, in    order to give us more freedom in emitting all of the functions in question.     Back in olden times, when gcc was young, we developed an insanely     complicated scheme whereby variables which were referenced nonlocally    were forced to live in the stack of the declaring function, and then    the nested functions magically discovered where these variables were    placed.  In order for this scheme to function properly, it required    that the outer function be partially expanded, then we switch to     compiling the inner function, and once done with those we switch back    to compiling the outer function.  Such delicate ordering requirements    makes it difficult to do whole translation unit optimizations     involving such functions.     The implementation here is much more direct.  Everything that can be    referenced by an inner function is a member of an explicitly created    structure herein called the "nonlocal frame struct".  The incoming    static chain for a nested function is a pointer to this struct in     the parent.  In this way, we settle on known offsets from a known    base, and so are decoupled from the logic that places objects in the    function's stack frame.  More importantly, we don't have to wait for    that to happen -- since the compilation of the inner function is no    longer tied to a real stack frame, the nonlocal frame struct can be    allocated anywhere.  Which means that the outer function is now    inlinable.     Theory of operation here is very simple.  Iterate over all the     statements in all the functions (depth first) several times,     allocating structures and fields on demand.  In general we want to    examine inner functions first, so that we can avoid making changes    to outer functions which are unnecessary.     The order of the passes matters a bit, in that later passes will be    skipped if it is discovered that the functions don't actually interact    at all.  That is, they're nested in the lexical sense but could have    been written as independent functions without change.  */
end_comment

begin_decl_stmt
name|struct
name|var_map_elt
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|old
decl_stmt|;
name|tree
name|new
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|nesting_info
name|GTY
argument_list|(
operator|(
name|chain_next
argument_list|(
literal|"%h.next"
argument_list|)
operator|)
argument_list|)
block|{
name|struct
name|nesting_info
modifier|*
name|outer
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|inner
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|next
decl_stmt|;
name|htab_t
name|GTY
argument_list|(
operator|(
name|param_is
argument_list|(
expr|struct
name|var_map_elt
argument_list|)
operator|)
argument_list|)
name|field_map
decl_stmt|;
name|htab_t
name|GTY
argument_list|(
operator|(
name|param_is
argument_list|(
expr|struct
name|var_map_elt
argument_list|)
operator|)
argument_list|)
name|var_map
decl_stmt|;
name|bitmap
name|suppress_expansion
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|new_local_var_chain
decl_stmt|;
name|tree
name|debug_var_chain
decl_stmt|;
name|tree
name|frame_type
decl_stmt|;
name|tree
name|frame_decl
decl_stmt|;
name|tree
name|chain_field
decl_stmt|;
name|tree
name|chain_decl
decl_stmt|;
name|tree
name|nl_goto_field
decl_stmt|;
name|bool
name|any_parm_remapped
decl_stmt|;
name|bool
name|any_tramp_created
decl_stmt|;
name|char
name|static_chain_added
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Hashing and equality functions for nesting_info->var_map.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|var_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|struct
name|var_map_elt
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|var_map_elt
operator|*
operator|)
name|x
decl_stmt|;
return|return
name|htab_hash_pointer
argument_list|(
name|a
operator|->
name|old
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|var_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
specifier|const
name|struct
name|var_map_elt
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|var_map_elt
operator|*
operator|)
name|x
decl_stmt|;
specifier|const
name|struct
name|var_map_elt
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|var_map_elt
operator|*
operator|)
name|y
decl_stmt|;
return|return
name|a
operator|->
name|old
operator|==
name|b
operator|->
name|old
return|;
block|}
end_function

begin_comment
comment|/* We're working in so many different function contexts simultaneously,    that create_tmp_var is dangerous.  Prevent mishap.  */
end_comment

begin_define
define|#
directive|define
name|create_tmp_var
value|cant_use_create_tmp_var_here_dummy
end_define

begin_comment
comment|/* Like create_tmp_var, except record the variable for registration at    the given nesting level.  */
end_comment

begin_function
specifier|static
name|tree
name|create_tmp_var_for
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|tree
name|tmp_var
decl_stmt|;
comment|/* If the type is of variable size or a type which must be created by the      frontend, something is wrong.  Note that we explicitly allow      incomplete types here, since we create them ourselves here.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|tmp_var
operator|=
name|create_tmp_var_raw
argument_list|(
name|type
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tmp_var
argument_list|)
operator|=
name|info
operator|->
name|context
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|tmp_var
argument_list|)
operator|=
name|info
operator|->
name|new_local_var_chain
expr_stmt|;
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|new_local_var_chain
operator|=
name|tmp_var
expr_stmt|;
return|return
name|tmp_var
return|;
block|}
end_function

begin_comment
comment|/* Take the address of EXP to be used within function CONTEXT.    Mark it for addressability as necessary.  */
end_comment

begin_function
name|tree
name|build_addr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|context
parameter_list|)
block|{
name|tree
name|base
init|=
name|exp
decl_stmt|;
name|tree
name|save_context
decl_stmt|;
name|tree
name|retval
decl_stmt|;
while|while
condition|(
name|handled_component_p
argument_list|(
name|base
argument_list|)
condition|)
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|base
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|base
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Building the ADDR_EXPR will compute a set of properties for      that ADDR_EXPR.  Those properties are unfortunately context      specific.  ie, they are dependent on CURRENT_FUNCTION_DECL.       Temporarily set CURRENT_FUNCTION_DECL to the desired context,      build the ADDR_EXPR, then restore CURRENT_FUNCTION_DECL.  That      way the properties are for the ADDR_EXPR are computed properly.  */
name|save_context
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|context
expr_stmt|;
name|retval
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|save_context
expr_stmt|;
empty_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Insert FIELD into TYPE, sorted by alignment requirements.  */
end_comment

begin_function
name|void
name|insert_field_into_struct
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|field
parameter_list|)
block|{
name|tree
modifier|*
name|p
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
operator|=
name|type
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
control|)
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|>=
name|DECL_ALIGN
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|field
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build or return the RECORD_TYPE that describes the frame state that is    shared between INFO->CONTEXT and its nested functions.  This record will    not be complete until finalize_nesting_tree; up until that point we'll    be adding fields as necessary.     We also build the DECL that represents this frame in the function.  */
end_comment

begin_function
specifier|static
name|tree
name|get_frame_type
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|)
block|{
name|tree
name|type
init|=
name|info
operator|->
name|frame_type
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|type
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|name
operator|=
name|concat
argument_list|(
literal|"FRAME."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|info
operator|->
name|context
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|frame_type
operator|=
name|type
expr_stmt|;
name|info
operator|->
name|frame_decl
operator|=
name|create_tmp_var_for
argument_list|(
name|info
argument_list|,
name|type
argument_list|,
literal|"FRAME"
argument_list|)
expr_stmt|;
comment|/* ??? Always make it addressable for now, since it is meant to 	 be pointed to by the static chain pointer.  This pessimizes 	 when it turns out that no static chains are needed because 	 the nested functions referencing non-local variables are not 	 reachable, but the true pessimization is to create the non- 	 local frame structure in the first place.  */
name|TREE_ADDRESSABLE
argument_list|(
name|info
operator|->
name|frame_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return true if DECL should be referenced by pointer in the non-local    frame structure.  */
end_comment

begin_function
specifier|static
name|bool
name|use_pointer_in_frame
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* It's illegal to copy TREE_ADDRESSABLE, impossible to copy variable          sized decls, and inefficient to copy large aggregates.  Don't bother          moving anything but scalar variables.  */
return|return
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Variable sized types make things "interesting" in the frame.  */
return|return
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given DECL, a non-locally accessed variable, find or create a field    in the non-local frame structure for the given nesting context.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_for_decl
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|decl
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|var_map_elt
modifier|*
name|elt
decl_stmt|,
name|dummy
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|dummy
operator|.
name|old
operator|=
name|decl
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|info
operator|->
name|field_map
argument_list|,
operator|&
name|dummy
argument_list|,
name|insert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
block|{
name|gcc_assert
argument_list|(
name|insert
operator|!=
name|INSERT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|elt
operator|=
operator|(
expr|struct
name|var_map_elt
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|elt
operator|&&
name|insert
operator|==
name|INSERT
condition|)
block|{
name|field
operator|=
name|make_node
argument_list|(
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_pointer_in_frame
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|field
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|field
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|field
argument_list|)
operator|=
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|field
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|insert_field_into_struct
argument_list|(
name|get_frame_type
argument_list|(
name|info
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|elt
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|var_map_elt
argument_list|)
expr_stmt|;
name|elt
operator|->
name|old
operator|=
name|decl
expr_stmt|;
name|elt
operator|->
name|new
operator|=
name|field
expr_stmt|;
operator|*
name|slot
operator|=
name|elt
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|info
operator|->
name|any_parm_remapped
operator|=
name|true
expr_stmt|;
block|}
else|else
name|field
operator|=
name|elt
condition|?
name|elt
operator|->
name|new
else|:
name|NULL
expr_stmt|;
return|return
name|field
return|;
block|}
end_function

begin_comment
comment|/* Build or return the variable that holds the static chain within    INFO->CONTEXT.  This variable may only be used within INFO->CONTEXT.  */
end_comment

begin_function
specifier|static
name|tree
name|get_chain_decl
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|)
block|{
name|tree
name|decl
init|=
name|info
operator|->
name|chain_decl
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|get_frame_type
argument_list|(
name|info
operator|->
name|outer
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Note that this variable is *not* entered into any BIND_EXPR; 	 the construction of this variable is handled specially in 	 expand_function_start and initialize_inlined_parameters. 	 Note also that it's represented as a parameter.  This is more 	 close to the truth, since the initial value does come from  	 the caller.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|create_tmp_var_name
argument_list|(
literal|"CHAIN"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|info
operator|->
name|context
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Tell tree-inline.c that we never write to this variable, so 	 it can copy-prop the replacement value immediately.  */
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|chain_decl
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Build or return the field within the non-local frame state that holds    the static chain for INFO->CONTEXT.  This is the way to walk back up    multiple nesting levels.  */
end_comment

begin_function
specifier|static
name|tree
name|get_chain_field
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|)
block|{
name|tree
name|field
init|=
name|info
operator|->
name|chain_field
decl_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|get_frame_type
argument_list|(
name|info
operator|->
name|outer
argument_list|)
argument_list|)
decl_stmt|;
name|field
operator|=
name|make_node
argument_list|(
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|=
name|get_identifier
argument_list|(
literal|"__chain"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insert_field_into_struct
argument_list|(
name|get_frame_type
argument_list|(
name|info
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|info
operator|->
name|chain_field
operator|=
name|field
expr_stmt|;
block|}
return|return
name|field
return|;
block|}
end_function

begin_comment
comment|/* Copy EXP into a temporary.  Allocate the temporary in the context of    INFO and insert the initialization statement before TSI.  */
end_comment

begin_function
specifier|static
name|tree
name|init_tmp_var
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|exp
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|stmt
decl_stmt|;
name|t
operator|=
name|create_tmp_var_for
argument_list|(
name|info
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|stmt
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but only do so to force EXP to satisfy is_gimple_val.  */
end_comment

begin_function
specifier|static
name|tree
name|tsi_gimplify_val
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|exp
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
if|if
condition|(
name|is_gimple_val
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
else|else
return|return
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|exp
argument_list|,
name|tsi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but copy from the temporary and insert the statement    after the iterator.  */
end_comment

begin_function
specifier|static
name|tree
name|save_tmp_var
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|exp
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|stmt
decl_stmt|;
name|t
operator|=
name|create_tmp_var_for
argument_list|(
name|info
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|exp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|stmt
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build or return the type used to represent a nested function trampoline.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|trampoline_type
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|tree
name|get_trampoline_type
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|record
decl_stmt|,
name|t
decl_stmt|;
name|unsigned
name|align
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|trampoline_type
condition|)
return|return
name|trampoline_type
return|;
name|align
operator|=
name|TRAMPOLINE_ALIGNMENT
expr_stmt|;
name|size
operator|=
name|TRAMPOLINE_SIZE
expr_stmt|;
comment|/* If we won't be able to guarantee alignment simply via TYPE_ALIGN,      then allocate extra space so that we can do dynamic alignment.  */
if|if
condition|(
name|align
operator|>
name|STACK_BOUNDARY
condition|)
block|{
name|size
operator|+=
operator|(
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|&
operator|-
operator|(
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|align
operator|=
name|STACK_BOUNDARY
expr_stmt|;
block|}
name|t
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__data"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|align
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|record
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|get_identifier
argument_list|(
literal|"__builtin_trampoline"
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|t
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
return|return
name|record
return|;
block|}
end_function

begin_comment
comment|/* Given DECL, a nested function, find or create a field in the non-local    frame structure for a trampoline for this function.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tramp_for_decl
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|decl
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|var_map_elt
modifier|*
name|elt
decl_stmt|,
name|dummy
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|dummy
operator|.
name|old
operator|=
name|decl
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|info
operator|->
name|var_map
argument_list|,
operator|&
name|dummy
argument_list|,
name|insert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
block|{
name|gcc_assert
argument_list|(
name|insert
operator|!=
name|INSERT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|elt
operator|=
operator|(
expr|struct
name|var_map_elt
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|elt
operator|&&
name|insert
operator|==
name|INSERT
condition|)
block|{
name|field
operator|=
name|make_node
argument_list|(
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|=
name|get_trampoline_type
argument_list|()
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insert_field_into_struct
argument_list|(
name|get_frame_type
argument_list|(
name|info
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|elt
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|var_map_elt
argument_list|)
expr_stmt|;
name|elt
operator|->
name|old
operator|=
name|decl
expr_stmt|;
name|elt
operator|->
name|new
operator|=
name|field
expr_stmt|;
operator|*
name|slot
operator|=
name|elt
expr_stmt|;
name|info
operator|->
name|any_tramp_created
operator|=
name|true
expr_stmt|;
block|}
else|else
name|field
operator|=
name|elt
condition|?
name|elt
operator|->
name|new
else|:
name|NULL
expr_stmt|;
return|return
name|field
return|;
block|}
end_function

begin_comment
comment|/* Build or return the field within the non-local frame state that holds    the non-local goto "jmp_buf".  The buffer itself is maintained by the    rtl middle-end as dynamic stack space is allocated.  */
end_comment

begin_function
specifier|static
name|tree
name|get_nl_goto_field
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|)
block|{
name|tree
name|field
init|=
name|info
operator|->
name|nl_goto_field
decl_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|unsigned
name|size
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* For __builtin_nonlocal_goto, we need N words.  The first is the 	 frame pointer, the rest is for the target's stack pointer save 	 area.  The number of words is controlled by STACK_SAVEAREA_MODE; 	 not the best interface, but it'll do for now.  */
if|if
condition|(
name|Pmode
operator|==
name|ptr_mode
condition|)
name|type
operator|=
name|ptr_type_node
expr_stmt|;
else|else
name|type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|STACK_SAVEAREA_MODE
argument_list|(
name|SAVE_NONLOCAL
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|size
operator|/
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|size
operator|=
name|size
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|=
name|make_node
argument_list|(
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|=
name|get_identifier
argument_list|(
literal|"__nl_goto_buf"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insert_field_into_struct
argument_list|(
name|get_frame_type
argument_list|(
name|info
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|info
operator|->
name|nl_goto_field
operator|=
name|field
expr_stmt|;
block|}
return|return
name|field
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for walk_stmts.  Walk output operands of an ASM_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|walk_asm_expr
parameter_list|(
name|struct
name|walk_stmt_info
modifier|*
name|wi
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|noutputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|link
operator|=
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
expr_stmt|;
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
operator|(
name|allows_reg
operator|||
operator|!
name|allows_mem
operator|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|wi
operator|->
name|callback
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
operator|(
name|allows_reg
operator|||
operator|!
name|allows_mem
operator|)
expr_stmt|;
comment|/* Although input "m" is not really a LHS, we need a lvalue.  */
name|wi
operator|->
name|is_lhs
operator|=
operator|!
name|wi
operator|->
name|val_only
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|wi
operator|->
name|callback
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Iterate over all sub-statements of *TP calling walk_tree with    WI->CALLBACK for every sub-expression in each statement found.  */
end_comment

begin_function
name|void
name|walk_stmts
parameter_list|(
name|struct
name|walk_stmt_info
modifier|*
name|wi
parameter_list|,
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|int
name|walk_subtrees
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|wi
operator|->
name|want_locations
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|t
argument_list|)
condition|)
name|input_location
operator|=
name|EXPR_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|wi
operator|->
name|tsi
operator|=
name|i
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|COND_EXPR
case|:
name|walk_tree
argument_list|(
operator|&
name|COND_EXPR_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|wi
operator|->
name|callback
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|COND_EXPR_THEN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|COND_EXPR_ELSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXPR
case|:
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|CATCH_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_FILTER_EXPR
case|:
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|EH_FILTER_FAILURE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_CATCH_EXPR
case|:
case|case
name|TRY_FINALLY_EXPR
case|:
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
if|if
condition|(
name|wi
operator|->
name|want_bind_expr
condition|)
block|{
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|wi
operator|->
name|callback
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|wi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|walk_subtrees
condition|)
break|break;
block|}
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
if|if
condition|(
name|wi
operator|->
name|want_return_expr
condition|)
block|{
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|wi
operator|->
name|callback
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|wi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|walk_subtrees
condition|)
break|break;
block|}
name|walk_stmts
argument_list|(
name|wi
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
comment|/* A formal temporary lhs may use a COMPONENT_REF rhs.  */
name|wi
operator|->
name|val_only
operator|=
operator|!
name|is_gimple_formal_tmp_var
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|wi
operator|->
name|callback
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the rhs is appropriate for a memory, we may use a 	 COMPONENT_REF on the lhs.  */
name|wi
operator|->
name|val_only
operator|=
operator|!
name|is_gimple_mem_rhs
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|true
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|wi
operator|->
name|callback
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|walk_asm_expr
argument_list|(
name|wi
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|wi
operator|->
name|callback
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Invoke CALLBACK on all statements of *STMT_P.  */
end_comment

begin_function
specifier|static
name|void
name|walk_body
parameter_list|(
name|walk_tree_fn
name|callback
parameter_list|,
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|struct
name|walk_stmt_info
name|wi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|wi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|wi
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|wi
operator|.
name|val_only
operator|=
name|true
expr_stmt|;
name|walk_stmts
argument_list|(
operator|&
name|wi
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invoke CALLBACK on all statements of INFO->CONTEXT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|walk_function
parameter_list|(
name|walk_tree_fn
name|callback
parameter_list|,
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|)
block|{
name|walk_body
argument_list|(
name|callback
argument_list|,
name|info
argument_list|,
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|info
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly for ROOT and all functions nested underneath, depth first.  */
end_comment

begin_function
specifier|static
name|void
name|walk_all_functions
parameter_list|(
name|walk_tree_fn
name|callback
parameter_list|,
name|struct
name|nesting_info
modifier|*
name|root
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|root
operator|->
name|inner
condition|)
name|walk_all_functions
argument_list|(
name|callback
argument_list|,
name|root
operator|->
name|inner
argument_list|)
expr_stmt|;
name|walk_function
argument_list|(
name|callback
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|root
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have to check for a fairly pathological case.  The operands of function    nested function are to be interpreted in the context of the enclosing    function.  So if any are variably-sized, they will get remapped when the    enclosing function is inlined.  But that remapping would also have to be    done in the types of the PARM_DECLs of the nested function, meaning the    argument types of that function will disagree with the arguments in the    calls to that function.  So we'd either have to make a copy of the nested    function corresponding to each time the enclosing function was inlined or    add a VIEW_CONVERT_EXPR to each such operand for each call to the nested    function.  The former is not practical.  The latter would still require    detecting this case to know when to add the conversions.  So, for now at    least, we don't inline such an enclosing function.     We have to do that check recursively, so here return indicating whether    FNDECL has such a nested function.  ORIG_FN is the function we were    trying to inline to use for checking whether any argument is variably    modified by anything in it.     It would be better to do this in tree-inline.c so that we could give    the appropriate warning for why a function can't be inlined, but that's    too late since the nesting structure has already been flattened and    adding a flag just to record this fact seems a waste of a flag.  */
end_comment

begin_function
specifier|static
name|bool
name|check_for_nested_with_variably_modified
parameter_list|(
name|tree
name|fndecl
parameter_list|,
name|tree
name|orig_fndecl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|cgn
init|=
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|cgn
operator|=
name|cgn
operator|->
name|nested
init|;
name|cgn
condition|;
name|cgn
operator|=
name|cgn
operator|->
name|next_nested
control|)
block|{
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|cgn
operator|->
name|decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|orig_fndecl
condition|)
return|return
name|true
return|;
if|if
condition|(
name|check_for_nested_with_variably_modified
argument_list|(
name|cgn
operator|->
name|decl
argument_list|,
name|orig_fndecl
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Construct our local datastructure describing the function nesting    tree rooted by CGN.  */
end_comment

begin_function
specifier|static
name|struct
name|nesting_info
modifier|*
name|create_nesting_tree
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|cgn
parameter_list|)
block|{
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|GGC_CNEW
argument_list|(
expr|struct
name|nesting_info
argument_list|)
decl_stmt|;
name|info
operator|->
name|field_map
operator|=
name|htab_create_ggc
argument_list|(
literal|7
argument_list|,
name|var_map_hash
argument_list|,
name|var_map_eq
argument_list|,
name|ggc_free
argument_list|)
expr_stmt|;
name|info
operator|->
name|var_map
operator|=
name|htab_create_ggc
argument_list|(
literal|7
argument_list|,
name|var_map_hash
argument_list|,
name|var_map_eq
argument_list|,
name|ggc_free
argument_list|)
expr_stmt|;
name|info
operator|->
name|suppress_expansion
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
name|info
operator|->
name|context
operator|=
name|cgn
operator|->
name|decl
expr_stmt|;
for|for
control|(
name|cgn
operator|=
name|cgn
operator|->
name|nested
init|;
name|cgn
condition|;
name|cgn
operator|=
name|cgn
operator|->
name|next_nested
control|)
block|{
name|struct
name|nesting_info
modifier|*
name|sub
init|=
name|create_nesting_tree
argument_list|(
name|cgn
argument_list|)
decl_stmt|;
name|sub
operator|->
name|outer
operator|=
name|info
expr_stmt|;
name|sub
operator|->
name|next
operator|=
name|info
operator|->
name|inner
expr_stmt|;
name|info
operator|->
name|inner
operator|=
name|sub
expr_stmt|;
block|}
comment|/* See discussion at check_for_nested_with_variably_modified for a      discussion of why this has to be here.  */
if|if
condition|(
name|check_for_nested_with_variably_modified
argument_list|(
name|info
operator|->
name|context
argument_list|,
name|info
operator|->
name|context
argument_list|)
condition|)
name|DECL_UNINLINABLE
argument_list|(
name|info
operator|->
name|context
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_comment
comment|/* Return an expression computing the static chain for TARGET_CONTEXT    from INFO->CONTEXT.  Insert any necessary computations before TSI.  */
end_comment

begin_function
specifier|static
name|tree
name|get_static_chain
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|target_context
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|struct
name|nesting_info
modifier|*
name|i
decl_stmt|;
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|context
operator|==
name|target_context
condition|)
block|{
name|x
operator|=
name|build_addr
argument_list|(
name|info
operator|->
name|frame_decl
argument_list|,
name|target_context
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|get_chain_decl
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|outer
init|;
name|i
operator|->
name|context
operator|!=
name|target_context
condition|;
name|i
operator|=
name|i
operator|->
name|outer
control|)
block|{
name|tree
name|field
init|=
name|get_chain_field
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|x
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|x
operator|=
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
name|tsi
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return an expression referencing FIELD from TARGET_CONTEXT's non-local    frame as seen from INFO->CONTEXT.  Insert any necessary computations    before TSI.  */
end_comment

begin_function
specifier|static
name|tree
name|get_frame_field
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|target_context
parameter_list|,
name|tree
name|field
parameter_list|,
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|struct
name|nesting_info
modifier|*
name|i
decl_stmt|;
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|context
operator|==
name|target_context
condition|)
block|{
comment|/* Make sure frame_decl gets created.  */
operator|(
name|void
operator|)
name|get_frame_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|x
operator|=
name|info
operator|->
name|frame_decl
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|get_chain_decl
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|outer
init|;
name|i
operator|->
name|context
operator|!=
name|target_context
condition|;
name|i
operator|=
name|i
operator|->
name|outer
control|)
block|{
name|tree
name|field
init|=
name|get_chain_field
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|x
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|x
operator|=
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
name|tsi
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|x
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of convert_nonlocal_reference.  Create a local variable    in the nested function with DECL_VALUE_EXPR set to reference the true    variable in the parent function.  This is used both for debug info     and in OpenMP lowering.  */
end_comment

begin_function
specifier|static
name|tree
name|get_nonlocal_debug_decl
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|var_map_elt
modifier|*
name|elt
decl_stmt|,
name|dummy
decl_stmt|;
name|tree
name|target_context
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|i
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|field
decl_stmt|,
name|new_decl
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|dummy
operator|.
name|old
operator|=
name|decl
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|info
operator|->
name|var_map
argument_list|,
operator|&
name|dummy
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|elt
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|elt
condition|)
return|return
name|elt
operator|->
name|new
return|;
name|target_context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* A copy of the code in get_frame_field, but without the temporaries.  */
if|if
condition|(
name|info
operator|->
name|context
operator|==
name|target_context
condition|)
block|{
comment|/* Make sure frame_decl gets created.  */
operator|(
name|void
operator|)
name|get_frame_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|x
operator|=
name|info
operator|->
name|frame_decl
expr_stmt|;
name|i
operator|=
name|info
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|get_chain_decl
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|outer
init|;
name|i
operator|->
name|context
operator|!=
name|target_context
condition|;
name|i
operator|=
name|i
operator|->
name|outer
control|)
block|{
name|field
operator|=
name|get_chain_field
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|x
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|field
operator|=
name|lookup_field_for_decl
argument_list|(
name|i
argument_list|,
name|decl
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|x
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_pointer_in_frame
argument_list|(
name|decl
argument_list|)
condition|)
name|x
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* ??? We should be remapping types as well, surely.  */
name|new_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|info
operator|->
name|context
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|new_decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|elt
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|old
operator|=
name|decl
expr_stmt|;
name|elt
operator|->
name|new
operator|=
name|new_decl
expr_stmt|;
operator|*
name|slot
operator|=
name|elt
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|info
operator|->
name|debug_var_chain
expr_stmt|;
name|info
operator|->
name|debug_var_chain
operator|=
name|new_decl
expr_stmt|;
return|return
name|new_decl
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_function+walk_tree, rewrite all references to VAR    and PARM_DECLs that belong to outer functions.     The rewrite will involve some number of structure accesses back up    the static chain.  E.g. for a variable FOO up one nesting level it'll    be CHAIN->FOO.  For two levels it'll be CHAIN->__chain->FOO.  Further    indirections apply to decls for which use_pointer_in_frame is true.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|convert_nonlocal_omp_clauses
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|struct
name|walk_stmt_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|tree
name|convert_nonlocal_reference
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
operator|(
expr|struct
name|walk_stmt_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|tree
name|save_local_var_chain
decl_stmt|;
name|bitmap
name|save_suppress
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
comment|/* Non-automatic variables are never processed.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|decl_function_context
argument_list|(
name|t
argument_list|)
operator|!=
name|info
operator|->
name|context
condition|)
block|{
name|tree
name|x
decl_stmt|;
name|wi
operator|->
name|changed
operator|=
name|true
expr_stmt|;
name|x
operator|=
name|get_nonlocal_debug_decl
argument_list|(
name|info
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|info
operator|->
name|suppress_expansion
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|target_context
init|=
name|decl_function_context
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|outer
init|;
name|i
operator|->
name|context
operator|!=
name|target_context
condition|;
name|i
operator|=
name|i
operator|->
name|outer
control|)
continue|continue;
name|x
operator|=
name|lookup_field_for_decl
argument_list|(
name|i
argument_list|,
name|t
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|x
operator|=
name|get_frame_field
argument_list|(
name|info
argument_list|,
name|target_context
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_pointer_in_frame
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|x
operator|=
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wi
operator|->
name|val_only
condition|)
block|{
if|if
condition|(
name|wi
operator|->
name|is_lhs
condition|)
name|x
operator|=
name|save_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
block|}
operator|*
name|tp
operator|=
name|x
expr_stmt|;
block|}
break|break;
case|case
name|GOTO_EXPR
case|:
comment|/* Don't walk non-local gotos for now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|LABEL_DECL
case|:
comment|/* We're taking the address of a label from a parent function, but 	 this is not itself a non-local goto.  Mark the label such that it 	 will not be deleted, much as we would with a label address in 	 static storage.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|t
argument_list|)
operator|!=
name|info
operator|->
name|context
condition|)
name|FORCED_LABEL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
block|{
name|bool
name|save_val_only
init|=
name|wi
operator|->
name|val_only
decl_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|false
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
name|wi
operator|->
name|changed
operator|=
name|false
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|wi
operator|->
name|changed
condition|)
block|{
name|tree
name|save_context
decl_stmt|;
comment|/* If we changed anything, then TREE_INVARIANT is be wrong, 	       since we're no longer directly referencing a decl.  */
name|save_context
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|info
operator|->
name|context
expr_stmt|;
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|save_context
expr_stmt|;
comment|/* If the callback converted the address argument in a context 	       where we only accept variables (and min_invariant, presumably), 	       then compute the address into a temporary.  */
if|if
condition|(
name|save_val_only
condition|)
operator|*
name|tp
operator|=
name|tsi_gimplify_val
argument_list|(
name|wi
operator|->
name|info
argument_list|,
name|t
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
comment|/* Go down this entire nest and just look at the final prefix and 	 anything that describes the references.  Otherwise, we lose track 	 of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|;
name|tp
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|t
operator|=
operator|*
name|tp
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|wi
operator|->
name|val_only
operator|=
name|false
expr_stmt|;
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|convert_nonlocal_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_PARALLEL
case|:
name|save_suppress
operator|=
name|info
operator|->
name|suppress_expansion
expr_stmt|;
if|if
condition|(
name|convert_nonlocal_omp_clauses
argument_list|(
operator|&
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|wi
argument_list|)
condition|)
block|{
name|tree
name|c
decl_stmt|,
name|decl
decl_stmt|;
name|decl
operator|=
name|get_chain_decl
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_FIRSTPRIVATE
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
operator|=
name|decl
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
operator|=
name|c
expr_stmt|;
block|}
name|save_local_var_chain
operator|=
name|info
operator|->
name|new_local_var_chain
expr_stmt|;
name|info
operator|->
name|new_local_var_chain
operator|=
name|NULL
expr_stmt|;
name|walk_body
argument_list|(
name|convert_nonlocal_reference
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_PARALLEL_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|new_local_var_chain
condition|)
name|declare_vars
argument_list|(
name|info
operator|->
name|new_local_var_chain
argument_list|,
name|OMP_PARALLEL_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|info
operator|->
name|new_local_var_chain
operator|=
name|save_local_var_chain
expr_stmt|;
name|info
operator|->
name|suppress_expansion
operator|=
name|save_suppress
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
name|save_suppress
operator|=
name|info
operator|->
name|suppress_expansion
expr_stmt|;
name|convert_nonlocal_omp_clauses
argument_list|(
operator|&
name|OMP_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|wi
argument_list|)
expr_stmt|;
name|walk_body
argument_list|(
name|convert_nonlocal_reference
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|suppress_expansion
operator|=
name|save_suppress
expr_stmt|;
break|break;
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
name|walk_body
argument_list|(
name|convert_nonlocal_reference
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
block|}
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|convert_nonlocal_omp_clauses
parameter_list|(
name|tree
modifier|*
name|pclauses
parameter_list|,
name|struct
name|walk_stmt_info
modifier|*
name|wi
parameter_list|)
block|{
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|bool
name|need_chain
init|=
name|false
decl_stmt|;
name|tree
name|clause
decl_stmt|,
name|decl
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|bitmap
name|new_suppress
decl_stmt|;
name|new_suppress
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
name|bitmap_copy
argument_list|(
name|new_suppress
argument_list|,
name|info
operator|->
name|suppress_expansion
argument_list|)
expr_stmt|;
for|for
control|(
name|clause
operator|=
operator|*
name|pclauses
init|;
name|clause
condition|;
name|clause
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clause
argument_list|)
control|)
block|{
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|clause
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
case|case
name|OMP_CLAUSE_SHARED
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|clause
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|!=
name|info
operator|->
name|context
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|new_suppress
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|clause
argument_list|)
operator|=
name|get_nonlocal_debug_decl
argument_list|(
name|info
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|need_chain
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
if|if
condition|(
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|clause
argument_list|)
operator|==
name|NULL
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
name|convert_nonlocal_reference
argument_list|(
operator|&
name|OMP_CLAUSE_OPERAND
argument_list|(
name|clause
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|,
name|wi
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|info
operator|->
name|suppress_expansion
operator|=
name|new_suppress
expr_stmt|;
return|return
name|need_chain
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of convert_local_reference.  Create a local variable    in the parent function with DECL_VALUE_EXPR set to reference the    field in FRAME.  This is used both for debug info and in OpenMP    lowering.  */
end_comment

begin_function
specifier|static
name|tree
name|get_local_debug_decl
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|info
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|field
parameter_list|)
block|{
name|struct
name|var_map_elt
modifier|*
name|elt
decl_stmt|,
name|dummy
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|new_decl
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|dummy
operator|.
name|old
operator|=
name|decl
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|info
operator|->
name|var_map
argument_list|,
operator|&
name|dummy
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|elt
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|elt
condition|)
return|return
name|elt
operator|->
name|new
return|;
comment|/* Make sure frame_decl gets created.  */
operator|(
name|void
operator|)
name|get_frame_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|x
operator|=
name|info
operator|->
name|frame_decl
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|x
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|new_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|info
operator|->
name|context
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|new_decl
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|elt
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|old
operator|=
name|decl
expr_stmt|;
name|elt
operator|->
name|new
operator|=
name|new_decl
expr_stmt|;
operator|*
name|slot
operator|=
name|elt
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|info
operator|->
name|debug_var_chain
expr_stmt|;
name|info
operator|->
name|debug_var_chain
operator|=
name|new_decl
expr_stmt|;
comment|/* Do not emit debug info twice.  */
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|new_decl
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_function+walk_tree, rewrite all references to VAR    and PARM_DECLs that were referenced by inner nested functions.    The rewrite will be a structure reference to the local frame variable.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|convert_local_omp_clauses
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|struct
name|walk_stmt_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|tree
name|convert_local_reference
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
operator|(
expr|struct
name|walk_stmt_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|,
name|field
decl_stmt|,
name|x
decl_stmt|;
name|bool
name|save_val_only
decl_stmt|;
name|tree
name|save_local_var_chain
decl_stmt|;
name|bitmap
name|save_suppress
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
comment|/* Non-automatic variables are never processed.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|decl_function_context
argument_list|(
name|t
argument_list|)
operator|==
name|info
operator|->
name|context
condition|)
block|{
comment|/* If we copied a pointer to the frame, then the original decl 	     is used unchanged in the parent function.  */
if|if
condition|(
name|use_pointer_in_frame
argument_list|(
name|t
argument_list|)
condition|)
break|break;
comment|/* No need to transform anything if no child references the 	     variable.  */
name|field
operator|=
name|lookup_field_for_decl
argument_list|(
name|info
argument_list|,
name|t
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
break|break;
name|wi
operator|->
name|changed
operator|=
name|true
expr_stmt|;
name|x
operator|=
name|get_local_debug_decl
argument_list|(
name|info
argument_list|,
name|t
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|info
operator|->
name|suppress_expansion
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|x
operator|=
name|get_frame_field
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|context
argument_list|,
name|field
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|->
name|val_only
condition|)
block|{
if|if
condition|(
name|wi
operator|->
name|is_lhs
condition|)
name|x
operator|=
name|save_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
block|}
operator|*
name|tp
operator|=
name|x
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
name|save_val_only
operator|=
name|wi
operator|->
name|val_only
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|false
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
name|wi
operator|->
name|changed
operator|=
name|false
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|save_val_only
expr_stmt|;
comment|/* If we converted anything ... */
if|if
condition|(
name|wi
operator|->
name|changed
condition|)
block|{
name|tree
name|save_context
decl_stmt|;
comment|/* Then the frame decl is now addressable.  */
name|TREE_ADDRESSABLE
argument_list|(
name|info
operator|->
name|frame_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|save_context
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|info
operator|->
name|context
expr_stmt|;
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|save_context
expr_stmt|;
comment|/* If we are in a context where we only accept values, then 	     compute the address into a temporary.  */
if|if
condition|(
name|save_val_only
condition|)
operator|*
name|tp
operator|=
name|tsi_gimplify_val
argument_list|(
name|wi
operator|->
name|info
argument_list|,
name|t
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
comment|/* Go down this entire nest and just look at the final prefix and 	 anything that describes the references.  Otherwise, we lose track 	 of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */
name|save_val_only
operator|=
name|wi
operator|->
name|val_only
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|;
name|tp
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|t
operator|=
operator|*
name|tp
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|wi
operator|->
name|val_only
operator|=
name|false
expr_stmt|;
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|convert_local_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|save_val_only
expr_stmt|;
break|break;
case|case
name|OMP_PARALLEL
case|:
name|save_suppress
operator|=
name|info
operator|->
name|suppress_expansion
expr_stmt|;
if|if
condition|(
name|convert_local_omp_clauses
argument_list|(
operator|&
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|wi
argument_list|)
condition|)
block|{
name|tree
name|c
decl_stmt|;
operator|(
name|void
operator|)
name|get_frame_type
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_SHARED
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
operator|=
name|info
operator|->
name|frame_decl
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
operator|=
name|c
expr_stmt|;
block|}
name|save_local_var_chain
operator|=
name|info
operator|->
name|new_local_var_chain
expr_stmt|;
name|info
operator|->
name|new_local_var_chain
operator|=
name|NULL
expr_stmt|;
name|walk_body
argument_list|(
name|convert_local_reference
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_PARALLEL_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|new_local_var_chain
condition|)
name|declare_vars
argument_list|(
name|info
operator|->
name|new_local_var_chain
argument_list|,
name|OMP_PARALLEL_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|info
operator|->
name|new_local_var_chain
operator|=
name|save_local_var_chain
expr_stmt|;
name|info
operator|->
name|suppress_expansion
operator|=
name|save_suppress
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
name|save_suppress
operator|=
name|info
operator|->
name|suppress_expansion
expr_stmt|;
name|convert_local_omp_clauses
argument_list|(
operator|&
name|OMP_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|wi
argument_list|)
expr_stmt|;
name|walk_body
argument_list|(
name|convert_local_reference
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|suppress_expansion
operator|=
name|save_suppress
expr_stmt|;
break|break;
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
name|walk_body
argument_list|(
name|convert_local_reference
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
block|}
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|convert_local_omp_clauses
parameter_list|(
name|tree
modifier|*
name|pclauses
parameter_list|,
name|struct
name|walk_stmt_info
modifier|*
name|wi
parameter_list|)
block|{
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|bool
name|need_frame
init|=
name|false
decl_stmt|;
name|tree
name|clause
decl_stmt|,
name|decl
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|bitmap
name|new_suppress
decl_stmt|;
name|new_suppress
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
name|bitmap_copy
argument_list|(
name|new_suppress
argument_list|,
name|info
operator|->
name|suppress_expansion
argument_list|)
expr_stmt|;
for|for
control|(
name|clause
operator|=
operator|*
name|pclauses
init|;
name|clause
condition|;
name|clause
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clause
argument_list|)
control|)
block|{
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|clause
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
case|case
name|OMP_CLAUSE_SHARED
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|clause
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
name|info
operator|->
name|context
operator|&&
operator|!
name|use_pointer_in_frame
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|field
init|=
name|lookup_field_for_decl
argument_list|(
name|info
argument_list|,
name|decl
argument_list|,
name|NO_INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|new_suppress
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|clause
argument_list|)
operator|=
name|get_local_debug_decl
argument_list|(
name|info
argument_list|,
name|decl
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|need_frame
operator|=
name|true
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
if|if
condition|(
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|clause
argument_list|)
operator|==
name|NULL
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
name|wi
operator|->
name|val_only
operator|=
name|true
expr_stmt|;
name|wi
operator|->
name|is_lhs
operator|=
name|false
expr_stmt|;
name|convert_local_reference
argument_list|(
operator|&
name|OMP_CLAUSE_OPERAND
argument_list|(
name|clause
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|,
name|wi
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|info
operator|->
name|suppress_expansion
operator|=
name|new_suppress
expr_stmt|;
return|return
name|need_frame
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_function+walk_tree, rewrite all GOTO_EXPRs that     reference labels from outer functions.  The rewrite will be a     call to __builtin_nonlocal_goto.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_nl_goto_reference
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
operator|(
expr|struct
name|walk_stmt_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|,
name|label
decl_stmt|,
name|new_label
decl_stmt|,
name|target_context
decl_stmt|,
name|x
decl_stmt|,
name|arg
decl_stmt|,
name|field
decl_stmt|;
name|struct
name|var_map_elt
modifier|*
name|elt
decl_stmt|,
name|dummy
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|GOTO_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|label
operator|=
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
return|return
name|NULL_TREE
return|;
name|target_context
operator|=
name|decl_function_context
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_context
operator|==
name|info
operator|->
name|context
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|outer
init|;
name|target_context
operator|!=
name|i
operator|->
name|context
condition|;
name|i
operator|=
name|i
operator|->
name|outer
control|)
continue|continue;
comment|/* The original user label may also be use for a normal goto, therefore      we must create a new label that will actually receive the abnormal      control transfer.  This new label will be marked LABEL_NONLOCAL; this      mark will trigger proper behavior in the cfg, as well as cause the      (hairy target-specific) non-local goto receiver code to be generated      when we expand rtl.  Enter this association into var_map so that we      can insert the new label into the IL during a second pass.  */
name|dummy
operator|.
name|old
operator|=
name|label
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|i
operator|->
name|var_map
argument_list|,
operator|&
name|dummy
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|elt
operator|=
operator|(
expr|struct
name|var_map_elt
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|elt
operator|==
name|NULL
condition|)
block|{
name|new_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|DECL_NONLOCAL
argument_list|(
name|new_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|elt
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|var_map_elt
argument_list|)
expr_stmt|;
name|elt
operator|->
name|old
operator|=
name|label
expr_stmt|;
name|elt
operator|->
name|new
operator|=
name|new_label
expr_stmt|;
operator|*
name|slot
operator|=
name|elt
expr_stmt|;
block|}
else|else
name|new_label
operator|=
name|elt
operator|->
name|new
expr_stmt|;
comment|/* Build: __builtin_nl_goto(new_label,&chain->nl_goto_field).  */
name|field
operator|=
name|get_nl_goto_field
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|x
operator|=
name|get_frame_field
argument_list|(
name|info
argument_list|,
name|target_context
argument_list|,
name|field
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_addr
argument_list|(
name|x
argument_list|,
name|target_context
argument_list|)
expr_stmt|;
name|x
operator|=
name|tsi_gimplify_val
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_addr
argument_list|(
name|new_label
argument_list|,
name|target_context
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|x
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_NONLOCAL_GOTO
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|x
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|tsi_stmt
argument_list|(
name|wi
operator|->
name|tsi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tsi_stmt_ptr
argument_list|(
name|wi
operator|->
name|tsi
argument_list|)
operator|=
name|x
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_function+walk_tree, rewrite all LABEL_EXPRs that     are referenced via nonlocal goto from a nested function.  The rewrite    will involve installing a newly generated DECL_NONLOCAL label, and    (potentially) a branch around the rtl gunk that is assumed to be     attached to such a label.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_nl_goto_receiver
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
operator|(
expr|struct
name|walk_stmt_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|,
name|label
decl_stmt|,
name|new_label
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|var_map_elt
modifier|*
name|elt
decl_stmt|,
name|dummy
decl_stmt|;
name|tree_stmt_iterator
name|tmp_tsi
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|label
operator|=
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dummy
operator|.
name|old
operator|=
name|label
expr_stmt|;
name|elt
operator|=
operator|(
expr|struct
name|var_map_elt
operator|*
operator|)
name|htab_find
argument_list|(
name|info
operator|->
name|var_map
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elt
condition|)
return|return
name|NULL_TREE
return|;
name|new_label
operator|=
name|elt
operator|->
name|new
expr_stmt|;
comment|/* If there's any possibility that the previous statement falls through,      then we must branch around the new non-local label.  */
name|tmp_tsi
operator|=
name|wi
operator|->
name|tsi
expr_stmt|;
name|tsi_prev
argument_list|(
operator|&
name|tmp_tsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsi_end_p
argument_list|(
name|tmp_tsi
argument_list|)
operator|||
name|block_may_fallthru
argument_list|(
name|tsi_stmt
argument_list|(
name|tmp_tsi
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
operator|&
name|wi
operator|->
name|tsi
argument_list|,
name|x
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
operator|&
name|wi
operator|->
name|tsi
argument_list|,
name|x
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_function+walk_tree, rewrite all references to addresses    of nested functions that require the use of trampolines.  The rewrite    will involve a reference a trampoline generated for the occasion.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_tramp_reference
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
operator|(
expr|struct
name|walk_stmt_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|,
name|decl
decl_stmt|,
name|target_context
decl_stmt|,
name|x
decl_stmt|,
name|arg
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
comment|/* Build 	   T.1 =&CHAIN->tramp; 	   T.2 = __builtin_adjust_trampoline (T.1); 	   T.3 = (func_type)T.2;       */
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
break|break;
comment|/* Only need to process nested functions.  */
name|target_context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_context
condition|)
break|break;
comment|/* If the nested function doesn't use a static chain, then 	 it doesn't need a trampoline.  */
if|if
condition|(
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* Lookup the immediate parent of the callee, as that's where 	 we need to insert the trampoline.  */
for|for
control|(
name|i
operator|=
name|info
init|;
name|i
operator|->
name|context
operator|!=
name|target_context
condition|;
name|i
operator|=
name|i
operator|->
name|outer
control|)
continue|continue;
name|x
operator|=
name|lookup_tramp_for_decl
argument_list|(
name|i
argument_list|,
name|decl
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* Compute the address of the field holding the trampoline.  */
name|x
operator|=
name|get_frame_field
argument_list|(
name|info
argument_list|,
name|target_context
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_addr
argument_list|(
name|x
argument_list|,
name|target_context
argument_list|)
expr_stmt|;
name|x
operator|=
name|tsi_gimplify_val
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Do machine-specific ugliness.  Normally this will involve 	 computing extra alignment, but it can really be anything.  */
name|x
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_ADJUST_TRAMPOLINE
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|x
operator|=
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
comment|/* Cast back to the proper function type.  */
name|x
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|init_tmp_var
argument_list|(
name|info
argument_list|,
name|x
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* Only walk call arguments, lest we generate trampolines for 	 direct calls.  */
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|convert_tramp_reference
argument_list|,
name|wi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called via walk_function+walk_tree, rewrite all CALL_EXPRs that     reference nested functions to make sure that the static chain is    set up properly for the call.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_call_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|walk_stmt_info
modifier|*
name|wi
init|=
operator|(
expr|struct
name|walk_stmt_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nesting_info
modifier|*
name|info
init|=
name|wi
operator|->
name|info
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|,
name|decl
decl_stmt|,
name|target_context
decl_stmt|;
name|char
name|save_static_chain_added
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
break|break;
name|target_context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_context
operator|&&
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|get_static_chain
argument_list|(
name|info
argument_list|,
name|target_context
argument_list|,
operator|&
name|wi
operator|->
name|tsi
argument_list|)
expr_stmt|;
name|info
operator|->
name|static_chain_added
operator||=
operator|(
literal|1
operator|<<
operator|(
name|info
operator|->
name|context
operator|!=
name|target_context
operator|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|RETURN_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
case|case
name|WITH_SIZE_EXPR
case|:
comment|/* Only return modify and with_size_expr may contain calls.  */
operator|*
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OMP_PARALLEL
case|:
name|save_static_chain_added
operator|=
name|info
operator|->
name|static_chain_added
expr_stmt|;
name|info
operator|->
name|static_chain_added
operator|=
literal|0
expr_stmt|;
name|walk_body
argument_list|(
name|convert_call_expr
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_PARALLEL_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|c
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|static_chain_added
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|decl
operator|=
name|i
condition|?
name|get_chain_decl
argument_list|(
name|info
argument_list|)
else|:
name|info
operator|->
name|frame_decl
expr_stmt|;
comment|/* Don't add CHAIN.* or FRAME.* twice.  */
for|for
control|(
name|c
operator|=
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
operator|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_FIRSTPRIVATE
operator|||
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_SHARED
operator|)
operator|&&
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
operator|==
name|decl
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_FIRSTPRIVATE
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
operator|=
name|decl
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
operator|=
name|c
expr_stmt|;
block|}
block|}
name|info
operator|->
name|static_chain_added
operator||=
name|save_static_chain_added
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_SINGLE
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
name|walk_body
argument_list|(
name|convert_call_expr
argument_list|,
name|info
argument_list|,
operator|&
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Walk the nesting tree starting with ROOT, depth first.  Convert all    trampolines and call expressions.  On the way back up, determine if    a nested function actually uses its static chain; if not, remember that.  */
end_comment

begin_function
specifier|static
name|void
name|convert_all_function_calls
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|root
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|root
operator|->
name|inner
condition|)
name|convert_all_function_calls
argument_list|(
name|root
operator|->
name|inner
argument_list|)
expr_stmt|;
name|walk_function
argument_list|(
name|convert_tramp_reference
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|walk_function
argument_list|(
name|convert_call_expr
argument_list|,
name|root
argument_list|)
expr_stmt|;
comment|/* If the function does not use a static chain, then remember that.  */
if|if
condition|(
name|root
operator|->
name|outer
operator|&&
operator|!
name|root
operator|->
name|chain_decl
operator|&&
operator|!
name|root
operator|->
name|chain_field
condition|)
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|root
operator|->
name|context
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|root
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|root
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Do "everything else" to clean up or complete state collected by the    various walking passes -- lay out the types and decls, generate code    to initialize the frame decl, store critical expressions in the    struct function for rtl to find.  */
end_comment

begin_function
specifier|static
name|void
name|finalize_nesting_tree_1
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|root
parameter_list|)
block|{
name|tree
name|stmt_list
init|=
name|NULL
decl_stmt|;
name|tree
name|context
init|=
name|root
operator|->
name|context
decl_stmt|;
name|struct
name|function
modifier|*
name|sf
decl_stmt|;
comment|/* If we created a non-local frame type or decl, we need to lay them      out at this time.  */
if|if
condition|(
name|root
operator|->
name|frame_type
condition|)
block|{
comment|/* In some cases the frame type will trigger the -Wpadded warning. 	 This is not helpful; suppress it. */
name|int
name|save_warn_padded
init|=
name|warn_padded
decl_stmt|;
name|warn_padded
operator|=
literal|0
expr_stmt|;
name|layout_type
argument_list|(
name|root
operator|->
name|frame_type
argument_list|)
expr_stmt|;
name|warn_padded
operator|=
name|save_warn_padded
expr_stmt|;
name|layout_decl
argument_list|(
name|root
operator|->
name|frame_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If any parameters were referenced non-locally, then we need to       insert a copy.  Likewise, if any variables were referenced by      pointer, we need to initialize the address.  */
if|if
condition|(
name|root
operator|->
name|any_parm_remapped
condition|)
block|{
name|tree
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|context
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|tree
name|field
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|field
operator|=
name|lookup_field_for_decl
argument_list|(
name|root
argument_list|,
name|p
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
continue|continue;
if|if
condition|(
name|use_pointer_in_frame
argument_list|(
name|p
argument_list|)
condition|)
name|x
operator|=
name|build_addr
argument_list|(
name|p
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|p
expr_stmt|;
name|y
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|root
operator|->
name|frame_decl
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a chain_field was created, then it needs to be initialized      from chain_decl.  */
if|if
condition|(
name|root
operator|->
name|chain_field
condition|)
block|{
name|tree
name|x
init|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|root
operator|->
name|chain_field
argument_list|)
argument_list|,
name|root
operator|->
name|frame_decl
argument_list|,
name|root
operator|->
name|chain_field
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|,
name|get_chain_decl
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
block|}
comment|/* If trampolines were created, then we need to initialize them.  */
if|if
condition|(
name|root
operator|->
name|any_tramp_created
condition|)
block|{
name|struct
name|nesting_info
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|root
operator|->
name|inner
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
name|tree
name|arg
decl_stmt|,
name|x
decl_stmt|,
name|field
decl_stmt|;
name|field
operator|=
name|lookup_tramp_for_decl
argument_list|(
name|root
argument_list|,
name|i
operator|->
name|context
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
continue|continue;
if|if
condition|(
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|i
operator|->
name|context
argument_list|)
condition|)
name|x
operator|=
name|null_pointer_node
expr_stmt|;
else|else
name|x
operator|=
name|build_addr
argument_list|(
name|root
operator|->
name|frame_decl
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_addr
argument_list|(
name|i
operator|->
name|context
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|x
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|root
operator|->
name|frame_decl
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_addr
argument_list|(
name|x
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|x
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_INIT_TRAMPOLINE
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we created initialization statements, insert them.  */
if|if
condition|(
name|stmt_list
condition|)
block|{
name|annotate_all_with_locus
argument_list|(
operator|&
name|stmt_list
argument_list|,
name|DECL_SOURCE_LOCATION
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|context
argument_list|)
argument_list|)
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
name|BIND_EXPR_BODY
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|=
name|stmt_list
expr_stmt|;
block|}
comment|/* If a chain_decl was created, then it needs to be registered with      struct function so that it gets initialized from the static chain      register at the beginning of the function.  */
name|sf
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|root
operator|->
name|context
argument_list|)
expr_stmt|;
name|sf
operator|->
name|static_chain_decl
operator|=
name|root
operator|->
name|chain_decl
expr_stmt|;
comment|/* Similarly for the non-local goto save area.  */
if|if
condition|(
name|root
operator|->
name|nl_goto_field
condition|)
block|{
name|sf
operator|->
name|nonlocal_goto_save_area
operator|=
name|get_frame_field
argument_list|(
name|root
argument_list|,
name|context
argument_list|,
name|root
operator|->
name|nl_goto_field
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sf
operator|->
name|has_nonlocal_label
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Make sure all new local variables get inserted into the      proper BIND_EXPR.  */
if|if
condition|(
name|root
operator|->
name|new_local_var_chain
condition|)
name|declare_vars
argument_list|(
name|root
operator|->
name|new_local_var_chain
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|root
operator|->
name|context
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|debug_var_chain
condition|)
name|declare_vars
argument_list|(
name|root
operator|->
name|debug_var_chain
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|root
operator|->
name|context
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Dump the translated tree function.  */
name|dump_function
argument_list|(
name|TDI_nested
argument_list|,
name|root
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|finalize_nesting_tree
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|root
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|root
operator|->
name|inner
condition|)
name|finalize_nesting_tree
argument_list|(
name|root
operator|->
name|inner
argument_list|)
expr_stmt|;
name|finalize_nesting_tree_1
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|root
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Unnest the nodes and pass them to cgraph.  */
end_comment

begin_function
specifier|static
name|void
name|unnest_nesting_tree_1
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
init|=
name|cgraph_node
argument_list|(
name|root
operator|->
name|context
argument_list|)
decl_stmt|;
comment|/* For nested functions update the cgraph to reflect unnesting.      We also delay finalizing of these functions up to this point.  */
if|if
condition|(
name|node
operator|->
name|origin
condition|)
block|{
name|cgraph_unnest_node
argument_list|(
name|cgraph_node
argument_list|(
name|root
operator|->
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|cgraph_finalize_function
argument_list|(
name|root
operator|->
name|context
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unnest_nesting_tree
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|root
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|root
operator|->
name|inner
condition|)
name|unnest_nesting_tree
argument_list|(
name|root
operator|->
name|inner
argument_list|)
expr_stmt|;
name|unnest_nesting_tree_1
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|root
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Free the data structures allocated during this pass.  */
end_comment

begin_function
specifier|static
name|void
name|free_nesting_tree
parameter_list|(
name|struct
name|nesting_info
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|nesting_info
modifier|*
name|next
decl_stmt|;
do|do
block|{
if|if
condition|(
name|root
operator|->
name|inner
condition|)
name|free_nesting_tree
argument_list|(
name|root
operator|->
name|inner
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|root
operator|->
name|var_map
argument_list|)
expr_stmt|;
name|next
operator|=
name|root
operator|->
name|next
expr_stmt|;
name|ggc_free
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|root
condition|)
do|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|nesting_info
operator|*
name|root
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Main entry point for this pass.  Process FNDECL and all of its nested    subroutines and turn them into something less tightly bound.  */
end_comment

begin_function
name|void
name|lower_nested_functions
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|cgn
decl_stmt|;
comment|/* If there are no nested functions, there's nothing to do.  */
name|cgn
operator|=
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cgn
operator|->
name|nested
condition|)
return|return;
name|root
operator|=
name|create_nesting_tree
argument_list|(
name|cgn
argument_list|)
expr_stmt|;
name|walk_all_functions
argument_list|(
name|convert_nonlocal_reference
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|walk_all_functions
argument_list|(
name|convert_local_reference
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|walk_all_functions
argument_list|(
name|convert_nl_goto_reference
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|walk_all_functions
argument_list|(
name|convert_nl_goto_receiver
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|convert_all_function_calls
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|finalize_nesting_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|unnest_nesting_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|free_nesting_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-nested.h"
end_include

end_unit

