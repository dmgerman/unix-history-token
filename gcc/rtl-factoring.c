begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL factoring (sequence abstraction).    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"resource.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"addresses.h"
end_include

begin_comment
comment|/* Sequence abstraction:     It is a size optimization method. The main idea of this technique is to    find identical sequences of code, which can be turned into procedures and    then replace all occurrences with calls to the newly created subroutine.    It is kind of an opposite of function inlining.     There are four major parts of this file:     sequence fingerprint      In order to avoid the comparison of every insn with every other, hash      value will be designed for every insn by COMPUTE_HASH.      These hash values are used for grouping the sequence candidates. So      we only need to compare every insn with every other in same hash group.       FILL_HASH_BUCKET creates all hash values and stores into HASH_BUCKETS.      The result is used by COLLECT_PATTERN_SEQS.     code matching      In code matching the algorithm compares every two possible sequence      candidates which last insns are in the same hash group. If these      sequences are identical they will be stored and do further searches for      finding more sequences which are identical with the first one.       COLLECT_PATTERN_SEQS does the code matching and stores the results into      PATTERN_SEQS.     gain computation      This part computes the gain of abstraction which could be archived when      turning the pattern sequence into a pseudo-function and its matching      sequences into pseudo-calls. After it the most effective sequences will      be marked for abstraction.       RECOMPUTE_GAIN does the gain computation. The sequences with the maximum      gain is on the top of PATTERN_SEQS.     abstract code      This part turns the pattern sequence into a pseudo-function and its      matching sequences into pseudo-calls.       ABSTRACT_BEST_SEQ does the code merging.      C code example:     // Original source            // After sequence abstraction    {                             {                                    void *jump_label;      ...                           ...                                    jump_label =&&exit_0;                                  entry_0:      I0;                           I0;      I1;                           I1;      I2;                           I2;      I3;                           I3;                                    goto *jump_label;                                  exit_0:      ...                           ...                                    jump_label =&&exit_1;                                  goto entry_0;      I0;      I1;      I2;      I3;                                  exit_1:      ...                           ...                                    jump_label =&&exit_2;                                    goto entry_0;      I0;      I1;      I2;      I3;                                  exit_2:      ...                           ...                                    jump_label =&&exit_3;                                    goto entry_0;      I0;      I1;      I2;      I3;                                 exit_3:      ...                           ...    }                             }      TODO:    - Use REG_ALLOC_ORDER when choosing link register.    - Handle JUMP_INSNs. Also handle volatile function calls (handle them      similar to unconditional jumps.)    - Test command line option -fpic. */
end_comment

begin_comment
comment|/* Predicate yielding nonzero iff X is an abstractable insn.  Non-jump insns are    abstractable.  */
end_comment

begin_define
define|#
directive|define
name|ABSTRACTABLE_INSN_P
parameter_list|(
name|X
parameter_list|)
value|(INSN_P (X)&& !JUMP_P (X))
end_define

begin_comment
comment|/* First parameter of the htab_create function call.  */
end_comment

begin_define
define|#
directive|define
name|HASH_INIT
value|1023
end_define

begin_comment
comment|/* Multiplier for cost of sequence call to avoid abstracting short    sequences.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEQ_CALL_COST_MULTIPLIER
end_ifndef

begin_define
define|#
directive|define
name|SEQ_CALL_COST_MULTIPLIER
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Recomputes the cost of MSEQ pattern/matching sequence.  */
end_comment

begin_define
define|#
directive|define
name|RECOMPUTE_COST
parameter_list|(
name|SEQ
parameter_list|)
define|\
value|{                                                           \   int l;                                                    \   rtx x = SEQ->insn;                                        \   SEQ->cost = 0;                                            \   for (l = 0; l< SEQ->abstracted_length; l++)              \     {                                                       \       SEQ->cost += compute_rtx_cost (x);                    \       x = prev_insn_in_block (x);                           \     }                                                       \ }
end_define

begin_comment
comment|/* A sequence matching a pattern sequence.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|matching_seq_def
block|{
comment|/* The last insn in the matching sequence.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Index of INSN instruction.  */
name|unsigned
name|long
name|idx
decl_stmt|;
comment|/* The number of insns matching in this sequence and the pattern sequence.    */
name|int
name|matching_length
decl_stmt|;
comment|/* The number of insns selected to abstract from this sequence. Less than      or equal to MATCHING_LENGTH.  */
name|int
name|abstracted_length
decl_stmt|;
comment|/* The cost of the sequence.  */
name|int
name|cost
decl_stmt|;
comment|/* The next sequence in the chain matching the same pattern.  */
name|struct
name|matching_seq_def
modifier|*
name|next_matching_seq
decl_stmt|;
block|}
typedef|*
name|matching_seq
typedef|;
end_typedef

begin_comment
comment|/* A pattern instruction sequence.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pattern_seq_def
block|{
comment|/* The last insn in the pattern sequence.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Index of INSN instruction.  */
name|unsigned
name|long
name|idx
decl_stmt|;
comment|/* The gain of transforming the pattern sequence into a pseudo-function and      the matching sequences into pseudo-calls.  */
name|int
name|gain
decl_stmt|;
comment|/* The maximum of the ABSTRACTED_LENGTH of the matching sequences.  */
name|int
name|abstracted_length
decl_stmt|;
comment|/* The cost of the sequence.  */
name|int
name|cost
decl_stmt|;
comment|/* The register used to hold the return address during the pseudo-call.  */
name|rtx
name|link_reg
decl_stmt|;
comment|/* The sequences matching this pattern.  */
name|matching_seq
name|matching_seqs
decl_stmt|;
comment|/* The next pattern sequence in the chain.  */
name|struct
name|pattern_seq_def
modifier|*
name|next_pattern_seq
decl_stmt|;
block|}
typedef|*
name|pattern_seq
typedef|;
end_typedef

begin_comment
comment|/* A block of a pattern sequence.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|seq_block_def
block|{
comment|/* The number of insns in the block.  */
name|int
name|length
decl_stmt|;
comment|/* The code_label of the block.  */
name|rtx
name|label
decl_stmt|;
comment|/* The sequences entering the pattern sequence at LABEL.  */
name|matching_seq
name|matching_seqs
decl_stmt|;
comment|/* The next block in the chain. The blocks are sorted by LENGTH in      ascending order.  */
name|struct
name|seq_block_def
modifier|*
name|next_seq_block
decl_stmt|;
block|}
typedef|*
name|seq_block
typedef|;
end_typedef

begin_comment
comment|/* Contains same sequence candidates for further searching.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|hash_bucket_def
block|{
comment|/* The hash value of the group.  */
name|unsigned
name|int
name|hash
decl_stmt|;
comment|/* List of sequence candidates.  */
name|htab_t
name|seq_candidates
decl_stmt|;
block|}
typedef|*
name|p_hash_bucket
typedef|;
end_typedef

begin_comment
comment|/* Contains the last insn of the sequence, and its index value.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|hash_elem_def
block|{
comment|/* Unique index; ordered by FILL_HASH_BUCKET.  */
name|unsigned
name|long
name|idx
decl_stmt|;
comment|/* The last insn in the sequence.  */
name|rtx
name|insn
decl_stmt|;
comment|/* The cached length of the insn.  */
name|int
name|length
decl_stmt|;
block|}
typedef|*
name|p_hash_elem
typedef|;
end_typedef

begin_comment
comment|/* The list of same sequence candidates.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|hash_buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pattern sequences collected from the current functions.  */
end_comment

begin_decl_stmt
specifier|static
name|pattern_seq
name|pattern_seqs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The blocks of the current pattern sequence.  */
end_comment

begin_decl_stmt
specifier|static
name|seq_block
name|seq_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cost of calling sequence.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|seq_call_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cost of jump.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|seq_jump_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cost of returning.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|seq_return_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns the first insn preceding INSN for which INSN_P is true and belongs to    the same basic block. Returns NULL_RTX if no such insn can be found.  */
end_comment

begin_function
specifier|static
name|rtx
name|prev_insn_in_block
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
return|return
name|NULL_RTX
return|;
while|while
condition|(
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|insn
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Returns the hash value of INSN.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|compute_hash
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|hash
operator|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|*
literal|100
expr_stmt|;
name|prev
operator|=
name|prev_insn_in_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|hash
operator|+=
name|INSN_CODE
argument_list|(
name|prev
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Compute the cost of INSN rtx for abstraction.  */
end_comment

begin_function
specifier|static
name|int
name|compute_rtx_cost
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|hash_bucket_def
name|tmp_bucket
decl_stmt|;
name|p_hash_bucket
name|bucket
decl_stmt|;
name|struct
name|hash_elem_def
name|tmp_elem
decl_stmt|;
name|p_hash_elem
name|elem
init|=
name|NULL
decl_stmt|;
name|int
name|cost
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Compute hash value for INSN.  */
name|tmp_bucket
operator|.
name|hash
operator|=
name|compute_hash
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Select the hash group.  */
name|bucket
operator|=
name|htab_find
argument_list|(
name|hash_buckets
argument_list|,
operator|&
name|tmp_bucket
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
condition|)
block|{
name|tmp_elem
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
comment|/* Select the insn.  */
name|elem
operator|=
name|htab_find
argument_list|(
name|bucket
operator|->
name|seq_candidates
argument_list|,
operator|&
name|tmp_elem
argument_list|)
expr_stmt|;
comment|/* If INSN is parsed the cost will be the cached length.  */
if|if
condition|(
name|elem
condition|)
name|cost
operator|=
name|elem
operator|->
name|length
expr_stmt|;
block|}
comment|/* If we can't parse the INSN cost will be the instruction length.  */
if|if
condition|(
name|cost
operator|==
operator|-
literal|1
condition|)
block|{
name|cost
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Cache the length.  */
if|if
condition|(
name|elem
condition|)
name|elem
operator|->
name|length
operator|=
name|cost
expr_stmt|;
block|}
comment|/* If we can't get an accurate estimate for a complex instruction,      assume that it has the same cost as a single fast instruction.  */
return|return
name|cost
operator|!=
literal|0
condition|?
name|cost
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determines the number of common insns in the sequences ending in INSN1 and    INSN2. Returns with LEN number of common insns and COST cost of sequence. */
end_comment

begin_function
specifier|static
name|void
name|matching_length
parameter_list|(
name|rtx
name|insn1
parameter_list|,
name|rtx
name|insn2
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|cost
parameter_list|)
block|{
name|rtx
name|x1
decl_stmt|;
name|rtx
name|x2
decl_stmt|;
name|x1
operator|=
name|insn1
expr_stmt|;
name|x2
operator|=
name|insn2
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|cost
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|x1
operator|&&
name|x2
operator|&&
operator|(
name|x1
operator|!=
name|insn2
operator|)
operator|&&
operator|(
name|x2
operator|!=
name|insn1
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|x1
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|x2
argument_list|)
argument_list|)
condition|)
block|{
operator|(
operator|*
name|len
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|cost
operator|)
operator|+=
name|compute_rtx_cost
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|prev_insn_in_block
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|prev_insn_in_block
argument_list|(
name|x2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adds E0 as a pattern sequence to PATTERN_SEQS with E1 as a matching    sequence.  */
end_comment

begin_function
specifier|static
name|void
name|match_seqs
parameter_list|(
name|p_hash_elem
name|e0
parameter_list|,
name|p_hash_elem
name|e1
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|matching_seq
name|mseq
decl_stmt|,
name|p_prev
decl_stmt|,
name|p_next
decl_stmt|;
comment|/* Determines the cost of the sequence and return without doing anything      if it is too small to produce any gain.  */
name|matching_length
argument_list|(
name|e0
operator|->
name|insn
argument_list|,
name|e1
operator|->
name|insn
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<=
name|seq_call_cost
condition|)
return|return;
comment|/* Prepend a new PATTERN_SEQ to PATTERN_SEQS if the last pattern sequence      does not end in E0->INSN. This assumes that once the E0->INSN changes      the old value will never appear again.  */
if|if
condition|(
operator|!
name|pattern_seqs
operator|||
name|pattern_seqs
operator|->
name|insn
operator|!=
name|e0
operator|->
name|insn
condition|)
block|{
name|pattern_seq
name|pseq
init|=
operator|(
name|pattern_seq
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pattern_seq_def
argument_list|)
argument_list|)
decl_stmt|;
name|pseq
operator|->
name|insn
operator|=
name|e0
operator|->
name|insn
expr_stmt|;
name|pseq
operator|->
name|idx
operator|=
name|e0
operator|->
name|idx
expr_stmt|;
name|pseq
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
comment|/* Set to zero to force recomputing.  */
name|pseq
operator|->
name|abstracted_length
operator|=
literal|0
expr_stmt|;
name|pseq
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
name|pseq
operator|->
name|link_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|pseq
operator|->
name|matching_seqs
operator|=
name|NULL
expr_stmt|;
name|pseq
operator|->
name|next_pattern_seq
operator|=
name|pattern_seqs
expr_stmt|;
name|pattern_seqs
operator|=
name|pseq
expr_stmt|;
block|}
comment|/* Find the position of E1 in the matching sequences list.  */
name|p_prev
operator|=
name|NULL
expr_stmt|;
name|p_next
operator|=
name|pattern_seqs
operator|->
name|matching_seqs
expr_stmt|;
while|while
condition|(
name|p_next
operator|&&
name|p_next
operator|->
name|idx
operator|<
name|e1
operator|->
name|idx
condition|)
block|{
name|p_prev
operator|=
name|p_next
expr_stmt|;
name|p_next
operator|=
name|p_next
operator|->
name|next_matching_seq
expr_stmt|;
block|}
comment|/* Add a new E1 matching sequence to the pattern sequence. We know that      it ends in E0->INSN.  */
name|mseq
operator|=
operator|(
name|matching_seq
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|matching_seq_def
argument_list|)
argument_list|)
expr_stmt|;
name|mseq
operator|->
name|insn
operator|=
name|e1
operator|->
name|insn
expr_stmt|;
name|mseq
operator|->
name|idx
operator|=
name|e1
operator|->
name|idx
expr_stmt|;
name|mseq
operator|->
name|matching_length
operator|=
name|len
expr_stmt|;
name|mseq
operator|->
name|abstracted_length
operator|=
literal|0
expr_stmt|;
name|mseq
operator|->
name|cost
operator|=
name|cost
expr_stmt|;
if|if
condition|(
name|p_prev
operator|==
name|NULL
condition|)
name|pattern_seqs
operator|->
name|matching_seqs
operator|=
name|mseq
expr_stmt|;
else|else
name|p_prev
operator|->
name|next_matching_seq
operator|=
name|mseq
expr_stmt|;
name|mseq
operator|->
name|next_matching_seq
operator|=
name|p_next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Collects all pattern sequences and their matching sequences and puts them    into PATTERN_SEQS.  */
end_comment

begin_function
specifier|static
name|void
name|collect_pattern_seqs
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_iterator
name|hti0
decl_stmt|,
name|hti1
decl_stmt|,
name|hti2
decl_stmt|;
name|p_hash_bucket
name|hash_bucket
decl_stmt|;
name|p_hash_elem
name|e0
decl_stmt|,
name|e1
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
name|basic_block
name|bb
decl_stmt|;
name|bitmap_head
name|stack_reg_live
decl_stmt|;
comment|/* Extra initialization step to ensure that no stack registers (if present)      are live across abnormal edges. Set a flag in STACK_REG_LIVE for an insn      if a stack register is live after the insn.  */
name|bitmap_initialize
argument_list|(
operator|&
name|stack_reg_live
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|regset_head
name|live
decl_stmt|;
name|struct
name|propagate_block_info
modifier|*
name|pbi
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Initialize liveness propagation.  */
name|INIT_REG_SET
argument_list|(
operator|&
name|live
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
operator|&
name|live
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|bb
argument_list|,
operator|&
name|live
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Propagate liveness info and mark insns where a stack reg is live.  */
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_STACK_REG
init|;
name|reg
operator|<=
name|LAST_STACK_REG
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
operator|&
name|live
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
operator|&
name|stack_reg_live
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Free unused data.  */
name|CLEAR_REG_SET
argument_list|(
operator|&
name|live
argument_list|)
expr_stmt|;
name|free_propagate_block_info
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize PATTERN_SEQS to empty.  */
name|pattern_seqs
operator|=
literal|0
expr_stmt|;
comment|/* Try to match every abstractable insn with every other insn in the same      HASH_BUCKET.  */
name|FOR_EACH_HTAB_ELEMENT
argument_list|(
argument|hash_buckets
argument_list|,
argument|hash_bucket
argument_list|,
argument|p_hash_bucket
argument_list|,
argument|hti0
argument_list|)
if|if
condition|(
name|htab_elements
argument_list|(
name|hash_bucket
operator|->
name|seq_candidates
argument_list|)
operator|>
literal|1
condition|)
name|FOR_EACH_HTAB_ELEMENT
argument_list|(
argument|hash_bucket->seq_candidates
argument_list|,
argument|e0
argument_list|,
argument|p_hash_elem
argument_list|,
argument|hti1
argument_list|)
name|FOR_EACH_HTAB_ELEMENT
argument_list|(
argument|hash_bucket->seq_candidates
argument_list|,
argument|e1
argument_list|,
argument|p_hash_elem
argument_list|,
argument|hti2
argument_list|)
if|if
condition|(
name|e0
operator|!=
name|e1
ifdef|#
directive|ifdef
name|STACK_REGS
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|stack_reg_live
argument_list|,
name|INSN_UID
argument_list|(
name|e0
operator|->
name|insn
argument_list|)
argument_list|)
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|stack_reg_live
argument_list|,
name|INSN_UID
argument_list|(
name|e1
operator|->
name|insn
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
name|match_seqs
argument_list|(
name|e0
argument_list|,
name|e1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* Free unused data.  */
name|bitmap_clear
argument_list|(
operator|&
name|stack_reg_live
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Transforms a regset to a HARD_REG_SET. Every hard register in REGS is added    to hregs. Additionally, the hard counterpart of every renumbered pseudo    register is also added.  */
end_comment

begin_function
specifier|static
name|void
name|renumbered_reg_set_to_hard_reg_set
parameter_list|(
name|HARD_REG_SET
modifier|*
name|hregs
parameter_list|,
name|regset
name|regs
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
operator|*
name|hregs
argument_list|,
name|regs
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|r
operator|<
name|max_regno
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|regs
argument_list|,
name|r
argument_list|)
operator|&&
name|reg_renumber
index|[
name|r
index|]
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|hregs
argument_list|,
name|reg_renumber
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clears the bits in REGS for all registers, which are live in the sequence    give by its last INSN and its LENGTH.  */
end_comment

begin_function
specifier|static
name|void
name|clear_regs_live_in_seq
parameter_list|(
name|HARD_REG_SET
modifier|*
name|regs
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|regset_head
name|live
decl_stmt|;
name|HARD_REG_SET
name|hlive
decl_stmt|;
name|struct
name|propagate_block_info
modifier|*
name|pbi
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize liveness propagation.  */
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|live
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
operator|&
name|live
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|bb
argument_list|,
operator|&
name|live
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Propagate until INSN if found.  */
for|for
control|(
name|x
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
name|x
operator|!=
name|insn
condition|;
control|)
name|x
operator|=
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Clear registers live after INSN.  */
name|renumbered_reg_set_to_hard_reg_set
argument_list|(
operator|&
name|hlive
argument_list|,
operator|&
name|live
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
operator|*
name|regs
argument_list|,
name|hlive
argument_list|)
expr_stmt|;
comment|/* Clear registers live in and before the sequence.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
control|)
block|{
name|rtx
name|prev
init|=
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|renumbered_reg_set_to_hard_reg_set
argument_list|(
operator|&
name|hlive
argument_list|,
operator|&
name|live
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
operator|*
name|regs
argument_list|,
name|hlive
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|x
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Free unused data.  */
name|free_propagate_block_info
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Computes the gain of turning PSEQ into a pseudo-function and its matching    sequences into pseudo-calls. Also computes and caches the number of insns to    abstract from  the matching sequences.  */
end_comment

begin_function
specifier|static
name|void
name|recompute_gain_for_pattern_seq
parameter_list|(
name|pattern_seq
name|pseq
parameter_list|)
block|{
name|matching_seq
name|mseq
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hascall
decl_stmt|;
name|HARD_REG_SET
name|linkregs
decl_stmt|;
comment|/* Initialize data.  */
name|SET_HARD_REG_SET
argument_list|(
name|linkregs
argument_list|)
expr_stmt|;
name|pseq
operator|->
name|link_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|pseq
operator|->
name|abstracted_length
operator|=
literal|0
expr_stmt|;
name|pseq
operator|->
name|gain
operator|=
operator|-
operator|(
name|seq_call_cost
operator|-
name|seq_jump_cost
operator|+
name|seq_return_cost
operator|)
expr_stmt|;
comment|/* Determine ABSTRACTED_LENGTH and COST for matching sequences of PSEQ.      ABSTRACTED_LENGTH may be less than MATCHING_LENGTH if sequences in the      same block overlap. */
for|for
control|(
name|mseq
operator|=
name|pseq
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
block|{
comment|/* Determine ABSTRACTED_LENGTH.  */
if|if
condition|(
name|mseq
operator|->
name|next_matching_seq
condition|)
name|mseq
operator|->
name|abstracted_length
operator|=
call|(
name|int
call|)
argument_list|(
name|mseq
operator|->
name|next_matching_seq
operator|->
name|idx
operator|-
name|mseq
operator|->
name|idx
argument_list|)
expr_stmt|;
else|else
name|mseq
operator|->
name|abstracted_length
operator|=
name|mseq
operator|->
name|matching_length
expr_stmt|;
if|if
condition|(
name|mseq
operator|->
name|abstracted_length
operator|>
name|mseq
operator|->
name|matching_length
condition|)
name|mseq
operator|->
name|abstracted_length
operator|=
name|mseq
operator|->
name|matching_length
expr_stmt|;
comment|/* Compute the cost of sequence.  */
name|RECOMPUTE_COST
argument_list|(
name|mseq
argument_list|)
expr_stmt|;
comment|/* If COST is big enough registers live in this matching sequence          should not be used as a link register. Also set ABSTRACTED_LENGTH          of PSEQ.  */
if|if
condition|(
name|mseq
operator|->
name|cost
operator|>
name|seq_call_cost
condition|)
block|{
name|clear_regs_live_in_seq
argument_list|(
operator|&
name|linkregs
argument_list|,
name|mseq
operator|->
name|insn
argument_list|,
name|mseq
operator|->
name|abstracted_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|mseq
operator|->
name|abstracted_length
operator|>
name|pseq
operator|->
name|abstracted_length
condition|)
name|pseq
operator|->
name|abstracted_length
operator|=
name|mseq
operator|->
name|abstracted_length
expr_stmt|;
block|}
block|}
comment|/* Modify ABSTRACTED_LENGTH of PSEQ if pattern sequence overlaps with one      of the matching sequences.  */
for|for
control|(
name|mseq
operator|=
name|pseq
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
block|{
name|x
operator|=
name|pseq
operator|->
name|insn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|pseq
operator|->
name|abstracted_length
operator|)
operator|&&
operator|(
name|x
operator|!=
name|mseq
operator|->
name|insn
operator|)
condition|;
name|i
operator|++
control|)
name|x
operator|=
name|prev_insn_in_block
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|pseq
operator|->
name|abstracted_length
operator|=
name|i
expr_stmt|;
block|}
comment|/* Compute the cost of pattern sequence.  */
name|RECOMPUTE_COST
argument_list|(
name|pseq
argument_list|)
expr_stmt|;
comment|/* No gain if COST is too small.  */
if|if
condition|(
name|pseq
operator|->
name|cost
operator|<=
name|seq_call_cost
condition|)
block|{
name|pseq
operator|->
name|gain
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Ensure that no matching sequence is longer than the pattern sequence.  */
for|for
control|(
name|mseq
operator|=
name|pseq
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
block|{
if|if
condition|(
name|mseq
operator|->
name|abstracted_length
operator|>
name|pseq
operator|->
name|abstracted_length
condition|)
block|{
name|mseq
operator|->
name|abstracted_length
operator|=
name|pseq
operator|->
name|abstracted_length
expr_stmt|;
name|RECOMPUTE_COST
argument_list|(
name|mseq
argument_list|)
expr_stmt|;
block|}
comment|/* Once the length is stabilizing the gain can be calculated.  */
if|if
condition|(
name|mseq
operator|->
name|cost
operator|>
name|seq_call_cost
condition|)
name|pseq
operator|->
name|gain
operator|+=
name|mseq
operator|->
name|cost
operator|-
name|seq_call_cost
expr_stmt|;
block|}
comment|/* No need to do further work if there is no gain.  */
if|if
condition|(
name|pseq
operator|->
name|gain
operator|<=
literal|0
condition|)
return|return;
comment|/* Should not use registers live in the pattern sequence as link register.    */
name|clear_regs_live_in_seq
argument_list|(
operator|&
name|linkregs
argument_list|,
name|pseq
operator|->
name|insn
argument_list|,
name|pseq
operator|->
name|abstracted_length
argument_list|)
expr_stmt|;
comment|/* Determine whether pattern sequence contains a call_insn.  */
name|hascall
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|pseq
operator|->
name|insn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pseq
operator|->
name|abstracted_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|hascall
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|x
operator|=
name|prev_insn_in_block
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Should not use a register as a link register if - it is a fixed      register, or - the sequence contains a call insn and the register is a      call used register, or - the register needs to be saved if used in a      function but was not used before (since saving it can invalidate already      computed frame pointer offsets), or - the register cannot be used as a      base register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
ifdef|#
directive|ifdef
name|REGNO_OK_FOR_INDIRECT_JUMP_P
operator|||
operator|(
operator|!
name|REGNO_OK_FOR_INDIRECT_JUMP_P
argument_list|(
name|i
argument_list|,
name|Pmode
argument_list|)
operator|)
else|#
directive|else
operator|||
operator|(
operator|!
name|ok_for_base_p_1
argument_list|(
name|i
argument_list|,
name|Pmode
argument_list|,
name|MEM
argument_list|,
name|SCRATCH
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|base_reg_class
argument_list|(
name|VOIDmode
argument_list|,
name|MEM
argument_list|,
name|SCRATCH
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
operator|||
operator|(
name|hascall
operator|&&
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|regs_ever_live
index|[
name|i
index|]
operator|)
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|linkregs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Find an appropriate register to be used as the link register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|linkregs
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|pseq
operator|->
name|link_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Abstraction is not possible if no link register is available, so set      gain to 0.  */
if|if
condition|(
operator|!
name|pseq
operator|->
name|link_reg
condition|)
name|pseq
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocates memory occupied by PSEQ and its matching seqs.  */
end_comment

begin_function
specifier|static
name|void
name|free_pattern_seq
parameter_list|(
name|pattern_seq
name|pseq
parameter_list|)
block|{
while|while
condition|(
name|pseq
operator|->
name|matching_seqs
condition|)
block|{
name|matching_seq
name|mseq
init|=
name|pseq
operator|->
name|matching_seqs
decl_stmt|;
name|pseq
operator|->
name|matching_seqs
operator|=
name|mseq
operator|->
name|next_matching_seq
expr_stmt|;
name|free
argument_list|(
name|mseq
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pseq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Computes the gain for pattern sequences. Pattern sequences producing no gain    are deleted. The pattern sequence with the biggest gain is moved to the first    place of PATTERN_SEQS.  */
end_comment

begin_function
specifier|static
name|void
name|recompute_gain
parameter_list|(
name|void
parameter_list|)
block|{
name|pattern_seq
modifier|*
name|pseq
decl_stmt|;
name|int
name|maxgain
decl_stmt|;
name|maxgain
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pseq
operator|=
operator|&
name|pattern_seqs
init|;
operator|*
name|pseq
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pseq
operator|)
operator|->
name|gain
operator|<=
literal|0
condition|)
name|recompute_gain_for_pattern_seq
argument_list|(
operator|*
name|pseq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pseq
operator|)
operator|->
name|gain
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pseq
operator|)
operator|->
name|gain
operator|>
name|maxgain
condition|)
block|{
name|pattern_seq
name|temp
init|=
operator|*
name|pseq
decl_stmt|;
operator|(
operator|*
name|pseq
operator|)
operator|=
name|temp
operator|->
name|next_pattern_seq
expr_stmt|;
name|temp
operator|->
name|next_pattern_seq
operator|=
name|pattern_seqs
expr_stmt|;
name|pattern_seqs
operator|=
name|temp
expr_stmt|;
name|maxgain
operator|=
name|pattern_seqs
operator|->
name|gain
expr_stmt|;
block|}
else|else
block|{
name|pseq
operator|=
operator|&
operator|(
operator|*
name|pseq
operator|)
operator|->
name|next_pattern_seq
expr_stmt|;
block|}
block|}
else|else
block|{
name|pattern_seq
name|temp
init|=
operator|*
name|pseq
decl_stmt|;
operator|*
name|pseq
operator|=
name|temp
operator|->
name|next_pattern_seq
expr_stmt|;
name|free_pattern_seq
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Updated those pattern sequences and matching sequences, which overlap with    the sequence given by INSN and LEN. Deletes sequences shrinking below a    limit.  */
end_comment

begin_function
specifier|static
name|void
name|erase_from_pattern_seqs
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|pattern_seq
modifier|*
name|pseq
decl_stmt|;
name|matching_seq
modifier|*
name|mseq
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|mlen
decl_stmt|;
name|int
name|pcost
decl_stmt|,
name|mcost
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|pseq
operator|=
operator|&
name|pattern_seqs
init|;
operator|*
name|pseq
condition|;
control|)
block|{
name|plen
operator|=
literal|0
expr_stmt|;
name|pcost
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
operator|(
operator|*
name|pseq
operator|)
operator|->
name|insn
init|;
name|x
operator|&&
operator|(
name|x
operator|!=
name|insn
operator|)
condition|;
name|x
operator|=
name|prev_insn_in_block
argument_list|(
name|x
argument_list|)
control|)
block|{
name|plen
operator|++
expr_stmt|;
name|pcost
operator|+=
name|compute_rtx_cost
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pcost
operator|<=
name|seq_call_cost
condition|)
block|{
name|pattern_seq
name|temp
init|=
operator|*
name|pseq
decl_stmt|;
operator|*
name|pseq
operator|=
name|temp
operator|->
name|next_pattern_seq
expr_stmt|;
name|free_pattern_seq
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|mseq
operator|=
operator|&
operator|(
operator|*
name|pseq
operator|)
operator|->
name|matching_seqs
init|;
operator|*
name|mseq
condition|;
control|)
block|{
name|mlen
operator|=
literal|0
expr_stmt|;
name|mcost
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
operator|(
operator|*
name|mseq
operator|)
operator|->
name|insn
init|;
name|x
operator|&&
operator|(
name|x
operator|!=
name|insn
operator|)
operator|&&
operator|(
name|mlen
operator|<
name|plen
operator|)
operator|&&
operator|(
name|mlen
operator|<
operator|(
operator|*
name|mseq
operator|)
operator|->
name|matching_length
operator|)
condition|;
name|x
operator|=
name|prev_insn_in_block
argument_list|(
name|x
argument_list|)
control|)
block|{
name|mlen
operator|++
expr_stmt|;
name|mcost
operator|+=
name|compute_rtx_cost
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcost
operator|<=
name|seq_call_cost
condition|)
block|{
name|matching_seq
name|temp
init|=
operator|*
name|mseq
decl_stmt|;
operator|*
name|mseq
operator|=
name|temp
operator|->
name|next_matching_seq
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Set to 0 to force gain recomputation.  */
operator|(
operator|*
name|pseq
operator|)
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mlen
operator|<
operator|(
operator|*
name|mseq
operator|)
operator|->
name|matching_length
condition|)
block|{
operator|(
operator|*
name|mseq
operator|)
operator|->
name|cost
operator|=
name|mcost
expr_stmt|;
operator|(
operator|*
name|mseq
operator|)
operator|->
name|matching_length
operator|=
name|mlen
expr_stmt|;
comment|/* Set to 0 to force gain recomputation.  */
operator|(
operator|*
name|pseq
operator|)
operator|->
name|gain
operator|=
literal|0
expr_stmt|;
block|}
name|mseq
operator|=
operator|&
operator|(
operator|*
name|mseq
operator|)
operator|->
name|next_matching_seq
expr_stmt|;
block|}
block|}
name|pseq
operator|=
operator|&
operator|(
operator|*
name|pseq
operator|)
operator|->
name|next_pattern_seq
expr_stmt|;
block|}
block|}
name|len
operator|--
expr_stmt|;
name|insn
operator|=
name|prev_insn_in_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Updates those pattern sequences and matching sequences, which overlap with    the pattern sequence with the biggest gain and its matching sequences.  */
end_comment

begin_function
specifier|static
name|void
name|update_pattern_seqs
parameter_list|(
name|void
parameter_list|)
block|{
name|pattern_seq
name|bestpseq
decl_stmt|;
name|matching_seq
name|mseq
decl_stmt|;
name|bestpseq
operator|=
name|pattern_seqs
expr_stmt|;
name|pattern_seqs
operator|=
name|bestpseq
operator|->
name|next_pattern_seq
expr_stmt|;
for|for
control|(
name|mseq
operator|=
name|bestpseq
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
if|if
condition|(
name|mseq
operator|->
name|cost
operator|>
name|seq_call_cost
condition|)
name|erase_from_pattern_seqs
argument_list|(
name|mseq
operator|->
name|insn
argument_list|,
name|mseq
operator|->
name|abstracted_length
argument_list|)
expr_stmt|;
name|erase_from_pattern_seqs
argument_list|(
name|bestpseq
operator|->
name|insn
argument_list|,
name|bestpseq
operator|->
name|abstracted_length
argument_list|)
expr_stmt|;
name|bestpseq
operator|->
name|next_pattern_seq
operator|=
name|pattern_seqs
expr_stmt|;
name|pattern_seqs
operator|=
name|bestpseq
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Groups together those matching sequences of the best pattern sequence, which    have the same ABSTRACTED_LENGTH and puts these groups in ascending order.    SEQ_BLOCKS contains the result.  */
end_comment

begin_function
specifier|static
name|void
name|determine_seq_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|seq_block
name|sb
decl_stmt|;
name|matching_seq
modifier|*
name|mseq
decl_stmt|;
name|matching_seq
name|m
decl_stmt|;
comment|/* Initialize SEQ_BLOCKS to empty.  */
name|seq_blocks
operator|=
literal|0
expr_stmt|;
comment|/* Process all matching sequences.  */
for|for
control|(
name|mseq
operator|=
operator|&
name|pattern_seqs
operator|->
name|matching_seqs
init|;
operator|*
name|mseq
condition|;
control|)
block|{
comment|/* Deal only with matching sequences being long enough. */
if|if
condition|(
operator|(
operator|*
name|mseq
operator|)
operator|->
name|cost
operator|<=
name|seq_call_cost
condition|)
block|{
name|mseq
operator|=
operator|&
operator|(
operator|*
name|mseq
operator|)
operator|->
name|next_matching_seq
expr_stmt|;
continue|continue;
block|}
comment|/* Ensure that SB contains a seq_block with the appropriate length.          Insert a new seq_block if necessary.  */
if|if
condition|(
operator|!
name|seq_blocks
operator|||
operator|(
operator|(
operator|*
name|mseq
operator|)
operator|->
name|abstracted_length
operator|<
name|seq_blocks
operator|->
name|length
operator|)
condition|)
block|{
name|sb
operator|=
operator|(
name|seq_block
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|seq_block_def
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|length
operator|=
operator|(
operator|*
name|mseq
operator|)
operator|->
name|abstracted_length
expr_stmt|;
name|sb
operator|->
name|label
operator|=
name|NULL_RTX
expr_stmt|;
name|sb
operator|->
name|matching_seqs
operator|=
literal|0
expr_stmt|;
name|sb
operator|->
name|next_seq_block
operator|=
name|seq_blocks
expr_stmt|;
name|seq_blocks
operator|=
name|sb
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|sb
operator|=
name|seq_blocks
init|;
name|sb
condition|;
name|sb
operator|=
name|sb
operator|->
name|next_seq_block
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|mseq
operator|)
operator|->
name|abstracted_length
operator|==
name|sb
operator|->
name|length
condition|)
break|break;
if|if
condition|(
operator|!
name|sb
operator|->
name|next_seq_block
operator|||
operator|(
operator|(
operator|*
name|mseq
operator|)
operator|->
name|abstracted_length
operator|<
name|sb
operator|->
name|next_seq_block
operator|->
name|length
operator|)
condition|)
block|{
name|seq_block
name|temp
init|=
operator|(
name|seq_block
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|seq_block_def
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|length
operator|=
operator|(
operator|*
name|mseq
operator|)
operator|->
name|abstracted_length
expr_stmt|;
name|temp
operator|->
name|label
operator|=
name|NULL_RTX
expr_stmt|;
name|temp
operator|->
name|matching_seqs
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|next_seq_block
operator|=
name|sb
operator|->
name|next_seq_block
expr_stmt|;
name|sb
operator|->
name|next_seq_block
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove the matching sequence from the linked list of the pattern          sequence and link it to SB.  */
name|m
operator|=
operator|*
name|mseq
expr_stmt|;
operator|*
name|mseq
operator|=
name|m
operator|->
name|next_matching_seq
expr_stmt|;
name|m
operator|->
name|next_matching_seq
operator|=
name|sb
operator|->
name|matching_seqs
expr_stmt|;
name|sb
operator|->
name|matching_seqs
operator|=
name|m
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Builds a symbol_ref for LABEL.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_symbol_ref_rtx_for_label
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|rtx
name|sym
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* Ensures that INSN is the last insn in its block and returns the block label    of the next block.  */
end_comment

begin_function
specifier|static
name|rtx
name|block_label_after
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|)
operator|&&
operator|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
operator|)
condition|)
return|return
name|block_label
argument_list|(
name|bb
operator|->
name|next_bb
argument_list|)
return|;
else|else
return|return
name|block_label
argument_list|(
name|split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
operator|->
name|dest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ensures that the last insns of the best pattern and its matching sequences    are the last insns in their block. Additionally, extends the live set at the    end of the pattern sequence with the live sets at the end of the matching    sequences.  */
end_comment

begin_function
specifier|static
name|void
name|split_blocks_after_seqs
parameter_list|(
name|void
parameter_list|)
block|{
name|seq_block
name|sb
decl_stmt|;
name|matching_seq
name|mseq
decl_stmt|;
name|block_label_after
argument_list|(
name|pattern_seqs
operator|->
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|sb
operator|=
name|seq_blocks
init|;
name|sb
condition|;
name|sb
operator|=
name|sb
operator|->
name|next_seq_block
control|)
block|{
for|for
control|(
name|mseq
operator|=
name|sb
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
block|{
name|block_label_after
argument_list|(
name|mseq
operator|->
name|insn
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|pattern_seqs
operator|->
name|insn
argument_list|)
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|mseq
operator|->
name|insn
argument_list|)
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Splits the best pattern sequence according to SEQ_BLOCKS. Emits pseudo-call    and -return insns before and after the sequence.  */
end_comment

begin_function
specifier|static
name|void
name|split_pattern_seq
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|retlabel
decl_stmt|,
name|retjmp
decl_stmt|,
name|saveinsn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|seq_block
name|sb
decl_stmt|;
name|insn
operator|=
name|pattern_seqs
operator|->
name|insn
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Get the label after the sequence. This will be the return address. The      label will be referenced using a symbol_ref so protect it from      deleting.  */
name|retlabel
operator|=
name|block_label_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|retlabel
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Emit an indirect jump via the link register after the sequence acting      as the return insn.  Also emit a barrier and update the basic block.  */
name|retjmp
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_indirect_jump
argument_list|(
name|pattern_seqs
operator|->
name|link_reg
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace all outgoing edges with a new one to the block of RETLABEL.  */
while|while
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|!=
literal|0
condition|)
name|remove_edge
argument_list|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|bb
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|retlabel
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
argument_list|)
expr_stmt|;
comment|/* Split the sequence according to SEQ_BLOCKS and cache the label of the      resulting basic blocks.  */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sb
operator|=
name|seq_blocks
init|;
name|sb
condition|;
name|sb
operator|=
name|sb
operator|->
name|next_seq_block
control|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|sb
operator|->
name|length
condition|;
name|i
operator|++
control|)
name|insn
operator|=
name|prev_insn_in_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|sb
operator|->
name|label
operator|=
name|block_label
argument_list|(
name|split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/* Emit an insn saving the return address to the link register before the      sequence.  */
name|saveinsn
operator|=
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|pattern_seqs
operator|->
name|link_reg
argument_list|,
name|gen_symbol_ref_rtx_for_label
argument_list|(
name|retlabel
argument_list|)
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update liveness info.  */
name|SET_REGNO_REG_SET
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|REGNO
argument_list|(
name|pattern_seqs
operator|->
name|link_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deletes the insns of the matching sequences of the best pattern sequence and    replaces them with pseudo-calls to the pattern sequence.  */
end_comment

begin_function
specifier|static
name|void
name|erase_matching_seqs
parameter_list|(
name|void
parameter_list|)
block|{
name|seq_block
name|sb
decl_stmt|;
name|matching_seq
name|mseq
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|retlabel
decl_stmt|,
name|saveinsn
decl_stmt|,
name|callinsn
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|sb
operator|=
name|seq_blocks
init|;
name|sb
condition|;
name|sb
operator|=
name|sb
operator|->
name|next_seq_block
control|)
block|{
for|for
control|(
name|mseq
operator|=
name|sb
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
block|{
name|insn
operator|=
name|mseq
operator|->
name|insn
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Get the label after the sequence. This will be the return              address. The label will be referenced using a symbol_ref so              protect it from deleting.  */
name|retlabel
operator|=
name|block_label_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|retlabel
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Delete the insns of the sequence.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|->
name|length
condition|;
name|i
operator|++
control|)
name|insn
operator|=
name|prev_insn_in_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_basic_block
argument_list|(
name|split_block
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|)
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* Emit an insn saving the return address to the link register              before the deleted sequence.  */
name|saveinsn
operator|=
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|pattern_seqs
operator|->
name|link_reg
argument_list|,
name|gen_symbol_ref_rtx_for_label
argument_list|(
name|retlabel
argument_list|)
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|saveinsn
argument_list|)
operator|=
name|bb
expr_stmt|;
comment|/* Emit a jump to the appropriate part of the pattern sequence              after the save insn. Also update the basic block.  */
name|callinsn
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|sb
operator|->
name|label
argument_list|)
argument_list|,
name|saveinsn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|callinsn
argument_list|)
operator|=
name|sb
operator|->
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|sb
operator|->
name|label
argument_list|)
operator|++
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|callinsn
argument_list|)
operator|=
name|bb
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|callinsn
expr_stmt|;
comment|/* Maintain control flow and liveness information.  */
name|SET_REGNO_REG_SET
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|REGNO
argument_list|(
name|pattern_seqs
operator|->
name|link_reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|sb
operator|->
name|label
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|sb
operator|->
name|label
argument_list|)
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|make_edge
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|seq_blocks
operator|->
name|label
argument_list|)
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|retlabel
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Deallocates SEQ_BLOCKS and all the matching sequences.  */
end_comment

begin_function
specifier|static
name|void
name|free_seq_blocks
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|seq_blocks
condition|)
block|{
name|seq_block
name|sb
init|=
name|seq_blocks
decl_stmt|;
while|while
condition|(
name|sb
operator|->
name|matching_seqs
condition|)
block|{
name|matching_seq
name|mseq
init|=
name|sb
operator|->
name|matching_seqs
decl_stmt|;
name|sb
operator|->
name|matching_seqs
operator|=
name|mseq
operator|->
name|next_matching_seq
expr_stmt|;
name|free
argument_list|(
name|mseq
argument_list|)
expr_stmt|;
block|}
name|seq_blocks
operator|=
name|sb
operator|->
name|next_seq_block
expr_stmt|;
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Transforms the best pattern sequence into a pseudo-function and its matching    sequences to pseudo-calls. Afterwards the best pattern sequence is removed    from PATTERN_SEQS.  */
end_comment

begin_function
specifier|static
name|void
name|abstract_best_seq
parameter_list|(
name|void
parameter_list|)
block|{
name|pattern_seq
name|bestpseq
decl_stmt|;
comment|/* Do the abstraction.  */
name|determine_seq_blocks
argument_list|()
expr_stmt|;
name|split_blocks_after_seqs
argument_list|()
expr_stmt|;
name|split_pattern_seq
argument_list|()
expr_stmt|;
name|erase_matching_seqs
argument_list|()
expr_stmt|;
name|free_seq_blocks
argument_list|()
expr_stmt|;
comment|/* Record the usage of the link register.  */
name|regs_ever_live
index|[
name|REGNO
argument_list|(
name|pattern_seqs
operator|->
name|link_reg
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Remove the best pattern sequence.  */
name|bestpseq
operator|=
name|pattern_seqs
expr_stmt|;
name|pattern_seqs
operator|=
name|bestpseq
operator|->
name|next_pattern_seq
expr_stmt|;
name|free_pattern_seq
argument_list|(
name|bestpseq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints info on the pattern sequences to the dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_pattern_seqs
parameter_list|(
name|void
parameter_list|)
block|{
name|pattern_seq
name|pseq
decl_stmt|;
name|matching_seq
name|mseq
decl_stmt|;
if|if
condition|(
operator|!
name|dump_file
condition|)
return|return;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Pattern sequences\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|pseq
operator|=
name|pattern_seqs
init|;
name|pseq
condition|;
name|pseq
operator|=
name|pseq
operator|->
name|next_pattern_seq
control|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Pattern sequence at insn %d matches sequences at"
argument_list|,
name|INSN_UID
argument_list|(
name|pseq
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mseq
operator|=
name|pseq
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" insn %d (length %d)"
argument_list|,
name|INSN_UID
argument_list|(
name|mseq
operator|->
name|insn
argument_list|)
argument_list|,
name|mseq
operator|->
name|matching_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|mseq
operator|->
name|next_matching_seq
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints info on the best pattern sequence transformed in the ITER-th    iteration to the dump file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_best_pattern_seq
parameter_list|(
name|int
name|iter
parameter_list|)
block|{
name|matching_seq
name|mseq
decl_stmt|;
if|if
condition|(
operator|!
name|dump_file
condition|)
return|return;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Iteration %d\n"
argument_list|,
name|iter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Best pattern sequence with %d gain is at insn %d (length %d).\n"
argument_list|,
name|pattern_seqs
operator|->
name|gain
argument_list|,
name|INSN_UID
argument_list|(
name|pattern_seqs
operator|->
name|insn
argument_list|)
argument_list|,
name|pattern_seqs
operator|->
name|abstracted_length
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Matching sequences are at"
argument_list|)
expr_stmt|;
for|for
control|(
name|mseq
operator|=
name|pattern_seqs
operator|->
name|matching_seqs
init|;
name|mseq
condition|;
name|mseq
operator|=
name|mseq
operator|->
name|next_matching_seq
control|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" insn %d (length %d)"
argument_list|,
name|INSN_UID
argument_list|(
name|mseq
operator|->
name|insn
argument_list|)
argument_list|,
name|mseq
operator|->
name|abstracted_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|mseq
operator|->
name|next_matching_seq
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Using reg %d as link register.\n\n"
argument_list|,
name|REGNO
argument_list|(
name|pattern_seqs
operator|->
name|link_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Htab hash function for hash_bucket_def structure.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|htab_hash_bucket
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|p_hash_bucket
name|bucket
init|=
operator|(
name|p_hash_bucket
operator|)
name|p
decl_stmt|;
return|return
name|bucket
operator|->
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Htab equal function for hash_bucket_def structure.  */
end_comment

begin_function
specifier|static
name|int
name|htab_eq_bucket
parameter_list|(
specifier|const
name|void
modifier|*
name|p0
parameter_list|,
specifier|const
name|void
modifier|*
name|p1
parameter_list|)
block|{
return|return
name|htab_hash_bucket
argument_list|(
name|p0
argument_list|)
operator|==
name|htab_hash_bucket
argument_list|(
name|p1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Htab delete function for hash_bucket_def structure.  */
end_comment

begin_function
specifier|static
name|void
name|htab_del_bucket
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|p_hash_bucket
name|bucket
init|=
operator|(
name|p_hash_bucket
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|bucket
operator|->
name|seq_candidates
condition|)
name|htab_delete
argument_list|(
name|bucket
operator|->
name|seq_candidates
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Htab hash function for hash_bucket_def structure.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|htab_hash_elem
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|p_hash_elem
name|elem
init|=
operator|(
name|p_hash_elem
operator|)
name|p
decl_stmt|;
return|return
name|htab_hash_pointer
argument_list|(
name|elem
operator|->
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Htab equal function for hash_bucket_def structure.  */
end_comment

begin_function
specifier|static
name|int
name|htab_eq_elem
parameter_list|(
specifier|const
name|void
modifier|*
name|p0
parameter_list|,
specifier|const
name|void
modifier|*
name|p1
parameter_list|)
block|{
return|return
name|htab_hash_elem
argument_list|(
name|p0
argument_list|)
operator|==
name|htab_hash_elem
argument_list|(
name|p1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Htab delete function for hash_bucket_def structure.  */
end_comment

begin_function
specifier|static
name|void
name|htab_del_elem
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|p_hash_elem
name|elem
init|=
operator|(
name|p_hash_elem
operator|)
name|p
decl_stmt|;
name|free
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates a hash value for each sequence candidate and saves them    in HASH_BUCKET.  */
end_comment

begin_function
specifier|static
name|void
name|fill_hash_bucket
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|p_hash_bucket
name|bucket
decl_stmt|;
name|struct
name|hash_bucket_def
name|tmp_bucket
decl_stmt|;
name|p_hash_elem
name|elem
decl_stmt|;
name|unsigned
name|long
name|insn_idx
decl_stmt|;
name|insn_idx
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
operator|!
name|ABSTRACTABLE_INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Compute hash value for INSN.  */
name|tmp_bucket
operator|.
name|hash
operator|=
name|compute_hash
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Select the hash group.  */
name|bucket
operator|=
name|htab_find
argument_list|(
name|hash_buckets
argument_list|,
operator|&
name|tmp_bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bucket
condition|)
block|{
comment|/* Create a new hash group.  */
name|bucket
operator|=
operator|(
name|p_hash_bucket
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hash_bucket_def
argument_list|)
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|hash
operator|=
name|tmp_bucket
operator|.
name|hash
expr_stmt|;
name|bucket
operator|->
name|seq_candidates
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|hash_buckets
argument_list|,
operator|&
name|tmp_bucket
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|bucket
expr_stmt|;
block|}
comment|/* Create new list for storing sequence candidates.  */
if|if
condition|(
operator|!
name|bucket
operator|->
name|seq_candidates
condition|)
name|bucket
operator|->
name|seq_candidates
operator|=
name|htab_create
argument_list|(
name|HASH_INIT
argument_list|,
name|htab_hash_elem
argument_list|,
name|htab_eq_elem
argument_list|,
name|htab_del_elem
argument_list|)
expr_stmt|;
name|elem
operator|=
operator|(
name|p_hash_elem
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hash_elem_def
argument_list|)
argument_list|)
expr_stmt|;
name|elem
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|elem
operator|->
name|idx
operator|=
name|insn_idx
expr_stmt|;
name|elem
operator|->
name|length
operator|=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Insert INSN into BUCKET hash bucket.  */
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|bucket
operator|->
name|seq_candidates
argument_list|,
name|elem
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|elem
expr_stmt|;
name|insn_idx
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Computes the cost of calling sequence and the cost of return.  */
end_comment

begin_function
specifier|static
name|void
name|compute_init_costs
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|rtx_jump
decl_stmt|,
name|rtx_store
decl_stmt|,
name|rtx_return
decl_stmt|,
name|reg
decl_stmt|,
name|label
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|label
operator|=
name|block_label
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pattern for indirect jump.  */
name|rtx_jump
operator|=
name|gen_indirect_jump
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Pattern for storing address.  */
name|rtx_store
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_symbol_ref_rtx_for_label
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pattern for return insn.  */
name|rtx_return
operator|=
name|gen_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* The cost of jump.  */
name|seq_jump_cost
operator|=
name|compute_rtx_cost
argument_list|(
name|make_jump_insn_raw
argument_list|(
name|rtx_jump
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The cost of calling sequence.  */
name|seq_call_cost
operator|=
name|seq_jump_cost
operator|+
name|compute_rtx_cost
argument_list|(
name|make_insn_raw
argument_list|(
name|rtx_store
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The cost of return.  */
name|seq_return_cost
operator|=
name|compute_rtx_cost
argument_list|(
name|make_jump_insn_raw
argument_list|(
name|rtx_return
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simple heuristic for minimal sequence cost.  */
name|seq_call_cost
operator|=
call|(
name|int
call|)
argument_list|(
name|seq_call_cost
operator|*
operator|(
name|double
operator|)
name|SEQ_CALL_COST_MULTIPLIER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds equivalent insn sequences in the current function and retains only one    instance of them which is turned into a pseudo-function. The additional    copies are erased and replaced by pseudo-calls to the retained sequence.  */
end_comment

begin_function
specifier|static
name|void
name|rtl_seqabstr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|iter
decl_stmt|;
comment|/* Create a hash list for COLLECT_PATTERN_SEQS.  */
name|hash_buckets
operator|=
name|htab_create
argument_list|(
name|HASH_INIT
argument_list|,
name|htab_hash_bucket
argument_list|,
name|htab_eq_bucket
argument_list|,
name|htab_del_bucket
argument_list|)
expr_stmt|;
name|fill_hash_bucket
argument_list|()
expr_stmt|;
comment|/* Compute the common cost of abstraction.  */
name|compute_init_costs
argument_list|()
expr_stmt|;
comment|/* Build an initial set of pattern sequences from the current function.  */
name|collect_pattern_seqs
argument_list|()
expr_stmt|;
name|dump_pattern_seqs
argument_list|()
expr_stmt|;
comment|/* Iterate until there are no sequences to abstract.  */
for|for
control|(
name|iter
operator|=
literal|1
init|;
condition|;
name|iter
operator|++
control|)
block|{
comment|/* Recompute gain for sequences if necessary and select sequence with          biggest gain.  */
name|recompute_gain
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pattern_seqs
condition|)
break|break;
name|dump_best_pattern_seq
argument_list|(
name|iter
argument_list|)
expr_stmt|;
comment|/* Update the cached info of the other sequences and force gain          recomputation where needed.  */
name|update_pattern_seqs
argument_list|()
expr_stmt|;
comment|/* Turn best sequences into pseudo-functions and -calls.  */
name|abstract_best_seq
argument_list|()
expr_stmt|;
block|}
comment|/* Cleanup hash tables.  */
name|htab_delete
argument_list|(
name|hash_buckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|>
literal|1
condition|)
block|{
comment|/* Update notes.  */
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|life_analysis
argument_list|(
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
comment|/* Extra cleanup.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
operator||
operator|(
name|flag_crossjumping
condition|?
name|CLEANUP_CROSSJUMP
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The gate function for TREE_OPT_PASS.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_rtl_seqabstr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_rtl_seqabstr
return|;
block|}
end_function

begin_comment
comment|/* The entry point of the sequence abstraction algorithm.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_rtl_seqabstr
parameter_list|(
name|void
parameter_list|)
block|{
name|life_analysis
argument_list|(
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
operator||
name|CLEANUP_UPDATE_LIFE
operator||
operator|(
name|flag_crossjumping
condition|?
name|CLEANUP_CROSSJUMP
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Abstract out common insn sequences. */
name|rtl_seqabstr
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_rtl_seqabstr
init|=
block|{
literal|"seqabstr"
block|,
comment|/* name */
name|gate_rtl_seqabstr
block|,
comment|/* gate */
name|rest_of_rtl_seqabstr
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_SEQABSTR
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'Q'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

