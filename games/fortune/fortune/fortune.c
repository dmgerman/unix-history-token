begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1986, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ken Arnold.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static const char copyright[] = "@(#) Copyright (c) 1986, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static const char sccsid[] = "@(#)fortune.c   8.1 (Berkeley) 5/31/93";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"strfile.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|bool
value|short
end_define

begin_define
define|#
directive|define
name|MINW
value|6
end_define

begin_comment
comment|/* minimum wait if desired */
end_comment

begin_define
define|#
directive|define
name|CPERS
value|20
end_define

begin_comment
comment|/* # of chars for each sec */
end_comment

begin_define
define|#
directive|define
name|SLEN
value|160
end_define

begin_comment
comment|/* # of chars in short fortune */
end_comment

begin_define
define|#
directive|define
name|POS_UNKNOWN
value|((uint32_t) -1)
end_define

begin_comment
comment|/* pos for file unknown */
end_comment

begin_define
define|#
directive|define
name|NO_PROB
value|(-1)
end_define

begin_comment
comment|/* no prob specified for file */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
value|{ if (Debug>= l) fprintf x; }
end_define

begin_undef
undef|#
directive|undef
name|NDEBUG
end_undef

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|NDEBUG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|fd
block|{
name|int
name|percent
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|datfd
decl_stmt|;
name|uint32_t
name|pos
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|datfile
decl_stmt|,
modifier|*
name|posfile
decl_stmt|;
name|bool
name|read_tbl
decl_stmt|;
name|bool
name|was_pos_file
decl_stmt|;
name|STRFILE
name|tbl
decl_stmt|;
name|int
name|num_children
decl_stmt|;
name|struct
name|fd
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|fd
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|FILEDESC
typedef|;
end_typedef

begin_decl_stmt
name|bool
name|Found_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* did we find a match? */
end_comment

begin_decl_stmt
name|bool
name|Find_files
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just find a list of proper fortune files */
end_comment

begin_decl_stmt
name|bool
name|Fortunes_only
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check only "fortunes" files */
end_comment

begin_decl_stmt
name|bool
name|Wait
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait desired after fortune */
end_comment

begin_decl_stmt
name|bool
name|Short_only
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* short fortune desired */
end_comment

begin_decl_stmt
name|bool
name|Long_only
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* long fortune desired */
end_comment

begin_decl_stmt
name|bool
name|Offend
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offensive fortunes only */
end_comment

begin_decl_stmt
name|bool
name|All_forts
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* any fortune allowed */
end_comment

begin_decl_stmt
name|bool
name|Equal_probs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scatter un-allocted prob equally */
end_comment

begin_decl_stmt
name|bool
name|Match
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dump fortunes matching a pattern */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|bool
name|Debug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print debug messages */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|Fortbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fortune buffer for -m */
end_comment

begin_decl_stmt
name|int
name|Fort_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|Seekpts
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seek pointers to fortunes */
end_comment

begin_decl_stmt
name|FILEDESC
modifier|*
name|File_list
init|=
name|NULL
decl_stmt|,
comment|/* Head of file list */
modifier|*
name|File_tail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tail of file list */
end_comment

begin_decl_stmt
name|FILEDESC
modifier|*
name|Fortfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fortune file to use */
end_comment

begin_decl_stmt
name|STRFILE
name|Noprob_tbl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sum of data for all no prob files */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|Fortune_path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Fortune_path_arr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|add_dir
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|add_file
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|FILEDESC
modifier|*
modifier|*
parameter_list|,
name|FILEDESC
modifier|*
modifier|*
parameter_list|,
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|all_forts
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|copy
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|display
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_free
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|do_malloc
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|form_file_list
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|fortlen
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_fort
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_pos
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_tbl
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getargs
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getpath
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_prob
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|is_dir
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|is_fortfile
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|is_off_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|max
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FILEDESC
modifier|*
name|new_fp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|off_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|open_dat
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|open_fp
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FILEDESC
modifier|*
name|pick_child
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_file_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_list
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sum_noprobs
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sum_tbl
parameter_list|(
name|STRFILE
modifier|*
parameter_list|,
name|STRFILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|zero_tbl
parameter_list|(
name|STRFILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|conv_pat
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|find_matches
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|matches_in_list
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|maxlen_in_list
parameter_list|(
name|FILEDESC
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|regex_t
name|Re_pat
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OK_TO_WRITE_DISK
name|int
name|fd
decl_stmt|;
endif|#
directive|endif
comment|/* OK_TO_WRITE_DISK */
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|getpath
argument_list|()
expr_stmt|;
name|getargs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|Match
condition|)
name|exit
argument_list|(
name|find_matches
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|init_prob
argument_list|()
expr_stmt|;
do|do
block|{
name|get_fort
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|Short_only
operator|&&
name|fortlen
argument_list|()
operator|>
name|SLEN
operator|)
operator|||
operator|(
name|Long_only
operator|&&
name|fortlen
argument_list|()
operator|<=
name|SLEN
operator|)
condition|)
do|;
name|display
argument_list|(
name|Fortfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OK_TO_WRITE_DISK
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|Fortfile
operator|->
name|posfile
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|Fortfile
operator|->
name|posfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOCK_EX
comment|/* 	 * if we can, we exclusive lock, but since it isn't very 	 * important, we just punt if we don't have easy locking 	 * available. 	 */
operator|(
name|void
operator|)
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCK_EX */
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|Fortfile
operator|->
name|pos
argument_list|,
sizeof|sizeof
name|Fortfile
operator|->
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fortfile
operator|->
name|was_pos_file
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|Fortfile
operator|->
name|path
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCK_EX
operator|(
name|void
operator|)
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_UN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCK_EX */
endif|#
directive|endif
comment|/* OK_TO_WRITE_DISK */
if|if
condition|(
name|Wait
condition|)
block|{
if|if
condition|(
name|Fort_len
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fortlen
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|max
argument_list|(
name|Fort_len
operator|/
name|CPERS
argument_list|,
name|MINW
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|open_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fseeko
argument_list|(
name|fp
operator|->
name|inf
argument_list|,
name|Seekpts
index|[
literal|0
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|Fort_len
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|fp
operator|->
name|inf
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|STR_ENDSTRING
argument_list|(
name|line
argument_list|,
name|fp
operator|->
name|tbl
argument_list|)
condition|;
name|Fort_len
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|tbl
operator|.
name|str_flags
operator|&
name|STR_ROTATED
condition|)
for|for
control|(
name|p
operator|=
name|line
init|;
operator|(
name|ch
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'A'
operator|+
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|13
operator|)
operator|%
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'a'
operator|+
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|13
operator|)
operator|%
literal|26
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|tbl
operator|.
name|str_flags
operator|&
name|STR_COMMENTS
operator|&&
name|line
index|[
literal|0
index|]
operator|==
name|fp
operator|->
name|tbl
operator|.
name|str_delim
operator|&&
name|line
index|[
literal|1
index|]
operator|==
name|fp
operator|->
name|tbl
operator|.
name|str_delim
condition|)
continue|continue;
name|fputs
argument_list|(
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * fortlen:  *	Return the length of the fortune.  */
end_comment

begin_function
name|int
name|fortlen
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nchar
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Fortfile
operator|->
name|tbl
operator|.
name|str_flags
operator|&
operator|(
name|STR_RANDOM
operator||
name|STR_ORDERED
operator|)
operator|)
condition|)
name|nchar
operator|=
call|(
name|int
call|)
argument_list|(
name|Seekpts
index|[
literal|1
index|]
operator|-
name|Seekpts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|open_fp
argument_list|(
name|Fortfile
argument_list|)
expr_stmt|;
name|fseeko
argument_list|(
name|Fortfile
operator|->
name|inf
argument_list|,
name|Seekpts
index|[
literal|0
index|]
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|nchar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|Fortfile
operator|->
name|inf
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|STR_ENDSTRING
argument_list|(
name|line
argument_list|,
name|Fortfile
operator|->
name|tbl
argument_list|)
condition|)
name|nchar
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|Fort_len
operator|=
name|nchar
expr_stmt|;
return|return
operator|(
name|nchar
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	This routine evaluates the arguments on the command line  */
end_comment

begin_function
name|void
name|getargs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ignore_case
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|ignore_case
operator|=
name|FALSE
expr_stmt|;
name|pat
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aDefilm:osw"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aefilm:osw"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
endif|#
directive|endif
comment|/* DEBUG */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* any fortune */
name|All_forts
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|Debug
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEBUG */
case|case
literal|'e'
case|:
name|Equal_probs
operator|++
expr_stmt|;
comment|/* scatter un-allocted prob equally */
break|break;
case|case
literal|'f'
case|:
comment|/* find fortune files */
name|Find_files
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* long ones only */
name|Long_only
operator|++
expr_stmt|;
name|Short_only
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* offensive ones only */
name|Offend
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* short ones only */
name|Short_only
operator|++
expr_stmt|;
name|Long_only
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* give time to read */
name|Wait
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* dump out the fortunes */
name|Match
operator|++
expr_stmt|;
name|pat
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* case-insensitive match */
name|ignore_case
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
name|form_file_list
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* errors printed through form_file_list() */
if|if
condition|(
name|Find_files
condition|)
block|{
name|print_file_list
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|Debug
operator|>=
literal|1
condition|)
name|print_file_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|pat
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ignore_case
condition|)
name|pat
operator|=
name|conv_pat
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|error
operator|=
name|regcomp
argument_list|(
operator|&
name|Re_pat
argument_list|,
name|pat
argument_list|,
name|REG_BASIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regcomp(%s) fails\n"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * form_file_list:  *	Form the file list from the file specifications.  */
end_comment

begin_function
name|int
name|form_file_list
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|,
name|int
name|file_cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|percent
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
if|if
condition|(
name|file_cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Find_files
condition|)
block|{
name|Fortunes_only
operator|=
name|TRUE
expr_stmt|;
name|pstr
operator|=
name|Fortune_path_arr
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pstr
condition|)
block|{
name|i
operator|+=
name|add_file
argument_list|(
name|NO_PROB
argument_list|,
operator|*
name|pstr
operator|++
argument_list|,
name|NULL
argument_list|,
operator|&
name|File_list
argument_list|,
operator|&
name|File_tail
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Fortunes_only
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No fortunes found in %s.\n"
argument_list|,
name|Fortune_path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|!=
literal|0
operator|)
return|;
block|}
else|else
block|{
name|pstr
operator|=
name|Fortune_path_arr
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pstr
condition|)
block|{
name|i
operator|+=
name|add_file
argument_list|(
name|NO_PROB
argument_list|,
literal|"fortunes"
argument_list|,
operator|*
name|pstr
operator|++
argument_list|,
operator|&
name|File_list
argument_list|,
operator|&
name|File_tail
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No fortunes found in %s.\n"
argument_list|,
name|Fortune_path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|!=
literal|0
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_cnt
condition|;
name|i
operator|++
control|)
block|{
name|percent
operator|=
name|NO_PROB
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|files
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|sp
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|percent
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|files
index|[
name|i
index|]
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|sp
argument_list|)
condition|;
name|sp
operator|++
control|)
name|percent
operator|=
name|percent
operator|*
literal|10
operator|+
operator|*
name|sp
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|percent
operator|>
literal|100
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"percentages must be<= 100\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'.'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"percentages must be integers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 			 * If the number isn't followed by a '%', then 			 * it was not a percentage, just the first part 			 * of a file name which starts with digits. 			 */
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'%'
condition|)
block|{
name|percent
operator|=
name|NO_PROB
expr_stmt|;
name|sp
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|file_cnt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"percentages must precede files\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|sp
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sp
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pstr
operator|=
name|Fortune_path_arr
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pstr
condition|)
block|{
name|i
operator|+=
name|add_file
argument_list|(
name|NO_PROB
argument_list|,
operator|*
name|pstr
operator|++
argument_list|,
name|NULL
argument_list|,
operator|&
name|File_list
argument_list|,
operator|&
name|File_tail
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No fortunes found in %s.\n"
argument_list|,
name|Fortune_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|add_file
argument_list|(
name|percent
argument_list|,
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|File_list
argument_list|,
operator|&
name|File_tail
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add_file:  *	Add a file to the file list.  */
end_comment

begin_function
name|int
name|add_file
parameter_list|(
name|int
name|percent
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|FILEDESC
modifier|*
modifier|*
name|head
parameter_list|,
name|FILEDESC
modifier|*
modifier|*
name|tail
parameter_list|,
name|FILEDESC
modifier|*
name|parent
parameter_list|)
block|{
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|tpath
decl_stmt|,
modifier|*
name|offensive
decl_stmt|;
name|bool
name|was_malloc
decl_stmt|;
name|bool
name|isdir
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|file
expr_stmt|;
name|tpath
operator|=
name|NULL
expr_stmt|;
name|was_malloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|tpath
operator|=
name|do_malloc
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|tpath
argument_list|,
name|dir
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|path
operator|=
name|tpath
expr_stmt|;
name|was_malloc
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|isdir
operator|=
name|is_dir
argument_list|(
name|path
argument_list|)
operator|)
operator|&&
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|tpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* don't recurse */
block|}
name|offensive
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
operator|&&
name|parent
operator|==
name|NULL
operator|&&
operator|(
name|All_forts
operator|||
name|Offend
operator|)
operator|&&
operator|!
name|is_off_name
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|offensive
operator|=
name|off_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|Offend
condition|)
block|{
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|tpath
argument_list|)
expr_stmt|;
name|path
operator|=
name|offensive
expr_stmt|;
name|offensive
operator|=
name|NULL
expr_stmt|;
name|was_malloc
operator|=
name|TRUE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"\ttrying \"%s\"\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|off_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"adding file \"%s\"\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|over
label|:
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * This is a sneak.  If the user said -a, and if the 		 * file we're given isn't a file, we check to see if 		 * there is a -o version.  If there is, we treat it as 		 * if *that* were the file given.  We only do this for 		 * individual files -- if we're scanning a directory, 		 * we'll pick up the -o file anyway. 		 */
if|if
condition|(
name|All_forts
operator|&&
name|offensive
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|tpath
argument_list|)
expr_stmt|;
name|path
operator|=
name|offensive
expr_stmt|;
name|offensive
operator|=
name|NULL
expr_stmt|;
name|was_malloc
operator|=
name|TRUE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"\ttrying \"%s\"\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|off_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
goto|goto
name|over
goto|;
block|}
if|if
condition|(
name|dir
operator|==
name|NULL
operator|&&
name|file
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|pstr
init|=
name|Fortune_path_arr
decl_stmt|;
while|while
condition|(
operator|*
name|pstr
condition|)
block|{
name|i
operator|+=
name|add_file
argument_list|(
name|percent
argument_list|,
name|file
argument_list|,
operator|*
name|pstr
operator|++
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No '%s' found in %s.\n"
argument_list|,
name|file
argument_list|,
name|Fortune_path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|!=
literal|0
operator|)
return|;
block|}
comment|/* 		if (parent == NULL) 			perror(path); 		*/
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|tpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"path = \"%s\"\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|new_fp
argument_list|()
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|percent
operator|=
name|percent
expr_stmt|;
name|fp
operator|->
name|name
operator|=
name|file
expr_stmt|;
name|fp
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|fp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
operator|(
name|isdir
operator|&&
operator|!
name|add_dir
argument_list|(
name|fp
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|isdir
operator|&&
operator|!
name|is_fortfile
argument_list|(
name|path
argument_list|,
operator|&
name|fp
operator|->
name|datfile
argument_list|,
operator|&
name|fp
operator|->
name|posfile
argument_list|,
operator|(
name|parent
operator|!=
name|NULL
operator|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:%s not a fortune file or directory\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|tpath
argument_list|)
expr_stmt|;
name|do_free
argument_list|(
name|fp
operator|->
name|datfile
argument_list|)
expr_stmt|;
name|do_free
argument_list|(
name|fp
operator|->
name|posfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|do_free
argument_list|(
name|offensive
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * If the user said -a, we need to make this node a pointer to 	 * both files, if there are two.  We don't need to do this if 	 * we are scanning a directory, since the scan will pick up the 	 * -o file anyway. 	 */
if|if
condition|(
name|All_forts
operator|&&
name|parent
operator|==
name|NULL
operator|&&
operator|!
name|is_off_name
argument_list|(
name|path
argument_list|)
condition|)
name|all_forts
argument_list|(
name|fp
argument_list|,
name|offensive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|head
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
operator|*
name|tail
operator|=
name|fp
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
block|{
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|prev
operator|=
operator|*
name|tail
expr_stmt|;
operator|*
name|tail
operator|=
name|fp
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|fp
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OK_TO_WRITE_DISK
name|fp
operator|->
name|was_pos_file
operator|=
operator|(
name|access
argument_list|(
name|fp
operator|->
name|posfile
argument_list|,
name|W_OK
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* OK_TO_WRITE_DISK */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * new_fp:  *	Return a pointer to an initialized new FILEDESC.  */
end_comment

begin_function
name|FILEDESC
modifier|*
name|new_fp
parameter_list|(
name|void
parameter_list|)
block|{
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|do_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|datfd
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|pos
operator|=
name|POS_UNKNOWN
expr_stmt|;
name|fp
operator|->
name|inf
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|percent
operator|=
name|NO_PROB
expr_stmt|;
name|fp
operator|->
name|read_tbl
operator|=
name|FALSE
expr_stmt|;
name|fp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|datfile
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|posfile
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * off_name:  *	Return a pointer to the offensive version of a file of this name.  */
end_comment

begin_function
name|char
modifier|*
name|off_name
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|copy
argument_list|(
name|file
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcat
argument_list|(
name|new
argument_list|,
literal|"-o"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * is_off_name:  *	Is the file an offensive-style name?  */
end_comment

begin_function
name|int
name|is_off_name
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|>=
literal|3
operator|&&
name|file
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'-'
operator|&&
name|file
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * all_forts:  *	Modify a FILEDESC element to be the parent of two children if  *	there are two children to be a parent of.  */
end_comment

begin_function
name|void
name|all_forts
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|offensive
parameter_list|)
block|{
name|char
modifier|*
name|sp
decl_stmt|;
name|FILEDESC
modifier|*
name|scene
decl_stmt|,
modifier|*
name|obscene
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|datfile
decl_stmt|,
modifier|*
name|posfile
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
comment|/* this is a directory, not a file */
return|return;
if|if
condition|(
operator|!
name|is_fortfile
argument_list|(
name|offensive
argument_list|,
operator|&
name|datfile
argument_list|,
operator|&
name|posfile
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|offensive
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"adding \"%s\" because of -a\n"
operator|,
name|offensive
operator|)
argument_list|)
expr_stmt|;
name|scene
operator|=
name|new_fp
argument_list|()
expr_stmt|;
name|obscene
operator|=
name|new_fp
argument_list|()
expr_stmt|;
operator|*
name|scene
operator|=
operator|*
name|fp
expr_stmt|;
name|fp
operator|->
name|num_children
operator|=
literal|2
expr_stmt|;
name|fp
operator|->
name|child
operator|=
name|scene
expr_stmt|;
name|scene
operator|->
name|next
operator|=
name|obscene
expr_stmt|;
name|obscene
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|scene
operator|->
name|child
operator|=
name|obscene
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|scene
operator|->
name|parent
operator|=
name|obscene
operator|->
name|parent
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|scene
operator|->
name|percent
operator|=
name|obscene
operator|->
name|percent
operator|=
name|NO_PROB
expr_stmt|;
name|obscene
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|obscene
operator|->
name|inf
operator|=
name|NULL
expr_stmt|;
name|obscene
operator|->
name|path
operator|=
name|offensive
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|rindex
argument_list|(
name|offensive
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|obscene
operator|->
name|name
operator|=
name|offensive
expr_stmt|;
else|else
name|obscene
operator|->
name|name
operator|=
operator|++
name|sp
expr_stmt|;
name|obscene
operator|->
name|datfile
operator|=
name|datfile
expr_stmt|;
name|obscene
operator|->
name|posfile
operator|=
name|posfile
expr_stmt|;
name|obscene
operator|->
name|read_tbl
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|OK_TO_WRITE_DISK
name|obscene
operator|->
name|was_pos_file
operator|=
operator|(
name|access
argument_list|(
name|obscene
operator|->
name|posfile
argument_list|,
name|W_OK
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* OK_TO_WRITE_DISK */
block|}
end_function

begin_comment
comment|/*  * add_dir:  *	Add the contents of an entire directory.  */
end_comment

begin_function
name|int
name|add_dir
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|)
block|{
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dirent
decl_stmt|;
name|FILEDESC
modifier|*
name|tailp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp
operator|->
name|fd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
name|opendir
argument_list|(
name|fp
operator|->
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|tailp
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"adding dir \"%s\"\n"
operator|,
name|fp
operator|->
name|path
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|num_children
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dirent
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dirent
operator|->
name|d_namlen
operator|==
literal|0
condition|)
continue|continue;
name|name
operator|=
name|copy
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
name|dirent
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_file
argument_list|(
name|NO_PROB
argument_list|,
name|name
argument_list|,
name|fp
operator|->
name|path
argument_list|,
operator|&
name|fp
operator|->
name|child
argument_list|,
operator|&
name|tailp
argument_list|,
name|fp
argument_list|)
condition|)
name|fp
operator|->
name|num_children
operator|++
expr_stmt|;
else|else
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|num_children
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune: %s: No fortune files in directory.\n"
argument_list|,
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * is_dir:  *	Return TRUE if the file is a directory, FALSE otherwise.  */
end_comment

begin_function
name|int
name|is_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * is_fortfile:  *	Return TRUE if the file is a fortune database file.  We try and  *	exclude files without reading them if possible to avoid  *	overhead.  Files which start with ".", or which have "illegal"  *	suffixes, as contained in suflist[], are ruled out.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|is_fortfile
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|datp
parameter_list|,
name|char
modifier|*
modifier|*
name|posp
parameter_list|,
name|int
name|check_for_offend
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|datfile
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|suflist
index|[]
init|=
block|{
comment|/* list of "illegal" suffixes" */
literal|"dat"
block|,
literal|"pos"
block|,
literal|"c"
block|,
literal|"h"
block|,
literal|"p"
block|,
literal|"i"
block|,
literal|"f"
block|,
literal|"pas"
block|,
literal|"ftn"
block|,
literal|"ins.c"
block|,
literal|"ins,pas"
block|,
literal|"ins.ftn"
block|,
literal|"sml"
block|,
name|NULL
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"is_fortfile(%s) returns "
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Preclude any -o files for offendable people, and any non -o 	 * files for completely offensive people. 	 */
if|if
condition|(
name|check_for_offend
operator|&&
operator|!
name|All_forts
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|Offend
operator|^
operator|(
name|file
index|[
name|i
operator|-
literal|2
index|]
operator|==
literal|'-'
operator|&&
name|file
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (offending file)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sp
operator|=
name|file
expr_stmt|;
else|else
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'.'
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (file starts with '.')\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|Fortunes_only
operator|&&
name|strncmp
argument_list|(
name|sp
argument_list|,
literal|"fortunes"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (check fortunes only)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|rindex
argument_list|(
name|sp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|suflist
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sp
argument_list|,
name|suflist
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (file has suffix \".%s\")\n"
operator|,
name|sp
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
name|datfile
operator|=
name|copy
argument_list|(
name|file
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* +4 for ".dat" */
name|strcat
argument_list|(
name|datfile
argument_list|,
literal|".dat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|datfile
argument_list|,
name|R_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (no readable \".dat\" file)\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|<
literal|2
condition|)
name|DPRINTF
argument_list|(
literal|0
argument_list|,
operator|(
name|stderr
operator|,
literal|"Warning: file \"%s\" unreadable\n"
operator|,
name|datfile
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|datfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|datp
operator|!=
name|NULL
condition|)
operator|*
name|datp
operator|=
name|datfile
expr_stmt|;
else|else
name|free
argument_list|(
name|datfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|posp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|OK_TO_WRITE_DISK
operator|*
name|posp
operator|=
name|copy
argument_list|(
name|file
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* +4 for ".dat" */
operator|(
name|void
operator|)
name|strcat
argument_list|(
operator|*
name|posp
argument_list|,
literal|".pos"
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|posp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* OK_TO_WRITE_DISK */
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"TRUE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copy:  *	Return a malloc()'ed copy of the string  */
end_comment

begin_function
name|char
modifier|*
name|copy
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|new
operator|=
name|do_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
name|new
expr_stmt|;
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|str
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|str
operator|++
condition|)
do|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * do_malloc:  *	Do a malloc, checking for NULL return.  */
end_comment

begin_function
name|void
modifier|*
name|do_malloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune: out of memory.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * do_free:  *	Free malloc'ed space, if any.  */
end_comment

begin_function
name|void
name|do_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * init_prob:  *	Initialize the fortune probabilities.  */
end_comment

begin_function
name|void
name|init_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|FILEDESC
modifier|*
name|fp
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|int
name|percent
decl_stmt|,
name|num_noprob
decl_stmt|,
name|frac
decl_stmt|;
comment|/* 	 * Distribute the residual probability (if any) across all 	 * files with unspecified probability (i.e., probability of 0) 	 * (if any). 	 */
name|percent
operator|=
literal|0
expr_stmt|;
name|num_noprob
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|File_tail
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|prev
control|)
if|if
condition|(
name|fp
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
block|{
name|num_noprob
operator|++
expr_stmt|;
if|if
condition|(
name|Equal_probs
condition|)
name|last
operator|=
name|fp
expr_stmt|;
block|}
else|else
name|percent
operator|+=
name|fp
operator|->
name|percent
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"summing probabilities:%d%% with %d NO_PROB's"
operator|,
name|percent
operator|,
name|num_noprob
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|percent
operator|>
literal|100
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune: probabilities sum to %d%%> 100%%!\n"
argument_list|,
name|percent
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|percent
operator|<
literal|100
operator|&&
name|num_noprob
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune: no place to put residual probability (%d%%< 100%%)\n"
argument_list|,
name|percent
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|percent
operator|==
literal|100
operator|&&
name|num_noprob
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune: no probability left to put in residual files (100%%)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|percent
operator|=
literal|100
operator|-
name|percent
expr_stmt|;
if|if
condition|(
name|Equal_probs
condition|)
block|{
if|if
condition|(
name|num_noprob
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|num_noprob
operator|>
literal|1
condition|)
block|{
name|frac
operator|=
name|percent
operator|/
name|num_noprob
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|", frac = %d%%"
operator|,
name|frac
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|File_tail
init|;
name|fp
operator|!=
name|last
condition|;
name|fp
operator|=
name|fp
operator|->
name|prev
control|)
if|if
condition|(
name|fp
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
block|{
name|fp
operator|->
name|percent
operator|=
name|frac
expr_stmt|;
name|percent
operator|-=
name|frac
expr_stmt|;
block|}
block|}
name|last
operator|->
name|percent
operator|=
name|percent
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|", residual = %d%%"
operator|,
name|percent
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|", %d%% distributed over remaining fortunes\n"
operator|,
name|percent
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>=
literal|1
condition|)
name|print_file_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * get_fort:  *	Get the fortune data file's seek pointer for the next fortune.  */
end_comment

begin_function
name|void
name|get_fort
parameter_list|(
name|void
parameter_list|)
block|{
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|int
name|choice
decl_stmt|;
if|if
condition|(
name|File_list
operator|->
name|next
operator|==
name|NULL
operator|||
name|File_list
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
name|fp
operator|=
name|File_list
expr_stmt|;
else|else
block|{
name|choice
operator|=
name|arc4random_uniform
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"choice = %d\n"
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|File_list
init|;
name|fp
operator|->
name|percent
operator|!=
name|NO_PROB
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|choice
operator|<
name|fp
operator|->
name|percent
condition|)
break|break;
else|else
block|{
name|choice
operator|-=
name|fp
operator|->
name|percent
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    skip \"%s\", %d%% (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|percent
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"using \"%s\", %d%% (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|percent
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|percent
operator|!=
name|NO_PROB
condition|)
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fp
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|sum_noprobs
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|choice
operator|=
name|arc4random_uniform
argument_list|(
name|Noprob_tbl
operator|.
name|str_numstr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"choice = %d (of %u) \n"
operator|,
name|choice
operator|,
name|Noprob_tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|unsigned
name|int
operator|)
name|choice
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|)
block|{
name|choice
operator|-=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    skip \"%s\", %u (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"using \"%s\", %u\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
block|}
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"picking child\n"
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|pick_child
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|Fortfile
operator|=
name|fp
expr_stmt|;
name|get_pos
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|open_dat
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fp
operator|->
name|datfd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
sizeof|sizeof
name|fp
operator|->
name|tbl
operator|+
name|fp
operator|->
name|pos
operator|*
sizeof|sizeof
name|Seekpts
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fp
operator|->
name|datfd
argument_list|,
name|Seekpts
argument_list|,
sizeof|sizeof
name|Seekpts
argument_list|)
expr_stmt|;
name|Seekpts
index|[
literal|0
index|]
operator|=
name|be64toh
argument_list|(
name|Seekpts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Seekpts
index|[
literal|1
index|]
operator|=
name|be64toh
argument_list|(
name|Seekpts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pick_child  *	Pick a child from a chosen parent.  */
end_comment

begin_function
name|FILEDESC
modifier|*
name|pick_child
parameter_list|(
name|FILEDESC
modifier|*
name|parent
parameter_list|)
block|{
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|int
name|choice
decl_stmt|;
if|if
condition|(
name|Equal_probs
condition|)
block|{
name|choice
operator|=
name|arc4random_uniform
argument_list|(
name|parent
operator|->
name|num_children
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    choice = %d (of %d)\n"
operator|,
name|choice
operator|,
name|parent
operator|->
name|num_children
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|parent
operator|->
name|child
init|;
name|choice
operator|--
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
continue|continue;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    using %s\n"
operator|,
name|fp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
else|else
block|{
name|get_tbl
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|choice
operator|=
name|arc4random_uniform
argument_list|(
name|parent
operator|->
name|tbl
operator|.
name|str_numstr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    choice = %d (of %u)\n"
operator|,
name|choice
operator|,
name|parent
operator|->
name|tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|parent
operator|->
name|child
init|;
operator|(
name|unsigned
operator|)
name|choice
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
block|{
name|choice
operator|-=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"\tskip %s, %u (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    using %s, %u\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * sum_noprobs:  *	Sum up all the noprob probabilities, starting with fp.  */
end_comment

begin_function
name|void
name|sum_noprobs
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|bool
name|did_noprobs
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|did_noprobs
condition|)
return|return;
name|zero_tbl
argument_list|(
operator|&
name|Noprob_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sum_tbl
argument_list|(
operator|&
name|Noprob_tbl
argument_list|,
operator|&
name|fp
operator|->
name|tbl
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
block|}
name|did_noprobs
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|max
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
operator|(
name|i
operator|>=
name|j
condition|?
name|i
else|:
name|j
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * open_fp:  *	Assocatiate a FILE * with the given FILEDESC.  */
end_comment

begin_function
name|void
name|open_fp
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|inf
operator|==
name|NULL
operator|&&
operator|(
name|fp
operator|->
name|inf
operator|=
name|fdopen
argument_list|(
name|fp
operator|->
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * open_dat:  *	Open up the dat file if we need to.  */
end_comment

begin_function
name|void
name|open_dat
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|datfd
operator|<
literal|0
operator|&&
operator|(
name|fp
operator|->
name|datfd
operator|=
name|open
argument_list|(
name|fp
operator|->
name|datfile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|datfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * get_pos:  *	Get the position from the pos file, if there is one.  If not,  *	return a random number.  */
end_comment

begin_function
name|void
name|get_pos
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|OK_TO_WRITE_DISK
name|int
name|fd
decl_stmt|;
endif|#
directive|endif
comment|/* OK_TO_WRITE_DISK */
name|assert
argument_list|(
name|fp
operator|->
name|read_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|pos
operator|==
name|POS_UNKNOWN
condition|)
block|{
ifdef|#
directive|ifdef
name|OK_TO_WRITE_DISK
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fp
operator|->
name|posfile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|fp
operator|->
name|pos
argument_list|,
sizeof|sizeof
name|fp
operator|->
name|pos
argument_list|)
operator|!=
sizeof|sizeof
name|fp
operator|->
name|pos
condition|)
name|fp
operator|->
name|pos
operator|=
name|arc4random_uniform
argument_list|(
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|pos
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|)
name|fp
operator|->
name|pos
operator|%=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|fp
operator|->
name|pos
operator|=
name|arc4random_uniform
argument_list|(
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OK_TO_WRITE_DISK */
block|}
if|if
condition|(
operator|++
operator|(
name|fp
operator|->
name|pos
operator|)
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|)
name|fp
operator|->
name|pos
operator|-=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"pos for %s is %ld\n"
operator|,
name|fp
operator|->
name|name
operator|,
operator|(
name|long
operator|)
name|fp
operator|->
name|pos
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get_tbl:  *	Get the tbl data file the datfile.  */
end_comment

begin_function
name|void
name|get_tbl
parameter_list|(
name|FILEDESC
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|FILEDESC
modifier|*
name|child
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|read_tbl
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|child
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fp
operator|->
name|datfile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|datfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|->
name|tbl
argument_list|,
sizeof|sizeof
name|fp
operator|->
name|tbl
argument_list|)
operator|!=
sizeof|sizeof
name|fp
operator|->
name|tbl
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune: %s corrupted\n"
argument_list|,
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* fp->tbl.str_version = be32toh(fp->tbl.str_version); */
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|=
name|be32toh
argument_list|(
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tbl
operator|.
name|str_longlen
operator|=
name|be32toh
argument_list|(
name|fp
operator|->
name|tbl
operator|.
name|str_longlen
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tbl
operator|.
name|str_shortlen
operator|=
name|be32toh
argument_list|(
name|fp
operator|->
name|tbl
operator|.
name|str_shortlen
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tbl
operator|.
name|str_flags
operator|=
name|be32toh
argument_list|(
name|fp
operator|->
name|tbl
operator|.
name|str_flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zero_tbl
argument_list|(
operator|&
name|fp
operator|->
name|tbl
argument_list|)
expr_stmt|;
for|for
control|(
name|child
operator|=
name|fp
operator|->
name|child
init|;
name|child
operator|!=
name|NULL
condition|;
name|child
operator|=
name|child
operator|->
name|next
control|)
block|{
name|get_tbl
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|sum_tbl
argument_list|(
operator|&
name|fp
operator|->
name|tbl
argument_list|,
operator|&
name|child
operator|->
name|tbl
argument_list|)
expr_stmt|;
block|}
block|}
name|fp
operator|->
name|read_tbl
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zero_tbl:  *	Zero out the fields we care about in a tbl structure.  */
end_comment

begin_function
name|void
name|zero_tbl
parameter_list|(
name|STRFILE
modifier|*
name|tp
parameter_list|)
block|{
name|tp
operator|->
name|str_numstr
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|str_longlen
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|str_shortlen
operator|=
operator|~
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sum_tbl:  *	Merge the tbl data of t2 into t1.  */
end_comment

begin_function
name|void
name|sum_tbl
parameter_list|(
name|STRFILE
modifier|*
name|t1
parameter_list|,
name|STRFILE
modifier|*
name|t2
parameter_list|)
block|{
name|t1
operator|->
name|str_numstr
operator|+=
name|t2
operator|->
name|str_numstr
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|str_longlen
operator|<
name|t2
operator|->
name|str_longlen
condition|)
name|t1
operator|->
name|str_longlen
operator|=
name|t2
operator|->
name|str_longlen
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|str_shortlen
operator|>
name|t2
operator|->
name|str_shortlen
condition|)
name|t1
operator|->
name|str_shortlen
operator|=
name|t2
operator|->
name|str_shortlen
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|STR
parameter_list|(
name|str
parameter_list|)
value|((str) == NULL ? "NULL" : (str))
end_define

begin_comment
comment|/*  * print_file_list:  *	Print out the file list  */
end_comment

begin_function
name|void
name|print_file_list
parameter_list|(
name|void
parameter_list|)
block|{
name|print_list
argument_list|(
name|File_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print_list:  *	Print out the actual list, recursively.  */
end_comment

begin_function
name|void
name|print_list
parameter_list|(
name|FILEDESC
modifier|*
name|list
parameter_list|,
name|int
name|lev
parameter_list|)
block|{
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s"
argument_list|,
name|lev
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"___%%"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d%%"
argument_list|,
name|list
operator|->
name|percent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|STR
argument_list|(
name|list
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|" (%s, %s, %s)"
operator|,
name|STR
argument_list|(
name|list
operator|->
name|path
argument_list|)
operator|,
name|STR
argument_list|(
name|list
operator|->
name|datfile
argument_list|)
operator|,
name|STR
argument_list|(
name|list
operator|->
name|posfile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|child
operator|!=
name|NULL
condition|)
name|print_list
argument_list|(
name|list
operator|->
name|child
argument_list|,
name|lev
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * conv_pat:  *	Convert the pattern to an ignore-case equivalent.  */
end_comment

begin_function
name|char
modifier|*
name|conv_pat
parameter_list|(
name|char
modifier|*
name|orig
parameter_list|)
block|{
name|char
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
comment|/* allow for '\0' */
for|for
control|(
name|sp
operator|=
name|orig
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|sp
argument_list|)
condition|)
name|cnt
operator|+=
literal|4
expr_stmt|;
else|else
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|cnt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pattern too long for ignoring case\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|new
init|;
operator|*
name|orig
operator|!=
literal|'\0'
condition|;
name|orig
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|orig
argument_list|)
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|*
name|orig
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|orig
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|orig
argument_list|)
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|*
name|orig
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|orig
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
else|else
operator|*
name|sp
operator|++
operator|=
operator|*
name|orig
expr_stmt|;
block|}
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find_matches:  *	Find all the fortunes which match the pattern we've been given.  */
end_comment

begin_function
name|int
name|find_matches
parameter_list|(
name|void
parameter_list|)
block|{
name|Fort_len
operator|=
name|maxlen_in_list
argument_list|(
name|File_list
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"Maximum length is %d\n"
operator|,
name|Fort_len
operator|)
argument_list|)
expr_stmt|;
comment|/* extra length, "%\n" is appended */
name|Fortbuf
operator|=
name|do_malloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|Fort_len
operator|+
literal|10
argument_list|)
expr_stmt|;
name|Found_one
operator|=
name|FALSE
expr_stmt|;
name|matches_in_list
argument_list|(
name|File_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|Found_one
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * maxlen_in_list  *	Return the maximum fortune len in the file list.  */
end_comment

begin_function
name|int
name|maxlen_in_list
parameter_list|(
name|FILEDESC
modifier|*
name|list
parameter_list|)
block|{
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|maxlen
decl_stmt|;
name|maxlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|list
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|maxlen_in_list
argument_list|(
name|fp
operator|->
name|child
argument_list|)
operator|)
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tbl
operator|.
name|str_longlen
operator|>
operator|(
name|unsigned
name|int
operator|)
name|maxlen
condition|)
name|maxlen
operator|=
name|fp
operator|->
name|tbl
operator|.
name|str_longlen
expr_stmt|;
block|}
block|}
return|return
operator|(
name|maxlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * matches_in_list  *	Print out the matches from the files in the list.  */
end_comment

begin_function
name|void
name|matches_in_list
parameter_list|(
name|FILEDESC
modifier|*
name|list
parameter_list|)
block|{
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|int
name|in_file
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|list
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|matches_in_list
argument_list|(
name|fp
operator|->
name|child
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"searching in %s\n"
operator|,
name|fp
operator|->
name|path
operator|)
argument_list|)
expr_stmt|;
name|open_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|Fortbuf
expr_stmt|;
name|in_file
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|sp
argument_list|,
name|Fort_len
argument_list|,
name|fp
operator|->
name|inf
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|fp
operator|->
name|tbl
operator|.
name|str_flags
operator|&
name|STR_COMMENTS
operator|&&
name|sp
index|[
literal|0
index|]
operator|==
name|fp
operator|->
name|tbl
operator|.
name|str_delim
operator|&&
name|sp
index|[
literal|1
index|]
operator|==
name|fp
operator|->
name|tbl
operator|.
name|str_delim
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|STR_ENDSTRING
argument_list|(
name|sp
argument_list|,
name|fp
operator|->
name|tbl
argument_list|)
condition|)
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tbl
operator|.
name|str_flags
operator|&
name|STR_ROTATED
condition|)
for|for
control|(
name|p
operator|=
name|Fortbuf
init|;
operator|(
name|ch
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'A'
operator|+
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|13
operator|)
operator|%
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'a'
operator|+
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|13
operator|)
operator|%
literal|26
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|Re_pat
argument_list|,
name|Fortbuf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|REG_NOMATCH
condition|)
block|{
name|printf
argument_list|(
literal|"%c%c"
argument_list|,
name|fp
operator|->
name|tbl
operator|.
name|str_delim
argument_list|,
name|fp
operator|->
name|tbl
operator|.
name|str_delim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_file
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|fp
operator|->
name|name
argument_list|)
expr_stmt|;
name|Found_one
operator|=
name|TRUE
expr_stmt|;
name|in_file
operator|=
name|TRUE
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|Fortbuf
argument_list|,
literal|1
argument_list|,
operator|(
name|sp
operator|-
name|Fortbuf
operator|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|Fortbuf
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune [-a"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"efilosw]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [-m pattern]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [[N%%] file/directory/all]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getpath  * 	Set up file search patch from environment var FORTUNE_PATH;  *	if not set, use the compiled in FORTDIR.  */
end_comment

begin_function
name|void
name|getpath
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nstr
decl_stmt|,
name|foundenv
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|,
modifier|*
modifier|*
name|ppch
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|foundenv
operator|=
literal|1
expr_stmt|;
name|Fortune_path
operator|=
name|getenv
argument_list|(
literal|"FORTUNE_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Fortune_path
operator|==
name|NULL
condition|)
block|{
name|Fortune_path
operator|=
name|FORTDIR
expr_stmt|;
name|foundenv
operator|=
literal|0
expr_stmt|;
block|}
name|path
operator|=
name|strdup
argument_list|(
name|Fortune_path
argument_list|)
expr_stmt|;
for|for
control|(
name|nstr
operator|=
literal|2
operator|,
name|pch
operator|=
name|path
init|;
operator|*
name|pch
operator|!=
literal|'\0'
condition|;
name|pch
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pch
operator|==
literal|':'
condition|)
name|nstr
operator|++
expr_stmt|;
block|}
name|ppch
operator|=
name|Fortune_path_arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nstr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nstr
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|strtok
argument_list|(
name|path
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
while|while
condition|(
name|str
condition|)
block|{
if|if
condition|(
name|is_dir
argument_list|(
name|str
argument_list|)
condition|)
block|{
name|nstr
operator|++
expr_stmt|;
operator|*
name|ppch
operator|++
operator|=
name|str
expr_stmt|;
block|}
name|str
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nstr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|foundenv
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune: FORTUNE_PATH: None of the specified "
literal|"directories found.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|Fortune_path_arr
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|FORTDIR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

