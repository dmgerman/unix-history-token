begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Timothy C. Stoehr.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)use.c	8.1 (Berkeley) 5/31/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * use.c  *  * This source herein may be modified and/or distributed by anybody who  * so desires, with the following restrictions:  *    1.)  No portion of this notice shall be removed.  *    2.)  Credit shall not be taken for the creation of this source.  *    3.)  This code is not to be traded, sold, or used for personal  *         gain or profit.  *  */
end_comment

begin_include
include|#
directive|include
file|"rogue.h"
end_include

begin_decl_stmt
name|short
name|halluc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|blind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|confused
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|levitate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|haste_self
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|see_invisible
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|extra_hp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|detect_monster
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|con_mon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|strange_feeling
init|=
literal|"you have a strange feeling for a moment, then it passes"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|bear_trap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|hunger_str
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|cur_room
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|level_points
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|being_held
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fruit
decl_stmt|,
modifier|*
name|you_can_move_again
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|sustain_strength
decl_stmt|;
end_decl_stmt

begin_macro
name|quaff
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|object
modifier|*
name|obj
decl_stmt|;
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"quaff what?"
argument_list|,
name|POTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"no such item."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|obj
operator|->
name|what_is
operator|!=
name|POTION
condition|)
block|{
name|message
argument_list|(
literal|"you can't drink that"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|obj
operator|->
name|which_kind
condition|)
block|{
case|case
name|INCREASE_STRENGTH
case|:
name|message
argument_list|(
literal|"you feel stronger now, what bulging muscles!"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rogue
operator|.
name|str_current
operator|++
expr_stmt|;
if|if
condition|(
name|rogue
operator|.
name|str_current
operator|>
name|rogue
operator|.
name|str_max
condition|)
block|{
name|rogue
operator|.
name|str_max
operator|=
name|rogue
operator|.
name|str_current
expr_stmt|;
block|}
break|break;
case|case
name|RESTORE_STRENGTH
case|:
name|rogue
operator|.
name|str_current
operator|=
name|rogue
operator|.
name|str_max
expr_stmt|;
name|message
argument_list|(
literal|"this tastes great, you feel warm all over"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEALING
case|:
name|message
argument_list|(
literal|"you begin to feel better"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|potion_heal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTRA_HEALING
case|:
name|message
argument_list|(
literal|"you begin to feel much better"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|potion_heal
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|POISON
case|:
if|if
condition|(
operator|!
name|sustain_strength
condition|)
block|{
name|rogue
operator|.
name|str_current
operator|-=
name|get_rand
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rogue
operator|.
name|str_current
operator|<
literal|1
condition|)
block|{
name|rogue
operator|.
name|str_current
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|message
argument_list|(
literal|"you feel very sick now"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|halluc
condition|)
block|{
name|unhallucinate
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|RAISE_LEVEL
case|:
name|rogue
operator|.
name|exp_points
operator|=
name|level_points
index|[
name|rogue
operator|.
name|exp
operator|-
literal|1
index|]
expr_stmt|;
name|message
argument_list|(
literal|"you suddenly feel much more skillful"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_exp
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BLINDNESS
case|:
name|go_blind
argument_list|()
expr_stmt|;
break|break;
case|case
name|HALLUCINATION
case|:
name|message
argument_list|(
literal|"oh wow, everything seems so cosmic"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|halluc
operator|+=
name|get_rand
argument_list|(
literal|500
argument_list|,
literal|800
argument_list|)
expr_stmt|;
break|break;
case|case
name|DETECT_MONSTER
case|:
name|show_monsters
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|level_monsters
operator|.
name|next_monster
operator|)
condition|)
block|{
name|message
argument_list|(
name|strange_feeling
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DETECT_OBJECTS
case|:
if|if
condition|(
name|level_objects
operator|.
name|next_object
condition|)
block|{
if|if
condition|(
operator|!
name|blind
condition|)
block|{
name|show_objects
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|message
argument_list|(
name|strange_feeling
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONFUSION
case|:
name|message
argument_list|(
operator|(
name|halluc
condition|?
literal|"what a trippy feeling"
else|:
literal|"you feel confused"
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnfs
argument_list|()
expr_stmt|;
break|break;
case|case
name|LEVITATION
case|:
name|message
argument_list|(
literal|"you start to float in the air"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|levitate
operator|+=
name|get_rand
argument_list|(
literal|15
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|being_held
operator|=
name|bear_trap
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HASTE_SELF
case|:
name|message
argument_list|(
literal|"you feel yourself moving much faster"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|haste_self
operator|+=
name|get_rand
argument_list|(
literal|11
argument_list|,
literal|21
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|haste_self
operator|%
literal|2
operator|)
condition|)
block|{
name|haste_self
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SEE_INVISIBLE
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"hmm, this potion tastes like %sjuice"
argument_list|,
name|fruit
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blind
condition|)
block|{
name|unblind
argument_list|()
expr_stmt|;
block|}
name|see_invisible
operator|=
literal|1
expr_stmt|;
name|relight
argument_list|()
expr_stmt|;
break|break;
block|}
name|print_stats
argument_list|(
operator|(
name|STAT_STRENGTH
operator||
name|STAT_HP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_potions
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|id_status
operator|!=
name|CALLED
condition|)
block|{
name|id_potions
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|id_status
operator|=
name|IDENTIFIED
expr_stmt|;
block|}
name|vanish
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|rogue
operator|.
name|pack
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|read_scroll
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|;
name|object
modifier|*
name|obj
decl_stmt|;
name|char
name|msg
index|[
name|DCOLS
index|]
decl_stmt|;
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"read what?"
argument_list|,
name|SCROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"no such item."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|obj
operator|->
name|what_is
operator|!=
name|SCROL
condition|)
block|{
name|message
argument_list|(
literal|"you can't read that"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|obj
operator|->
name|which_kind
condition|)
block|{
case|case
name|SCARE_MONSTER
case|:
name|message
argument_list|(
literal|"you hear a maniacal laughter in the distance"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HOLD_MONSTER
case|:
name|hold_monster
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENCH_WEAPON
case|:
if|if
condition|(
name|rogue
operator|.
name|weapon
condition|)
block|{
if|if
condition|(
name|rogue
operator|.
name|weapon
operator|->
name|what_is
operator|==
name|WEAPON
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"your %sglow%s %sfor a moment"
argument_list|,
name|name_of
argument_list|(
name|rogue
operator|.
name|weapon
argument_list|)
argument_list|,
operator|(
operator|(
name|rogue
operator|.
name|weapon
operator|->
name|quantity
operator|<=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
operator|)
argument_list|,
name|get_ench_color
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|coin_toss
argument_list|()
condition|)
block|{
name|rogue
operator|.
name|weapon
operator|->
name|hit_enchant
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rogue
operator|.
name|weapon
operator|->
name|d_enchant
operator|++
expr_stmt|;
block|}
block|}
name|rogue
operator|.
name|weapon
operator|->
name|is_cursed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"your hands tingle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCH_ARMOR
case|:
if|if
condition|(
name|rogue
operator|.
name|armor
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"your armor glows %sfor a moment"
argument_list|,
name|get_ench_color
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rogue
operator|.
name|armor
operator|->
name|d_enchant
operator|++
expr_stmt|;
name|rogue
operator|.
name|armor
operator|->
name|is_cursed
operator|=
literal|0
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_ARMOR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"your skin crawls"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IDENTIFY
case|:
name|message
argument_list|(
literal|"this is a scroll of identify"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obj
operator|->
name|identified
operator|=
literal|1
expr_stmt|;
name|id_scrolls
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|id_status
operator|=
name|IDENTIFIED
expr_stmt|;
name|idntfy
argument_list|()
expr_stmt|;
break|break;
case|case
name|TELEPORT
case|:
name|tele
argument_list|()
expr_stmt|;
break|break;
case|case
name|SLEEP
case|:
name|message
argument_list|(
literal|"you fall asleep"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|take_a_nap
argument_list|()
expr_stmt|;
break|break;
case|case
name|PROTECT_ARMOR
case|:
if|if
condition|(
name|rogue
operator|.
name|armor
condition|)
block|{
name|message
argument_list|(
literal|"your armor is covered by a shimmering gold shield"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rogue
operator|.
name|armor
operator|->
name|is_protected
operator|=
literal|1
expr_stmt|;
name|rogue
operator|.
name|armor
operator|->
name|is_cursed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"your acne seems to have disappeared"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REMOVE_CURSE
case|:
name|message
argument_list|(
operator|(
operator|!
name|halluc
operator|)
condition|?
literal|"you feel as though someone is watching over you"
else|:
literal|"you feel in touch with the universal oneness"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uncurse_all
argument_list|()
expr_stmt|;
break|break;
case|case
name|CREATE_MONSTER
case|:
name|create_monster
argument_list|()
expr_stmt|;
break|break;
case|case
name|AGGRAVATE_MONSTER
case|:
name|aggravate
argument_list|()
expr_stmt|;
break|break;
case|case
name|MAGIC_MAPPING
case|:
name|message
argument_list|(
literal|"this scroll seems to have a map on it"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|draw_magic_map
argument_list|()
expr_stmt|;
break|break;
case|case
name|CON_MON
case|:
name|con_mon
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"your hands glow %sfor a moment"
argument_list|,
name|get_ench_color
argument_list|()
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|id_scrolls
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|id_status
operator|!=
name|CALLED
condition|)
block|{
name|id_scrolls
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|id_status
operator|=
name|IDENTIFIED
expr_stmt|;
block|}
name|vanish
argument_list|(
name|obj
argument_list|,
operator|(
name|obj
operator|->
name|which_kind
operator|!=
name|SLEEP
operator|)
argument_list|,
operator|&
name|rogue
operator|.
name|pack
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* vanish() does NOT handle a quiver of weapons with more than one  *  arrow (or whatever) in the quiver.  It will only decrement the count.  */
end_comment

begin_macro
name|vanish
argument_list|(
argument|obj
argument_list|,
argument|rm
argument_list|,
argument|pack
argument_list|)
end_macro

begin_decl_stmt
name|object
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|object
modifier|*
name|pack
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|obj
operator|->
name|quantity
operator|>
literal|1
condition|)
block|{
name|obj
operator|->
name|quantity
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|obj
operator|->
name|in_use_flags
operator|&
name|BEING_WIELDED
condition|)
block|{
name|unwield
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|in_use_flags
operator|&
name|BEING_WORN
condition|)
block|{
name|unwear
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|in_use_flags
operator|&
name|ON_EITHER_HAND
condition|)
block|{
name|un_put_on
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|take_from_pack
argument_list|(
name|obj
argument_list|,
name|pack
argument_list|)
expr_stmt|;
name|free_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rm
condition|)
block|{
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|potion_heal
argument_list|(
argument|extra
argument_list|)
end_macro

begin_block
block|{
name|float
name|ratio
decl_stmt|;
name|short
name|add
decl_stmt|;
name|rogue
operator|.
name|hp_current
operator|+=
name|rogue
operator|.
name|exp
expr_stmt|;
name|ratio
operator|=
operator|(
operator|(
name|float
operator|)
name|rogue
operator|.
name|hp_current
operator|)
operator|/
name|rogue
operator|.
name|hp_max
expr_stmt|;
if|if
condition|(
name|ratio
operator|>=
literal|1.00
condition|)
block|{
name|rogue
operator|.
name|hp_max
operator|+=
operator|(
name|extra
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|extra_hp
operator|+=
operator|(
name|extra
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|rogue
operator|.
name|hp_current
operator|=
name|rogue
operator|.
name|hp_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ratio
operator|>=
literal|0.90
condition|)
block|{
name|rogue
operator|.
name|hp_max
operator|+=
operator|(
name|extra
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|extra_hp
operator|+=
operator|(
name|extra
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|rogue
operator|.
name|hp_current
operator|=
name|rogue
operator|.
name|hp_max
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ratio
operator|<
literal|0.33
condition|)
block|{
name|ratio
operator|=
literal|0.33
expr_stmt|;
block|}
if|if
condition|(
name|extra
condition|)
block|{
name|ratio
operator|+=
name|ratio
expr_stmt|;
block|}
name|add
operator|=
call|(
name|short
call|)
argument_list|(
name|ratio
operator|*
operator|(
operator|(
name|float
operator|)
name|rogue
operator|.
name|hp_max
operator|-
name|rogue
operator|.
name|hp_current
operator|)
argument_list|)
expr_stmt|;
name|rogue
operator|.
name|hp_current
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|rogue
operator|.
name|hp_current
operator|>
name|rogue
operator|.
name|hp_max
condition|)
block|{
name|rogue
operator|.
name|hp_current
operator|=
name|rogue
operator|.
name|hp_max
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blind
condition|)
block|{
name|unblind
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|confused
operator|&&
name|extra
condition|)
block|{
name|unconfuse
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|confused
condition|)
block|{
name|confused
operator|=
operator|(
name|confused
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|halluc
operator|&&
name|extra
condition|)
block|{
name|unhallucinate
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|halluc
condition|)
block|{
name|halluc
operator|=
operator|(
name|halluc
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|idntfy
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|;
name|object
modifier|*
name|obj
decl_stmt|;
name|struct
name|id
modifier|*
name|id_table
decl_stmt|;
name|char
name|desc
index|[
name|DCOLS
index|]
decl_stmt|;
name|AGAIN
label|:
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"what would you like to identify?"
argument_list|,
name|ALL_OBJECTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"no such item, try again"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_message
argument_list|()
expr_stmt|;
goto|goto
name|AGAIN
goto|;
block|}
name|obj
operator|->
name|identified
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|what_is
operator|&
operator|(
name|SCROL
operator||
name|POTION
operator||
name|WEAPON
operator||
name|ARMOR
operator||
name|WAND
operator||
name|RING
operator|)
condition|)
block|{
name|id_table
operator|=
name|get_id_table
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|id_table
index|[
name|obj
operator|->
name|which_kind
index|]
operator|.
name|id_status
operator|=
name|IDENTIFIED
expr_stmt|;
block|}
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eat
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|;
name|short
name|moves
decl_stmt|;
name|object
modifier|*
name|obj
decl_stmt|;
name|char
name|buf
index|[
literal|70
index|]
decl_stmt|;
name|ch
operator|=
name|pack_letter
argument_list|(
literal|"eat what?"
argument_list|,
name|FOOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CANCEL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|=
name|get_letter_object
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"no such item."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|obj
operator|->
name|what_is
operator|!=
name|FOOD
condition|)
block|{
name|message
argument_list|(
literal|"you can't eat that"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|obj
operator|->
name|which_kind
operator|==
name|FRUIT
operator|)
operator|||
name|rand_percent
argument_list|(
literal|60
argument_list|)
condition|)
block|{
name|moves
operator|=
name|get_rand
argument_list|(
literal|950
argument_list|,
literal|1150
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|which_kind
operator|==
name|RATION
condition|)
block|{
name|message
argument_list|(
literal|"yum, that tasted good"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"my, that was a yummy %s"
argument_list|,
name|fruit
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|moves
operator|=
name|get_rand
argument_list|(
literal|750
argument_list|,
literal|950
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"yuk, that food tasted awful"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_exp
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rogue
operator|.
name|moves_left
operator|/=
literal|3
expr_stmt|;
name|rogue
operator|.
name|moves_left
operator|+=
name|moves
expr_stmt|;
name|hunger_str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_HUNGER
argument_list|)
expr_stmt|;
name|vanish
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|rogue
operator|.
name|pack
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hold_monster
argument_list|()
end_macro

begin_block
block|{
name|short
name|i
decl_stmt|,
name|j
decl_stmt|;
name|short
name|mcount
init|=
literal|0
decl_stmt|;
name|object
modifier|*
name|monster
decl_stmt|;
name|short
name|row
decl_stmt|,
name|col
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|2
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
operator|-
literal|2
init|;
name|j
operator|<=
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|row
operator|=
name|rogue
operator|.
name|row
operator|+
name|i
expr_stmt|;
name|col
operator|=
name|rogue
operator|.
name|col
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|(
name|row
operator|<
name|MIN_ROW
operator|)
operator|||
operator|(
name|row
operator|>
operator|(
name|DROWS
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
name|col
operator|<
literal|0
operator|)
operator|||
operator|(
name|col
operator|>
operator|(
name|DCOLS
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|MONSTER
condition|)
block|{
name|monster
operator|=
name|object_at
argument_list|(
operator|&
name|level_monsters
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|monster
operator|->
name|m_flags
operator||=
name|ASLEEP
expr_stmt|;
name|monster
operator|->
name|m_flags
operator|&=
operator|(
operator|~
name|WAKENS
operator|)
expr_stmt|;
name|mcount
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mcount
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"you feel a strange sense of loss"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mcount
operator|==
literal|1
condition|)
block|{
name|message
argument_list|(
literal|"the monster freezes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"the monsters around you freeze"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|tele
argument_list|()
end_macro

begin_block
block|{
name|mvaddch
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|,
name|get_dungeon_char
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_room
operator|>=
literal|0
condition|)
block|{
name|darken_room
argument_list|(
name|cur_room
argument_list|)
expr_stmt|;
block|}
name|put_player
argument_list|(
name|get_room_number
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|being_held
operator|=
literal|0
expr_stmt|;
name|bear_trap
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|hallucinate
argument_list|()
end_macro

begin_block
block|{
name|object
modifier|*
name|obj
decl_stmt|,
modifier|*
name|monster
decl_stmt|;
name|short
name|ch
decl_stmt|;
if|if
condition|(
name|blind
condition|)
return|return;
name|obj
operator|=
name|level_objects
operator|.
name|next_object
expr_stmt|;
while|while
condition|(
name|obj
condition|)
block|{
name|ch
operator|=
name|mvinch
argument_list|(
name|obj
operator|->
name|row
argument_list|,
name|obj
operator|->
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ch
operator|<
literal|'A'
operator|)
operator|||
operator|(
name|ch
operator|>
literal|'Z'
operator|)
operator|)
operator|&&
operator|(
operator|(
name|obj
operator|->
name|row
operator|!=
name|rogue
operator|.
name|row
operator|)
operator|||
operator|(
name|obj
operator|->
name|col
operator|!=
name|rogue
operator|.
name|col
operator|)
operator|)
condition|)
if|if
condition|(
operator|(
name|ch
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'.'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'#'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'+'
operator|)
condition|)
block|{
name|addch
argument_list|(
name|gr_obj_char
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
name|obj
operator|->
name|next_object
expr_stmt|;
block|}
name|monster
operator|=
name|level_monsters
operator|.
name|next_monster
expr_stmt|;
while|while
condition|(
name|monster
condition|)
block|{
name|ch
operator|=
name|mvinch
argument_list|(
name|monster
operator|->
name|row
argument_list|,
name|monster
operator|->
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|addch
argument_list|(
name|get_rand
argument_list|(
literal|'A'
argument_list|,
literal|'Z'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|monster
operator|=
name|monster
operator|->
name|next_monster
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|unhallucinate
argument_list|()
end_macro

begin_block
block|{
name|halluc
operator|=
literal|0
expr_stmt|;
name|relight
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"everything looks SO boring now"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|unblind
argument_list|()
end_macro

begin_block
block|{
name|blind
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
literal|"the veil of darkness lifts"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|relight
argument_list|()
expr_stmt|;
if|if
condition|(
name|halluc
condition|)
block|{
name|hallucinate
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|detect_monster
condition|)
block|{
name|show_monsters
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|relight
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cur_room
operator|==
name|PASSAGE
condition|)
block|{
name|light_passage
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|light_up_room
argument_list|(
name|cur_room
argument_list|)
expr_stmt|;
block|}
name|mvaddch
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|,
name|rogue
operator|.
name|fchar
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|take_a_nap
argument_list|()
end_macro

begin_block
block|{
name|short
name|i
decl_stmt|;
name|i
operator|=
name|get_rand
argument_list|(
literal|2
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|md_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|mv_mons
argument_list|()
expr_stmt|;
block|}
name|md_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|you_can_move_again
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|go_blind
argument_list|()
end_macro

begin_block
block|{
name|short
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|blind
condition|)
block|{
name|message
argument_list|(
literal|"a cloak of darkness falls around you"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|blind
operator|+=
name|get_rand
argument_list|(
literal|500
argument_list|,
literal|800
argument_list|)
expr_stmt|;
if|if
condition|(
name|detect_monster
condition|)
block|{
name|object
modifier|*
name|monster
decl_stmt|;
name|monster
operator|=
name|level_monsters
operator|.
name|next_monster
expr_stmt|;
while|while
condition|(
name|monster
condition|)
block|{
name|mvaddch
argument_list|(
name|monster
operator|->
name|row
argument_list|,
name|monster
operator|->
name|col
argument_list|,
name|monster
operator|->
name|trail_char
argument_list|)
expr_stmt|;
name|monster
operator|=
name|monster
operator|->
name|next_monster
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_room
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|rooms
index|[
name|cur_room
index|]
operator|.
name|top_row
operator|+
literal|1
init|;
name|i
operator|<
name|rooms
index|[
name|cur_room
index|]
operator|.
name|bottom_row
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|rooms
index|[
name|cur_room
index|]
operator|.
name|left_col
operator|+
literal|1
init|;
name|j
operator|<
name|rooms
index|[
name|cur_room
index|]
operator|.
name|right_col
condition|;
name|j
operator|++
control|)
block|{
name|mvaddch
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mvaddch
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|,
name|rogue
operator|.
name|fchar
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|const
name|char
modifier|*
name|get_ench_color
parameter_list|()
block|{
if|if
condition|(
name|halluc
condition|)
block|{
return|return
operator|(
name|id_potions
index|[
name|get_rand
argument_list|(
literal|0
argument_list|,
name|POTIONS
operator|-
literal|1
argument_list|)
index|]
operator|.
name|title
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|con_mon
condition|)
block|{
return|return
operator|(
literal|"red "
operator|)
return|;
block|}
return|return
operator|(
literal|"blue "
operator|)
return|;
block|}
end_function

begin_macro
name|cnfs
argument_list|()
end_macro

begin_block
block|{
name|confused
operator|+=
name|get_rand
argument_list|(
literal|12
argument_list|,
literal|22
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|unconfuse
argument_list|()
end_macro

begin_block
block|{
name|char
name|msg
index|[
literal|80
index|]
decl_stmt|;
name|confused
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"you feel less %s now"
argument_list|,
operator|(
name|halluc
condition|?
literal|"trippy"
else|:
literal|"confused"
operator|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|uncurse_all
argument_list|()
end_macro

begin_block
block|{
name|object
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|rogue
operator|.
name|pack
operator|.
name|next_object
expr_stmt|;
while|while
condition|(
name|obj
condition|)
block|{
name|obj
operator|->
name|is_cursed
operator|=
literal|0
expr_stmt|;
name|obj
operator|=
name|obj
operator|->
name|next_object
expr_stmt|;
block|}
block|}
end_block

end_unit

