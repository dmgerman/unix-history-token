begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * The game adventure was originally written in Fortran by Will Crowther  * and Don Woods.  It was later translated to C and enhanced by Jim  * Gillogly.  This code is derived from software contributed to Berkeley  * by Jim Gillogly at The Rand Corporation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)save.c	8.1 (Berkeley) 5/31/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"hdr.h"
end_include

begin_struct
struct|struct
name|savestruct
block|{
name|void
modifier|*
name|address
decl_stmt|;
name|int
name|width
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|savestruct
name|save_array
index|[]
init|=
block|{
operator|&
name|abbnum
block|,
sizeof|sizeof
argument_list|(
name|abbnum
argument_list|)
block|,
operator|&
name|attack
block|,
sizeof|sizeof
argument_list|(
name|attack
argument_list|)
block|,
operator|&
name|blklin
block|,
sizeof|sizeof
argument_list|(
name|blklin
argument_list|)
block|,
operator|&
name|bonus
block|,
sizeof|sizeof
argument_list|(
name|bonus
argument_list|)
block|,
operator|&
name|chloc
block|,
sizeof|sizeof
argument_list|(
name|chloc
argument_list|)
block|,
operator|&
name|chloc2
block|,
sizeof|sizeof
argument_list|(
name|chloc2
argument_list|)
block|,
operator|&
name|clock1
block|,
sizeof|sizeof
argument_list|(
name|clock1
argument_list|)
block|,
operator|&
name|clock2
block|,
sizeof|sizeof
argument_list|(
name|clock2
argument_list|)
block|,
operator|&
name|closed
block|,
sizeof|sizeof
argument_list|(
name|closed
argument_list|)
block|,
operator|&
name|closng
block|,
sizeof|sizeof
argument_list|(
name|closng
argument_list|)
block|,
operator|&
name|daltlc
block|,
sizeof|sizeof
argument_list|(
name|daltlc
argument_list|)
block|,
operator|&
name|demo
block|,
sizeof|sizeof
argument_list|(
name|demo
argument_list|)
block|,
operator|&
name|detail
block|,
sizeof|sizeof
argument_list|(
name|detail
argument_list|)
block|,
operator|&
name|dflag
block|,
sizeof|sizeof
argument_list|(
name|dflag
argument_list|)
block|,
operator|&
name|dkill
block|,
sizeof|sizeof
argument_list|(
name|dkill
argument_list|)
block|,
operator|&
name|dtotal
block|,
sizeof|sizeof
argument_list|(
name|dtotal
argument_list|)
block|,
operator|&
name|foobar
block|,
sizeof|sizeof
argument_list|(
name|foobar
argument_list|)
block|,
operator|&
name|gaveup
block|,
sizeof|sizeof
argument_list|(
name|gaveup
argument_list|)
block|,
operator|&
name|holdng
block|,
sizeof|sizeof
argument_list|(
name|holdng
argument_list|)
block|,
operator|&
name|iwest
block|,
sizeof|sizeof
argument_list|(
name|iwest
argument_list|)
block|,
operator|&
name|k
block|,
sizeof|sizeof
argument_list|(
name|k
argument_list|)
block|,
operator|&
name|k2
block|,
sizeof|sizeof
argument_list|(
name|k2
argument_list|)
block|,
operator|&
name|knfloc
block|,
sizeof|sizeof
argument_list|(
name|knfloc
argument_list|)
block|,
operator|&
name|kq
block|,
sizeof|sizeof
argument_list|(
name|kq
argument_list|)
block|,
operator|&
name|latncy
block|,
sizeof|sizeof
argument_list|(
name|latncy
argument_list|)
block|,
operator|&
name|limit
block|,
sizeof|sizeof
argument_list|(
name|limit
argument_list|)
block|,
operator|&
name|lmwarn
block|,
sizeof|sizeof
argument_list|(
name|lmwarn
argument_list|)
block|,
operator|&
name|loc
block|,
sizeof|sizeof
argument_list|(
name|loc
argument_list|)
block|,
operator|&
name|maxdie
block|,
sizeof|sizeof
argument_list|(
name|maxdie
argument_list|)
block|,
operator|&
name|mxscor
block|,
sizeof|sizeof
argument_list|(
name|mxscor
argument_list|)
block|,
operator|&
name|newloc
block|,
sizeof|sizeof
argument_list|(
name|newloc
argument_list|)
block|,
operator|&
name|numdie
block|,
sizeof|sizeof
argument_list|(
name|numdie
argument_list|)
block|,
operator|&
name|obj
block|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
block|,
operator|&
name|oldlc2
block|,
sizeof|sizeof
argument_list|(
name|oldlc2
argument_list|)
block|,
operator|&
name|oldloc
block|,
sizeof|sizeof
argument_list|(
name|oldloc
argument_list|)
block|,
operator|&
name|panic
block|,
sizeof|sizeof
argument_list|(
name|panic
argument_list|)
block|,
operator|&
name|saved
block|,
sizeof|sizeof
argument_list|(
name|saved
argument_list|)
block|,
operator|&
name|savet
block|,
sizeof|sizeof
argument_list|(
name|savet
argument_list|)
block|,
operator|&
name|scorng
block|,
sizeof|sizeof
argument_list|(
name|scorng
argument_list|)
block|,
operator|&
name|spk
block|,
sizeof|sizeof
argument_list|(
name|spk
argument_list|)
block|,
operator|&
name|stick
block|,
sizeof|sizeof
argument_list|(
name|stick
argument_list|)
block|,
operator|&
name|tally
block|,
sizeof|sizeof
argument_list|(
name|tally
argument_list|)
block|,
operator|&
name|tally2
block|,
sizeof|sizeof
argument_list|(
name|tally2
argument_list|)
block|,
operator|&
name|tkk
block|,
sizeof|sizeof
argument_list|(
name|tkk
argument_list|)
block|,
operator|&
name|turns
block|,
sizeof|sizeof
argument_list|(
name|turns
argument_list|)
block|,
operator|&
name|verb
block|,
sizeof|sizeof
argument_list|(
name|verb
argument_list|)
block|,
operator|&
name|wd1
block|,
sizeof|sizeof
argument_list|(
name|wd1
argument_list|)
block|,
operator|&
name|wd2
block|,
sizeof|sizeof
argument_list|(
name|wd2
argument_list|)
block|,
operator|&
name|wzdark
block|,
sizeof|sizeof
argument_list|(
name|wzdark
argument_list|)
block|,
operator|&
name|yea
block|,
sizeof|sizeof
argument_list|(
name|yea
argument_list|)
block|,
name|atloc
block|,
sizeof|sizeof
argument_list|(
name|atloc
argument_list|)
block|,
name|dloc
block|,
sizeof|sizeof
argument_list|(
name|dloc
argument_list|)
block|,
name|dseen
block|,
sizeof|sizeof
argument_list|(
name|dseen
argument_list|)
block|,
name|fixed
block|,
sizeof|sizeof
argument_list|(
name|fixed
argument_list|)
block|,
name|hinted
block|,
sizeof|sizeof
argument_list|(
name|hinted
argument_list|)
block|,
name|linkx
block|,
sizeof|sizeof
argument_list|(
name|linkx
argument_list|)
block|,
name|odloc
block|,
sizeof|sizeof
argument_list|(
name|odloc
argument_list|)
block|,
name|place
block|,
sizeof|sizeof
argument_list|(
name|place
argument_list|)
block|,
name|prop
block|,
sizeof|sizeof
argument_list|(
name|prop
argument_list|)
block|,
name|tk
block|,
sizeof|sizeof
argument_list|(
name|tk
argument_list|)
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|save
argument_list|(
argument|outfile
argument_list|)
end_macro

begin_comment
comment|/* Two passes on data: first to get checksum, second */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to output the data using checksum to start random #s */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
name|struct
name|savestruct
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|crc_start
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|save_array
init|;
name|p
operator|->
name|address
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
name|sum
operator|=
name|crc
argument_list|(
name|p
operator|->
name|address
argument_list|,
name|p
operator|->
name|width
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|int
operator|)
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Hmm.  The name \"%s\" appears to be magically blocked.\n"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fwrite
argument_list|(
operator|&
name|sum
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|,
literal|1
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Here's the random() key */
for|for
control|(
name|p
operator|=
name|save_array
init|;
name|p
operator|->
name|address
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
name|s
operator|=
name|p
operator|->
name|address
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|width
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|^
name|random
argument_list|()
operator|)
operator|&
literal|0xFF
expr_stmt|;
comment|/* Lightly encrypt */
name|fwrite
argument_list|(
name|p
operator|->
name|address
argument_list|,
name|p
operator|->
name|width
argument_list|,
literal|1
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|restore
argument_list|(
argument|infile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|in
decl_stmt|;
name|struct
name|savestruct
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|sum
decl_stmt|,
name|cksum
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|infile
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Hmm.  The file \"%s\" appears to be magically blocked.\n"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fread
argument_list|(
operator|&
name|sum
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* Get the seed */
name|srandom
argument_list|(
operator|(
name|int
operator|)
name|sum
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|save_array
init|;
name|p
operator|->
name|address
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|fread
argument_list|(
name|p
operator|->
name|address
argument_list|,
name|p
operator|->
name|width
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p
operator|->
name|address
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|width
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|^
name|random
argument_list|()
operator|)
operator|&
literal|0xFF
expr_stmt|;
comment|/* Lightly decrypt */
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|crc_start
argument_list|()
expr_stmt|;
comment|/* See if she cheated */
for|for
control|(
name|p
operator|=
name|save_array
init|;
name|p
operator|->
name|address
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
name|cksum
operator|=
name|crc
argument_list|(
name|p
operator|->
name|address
argument_list|,
name|p
operator|->
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|cksum
condition|)
comment|/* Tsk tsk */
return|return
literal|2
return|;
comment|/* Altered the file */
comment|/* We successfully restored, so this really was a save file */
comment|/* Get rid of the file, but don't bother checking that we did */
return|return
literal|0
return|;
block|}
end_block

end_unit

