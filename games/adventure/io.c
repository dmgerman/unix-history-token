begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * The game adventure was originally written in Fortran by Will Crowther  * and Don Woods.  It was later translated to C and enhanced by Jim  * Gillogly.  This code is derived from software contributed to Berkeley  * by Jim Gillogly at The Rand Corporation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)io.c	8.1 (Berkeley) 5/31/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*      Re-coding of advent in C: file i/o and user i/o                 */
end_comment

begin_include
include|#
directive|include
file|"hdr.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_function_decl
specifier|static
name|int
name|next
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rnum
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdesc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdflt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rhints
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rliq
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rlocs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtrav
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rvoc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|twrite
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* get command from user        */
end_comment

begin_comment
comment|/* no prompt, usually           */
end_comment

begin_function
name|void
name|getin
parameter_list|(
name|char
modifier|*
modifier|*
name|wrd1
parameter_list|,
name|char
modifier|*
modifier|*
name|wrd2
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|static
name|char
name|wd1buf
index|[
name|MAXSTR
index|]
decl_stmt|,
name|wd2buf
index|[
name|MAXSTR
index|]
decl_stmt|;
name|int
name|first
decl_stmt|,
name|numch
decl_stmt|;
operator|*
name|wrd1
operator|=
name|wd1buf
expr_stmt|;
comment|/* return ptr to internal string*/
operator|*
name|wrd2
operator|=
name|wd2buf
expr_stmt|;
name|wd2buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case it isn't set here    */
for|for
control|(
name|s
operator|=
name|wd1buf
operator|,
name|first
operator|=
literal|1
operator|,
name|numch
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|getchar
argument_list|()
operator|)
operator|>=
literal|'A'
operator|&&
operator|*
name|s
operator|<=
literal|'Z'
condition|)
operator|*
name|s
operator|=
operator|*
name|s
operator|-
operator|(
literal|'A'
operator|-
literal|'a'
operator|)
expr_stmt|;
comment|/* convert to upper case        */
switch|switch
condition|(
operator|*
name|s
condition|)
comment|/* start reading from user      */
block|{
case|case
literal|'\n'
case|:
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|' '
case|:
if|if
condition|(
name|s
operator|==
name|wd1buf
operator|||
name|s
operator|==
name|wd2buf
condition|)
comment|/* initial blank   */
continue|continue;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
condition|)
comment|/* finished 1st wd; start 2nd   */
block|{
name|first
operator|=
name|numch
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|wd2buf
expr_stmt|;
break|break;
block|}
else|else
comment|/* finished 2nd word            */
block|{
name|FLUSHLINE
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
block|}
case|case
name|EOF
case|:
name|printf
argument_list|(
literal|"user closed input stream, quitting...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
operator|++
name|numch
operator|>=
name|MAXSTR
condition|)
comment|/* string too long      */
block|{
name|printf
argument_list|(
literal|"Give me a break!!\n"
argument_list|)
expr_stmt|;
name|wd1buf
index|[
literal|0
index|]
operator|=
name|wd2buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|FLUSHLINE
expr_stmt|;
return|return;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|yes
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|z
parameter_list|)
comment|/* confirm with rspeak          */
block|{
name|int
name|result
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rspeak
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* tell him what we want*/
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'y'
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|printf
argument_list|(
literal|"user closed input stream, quitting...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|FLUSHLINE
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|||
name|ch
operator|==
literal|'n'
condition|)
break|break;
name|printf
argument_list|(
literal|"Please answer the question.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TRUE
condition|)
name|rspeak
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|FALSE
condition|)
name|rspeak
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|yesm
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|z
parameter_list|)
comment|/* confirm with mspeak          */
block|{
name|int
name|result
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mspeak
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* tell him what we want*/
if|if
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'y'
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|printf
argument_list|(
literal|"user closed input stream, quitting...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|FLUSHLINE
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|||
name|ch
operator|==
literal|'n'
condition|)
break|break;
name|printf
argument_list|(
literal|"Please answer the question.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|TRUE
condition|)
name|mspeak
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|FALSE
condition|)
name|mspeak
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FILE *inbuf,*outbuf; */
end_comment

begin_decl_stmt
name|char
modifier|*
name|inptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer into virtual disk    */
end_comment

begin_decl_stmt
name|int
name|outsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* putting stuff to data file?  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|iotape
index|[]
init|=
literal|"Ax3F'\003tt$8h\315qer*h\017nGKrX\207:!l"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tape
init|=
name|iotape
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to encryption tape   */
end_comment

begin_function
specifier|static
name|int
name|next
parameter_list|(
name|void
parameter_list|)
comment|/* next virtual char, bump adr  */
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
operator|(
operator|*
name|inptr
operator|^
name|random
argument_list|()
operator|)
operator|&
literal|0xFF
expr_stmt|;
comment|/* Decrypt input data           */
if|if
condition|(
name|outsw
condition|)
comment|/* putting data in tmp file     */
block|{
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* rewind encryption tape       */
operator|*
name|inptr
operator|=
name|ch
operator|^
operator|*
name|tape
operator|++
expr_stmt|;
comment|/* re-encrypt and replace value */
block|}
name|inptr
operator|++
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|char
name|breakch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tell which char ended rnum   */
end_comment

begin_function
name|void
name|rdata
parameter_list|(
name|void
parameter_list|)
comment|/* "read" data from virtual file*/
block|{
name|int
name|sect
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|inptr
operator|=
name|data_file
expr_stmt|;
comment|/* Pointer to virtual data file */
name|srandom
argument_list|(
name|SEED
argument_list|)
expr_stmt|;
comment|/* which is lightly encrypted.  */
name|clsses
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* read data sections           */
block|{
name|sect
operator|=
name|next
argument_list|()
operator|-
literal|'0'
expr_stmt|;
comment|/* 1st digit of section number  */
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"Section %c"
argument_list|,
name|sect
operator|+
literal|'0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ch
operator|=
name|next
argument_list|()
operator|)
operator|!=
name|LF
condition|)
comment|/* is there a second digit?     */
block|{
name|FLUSHLF
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sect
operator|=
literal|10
operator|*
name|sect
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sect
condition|)
block|{
case|case
literal|0
case|:
comment|/* finished reading database    */
return|return;
case|case
literal|1
case|:
comment|/* long form descriptions       */
name|rdesc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* short form descriptions      */
name|rdesc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* travel table                 */
name|rtrav
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* vocabulary                   */
name|rvoc
argument_list|()
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* object descriptions          */
name|rdesc
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* arbitrary messages           */
name|rdesc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* object locations             */
name|rlocs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* action defaults              */
name|rdflt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* liquid assets                */
name|rliq
argument_list|()
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* class messages               */
name|rdesc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* hints                        */
name|rhints
argument_list|()
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* magic messages               */
name|rdesc
argument_list|(
literal|12
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Invalid data section number: %d\n"
argument_list|,
name|sect
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|putchar
argument_list|(
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|breakch
operator|!=
name|LF
condition|)
comment|/* routines return after "-1"   */
name|FLUSHLF
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|char
name|nbf
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rnum
parameter_list|(
name|void
parameter_list|)
comment|/* read initial location num    */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* restart encryption tape      */
for|for
control|(
name|s
operator|=
name|nbf
operator|,
operator|*
name|s
operator|=
literal|0
init|;
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|next
argument_list|()
operator|)
operator|==
name|TAB
operator|||
operator|*
name|s
operator|==
literal|'\n'
operator|||
operator|*
name|s
operator|==
name|LF
condition|)
break|break;
name|breakch
operator|=
operator|*
name|s
expr_stmt|;
comment|/* save char for rtrav()        */
operator|*
name|s
operator|=
literal|0
expr_stmt|;
comment|/* got the number as ascii      */
if|if
condition|(
name|nbf
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* end of data                  */
return|return
operator|(
name|atoi
argument_list|(
name|nbf
argument_list|)
operator|)
return|;
comment|/* convert it to integer        */
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|seekhere
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rdesc
parameter_list|(
name|int
name|sect
parameter_list|)
comment|/* read description-format msgs */
block|{
name|int
name|locc
decl_stmt|;
name|char
modifier|*
name|seekstart
decl_stmt|,
modifier|*
name|maystart
decl_stmt|;
name|seekhere
operator|=
name|inptr
expr_stmt|;
comment|/* Where are we in virtual file?*/
name|outsw
operator|=
literal|1
expr_stmt|;
comment|/* these msgs go into tmp file  */
for|for
control|(
name|oldloc
operator|=
operator|-
literal|1
operator|,
name|seekstart
operator|=
name|seekhere
init|;
condition|;
control|)
block|{
name|maystart
operator|=
name|inptr
expr_stmt|;
comment|/* maybe starting new entry     */
if|if
condition|(
operator|(
name|locc
operator|=
name|rnum
argument_list|()
operator|)
operator|!=
name|oldloc
operator|&&
name|oldloc
operator|>=
literal|0
comment|/* finished msg */
operator|&&
operator|!
operator|(
name|sect
operator|==
literal|5
operator|&&
operator|(
name|locc
operator|==
literal|0
operator|||
name|locc
operator|>=
literal|100
operator|)
operator|)
condition|)
comment|/* unless sect 5*/
block|{
switch|switch
condition|(
name|sect
condition|)
comment|/* now put it into right table  */
block|{
case|case
literal|1
case|:
comment|/* long descriptions            */
name|ltext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|ltext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* short descriptions           */
name|stext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|stext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* object descriptions          */
name|ptext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|ptext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* random messages              */
if|if
condition|(
name|oldloc
operator|>
name|RTXSIZ
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Too many random msgs"
argument_list|)
expr_stmt|;
block|}
name|rtext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|rtext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* class messages               */
name|ctext
index|[
name|clsses
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|ctext
index|[
name|clsses
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
name|cval
index|[
name|clsses
operator|++
index|]
operator|=
name|oldloc
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* magic messages               */
if|if
condition|(
name|oldloc
operator|>
name|MAGSIZ
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Too many magic msgs"
argument_list|)
expr_stmt|;
block|}
name|mtext
index|[
name|oldloc
index|]
operator|.
name|seekadr
operator|=
name|seekhere
expr_stmt|;
name|mtext
index|[
name|oldloc
index|]
operator|.
name|txtlen
operator|=
name|maystart
operator|-
name|seekstart
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"rdesc called with bad section"
argument_list|)
expr_stmt|;
block|}
name|seekhere
operator|+=
name|maystart
operator|-
name|seekstart
expr_stmt|;
block|}
if|if
condition|(
name|locc
operator|<
literal|0
condition|)
block|{
name|outsw
operator|=
literal|0
expr_stmt|;
comment|/* turn off output              */
name|seekhere
operator|+=
literal|3
expr_stmt|;
comment|/* -1<delimiter>                */
return|return;
block|}
if|if
condition|(
name|sect
operator|!=
literal|5
operator|||
operator|(
name|locc
operator|>
literal|0
operator|&&
name|locc
operator|<
literal|100
operator|)
condition|)
block|{
if|if
condition|(
name|oldloc
operator|!=
name|locc
condition|)
comment|/* starting a new message       */
name|seekstart
operator|=
name|maystart
expr_stmt|;
name|oldloc
operator|=
name|locc
expr_stmt|;
block|}
name|FLUSHLF
expr_stmt|;
comment|/* scan the line                */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rtrav
parameter_list|(
name|void
parameter_list|)
comment|/* read travel table            */
block|{
name|int
name|locc
decl_stmt|;
name|struct
name|travlist
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|,
name|entries
decl_stmt|;
name|entries
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|oldloc
operator|=
operator|-
literal|1
init|;
condition|;
control|)
comment|/* get another line             */
block|{
if|if
condition|(
operator|(
name|locc
operator|=
name|rnum
argument_list|()
operator|)
operator|!=
name|oldloc
operator|&&
name|oldloc
operator|>=
literal|0
condition|)
comment|/* end of entry */
block|{
name|t
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* terminate the old entry      */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"%d:%d entries\n"
argument_list|,
name|oldloc
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|twrite
argument_list|(
name|oldloc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|locc
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|locc
operator|!=
name|oldloc
condition|)
comment|/* getting a new entry         */
block|{
name|t
operator|=
name|travel
index|[
name|locc
index|]
operator|=
operator|(
expr|struct
name|travlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|travlist
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      printf("New travel list for %d\n",locc);        */
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory!"
argument_list|)
expr_stmt|;
name|entries
operator|=
literal|0
expr_stmt|;
name|oldloc
operator|=
name|locc
expr_stmt|;
block|}
name|s
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
name|s
operator|++
control|)
comment|/* get the newloc number /ASCII */
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|next
argument_list|()
operator|)
operator|==
name|TAB
operator|||
operator|*
name|s
operator|==
name|LF
condition|)
break|break;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* quad long number handling    */
comment|/*      printf("Newloc: %s (%d chars)\n",buf,len);              */
if|if
condition|(
name|len
operator|<
literal|4
condition|)
comment|/* no "m" conditions            */
block|{
name|m
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* newloc mod 1000 = newloc     */
block|}
else|else
comment|/* a long integer               */
block|{
name|n
operator|=
name|atoi
argument_list|(
name|buf
operator|+
name|len
operator|-
literal|3
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* terminate newloc/1000        */
name|m
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|breakch
operator|!=
name|LF
condition|)
comment|/* only do one line at a time   */
block|{
if|if
condition|(
name|entries
operator|++
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|next
operator|=
operator|(
expr|struct
name|travlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|travlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory!"
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|tverb
operator|=
name|rnum
argument_list|()
expr_stmt|;
comment|/* get verb from the file       */
name|t
operator|->
name|tloc
operator|=
name|n
expr_stmt|;
comment|/* table entry mod 1000         */
name|t
operator|->
name|conditions
operator|=
name|m
expr_stmt|;
comment|/* table entry / 1000           */
comment|/*      printf("entry %d for %d\n",entries,locc);       */
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|twrite
parameter_list|(
name|int
name|loq
parameter_list|)
comment|/* travel options from this loc */
block|{
name|struct
name|travlist
modifier|*
name|t
decl_stmt|;
name|printf
argument_list|(
literal|"If"
argument_list|)
expr_stmt|;
name|speak
argument_list|(
operator|&
name|ltext
index|[
name|loq
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"then\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|travel
index|[
name|loq
index|]
init|;
name|t
operator|!=
literal|0
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"verb %d takes you to "
argument_list|,
name|t
operator|->
name|tverb
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tloc
operator|<=
literal|300
condition|)
name|speak
argument_list|(
operator|&
name|ltext
index|[
name|t
operator|->
name|tloc
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|tloc
operator|<=
literal|500
condition|)
name|printf
argument_list|(
literal|"special code %d\n"
argument_list|,
name|t
operator|->
name|tloc
operator|-
literal|300
argument_list|)
expr_stmt|;
else|else
name|rspeak
argument_list|(
name|t
operator|->
name|tloc
operator|-
literal|500
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"under conditions %d\n"
argument_list|,
name|t
operator|->
name|conditions
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
specifier|static
name|void
name|rvoc
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* read the vocabulary          */
name|int
name|rv_index
decl_stmt|;
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rv_index
operator|=
name|rnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|rv_index
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|s
operator|=
name|buf
operator|,
operator|*
name|s
operator|=
literal|0
init|;
condition|;
name|s
operator|++
control|)
comment|/* get the word                 */
if|if
condition|(
operator|(
operator|*
name|s
operator|=
name|next
argument_list|()
operator|)
operator|==
name|TAB
operator|||
operator|*
name|s
operator|==
literal|'\n'
operator|||
operator|*
name|s
operator|==
name|LF
operator|||
operator|*
name|s
operator|==
literal|' '
condition|)
break|break;
comment|/* terminate word with newline, LF, tab, blank  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
name|LF
condition|)
name|FLUSHLF
expr_stmt|;
comment|/* can be comments    */
operator|*
name|s
operator|=
literal|0
expr_stmt|;
comment|/*      printf("\"%s\"=%d\n",buf,index);*/
name|vocab
argument_list|(
name|buf
argument_list|,
operator|-
literal|2
argument_list|,
name|rv_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rlocs
parameter_list|(
name|void
parameter_list|)
comment|/* initial object locations     */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|obj
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
name|plac
index|[
name|obj
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
comment|/* initial loc for this obj     */
if|if
condition|(
name|breakch
operator|==
name|TAB
condition|)
comment|/* there's another entry        */
name|fixd
index|[
name|obj
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
else|else
name|fixd
index|[
name|obj
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rdflt
parameter_list|(
name|void
parameter_list|)
comment|/* default verb messages        */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|verb
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
name|actspk
index|[
name|verb
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rliq
parameter_list|(
name|void
parameter_list|)
comment|/* liquid assets&c: cond bits  */
block|{
name|int
name|bitnum
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* read new bit list            */
block|{
if|if
condition|(
operator|(
name|bitnum
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
for|for
control|(
init|;
condition|;
control|)
comment|/* read locs for bits           */
block|{
name|cond
index|[
name|rnum
argument_list|()
index|]
operator||=
name|setbit
index|[
name|bitnum
index|]
expr_stmt|;
if|if
condition|(
name|breakch
operator|==
name|LF
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rhints
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|hintnum
decl_stmt|,
name|i
decl_stmt|;
name|hntmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|hintnum
operator|=
name|rnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|hints
index|[
name|hintnum
index|]
index|[
name|i
index|]
operator|=
name|rnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|hintnum
operator|>
name|hntmax
condition|)
name|hntmax
operator|=
name|hintnum
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rspeak
parameter_list|(
name|int
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|speak
argument_list|(
operator|&
name|rtext
index|[
name|msg
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mspeak
parameter_list|(
name|int
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|!=
literal|0
condition|)
name|speak
argument_list|(
operator|&
name|mtext
index|[
name|msg
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read, decrypt, and print a message (not ptext)      */
end_comment

begin_comment
comment|/* msg is a pointer to seek address and length of mess */
end_comment

begin_function
name|void
name|speak
parameter_list|(
specifier|const
name|struct
name|text
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|nonfirst
decl_stmt|;
name|s
operator|=
name|msg
operator|->
name|seekadr
expr_stmt|;
name|nonfirst
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|-
name|msg
operator|->
name|seekadr
operator|<
name|msg
operator|->
name|txtlen
condition|)
comment|/* read a line at a time */
block|{
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* restart decryption tape      */
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|TAB
condition|)
empty_stmt|;
comment|/* read past loc num       */
comment|/* assume tape is longer than location number           */
comment|/*   plus the lookahead put together                    */
if|if
condition|(
operator|(
operator|*
name|s
operator|^
operator|*
name|tape
operator|)
operator|==
literal|'>'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|1
operator|)
operator|)
operator|==
literal|'$'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|2
operator|)
operator|)
operator|==
literal|'<'
condition|)
break|break;
if|if
condition|(
name|blklin
operator|&&
operator|!
name|nonfirst
operator|++
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* rewind decryp tape */
name|putchar
argument_list|(
operator|*
name|s
operator|^
operator|*
name|tape
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|LF
condition|)
do|;
comment|/* better end with LF   */
block|}
block|}
end_function

begin_comment
comment|/* read, decrypt an print a ptext message              */
end_comment

begin_comment
comment|/* msg is the number of all the p msgs for this place  */
end_comment

begin_comment
comment|/* assumes object 1 doesn't have prop 1, obj 2 no prop 2&c*/
end_comment

begin_function
name|void
name|pspeak
parameter_list|(
name|int
name|m
parameter_list|,
name|int
name|skip
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|nonfirst
decl_stmt|;
name|char
modifier|*
name|numst
decl_stmt|,
name|ps_save
decl_stmt|;
name|struct
name|text
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|tbuf
decl_stmt|;
name|msg
operator|=
operator|&
name|ptext
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tbuf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|msg
operator|->
name|txtlen
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory!"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tbuf
argument_list|,
name|msg
operator|->
name|seekadr
argument_list|,
operator|(
name|size_t
operator|)
name|msg
operator|->
name|txtlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Room to null */
name|s
operator|=
name|tbuf
expr_stmt|;
name|nonfirst
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|-
name|tbuf
operator|<
name|msg
operator|->
name|txtlen
condition|)
comment|/* read line at a time */
block|{
name|tape
operator|=
name|iotape
expr_stmt|;
comment|/* restart decryption tape      */
for|for
control|(
name|numst
operator|=
name|s
init|;
operator|(
operator|*
name|s
operator|^=
operator|*
name|tape
operator|++
operator|)
operator|!=
name|TAB
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* get number  */
name|ps_save
operator|=
operator|*
name|s
expr_stmt|;
comment|/* Temporarily trash the string (cringe) */
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* decrypting number within the string          */
if|if
condition|(
name|atoi
argument_list|(
name|numst
argument_list|)
operator|!=
literal|100
operator|*
name|skip
operator|&&
name|skip
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|LF
condition|)
comment|/* flush the line    */
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|*
name|s
operator|^
operator|*
name|tape
operator|)
operator|==
literal|'>'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|1
operator|)
operator|)
operator|==
literal|'$'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
operator|^
operator|*
operator|(
name|tape
operator|+
literal|2
operator|)
operator|)
operator|==
literal|'<'
condition|)
break|break;
if|if
condition|(
name|blklin
operator|&&
operator|!
name|nonfirst
operator|++
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|tape
operator|==
literal|0
condition|)
name|tape
operator|=
name|iotape
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator|^
operator|*
name|tape
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|s
operator|++
operator|^
operator|*
name|tape
operator|++
operator|)
operator|!=
name|LF
condition|)
do|;
comment|/* better end with LF   */
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
break|break;
block|}
name|free
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

