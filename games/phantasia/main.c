begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Phantasia 3.3.2 -- Interterminal fantasy game  *  * Edward A. Estes  * AT&T, March 12, 1986  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* DISCLAIMER:  *  * This game is distributed for free as is.  It is not guaranteed to work  * in every conceivable environment.  It is not even guaranteed to work  * in ANY environment.  *  * This game is distributed without notice of copyright, therefore it  * may be used in any manner the recipient sees fit.  However, the  * author assumes no responsibility for maintaining or revising this  * game, in its original form, or any derivitives thereof.  *  * The author shall not be responsible for any loss, cost, or damage,  * including consequential damage, caused by reliance on this material.  *  * The author makes no warranties, express or implied, including warranties  * of merchantability or fitness for a particular purpose or use.  *  * AT&T is in no way connected with this game.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  * The program allocates as much file space as it needs to store characters,  * so the possibility exists for the character file to grow without bound.  * The file is purged upon normal entry to try to avoid that problem.  * A similar problem exists for energy voids.  To alleviate the problem here,  * the void file is cleared with every new king, and a limit is placed  * on the size of the energy void file.  */
end_comment

begin_comment
comment|/*  * Put one line of text into the file 'motd' for announcements, etc.  */
end_comment

begin_comment
comment|/*  * The scoreboard file is updated when someone dies, and keeps track  * of the highest character to date for that login.  * Being purged from the character file does not cause the scoreboard  * to be updated.  */
end_comment

begin_comment
comment|/*  * All source files are set up for 'vi' with shiftwidth=4, tabstop=8.  */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * main.c	Main routines for Phantasia  */
end_comment

begin_include
include|#
directive|include
file|"include.h"
end_include

begin_comment
comment|/*************************************************************************** / FUNCTION NAME: main() / / FUNCTION: initialize state, and call main process / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: /	int	argc - argument count /	char	**argv - argument vector / / RETURN VALUE: none / / MODULES CALLED: monstlist(), checkenemy(), activelist(), /	throneroom(), checkbattle(), readmessage(), changestats(), writerecord(), /	tradingpost(), adjuststats(), recallplayer(), displaystats(), checktampered(), /	fabs(), rollnewplayer(), time(), exit(), sqrt(), floor(), wmove(), /	signal(), strcat(), purgeoldplayers(), getuid(), isatty(), wclear(), /	strcpy(), system(), altercoordinates(), cleanup(), waddstr(), procmain(), /	playinit(), leavegame(), localtime(), getanswer(), neatstuff(), initialstate(), /	scorelist(), titlelist() / / GLOBAL INPUTS: *Login, Throne, Wizard, Player, *stdscr, Changed, Databuf[], /	Fileloc, Stattable[] / / GLOBAL OUTPUTS: Wizard, Player, Changed, Fileloc, Timeout, *Statptr / / DESCRIPTION: /	Process arguments, initialize program, and loop forever processing /	player input. / ****************************************************************************/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|bool
name|noheader
init|=
name|FALSE
decl_stmt|;
comment|/* set if don't want header */
name|bool
name|headeronly
init|=
name|FALSE
decl_stmt|;
comment|/* set if only want header */
name|bool
name|examine
init|=
name|FALSE
decl_stmt|;
comment|/* set if examine a character */
name|time_t
name|seconds
decl_stmt|;
comment|/* for time of day */
name|double
name|dtemp
decl_stmt|;
comment|/* for temporary calculations */
name|initialstate
argument_list|()
expr_stmt|;
comment|/* init globals */
comment|/* process arguments */
while|while
condition|(
operator|--
name|argc
operator|&&
operator|(
operator|*
operator|++
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* short */
name|noheader
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Header */
name|headeronly
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* all users */
name|activelist
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|'p'
case|:
comment|/* purge old players */
name|purgeoldplayers
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|'S'
case|:
comment|/* set 'Wizard' */
name|Wizard
operator|=
operator|!
name|getuid
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* examine */
name|examine
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* monsters */
name|monstlist
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|'b'
case|:
comment|/* scoreboard */
name|scorelist
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
comment|/* don't let non-tty's play */
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|playinit
argument_list|()
expr_stmt|;
comment|/* set up to catch signals, init curses */
if|if
condition|(
name|examine
condition|)
block|{
name|changestats
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|!
name|noheader
condition|)
block|{
name|titlelist
argument_list|()
expr_stmt|;
name|purgeoldplayers
argument_list|()
expr_stmt|;
comment|/* clean up old characters */
block|}
if|if
condition|(
name|headeronly
condition|)
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
do|do
comment|/* get the player structure filled */
block|{
name|Fileloc
operator|=
operator|-
literal|1L
expr_stmt|;
name|mvaddstr
argument_list|(
literal|22
argument_list|,
literal|17
argument_list|,
literal|"Do you have a character to run [Q = Quit] ? "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|getanswer
argument_list|(
literal|"NYQ"
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
case|case
literal|'Y'
case|:
name|Fileloc
operator|=
name|recallplayer
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
name|Fileloc
operator|=
name|rollnewplayer
argument_list|()
expr_stmt|;
break|break;
block|}
name|clear
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|Fileloc
operator|<
literal|0L
condition|)
do|;
if|if
condition|(
name|Player
operator|.
name|p_level
operator|>
literal|5.0
condition|)
comment|/* low level players have long timeout */
name|Timeout
operator|=
name|TRUE
expr_stmt|;
comment|/* update some important player statistics */
name|strcpy
argument_list|(
name|Player
operator|.
name|p_login
argument_list|,
name|Login
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|seconds
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_lastused
operator|=
name|localtime
argument_list|(
operator|&
name|seconds
argument_list|)
operator|->
name|tm_yday
expr_stmt|;
name|Player
operator|.
name|p_status
operator|=
name|S_PLAYING
expr_stmt|;
name|writerecord
argument_list|(
operator|&
name|Player
argument_list|,
name|Fileloc
argument_list|)
expr_stmt|;
name|Statptr
operator|=
operator|&
name|Stattable
index|[
name|Player
operator|.
name|p_type
index|]
expr_stmt|;
comment|/* initialize pointer */
comment|/* catch interrupts */
ifdef|#
directive|ifdef
name|BSD41
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD42
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS3
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS5
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|altercoordinates
argument_list|(
name|Player
operator|.
name|p_x
argument_list|,
name|Player
operator|.
name|p_y
argument_list|,
name|A_FORCED
argument_list|)
expr_stmt|;
comment|/* set some flags */
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* loop forever, processing input */
block|{
name|adjuststats
argument_list|()
expr_stmt|;
comment|/* cleanup stats */
if|if
condition|(
name|Throne
operator|&&
name|Player
operator|.
name|p_crowns
operator|==
literal|0
operator|&&
name|Player
operator|.
name|p_specialtype
operator|!=
name|SC_KING
condition|)
comment|/* not allowed on throne -- move */
block|{
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"You're not allowed in the Lord's Chamber without a crown.\n"
argument_list|)
expr_stmt|;
name|altercoordinates
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
name|A_NEAR
argument_list|)
expr_stmt|;
block|}
name|checktampered
argument_list|()
expr_stmt|;
comment|/* check for energy voids, etc. */
if|if
condition|(
name|Player
operator|.
name|p_status
operator|!=
name|S_CLOAKED
comment|/* not cloaked */
operator|&&
operator|(
name|dtemp
operator|=
name|fabs
argument_list|(
name|Player
operator|.
name|p_x
argument_list|)
operator|)
operator|==
name|fabs
argument_list|(
name|Player
operator|.
name|p_y
argument_list|)
comment|/* |x| = |y| */
operator|&&
operator|!
name|Throne
condition|)
comment|/* not on throne */
block|{
name|dtemp
operator|=
name|sqrt
argument_list|(
name|dtemp
operator|/
literal|100.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|floor
argument_list|(
name|dtemp
argument_list|)
operator|==
name|dtemp
condition|)
comment|/* |x| / 100 == n*n; at a trading post */
block|{
name|tradingpost
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
name|checkbattle
argument_list|()
expr_stmt|;
comment|/* check for player to player battle */
name|neatstuff
argument_list|()
expr_stmt|;
comment|/* gurus, medics, etc. */
if|if
condition|(
name|Player
operator|.
name|p_status
operator|==
name|S_CLOAKED
condition|)
comment|/* costs 3 mana per turn to be cloaked */
if|if
condition|(
name|Player
operator|.
name|p_mana
operator|>
literal|3.0
condition|)
name|Player
operator|.
name|p_mana
operator|-=
literal|3.0
expr_stmt|;
else|else
comment|/* ran out of mana, uncloak */
block|{
name|Player
operator|.
name|p_status
operator|=
name|S_PLAYING
expr_stmt|;
name|Changed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|Player
operator|.
name|p_status
operator|!=
name|S_PLAYING
operator|&&
name|Player
operator|.
name|p_status
operator|!=
name|S_CLOAKED
condition|)
comment|/* change status back to S_PLAYING */
block|{
name|Player
operator|.
name|p_status
operator|=
name|S_PLAYING
expr_stmt|;
name|Changed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|Changed
condition|)
comment|/* update file only if important stuff has changed */
block|{
name|writerecord
argument_list|(
operator|&
name|Player
argument_list|,
name|Fileloc
argument_list|)
expr_stmt|;
name|Changed
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|readmessage
argument_list|()
expr_stmt|;
comment|/* read message, if any */
name|displaystats
argument_list|()
expr_stmt|;
comment|/* print statistics */
name|move
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Throne
condition|)
comment|/* maybe make king, print prompt, etc. */
name|throneroom
argument_list|()
expr_stmt|;
comment|/* print status line */
name|addstr
argument_list|(
literal|"1:Move  2:Players  3:Talk  4:Stats  5:Quit  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_level
operator|>=
name|MEL_CLOAK
operator|&&
name|Player
operator|.
name|p_magiclvl
operator|>=
name|ML_CLOAK
condition|)
name|addstr
argument_list|(
literal|"6:Cloak  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_level
operator|>=
name|MEL_TELEPORT
operator|&&
name|Player
operator|.
name|p_magiclvl
operator|>=
name|ML_TELEPORT
condition|)
name|addstr
argument_list|(
literal|"7:Teleport  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_specialtype
operator|>=
name|SC_COUNCIL
operator|||
name|Wizard
condition|)
name|addstr
argument_list|(
literal|"8:Intervene  "
argument_list|)
expr_stmt|;
name|procmain
argument_list|()
expr_stmt|;
comment|/* process input */
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: initialstate() / / FUNCTION: initialize some important global variable / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: time(), fopen(), srandom(), error(), getuid(), getlogin(), /	getpwuid() / / GLOBAL INPUTS: / / GLOBAL OUTPUTS: *Energyvoidfp, Echo, Marsh, *Login, Users, Beyond, /	Throne, Wizard, Changed, Okcount, Timeout, Windows, *Monstfp, *Messagefp, /	*Playersfp / / DESCRIPTION: /	Set global flags, and open files which remain open. / *************************************************************************/
end_comment

begin_macro
name|initialstate
argument_list|()
end_macro

begin_block
block|{
name|Beyond
operator|=
name|FALSE
expr_stmt|;
name|Marsh
operator|=
name|FALSE
expr_stmt|;
name|Throne
operator|=
name|FALSE
expr_stmt|;
name|Changed
operator|=
name|FALSE
expr_stmt|;
name|Wizard
operator|=
name|FALSE
expr_stmt|;
name|Timeout
operator|=
name|FALSE
expr_stmt|;
name|Users
operator|=
literal|0
expr_stmt|;
name|Windows
operator|=
name|FALSE
expr_stmt|;
name|Echo
operator|=
name|TRUE
expr_stmt|;
comment|/* setup login name */
if|if
condition|(
operator|(
name|Login
operator|=
name|getlogin
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|Login
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|->
name|pw_name
expr_stmt|;
comment|/* open some files */
if|if
condition|(
operator|(
name|Playersfp
operator|=
name|fopen
argument_list|(
name|_PATH_PEOPLE
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_PATH_PEOPLE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
if|if
condition|(
operator|(
name|Monstfp
operator|=
name|fopen
argument_list|(
name|_PATH_MONST
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_PATH_MONST
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
if|if
condition|(
operator|(
name|Messagefp
operator|=
name|fopen
argument_list|(
name|_PATH_MESS
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_PATH_MESS
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
if|if
condition|(
operator|(
name|Energyvoidfp
operator|=
name|fopen
argument_list|(
name|_PATH_VOID
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_PATH_VOID
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|srandomdev
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: rollnewplayer() / / FUNCTION: roll up a new character / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: initplayer(), allocrecord(), truncstring(), fabs(), wmove(), /	wclear(), sscanf(), strcmp(), genchar(), waddstr(), findname(), mvprintw(), /	getanswer(), getstring() / / GLOBAL INPUTS: Other, Wizard, Player, *stdscr, Databuf[] / / GLOBAL OUTPUTS: Echo / / DESCRIPTION: /	Prompt player, and roll up new character. / *************************************************************************/
end_comment

begin_function
name|long
name|rollnewplayer
parameter_list|()
block|{
name|int
name|chartype
decl_stmt|;
comment|/* character type */
name|int
name|ch
decl_stmt|;
comment|/* input */
name|initplayer
argument_list|(
operator|&
name|Player
argument_list|)
expr_stmt|;
comment|/* initialize player structure */
name|clear
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|21
argument_list|,
literal|"Which type of character do you want:"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|8
argument_list|,
literal|4
argument_list|,
literal|"1:Magic User  2:Fighter  3:Elf  4:Dwarf  5:Halfling  6:Experimento  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|Wizard
condition|)
block|{
name|addstr
argument_list|(
literal|"7:Super  ? "
argument_list|)
expr_stmt|;
name|chartype
operator|=
name|getanswer
argument_list|(
literal|"1234567"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addstr
argument_list|(
literal|"?  "
argument_list|)
expr_stmt|;
name|chartype
operator|=
name|getanswer
argument_list|(
literal|"123456"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|genchar
argument_list|(
name|chartype
argument_list|)
expr_stmt|;
comment|/* roll up a character */
comment|/* print out results */
name|mvprintw
argument_list|(
literal|12
argument_list|,
literal|14
argument_list|,
literal|"Strength    :  %2.0f  Quickness:  %2.0f  Mana       :  %2.0f\n"
argument_list|,
name|Player
operator|.
name|p_strength
argument_list|,
name|Player
operator|.
name|p_quickness
argument_list|,
name|Player
operator|.
name|p_mana
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|13
argument_list|,
literal|14
argument_list|,
literal|"Energy Level:  %2.0f  Brains   :  %2.0f  Magic Level:  %2.0f\n"
argument_list|,
name|Player
operator|.
name|p_energy
argument_list|,
name|Player
operator|.
name|p_brains
argument_list|,
name|Player
operator|.
name|p_magiclvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_type
operator|==
name|C_EXPER
operator|||
name|Player
operator|.
name|p_type
operator|==
name|C_SUPER
condition|)
break|break;
name|mvaddstr
argument_list|(
literal|14
argument_list|,
literal|14
argument_list|,
literal|"Type '1' to keep>"
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getanswer
argument_list|(
literal|" "
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'1'
condition|)
do|;
if|if
condition|(
name|Player
operator|.
name|p_type
operator|==
name|C_EXPER
operator|||
name|Player
operator|.
name|p_type
operator|==
name|C_SUPER
condition|)
comment|/* get coordinates for experimento */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mvaddstr
argument_list|(
literal|16
argument_list|,
literal|0
argument_list|,
literal|"Enter the X Y coordinates of your experimento ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|Databuf
argument_list|,
literal|"%lf %lf"
argument_list|,
operator|&
name|Player
operator|.
name|p_x
argument_list|,
operator|&
name|Player
operator|.
name|p_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|Player
operator|.
name|p_x
argument_list|)
operator|>
name|D_EXPER
operator|||
name|fabs
argument_list|(
name|Player
operator|.
name|p_y
argument_list|)
operator|>
name|D_EXPER
condition|)
name|mvaddstr
argument_list|(
literal|17
argument_list|,
literal|0
argument_list|,
literal|"Invalid coordinates.  Try again.\n"
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
init|;
condition|;
control|)
comment|/* name the new character */
block|{
name|mvprintw
argument_list|(
literal|18
argument_list|,
literal|0
argument_list|,
literal|"Give your character a name [up to %d characters] ?  "
argument_list|,
name|SZ_NAME
operator|-
literal|1
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Player
operator|.
name|p_name
argument_list|,
name|SZ_NAME
argument_list|)
expr_stmt|;
name|truncstring
argument_list|(
name|Player
operator|.
name|p_name
argument_list|)
expr_stmt|;
comment|/* remove trailing blanks */
if|if
condition|(
name|Player
operator|.
name|p_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* no null names */
name|mvaddstr
argument_list|(
literal|19
argument_list|,
literal|0
argument_list|,
literal|"Invalid name."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|findname
argument_list|(
name|Player
operator|.
name|p_name
argument_list|,
operator|&
name|Other
argument_list|)
operator|>=
literal|0L
condition|)
comment|/* cannot have duplicate names */
name|mvaddstr
argument_list|(
literal|19
argument_list|,
literal|0
argument_list|,
literal|"Name already in use."
argument_list|)
expr_stmt|;
else|else
comment|/* name is acceptable */
break|break;
name|addstr
argument_list|(
literal|"  Pick another.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* get a password for character */
name|Echo
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"Give your character a password [up to 8 characters] ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Player
operator|.
name|p_password
argument_list|,
name|SZ_PASSWORD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|,
literal|"One more time to verify ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Databuf
argument_list|,
name|SZ_PASSWORD
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|strcmp
argument_list|(
name|Player
operator|.
name|p_password
argument_list|,
name|Databuf
argument_list|)
operator|!=
literal|0
condition|)
do|;
name|Echo
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|allocrecord
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: procmain() / / FUNCTION: process input from player / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: dotampered(), changestats(), inputoption(), allstatslist(), /	fopen(), wmove(), drandom(), sscanf(), fclose(), altercoordinates(), /	waddstr(), fprintf(), distance(), userlist(), leavegame(), encounter(), /	getstring(), wclrtobot() / / GLOBAL INPUTS: Circle, Illcmd[], Throne, Wizard, Player, *stdscr, /	Databuf[], Illmove[] / / GLOBAL OUTPUTS: Player, Changed / / DESCRIPTION: /	Process main menu options. / *************************************************************************/
end_comment

begin_macro
name|procmain
argument_list|()
end_macro

begin_block
block|{
name|int
name|ch
decl_stmt|;
comment|/* input */
name|double
name|x
decl_stmt|;
comment|/* desired new x coordinate */
name|double
name|y
decl_stmt|;
comment|/* desired new y coordinate */
name|double
name|temp
decl_stmt|;
comment|/* for temporary calculations */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* for opening files */
specifier|register
name|int
name|loop
decl_stmt|;
comment|/* a loop counter */
name|bool
name|hasmoved
init|=
name|FALSE
decl_stmt|;
comment|/* set if player has moved */
name|ch
operator|=
name|inputoption
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
comment|/* clear status area */
name|move
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
comment|/* clear data on bottom area of screen */
if|if
condition|(
name|Player
operator|.
name|p_specialtype
operator|==
name|SC_VALAR
operator|&&
operator|(
name|ch
operator|==
literal|'1'
operator|||
name|ch
operator|==
literal|'7'
operator|)
condition|)
comment|/* valar cannot move */
name|ch
operator|=
literal|' '
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'K'
case|:
comment|/* move up/north */
case|case
literal|'N'
case|:
name|x
operator|=
name|Player
operator|.
name|p_x
expr_stmt|;
name|y
operator|=
name|Player
operator|.
name|p_y
operator|+
name|MAXMOVE
argument_list|()
expr_stmt|;
name|hasmoved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* move down/south */
case|case
literal|'S'
case|:
name|x
operator|=
name|Player
operator|.
name|p_x
expr_stmt|;
name|y
operator|=
name|Player
operator|.
name|p_y
operator|-
name|MAXMOVE
argument_list|()
expr_stmt|;
name|hasmoved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* move right/east */
case|case
literal|'E'
case|:
name|x
operator|=
name|Player
operator|.
name|p_x
operator|+
name|MAXMOVE
argument_list|()
expr_stmt|;
name|y
operator|=
name|Player
operator|.
name|p_y
expr_stmt|;
name|hasmoved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* move left/west */
case|case
literal|'W'
case|:
name|x
operator|=
name|Player
operator|.
name|p_x
operator|-
name|MAXMOVE
argument_list|()
expr_stmt|;
name|y
operator|=
name|Player
operator|.
name|p_y
expr_stmt|;
name|hasmoved
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* rest */
name|Player
operator|.
name|p_energy
operator|+=
operator|(
name|Player
operator|.
name|p_maxenergy
operator|+
name|Player
operator|.
name|p_shield
operator|)
operator|/
literal|15.0
operator|+
name|Player
operator|.
name|p_level
operator|/
literal|3.0
operator|+
literal|2.0
expr_stmt|;
name|Player
operator|.
name|p_energy
operator|=
name|MIN
argument_list|(
name|Player
operator|.
name|p_energy
argument_list|,
name|Player
operator|.
name|p_maxenergy
operator|+
name|Player
operator|.
name|p_shield
argument_list|)
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_status
operator|!=
name|S_CLOAKED
condition|)
comment|/* cannot find mana if cloaked */
block|{
name|Player
operator|.
name|p_mana
operator|+=
operator|(
name|Circle
operator|+
name|Player
operator|.
name|p_level
operator|)
operator|/
literal|4.0
expr_stmt|;
if|if
condition|(
name|drandom
argument_list|()
operator|<
literal|0.2
operator|&&
name|Player
operator|.
name|p_status
operator|==
name|S_PLAYING
operator|&&
operator|!
name|Throne
condition|)
comment|/* wandering monster */
name|encounter
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
comment|/* change/examine a character */
name|changestats
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* move */
for|for
control|(
name|loop
operator|=
literal|3
init|;
name|loop
condition|;
operator|--
name|loop
control|)
block|{
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"X Y Coordinates ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|Databuf
argument_list|,
literal|"%lf %lf"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
operator|!=
literal|2
condition|)
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Try again\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|distance
argument_list|(
name|Player
operator|.
name|p_x
argument_list|,
name|x
argument_list|,
name|Player
operator|.
name|p_y
argument_list|,
name|y
argument_list|)
operator|>
name|MAXMOVE
argument_list|()
condition|)
name|ILLMOVE
argument_list|()
expr_stmt|;
else|else
block|{
name|hasmoved
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'2'
case|:
comment|/* players */
name|userlist
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
comment|/* message */
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Message ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|)
expr_stmt|;
comment|/* we open the file for writing to erase any data which is already there */
name|fp
operator|=
name|fopen
argument_list|(
name|_PATH_MESS
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Databuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: %s"
argument_list|,
name|Player
operator|.
name|p_name
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
comment|/* stats */
name|allstatslist
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
comment|/* good-bye */
name|leavegame
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|'6'
case|:
comment|/* cloak */
if|if
condition|(
name|Player
operator|.
name|p_level
operator|<
name|MEL_CLOAK
operator|||
name|Player
operator|.
name|p_magiclvl
operator|<
name|ML_CLOAK
condition|)
name|ILLCMD
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|Player
operator|.
name|p_status
operator|==
name|S_CLOAKED
condition|)
name|Player
operator|.
name|p_status
operator|=
name|S_PLAYING
expr_stmt|;
elseif|else
if|if
condition|(
name|Player
operator|.
name|p_mana
operator|<
name|MM_CLOAK
condition|)
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"No mana left.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|Changed
operator|=
name|TRUE
expr_stmt|;
name|Player
operator|.
name|p_mana
operator|-=
name|MM_CLOAK
expr_stmt|;
name|Player
operator|.
name|p_status
operator|=
name|S_CLOAKED
expr_stmt|;
block|}
break|break;
case|case
literal|'7'
case|:
comment|/* teleport */
comment|/* 	     * conditions for teleport 	     *	- 20 per (level plus magic level) 	     *	- OR council of the wise or valar or ex-valar 	     *	- OR transport from throne 	     * transports from throne cost no mana 	     */
if|if
condition|(
name|Player
operator|.
name|p_level
operator|<
name|MEL_TELEPORT
operator|||
name|Player
operator|.
name|p_magiclvl
operator|<
name|ML_TELEPORT
condition|)
name|ILLCMD
argument_list|()
expr_stmt|;
else|else
for|for
control|(
name|loop
operator|=
literal|3
init|;
name|loop
condition|;
operator|--
name|loop
control|)
block|{
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"X Y Coordinates ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|Databuf
argument_list|,
literal|"%lf %lf"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
operator|==
literal|2
condition|)
block|{
name|temp
operator|=
name|distance
argument_list|(
name|Player
operator|.
name|p_x
argument_list|,
name|x
argument_list|,
name|Player
operator|.
name|p_y
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Throne
comment|/* can transport anywhere from throne */
operator|&&
name|Player
operator|.
name|p_specialtype
operator|<=
name|SC_COUNCIL
comment|/* council, valar can transport anywhere */
operator|&&
name|temp
operator|>
operator|(
name|Player
operator|.
name|p_level
operator|+
name|Player
operator|.
name|p_magiclvl
operator|)
operator|*
literal|20.0
condition|)
comment|/* can only move 20 per exp. level + mag. level */
name|ILLMOVE
argument_list|()
expr_stmt|;
else|else
block|{
name|temp
operator|=
operator|(
name|temp
operator|/
literal|75.0
operator|+
literal|1.0
operator|)
operator|*
literal|20.0
expr_stmt|;
comment|/* mana used */
if|if
condition|(
operator|!
name|Throne
operator|&&
name|temp
operator|>
name|Player
operator|.
name|p_mana
condition|)
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Not enough power for that distance.\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|Throne
condition|)
name|Player
operator|.
name|p_mana
operator|-=
name|temp
expr_stmt|;
name|hasmoved
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'9'
case|:
comment|/* monster */
if|if
condition|(
name|Throne
condition|)
comment|/* no monsters while on throne */
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"No monsters in the chamber!\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Player
operator|.
name|p_specialtype
operator|!=
name|SC_VALAR
condition|)
comment|/* the valar cannot call monsters */
block|{
name|Player
operator|.
name|p_sin
operator|+=
literal|1e-6
expr_stmt|;
name|encounter
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'0'
case|:
comment|/* decree */
if|if
condition|(
name|Wizard
operator|||
name|Player
operator|.
name|p_specialtype
operator|==
name|SC_KING
operator|&&
name|Throne
condition|)
comment|/* kings must be on throne to decree */
name|dotampered
argument_list|()
expr_stmt|;
else|else
name|ILLCMD
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
comment|/* intervention */
if|if
condition|(
name|Wizard
operator|||
name|Player
operator|.
name|p_specialtype
operator|>=
name|SC_COUNCIL
condition|)
name|dotampered
argument_list|()
expr_stmt|;
else|else
name|ILLCMD
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hasmoved
condition|)
comment|/* player has moved -- alter coordinates, and do random monster */
block|{
name|altercoordinates
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|A_SPECIFIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|drandom
argument_list|()
operator|<
literal|0.2
operator|&&
name|Player
operator|.
name|p_status
operator|==
name|S_PLAYING
operator|&&
operator|!
name|Throne
condition|)
name|encounter
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: titlelist() / / FUNCTION: print title page / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: fread(), fseek(), fopen(), fgets(), wmove(), strcpy(), /	fclose(), strlen(), waddstr(), sprintf(), wrefresh() / / GLOBAL INPUTS: Lines, Other, *stdscr, Databuf[], *Playersfp / / GLOBAL OUTPUTS: Lines / / DESCRIPTION: /	Print important information about game, players, etc. / *************************************************************************/
end_comment

begin_macro
name|titlelist
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* used for opening various files */
name|bool
name|councilfound
init|=
name|FALSE
decl_stmt|;
comment|/* set if we find a member of the council */
name|bool
name|kingfound
init|=
name|FALSE
decl_stmt|;
comment|/* set if we find a king */
name|double
name|hiexp
decl_stmt|,
name|nxtexp
decl_stmt|;
comment|/* used for finding the two highest players */
name|double
name|hilvl
decl_stmt|,
name|nxtlvl
decl_stmt|;
comment|/* used for finding the two highest players */
name|char
name|hiname
index|[
literal|21
index|]
decl_stmt|,
name|nxtname
index|[
literal|21
index|]
decl_stmt|;
comment|/* used for finding the two highest players */
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|14
argument_list|,
literal|"W e l c o m e   t o   P h a n t a s i a (vers. 3.3.2)!"
argument_list|)
expr_stmt|;
comment|/* print message of the day */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|_PATH_MOTD
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|fgets
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mvaddstr
argument_list|(
literal|2
argument_list|,
literal|40
operator|-
name|strlen
argument_list|(
name|Databuf
argument_list|)
operator|/
literal|2
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* search for king */
name|fseek
argument_list|(
name|Playersfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Other
argument_list|,
name|SZ_PLAYERSTRUCT
argument_list|,
literal|1
argument_list|,
name|Playersfp
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|Other
operator|.
name|p_specialtype
operator|==
name|SC_KING
operator|&&
name|Other
operator|.
name|p_status
operator|!=
name|S_NOTUSED
condition|)
comment|/* found the king */
block|{
name|sprintf
argument_list|(
name|Databuf
argument_list|,
literal|"The present ruler is %s  Level:%.0f"
argument_list|,
name|Other
operator|.
name|p_name
argument_list|,
name|Other
operator|.
name|p_level
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|40
operator|-
name|strlen
argument_list|(
name|Databuf
argument_list|)
operator|/
literal|2
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
name|kingfound
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|kingfound
condition|)
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|24
argument_list|,
literal|"There is no ruler at this time."
argument_list|)
expr_stmt|;
comment|/* search for valar */
name|fseek
argument_list|(
name|Playersfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Other
argument_list|,
name|SZ_PLAYERSTRUCT
argument_list|,
literal|1
argument_list|,
name|Playersfp
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|Other
operator|.
name|p_specialtype
operator|==
name|SC_VALAR
operator|&&
name|Other
operator|.
name|p_status
operator|!=
name|S_NOTUSED
condition|)
comment|/* found the valar */
block|{
name|sprintf
argument_list|(
name|Databuf
argument_list|,
literal|"The Valar is %s   Login:  %s"
argument_list|,
name|Other
operator|.
name|p_name
argument_list|,
name|Other
operator|.
name|p_login
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|6
argument_list|,
literal|40
operator|-
name|strlen
argument_list|(
name|Databuf
argument_list|)
operator|/
literal|2
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* search for council of the wise */
name|fseek
argument_list|(
name|Playersfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Lines
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Other
argument_list|,
name|SZ_PLAYERSTRUCT
argument_list|,
literal|1
argument_list|,
name|Playersfp
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|Other
operator|.
name|p_specialtype
operator|==
name|SC_COUNCIL
operator|&&
name|Other
operator|.
name|p_status
operator|!=
name|S_NOTUSED
condition|)
comment|/* found a member of the council */
block|{
if|if
condition|(
operator|!
name|councilfound
condition|)
block|{
name|mvaddstr
argument_list|(
literal|8
argument_list|,
literal|30
argument_list|,
literal|"Council of the Wise:"
argument_list|)
expr_stmt|;
name|councilfound
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* This assumes a finite (<=5) number of C.O.W.: */
name|sprintf
argument_list|(
name|Databuf
argument_list|,
literal|"%s   Login:  %s"
argument_list|,
name|Other
operator|.
name|p_name
argument_list|,
name|Other
operator|.
name|p_login
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|Lines
operator|++
argument_list|,
literal|40
operator|-
name|strlen
argument_list|(
name|Databuf
argument_list|)
operator|/
literal|2
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
block|}
comment|/* search for the two highest players */
name|nxtname
index|[
literal|0
index|]
operator|=
name|hiname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hiexp
operator|=
literal|0.0
expr_stmt|;
name|nxtlvl
operator|=
name|hilvl
operator|=
literal|0
expr_stmt|;
name|fseek
argument_list|(
name|Playersfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Other
argument_list|,
name|SZ_PLAYERSTRUCT
argument_list|,
literal|1
argument_list|,
name|Playersfp
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|Other
operator|.
name|p_experience
operator|>
name|hiexp
operator|&&
name|Other
operator|.
name|p_specialtype
operator|<=
name|SC_KING
operator|&&
name|Other
operator|.
name|p_status
operator|!=
name|S_NOTUSED
condition|)
comment|/* highest found so far */
block|{
name|nxtexp
operator|=
name|hiexp
expr_stmt|;
name|hiexp
operator|=
name|Other
operator|.
name|p_experience
expr_stmt|;
name|nxtlvl
operator|=
name|hilvl
expr_stmt|;
name|hilvl
operator|=
name|Other
operator|.
name|p_level
expr_stmt|;
name|strcpy
argument_list|(
name|nxtname
argument_list|,
name|hiname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hiname
argument_list|,
name|Other
operator|.
name|p_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Other
operator|.
name|p_experience
operator|>
name|nxtexp
operator|&&
name|Other
operator|.
name|p_specialtype
operator|<=
name|SC_KING
operator|&&
name|Other
operator|.
name|p_status
operator|!=
name|S_NOTUSED
condition|)
comment|/* next highest found so far */
block|{
name|nxtexp
operator|=
name|Other
operator|.
name|p_experience
expr_stmt|;
name|nxtlvl
operator|=
name|Other
operator|.
name|p_level
expr_stmt|;
name|strcpy
argument_list|(
name|nxtname
argument_list|,
name|Other
operator|.
name|p_name
argument_list|)
expr_stmt|;
block|}
name|mvaddstr
argument_list|(
literal|15
argument_list|,
literal|28
argument_list|,
literal|"Highest characters are:"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Databuf
argument_list|,
literal|"%s  Level:%.0f   and   %s  Level:%.0f"
argument_list|,
name|hiname
argument_list|,
name|hilvl
argument_list|,
name|nxtname
argument_list|,
name|nxtlvl
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|17
argument_list|,
literal|40
operator|-
name|strlen
argument_list|(
name|Databuf
argument_list|)
operator|/
literal|2
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
comment|/* print last to die */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|_PATH_LASTDEAD
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|fgets
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mvaddstr
argument_list|(
literal|19
argument_list|,
literal|25
argument_list|,
literal|"The last character to die was:"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|40
operator|-
name|strlen
argument_list|(
name|Databuf
argument_list|)
operator|/
literal|2
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: recallplayer() / / FUNCTION: find a character on file / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: writerecord(), truncstring(), more(), death(), wmove(), /	wclear(), strcmp(), printw(), cleanup(), waddstr(), findname(), mvprintw(), /	getanswer(), getstring() / / GLOBAL INPUTS: Player, *stdscr, Databuf[] / / GLOBAL OUTPUTS: Echo, Player / / DESCRIPTION: /	Search for a character of a certain name, and check password. / *************************************************************************/
end_comment

begin_function
name|long
name|recallplayer
parameter_list|()
block|{
name|long
name|loc
init|=
literal|0L
decl_stmt|;
comment|/* location in player file */
specifier|register
name|int
name|loop
decl_stmt|;
comment|/* loop counter */
name|int
name|ch
decl_stmt|;
comment|/* input */
name|clear
argument_list|()
expr_stmt|;
name|mvprintw
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|,
literal|"What was your character's name ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Databuf
argument_list|,
name|SZ_NAME
argument_list|)
expr_stmt|;
name|truncstring
argument_list|(
name|Databuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|loc
operator|=
name|findname
argument_list|(
name|Databuf
argument_list|,
operator|&
name|Player
argument_list|)
operator|)
operator|>=
literal|0L
condition|)
comment|/* found character */
block|{
name|Echo
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
literal|2
condition|;
operator|++
name|loop
control|)
block|{
comment|/* prompt for password */
name|mvaddstr
argument_list|(
literal|11
argument_list|,
literal|0
argument_list|,
literal|"Password ? "
argument_list|)
expr_stmt|;
name|getstring
argument_list|(
name|Databuf
argument_list|,
name|SZ_PASSWORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|Databuf
argument_list|,
name|Player
operator|.
name|p_password
argument_list|)
operator|==
literal|0
condition|)
comment|/* password good */
block|{
name|Echo
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_status
operator|!=
name|S_OFF
condition|)
comment|/* player did not exit normally last time */
block|{
name|clear
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Your character did not exit normally last time.\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"If you think you have good cause to have your character saved,\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"you may quit and mail your reason to 'root'.\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Otherwise, continuing spells certain death.\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Do you want to quit ? "
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getanswer
argument_list|(
literal|"YN"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'Y'
condition|)
block|{
name|Player
operator|.
name|p_status
operator|=
name|S_HUNGUP
expr_stmt|;
name|writerecord
argument_list|(
operator|&
name|Player
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|death
argument_list|(
literal|"Stupidity"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
return|return
operator|(
name|loc
operator|)
return|;
block|}
else|else
name|mvaddstr
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|,
literal|"No good.\n"
argument_list|)
expr_stmt|;
block|}
name|Echo
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|mvaddstr
argument_list|(
literal|11
argument_list|,
literal|0
argument_list|,
literal|"Not found.\n"
argument_list|)
expr_stmt|;
name|more
argument_list|(
literal|13
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1L
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: neatstuff() / / FUNCTION: do random stuff / / AUTHOR: E. A. Estes, 3/3/86 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: collecttaxes(), floor(), wmove(), drandom(), infloat(), /	waddstr(), mvprintw(), getanswer() / / GLOBAL INPUTS: Player, *stdscr, *Statptr / / GLOBAL OUTPUTS: Player / / DESCRIPTION: /	Handle gurus, medics, etc. / *************************************************************************/
end_comment

begin_macro
name|neatstuff
argument_list|()
end_macro

begin_block
block|{
name|double
name|temp
decl_stmt|;
comment|/* for temporary calculations */
name|int
name|ch
decl_stmt|;
comment|/* input */
switch|switch
condition|(
operator|(
name|int
operator|)
name|ROLL
argument_list|(
literal|0.0
argument_list|,
literal|100.0
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
if|if
condition|(
name|Player
operator|.
name|p_poison
operator|>
literal|0.0
condition|)
block|{
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've found a medic!  How much will you offer to be cured ? "
argument_list|)
expr_stmt|;
name|temp
operator|=
name|floor
argument_list|(
name|infloat
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0.0
operator|||
name|temp
operator|>
name|Player
operator|.
name|p_gold
condition|)
comment|/* negative gold, or more than available */
block|{
name|mvaddstr
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|"He was not amused, and made you worse.\n"
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_poison
operator|+=
literal|1.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drandom
argument_list|()
operator|/
literal|2.0
operator|>
operator|(
name|temp
operator|+
literal|1.0
operator|)
operator|/
name|MAX
argument_list|(
name|Player
operator|.
name|p_gold
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* medic wants 1/2 of available gold */
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Sorry, he wasn't interested.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"He accepted."
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_poison
operator|=
name|MAX
argument_list|(
literal|0.0
argument_list|,
name|Player
operator|.
name|p_poison
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_gold
operator|-=
name|temp
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|3
case|:
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've been caught raping and pillaging!\n"
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_experience
operator|+=
literal|4000.0
expr_stmt|;
name|Player
operator|.
name|p_sin
operator|+=
literal|0.5
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|temp
operator|=
name|ROLL
argument_list|(
literal|10.0
argument_list|,
literal|75.0
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've found %.0f gold pieces, want them ? "
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getanswer
argument_list|(
literal|"NY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'Y'
condition|)
name|collecttaxes
argument_list|(
name|temp
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|Player
operator|.
name|p_sin
operator|>
literal|1.0
condition|)
block|{
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've found a Holy Orb!\n"
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_sin
operator|-=
literal|0.25
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|Player
operator|.
name|p_poison
operator|<
literal|1.0
condition|)
block|{
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've been hit with a plague!\n"
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_poison
operator|+=
literal|1.0
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've found some holy water.\n"
argument_list|)
expr_stmt|;
operator|++
name|Player
operator|.
name|p_holywater
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've met a Guru. . ."
argument_list|)
expr_stmt|;
if|if
condition|(
name|drandom
argument_list|()
operator|*
name|Player
operator|.
name|p_sin
operator|>
literal|1.0
condition|)
name|addstr
argument_list|(
literal|"You disgusted him with your sins!\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Player
operator|.
name|p_poison
operator|>
literal|0.0
condition|)
block|{
name|addstr
argument_list|(
literal|"He looked kindly upon you, and cured you.\n"
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_poison
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|addstr
argument_list|(
literal|"He rewarded you for your virtue.\n"
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_mana
operator|+=
literal|50.0
expr_stmt|;
name|Player
operator|.
name|p_shield
operator|+=
literal|2.0
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've found an amulet.\n"
argument_list|)
expr_stmt|;
operator|++
name|Player
operator|.
name|p_amulets
expr_stmt|;
break|break;
case|case
literal|10
case|:
if|if
condition|(
name|Player
operator|.
name|p_blindness
condition|)
block|{
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"You've regained your sight!\n"
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_blindness
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
comment|/* deal with poison */
if|if
condition|(
name|Player
operator|.
name|p_poison
operator|>
literal|0.0
condition|)
block|{
name|temp
operator|=
name|Player
operator|.
name|p_poison
operator|*
name|Statptr
operator|->
name|c_weakness
operator|*
name|Player
operator|.
name|p_maxenergy
operator|/
literal|600.0
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_energy
operator|>
name|Player
operator|.
name|p_maxenergy
operator|/
literal|10.0
operator|&&
name|temp
operator|+
literal|5.0
operator|<
name|Player
operator|.
name|p_energy
condition|)
name|Player
operator|.
name|p_energy
operator|-=
name|temp
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: genchar() / / FUNCTION: generate a random character / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: /	int type - ASCII value of character type to generate / / RETURN VALUE: none / / MODULES CALLED: floor(), drandom() / / GLOBAL INPUTS: Wizard, Player, Stattable[] / / GLOBAL OUTPUTS: Player / / DESCRIPTION: /	Use the lookup table for rolling stats. / *************************************************************************/
end_comment

begin_macro
name|genchar
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|subscript
decl_stmt|;
comment|/* used for subscripting into Stattable */
specifier|register
name|struct
name|charstats
modifier|*
name|statptr
decl_stmt|;
comment|/* for pointing into Stattable */
name|subscript
operator|=
name|type
operator|-
literal|'1'
expr_stmt|;
if|if
condition|(
name|subscript
operator|<
name|C_MAGIC
operator|||
name|subscript
operator|>
name|C_EXPER
condition|)
if|if
condition|(
name|subscript
operator|!=
name|C_SUPER
operator|||
operator|!
name|Wizard
condition|)
comment|/* fighter is default */
name|subscript
operator|=
name|C_FIGHTER
expr_stmt|;
name|statptr
operator|=
operator|&
name|Stattable
index|[
name|subscript
index|]
expr_stmt|;
name|Player
operator|.
name|p_quickness
operator|=
name|ROLL
argument_list|(
name|statptr
operator|->
name|c_quickness
operator|.
name|base
argument_list|,
name|statptr
operator|->
name|c_quickness
operator|.
name|interval
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_strength
operator|=
name|ROLL
argument_list|(
name|statptr
operator|->
name|c_strength
operator|.
name|base
argument_list|,
name|statptr
operator|->
name|c_strength
operator|.
name|interval
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_mana
operator|=
name|ROLL
argument_list|(
name|statptr
operator|->
name|c_mana
operator|.
name|base
argument_list|,
name|statptr
operator|->
name|c_mana
operator|.
name|interval
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_maxenergy
operator|=
name|Player
operator|.
name|p_energy
operator|=
name|ROLL
argument_list|(
name|statptr
operator|->
name|c_energy
operator|.
name|base
argument_list|,
name|statptr
operator|->
name|c_energy
operator|.
name|interval
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_brains
operator|=
name|ROLL
argument_list|(
name|statptr
operator|->
name|c_brains
operator|.
name|base
argument_list|,
name|statptr
operator|->
name|c_brains
operator|.
name|interval
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_magiclvl
operator|=
name|ROLL
argument_list|(
name|statptr
operator|->
name|c_magiclvl
operator|.
name|base
argument_list|,
name|statptr
operator|->
name|c_magiclvl
operator|.
name|interval
argument_list|)
expr_stmt|;
name|Player
operator|.
name|p_type
operator|=
name|subscript
expr_stmt|;
if|if
condition|(
name|Player
operator|.
name|p_type
operator|==
name|C_HALFLING
condition|)
comment|/* give halfling some experience */
name|Player
operator|.
name|p_experience
operator|=
name|ROLL
argument_list|(
literal|600.0
argument_list|,
literal|200.0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: playinit() / / FUNCTION: initialize for playing game / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: signal(), wclear(), noecho(), crmode(), initscr(), /	wrefresh() / / GLOBAL INPUTS: *stdscr, ill_sig() / / GLOBAL OUTPUTS: Windows / / DESCRIPTION: /	Catch a bunch of signals, and turn on curses stuff. / *************************************************************************/
end_comment

begin_macro
name|playinit
argument_list|()
end_macro

begin_block
block|{
comment|/* catch/ingnore signals */
ifdef|#
directive|ifdef
name|BSD41
name|sigignore
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sigignore
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigignore
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
name|sigignore
argument_list|(
name|SIGTSTP
argument_list|)
expr_stmt|;
name|sigignore
argument_list|(
name|SIGTTIN
argument_list|)
expr_stmt|;
name|sigignore
argument_list|(
name|SIGTTOU
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGHUP
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGTRAP
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGIOT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGEMT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGFPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGBUS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGSEGV
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGSYS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGPIPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD42
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS3
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS5
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|ill_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initscr
argument_list|()
expr_stmt|;
comment|/* turn on curses */
name|noecho
argument_list|()
expr_stmt|;
comment|/* do not echo input */
name|crmode
argument_list|()
expr_stmt|;
comment|/* do not process erase, kill */
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|Windows
operator|=
name|TRUE
expr_stmt|;
comment|/* mark the state */
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: cleanup() / / FUNCTION: close some files, and maybe exit / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: /	bool doexit - exit flag / / RETURN VALUE: none / / MODULES CALLED: exit(), wmove(), fclose(), endwin(), nocrmode(), wrefresh() / / GLOBAL INPUTS: *Energyvoidfp, LINES, *stdscr, Windows, *Monstfp, /	*Messagefp, *Playersfp / / GLOBAL OUTPUTS: none / / DESCRIPTION: /	Close all open files.  If we are "in curses" terminate curses. /	If 'doexit' is set, exit, otherwise return. / *************************************************************************/
end_comment

begin_macro
name|cleanup
argument_list|(
argument|doexit
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|doexit
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Windows
condition|)
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|nocrmode
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Playersfp
condition|)
block|{
name|fclose
argument_list|(
name|Playersfp
argument_list|)
expr_stmt|;
name|Playersfp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|Monstfp
condition|)
block|{
name|fclose
argument_list|(
name|Monstfp
argument_list|)
expr_stmt|;
name|Monstfp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|Messagefp
condition|)
block|{
name|fclose
argument_list|(
name|Messagefp
argument_list|)
expr_stmt|;
name|Messagefp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|Energyvoidfp
condition|)
block|{
name|fclose
argument_list|(
name|Energyvoidfp
argument_list|)
expr_stmt|;
name|Energyvoidfp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|doexit
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

end_unit

