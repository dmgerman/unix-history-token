begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * setup.c - set up all files for Phantasia  */
end_comment

begin_include
include|#
directive|include
file|"include.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: main() / / FUNCTION: setup files for Phantasia 3.3.2 / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: time(), exit(), stat(), Error(), creat(), close(), fopen(), /	fgets(), floor(), srandom(), umask(), drandom(), strcpy(), getuid(), /	unlink(), fwrite(), fclose(), sscanf(), printf(), strlen(), fprintf() / / GLOBAL INPUTS: Curmonster, _iob[], Databuf[], *Monstfp, Enrgyvoid / / GLOBAL OUTPUTS: Curmonster, Databuf[], *Monstfp, Enrgyvoid / / DESCRIPTION: / /	This program tries to verify the parameters specified in /	the Makefile. / /	Create all necessary files.  Note that nothing needs to be /	put in these files. /	Also, the monster binary data base is created here. / *************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|files
index|[]
init|=
block|{
comment|/* all files to create */
name|_SPATH_MONST
block|,
name|_SPATH_PEOPLE
block|,
name|_SPATH_MESS
block|,
name|_SPATH_LASTDEAD
block|,
name|_SPATH_MOTD
block|,
name|_SPATH_GOLD
block|,
name|_SPATH_VOID
block|,
name|_SPATH_SCORE
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|monsterfile
init|=
literal|"monsters.asc"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|filename
decl_stmt|;
comment|/* for pointing to file names */
specifier|register
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* for opening files */
name|struct
name|stat
name|fbuf
decl_stmt|;
comment|/* for getting files statistics */
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"m:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'m'
case|:
name|monsterfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
break|break;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|srandomdev
argument_list|()
expr_stmt|;
name|umask
argument_list|(
literal|0117
argument_list|)
expr_stmt|;
comment|/* only owner can read/write created files */
comment|/* try to create data files */
name|filename
operator|=
operator|&
name|files
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|filename
operator|!=
name|NULL
condition|)
comment|/* create each file */
block|{
if|if
condition|(
name|stat
argument_list|(
operator|*
name|filename
argument_list|,
operator|&
name|fbuf
argument_list|)
operator|==
literal|0
condition|)
comment|/* file exists; remove it */
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|filename
argument_list|,
name|_SPATH_PEOPLE
argument_list|)
condition|)
comment|/* do not reset character file if it already exists */
block|{
operator|++
name|filename
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unlink
argument_list|(
operator|*
name|filename
argument_list|)
operator|<
literal|0
condition|)
name|Error
argument_list|(
literal|"Cannot unlink %s.\n"
argument_list|,
operator|*
name|filename
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
operator|*
name|filename
argument_list|,
literal|0660
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Error
argument_list|(
literal|"Cannot create %s.\n"
argument_list|,
operator|*
name|filename
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* close newly created file */
operator|++
name|filename
expr_stmt|;
comment|/* process next file */
block|}
comment|/* put holy grail info into energy void file */
name|Enrgyvoid
operator|.
name|ev_active
operator|=
name|TRUE
expr_stmt|;
name|Enrgyvoid
operator|.
name|ev_x
operator|=
name|ROLL
argument_list|(
operator|-
literal|1.0e6
argument_list|,
literal|2.0e6
argument_list|)
expr_stmt|;
name|Enrgyvoid
operator|.
name|ev_y
operator|=
name|ROLL
argument_list|(
operator|-
literal|1.0e6
argument_list|,
literal|2.0e6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|_SPATH_VOID
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Error
argument_list|(
literal|"Cannot update %s.\n"
argument_list|,
name|_SPATH_VOID
argument_list|)
expr_stmt|;
else|else
block|{
name|fwrite
argument_list|(
operator|&
name|Enrgyvoid
argument_list|,
name|SZ_VOIDSTRUCT
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* create binary monster data base */
if|if
condition|(
operator|(
name|Monstfp
operator|=
name|fopen
argument_list|(
name|_SPATH_MONST
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Error
argument_list|(
literal|"Cannot update %s.\n"
argument_list|,
name|_SPATH_MONST
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|monsterfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|Monstfp
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"cannot open %s to create monster database.\n"
argument_list|,
literal|"monsters.asc"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Curmonster
operator|.
name|m_o_strength
operator|=
name|Curmonster
operator|.
name|m_o_speed
operator|=
name|Curmonster
operator|.
name|m_maxspeed
operator|=
name|Curmonster
operator|.
name|m_o_energy
operator|=
name|Curmonster
operator|.
name|m_melee
operator|=
name|Curmonster
operator|.
name|m_skirmish
operator|=
literal|0.0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* read in text file, convert to binary */
block|{
name|sscanf
argument_list|(
operator|&
name|Databuf
index|[
literal|24
index|]
argument_list|,
literal|"%lf%lf%lf%lf%lf%d%d%lf"
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_strength
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_brains
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_speed
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_energy
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_experience
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_treasuretype
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_type
argument_list|,
operator|&
name|Curmonster
operator|.
name|m_flock
argument_list|)
expr_stmt|;
name|Databuf
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|Curmonster
operator|.
name|m_name
argument_list|,
name|Databuf
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Curmonster
argument_list|,
name|SZ_MONSTERSTRUCT
argument_list|,
literal|1
argument_list|,
name|Monstfp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|Monstfp
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MAKE_INSTALLS_THIS_AND_DOESNT_WANT_TO_HEAR_ABOUT_IT
comment|/* write to motd file */
name|printf
argument_list|(
literal|"One line 'motd' ? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|Databuf
argument_list|,
name|SZ_DATABUF
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|Databuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|_SPATH_MOTD
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Error
argument_list|(
literal|"Cannot update %s.\n"
argument_list|,
name|_SPATH_MOTD
argument_list|)
expr_stmt|;
else|else
block|{
name|fwrite
argument_list|(
name|Databuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|Databuf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* report compile-time options */
name|printf
argument_list|(
literal|"Compiled options:\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Phantasia destination directory:  %s\n"
argument_list|,
name|_SPATH_PHANTDIR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Wizard: root UID: 0\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD41
name|printf
argument_list|(
literal|"Compiled for BSD 4.1\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD42
name|printf
argument_list|(
literal|"Compiled for BSD 4.2\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS3
name|printf
argument_list|(
literal|"Compiled for System III\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS5
name|printf
argument_list|(
literal|"Compiled for System V\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: Error() / / FUNCTION: print an error message, and exit / / AUTHOR: E. A. Estes, 12/4/85 / / ARGUMENTS: /	char *str - format string for printf() /	char *file - file which caused error / / RETURN VALUE: none / / MODULES CALLED: exit(), perror(), fprintf() / / GLOBAL INPUTS: _iob[] / / GLOBAL OUTPUTS: none / / DESCRIPTION: /	Print an error message, then exit. / *************************************************************************/
end_comment

begin_macro
name|Error
argument_list|(
argument|str
argument_list|,
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************************************************************ / / FUNCTION NAME: drandom() / / FUNCTION: return a random number / / AUTHOR: E. A. Estes, 2/7/86 / / ARGUMENTS: none / / RETURN VALUE: none / / MODULES CALLED: random() / / GLOBAL INPUTS: none / / GLOBAL OUTPUTS: none / / DESCRIPTION: / *************************************************************************/
end_comment

begin_function
name|double
name|drandom
parameter_list|()
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
literal|2
condition|)
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|random
argument_list|()
operator|&
literal|0x7fff
argument_list|)
operator|/
literal|32768.0
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|double
operator|)
name|random
argument_list|()
operator|/
literal|32768.0
operator|)
return|;
block|}
end_function

end_unit

