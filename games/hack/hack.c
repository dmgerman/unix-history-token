begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/* hack.c - version 1.0.3 */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"hack.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function_decl
specifier|extern
name|char
name|news0
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|nomovemsg
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|exclam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|obj
modifier|*
name|addinv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|hmon
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* called on movement: 	1. when throwing ball+chain far away 	2. when teleporting 	3. when walking out of a lit room  */
end_comment

begin_macro
name|unsee
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|rm
modifier|*
name|lev
decl_stmt|;
comment|/* 	if(u.udispl){ 		u.udispl = 0; 		newsym(u.udisx, u.udisy); 	} */
ifndef|#
directive|ifndef
name|QUEST
if|if
condition|(
name|seehx
condition|)
block|{
name|seehx
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|QUEST
for|for
control|(
name|x
operator|=
name|u
operator|.
name|ux
operator|-
literal|1
init|;
name|x
operator|<
name|u
operator|.
name|ux
operator|+
literal|2
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|u
operator|.
name|uy
operator|-
literal|1
init|;
name|y
operator|<
name|u
operator|.
name|uy
operator|+
literal|2
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isok
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
continue|continue;
name|lev
operator|=
operator|&
name|levl
index|[
name|x
index|]
index|[
name|y
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|lev
operator|->
name|lit
operator|&&
name|lev
operator|->
name|scrsym
operator|==
literal|'.'
condition|)
block|{
name|lev
operator|->
name|scrsym
operator|=
literal|' '
expr_stmt|;
name|lev
operator|->
name|new
operator|=
literal|1
expr_stmt|;
name|on_scr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* called: 	in hack.eat.c: seeoff(0) - blind after eating rotten food 	in hack.mon.c: seeoff(0) - blinded by a yellow light 	in hack.mon.c: seeoff(1) - swallowed 	in hack.do.c:  seeoff(0) - blind after drinking potion 	in hack.do.c:  seeoff(1) - go up or down the stairs 	in hack.trap.c:seeoff(1) - fall through trapdoor  */
end_comment

begin_macro
name|seeoff
argument_list|(
argument|mode
argument_list|)
end_macro

begin_comment
comment|/* 1 to redo @, 0 to leave them */
end_comment

begin_block
block|{
comment|/* 1 means misc movement, 0 means blindness */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|rm
modifier|*
name|lev
decl_stmt|;
if|if
condition|(
name|u
operator|.
name|udispl
operator|&&
name|mode
condition|)
block|{
name|u
operator|.
name|udispl
operator|=
literal|0
expr_stmt|;
name|levl
index|[
name|u
operator|.
name|udisx
index|]
index|[
name|u
operator|.
name|udisy
index|]
operator|.
name|scrsym
operator|=
name|news0
argument_list|(
name|u
operator|.
name|udisx
argument_list|,
name|u
operator|.
name|udisy
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QUEST
if|if
condition|(
name|seehx
condition|)
block|{
name|seehx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
endif|QUEST
if|if
condition|(
operator|!
name|mode
condition|)
block|{
for|for
control|(
name|x
operator|=
name|u
operator|.
name|ux
operator|-
literal|1
init|;
name|x
operator|<
name|u
operator|.
name|ux
operator|+
literal|2
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|u
operator|.
name|uy
operator|-
literal|1
init|;
name|y
operator|<
name|u
operator|.
name|uy
operator|+
literal|2
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isok
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
continue|continue;
name|lev
operator|=
operator|&
name|levl
index|[
name|x
index|]
index|[
name|y
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|lev
operator|->
name|lit
operator|&&
name|lev
operator|->
name|scrsym
operator|==
literal|'.'
condition|)
name|lev
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|domove
argument_list|()
end_macro

begin_block
block|{
name|xchar
name|oldx
decl_stmt|,
name|oldy
decl_stmt|;
name|struct
name|monst
modifier|*
name|mtmp
decl_stmt|;
name|struct
name|rm
modifier|*
name|tmpr
decl_stmt|,
modifier|*
name|ust
decl_stmt|;
name|struct
name|trap
modifier|*
name|trap
decl_stmt|;
name|struct
name|obj
modifier|*
name|otmp
decl_stmt|;
name|u_wipe_engr
argument_list|(
name|rnd
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv_weight
argument_list|()
operator|>
literal|0
condition|)
block|{
name|pline
argument_list|(
literal|"You collapse under your load."
argument_list|)
expr_stmt|;
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|u
operator|.
name|uswallow
condition|)
block|{
name|u
operator|.
name|dx
operator|=
name|u
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|ux
operator|=
name|u
operator|.
name|ustuck
operator|->
name|mx
expr_stmt|;
name|u
operator|.
name|uy
operator|=
name|u
operator|.
name|ustuck
operator|->
name|my
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Confusion
condition|)
block|{
do|do
block|{
name|confdir
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isok
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
operator|||
name|IS_ROCK
argument_list|(
name|levl
index|[
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
index|]
index|[
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
index|]
operator|.
name|typ
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|isok
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
condition|)
block|{
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ust
operator|=
operator|&
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|u
operator|.
name|uy
index|]
expr_stmt|;
name|oldx
operator|=
name|u
operator|.
name|ux
expr_stmt|;
name|oldy
operator|=
name|u
operator|.
name|uy
expr_stmt|;
if|if
condition|(
operator|!
name|u
operator|.
name|uswallow
operator|&&
operator|(
name|trap
operator|=
name|t_at
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
operator|)
operator|&&
name|trap
operator|->
name|tseen
condition|)
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|ustuck
operator|&&
operator|!
name|u
operator|.
name|uswallow
operator|&&
operator|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
operator|!=
name|u
operator|.
name|ustuck
operator|->
name|mx
operator|||
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
operator|!=
name|u
operator|.
name|ustuck
operator|->
name|my
operator|)
condition|)
block|{
if|if
condition|(
name|dist
argument_list|(
name|u
operator|.
name|ustuck
operator|->
name|mx
argument_list|,
name|u
operator|.
name|ustuck
operator|->
name|my
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* perhaps it fled (or was teleported or ... ) */
name|u
operator|.
name|ustuck
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Blind
condition|)
name|pline
argument_list|(
literal|"You cannot escape from it!"
argument_list|)
expr_stmt|;
else|else
name|pline
argument_list|(
literal|"You cannot escape from %s!"
argument_list|,
name|monnam
argument_list|(
name|u
operator|.
name|ustuck
argument_list|)
argument_list|)
expr_stmt|;
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|u
operator|.
name|uswallow
operator|||
operator|(
name|mtmp
operator|=
name|m_at
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
operator|)
condition|)
block|{
comment|/* attack monster */
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gethungry
argument_list|()
expr_stmt|;
if|if
condition|(
name|multi
operator|<
literal|0
condition|)
return|return;
comment|/* we just fainted */
comment|/* try to attack; note that it might evade */
if|if
condition|(
name|attack
argument_list|(
name|u
operator|.
name|uswallow
condition|?
name|u
operator|.
name|ustuck
else|:
name|mtmp
argument_list|)
condition|)
return|return;
block|}
comment|/* not attacking an animal, so we try to move */
if|if
condition|(
name|u
operator|.
name|utrap
condition|)
block|{
if|if
condition|(
name|u
operator|.
name|utraptype
operator|==
name|TT_PIT
condition|)
block|{
name|pline
argument_list|(
literal|"You are still in a pit."
argument_list|)
expr_stmt|;
name|u
operator|.
name|utrap
operator|--
expr_stmt|;
block|}
else|else
block|{
name|pline
argument_list|(
literal|"You are caught in a beartrap."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|.
name|dx
operator|&&
name|u
operator|.
name|dy
operator|)
operator|||
operator|!
name|rn2
argument_list|(
literal|5
argument_list|)
condition|)
name|u
operator|.
name|utrap
operator|--
expr_stmt|;
block|}
return|return;
block|}
name|tmpr
operator|=
operator|&
name|levl
index|[
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
index|]
index|[
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
index|]
expr_stmt|;
if|if
condition|(
name|IS_ROCK
argument_list|(
name|tmpr
operator|->
name|typ
argument_list|)
operator|||
operator|(
name|u
operator|.
name|dx
operator|&&
name|u
operator|.
name|dy
operator|&&
operator|(
name|tmpr
operator|->
name|typ
operator|==
name|DOOR
operator|||
name|ust
operator|->
name|typ
operator|==
name|DOOR
operator|)
operator|)
condition|)
block|{
name|flags
operator|.
name|move
operator|=
literal|0
expr_stmt|;
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|otmp
operator|=
name|sobj_at
argument_list|(
name|ENORMOUS_ROCK
argument_list|,
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
condition|)
block|{
name|xchar
name|rx
init|=
name|u
operator|.
name|ux
operator|+
literal|2
operator|*
name|u
operator|.
name|dx
decl_stmt|,
name|ry
init|=
name|u
operator|.
name|uy
operator|+
literal|2
operator|*
name|u
operator|.
name|dy
decl_stmt|;
name|struct
name|trap
modifier|*
name|ttmp
decl_stmt|;
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isok
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
operator|&&
operator|!
name|IS_ROCK
argument_list|(
name|levl
index|[
name|rx
index|]
index|[
name|ry
index|]
operator|.
name|typ
argument_list|)
operator|&&
operator|(
name|levl
index|[
name|rx
index|]
index|[
name|ry
index|]
operator|.
name|typ
operator|!=
name|DOOR
operator|||
operator|!
operator|(
name|u
operator|.
name|dx
operator|&&
name|u
operator|.
name|dy
operator|)
operator|)
operator|&&
operator|!
name|sobj_at
argument_list|(
name|ENORMOUS_ROCK
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_at
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
condition|)
block|{
name|pline
argument_list|(
literal|"You hear a monster behind the rock."
argument_list|)
expr_stmt|;
name|pline
argument_list|(
literal|"Perhaps that's why you cannot move it."
argument_list|)
expr_stmt|;
goto|goto
name|cannot_push
goto|;
block|}
if|if
condition|(
name|ttmp
operator|=
name|t_at
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
condition|)
switch|switch
condition|(
name|ttmp
operator|->
name|ttyp
condition|)
block|{
case|case
name|PIT
case|:
name|pline
argument_list|(
literal|"You push the rock into a pit!"
argument_list|)
expr_stmt|;
name|deltrap
argument_list|(
name|ttmp
argument_list|)
expr_stmt|;
name|delobj
argument_list|(
name|otmp
argument_list|)
expr_stmt|;
name|pline
argument_list|(
literal|"It completely fills the pit!"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TELEP_TRAP
case|:
name|pline
argument_list|(
literal|"You push the rock and suddenly it disappears!"
argument_list|)
expr_stmt|;
name|delobj
argument_list|(
name|otmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|levl
index|[
name|rx
index|]
index|[
name|ry
index|]
operator|.
name|typ
operator|==
name|POOL
condition|)
block|{
name|levl
index|[
name|rx
index|]
index|[
name|ry
index|]
operator|.
name|typ
operator|=
name|ROOM
expr_stmt|;
name|mnewsym
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
expr_stmt|;
name|prl
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
expr_stmt|;
name|pline
argument_list|(
literal|"You push the rock into the water."
argument_list|)
expr_stmt|;
name|pline
argument_list|(
literal|"Now you can cross the water!"
argument_list|)
expr_stmt|;
name|delobj
argument_list|(
name|otmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|otmp
operator|->
name|ox
operator|=
name|rx
expr_stmt|;
name|otmp
operator|->
name|oy
operator|=
name|ry
expr_stmt|;
comment|/* pobj(otmp); */
if|if
condition|(
name|cansee
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
condition|)
name|atl
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|,
name|otmp
operator|->
name|olet
argument_list|)
expr_stmt|;
if|if
condition|(
name|Invisible
condition|)
name|newsym
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
expr_stmt|;
block|{
specifier|static
name|long
name|lastmovetime
decl_stmt|;
comment|/* note: this var contains garbage initially and 			   after a restore */
if|if
condition|(
name|moves
operator|>
name|lastmovetime
operator|+
literal|2
operator|||
name|moves
operator|<
name|lastmovetime
condition|)
name|pline
argument_list|(
literal|"With great effort you move the enormous rock."
argument_list|)
expr_stmt|;
name|lastmovetime
operator|=
name|moves
expr_stmt|;
block|}
block|}
else|else
block|{
name|pline
argument_list|(
literal|"You try to move the enormous rock, but in vain."
argument_list|)
expr_stmt|;
name|cannot_push
label|:
if|if
condition|(
operator|(
operator|!
name|invent
operator|||
name|inv_weight
argument_list|()
operator|+
literal|90
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|u
operator|.
name|dx
operator|||
operator|!
name|u
operator|.
name|dy
operator|||
operator|(
name|IS_ROCK
argument_list|(
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
index|]
operator|.
name|typ
argument_list|)
operator|&&
name|IS_ROCK
argument_list|(
name|levl
index|[
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
index|]
index|[
name|u
operator|.
name|uy
index|]
operator|.
name|typ
argument_list|)
operator|)
operator|)
condition|)
block|{
name|pline
argument_list|(
literal|"However, you can squeeze yourself into a small opening."
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
return|return;
block|}
block|}
if|if
condition|(
name|u
operator|.
name|dx
operator|&&
name|u
operator|.
name|dy
operator|&&
name|IS_ROCK
argument_list|(
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
index|]
operator|.
name|typ
argument_list|)
operator|&&
name|IS_ROCK
argument_list|(
name|levl
index|[
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
index|]
index|[
name|u
operator|.
name|uy
index|]
operator|.
name|typ
argument_list|)
operator|&&
name|invent
operator|&&
name|inv_weight
argument_list|()
operator|+
literal|40
operator|>
literal|0
condition|)
block|{
name|pline
argument_list|(
literal|"You are carrying too much to get through."
argument_list|)
expr_stmt|;
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Punished
operator|&&
name|DIST
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|,
name|uchain
operator|->
name|ox
argument_list|,
name|uchain
operator|->
name|oy
argument_list|)
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|carried
argument_list|(
name|uball
argument_list|)
condition|)
block|{
name|movobj
argument_list|(
name|uchain
argument_list|,
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
argument_list|)
expr_stmt|;
goto|goto
name|nodrag
goto|;
block|}
if|if
condition|(
name|DIST
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|,
name|uball
operator|->
name|ox
argument_list|,
name|uball
operator|->
name|oy
argument_list|)
operator|<
literal|3
condition|)
block|{
comment|/* leave ball, move chain under/over ball */
name|movobj
argument_list|(
name|uchain
argument_list|,
name|uball
operator|->
name|ox
argument_list|,
name|uball
operator|->
name|oy
argument_list|)
expr_stmt|;
goto|goto
name|nodrag
goto|;
block|}
if|if
condition|(
name|inv_weight
argument_list|()
operator|+
operator|(
name|int
operator|)
name|uball
operator|->
name|owt
operator|/
literal|2
operator|>
literal|0
condition|)
block|{
name|pline
argument_list|(
literal|"You cannot %sdrag the heavy iron ball."
argument_list|,
name|invent
condition|?
literal|"carry all that and also "
else|:
literal|""
argument_list|)
expr_stmt|;
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|movobj
argument_list|(
name|uball
argument_list|,
name|uchain
operator|->
name|ox
argument_list|,
name|uchain
operator|->
name|oy
argument_list|)
expr_stmt|;
name|unpobj
argument_list|(
name|uball
argument_list|)
expr_stmt|;
comment|/* BAH %% */
name|uchain
operator|->
name|ox
operator|=
name|u
operator|.
name|ux
expr_stmt|;
name|uchain
operator|->
name|oy
operator|=
name|u
operator|.
name|uy
expr_stmt|;
name|nomul
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
name|nomovemsg
operator|=
literal|""
expr_stmt|;
name|nodrag
label|:
empty_stmt|;
block|}
name|u
operator|.
name|ux
operator|+=
name|u
operator|.
name|dx
expr_stmt|;
name|u
operator|.
name|uy
operator|+=
name|u
operator|.
name|dy
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|run
condition|)
block|{
if|if
condition|(
name|tmpr
operator|->
name|typ
operator|==
name|DOOR
operator|||
operator|(
name|xupstair
operator|==
name|u
operator|.
name|ux
operator|&&
name|yupstair
operator|==
name|u
operator|.
name|uy
operator|)
operator|||
operator|(
name|xdnstair
operator|==
name|u
operator|.
name|ux
operator|&&
name|ydnstair
operator|==
name|u
operator|.
name|uy
operator|)
condition|)
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpr
operator|->
name|typ
operator|==
name|POOL
operator|&&
operator|!
name|Levitation
condition|)
name|drown
argument_list|()
expr_stmt|;
comment|/* not necessarily fatal */
comment|/* 	if(u.udispl) { 		u.udispl = 0; 		newsym(oldx,oldy); 	} */
if|if
condition|(
operator|!
name|Blind
condition|)
block|{
ifdef|#
directive|ifdef
name|QUEST
name|setsee
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ust
operator|->
name|lit
condition|)
block|{
if|if
condition|(
name|tmpr
operator|->
name|lit
condition|)
block|{
if|if
condition|(
name|tmpr
operator|->
name|typ
operator|==
name|DOOR
condition|)
name|prl1
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ust
operator|->
name|typ
operator|==
name|DOOR
condition|)
name|nose1
argument_list|(
name|oldx
operator|-
name|u
operator|.
name|dx
argument_list|,
name|oldy
operator|-
name|u
operator|.
name|dy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsee
argument_list|()
expr_stmt|;
name|prl1
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tmpr
operator|->
name|lit
condition|)
name|setsee
argument_list|()
expr_stmt|;
else|else
block|{
name|prl1
argument_list|(
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpr
operator|->
name|typ
operator|==
name|DOOR
condition|)
block|{
if|if
condition|(
name|u
operator|.
name|dy
condition|)
block|{
name|prl
argument_list|(
name|u
operator|.
name|ux
operator|-
literal|1
argument_list|,
name|u
operator|.
name|uy
argument_list|)
expr_stmt|;
name|prl
argument_list|(
name|u
operator|.
name|ux
operator|+
literal|1
argument_list|,
name|u
operator|.
name|uy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prl
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
operator|-
literal|1
argument_list|)
expr_stmt|;
name|prl
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|nose1
argument_list|(
name|oldx
operator|-
name|u
operator|.
name|dx
argument_list|,
name|oldy
operator|-
name|u
operator|.
name|dy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|QUEST
block|}
else|else
block|{
name|pru
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flags
operator|.
name|nopick
condition|)
name|pickup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trap
condition|)
name|dotrap
argument_list|(
name|trap
argument_list|)
expr_stmt|;
comment|/* fall into pit, arrow trap, etc. */
operator|(
name|void
operator|)
name|inshop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Blind
condition|)
name|read_engr_at
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|movobj
argument_list|(
argument|obj
argument_list|,
argument|ox
argument_list|,
argument|oy
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|obj
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ox
decl_stmt|,
name|oy
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Some dirty programming to get display right */
name|freeobj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|unpobj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|nobj
operator|=
name|fobj
expr_stmt|;
name|fobj
operator|=
name|obj
expr_stmt|;
name|obj
operator|->
name|ox
operator|=
name|ox
expr_stmt|;
name|obj
operator|->
name|oy
operator|=
name|oy
expr_stmt|;
block|}
end_block

begin_macro
name|dopickup
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|g_at
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
argument_list|)
operator|&&
operator|!
name|o_at
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
argument_list|)
condition|)
block|{
name|pline
argument_list|(
literal|"There is nothing here to pick up."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|Levitation
condition|)
block|{
name|pline
argument_list|(
literal|"You cannot reach the floor."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pickup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|pickup
argument_list|(
argument|all
argument_list|)
end_macro

begin_block
block|{
name|struct
name|gold
modifier|*
name|gold
decl_stmt|;
name|struct
name|obj
modifier|*
name|obj
decl_stmt|,
modifier|*
name|obj2
decl_stmt|;
name|int
name|wt
decl_stmt|;
if|if
condition|(
name|Levitation
condition|)
return|return;
while|while
condition|(
name|gold
operator|=
name|g_at
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
argument_list|)
condition|)
block|{
name|pline
argument_list|(
literal|"%ld gold piece%s."
argument_list|,
name|gold
operator|->
name|amount
argument_list|,
name|plur
argument_list|(
name|gold
operator|->
name|amount
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|ugold
operator|+=
name|gold
operator|->
name|amount
expr_stmt|;
name|flags
operator|.
name|botl
operator|=
literal|1
expr_stmt|;
name|freegold
argument_list|(
name|gold
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|run
condition|)
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Invisible
condition|)
name|newsym
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
argument_list|)
expr_stmt|;
block|}
comment|/* check for more than one object */
if|if
condition|(
operator|!
name|all
condition|)
block|{
name|int
name|ct
init|=
literal|0
decl_stmt|;
for|for
control|(
name|obj
operator|=
name|fobj
init|;
name|obj
condition|;
name|obj
operator|=
name|obj
operator|->
name|nobj
control|)
if|if
condition|(
name|obj
operator|->
name|ox
operator|==
name|u
operator|.
name|ux
operator|&&
name|obj
operator|->
name|oy
operator|==
name|u
operator|.
name|uy
condition|)
if|if
condition|(
operator|!
name|Punished
operator|||
name|obj
operator|!=
name|uchain
condition|)
name|ct
operator|++
expr_stmt|;
if|if
condition|(
name|ct
operator|<
literal|2
condition|)
name|all
operator|++
expr_stmt|;
else|else
name|pline
argument_list|(
literal|"There are several objects here."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|obj
operator|=
name|fobj
init|;
name|obj
condition|;
name|obj
operator|=
name|obj2
control|)
block|{
name|obj2
operator|=
name|obj
operator|->
name|nobj
expr_stmt|;
comment|/* perhaps obj will be picked up */
if|if
condition|(
name|obj
operator|->
name|ox
operator|==
name|u
operator|.
name|ux
operator|&&
name|obj
operator|->
name|oy
operator|==
name|u
operator|.
name|uy
condition|)
block|{
if|if
condition|(
name|flags
operator|.
name|run
condition|)
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* do not pick up uchain */
if|if
condition|(
name|Punished
operator|&&
name|obj
operator|==
name|uchain
condition|)
continue|continue;
if|if
condition|(
operator|!
name|all
condition|)
block|{
name|char
name|c
decl_stmt|;
name|pline
argument_list|(
literal|"Pick up %s ? [ynaq]"
argument_list|,
name|doname
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|index
argument_list|(
literal|"ynaq "
argument_list|,
operator|(
name|c
operator|=
name|readchar
argument_list|()
operator|)
argument_list|)
condition|)
name|bell
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
condition|)
return|return;
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'a'
condition|)
name|all
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|otyp
operator|==
name|DEAD_COCKATRICE
operator|&&
operator|!
name|uarmg
condition|)
block|{
name|pline
argument_list|(
literal|"Touching the dead cockatrice is a fatal mistake."
argument_list|)
expr_stmt|;
name|pline
argument_list|(
literal|"You turn to stone."
argument_list|)
expr_stmt|;
name|killer
operator|=
literal|"cockatrice cadaver"
expr_stmt|;
name|done
argument_list|(
literal|"died"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|otyp
operator|==
name|SCR_SCARE_MONSTER
condition|)
block|{
if|if
condition|(
operator|!
name|obj
operator|->
name|spe
condition|)
name|obj
operator|->
name|spe
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Note: perhaps the 1st pickup failed: you cannot 			carry anymore, and so we never dropped it - 			let's assume that treading on it twice also 			destroys the scroll */
name|pline
argument_list|(
literal|"The scroll turns to dust as you pick it up."
argument_list|)
expr_stmt|;
name|delobj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|wt
operator|=
name|inv_weight
argument_list|()
operator|+
name|obj
operator|->
name|owt
expr_stmt|;
if|if
condition|(
name|wt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|quan
operator|>
literal|1
condition|)
block|{
comment|/* see how many we can lift */
specifier|extern
name|struct
name|obj
modifier|*
name|splitobj
parameter_list|()
function_decl|;
name|int
name|savequan
init|=
name|obj
operator|->
name|quan
decl_stmt|;
name|int
name|iw
init|=
name|inv_weight
argument_list|()
decl_stmt|;
name|int
name|qq
decl_stmt|;
for|for
control|(
name|qq
operator|=
literal|1
init|;
name|qq
operator|<
name|savequan
condition|;
name|qq
operator|++
control|)
block|{
name|obj
operator|->
name|quan
operator|=
name|qq
expr_stmt|;
if|if
condition|(
name|iw
operator|+
name|weight
argument_list|(
name|obj
argument_list|)
operator|>
literal|0
condition|)
break|break;
block|}
name|obj
operator|->
name|quan
operator|=
name|savequan
expr_stmt|;
name|qq
operator|--
expr_stmt|;
comment|/* we can carry qq of them */
if|if
condition|(
operator|!
name|qq
condition|)
goto|goto
name|too_heavy
goto|;
name|pline
argument_list|(
literal|"You can only carry %s of the %s lying here."
argument_list|,
operator|(
name|qq
operator|==
literal|1
operator|)
condition|?
literal|"one"
else|:
literal|"some"
argument_list|,
name|doname
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splitobj
argument_list|(
name|obj
argument_list|,
name|qq
argument_list|)
expr_stmt|;
comment|/* note: obj2 is set already, so we'll never 				 * encounter the other half; if it should be 				 * otherwise then write 				 *	obj2 = splitobj(obj,qq); 				 */
goto|goto
name|lift_some
goto|;
block|}
name|too_heavy
label|:
name|pline
argument_list|(
literal|"There %s %s here, but %s."
argument_list|,
operator|(
name|obj
operator|->
name|quan
operator|==
literal|1
operator|)
condition|?
literal|"is"
else|:
literal|"are"
argument_list|,
name|doname
argument_list|(
name|obj
argument_list|)
argument_list|,
operator|!
name|invent
condition|?
literal|"it is too heavy for you to lift"
else|:
literal|"you cannot carry anymore"
argument_list|)
expr_stmt|;
break|break;
block|}
name|lift_some
label|:
if|if
condition|(
name|inv_cnt
argument_list|()
operator|>=
literal|52
condition|)
block|{
name|pline
argument_list|(
literal|"Your knapsack cannot accomodate anymore items."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wt
operator|>
operator|-
literal|5
condition|)
name|pline
argument_list|(
literal|"You have a little trouble lifting"
argument_list|)
expr_stmt|;
name|freeobj
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|Invisible
condition|)
name|newsym
argument_list|(
name|u
operator|.
name|ux
argument_list|,
name|u
operator|.
name|uy
argument_list|)
expr_stmt|;
name|addtobill
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* sets obj->unpaid if necessary */
block|{
name|int
name|pickquan
init|=
name|obj
operator|->
name|quan
decl_stmt|;
name|int
name|mergquan
decl_stmt|;
if|if
condition|(
operator|!
name|Blind
condition|)
name|obj
operator|->
name|dknown
operator|=
literal|1
expr_stmt|;
comment|/* this is done by prinv(), 				 but addinv() needs it already for merging */
name|obj
operator|=
name|addinv
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* might merge it with other objects */
name|mergquan
operator|=
name|obj
operator|->
name|quan
expr_stmt|;
name|obj
operator|->
name|quan
operator|=
name|pickquan
expr_stmt|;
comment|/* to fool prinv() */
name|prinv
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|->
name|quan
operator|=
name|mergquan
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* stop running if we see something interesting */
end_comment

begin_comment
comment|/* turn around a corner if that is the only way we can proceed */
end_comment

begin_comment
comment|/* do not turn left or right twice */
end_comment

begin_macro
name|lookaround
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|,
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|m0
decl_stmt|,
name|i0
init|=
literal|9
decl_stmt|;
name|int
name|corrct
init|=
literal|0
decl_stmt|,
name|noturn
init|=
literal|0
decl_stmt|;
name|struct
name|monst
modifier|*
name|mtmp
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
comment|/* suppress "used before set" message */
name|x0
operator|=
name|y0
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|lint
if|if
condition|(
name|Blind
operator|||
name|flags
operator|.
name|run
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|flags
operator|.
name|run
operator|==
literal|1
operator|&&
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|u
operator|.
name|uy
index|]
operator|.
name|typ
operator|==
name|ROOM
condition|)
return|return;
ifdef|#
directive|ifdef
name|QUEST
if|if
condition|(
name|u
operator|.
name|ux0
operator|==
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
operator|&&
name|u
operator|.
name|uy0
operator|==
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
condition|)
goto|goto
name|stop
goto|;
endif|#
directive|endif
endif|QUEST
for|for
control|(
name|x
operator|=
name|u
operator|.
name|ux
operator|-
literal|1
init|;
name|x
operator|<=
name|u
operator|.
name|ux
operator|+
literal|1
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|u
operator|.
name|uy
operator|-
literal|1
init|;
name|y
operator|<=
name|u
operator|.
name|uy
operator|+
literal|1
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|==
name|u
operator|.
name|ux
operator|&&
name|y
operator|==
name|u
operator|.
name|uy
condition|)
continue|continue;
if|if
condition|(
operator|!
name|levl
index|[
name|x
index|]
index|[
name|y
index|]
operator|.
name|typ
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mtmp
operator|=
name|m_at
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|&&
operator|!
name|mtmp
operator|->
name|mimic
operator|&&
operator|(
operator|!
name|mtmp
operator|->
name|minvis
operator|||
name|See_invisible
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|mtmp
operator|->
name|mtame
operator|||
operator|(
name|x
operator|==
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
operator|&&
name|y
operator|==
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
operator|)
condition|)
goto|goto
name|stop
goto|;
block|}
else|else
name|mtmp
operator|=
literal|0
expr_stmt|;
comment|/* invisible M cannot influence us */
if|if
condition|(
name|x
operator|==
name|u
operator|.
name|ux
operator|-
name|u
operator|.
name|dx
operator|&&
name|y
operator|==
name|u
operator|.
name|uy
operator|-
name|u
operator|.
name|dy
condition|)
continue|continue;
switch|switch
condition|(
name|levl
index|[
name|x
index|]
index|[
name|y
index|]
operator|.
name|scrsym
condition|)
block|{
case|case
literal|'|'
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|' '
case|:
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|x
operator|!=
name|u
operator|.
name|ux
operator|&&
name|y
operator|!=
name|u
operator|.
name|uy
condition|)
break|break;
if|if
condition|(
name|flags
operator|.
name|run
operator|!=
literal|1
condition|)
goto|goto
name|stop
goto|;
comment|/* fall into next case */
case|case
name|CORR_SYM
case|:
name|corr
label|:
if|if
condition|(
name|flags
operator|.
name|run
operator|==
literal|1
operator|||
name|flags
operator|.
name|run
operator|==
literal|3
condition|)
block|{
name|i
operator|=
name|DIST
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
argument_list|,
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
break|break;
if|if
condition|(
name|corrct
operator|==
literal|1
operator|&&
name|DIST
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|)
operator|!=
literal|1
condition|)
name|noturn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|i0
condition|)
block|{
name|i0
operator|=
name|i
expr_stmt|;
name|x0
operator|=
name|x
expr_stmt|;
name|y0
operator|=
name|y
expr_stmt|;
name|m0
operator|=
name|mtmp
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
name|corrct
operator|++
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
if|if
condition|(
name|flags
operator|.
name|run
operator|==
literal|1
condition|)
goto|goto
name|corr
goto|;
comment|/* if you must */
if|if
condition|(
name|x
operator|==
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|dx
operator|&&
name|y
operator|==
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|dy
condition|)
goto|goto
name|stop
goto|;
break|break;
default|default:
comment|/* e.g. objects or trap or stairs */
if|if
condition|(
name|flags
operator|.
name|run
operator|==
literal|1
condition|)
goto|goto
name|corr
goto|;
if|if
condition|(
name|mtmp
condition|)
break|break;
comment|/* d */
name|stop
label|:
name|nomul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|QUEST
if|if
condition|(
name|corrct
operator|>
literal|0
operator|&&
operator|(
name|flags
operator|.
name|run
operator|==
literal|4
operator|||
name|flags
operator|.
name|run
operator|==
literal|5
operator|)
condition|)
goto|goto
name|stop
goto|;
endif|#
directive|endif
endif|QUEST
if|if
condition|(
name|corrct
operator|>
literal|1
operator|&&
name|flags
operator|.
name|run
operator|==
literal|2
condition|)
goto|goto
name|stop
goto|;
if|if
condition|(
operator|(
name|flags
operator|.
name|run
operator|==
literal|1
operator|||
name|flags
operator|.
name|run
operator|==
literal|3
operator|)
operator|&&
operator|!
name|noturn
operator|&&
operator|!
name|m0
operator|&&
name|i0
operator|&&
operator|(
name|corrct
operator|==
literal|1
operator|||
operator|(
name|corrct
operator|==
literal|2
operator|&&
name|i0
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* make sure that we do not turn too far */
if|if
condition|(
name|i0
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|u
operator|.
name|dx
operator|==
name|y0
operator|-
name|u
operator|.
name|uy
operator|&&
name|u
operator|.
name|dy
operator|==
name|u
operator|.
name|ux
operator|-
name|x0
condition|)
name|i
operator|=
literal|2
expr_stmt|;
comment|/* straight turn right */
else|else
name|i
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* straight turn left */
block|}
elseif|else
if|if
condition|(
name|u
operator|.
name|dx
operator|&&
name|u
operator|.
name|dy
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|.
name|dx
operator|==
name|u
operator|.
name|dy
operator|&&
name|y0
operator|==
name|u
operator|.
name|uy
operator|)
operator|||
operator|(
name|u
operator|.
name|dx
operator|!=
name|u
operator|.
name|dy
operator|&&
name|y0
operator|!=
name|u
operator|.
name|uy
operator|)
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* half turn left */
else|else
name|i
operator|=
literal|1
expr_stmt|;
comment|/* half turn right */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|x0
operator|-
name|u
operator|.
name|ux
operator|==
name|y0
operator|-
name|u
operator|.
name|uy
operator|&&
operator|!
name|u
operator|.
name|dy
operator|)
operator|||
operator|(
name|x0
operator|-
name|u
operator|.
name|ux
operator|!=
name|y0
operator|-
name|u
operator|.
name|uy
operator|&&
name|u
operator|.
name|dy
operator|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
comment|/* half turn right */
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* half turn left */
block|}
name|i
operator|+=
name|u
operator|.
name|last_str_turn
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|2
operator|&&
name|i
operator|>=
operator|-
literal|2
condition|)
block|{
name|u
operator|.
name|last_str_turn
operator|=
name|i
expr_stmt|;
name|u
operator|.
name|dx
operator|=
name|x0
operator|-
name|u
operator|.
name|ux
operator|,
name|u
operator|.
name|dy
operator|=
name|y0
operator|-
name|u
operator|.
name|uy
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* something like lookaround, but we are not running */
end_comment

begin_comment
comment|/* react only to monsters that might hit us */
end_comment

begin_macro
name|monster_nearby
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|monst
modifier|*
name|mtmp
decl_stmt|;
if|if
condition|(
operator|!
name|Blind
condition|)
for|for
control|(
name|x
operator|=
name|u
operator|.
name|ux
operator|-
literal|1
init|;
name|x
operator|<=
name|u
operator|.
name|ux
operator|+
literal|1
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|u
operator|.
name|uy
operator|-
literal|1
init|;
name|y
operator|<=
name|u
operator|.
name|uy
operator|+
literal|1
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|==
name|u
operator|.
name|ux
operator|&&
name|y
operator|==
name|u
operator|.
name|uy
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mtmp
operator|=
name|m_at
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|&&
operator|!
name|mtmp
operator|->
name|mimic
operator|&&
operator|!
name|mtmp
operator|->
name|mtame
operator|&&
operator|!
name|mtmp
operator|->
name|mpeaceful
operator|&&
operator|!
name|index
argument_list|(
literal|"Ea"
argument_list|,
name|mtmp
operator|->
name|data
operator|->
name|mlet
argument_list|)
operator|&&
operator|!
name|mtmp
operator|->
name|mfroz
operator|&&
operator|!
name|mtmp
operator|->
name|msleep
operator|&&
comment|/* aplvax!jcn */
operator|(
operator|!
name|mtmp
operator|->
name|minvis
operator|||
name|See_invisible
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|QUEST
end_ifdef

begin_macro
name|cansee
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|xchar
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|adx
decl_stmt|,
name|ady
decl_stmt|,
name|sdx
decl_stmt|,
name|sdy
decl_stmt|,
name|dmax
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|Blind
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|isok
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|d
operator|=
name|dist
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|3
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|d
operator|>
name|u
operator|.
name|uhorizon
operator|*
name|u
operator|.
name|uhorizon
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|levl
index|[
name|x
index|]
index|[
name|y
index|]
operator|.
name|lit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dx
operator|=
name|x
operator|-
name|u
operator|.
name|ux
expr_stmt|;
name|adx
operator|=
name|abs
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|sdx
operator|=
name|sgn
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|dy
operator|=
name|y
operator|-
name|u
operator|.
name|uy
expr_stmt|;
name|ady
operator|=
name|abs
argument_list|(
name|dy
argument_list|)
expr_stmt|;
name|sdy
operator|=
name|sgn
argument_list|(
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0
operator|||
name|dy
operator|==
literal|0
operator|||
name|adx
operator|==
name|ady
condition|)
block|{
name|dmax
operator|=
operator|(
name|dx
operator|==
literal|0
operator|)
condition|?
name|ady
else|:
name|adx
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|1
init|;
name|d
operator|<=
name|dmax
condition|;
name|d
operator|++
control|)
if|if
condition|(
operator|!
name|rroom
argument_list|(
name|sdx
operator|*
name|d
argument_list|,
name|sdy
operator|*
name|d
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ady
operator|>
name|adx
condition|)
block|{
for|for
control|(
name|d
operator|=
literal|1
init|;
name|d
operator|<=
name|ady
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rroom
argument_list|(
name|sdx
operator|*
operator|(
operator|(
name|d
operator|*
name|adx
operator|)
operator|/
name|ady
operator|)
argument_list|,
name|sdy
operator|*
name|d
argument_list|)
operator|||
operator|!
name|rroom
argument_list|(
name|sdx
operator|*
operator|(
operator|(
name|d
operator|*
name|adx
operator|-
literal|1
operator|)
operator|/
name|ady
operator|+
literal|1
operator|)
argument_list|,
name|sdy
operator|*
name|d
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|d
operator|=
literal|1
init|;
name|d
operator|<=
name|adx
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rroom
argument_list|(
name|sdx
operator|*
name|d
argument_list|,
name|sdy
operator|*
operator|(
operator|(
name|d
operator|*
name|ady
operator|)
operator|/
name|adx
operator|)
argument_list|)
operator|||
operator|!
name|rroom
argument_list|(
name|sdx
operator|*
name|d
argument_list|,
name|sdy
operator|*
operator|(
operator|(
name|d
operator|*
name|ady
operator|-
literal|1
operator|)
operator|/
name|adx
operator|+
literal|1
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|rroom
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|IS_ROOM
argument_list|(
name|levl
index|[
name|u
operator|.
name|ux
operator|+
name|x
index|]
index|[
name|u
operator|.
name|uy
operator|+
name|y
index|]
operator|.
name|typ
argument_list|)
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_macro
name|cansee
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|xchar
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Blind
operator|||
name|u
operator|.
name|uswallow
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dist
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|<
literal|3
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|levl
index|[
name|x
index|]
index|[
name|y
index|]
operator|.
name|lit
operator|&&
name|seelx
operator|<=
name|x
operator|&&
name|x
operator|<=
name|seehx
operator|&&
name|seely
operator|<=
name|y
operator|&&
name|y
operator|<=
name|seehy
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|QUEST
end_endif

begin_macro
name|sgn
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|a
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|(
name|a
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|QUEST
end_ifdef

begin_macro
name|setsee
argument_list|()
end_macro

begin_block
block|{
name|x
operator|,
name|y
expr_stmt|;
if|if
condition|(
name|Blind
condition|)
block|{
name|pru
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|y
operator|=
name|u
operator|.
name|uy
operator|-
name|u
operator|.
name|uhorizon
init|;
name|y
operator|<=
name|u
operator|.
name|uy
operator|+
name|u
operator|.
name|uhorizon
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
name|u
operator|.
name|ux
operator|-
name|u
operator|.
name|uhorizon
init|;
name|x
operator|<=
name|u
operator|.
name|ux
operator|+
name|u
operator|.
name|uhorizon
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|cansee
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
name|prl
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_macro
name|setsee
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|Blind
condition|)
block|{
name|pru
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|u
operator|.
name|uy
index|]
operator|.
name|lit
condition|)
block|{
name|seelx
operator|=
name|u
operator|.
name|ux
operator|-
literal|1
expr_stmt|;
name|seehx
operator|=
name|u
operator|.
name|ux
operator|+
literal|1
expr_stmt|;
name|seely
operator|=
name|u
operator|.
name|uy
operator|-
literal|1
expr_stmt|;
name|seehy
operator|=
name|u
operator|.
name|uy
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|seelx
operator|=
name|u
operator|.
name|ux
init|;
name|levl
index|[
name|seelx
operator|-
literal|1
index|]
index|[
name|u
operator|.
name|uy
index|]
operator|.
name|lit
condition|;
name|seelx
operator|--
control|)
empty_stmt|;
for|for
control|(
name|seehx
operator|=
name|u
operator|.
name|ux
init|;
name|levl
index|[
name|seehx
operator|+
literal|1
index|]
index|[
name|u
operator|.
name|uy
index|]
operator|.
name|lit
condition|;
name|seehx
operator|++
control|)
empty_stmt|;
for|for
control|(
name|seely
operator|=
name|u
operator|.
name|uy
init|;
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|seely
operator|-
literal|1
index|]
operator|.
name|lit
condition|;
name|seely
operator|--
control|)
empty_stmt|;
for|for
control|(
name|seehy
operator|=
name|u
operator|.
name|uy
init|;
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|seehy
operator|+
literal|1
index|]
operator|.
name|lit
condition|;
name|seehy
operator|++
control|)
empty_stmt|;
block|}
for|for
control|(
name|y
operator|=
name|seely
init|;
name|y
operator|<=
name|seehy
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
name|seelx
init|;
name|x
operator|<=
name|seehx
condition|;
name|x
operator|++
control|)
block|{
name|prl
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|levl
index|[
name|u
operator|.
name|ux
index|]
index|[
name|u
operator|.
name|uy
index|]
operator|.
name|lit
condition|)
name|seehx
operator|=
literal|0
expr_stmt|;
comment|/* seems necessary elsewhere */
else|else
block|{
if|if
condition|(
name|seely
operator|==
name|u
operator|.
name|uy
condition|)
for|for
control|(
name|x
operator|=
name|u
operator|.
name|ux
operator|-
literal|1
init|;
name|x
operator|<=
name|u
operator|.
name|ux
operator|+
literal|1
condition|;
name|x
operator|++
control|)
name|prl
argument_list|(
name|x
argument_list|,
name|seely
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|seehy
operator|==
name|u
operator|.
name|uy
condition|)
for|for
control|(
name|x
operator|=
name|u
operator|.
name|ux
operator|-
literal|1
init|;
name|x
operator|<=
name|u
operator|.
name|ux
operator|+
literal|1
condition|;
name|x
operator|++
control|)
name|prl
argument_list|(
name|x
argument_list|,
name|seehy
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|seelx
operator|==
name|u
operator|.
name|ux
condition|)
for|for
control|(
name|y
operator|=
name|u
operator|.
name|uy
operator|-
literal|1
init|;
name|y
operator|<=
name|u
operator|.
name|uy
operator|+
literal|1
condition|;
name|y
operator|++
control|)
name|prl
argument_list|(
name|seelx
operator|-
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|seehx
operator|==
name|u
operator|.
name|ux
condition|)
for|for
control|(
name|y
operator|=
name|u
operator|.
name|uy
operator|-
literal|1
init|;
name|y
operator|<=
name|u
operator|.
name|uy
operator|+
literal|1
condition|;
name|y
operator|++
control|)
name|prl
argument_list|(
name|seehx
operator|+
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|QUEST
end_endif

begin_macro
name|nomul
argument_list|(
argument|nval
argument_list|)
end_macro

begin_decl_stmt
name|int
name|nval
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|multi
operator|<
literal|0
condition|)
return|return;
name|multi
operator|=
name|nval
expr_stmt|;
name|flags
operator|.
name|mv
operator|=
name|flags
operator|.
name|run
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|abon
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|u
operator|.
name|ustr
operator|==
literal|3
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|6
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|17
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|69
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* up to 18/50 */
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|118
condition|)
return|return
operator|(
literal|2
operator|)
return|;
else|else
return|return
operator|(
literal|3
operator|)
return|;
block|}
end_block

begin_macro
name|dbon
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|6
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|16
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|18
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|==
literal|18
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* up to 18 */
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|94
condition|)
return|return
operator|(
literal|3
operator|)
return|;
comment|/* up to 18/75 */
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|109
condition|)
return|return
operator|(
literal|4
operator|)
return|;
comment|/* up to 18/90 */
elseif|else
if|if
condition|(
name|u
operator|.
name|ustr
operator|<
literal|118
condition|)
return|return
operator|(
literal|5
operator|)
return|;
comment|/* up to 18/99 */
else|else
return|return
operator|(
literal|6
operator|)
return|;
block|}
end_block

begin_macro
name|losestr
argument_list|(
argument|num
argument_list|)
end_macro

begin_comment
comment|/* may kill you; cause may be poison or monster like 'A' */
end_comment

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u
operator|.
name|ustr
operator|-=
name|num
expr_stmt|;
while|while
condition|(
name|u
operator|.
name|ustr
operator|<
literal|3
condition|)
block|{
name|u
operator|.
name|ustr
operator|++
expr_stmt|;
name|u
operator|.
name|uhp
operator|-=
literal|6
expr_stmt|;
name|u
operator|.
name|uhpmax
operator|-=
literal|6
expr_stmt|;
block|}
name|flags
operator|.
name|botl
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|losehp
argument_list|(
argument|n
argument_list|,
argument|knam
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|knam
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u
operator|.
name|uhp
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|uhp
operator|>
name|u
operator|.
name|uhpmax
condition|)
name|u
operator|.
name|uhpmax
operator|=
name|u
operator|.
name|uhp
expr_stmt|;
comment|/* perhaps n was negative */
name|flags
operator|.
name|botl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|uhp
operator|<
literal|1
condition|)
block|{
name|killer
operator|=
name|knam
expr_stmt|;
comment|/* the thing that killed you */
name|done
argument_list|(
literal|"died"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|losehp_m
argument_list|(
argument|n
argument_list|,
argument|mtmp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|monst
modifier|*
name|mtmp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u
operator|.
name|uhp
operator|-=
name|n
expr_stmt|;
name|flags
operator|.
name|botl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|uhp
operator|<
literal|1
condition|)
name|done_in_by
argument_list|(
name|mtmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|losexp
argument_list|()
end_macro

begin_comment
comment|/* hit by V or W */
end_comment

begin_block
block|{
name|int
name|num
decl_stmt|;
specifier|extern
name|long
name|newuexp
parameter_list|()
function_decl|;
if|if
condition|(
name|u
operator|.
name|ulevel
operator|>
literal|1
condition|)
name|pline
argument_list|(
literal|"Goodbye level %u."
argument_list|,
name|u
operator|.
name|ulevel
operator|--
argument_list|)
expr_stmt|;
else|else
name|u
operator|.
name|uhp
operator|=
operator|-
literal|1
expr_stmt|;
name|num
operator|=
name|rnd
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|u
operator|.
name|uhp
operator|-=
name|num
expr_stmt|;
name|u
operator|.
name|uhpmax
operator|-=
name|num
expr_stmt|;
name|u
operator|.
name|uexp
operator|=
name|newuexp
argument_list|()
expr_stmt|;
name|flags
operator|.
name|botl
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|inv_weight
argument_list|()
end_macro

begin_block
block|{
name|struct
name|obj
modifier|*
name|otmp
init|=
name|invent
decl_stmt|;
name|int
name|wt
init|=
operator|(
name|u
operator|.
name|ugold
operator|+
literal|500
operator|)
operator|/
literal|1000
decl_stmt|;
name|int
name|carrcap
decl_stmt|;
if|if
condition|(
name|Levitation
condition|)
comment|/* pugh@cornell */
name|carrcap
operator|=
name|MAX_CARR_CAP
expr_stmt|;
else|else
block|{
name|carrcap
operator|=
literal|5
operator|*
operator|(
operator|(
operator|(
name|u
operator|.
name|ustr
operator|>
literal|18
operator|)
condition|?
literal|20
else|:
name|u
operator|.
name|ustr
operator|)
operator|+
name|u
operator|.
name|ulevel
operator|)
expr_stmt|;
if|if
condition|(
name|carrcap
operator|>
name|MAX_CARR_CAP
condition|)
name|carrcap
operator|=
name|MAX_CARR_CAP
expr_stmt|;
if|if
condition|(
name|Wounded_legs
operator|&
name|LEFT_SIDE
condition|)
name|carrcap
operator|-=
literal|10
expr_stmt|;
if|if
condition|(
name|Wounded_legs
operator|&
name|RIGHT_SIDE
condition|)
name|carrcap
operator|-=
literal|10
expr_stmt|;
block|}
while|while
condition|(
name|otmp
condition|)
block|{
name|wt
operator|+=
name|otmp
operator|->
name|owt
expr_stmt|;
name|otmp
operator|=
name|otmp
operator|->
name|nobj
expr_stmt|;
block|}
return|return
operator|(
name|wt
operator|-
name|carrcap
operator|)
return|;
block|}
end_block

begin_macro
name|inv_cnt
argument_list|()
end_macro

begin_block
block|{
name|struct
name|obj
modifier|*
name|otmp
init|=
name|invent
decl_stmt|;
name|int
name|ct
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|otmp
condition|)
block|{
name|ct
operator|++
expr_stmt|;
name|otmp
operator|=
name|otmp
operator|->
name|nobj
expr_stmt|;
block|}
return|return
operator|(
name|ct
operator|)
return|;
block|}
end_block

begin_function
name|long
name|newuexp
parameter_list|()
block|{
return|return
operator|(
literal|10
operator|*
operator|(
literal|1L
operator|<<
operator|(
name|u
operator|.
name|ulevel
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

end_unit

