begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * bs.c - original author: Bruce Holloway  *		salvo option by: Chuck A DeGaul  * with improved user interface, autoconfiguration and code cleanup  *		by Eric S. Raymond<esr@snark.thyrsus.com>  * v1.2 with color support and minor portability fixes, November 1990  * v2.0 featuring strict ANSI/POSIX conformance, November 1993.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|A_UNDERLINE
end_ifndef

begin_comment
comment|/* BSD curses */
end_comment

begin_define
define|#
directive|define
name|beep
parameter_list|()
value|write(1,"\007",1);
end_define

begin_define
define|#
directive|define
name|cbreak
value|crmode
end_define

begin_define
define|#
directive|define
name|saveterm
value|savetty
end_define

begin_define
define|#
directive|define
name|resetterm
value|resetty
end_define

begin_define
define|#
directive|define
name|nocbreak
value|nocrmode
end_define

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !A_UNDERLINE */
end_comment

begin_comment
comment|/*  * Constants for tuning the random-fire algorithm. It prefers moves that  * diagonal-stripe the board with a stripe separation of srchstep. If  * no such preferred moves are found, srchstep is decremented.  */
end_comment

begin_define
define|#
directive|define
name|BEGINSTEP
value|3
end_define

begin_comment
comment|/* initial value of srchstep */
end_comment

begin_comment
comment|/* miscellaneous constants */
end_comment

begin_define
define|#
directive|define
name|SHIPTYPES
value|5
end_define

begin_define
define|#
directive|define
name|OTHER
value|(1-turn)
end_define

begin_define
define|#
directive|define
name|PLAYER
value|0
end_define

begin_define
define|#
directive|define
name|COMPUTER
value|1
end_define

begin_define
define|#
directive|define
name|MARK_HIT
value|'H'
end_define

begin_define
define|#
directive|define
name|MARK_MISS
value|'o'
end_define

begin_define
define|#
directive|define
name|CTRLC
value|'\003'
end_define

begin_comment
comment|/* used as terminate command */
end_comment

begin_define
define|#
directive|define
name|FF
value|'\014'
end_define

begin_comment
comment|/* used as redraw command */
end_comment

begin_comment
comment|/* coordinate handling */
end_comment

begin_define
define|#
directive|define
name|BWIDTH
value|10
end_define

begin_define
define|#
directive|define
name|BDEPTH
value|10
end_define

begin_comment
comment|/* display symbols */
end_comment

begin_define
define|#
directive|define
name|SHOWHIT
value|'*'
end_define

begin_define
define|#
directive|define
name|SHOWSPLASH
value|' '
end_define

begin_define
define|#
directive|define
name|IS_SHIP
parameter_list|(
name|c
parameter_list|)
value|isupper(c)
end_define

begin_comment
comment|/* how to position us on player board */
end_comment

begin_define
define|#
directive|define
name|PYBASE
value|3
end_define

begin_define
define|#
directive|define
name|PXBASE
value|3
end_define

begin_define
define|#
directive|define
name|PY
parameter_list|(
name|y
parameter_list|)
value|(PYBASE + (y))
end_define

begin_define
define|#
directive|define
name|PX
parameter_list|(
name|x
parameter_list|)
value|(PXBASE + (x)*3)
end_define

begin_define
define|#
directive|define
name|pgoto
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
value|(void)move(PY(y), PX(x))
end_define

begin_comment
comment|/* how to position us on cpu board */
end_comment

begin_define
define|#
directive|define
name|CYBASE
value|3
end_define

begin_define
define|#
directive|define
name|CXBASE
value|48
end_define

begin_define
define|#
directive|define
name|CY
parameter_list|(
name|y
parameter_list|)
value|(CYBASE + (y))
end_define

begin_define
define|#
directive|define
name|CX
parameter_list|(
name|x
parameter_list|)
value|(CXBASE + (x)*3)
end_define

begin_define
define|#
directive|define
name|cgoto
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
value|(void)move(CY(y), CX(x))
end_define

begin_define
define|#
directive|define
name|ONBOARD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x>= 0&& x< BWIDTH&& y>= 0&& y< BDEPTH)
end_define

begin_comment
comment|/* other board locations */
end_comment

begin_define
define|#
directive|define
name|COLWIDTH
value|80
end_define

begin_define
define|#
directive|define
name|PROMPTLINE
value|21
end_define

begin_comment
comment|/* prompt line */
end_comment

begin_define
define|#
directive|define
name|SYBASE
value|CYBASE + BDEPTH + 3
end_define

begin_comment
comment|/* move key diagram */
end_comment

begin_define
define|#
directive|define
name|SXBASE
value|63
end_define

begin_define
define|#
directive|define
name|MYBASE
value|SYBASE - 1
end_define

begin_comment
comment|/* diagram caption */
end_comment

begin_define
define|#
directive|define
name|MXBASE
value|64
end_define

begin_define
define|#
directive|define
name|HYBASE
value|SYBASE - 1
end_define

begin_comment
comment|/* help area */
end_comment

begin_define
define|#
directive|define
name|HXBASE
value|0
end_define

begin_comment
comment|/* this will need to be changed if BWIDTH changes */
end_comment

begin_decl_stmt
specifier|static
name|char
name|numbers
index|[]
init|=
literal|"   0  1  2  3  4  5  6  7  8  9"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|carrier
index|[]
init|=
literal|"Aircraft Carrier"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|battle
index|[]
init|=
literal|"Battleship"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sub
index|[]
init|=
literal|"Submarine"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|destroy
index|[]
init|=
literal|"Destroyer"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ptboat
index|[]
init|=
literal|"PT Boat"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|name
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dftname
index|[]
init|=
literal|"stranger"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* direction constants */
end_comment

begin_enum
enum|enum
name|directions
block|{
name|E
block|,
name|SE
block|,
name|S
block|,
name|SW
block|,
name|W
block|,
name|NW
block|,
name|N
block|,
name|NE
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|xincr
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|yincr
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current ship position and direction */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curx
init|=
operator|(
name|BWIDTH
operator|/
literal|2
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cury
init|=
operator|(
name|BDEPTH
operator|/
literal|2
operator|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the ship type */
name|unsigned
name|int
name|hits
decl_stmt|;
comment|/* how many times has this ship been hit? */
name|char
name|symbol
decl_stmt|;
comment|/* symbol for game purposes */
name|char
name|length
decl_stmt|;
comment|/* length of ship */
name|char
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* coordinates of ship start point */
name|enum
name|directions
name|dir
decl_stmt|;
comment|/* direction of `bow' */
name|bool
name|placed
decl_stmt|;
comment|/* has it been placed on the board? */
block|}
name|ship_t
typedef|;
end_typedef

begin_decl_stmt
name|ship_t
name|plyship
index|[
name|SHIPTYPES
index|]
init|=
block|{
block|{
name|carrier
block|,
literal|0
block|,
literal|'A'
block|,
literal|5
block|}
block|,
block|{
name|battle
block|,
literal|0
block|,
literal|'B'
block|,
literal|4
block|}
block|,
block|{
name|destroy
block|,
literal|0
block|,
literal|'D'
block|,
literal|3
block|}
block|,
block|{
name|sub
block|,
literal|0
block|,
literal|'S'
block|,
literal|3
block|}
block|,
block|{
name|ptboat
block|,
literal|0
block|,
literal|'P'
block|,
literal|2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ship_t
name|cpuship
index|[
name|SHIPTYPES
index|]
init|=
block|{
block|{
name|carrier
block|,
literal|0
block|,
literal|'A'
block|,
literal|5
block|}
block|,
block|{
name|battle
block|,
literal|0
block|,
literal|'B'
block|,
literal|4
block|}
block|,
block|{
name|destroy
block|,
literal|0
block|,
literal|'D'
block|,
literal|3
block|}
block|,
block|{
name|sub
block|,
literal|0
block|,
literal|'S'
block|,
literal|3
block|}
block|,
block|{
name|ptboat
block|,
literal|0
block|,
literal|'P'
block|,
literal|2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "Hits" board, and main board. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hits
index|[
literal|2
index|]
index|[
name|BWIDTH
index|]
index|[
name|BDEPTH
index|]
decl_stmt|,
name|board
index|[
literal|2
index|]
index|[
name|BWIDTH
index|]
index|[
name|BDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|turn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0=player, 1=computer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|plywon
init|=
literal|0
decl_stmt|,
name|cpuwon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many games has each won? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|salvo
decl_stmt|,
name|blitz
decl_stmt|,
name|closepack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PR
value|(void)addstr
end_define

begin_function_decl
specifier|static
name|bool
name|checkplace
parameter_list|(
name|int
parameter_list|,
name|ship_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getcoord
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|playagain
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|uninitgame
parameter_list|(
name|sig
parameter_list|)
comment|/* end the game, either normally or due to signal */
name|int
name|sig
decl_stmt|;
block|{
name|clear
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|resetterm
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|echo
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|announceopts
parameter_list|()
comment|/* announce which game options are enabled */
block|{
if|if
condition|(
name|salvo
operator|||
name|blitz
operator|||
name|closepack
condition|)
block|{
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Playing optional game ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|salvo
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"salvo, "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"nosalvo, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|blitz
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"blitz "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"noblitz, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|closepack
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"closepack)"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"noclosepack)"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Playing standard game (noblitz, nosalvo, noclosepack)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intro
parameter_list|()
block|{
name|char
modifier|*
name|tmpname
decl_stmt|;
name|srandomdev
argument_list|()
expr_stmt|;
name|tmpname
operator|=
name|getlogin
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|uninitgame
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|uninitgame
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|uninitgame
argument_list|)
expr_stmt|;
comment|/* for assert(3) */
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|uninitgame
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpname
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|toupper
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|dftname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initscr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|KEY_MIN
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KEY_MIN */
operator|(
name|void
operator|)
name|saveterm
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|nonl
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cbreak
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|noecho
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PENGUIN
operator|(
name|void
operator|)
name|clear
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|29
argument_list|,
literal|"Welcome to Battleship!"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"                                                  \\\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"                           \\                     \\ \\\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"                          \\ \\                   \\ \\ \\_____________\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"                         \\ \\ \\_____________      \\ \\/            |\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"                          \\ \\/             \\      \\/             |\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"                           \\/               \\_____/              |__\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"           ________________/                                       |\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"           \\  S.S. Penguin                                         |\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"            \\                                                     /\n"
argument_list|)
expr_stmt|;
name|PR
argument_list|(
literal|"             \\___________________________________________________/\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
literal|22
argument_list|,
literal|27
argument_list|,
literal|"Hit any key to continue..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PENGUIN */
ifdef|#
directive|ifdef
name|A_COLOR
name|start_color
argument_list|()
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_BLACK
argument_list|,
name|COLOR_BLACK
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_GREEN
argument_list|,
name|COLOR_GREEN
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_RED
argument_list|,
name|COLOR_RED
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_CYAN
argument_list|,
name|COLOR_CYAN
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_WHITE
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_MAGENTA
argument_list|,
name|COLOR_MAGENTA
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_BLUE
argument_list|,
name|COLOR_BLUE
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
name|COLOR_YELLOW
argument_list|,
name|COLOR_YELLOW
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
block|}
end_function

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
specifier|static
name|void
name|prompt
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|s
parameter_list|)
comment|/* print a message at the prompt line */
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|PROMPTLINE
operator|+
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
name|f
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|move
argument_list|(
name|PROMPTLINE
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|placeship
parameter_list|(
name|b
parameter_list|,
name|ss
parameter_list|,
name|vis
parameter_list|)
name|int
name|b
decl_stmt|;
name|ship_t
modifier|*
name|ss
decl_stmt|;
name|int
name|vis
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|ss
operator|->
name|length
condition|;
operator|++
name|l
control|)
block|{
name|int
name|newx
init|=
name|ss
operator|->
name|x
operator|+
name|l
operator|*
name|xincr
index|[
name|ss
operator|->
name|dir
index|]
decl_stmt|;
name|int
name|newy
init|=
name|ss
operator|->
name|y
operator|+
name|l
operator|*
name|yincr
index|[
name|ss
operator|->
name|dir
index|]
decl_stmt|;
name|board
index|[
name|b
index|]
index|[
name|newx
index|]
index|[
name|newy
index|]
operator|=
name|ss
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|vis
condition|)
block|{
name|pgoto
argument_list|(
name|newy
argument_list|,
name|newx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|ss
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
name|ss
operator|->
name|hits
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rnd
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
name|random
argument_list|()
operator|%
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|randomplace
parameter_list|(
name|b
parameter_list|,
name|ss
parameter_list|)
comment|/* generate a valid random ship placement into px,py */
name|int
name|b
decl_stmt|;
name|ship_t
modifier|*
name|ss
decl_stmt|;
block|{
name|int
name|bwidth
init|=
name|BWIDTH
operator|-
name|ss
operator|->
name|length
decl_stmt|;
name|int
name|bdepth
init|=
name|BDEPTH
operator|-
name|ss
operator|->
name|length
decl_stmt|;
do|do
block|{
name|ss
operator|->
name|y
operator|=
name|rnd
argument_list|(
name|bdepth
argument_list|)
expr_stmt|;
name|ss
operator|->
name|x
operator|=
name|rnd
argument_list|(
name|bwidth
argument_list|)
expr_stmt|;
name|ss
operator|->
name|dir
operator|=
name|rnd
argument_list|(
literal|2
argument_list|)
condition|?
name|E
else|:
name|S
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|checkplace
argument_list|(
name|b
argument_list|,
name|ss
argument_list|,
name|FALSE
argument_list|)
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|initgame
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|unplaced
decl_stmt|;
name|ship_t
modifier|*
name|ss
decl_stmt|;
operator|(
name|void
operator|)
name|clear
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|35
argument_list|,
literal|"BATTLESHIPS"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|move
argument_list|(
name|PROMPTLINE
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|announceopts
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|board
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|BWIDTH
operator|*
name|BDEPTH
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hits
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|BWIDTH
operator|*
name|BDEPTH
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHIPTYPES
condition|;
name|i
operator|++
control|)
block|{
name|ss
operator|=
name|cpuship
operator|+
name|i
expr_stmt|;
name|ss
operator|->
name|x
operator|=
name|ss
operator|->
name|y
operator|=
name|ss
operator|->
name|dir
operator|=
name|ss
operator|->
name|hits
operator|=
name|ss
operator|->
name|placed
operator|=
literal|0
expr_stmt|;
name|ss
operator|=
name|plyship
operator|+
name|i
expr_stmt|;
name|ss
operator|->
name|x
operator|=
name|ss
operator|->
name|y
operator|=
name|ss
operator|->
name|dir
operator|=
name|ss
operator|->
name|hits
operator|=
name|ss
operator|->
name|placed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* draw empty boards */
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|PYBASE
operator|-
literal|2
argument_list|,
name|PXBASE
operator|+
literal|5
argument_list|,
literal|"Main Board"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|PYBASE
operator|-
literal|1
argument_list|,
name|PXBASE
operator|-
literal|3
argument_list|,
name|numbers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BDEPTH
condition|;
operator|++
name|i
control|)
block|{
operator|(
name|void
operator|)
name|mvaddch
argument_list|(
name|PYBASE
operator|+
name|i
argument_list|,
name|PXBASE
operator|-
literal|3
argument_list|,
name|i
operator|+
literal|'A'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|COLOR_BLUE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BWIDTH
condition|;
name|j
operator|++
control|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|" . "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
name|attrset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
name|i
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|PYBASE
operator|+
name|BDEPTH
argument_list|,
name|PXBASE
operator|-
literal|3
argument_list|,
name|numbers
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|CYBASE
operator|-
literal|2
argument_list|,
name|CXBASE
operator|+
literal|7
argument_list|,
literal|"Hit/Miss Board"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|CYBASE
operator|-
literal|1
argument_list|,
name|CXBASE
operator|-
literal|3
argument_list|,
name|numbers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BDEPTH
condition|;
operator|++
name|i
control|)
block|{
operator|(
name|void
operator|)
name|mvaddch
argument_list|(
name|CYBASE
operator|+
name|i
argument_list|,
name|CXBASE
operator|-
literal|3
argument_list|,
name|i
operator|+
literal|'A'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|COLOR_BLUE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BWIDTH
condition|;
name|j
operator|++
control|)
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|" . "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
name|attrset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
operator|(
name|void
operator|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
name|i
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|CYBASE
operator|+
name|BDEPTH
argument_list|,
name|CXBASE
operator|-
literal|3
argument_list|,
name|numbers
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
argument_list|,
name|HXBASE
argument_list|,
literal|"To position your ships: move the cursor to a spot, then"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|1
argument_list|,
name|HXBASE
argument_list|,
literal|"type the first letter of a ship type to select it, then"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|2
argument_list|,
name|HXBASE
argument_list|,
literal|"type a direction ([hjkl] or [4862]), indicating how the"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|3
argument_list|,
name|HXBASE
argument_list|,
literal|"ship should be pointed. You may also type a ship letter"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|4
argument_list|,
name|HXBASE
argument_list|,
literal|"followed by `r' to position it randomly, or type `R' to"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|5
argument_list|,
name|HXBASE
argument_list|,
literal|"place all remaining ships randomly."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|MYBASE
argument_list|,
name|MXBASE
argument_list|,
literal|"Aiming keys:"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|SYBASE
argument_list|,
name|SXBASE
argument_list|,
literal|"y k u    7 8 9"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|SYBASE
operator|+
literal|1
argument_list|,
name|SXBASE
argument_list|,
literal|" \\|/      \\|/ "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|SYBASE
operator|+
literal|2
argument_list|,
name|SXBASE
argument_list|,
literal|"h-+-l    4-+-6"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|SYBASE
operator|+
literal|3
argument_list|,
name|SXBASE
argument_list|,
literal|" /|\\      /|\\ "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|SYBASE
operator|+
literal|4
argument_list|,
name|SXBASE
argument_list|,
literal|"b j n    1 2 3"
argument_list|)
expr_stmt|;
comment|/* have the computer place ships */
for|for
control|(
name|ss
operator|=
name|cpuship
init|;
name|ss
operator|<
name|cpuship
operator|+
name|SHIPTYPES
condition|;
name|ss
operator|++
control|)
block|{
name|randomplace
argument_list|(
name|COMPUTER
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|placeship
argument_list|(
name|COMPUTER
argument_list|,
name|ss
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ss
operator|=
operator|(
name|ship_t
operator|*
operator|)
name|NULL
expr_stmt|;
do|do
block|{
name|char
name|c
decl_stmt|,
name|docked
index|[
name|SHIPTYPES
operator|+
literal|2
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|docked
decl_stmt|;
comment|/* figure which ships still wait to be placed */
operator|*
name|cp
operator|++
operator|=
literal|'R'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHIPTYPES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|plyship
index|[
name|i
index|]
operator|.
name|placed
condition|)
operator|*
name|cp
operator|++
operator|=
name|plyship
index|[
name|i
index|]
operator|.
name|symbol
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* get a command letter */
name|prompt
argument_list|(
literal|1
argument_list|,
literal|"Type one of [%s] to pick a ship."
argument_list|,
name|docked
operator|+
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|c
operator|=
name|getcoord
argument_list|(
name|PLAYER
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|strchr
argument_list|(
name|docked
argument_list|,
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'R'
condition|)
operator|(
name|void
operator|)
name|ungetch
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* map that into the corresponding symbol */
for|for
control|(
name|ss
operator|=
name|plyship
init|;
name|ss
operator|<
name|plyship
operator|+
name|SHIPTYPES
condition|;
name|ss
operator|++
control|)
if|if
condition|(
name|ss
operator|->
name|symbol
operator|==
name|c
condition|)
break|break;
name|prompt
argument_list|(
literal|1
argument_list|,
literal|"Type one of [hjklrR] to place your %s."
argument_list|,
name|ss
operator|->
name|name
argument_list|)
expr_stmt|;
name|pgoto
argument_list|(
name|cury
argument_list|,
name|curx
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|strchr
argument_list|(
literal|"hjklrR"
argument_list|,
name|c
argument_list|)
operator|||
name|c
operator|==
name|FF
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|FF
condition|)
block|{
operator|(
name|void
operator|)
name|clearok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
block|{
name|prompt
argument_list|(
literal|1
argument_list|,
literal|"Random-placing your %s"
argument_list|,
name|ss
operator|->
name|name
argument_list|)
expr_stmt|;
name|randomplace
argument_list|(
name|PLAYER
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|placeship
argument_list|(
name|PLAYER
argument_list|,
name|ss
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ss
operator|->
name|placed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'R'
condition|)
block|{
name|prompt
argument_list|(
literal|1
argument_list|,
literal|"Placing the rest of your fleet at random..."
argument_list|)
expr_stmt|;
for|for
control|(
name|ss
operator|=
name|plyship
init|;
name|ss
operator|<
name|plyship
operator|+
name|SHIPTYPES
condition|;
name|ss
operator|++
control|)
if|if
condition|(
operator|!
name|ss
operator|->
name|placed
condition|)
block|{
name|randomplace
argument_list|(
name|PLAYER
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|placeship
argument_list|(
name|PLAYER
argument_list|,
name|ss
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ss
operator|->
name|placed
operator|=
name|TRUE
expr_stmt|;
block|}
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"hjkl8462"
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|ss
operator|->
name|x
operator|=
name|curx
expr_stmt|;
name|ss
operator|->
name|y
operator|=
name|cury
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'k'
case|:
case|case
literal|'8'
case|:
name|ss
operator|->
name|dir
operator|=
name|N
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
case|case
literal|'2'
case|:
name|ss
operator|->
name|dir
operator|=
name|S
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'4'
case|:
name|ss
operator|->
name|dir
operator|=
name|W
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'6'
case|:
name|ss
operator|->
name|dir
operator|=
name|E
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|checkplace
argument_list|(
name|PLAYER
argument_list|,
name|ss
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|placeship
argument_list|(
name|PLAYER
argument_list|,
name|ss
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ss
operator|->
name|placed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
for|for
control|(
name|unplaced
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHIPTYPES
condition|;
name|i
operator|++
control|)
name|unplaced
operator|+=
operator|!
name|plyship
index|[
name|i
index|]
operator|.
name|placed
expr_stmt|;
block|}
do|while
condition|(
name|unplaced
condition|)
do|;
name|turn
operator|=
name|rnd
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
argument_list|,
name|HXBASE
argument_list|,
literal|"To fire, move the cursor to your chosen aiming point   "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|1
argument_list|,
name|HXBASE
argument_list|,
literal|"and strike any key other than a motion key.            "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|2
argument_list|,
name|HXBASE
argument_list|,
literal|"                                                       "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|3
argument_list|,
name|HXBASE
argument_list|,
literal|"                                                       "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|4
argument_list|,
name|HXBASE
argument_list|,
literal|"                                                       "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|5
argument_list|,
name|HXBASE
argument_list|,
literal|"                                                       "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|prompt
argument_list|(
literal|0
argument_list|,
literal|"Press any key to start..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|getcoord
parameter_list|(
name|atcpu
parameter_list|)
name|int
name|atcpu
decl_stmt|;
block|{
name|int
name|ny
decl_stmt|,
name|nx
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|atcpu
condition|)
name|cgoto
argument_list|(
name|cury
argument_list|,
name|curx
argument_list|)
expr_stmt|;
else|else
name|pgoto
argument_list|(
name|cury
argument_list|,
name|curx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|atcpu
condition|)
block|{
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|CYBASE
operator|+
name|BDEPTH
operator|+
literal|1
argument_list|,
name|CXBASE
operator|+
literal|11
argument_list|,
literal|"(%d, %c)"
argument_list|,
name|curx
argument_list|,
literal|'A'
operator|+
name|cury
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|cury
argument_list|,
name|curx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|PYBASE
operator|+
name|BDEPTH
operator|+
literal|1
argument_list|,
name|PXBASE
operator|+
literal|11
argument_list|,
literal|"(%d, %c)"
argument_list|,
name|curx
argument_list|,
literal|'A'
operator|+
name|cury
argument_list|)
expr_stmt|;
name|pgoto
argument_list|(
name|cury
argument_list|,
name|curx
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|=
name|getch
argument_list|()
condition|)
block|{
case|case
literal|'k'
case|:
case|case
literal|'8'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_UP
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
operator|+
name|BDEPTH
operator|-
literal|1
expr_stmt|;
name|nx
operator|=
name|curx
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
case|case
literal|'2'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_DOWN
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
operator|+
literal|1
expr_stmt|;
name|nx
operator|=
name|curx
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'4'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_LEFT
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
expr_stmt|;
name|nx
operator|=
name|curx
operator|+
name|BWIDTH
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'6'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_RIGHT
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
expr_stmt|;
name|nx
operator|=
name|curx
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'7'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_A1
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
operator|+
name|BDEPTH
operator|-
literal|1
expr_stmt|;
name|nx
operator|=
name|curx
operator|+
name|BWIDTH
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'1'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_C1
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
operator|+
literal|1
expr_stmt|;
name|nx
operator|=
name|curx
operator|+
name|BWIDTH
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'9'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_A3
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
operator|+
name|BDEPTH
operator|-
literal|1
expr_stmt|;
name|nx
operator|=
name|curx
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'3'
case|:
ifdef|#
directive|ifdef
name|KEY_MIN
case|case
name|KEY_C3
case|:
endif|#
directive|endif
comment|/* KEY_MIN */
name|ny
operator|=
name|cury
operator|+
literal|1
expr_stmt|;
name|nx
operator|=
name|curx
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|FF
case|:
name|nx
operator|=
name|curx
expr_stmt|;
name|ny
operator|=
name|cury
expr_stmt|;
operator|(
name|void
operator|)
name|clearok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|atcpu
condition|)
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|CYBASE
operator|+
name|BDEPTH
operator|+
literal|1
argument_list|,
name|CXBASE
operator|+
literal|11
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
name|PYBASE
operator|+
name|BDEPTH
operator|+
literal|1
argument_list|,
name|PXBASE
operator|+
literal|11
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|curx
operator|=
name|nx
operator|%
name|BWIDTH
expr_stmt|;
name|cury
operator|=
name|ny
operator|%
name|BDEPTH
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|collidecheck
parameter_list|(
name|b
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|)
comment|/* is this location on the selected zboard adjacent to a ship? */
name|int
name|b
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
name|int
name|collide
decl_stmt|;
comment|/* anything on the square */
if|if
condition|(
operator|(
name|collide
operator|=
name|IS_SHIP
argument_list|(
name|board
index|[
name|b
index|]
index|[
name|x
index|]
index|[
name|y
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|collide
operator|)
return|;
comment|/* anything on the neighbors */
if|if
condition|(
operator|!
name|closepack
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|int
name|xend
decl_stmt|,
name|yend
decl_stmt|;
name|yend
operator|=
name|y
operator|+
name|yincr
index|[
name|i
index|]
expr_stmt|;
name|xend
operator|=
name|x
operator|+
name|xincr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ONBOARD
argument_list|(
name|xend
argument_list|,
name|yend
argument_list|)
condition|)
name|collide
operator|+=
name|IS_SHIP
argument_list|(
name|board
index|[
name|b
index|]
index|[
name|xend
index|]
index|[
name|yend
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|collide
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|checkplace
parameter_list|(
name|b
parameter_list|,
name|ss
parameter_list|,
name|vis
parameter_list|)
name|int
name|b
decl_stmt|;
name|ship_t
modifier|*
name|ss
decl_stmt|;
name|int
name|vis
decl_stmt|;
block|{
name|int
name|l
decl_stmt|,
name|xend
decl_stmt|,
name|yend
decl_stmt|;
comment|/* first, check for board edges */
name|xend
operator|=
name|ss
operator|->
name|x
operator|+
name|ss
operator|->
name|length
operator|*
name|xincr
index|[
name|ss
operator|->
name|dir
index|]
expr_stmt|;
name|yend
operator|=
name|ss
operator|->
name|y
operator|+
name|ss
operator|->
name|length
operator|*
name|yincr
index|[
name|ss
operator|->
name|dir
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ONBOARD
argument_list|(
name|xend
argument_list|,
name|yend
argument_list|)
condition|)
block|{
if|if
condition|(
name|vis
condition|)
switch|switch
condition|(
name|rnd
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"Ship is hanging from the edge of the world"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|error
argument_list|(
literal|"Try fitting it on the board"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error
argument_list|(
literal|"Figure I won't find it if you put it there?"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|ss
operator|->
name|length
condition|;
operator|++
name|l
control|)
block|{
if|if
condition|(
name|collidecheck
argument_list|(
name|b
argument_list|,
name|ss
operator|->
name|y
operator|+
name|l
operator|*
name|yincr
index|[
name|ss
operator|->
name|dir
index|]
argument_list|,
name|ss
operator|->
name|x
operator|+
name|l
operator|*
name|xincr
index|[
name|ss
operator|->
name|dir
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|vis
condition|)
switch|switch
condition|(
name|rnd
argument_list|(
literal|3
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"There's already a ship there"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|error
argument_list|(
literal|"Collision alert!  Aaaaaagh!"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error
argument_list|(
literal|"Er, Admiral, what about the other ship?"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awinna
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ship_t
modifier|*
name|ss
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|ss
operator|=
operator|(
name|i
operator|)
condition|?
name|cpuship
else|:
name|plyship
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SHIPTYPES
condition|;
operator|++
name|j
operator|,
operator|++
name|ss
control|)
if|if
condition|(
name|ss
operator|->
name|length
operator|>
name|ss
operator|->
name|hits
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|SHIPTYPES
condition|)
return|return
operator|(
name|OTHER
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ship_t
modifier|*
name|hitship
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
comment|/* a hit on the targeted ship */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|ship_t
modifier|*
name|sb
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
name|char
name|sym
decl_stmt|;
name|int
name|oldx
decl_stmt|,
name|oldy
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|(
name|turn
operator|)
condition|?
name|plyship
else|:
name|cpuship
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sym
operator|=
name|board
index|[
name|OTHER
index|]
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
condition|)
return|return
operator|(
operator|(
name|ship_t
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|ss
operator|=
name|sb
init|;
name|ss
operator|<
name|sb
operator|+
name|SHIPTYPES
condition|;
operator|++
name|ss
control|)
if|if
condition|(
name|ss
operator|->
name|symbol
operator|==
name|sym
condition|)
block|{
if|if
condition|(
operator|++
name|ss
operator|->
name|hits
operator|<
name|ss
operator|->
name|length
condition|)
comment|/* still afloat? */
return|return
operator|(
operator|(
name|ship_t
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
comment|/* sunk! */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|closepack
condition|)
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|<=
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|int
name|bx
init|=
name|ss
operator|->
name|x
operator|+
name|j
operator|*
name|xincr
index|[
operator|(
name|ss
operator|->
name|dir
operator|+
literal|2
operator|)
operator|%
literal|8
index|]
decl_stmt|;
name|int
name|by
init|=
name|ss
operator|->
name|y
operator|+
name|j
operator|*
name|yincr
index|[
operator|(
name|ss
operator|->
name|dir
operator|+
literal|2
operator|)
operator|%
literal|8
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|ss
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|bx
operator|+
name|i
operator|*
name|xincr
index|[
name|ss
operator|->
name|dir
index|]
expr_stmt|;
name|y
operator|=
name|by
operator|+
name|i
operator|*
name|yincr
index|[
name|ss
operator|->
name|dir
index|]
expr_stmt|;
if|if
condition|(
name|ONBOARD
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|hits
index|[
name|turn
index|]
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|MARK_MISS
expr_stmt|;
if|if
condition|(
name|turn
operator|%
literal|2
operator|==
name|PLAYER
condition|)
block|{
name|cgoto
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|COLOR_GREEN
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
operator|(
name|void
operator|)
name|addch
argument_list|(
name|MARK_MISS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
name|attrset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
block|}
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|x
init|=
name|ss
operator|->
name|x
operator|+
name|i
operator|*
name|xincr
index|[
name|ss
operator|->
name|dir
index|]
decl_stmt|;
name|int
name|y
init|=
name|ss
operator|->
name|y
operator|+
name|i
operator|*
name|yincr
index|[
name|ss
operator|->
name|dir
index|]
decl_stmt|;
name|hits
index|[
name|turn
index|]
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|ss
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|turn
operator|%
literal|2
operator|==
name|PLAYER
condition|)
block|{
name|cgoto
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
name|ss
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|move
argument_list|(
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ss
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|move
argument_list|(
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ship_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|plyturn
parameter_list|()
block|{
name|ship_t
modifier|*
name|ss
decl_stmt|;
name|bool
name|hit
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|prompt
argument_list|(
literal|1
argument_list|,
literal|"Where do you want to shoot? "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|getcoord
argument_list|(
name|COMPUTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|hits
index|[
name|PLAYER
index|]
index|[
name|curx
index|]
index|[
name|cury
index|]
condition|)
block|{
name|prompt
argument_list|(
literal|1
argument_list|,
literal|"You shelled this spot already! Try again."
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
block|}
name|hit
operator|=
name|IS_SHIP
argument_list|(
name|board
index|[
name|COMPUTER
index|]
index|[
name|curx
index|]
index|[
name|cury
index|]
argument_list|)
expr_stmt|;
name|hits
index|[
name|PLAYER
index|]
index|[
name|curx
index|]
index|[
name|cury
index|]
operator|=
name|hit
condition|?
name|MARK_HIT
else|:
name|MARK_MISS
expr_stmt|;
name|cgoto
argument_list|(
name|cury
argument_list|,
name|curx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
if|if
condition|(
name|hit
condition|)
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|COLOR_RED
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|COLOR_GREEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* A_COLOR */
operator|(
name|void
operator|)
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|hits
index|[
name|PLAYER
index|]
index|[
name|curx
index|]
index|[
name|cury
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
name|attrset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
name|prompt
argument_list|(
literal|1
argument_list|,
literal|"You %s."
argument_list|,
name|hit
condition|?
literal|"scored a hit"
else|:
literal|"missed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit
operator|&&
operator|(
name|ss
operator|=
name|hitship
argument_list|(
name|curx
argument_list|,
name|cury
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|rnd
argument_list|(
literal|5
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|m
operator|=
literal|" You sank my %s!"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|m
operator|=
literal|" I have this sinking feeling about my %s...."
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|m
operator|=
literal|" My %s has gone to Davy Jones's locker!"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|m
operator|=
literal|" Glub, glub -- my %s is headed for the bottom!"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|m
operator|=
literal|" You'll pick up survivors from my %s, I hope...!"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|printw
argument_list|(
name|m
argument_list|,
name|ss
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
name|awinna
argument_list|()
operator|==
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|hit
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sgetc
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|int
name|ch
decl_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|toupper
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CTRLC
condition|)
name|uninitgame
argument_list|()
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|s
init|;
operator|*
name|s1
operator|&&
name|ch
operator|!=
operator|*
name|s1
condition|;
operator|++
name|s1
control|)
continue|continue;
if|if
condition|(
operator|*
name|s1
condition|)
block|{
operator|(
name|void
operator|)
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|ch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|randomfire
parameter_list|(
name|px
parameter_list|,
name|py
parameter_list|)
comment|/* random-fire routine -- implements simple diagonal-striping strategy */
name|int
modifier|*
name|px
decl_stmt|,
decl|*
name|py
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|int
name|turncount
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|srchstep
init|=
name|BEGINSTEP
decl_stmt|;
specifier|static
name|int
name|huntoffs
decl_stmt|;
comment|/* Offset on search strategy */
name|int
name|ypossible
index|[
name|BWIDTH
operator|*
name|BDEPTH
index|]
decl_stmt|,
name|xpossible
index|[
name|BWIDTH
operator|*
name|BDEPTH
index|]
decl_stmt|,
name|nposs
decl_stmt|;
name|int
name|ypreferred
index|[
name|BWIDTH
operator|*
name|BDEPTH
index|]
decl_stmt|,
name|xpreferred
index|[
name|BWIDTH
operator|*
name|BDEPTH
index|]
decl_stmt|,
name|npref
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|turncount
operator|++
operator|==
literal|0
condition|)
name|huntoffs
operator|=
name|rnd
argument_list|(
name|srchstep
argument_list|)
expr_stmt|;
comment|/* first, list all possible moves */
name|nposs
operator|=
name|npref
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|BWIDTH
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|BDEPTH
condition|;
name|y
operator|++
control|)
if|if
condition|(
operator|!
name|hits
index|[
name|COMPUTER
index|]
index|[
name|x
index|]
index|[
name|y
index|]
condition|)
block|{
name|xpossible
index|[
name|nposs
index|]
operator|=
name|x
expr_stmt|;
name|ypossible
index|[
name|nposs
index|]
operator|=
name|y
expr_stmt|;
name|nposs
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|+
name|huntoffs
operator|)
operator|%
name|srchstep
operator|)
operator|!=
operator|(
name|y
operator|%
name|srchstep
operator|)
condition|)
block|{
name|xpreferred
index|[
name|npref
index|]
operator|=
name|x
expr_stmt|;
name|ypreferred
index|[
name|npref
index|]
operator|=
name|y
expr_stmt|;
name|npref
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|npref
condition|)
block|{
name|i
operator|=
name|rnd
argument_list|(
name|npref
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|xpreferred
index|[
name|i
index|]
expr_stmt|;
operator|*
name|py
operator|=
name|ypreferred
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nposs
condition|)
block|{
name|i
operator|=
name|rnd
argument_list|(
name|nposs
argument_list|)
expr_stmt|;
operator|*
name|px
operator|=
name|xpossible
index|[
name|i
index|]
expr_stmt|;
operator|*
name|py
operator|=
name|ypossible
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|srchstep
operator|>
literal|1
condition|)
operator|--
name|srchstep
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"No moves possible?? Help!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_block

begin_define
define|#
directive|define
name|S_MISS
value|0
end_define

begin_define
define|#
directive|define
name|S_HIT
value|1
end_define

begin_define
define|#
directive|define
name|S_SUNK
value|-1
end_define

begin_function
specifier|static
name|bool
name|cpufire
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
comment|/* fire away at given location */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|bool
name|hit
decl_stmt|,
name|sunk
decl_stmt|;
name|ship_t
modifier|*
name|ss
decl_stmt|;
name|ss
operator|=
name|NULL
expr_stmt|;
name|hits
index|[
name|COMPUTER
index|]
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
operator|(
name|hit
operator|=
operator|(
name|board
index|[
name|PLAYER
index|]
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
operator|)
condition|?
name|MARK_HIT
else|:
name|MARK_MISS
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|PROMPTLINE
argument_list|,
literal|0
argument_list|,
literal|"I shoot at %c%d. I %s!"
argument_list|,
name|y
operator|+
literal|'A'
argument_list|,
name|x
argument_list|,
name|hit
condition|?
literal|"hit"
else|:
literal|"miss"
argument_list|)
expr_stmt|;
name|ss
operator|=
name|hitship
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|sunk
operator|=
name|hit
operator|&&
name|ss
expr_stmt|;
if|if
condition|(
name|sunk
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|" I've sunk your %s"
argument_list|,
name|ss
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clrtoeol
argument_list|()
expr_stmt|;
name|pgoto
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
if|if
condition|(
name|hit
condition|)
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|COLOR_RED
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|COLOR_GREEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* A_COLOR */
operator|(
name|void
operator|)
name|addch
argument_list|(
call|(
name|chtype
call|)
argument_list|(
name|hit
condition|?
name|SHOWHIT
else|:
name|SHOWSPLASH
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|A_COLOR
name|attrset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A_COLOR */
return|return
operator|(
name|hit
condition|?
operator|(
name|sunk
condition|?
name|S_SUNK
else|:
name|S_HIT
operator|)
else|:
name|S_MISS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code implements a fairly irregular FSM, so please forgive the rampant  * unstructuredness below. The five labels are states which need to be held  * between computer turns.  */
end_comment

begin_function
specifier|static
name|bool
name|cputurn
parameter_list|()
block|{
define|#
directive|define
name|POSSIBLE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(ONBOARD(x, y)&& !hits[COMPUTER][x][y])
define|#
directive|define
name|RANDOM_FIRE
value|0
define|#
directive|define
name|RANDOM_HIT
value|1
define|#
directive|define
name|HUNT_DIRECT
value|2
define|#
directive|define
name|FIRST_PASS
value|3
define|#
directive|define
name|REVERSE_JUMP
value|4
define|#
directive|define
name|SECOND_PASS
value|5
specifier|static
name|int
name|next
init|=
name|RANDOM_FIRE
decl_stmt|;
specifier|static
name|bool
name|used
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|ship_t
name|ts
decl_stmt|;
name|int
name|navail
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|d
decl_stmt|,
name|n
decl_stmt|,
name|hit
init|=
name|S_MISS
decl_stmt|;
switch|switch
condition|(
name|next
condition|)
block|{
case|case
name|RANDOM_FIRE
case|:
comment|/* last shot was random and missed */
name|refire
label|:
name|randomfire
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hit
operator|=
name|cpufire
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
condition|)
name|next
operator|=
name|RANDOM_FIRE
expr_stmt|;
else|else
block|{
name|ts
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ts
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|ts
operator|.
name|hits
operator|=
literal|1
expr_stmt|;
name|next
operator|=
operator|(
name|hit
operator|==
name|S_SUNK
operator|)
condition|?
name|RANDOM_FIRE
else|:
name|RANDOM_HIT
expr_stmt|;
block|}
break|break;
case|case
name|RANDOM_HIT
case|:
comment|/* last shot was random and hit */
name|used
index|[
name|E
operator|/
literal|2
index|]
operator|=
name|used
index|[
name|S
operator|/
literal|2
index|]
operator|=
name|used
index|[
name|W
operator|/
literal|2
index|]
operator|=
name|used
index|[
name|N
operator|/
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HUNT_DIRECT
case|:
comment|/* last shot hit, we're looking for ship's long axis */
for|for
control|(
name|d
operator|=
name|navail
operator|=
literal|0
init|;
name|d
operator|<
literal|4
condition|;
name|d
operator|++
control|)
block|{
name|x
operator|=
name|ts
operator|.
name|x
operator|+
name|xincr
index|[
name|d
operator|*
literal|2
index|]
expr_stmt|;
name|y
operator|=
name|ts
operator|.
name|y
operator|+
name|yincr
index|[
name|d
operator|*
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|used
index|[
name|d
index|]
operator|&&
name|POSSIBLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
name|navail
operator|++
expr_stmt|;
else|else
name|used
index|[
name|d
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|navail
operator|==
literal|0
condition|)
comment|/* no valid places for shots adjacent... */
goto|goto
name|refire
goto|;
comment|/* ...so we must random-fire */
else|else
block|{
for|for
control|(
name|d
operator|=
literal|0
operator|,
name|n
operator|=
name|rnd
argument_list|(
name|navail
argument_list|)
operator|+
literal|1
init|;
name|n
condition|;
name|n
operator|--
control|)
while|while
condition|(
name|used
index|[
name|d
index|]
condition|)
name|d
operator|++
expr_stmt|;
name|assert
argument_list|(
name|d
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|used
index|[
name|d
index|]
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|ts
operator|.
name|x
operator|+
name|xincr
index|[
name|d
operator|*
literal|2
index|]
expr_stmt|;
name|y
operator|=
name|ts
operator|.
name|y
operator|+
name|yincr
index|[
name|d
operator|*
literal|2
index|]
expr_stmt|;
name|assert
argument_list|(
name|POSSIBLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hit
operator|=
name|cpufire
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
condition|)
name|next
operator|=
name|HUNT_DIRECT
expr_stmt|;
else|else
block|{
name|ts
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ts
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|ts
operator|.
name|dir
operator|=
name|d
operator|*
literal|2
expr_stmt|;
name|ts
operator|.
name|hits
operator|++
expr_stmt|;
name|next
operator|=
operator|(
name|hit
operator|==
name|S_SUNK
operator|)
condition|?
name|RANDOM_FIRE
else|:
name|FIRST_PASS
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FIRST_PASS
case|:
comment|/* we have a start and a direction now */
name|x
operator|=
name|ts
operator|.
name|x
operator|+
name|xincr
index|[
name|ts
operator|.
name|dir
index|]
expr_stmt|;
name|y
operator|=
name|ts
operator|.
name|y
operator|+
name|yincr
index|[
name|ts
operator|.
name|dir
index|]
expr_stmt|;
if|if
condition|(
name|POSSIBLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|(
name|hit
operator|=
name|cpufire
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ts
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|ts
operator|.
name|hits
operator|++
expr_stmt|;
name|next
operator|=
operator|(
name|hit
operator|==
name|S_SUNK
operator|)
condition|?
name|RANDOM_FIRE
else|:
name|FIRST_PASS
expr_stmt|;
block|}
else|else
name|next
operator|=
name|REVERSE_JUMP
expr_stmt|;
break|break;
case|case
name|REVERSE_JUMP
case|:
comment|/* nail down the ship's other end */
name|d
operator|=
name|ts
operator|.
name|dir
operator|+
literal|4
expr_stmt|;
name|x
operator|=
name|ts
operator|.
name|x
operator|+
name|ts
operator|.
name|hits
operator|*
name|xincr
index|[
name|d
index|]
expr_stmt|;
name|y
operator|=
name|ts
operator|.
name|y
operator|+
name|ts
operator|.
name|hits
operator|*
name|yincr
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
name|POSSIBLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|(
name|hit
operator|=
name|cpufire
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ts
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|ts
operator|.
name|dir
operator|=
name|d
expr_stmt|;
name|ts
operator|.
name|hits
operator|++
expr_stmt|;
name|next
operator|=
operator|(
name|hit
operator|==
name|S_SUNK
operator|)
condition|?
name|RANDOM_FIRE
else|:
name|SECOND_PASS
expr_stmt|;
block|}
else|else
name|next
operator|=
name|RANDOM_FIRE
expr_stmt|;
break|break;
case|case
name|SECOND_PASS
case|:
comment|/* kill squares not caught on first pass */
name|x
operator|=
name|ts
operator|.
name|x
operator|+
name|xincr
index|[
name|ts
operator|.
name|dir
index|]
expr_stmt|;
name|y
operator|=
name|ts
operator|.
name|y
operator|+
name|yincr
index|[
name|ts
operator|.
name|dir
index|]
expr_stmt|;
if|if
condition|(
name|POSSIBLE
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|(
name|hit
operator|=
name|cpufire
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
condition|)
block|{
name|ts
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ts
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|ts
operator|.
name|hits
operator|++
expr_stmt|;
name|next
operator|=
operator|(
name|hit
operator|==
name|S_SUNK
operator|)
condition|?
name|RANDOM_FIRE
else|:
name|SECOND_PASS
expr_stmt|;
break|break;
block|}
else|else
name|next
operator|=
name|RANDOM_FIRE
expr_stmt|;
break|break;
block|}
comment|/* check for continuation and/or winner */
if|if
condition|(
name|salvo
condition|)
block|{
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|awinna
argument_list|()
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|PROMPTLINE
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|"New state %d, x=%d, y=%d, d=%d"
argument_list|,
name|next
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|hit
operator|)
return|;
block|}
end_function

begin_function
name|int
name|playagain
parameter_list|()
block|{
name|int
name|j
decl_stmt|;
name|ship_t
modifier|*
name|ss
decl_stmt|;
for|for
control|(
name|ss
operator|=
name|cpuship
init|;
name|ss
operator|<
name|cpuship
operator|+
name|SHIPTYPES
condition|;
name|ss
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ss
operator|->
name|length
condition|;
name|j
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|ss
operator|->
name|y
operator|+
name|j
operator|*
name|yincr
index|[
name|ss
operator|->
name|dir
index|]
argument_list|,
name|ss
operator|->
name|x
operator|+
name|j
operator|*
name|xincr
index|[
name|ss
operator|->
name|dir
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|ss
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|awinna
argument_list|()
condition|)
operator|++
name|cpuwon
expr_stmt|;
else|else
operator|++
name|plywon
expr_stmt|;
name|j
operator|=
literal|18
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|plywon
operator|>=
literal|10
condition|)
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|cpuwon
operator|>=
literal|10
condition|)
operator|++
name|j
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
literal|1
argument_list|,
operator|(
name|COLWIDTH
operator|-
name|j
operator|)
operator|/
literal|2
argument_list|,
literal|"%s: %d     Computer: %d"
argument_list|,
name|name
argument_list|,
name|plywon
argument_list|,
name|cpuwon
argument_list|)
expr_stmt|;
name|prompt
argument_list|(
literal|2
argument_list|,
operator|(
name|awinna
argument_list|()
operator|)
condition|?
literal|"Want to be humiliated again, %s [yn]? "
else|:
literal|"Going to give me a chance for revenge, %s [yn]? "
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|sgetc
argument_list|(
literal|"YN"
argument_list|)
operator|==
literal|'Y'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_options
parameter_list|(
name|c
parameter_list|,
name|op
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|op
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|op
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
default|default:
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: battle [-s | -b] [-c]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tWhere the options are:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-s : play a salvo game\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-b : play a blitz game\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-c : ships may be adjacent\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
switch|switch
condition|(
name|op
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|blitz
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|salvo
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad Arg: -b and -s are mutually exclusive\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|salvo
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|blitz
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad Arg: -s and -b are mutually exclusive\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|closepack
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad arg: type \"%s ?\" for usage message\n"
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scount
parameter_list|(
name|who
parameter_list|)
name|int
name|who
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|shots
decl_stmt|;
name|ship_t
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|who
condition|)
name|sp
operator|=
name|cpuship
expr_stmt|;
comment|/* count cpu shots */
else|else
name|sp
operator|=
name|plyship
expr_stmt|;
comment|/* count player shots */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shots
operator|=
literal|0
init|;
name|i
operator|<
name|SHIPTYPES
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|hits
operator|>=
name|sp
operator|->
name|length
condition|)
continue|continue;
comment|/* dead ship */
else|else
name|shots
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|shots
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
comment|/* revoke */
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|do_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|intro
argument_list|()
expr_stmt|;
do|do
block|{
name|initgame
argument_list|()
expr_stmt|;
while|while
condition|(
name|awinna
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|blitz
condition|)
block|{
if|if
condition|(
operator|!
name|salvo
condition|)
block|{
if|if
condition|(
name|turn
condition|)
operator|(
name|void
operator|)
name|cputurn
argument_list|()
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|plyturn
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|scount
argument_list|(
name|turn
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
name|turn
condition|)
block|{
if|if
condition|(
name|cputurn
argument_list|()
operator|&&
name|awinna
argument_list|()
operator|!=
operator|-
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|plyturn
argument_list|()
operator|&&
name|awinna
argument_list|()
operator|!=
operator|-
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
while|while
condition|(
name|turn
condition|?
name|cputurn
argument_list|()
else|:
name|plyturn
argument_list|()
condition|)
continue|continue;
name|turn
operator|=
name|OTHER
expr_stmt|;
block|}
block|}
do|while
condition|(
name|playagain
argument_list|()
condition|)
do|;
name|uninitgame
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* bs.c ends here */
end_comment

end_unit

