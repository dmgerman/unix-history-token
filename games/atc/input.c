begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ed James.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1987 by Ed James, UC Berkeley.  All rights reserved.  *  * Copy permission is hereby granted provided that this notice is  * retained on all partial or complete copies.  *  * For more info on this and all of my stuff, mail edjames@berkeley.edu.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)input.c	8.1 (Berkeley) 5/31/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"include.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|MAXRULES
value|6
end_define

begin_define
define|#
directive|define
name|MAXDEPTH
value|15
end_define

begin_define
define|#
directive|define
name|RETTOKEN
value|'\n'
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|CRTOKEN
value|'\r'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REDRAWTOKEN
value|'\014'
end_define

begin_comment
comment|/* CTRL(L) */
end_comment

begin_define
define|#
directive|define
name|SHELLTOKEN
value|'!'
end_define

begin_define
define|#
directive|define
name|HELPTOKEN
value|'?'
end_define

begin_define
define|#
directive|define
name|ALPHATOKEN
value|256
end_define

begin_define
define|#
directive|define
name|NUMTOKEN
value|257
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|token
decl_stmt|;
name|int
name|to_state
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
block|}
name|RULE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|num_rules
decl_stmt|;
name|RULE
modifier|*
name|rule
decl_stmt|;
block|}
name|STATE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|rule
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|}
name|STACK
typedef|;
end_typedef

begin_define
define|#
directive|define
name|T_RULE
value|stack[level].rule
end_define

begin_define
define|#
directive|define
name|T_STATE
value|stack[level].state
end_define

begin_define
define|#
directive|define
name|T_STR
value|stack[level].str
end_define

begin_define
define|#
directive|define
name|T_POS
value|stack[level].pos
end_define

begin_define
define|#
directive|define
name|T_CH
value|stack[level].ch
end_define

begin_define
define|#
directive|define
name|NUMELS
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (*(a)))
end_define

begin_define
define|#
directive|define
name|NUMSTATES
value|NUMELS(st)
end_define

begin_decl_stmt
name|char
modifier|*
name|setplane
argument_list|()
decl_stmt|,
modifier|*
name|circle
argument_list|()
decl_stmt|,
modifier|*
name|left
argument_list|()
decl_stmt|,
modifier|*
name|right
argument_list|()
decl_stmt|,
modifier|*
name|Left
argument_list|()
decl_stmt|,
modifier|*
name|Right
argument_list|()
decl_stmt|,
modifier|*
name|beacon
argument_list|()
decl_stmt|,
modifier|*
name|ex_it
argument_list|()
decl_stmt|,
modifier|*
name|climb
argument_list|()
decl_stmt|,
modifier|*
name|descend
argument_list|()
decl_stmt|,
modifier|*
name|setalt
argument_list|()
decl_stmt|,
modifier|*
name|setrelalt
argument_list|()
decl_stmt|,
modifier|*
name|benum
argument_list|()
decl_stmt|,
modifier|*
name|to_dir
argument_list|()
decl_stmt|,
modifier|*
name|rel_dir
argument_list|()
decl_stmt|,
modifier|*
name|delayb
argument_list|()
decl_stmt|,
modifier|*
name|mark
argument_list|()
decl_stmt|,
modifier|*
name|unmark
argument_list|()
decl_stmt|,
modifier|*
name|airport
argument_list|()
decl_stmt|,
modifier|*
name|turn
argument_list|()
decl_stmt|,
modifier|*
name|ignore
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RULE
name|state0
index|[]
init|=
block|{
block|{
name|ALPHATOKEN
block|,
literal|1
block|,
literal|"%c:"
block|,
name|setplane
block|}
block|,
block|{
name|RETTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|SYSV
block|{
name|CRTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" [a-z]<ret>"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state1
index|[]
init|=
block|{
block|{
literal|'t'
block|,
literal|2
block|,
literal|" turn"
block|,
name|turn
block|}
block|,
block|{
literal|'a'
block|,
literal|3
block|,
literal|" altitude:"
block|,
name|NULL
block|}
block|,
block|{
literal|'c'
block|,
literal|4
block|,
literal|" circle"
block|,
name|circle
block|}
block|,
block|{
literal|'m'
block|,
literal|7
block|,
literal|" mark"
block|,
name|mark
block|}
block|,
block|{
literal|'u'
block|,
literal|7
block|,
literal|" unmark"
block|,
name|unmark
block|}
block|,
block|{
literal|'i'
block|,
literal|7
block|,
literal|" ignore"
block|,
name|ignore
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" tacmui"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state2
index|[]
init|=
block|{
block|{
literal|'l'
block|,
literal|6
block|,
literal|" left"
block|,
name|left
block|}
block|,
block|{
literal|'r'
block|,
literal|6
block|,
literal|" right"
block|,
name|right
block|}
block|,
block|{
literal|'L'
block|,
literal|4
block|,
literal|" left 90"
block|,
name|Left
block|}
block|,
block|{
literal|'R'
block|,
literal|4
block|,
literal|" right 90"
block|,
name|Right
block|}
block|,
block|{
literal|'t'
block|,
literal|11
block|,
literal|" towards"
block|,
name|NULL
block|}
block|,
block|{
literal|'w'
block|,
literal|4
block|,
literal|" to 0"
block|,
name|to_dir
block|}
block|,
block|{
literal|'e'
block|,
literal|4
block|,
literal|" to 45"
block|,
name|to_dir
block|}
block|,
block|{
literal|'d'
block|,
literal|4
block|,
literal|" to 90"
block|,
name|to_dir
block|}
block|,
block|{
literal|'c'
block|,
literal|4
block|,
literal|" to 135"
block|,
name|to_dir
block|}
block|,
block|{
literal|'x'
block|,
literal|4
block|,
literal|" to 180"
block|,
name|to_dir
block|}
block|,
block|{
literal|'z'
block|,
literal|4
block|,
literal|" to 225"
block|,
name|to_dir
block|}
block|,
block|{
literal|'a'
block|,
literal|4
block|,
literal|" to 270"
block|,
name|to_dir
block|}
block|,
block|{
literal|'q'
block|,
literal|4
block|,
literal|" to 315"
block|,
name|to_dir
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" lrLRt<dir>"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state3
index|[]
init|=
block|{
block|{
literal|'+'
block|,
literal|10
block|,
literal|" climb"
block|,
name|climb
block|}
block|,
block|{
literal|'c'
block|,
literal|10
block|,
literal|" climb"
block|,
name|climb
block|}
block|,
block|{
literal|'-'
block|,
literal|10
block|,
literal|" descend"
block|,
name|descend
block|}
block|,
block|{
literal|'d'
block|,
literal|10
block|,
literal|" descend"
block|,
name|descend
block|}
block|,
block|{
name|NUMTOKEN
block|,
literal|7
block|,
literal|" %c000 feet"
block|,
name|setalt
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" +-cd[0-9]"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state4
index|[]
init|=
block|{
block|{
literal|'@'
block|,
literal|9
block|,
literal|" at"
block|,
name|NULL
block|}
block|,
block|{
literal|'a'
block|,
literal|9
block|,
literal|" at"
block|,
name|NULL
block|}
block|,
block|{
name|RETTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|SYSV
block|{
name|CRTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" @a<ret>"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state5
index|[]
init|=
block|{
block|{
name|NUMTOKEN
block|,
literal|7
block|,
literal|"%c"
block|,
name|delayb
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" [0-9]"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state6
index|[]
init|=
block|{
block|{
literal|'@'
block|,
literal|9
block|,
literal|" at"
block|,
name|NULL
block|}
block|,
block|{
literal|'a'
block|,
literal|9
block|,
literal|" at"
block|,
name|NULL
block|}
block|,
block|{
literal|'w'
block|,
literal|4
block|,
literal|" 0"
block|,
name|rel_dir
block|}
block|,
block|{
literal|'e'
block|,
literal|4
block|,
literal|" 45"
block|,
name|rel_dir
block|}
block|,
block|{
literal|'d'
block|,
literal|4
block|,
literal|" 90"
block|,
name|rel_dir
block|}
block|,
block|{
literal|'c'
block|,
literal|4
block|,
literal|" 135"
block|,
name|rel_dir
block|}
block|,
block|{
literal|'x'
block|,
literal|4
block|,
literal|" 180"
block|,
name|rel_dir
block|}
block|,
block|{
literal|'z'
block|,
literal|4
block|,
literal|" 225"
block|,
name|rel_dir
block|}
block|,
block|{
literal|'a'
block|,
literal|4
block|,
literal|" 270"
block|,
name|rel_dir
block|}
block|,
block|{
literal|'q'
block|,
literal|4
block|,
literal|" 315"
block|,
name|rel_dir
block|}
block|,
block|{
name|RETTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|SYSV
block|{
name|CRTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" @a<dir><ret>"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state7
index|[]
init|=
block|{
block|{
name|RETTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
ifdef|#
directive|ifdef
name|SYSV
block|{
name|CRTOKEN
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|"<ret>"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state8
index|[]
init|=
block|{
block|{
name|NUMTOKEN
block|,
literal|4
block|,
literal|"%c"
block|,
name|benum
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" [0-9]"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state9
index|[]
init|=
block|{
block|{
literal|'b'
block|,
literal|5
block|,
literal|" beacon #"
block|,
name|NULL
block|}
block|,
block|{
literal|'*'
block|,
literal|5
block|,
literal|" beacon #"
block|,
name|NULL
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" b*"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state10
index|[]
init|=
block|{
block|{
name|NUMTOKEN
block|,
literal|7
block|,
literal|" %c000 ft"
block|,
name|setrelalt
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" [0-9]"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state11
index|[]
init|=
block|{
block|{
literal|'b'
block|,
literal|8
block|,
literal|" beacon #"
block|,
name|beacon
block|}
block|,
block|{
literal|'*'
block|,
literal|8
block|,
literal|" beacon #"
block|,
name|beacon
block|}
block|,
block|{
literal|'e'
block|,
literal|8
block|,
literal|" exit #"
block|,
name|ex_it
block|}
block|,
block|{
literal|'a'
block|,
literal|8
block|,
literal|" airport #"
block|,
name|airport
block|}
block|,
block|{
name|HELPTOKEN
block|,
literal|12
block|,
literal|" b*ea"
block|,
name|NULL
block|}
block|}
decl_stmt|,
name|state12
index|[]
init|=
block|{
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|""
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEF_STATE
parameter_list|(
name|s
parameter_list|)
value|{ NUMELS(s),	(s)	}
end_define

begin_decl_stmt
name|STATE
name|st
index|[]
init|=
block|{
name|DEF_STATE
argument_list|(
name|state0
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state1
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state2
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state3
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state4
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state5
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state6
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state7
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state8
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state9
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state10
argument_list|)
block|,
name|DEF_STATE
argument_list|(
name|state11
argument_list|)
block|,
name|DEF_STATE
argument_list|(
argument|state12
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PLANE
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STACK
name|stack
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dest_type
decl_stmt|,
name|dest_no
decl_stmt|,
name|dir
decl_stmt|;
end_decl_stmt

begin_macro
name|pop
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|level
operator|--
expr_stmt|;
name|ioclrtoeol
argument_list|(
name|T_POS
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|T_STR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|T_RULE
operator|=
operator|-
literal|1
expr_stmt|;
name|T_CH
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rezero
argument_list|()
end_macro

begin_block
block|{
name|iomove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|T_STATE
operator|=
literal|0
expr_stmt|;
name|T_RULE
operator|=
operator|-
literal|1
expr_stmt|;
name|T_CH
operator|=
operator|-
literal|1
expr_stmt|;
name|T_POS
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|T_STR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|push
argument_list|(
argument|ruleno
argument_list|,
argument|ch
argument_list|)
end_macro

begin_block
block|{
name|int
name|newstate
decl_stmt|,
name|newpos
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|T_STR
argument_list|,
name|st
index|[
name|T_STATE
index|]
operator|.
name|rule
index|[
name|ruleno
index|]
operator|.
name|str
argument_list|,
name|tval
argument_list|)
expr_stmt|;
name|T_RULE
operator|=
name|ruleno
expr_stmt|;
name|T_CH
operator|=
name|ch
expr_stmt|;
name|newstate
operator|=
name|st
index|[
name|T_STATE
index|]
operator|.
name|rule
index|[
name|ruleno
index|]
operator|.
name|to_state
expr_stmt|;
name|newpos
operator|=
name|T_POS
operator|+
name|strlen
argument_list|(
name|T_STR
argument_list|)
expr_stmt|;
name|ioaddstr
argument_list|(
name|T_POS
argument_list|,
name|T_STR
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|ioclrtobot
argument_list|()
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|T_STATE
operator|=
name|newstate
expr_stmt|;
name|T_POS
operator|=
name|newpos
expr_stmt|;
name|T_RULE
operator|=
operator|-
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|T_STR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getcommand
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|done
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
name|PLANE
modifier|*
name|pp
decl_stmt|;
name|rezero
argument_list|()
expr_stmt|;
do|do
block|{
name|c
operator|=
name|gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|tty_new
operator|.
name|sg_erase
condition|)
block|{
if|if
condition|(
name|pop
argument_list|()
operator|<
literal|0
condition|)
name|noise
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|tty_new
operator|.
name|sg_kill
condition|)
block|{
while|while
condition|(
name|pop
argument_list|()
operator|>=
literal|0
condition|)
empty_stmt|;
block|}
else|else
block|{
name|done
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|st
index|[
name|T_STATE
index|]
operator|.
name|num_rules
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|st
index|[
name|T_STATE
index|]
operator|.
name|rule
index|[
name|i
index|]
operator|.
name|token
operator|==
name|c
operator|||
name|st
index|[
name|T_STATE
index|]
operator|.
name|rule
index|[
name|i
index|]
operator|.
name|token
operator|==
name|tval
condition|)
block|{
name|push
argument_list|(
name|i
argument_list|,
operator|(
name|c
operator|>=
name|ALPHATOKEN
operator|)
condition|?
name|tval
else|:
name|c
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
name|noise
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|T_STATE
operator|!=
operator|-
literal|1
condition|)
do|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* forced update */
name|dest_type
operator|=
name|T_NODEST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
block|{
name|func
operator|=
name|st
index|[
name|stack
index|[
name|i
index|]
operator|.
name|state
index|]
operator|.
name|rule
index|[
name|stack
index|[
name|i
index|]
operator|.
name|rule
index|]
operator|.
name|func
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|s
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|stack
index|[
name|i
index|]
operator|.
name|ch
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ioerror
argument_list|(
name|stack
index|[
name|i
index|]
operator|.
name|pos
argument_list|,
name|strlen
argument_list|(
name|stack
index|[
name|i
index|]
operator|.
name|str
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|pp
operator|=
name|findplane
argument_list|(
name|p
operator|.
name|plane_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|new_altitude
operator|!=
name|p
operator|.
name|new_altitude
condition|)
name|pp
operator|->
name|new_altitude
operator|=
name|p
operator|.
name|new_altitude
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|->
name|status
operator|!=
name|p
operator|.
name|status
condition|)
name|pp
operator|->
name|status
operator|=
name|p
operator|.
name|status
expr_stmt|;
else|else
block|{
name|pp
operator|->
name|new_dir
operator|=
name|p
operator|.
name|new_dir
expr_stmt|;
name|pp
operator|->
name|delayd
operator|=
name|p
operator|.
name|delayd
expr_stmt|;
name|pp
operator|->
name|delayd_no
operator|=
name|p
operator|.
name|delayd_no
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|noise
argument_list|()
end_macro

begin_block
block|{
name|putchar
argument_list|(
literal|'\07'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gettoken
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
operator|(
name|tval
operator|=
name|getAChar
argument_list|()
operator|)
operator|==
name|REDRAWTOKEN
operator|||
name|tval
operator|==
name|SHELLTOKEN
condition|)
block|{
if|if
condition|(
name|tval
operator|==
name|SHELLTOKEN
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
name|struct
name|itimerval
name|itv
decl_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSV
name|int
name|aval
decl_stmt|;
name|aval
operator|=
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
comment|/* child */
block|{
name|char
modifier|*
name|shell
decl_stmt|,
modifier|*
name|base
decl_stmt|;
comment|/* revoke */
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|done_screen
argument_list|()
expr_stmt|;
comment|/* run user's favorite shell */
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|base
operator|=
name|strrchr
argument_list|(
name|shell
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
name|base
operator|=
name|shell
expr_stmt|;
else|else
name|base
operator|++
expr_stmt|;
name|execl
argument_list|(
name|shell
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|execl
argument_list|(
name|_PATH_BSHELL
argument_list|,
literal|"sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* oops */
block|}
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty_new
argument_list|)
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|1
expr_stmt|;
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|sp
operator|->
name|update_secs
expr_stmt|;
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSV
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|tty_new
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|aval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|redraw
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|tval
argument_list|)
condition|)
return|return
operator|(
name|NUMTOKEN
operator|)
return|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|tval
argument_list|)
condition|)
return|return
operator|(
name|ALPHATOKEN
operator|)
return|;
else|else
return|return
operator|(
name|tval
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|setplane
parameter_list|(
name|c
parameter_list|)
block|{
name|PLANE
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|findplane
argument_list|(
name|number
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"Unknown Plane"
operator|)
return|;
name|bcopy
argument_list|(
name|pp
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|delayd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|turn
parameter_list|(
name|c
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|altitude
operator|==
literal|0
condition|)
return|return
operator|(
literal|"Planes at airports may not change direction"
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|circle
parameter_list|(
name|c
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|altitude
operator|==
literal|0
condition|)
return|return
operator|(
literal|"Planes cannot circle on the ground"
operator|)
return|;
name|p
operator|.
name|new_dir
operator|=
name|MAXDIR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|left
parameter_list|(
name|c
parameter_list|)
block|{
name|dir
operator|=
name|D_LEFT
expr_stmt|;
name|p
operator|.
name|new_dir
operator|=
name|p
operator|.
name|dir
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|new_dir
operator|<
literal|0
condition|)
name|p
operator|.
name|new_dir
operator|+=
name|MAXDIR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|right
parameter_list|(
name|c
parameter_list|)
block|{
name|dir
operator|=
name|D_RIGHT
expr_stmt|;
name|p
operator|.
name|new_dir
operator|=
name|p
operator|.
name|dir
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|new_dir
operator|>=
name|MAXDIR
condition|)
name|p
operator|.
name|new_dir
operator|-=
name|MAXDIR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Left
parameter_list|(
name|c
parameter_list|)
block|{
name|p
operator|.
name|new_dir
operator|=
name|p
operator|.
name|dir
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|new_dir
operator|<
literal|0
condition|)
name|p
operator|.
name|new_dir
operator|+=
name|MAXDIR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Right
parameter_list|(
name|c
parameter_list|)
block|{
name|p
operator|.
name|new_dir
operator|=
name|p
operator|.
name|dir
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|new_dir
operator|>=
name|MAXDIR
condition|)
name|p
operator|.
name|new_dir
operator|-=
name|MAXDIR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|delayb
parameter_list|(
name|c
parameter_list|)
block|{
name|int
name|xdiff
decl_stmt|,
name|ydiff
decl_stmt|;
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|sp
operator|->
name|num_beacons
condition|)
return|return
operator|(
literal|"Unknown beacon"
operator|)
return|;
name|xdiff
operator|=
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|x
operator|-
name|p
operator|.
name|xpos
expr_stmt|;
name|xdiff
operator|=
name|SGN
argument_list|(
name|xdiff
argument_list|)
expr_stmt|;
name|ydiff
operator|=
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|y
operator|-
name|p
operator|.
name|ypos
expr_stmt|;
name|ydiff
operator|=
name|SGN
argument_list|(
name|ydiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdiff
operator|!=
name|displacement
index|[
name|p
operator|.
name|dir
index|]
operator|.
name|dx
operator|||
name|ydiff
operator|!=
name|displacement
index|[
name|p
operator|.
name|dir
index|]
operator|.
name|dy
condition|)
return|return
operator|(
literal|"Beacon is not in flight path"
operator|)
return|;
name|p
operator|.
name|delayd
operator|=
literal|1
expr_stmt|;
name|p
operator|.
name|delayd_no
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|dest_type
operator|!=
name|T_NODEST
condition|)
block|{
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|T_BEACON
case|:
name|xdiff
operator|=
name|sp
operator|->
name|beacon
index|[
name|dest_no
index|]
operator|.
name|x
operator|-
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|x
expr_stmt|;
name|ydiff
operator|=
name|sp
operator|->
name|beacon
index|[
name|dest_no
index|]
operator|.
name|y
operator|-
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|y
expr_stmt|;
break|break;
case|case
name|T_EXIT
case|:
name|xdiff
operator|=
name|sp
operator|->
name|exit
index|[
name|dest_no
index|]
operator|.
name|x
operator|-
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|x
expr_stmt|;
name|ydiff
operator|=
name|sp
operator|->
name|exit
index|[
name|dest_no
index|]
operator|.
name|y
operator|-
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|y
expr_stmt|;
break|break;
case|case
name|T_AIRPORT
case|:
name|xdiff
operator|=
name|sp
operator|->
name|airport
index|[
name|dest_no
index|]
operator|.
name|x
operator|-
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|x
expr_stmt|;
name|ydiff
operator|=
name|sp
operator|->
name|airport
index|[
name|dest_no
index|]
operator|.
name|y
operator|-
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|y
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|"Bad case in delayb!  Get help!"
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|xdiff
operator|==
literal|0
operator|&&
name|ydiff
operator|==
literal|0
condition|)
return|return
operator|(
literal|"Would already be there"
operator|)
return|;
name|p
operator|.
name|new_dir
operator|=
name|DIR_FROM_DXDY
argument_list|(
name|xdiff
argument_list|,
name|ydiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|new_dir
operator|==
name|p
operator|.
name|dir
condition|)
return|return
operator|(
literal|"Already going in that direction"
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|beacon
parameter_list|(
name|c
parameter_list|)
block|{
name|dest_type
operator|=
name|T_BEACON
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ex_it
parameter_list|(
name|c
parameter_list|)
block|{
name|dest_type
operator|=
name|T_EXIT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|airport
parameter_list|(
name|c
parameter_list|)
block|{
name|dest_type
operator|=
name|T_AIRPORT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|climb
parameter_list|(
name|c
parameter_list|)
block|{
name|dir
operator|=
name|D_UP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|descend
parameter_list|(
name|c
parameter_list|)
block|{
name|dir
operator|=
name|D_DOWN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|setalt
parameter_list|(
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p
operator|.
name|altitude
operator|==
name|c
operator|-
literal|'0'
operator|)
operator|&&
operator|(
name|p
operator|.
name|new_altitude
operator|==
name|p
operator|.
name|altitude
operator|)
condition|)
return|return
operator|(
literal|"Already at that altitude"
operator|)
return|;
name|p
operator|.
name|new_altitude
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|setrelalt
parameter_list|(
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|"altitude not changed"
operator|)
return|;
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|D_UP
case|:
name|p
operator|.
name|new_altitude
operator|=
name|p
operator|.
name|altitude
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
name|D_DOWN
case|:
name|p
operator|.
name|new_altitude
operator|=
name|p
operator|.
name|altitude
operator|-
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|"Unknown case in setrelalt!  Get help!"
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|p
operator|.
name|new_altitude
operator|<
literal|0
condition|)
return|return
operator|(
literal|"Altitude would be too low"
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|.
name|new_altitude
operator|>
literal|9
condition|)
return|return
operator|(
literal|"Altitude would be too high"
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|benum
parameter_list|(
name|c
parameter_list|)
block|{
name|dest_no
operator|=
name|c
operator|-=
literal|'0'
expr_stmt|;
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|T_BEACON
case|:
if|if
condition|(
name|c
operator|>=
name|sp
operator|->
name|num_beacons
condition|)
return|return
operator|(
literal|"Unknown beacon"
operator|)
return|;
name|p
operator|.
name|new_dir
operator|=
name|DIR_FROM_DXDY
argument_list|(
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|x
operator|-
name|p
operator|.
name|xpos
argument_list|,
name|sp
operator|->
name|beacon
index|[
name|c
index|]
operator|.
name|y
operator|-
name|p
operator|.
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_EXIT
case|:
if|if
condition|(
name|c
operator|>=
name|sp
operator|->
name|num_exits
condition|)
return|return
operator|(
literal|"Unknown exit"
operator|)
return|;
name|p
operator|.
name|new_dir
operator|=
name|DIR_FROM_DXDY
argument_list|(
name|sp
operator|->
name|exit
index|[
name|c
index|]
operator|.
name|x
operator|-
name|p
operator|.
name|xpos
argument_list|,
name|sp
operator|->
name|exit
index|[
name|c
index|]
operator|.
name|y
operator|-
name|p
operator|.
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_AIRPORT
case|:
if|if
condition|(
name|c
operator|>=
name|sp
operator|->
name|num_airports
condition|)
return|return
operator|(
literal|"Unknown airport"
operator|)
return|;
name|p
operator|.
name|new_dir
operator|=
name|DIR_FROM_DXDY
argument_list|(
name|sp
operator|->
name|airport
index|[
name|c
index|]
operator|.
name|x
operator|-
name|p
operator|.
name|xpos
argument_list|,
name|sp
operator|->
name|airport
index|[
name|c
index|]
operator|.
name|y
operator|-
name|p
operator|.
name|ypos
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|"Unknown case in benum!  Get help!"
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|to_dir
parameter_list|(
name|c
parameter_list|)
block|{
name|p
operator|.
name|new_dir
operator|=
name|dir_no
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rel_dir
parameter_list|(
name|c
parameter_list|)
block|{
name|int
name|angle
decl_stmt|;
name|angle
operator|=
name|dir_no
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|D_LEFT
case|:
name|p
operator|.
name|new_dir
operator|=
name|p
operator|.
name|dir
operator|-
name|angle
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|new_dir
operator|<
literal|0
condition|)
name|p
operator|.
name|new_dir
operator|+=
name|MAXDIR
expr_stmt|;
break|break;
case|case
name|D_RIGHT
case|:
name|p
operator|.
name|new_dir
operator|=
name|p
operator|.
name|dir
operator|+
name|angle
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|new_dir
operator|>=
name|MAXDIR
condition|)
name|p
operator|.
name|new_dir
operator|-=
name|MAXDIR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|"Bizarre direction in rel_dir!  Get help!"
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|mark
parameter_list|(
name|c
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|altitude
operator|==
literal|0
condition|)
return|return
operator|(
literal|"Cannot mark planes on the ground"
operator|)
return|;
if|if
condition|(
name|p
operator|.
name|status
operator|==
name|S_MARKED
condition|)
return|return
operator|(
literal|"Already marked"
operator|)
return|;
name|p
operator|.
name|status
operator|=
name|S_MARKED
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unmark
parameter_list|(
name|c
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|altitude
operator|==
literal|0
condition|)
return|return
operator|(
literal|"Cannot unmark planes on the ground"
operator|)
return|;
if|if
condition|(
name|p
operator|.
name|status
operator|==
name|S_UNMARKED
condition|)
return|return
operator|(
literal|"Already unmarked"
operator|)
return|;
name|p
operator|.
name|status
operator|=
name|S_UNMARKED
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ignore
parameter_list|(
name|c
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|altitude
operator|==
literal|0
condition|)
return|return
operator|(
literal|"Cannot ignore planes on the ground"
operator|)
return|;
if|if
condition|(
name|p
operator|.
name|status
operator|==
name|S_IGNORED
condition|)
return|return
operator|(
literal|"Already ignored"
operator|)
return|;
name|p
operator|.
name|status
operator|=
name|S_IGNORED
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|dir_no
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dir
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'w'
case|:
name|dir
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|dir
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dir
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|dir
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|dir
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|dir
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|dir
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|dir
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad character in dir_no\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|dir
operator|)
return|;
block|}
end_block

end_unit

