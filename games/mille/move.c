begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)move.c	8.1 (Berkeley) 5/31/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"mille.h"
end_include

begin_include
include|#
directive|include
file|<unctrl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|attron
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_define
define|#
directive|define
name|_tty
value|cur_term->Nttyb
end_define

begin_endif
endif|#
directive|endif
endif|attron
end_endif

begin_comment
comment|/*  * @(#)move.c	1.2 (Berkeley) 3/28/83  */
end_comment

begin_undef
undef|#
directive|undef
name|CTRL
end_undef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|c
parameter_list|)
value|(c - 'A' + 1)
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|Movenames
index|[]
init|=
block|{
literal|"M_DISCARD"
block|,
literal|"M_DRAW"
block|,
literal|"M_PLAY"
block|,
literal|"M_ORDER"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|check_go
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getmove
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|haspicked
parameter_list|(
name|PLAY
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|playcard
parameter_list|(
name|PLAY
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|domove
parameter_list|()
block|{
name|PLAY
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|goodplay
decl_stmt|;
name|pp
operator|=
operator|&
name|Player
index|[
name|Play
index|]
expr_stmt|;
if|if
condition|(
name|Play
operator|==
name|PLAYER
condition|)
name|getmove
argument_list|()
expr_stmt|;
else|else
name|calcmove
argument_list|()
expr_stmt|;
name|Next
operator|=
name|FALSE
expr_stmt|;
name|goodplay
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|Movetype
condition|)
block|{
case|case
name|M_DISCARD
case|:
if|if
condition|(
name|haspicked
argument_list|(
name|pp
argument_list|)
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
operator|==
name|C_INIT
condition|)
if|if
condition|(
name|Card_no
operator|==
literal|6
condition|)
name|Finished
operator|=
name|TRUE
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no card there"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|issafety
argument_list|(
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"discard a safety?"
argument_list|)
expr_stmt|;
name|goodplay
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|Discard
operator|=
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
expr_stmt|;
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
operator|=
name|C_INIT
expr_stmt|;
name|Next
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Play
operator|==
name|PLAYER
condition|)
name|account
argument_list|(
name|Discard
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"must pick first"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_PLAY
case|:
name|goodplay
operator|=
name|playcard
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DRAW
case|:
name|Card_no
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Topcard
operator|<=
name|Deck
condition|)
name|error
argument_list|(
literal|"no more cards"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|haspicked
argument_list|(
name|pp
argument_list|)
condition|)
name|error
argument_list|(
literal|"already picked"
argument_list|)
expr_stmt|;
else|else
block|{
name|pp
operator|->
name|hand
index|[
literal|0
index|]
operator|=
operator|*
operator|--
name|Topcard
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"DOMOVE: Draw %s\n"
argument_list|,
name|C_name
index|[
operator|*
name|Topcard
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|acc
label|:
if|if
condition|(
name|Play
operator|==
name|COMP
condition|)
block|{
name|account
argument_list|(
operator|*
name|Topcard
argument_list|)
expr_stmt|;
if|if
condition|(
name|issafety
argument_list|(
operator|*
name|Topcard
argument_list|)
condition|)
name|pp
operator|->
name|safety
index|[
operator|*
name|Topcard
operator|-
name|S_CONV
index|]
operator|=
name|S_IN_HAND
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|hand
index|[
literal|1
index|]
operator|==
name|C_INIT
operator|&&
name|Topcard
operator|>
name|Deck
condition|)
block|{
name|Card_no
operator|=
literal|1
expr_stmt|;
name|pp
operator|->
name|hand
index|[
literal|1
index|]
operator|=
operator|*
operator|--
name|Topcard
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"DOMOVE: Draw %s\n"
argument_list|,
name|C_name
index|[
operator|*
name|Topcard
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|acc
goto|;
block|}
name|pp
operator|->
name|new_battle
operator|=
name|FALSE
expr_stmt|;
name|pp
operator|->
name|new_speed
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|M_ORDER
case|:
break|break;
block|}
comment|/* 	 * move blank card to top by one of two methods.  If the 	 * computer's hand was sorted, the randomness for picking 	 * between equally valued cards would be lost 	 */
if|if
condition|(
name|Order
operator|&&
name|Movetype
operator|!=
name|M_DRAW
operator|&&
name|goodplay
operator|&&
name|pp
operator|==
operator|&
name|Player
index|[
name|PLAYER
index|]
condition|)
name|sort
argument_list|(
name|pp
operator|->
name|hand
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|HAND_SZ
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|hand
index|[
name|i
index|]
operator|==
name|C_INIT
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|pp
operator|->
name|hand
index|[
name|j
index|]
operator|==
name|C_INIT
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|>=
name|HAND_SZ
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pp
operator|->
name|hand
index|[
name|i
index|]
operator|=
name|pp
operator|->
name|hand
index|[
name|j
index|]
expr_stmt|;
name|pp
operator|->
name|hand
index|[
name|j
index|]
operator|=
name|C_INIT
expr_stmt|;
block|}
if|if
condition|(
name|Topcard
operator|<=
name|Deck
condition|)
name|check_go
argument_list|()
expr_stmt|;
if|if
condition|(
name|Next
condition|)
name|nextplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Check and see if either side can go.  If they cannot,  * the game is over  */
end_comment

begin_function
specifier|static
name|void
name|check_go
parameter_list|()
block|{
name|CARD
name|card
decl_stmt|;
name|PLAY
modifier|*
name|pp
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
operator|&
name|Player
index|[
literal|2
index|]
condition|;
name|pp
operator|++
control|)
block|{
name|op
operator|=
operator|(
name|pp
operator|==
operator|&
name|Player
index|[
name|COMP
index|]
condition|?
operator|&
name|Player
index|[
name|PLAYER
index|]
else|:
operator|&
name|Player
index|[
name|COMP
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAND_SZ
condition|;
name|i
operator|++
control|)
block|{
name|card
operator|=
name|pp
operator|->
name|hand
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|issafety
argument_list|(
name|card
argument_list|)
operator|||
name|canplay
argument_list|(
name|pp
argument_list|,
name|op
argument_list|,
name|card
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"CHECK_GO: can play %s (%d), "
argument_list|,
name|C_name
index|[
name|card
index|]
argument_list|,
name|card
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"issafety(card) = %d, "
argument_list|,
name|issafety
argument_list|(
name|card
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"canplay(pp, op, card) = %d\n"
argument_list|,
name|canplay
argument_list|(
name|pp
argument_list|,
name|op
argument_list|,
name|card
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|Debug
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"CHECK_GO: cannot play %s\n"
argument_list|,
name|C_name
index|[
name|card
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|Finished
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|playcard
parameter_list|(
name|pp
parameter_list|)
name|PLAY
modifier|*
name|pp
decl_stmt|;
block|{
name|int
name|v
decl_stmt|;
name|CARD
name|card
decl_stmt|;
comment|/* 	 * check and see if player has picked 	 */
switch|switch
condition|(
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
condition|)
block|{
default|default:
if|if
condition|(
operator|!
name|haspicked
argument_list|(
name|pp
argument_list|)
condition|)
name|mustpick
label|:
return|return
name|error
argument_list|(
literal|"must pick first"
argument_list|)
return|;
case|case
name|C_GAS_SAFE
case|:
case|case
name|C_SPARE_SAFE
case|:
case|case
name|C_DRIVE_SAFE
case|:
case|case
name|C_RIGHT_WAY
case|:
break|break;
block|}
name|card
operator|=
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"PLAYCARD: Card = %s\n"
argument_list|,
name|C_name
index|[
name|card
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Next
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|card
condition|)
block|{
case|case
name|C_200
case|:
if|if
condition|(
name|pp
operator|->
name|nummiles
index|[
name|C_200
index|]
operator|==
literal|2
condition|)
return|return
name|error
argument_list|(
literal|"only two 200's per hand"
argument_list|)
return|;
case|case
name|C_100
case|:
case|case
name|C_75
case|:
if|if
condition|(
name|pp
operator|->
name|speed
operator|==
name|C_LIMIT
condition|)
return|return
name|error
argument_list|(
literal|"limit of 50"
argument_list|)
return|;
case|case
name|C_50
case|:
if|if
condition|(
name|pp
operator|->
name|mileage
operator|+
name|Value
index|[
name|card
index|]
operator|>
name|End
condition|)
return|return
name|error
argument_list|(
literal|"puts you over %d"
argument_list|,
name|End
argument_list|)
return|;
case|case
name|C_25
case|:
if|if
condition|(
operator|!
name|pp
operator|->
name|can_go
condition|)
return|return
name|error
argument_list|(
literal|"cannot move now"
argument_list|)
return|;
name|pp
operator|->
name|nummiles
index|[
name|card
index|]
operator|++
expr_stmt|;
name|v
operator|=
name|Value
index|[
name|card
index|]
expr_stmt|;
name|pp
operator|->
name|total
operator|+=
name|v
expr_stmt|;
name|pp
operator|->
name|hand_tot
operator|+=
name|v
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|mileage
operator|+=
name|v
operator|)
operator|==
name|End
condition|)
name|check_ext
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_GAS
case|:
case|case
name|C_SPARE
case|:
case|case
name|C_REPAIRS
case|:
if|if
condition|(
name|pp
operator|->
name|battle
operator|!=
name|opposite
argument_list|(
name|card
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"can't play \"%s\""
argument_list|,
name|C_name
index|[
name|card
index|]
argument_list|)
return|;
name|pp
operator|->
name|battle
operator|=
name|card
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|safety
index|[
name|S_RIGHT_WAY
index|]
operator|==
name|S_PLAYED
condition|)
name|pp
operator|->
name|can_go
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|C_GO
case|:
if|if
condition|(
name|pp
operator|->
name|battle
operator|!=
name|C_INIT
operator|&&
name|pp
operator|->
name|battle
operator|!=
name|C_STOP
operator|&&
operator|!
name|isrepair
argument_list|(
name|pp
operator|->
name|battle
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"cannot play \"Go\" on a \"%s\""
argument_list|,
name|C_name
index|[
name|pp
operator|->
name|battle
index|]
argument_list|)
return|;
name|pp
operator|->
name|battle
operator|=
name|C_GO
expr_stmt|;
name|pp
operator|->
name|can_go
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|C_END_LIMIT
case|:
if|if
condition|(
name|pp
operator|->
name|speed
operator|!=
name|C_LIMIT
condition|)
return|return
name|error
argument_list|(
literal|"not limited"
argument_list|)
return|;
name|pp
operator|->
name|speed
operator|=
name|C_END_LIMIT
expr_stmt|;
break|break;
case|case
name|C_EMPTY
case|:
case|case
name|C_FLAT
case|:
case|case
name|C_CRASH
case|:
case|case
name|C_STOP
case|:
name|pp
operator|=
operator|&
name|Player
index|[
name|other
argument_list|(
name|Play
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pp
operator|->
name|can_go
condition|)
return|return
name|error
argument_list|(
literal|"opponent cannot go"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|pp
operator|->
name|safety
index|[
name|safety
argument_list|(
name|card
argument_list|)
operator|-
name|S_CONV
index|]
operator|==
name|S_PLAYED
condition|)
name|protected
label|:
return|return
name|error
argument_list|(
literal|"opponent is protected"
argument_list|)
return|;
name|pp
operator|->
name|battle
operator|=
name|card
expr_stmt|;
name|pp
operator|->
name|new_battle
operator|=
name|TRUE
expr_stmt|;
name|pp
operator|->
name|can_go
operator|=
name|FALSE
expr_stmt|;
name|pp
operator|=
operator|&
name|Player
index|[
name|Play
index|]
expr_stmt|;
break|break;
case|case
name|C_LIMIT
case|:
name|pp
operator|=
operator|&
name|Player
index|[
name|other
argument_list|(
name|Play
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|speed
operator|==
name|C_LIMIT
condition|)
return|return
name|error
argument_list|(
literal|"opponent has limit"
argument_list|)
return|;
if|if
condition|(
name|pp
operator|->
name|safety
index|[
name|S_RIGHT_WAY
index|]
operator|==
name|S_PLAYED
condition|)
goto|goto
name|protected
goto|;
name|pp
operator|->
name|speed
operator|=
name|C_LIMIT
expr_stmt|;
name|pp
operator|->
name|new_speed
operator|=
name|TRUE
expr_stmt|;
name|pp
operator|=
operator|&
name|Player
index|[
name|Play
index|]
expr_stmt|;
break|break;
case|case
name|C_GAS_SAFE
case|:
case|case
name|C_SPARE_SAFE
case|:
case|case
name|C_DRIVE_SAFE
case|:
case|case
name|C_RIGHT_WAY
case|:
if|if
condition|(
name|pp
operator|->
name|battle
operator|==
name|opposite
argument_list|(
name|card
argument_list|)
operator|||
operator|(
name|card
operator|==
name|C_RIGHT_WAY
operator|&&
name|pp
operator|->
name|speed
operator|==
name|C_LIMIT
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|card
operator|==
name|C_RIGHT_WAY
operator|&&
operator|!
name|isrepair
argument_list|(
name|pp
operator|->
name|battle
argument_list|)
operator|)
condition|)
block|{
name|pp
operator|->
name|battle
operator|=
name|C_GO
expr_stmt|;
name|pp
operator|->
name|can_go
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|card
operator|==
name|C_RIGHT_WAY
operator|&&
name|pp
operator|->
name|speed
operator|==
name|C_LIMIT
condition|)
name|pp
operator|->
name|speed
operator|=
name|C_INIT
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|new_battle
operator|||
operator|(
name|pp
operator|->
name|new_speed
operator|&&
name|card
operator|==
name|C_RIGHT_WAY
operator|)
condition|)
block|{
name|pp
operator|->
name|coups
index|[
name|card
operator|-
name|S_CONV
index|]
operator|=
name|TRUE
expr_stmt|;
name|pp
operator|->
name|total
operator|+=
name|SC_COUP
expr_stmt|;
name|pp
operator|->
name|hand_tot
operator|+=
name|SC_COUP
expr_stmt|;
name|pp
operator|->
name|coupscore
operator|+=
name|SC_COUP
expr_stmt|;
block|}
block|}
comment|/* 		 * if not coup, must pick first 		 */
elseif|else
if|if
condition|(
name|pp
operator|->
name|hand
index|[
literal|0
index|]
operator|==
name|C_INIT
operator|&&
name|Topcard
operator|>
name|Deck
condition|)
goto|goto
name|mustpick
goto|;
name|pp
operator|->
name|safety
index|[
name|card
operator|-
name|S_CONV
index|]
operator|=
name|S_PLAYED
expr_stmt|;
name|pp
operator|->
name|total
operator|+=
name|SC_SAFETY
expr_stmt|;
name|pp
operator|->
name|hand_tot
operator|+=
name|SC_SAFETY
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|safescore
operator|+=
name|SC_SAFETY
operator|)
operator|==
name|NUM_SAFE
operator|*
name|SC_SAFETY
condition|)
block|{
name|pp
operator|->
name|total
operator|+=
name|SC_ALL_SAFE
expr_stmt|;
name|pp
operator|->
name|hand_tot
operator|+=
name|SC_ALL_SAFE
expr_stmt|;
block|}
if|if
condition|(
name|card
operator|==
name|C_RIGHT_WAY
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|speed
operator|==
name|C_LIMIT
condition|)
name|pp
operator|->
name|speed
operator|=
name|C_INIT
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|battle
operator|==
name|C_STOP
operator|||
name|pp
operator|->
name|battle
operator|==
name|C_INIT
condition|)
block|{
name|pp
operator|->
name|can_go
operator|=
name|TRUE
expr_stmt|;
name|pp
operator|->
name|battle
operator|=
name|C_INIT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pp
operator|->
name|can_go
operator|&&
name|isrepair
argument_list|(
name|pp
operator|->
name|battle
argument_list|)
condition|)
name|pp
operator|->
name|can_go
operator|=
name|TRUE
expr_stmt|;
block|}
name|Next
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|C_INIT
case|:
name|error
argument_list|(
literal|"no card there"
argument_list|)
expr_stmt|;
name|Next
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pp
operator|==
operator|&
name|Player
index|[
name|PLAYER
index|]
condition|)
name|account
argument_list|(
name|card
argument_list|)
expr_stmt|;
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
operator|=
name|C_INIT
expr_stmt|;
name|Next
operator|=
operator|(
name|Next
operator|==
operator|-
literal|1
condition|?
name|FALSE
else|:
name|TRUE
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getmove
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
modifier|*
name|sp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTRAP
specifier|static
name|bool
name|last_ex
init|=
name|FALSE
decl_stmt|;
comment|/* set if last command was E */
if|if
condition|(
name|last_ex
condition|)
block|{
name|undoex
argument_list|()
expr_stmt|;
name|prboard
argument_list|()
expr_stmt|;
name|last_ex
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|prompt
argument_list|(
name|MOVEPROMPT
argument_list|)
expr_stmt|;
name|leaveok
argument_list|(
name|Board
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|readch
argument_list|()
operator|)
operator|==
name|killchar
argument_list|()
operator|||
name|c
operator|==
name|erasechar
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|addch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'P'
case|:
comment|/* Pick */
name|Movetype
operator|=
name|M_DRAW
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
literal|'U'
case|:
comment|/* Use Card */
case|case
literal|'D'
case|:
comment|/* Discard Card */
if|if
condition|(
operator|(
name|Card_no
operator|=
name|getcard
argument_list|()
operator|)
operator|<
literal|0
condition|)
break|break;
name|Movetype
operator|=
operator|(
name|c
operator|==
literal|'U'
condition|?
name|M_PLAY
else|:
name|M_DISCARD
operator|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
literal|'O'
case|:
comment|/* Order */
name|Order
operator|=
operator|!
name|Order
expr_stmt|;
if|if
condition|(
name|Window
operator|==
name|W_SMALL
condition|)
block|{
if|if
condition|(
operator|!
name|Order
condition|)
name|mvwaddstr
argument_list|(
name|Score
argument_list|,
literal|12
argument_list|,
literal|21
argument_list|,
literal|"o: order hand"
argument_list|)
expr_stmt|;
else|else
name|mvwaddstr
argument_list|(
name|Score
argument_list|,
literal|12
argument_list|,
literal|21
argument_list|,
literal|"o: stop ordering"
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|Score
argument_list|)
expr_stmt|;
block|}
name|Movetype
operator|=
name|M_ORDER
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
literal|'Q'
case|:
comment|/* Quit */
name|rub
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Same as a rubout */
break|break;
case|case
literal|'W'
case|:
comment|/* Window toggle */
name|Window
operator|=
name|nextwin
argument_list|(
name|Window
argument_list|)
expr_stmt|;
name|newscore
argument_list|()
expr_stmt|;
name|prscore
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|Score
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Redraw screen */
case|case
name|CTRL
argument_list|(
literal|'L'
argument_list|)
case|:
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Save game */
name|On_exit
operator|=
name|FALSE
expr_stmt|;
name|save
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Extrapolate */
ifdef|#
directive|ifdef
name|EXTRAP
if|if
condition|(
name|last_ex
condition|)
break|break;
name|Finished
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Window
operator|!=
name|W_FULL
condition|)
name|newscore
argument_list|()
expr_stmt|;
name|prscore
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|Score
argument_list|)
expr_stmt|;
name|last_ex
operator|=
name|TRUE
expr_stmt|;
name|Finished
operator|=
name|FALSE
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"%c: command not implemented"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'\r'
case|:
comment|/* Ignore RETURNs and	*/
case|case
literal|'\n'
case|:
comment|/* Line Feeds		*/
case|case
literal|' '
case|:
comment|/* Spaces		*/
case|case
literal|'\0'
case|:
comment|/* and nulls		*/
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'Z'
case|:
comment|/* Debug code */
if|if
condition|(
operator|!
name|Debug
operator|&&
name|outf
operator|==
name|NULL
condition|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|prompt
argument_list|(
name|FILEPROMPT
argument_list|)
expr_stmt|;
name|leaveok
argument_list|(
name|Board
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|sp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|=
name|readch
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|killchar
argument_list|()
condition|)
goto|goto
name|over
goto|;
elseif|else
if|if
condition|(
operator|*
name|sp
operator|==
name|erasechar
argument_list|()
condition|)
block|{
if|if
condition|(
operator|--
name|sp
operator|<
name|buf
condition|)
name|sp
operator|=
name|buf
expr_stmt|;
else|else
block|{
name|addch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|<
literal|' '
condition|)
name|addch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|addstr
argument_list|(
name|unctrl
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|leaveok
argument_list|(
name|Board
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outf
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|outf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Debug
operator|=
operator|!
name|Debug
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
argument_list|(
literal|"unknown command: %s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ret
label|:
name|leaveok
argument_list|(
name|Board
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return whether or not the player has picked  */
end_comment

begin_function
specifier|static
name|int
name|haspicked
parameter_list|(
name|pp
parameter_list|)
name|PLAY
modifier|*
name|pp
decl_stmt|;
block|{
name|int
name|card
decl_stmt|;
if|if
condition|(
name|Topcard
operator|<=
name|Deck
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|pp
operator|->
name|hand
index|[
name|Card_no
index|]
condition|)
block|{
case|case
name|C_GAS_SAFE
case|:
case|case
name|C_SPARE_SAFE
case|:
case|case
name|C_DRIVE_SAFE
case|:
case|case
name|C_RIGHT_WAY
case|:
name|card
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|card
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|pp
operator|->
name|hand
index|[
name|card
index|]
operator|!=
name|C_INIT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|account
parameter_list|(
name|card
parameter_list|)
name|CARD
name|card
decl_stmt|;
block|{
name|CARD
name|oppos
decl_stmt|;
if|if
condition|(
name|card
operator|==
name|C_INIT
condition|)
return|return;
operator|++
name|Numseen
index|[
name|card
index|]
expr_stmt|;
if|if
condition|(
name|Play
operator|==
name|COMP
condition|)
switch|switch
condition|(
name|card
condition|)
block|{
case|case
name|C_GAS_SAFE
case|:
case|case
name|C_SPARE_SAFE
case|:
case|case
name|C_DRIVE_SAFE
case|:
name|oppos
operator|=
name|opposite
argument_list|(
name|card
argument_list|)
expr_stmt|;
name|Numgos
operator|+=
name|Numcards
index|[
name|oppos
index|]
operator|-
name|Numseen
index|[
name|oppos
index|]
expr_stmt|;
break|break;
case|case
name|C_CRASH
case|:
case|case
name|C_FLAT
case|:
case|case
name|C_EMPTY
case|:
case|case
name|C_STOP
case|:
name|Numgos
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|prompt
parameter_list|(
name|promptno
parameter_list|)
name|int
name|promptno
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|names
index|[]
init|=
block|{
literal|">>:Move:"
block|,
literal|"Really?"
block|,
literal|"Another hand?"
block|,
literal|"Another game?"
block|,
literal|"Save game?"
block|,
literal|"Same file?"
block|,
literal|"file:"
block|,
literal|"Extension?"
block|,
literal|"Overwrite file?"
block|, 			}
decl_stmt|;
specifier|static
name|int
name|last_prompt
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|promptno
operator|==
name|last_prompt
condition|)
name|move
argument_list|(
name|MOVE_Y
argument_list|,
name|MOVE_X
operator|+
name|strlen
argument_list|(
name|names
index|[
name|promptno
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|move
argument_list|(
name|MOVE_Y
argument_list|,
name|MOVE_X
argument_list|)
expr_stmt|;
if|if
condition|(
name|promptno
operator|==
name|MOVEPROMPT
condition|)
name|standout
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
name|names
index|[
name|promptno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|promptno
operator|==
name|MOVEPROMPT
condition|)
name|standend
argument_list|()
expr_stmt|;
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|last_prompt
operator|=
name|promptno
expr_stmt|;
block|}
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sort
parameter_list|(
name|hand
parameter_list|)
name|CARD
modifier|*
name|hand
decl_stmt|;
block|{
name|CARD
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|CARD
name|temp
decl_stmt|;
name|cp
operator|=
name|hand
expr_stmt|;
name|hand
operator|+=
name|HAND_SZ
expr_stmt|;
for|for
control|(
init|;
name|cp
operator|<
operator|&
name|hand
index|[
operator|-
literal|1
index|]
condition|;
name|cp
operator|++
control|)
for|for
control|(
name|tp
operator|=
name|cp
operator|+
literal|1
init|;
name|tp
operator|<
name|hand
condition|;
name|tp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|>
operator|*
name|tp
condition|)
block|{
name|temp
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
operator|*
name|tp
expr_stmt|;
operator|*
name|tp
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_function

end_unit

