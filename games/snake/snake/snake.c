begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)snake.c	8.2 (Berkeley) 1/7/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * snake - crt hack game.  *  * You move around the screen with arrow keys trying to pick up money  * without getting eaten by the snake.  hjkl work as in vi in place of  * arrow keys.  You can leave at the exit any time.  *  * compile as follows:  *	cc -O snake.c move.c -o snake -lm -ltermlib  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"snake.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|PENALTY
value|10
end_define

begin_comment
comment|/* % penalty for invoking spacewarp	*/
end_comment

begin_define
define|#
directive|define
name|EOT
value|'\004'
end_define

begin_define
define|#
directive|define
name|LF
value|'\n'
end_define

begin_define
define|#
directive|define
name|DEL
value|'\177'
end_define

begin_define
define|#
directive|define
name|ME
value|'I'
end_define

begin_define
define|#
directive|define
name|SNAKEHEAD
value|'S'
end_define

begin_define
define|#
directive|define
name|SNAKETAIL
value|'s'
end_define

begin_define
define|#
directive|define
name|TREASURE
value|'$'
end_define

begin_define
define|#
directive|define
name|GOAL
value|'#'
end_define

begin_define
define|#
directive|define
name|BSIZE
value|80
end_define

begin_decl_stmt
name|struct
name|point
name|you
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|point
name|money
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|point
name|finish
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|point
name|snake
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loot
decl_stmt|,
name|penalty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|long
name|tl
decl_stmt|,
name|tm
init|=
literal|0L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|moves
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|stri
index|[
name|BSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ch
decl_stmt|,
name|savec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kl
decl_stmt|,
modifier|*
name|kr
decl_stmt|,
modifier|*
name|ku
decl_stmt|,
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fast
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|repeat
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|tv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rawscores
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|void
name|stop
parameter_list|()
function_decl|;
name|rawscores
operator|=
name|open
argument_list|(
name|_PATH_RAWSCORES
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0664
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|fopen
argument_list|(
name|_PATH_LOGFILE
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
comment|/* revoke privs */
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|srandomdev
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"l:w:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
case|case
literal|'d'
case|:
name|tv
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'w'
case|:
comment|/* width */
name|ccnt
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* length */
name|lcnt
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|fputs
argument_list|(
literal|"usage: snake [-d seed] [-w width] [-l length]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|penalty
operator|=
name|loot
operator|=
literal|0
expr_stmt|;
name|getcap
argument_list|()
expr_stmt|;
name|i
operator|=
name|MIN
argument_list|(
name|lcnt
argument_list|,
name|ccnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|cook
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"snake: screen too small for a fair game.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * chunk is the amount of money the user gets for each $. 	 * The formula below tries to be fair for various screen sizes. 	 * We only pay attention to the smaller of the 2 edges, since 	 * that seems to be the bottleneck. 	 * This formula is a hyperbola which includes the following points: 	 *	(24, $25)	(original scoring algorithm) 	 *	(12, $40)	(experimentally derived by the "feel") 	 *	(48, $15)	(a guess) 	 * This will give a 4x4 screen $99/shot.  We don't allow anything 	 * smaller than 4x4 because there is a 3x3 game where you can win 	 * an infinite amount of money. 	 */
if|if
condition|(
name|i
operator|<
literal|12
condition|)
name|i
operator|=
literal|12
expr_stmt|;
comment|/* otherwise it isn't fair */
comment|/* 	 * Compensate for border.  This really changes the game since 	 * the screen is two squares smaller but we want the default 	 * to be $25, and the high scores on small screens were a bit 	 * much anyway. 	 */
name|i
operator|+=
literal|2
expr_stmt|;
name|chunk
operator|=
operator|(
literal|675.0
operator|/
operator|(
name|i
operator|+
literal|6
operator|)
operator|)
operator|+
literal|2.5
expr_stmt|;
comment|/* min screen edge */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|TI
argument_list|)
expr_stmt|;
comment|/*	String to begin programs that use cm */
name|putpad
argument_list|(
name|KS
argument_list|)
expr_stmt|;
comment|/*	Put terminal in keypad transmit mode */
name|snrand
argument_list|(
operator|&
name|finish
argument_list|)
expr_stmt|;
name|snrand
argument_list|(
operator|&
name|you
argument_list|)
expr_stmt|;
name|snrand
argument_list|(
operator|&
name|money
argument_list|)
expr_stmt|;
name|snrand
argument_list|(
operator|&
name|snake
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|orig
operator|.
name|sg_ospeed
operator|<
name|B9600
operator|)
operator|||
operator|(
operator|(
operator|!
name|CM
operator|)
operator|&&
operator|(
operator|!
name|TA
operator|)
operator|)
condition|)
name|fast
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|chase
argument_list|(
operator|&
name|snake
index|[
name|i
index|]
argument_list|,
operator|&
name|snake
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|mainloop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main command loop */
end_comment

begin_macro
name|mainloop
argument_list|()
end_macro

begin_block
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|,
name|lastc
decl_stmt|,
name|match
decl_stmt|;
name|move
argument_list|(
operator|&
name|you
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|&
literal|0177
operator|)
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|j
operator|=
name|scanf
argument_list|(
literal|"%d"
argument_list|,
operator|&
name|repeat
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
operator|&
literal|0177
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
name|lastc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Klength
operator|>
literal|0
operator|)
operator|&&
operator|(
name|c
operator|==
operator|*
name|KL
operator|||
name|c
operator|==
operator|*
name|KR
operator|||
name|c
operator|==
operator|*
name|KU
operator|||
name|c
operator|==
operator|*
name|KD
operator|)
condition|)
block|{
name|savec
operator|=
name|c
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
name|kl
operator|=
name|KL
expr_stmt|;
name|kr
operator|=
name|KR
expr_stmt|;
name|ku
operator|=
name|KU
expr_stmt|;
name|kd
operator|=
name|KD
expr_stmt|;
for|for
control|(
name|j
operator|=
name|Klength
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|match
operator|!=
literal|1
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|kl
operator|++
operator|==
name|c
condition|)
block|{
name|ch
operator|=
literal|'h'
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|kr
operator|++
operator|==
name|c
condition|)
block|{
name|ch
operator|=
literal|'l'
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ku
operator|++
operator|==
name|c
condition|)
block|{
name|ch
operator|=
literal|'k'
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|kd
operator|++
operator|==
name|c
condition|)
block|{
name|ch
operator|=
literal|'j'
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|ch
operator|=
name|savec
expr_stmt|;
comment|/* Oops! 		 * This works if we figure it out on second character. 		 */
break|break;
block|}
block|}
name|savec
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|1
condition|)
name|c
operator|=
name|getchar
argument_list|()
operator|&
literal|0177
expr_stmt|;
block|}
name|c
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fast
condition|)
name|flushi
argument_list|()
expr_stmt|;
name|lastc
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'z'
argument_list|)
case|:
name|suspend
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|EOT
case|:
case|case
literal|'x'
case|:
case|case
literal|0177
case|:
comment|/* del or end of file */
name|ll
argument_list|()
expr_stmt|;
name|length
argument_list|(
name|moves
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"quit"
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|setup
argument_list|()
expr_stmt|;
name|winnings
argument_list|(
name|cashvalue
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
case|case
literal|'d'
case|:
name|snap
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|spacewarp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
name|repeat
operator|=
name|you
operator|.
name|col
expr_stmt|;
name|c
operator|=
literal|'h'
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'S'
case|:
name|repeat
operator|=
name|you
operator|.
name|col
operator|-
name|money
operator|.
name|col
expr_stmt|;
name|c
operator|=
literal|'h'
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|repeat
operator|=
name|you
operator|.
name|line
expr_stmt|;
name|c
operator|=
literal|'k'
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
case|case
literal|'E'
case|:
name|repeat
operator|=
name|you
operator|.
name|line
operator|-
name|money
operator|.
name|line
expr_stmt|;
name|c
operator|=
literal|'k'
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|repeat
operator|=
name|ccnt
operator|-
literal|1
operator|-
name|you
operator|.
name|col
expr_stmt|;
name|c
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
case|case
literal|'F'
case|:
name|repeat
operator|=
name|money
operator|.
name|col
operator|-
name|you
operator|.
name|col
expr_stmt|;
name|c
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|repeat
operator|=
name|lcnt
operator|-
literal|1
operator|-
name|you
operator|.
name|line
expr_stmt|;
name|c
operator|=
literal|'j'
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
case|case
literal|'C'
case|:
name|repeat
operator|=
name|money
operator|.
name|line
operator|-
name|you
operator|.
name|line
expr_stmt|;
name|c
operator|=
literal|'j'
expr_stmt|;
break|break;
block|}
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|repeat
condition|;
name|k
operator|++
control|)
block|{
name|moves
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'h'
case|:
case|case
literal|'\b'
case|:
if|if
condition|(
name|you
operator|.
name|col
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
literal|1
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|you
operator|.
name|col
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
name|repeat
operator|)
operator|||
operator|(
name|you
operator|.
name|col
operator|==
literal|0
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
name|ME
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
case|case
literal|'l'
case|:
case|case
literal|' '
case|:
if|if
condition|(
name|you
operator|.
name|col
operator|<
name|ccnt
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
literal|1
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|you
operator|.
name|col
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
name|repeat
operator|)
operator|||
operator|(
name|you
operator|.
name|col
operator|==
name|ccnt
operator|-
literal|1
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
name|ME
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
literal|'e'
case|:
case|case
literal|'k'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|you
operator|.
name|line
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
literal|1
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|you
operator|.
name|line
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
name|repeat
operator|)
operator|||
operator|(
name|you
operator|.
name|line
operator|==
literal|0
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
name|ME
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
literal|'c'
case|:
case|case
literal|'j'
case|:
case|case
name|LF
case|:
case|case
literal|'m'
case|:
if|if
condition|(
name|you
operator|.
name|line
operator|+
literal|1
operator|<
name|lcnt
condition|)
block|{
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
literal|1
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|you
operator|.
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|fast
operator|)
operator|||
operator|(
name|k
operator|==
name|repeat
operator|)
operator|||
operator|(
name|you
operator|.
name|line
operator|==
name|lcnt
operator|-
literal|1
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
name|ME
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|same
argument_list|(
operator|&
name|you
argument_list|,
operator|&
name|money
argument_list|)
condition|)
block|{
name|char
name|xp
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|point
name|z
decl_stmt|;
name|loot
operator|+=
literal|25
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|repeat
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
do|do
block|{
name|snrand
argument_list|(
operator|&
name|money
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|money
operator|.
name|col
operator|==
name|finish
operator|.
name|col
operator|&&
name|money
operator|.
name|line
operator|==
name|finish
operator|.
name|line
operator|||
name|money
operator|.
name|col
operator|<
literal|5
operator|&&
name|money
operator|.
name|line
operator|==
literal|0
operator|||
name|money
operator|.
name|col
operator|==
name|you
operator|.
name|col
operator|&&
name|money
operator|.
name|line
operator|==
name|you
operator|.
name|line
condition|)
do|;
name|pchar
argument_list|(
operator|&
name|money
argument_list|,
name|TREASURE
argument_list|)
expr_stmt|;
name|winnings
argument_list|(
name|cashvalue
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|same
argument_list|(
operator|&
name|you
argument_list|,
operator|&
name|finish
argument_list|)
condition|)
block|{
name|win
argument_list|(
operator|&
name|finish
argument_list|)
expr_stmt|;
name|ll
argument_list|()
expr_stmt|;
name|cook
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"You have won with $%d.\n"
argument_list|,
name|cashvalue
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"won"
argument_list|)
expr_stmt|;
name|post
argument_list|(
name|cashvalue
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|length
argument_list|(
name|moves
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pushsnake
argument_list|()
condition|)
break|break;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setup
argument_list|()
end_macro

begin_block
block|{
comment|/* 		 * setup the board 		 */
name|int
name|i
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
name|ME
argument_list|)
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|finish
argument_list|,
name|GOAL
argument_list|)
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|money
argument_list|,
name|TREASURE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|pchar
argument_list|(
operator|&
name|snake
index|[
name|i
index|]
argument_list|,
name|SNAKETAIL
argument_list|)
expr_stmt|;
block|}
name|pchar
argument_list|(
operator|&
name|snake
index|[
literal|0
index|]
argument_list|,
name|SNAKEHEAD
argument_list|)
expr_stmt|;
name|drawbox
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|drawbox
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|point
name|p
decl_stmt|;
name|p
operator|.
name|line
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccnt
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|col
operator|=
name|i
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|col
operator|=
name|ccnt
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|lcnt
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|line
operator|=
name|i
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|col
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|lcnt
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|line
operator|=
name|i
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|line
operator|=
name|lcnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccnt
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|.
name|col
operator|=
name|i
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|snrand
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|.
name|col
operator|=
name|random
argument_list|()
operator|%
name|ccnt
expr_stmt|;
name|p
operator|.
name|line
operator|=
name|random
argument_list|()
operator|%
name|lcnt
expr_stmt|;
comment|/* make sure it's not on top of something else */
if|if
condition|(
name|p
operator|.
name|line
operator|==
literal|0
operator|&&
name|p
operator|.
name|col
operator|<
literal|5
condition|)
continue|continue;
if|if
condition|(
name|same
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|you
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|same
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|money
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|same
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|finish
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|same
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|snake
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|5
condition|)
continue|continue;
break|break;
block|}
operator|*
name|sp
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_macro
name|post
argument_list|(
argument|iscore
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|iscore
decl_stmt|,
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|score
init|=
name|iscore
decl_stmt|;
name|short
name|uid
decl_stmt|;
name|short
name|oldbest
init|=
literal|0
decl_stmt|;
name|short
name|allbwho
init|=
literal|0
decl_stmt|,
name|allbscore
init|=
literal|0
decl_stmt|;
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Neg uid, 0, and 1 cannot have scores recorded. 	 */
if|if
condition|(
operator|(
name|uid
operator|=
name|getuid
argument_list|()
operator|)
operator|<=
literal|1
condition|)
block|{
name|pr
argument_list|(
literal|"No saved scores for uid %d.\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rawscores
operator|==
operator|-
literal|1
condition|)
block|{
name|pr
argument_list|(
literal|"No score file %s: %s.\n"
argument_list|,
name|_PATH_RAWSCORES
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Figure out what happened in the past */
name|read
argument_list|(
name|rawscores
argument_list|,
operator|&
name|allbscore
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|rawscores
argument_list|,
operator|&
name|allbwho
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|rawscores
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|uid
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|rawscores
argument_list|,
operator|&
name|oldbest
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
return|return
operator|(
name|score
operator|>
name|oldbest
condition|?
literal|1
else|:
literal|0
operator|)
return|;
comment|/* Update this jokers best */
if|if
condition|(
name|score
operator|>
name|oldbest
condition|)
block|{
name|lseek
argument_list|(
name|rawscores
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|uid
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rawscores
argument_list|,
operator|&
name|score
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"You bettered your previous best of $%d\n"
argument_list|,
name|oldbest
argument_list|)
expr_stmt|;
block|}
else|else
name|pr
argument_list|(
literal|"Your best to date is $%d\n"
argument_list|,
name|oldbest
argument_list|)
expr_stmt|;
comment|/* See if we have a new champ */
name|p
operator|=
name|getpwuid
argument_list|(
name|allbwho
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|score
operator|>
name|allbscore
condition|)
block|{
name|lseek
argument_list|(
name|rawscores
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rawscores
argument_list|,
operator|&
name|score
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|rawscores
argument_list|,
operator|&
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allbwho
condition|)
name|pr
argument_list|(
literal|"You beat %s's old record of $%d!\n"
argument_list|,
name|p
operator|->
name|pw_name
argument_list|,
name|allbscore
argument_list|)
expr_stmt|;
else|else
name|pr
argument_list|(
literal|"You set a new record!\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|pr
argument_list|(
literal|"The highest is %s with $%d\n"
argument_list|,
name|p
operator|->
name|pw_name
argument_list|,
name|allbscore
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|rawscores
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Flush typeahead to keep from buffering a bunch of chars and then  * overshooting.  This loses horribly at 9600 baud, but works nicely  * if the terminal gets behind.  */
end_comment

begin_macro
name|flushi
argument_list|()
end_macro

begin_block
block|{
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|mx
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|my
index|[
literal|8
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|absv
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|1.4
block|,
literal|1
block|,
literal|1.4
block|,
literal|1
block|,
literal|1.4
block|,
literal|1
block|,
literal|1.4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oldw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|chase
argument_list|(
argument|np
argument_list|,
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|sp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* this algorithm has bugs; otherwise the 	   snake would get too good */
name|struct
name|point
name|d
decl_stmt|;
name|int
name|w
decl_stmt|,
name|i
decl_stmt|,
name|wt
index|[
literal|8
index|]
decl_stmt|;
name|double
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|vp
decl_stmt|,
name|max
decl_stmt|;
name|point
argument_list|(
operator|&
name|d
argument_list|,
name|you
operator|.
name|col
operator|-
name|sp
operator|->
name|col
argument_list|,
name|you
operator|.
name|line
operator|-
name|sp
operator|->
name|line
argument_list|)
expr_stmt|;
name|v1
operator|=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|d
operator|.
name|col
operator|*
name|d
operator|.
name|col
operator|+
name|d
operator|.
name|line
operator|*
name|d
operator|.
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|vp
operator|=
name|d
operator|.
name|col
operator|*
name|mx
index|[
name|i
index|]
operator|+
name|d
operator|.
name|line
operator|*
name|my
index|[
name|i
index|]
expr_stmt|;
name|v2
operator|=
name|absv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|>
literal|0
condition|)
name|vp
operator|=
operator|(
operator|(
name|double
operator|)
name|vp
operator|)
operator|/
operator|(
name|v1
operator|*
name|v2
operator|)
expr_stmt|;
else|else
name|vp
operator|=
literal|1.0
expr_stmt|;
if|if
condition|(
name|vp
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|vp
expr_stmt|;
name|w
operator|=
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|point
argument_list|(
operator|&
name|d
argument_list|,
name|sp
operator|->
name|col
operator|+
name|mx
index|[
name|i
index|]
argument_list|,
name|sp
operator|->
name|line
operator|+
name|my
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|wt
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|col
operator|<
literal|0
operator|||
name|d
operator|.
name|col
operator|>=
name|ccnt
operator|||
name|d
operator|.
name|line
operator|<
literal|0
operator|||
name|d
operator|.
name|line
operator|>=
name|lcnt
condition|)
continue|continue;
comment|/* 		 * Change to allow snake to eat you if you're on the money, 		 * otherwise, you can just crouch there until the snake goes 		 * away.  Not positive it's right. 		 * 		 * if (d.line == 0&& d.col< 5) continue; 		 */
if|if
condition|(
name|same
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|money
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|same
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|finish
argument_list|)
condition|)
continue|continue;
name|wt
index|[
name|i
index|]
operator|=
name|i
operator|==
name|w
condition|?
name|loot
operator|/
literal|10
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|oldw
condition|)
name|wt
index|[
name|i
index|]
operator|+=
name|loot
operator|/
literal|20
expr_stmt|;
block|}
for|for
control|(
name|w
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|w
operator|+=
name|wt
index|[
name|i
index|]
expr_stmt|;
name|vp
operator|=
operator|(
operator|(
name|rand
argument_list|()
operator|>>
literal|6
operator|)
operator|&
literal|01777
operator|)
operator|%
name|w
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vp
operator|<
name|wt
index|[
name|i
index|]
condition|)
break|break;
else|else
name|vp
operator|-=
name|wt
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|8
condition|)
block|{
name|pr
argument_list|(
literal|"failure\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|wt
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
block|}
name|oldw
operator|=
name|w
operator|=
name|i
expr_stmt|;
name|point
argument_list|(
name|np
argument_list|,
name|sp
operator|->
name|col
operator|+
name|mx
index|[
name|w
index|]
argument_list|,
name|sp
operator|->
name|line
operator|+
name|my
index|[
name|w
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|spacewarp
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|int
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|p
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|snrand
argument_list|(
operator|&
name|you
argument_list|)
expr_stmt|;
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|COLUMNS
operator|/
literal|2
operator|-
literal|8
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|col
operator|<
literal|0
condition|)
name|p
operator|.
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|line
operator|<
literal|0
condition|)
name|p
operator|.
name|line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|str
operator|=
literal|"BONUS!!!"
expr_stmt|;
name|loot
operator|=
name|loot
operator|-
name|penalty
expr_stmt|;
name|penalty
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
literal|"SPACE WARP!!!"
expr_stmt|;
name|penalty
operator|+=
name|loot
operator|/
name|PENALTY
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|apr
argument_list|(
operator|&
name|p
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|setup
argument_list|()
expr_stmt|;
name|winnings
argument_list|(
name|cashvalue
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|snap
argument_list|()
end_macro

begin_block
block|{
name|struct
name|point
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|you
operator|.
name|line
operator|<
literal|3
condition|)
block|{
name|pchar
argument_list|(
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|you
operator|.
name|col
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you
operator|.
name|line
operator|>
name|lcnt
operator|-
literal|4
condition|)
block|{
name|pchar
argument_list|(
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|you
operator|.
name|col
argument_list|,
name|lcnt
operator|-
literal|1
argument_list|)
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you
operator|.
name|col
operator|<
literal|10
condition|)
block|{
name|pchar
argument_list|(
name|point
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|,
name|you
operator|.
name|line
argument_list|)
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you
operator|.
name|col
operator|>
name|ccnt
operator|-
literal|10
condition|)
block|{
name|pchar
argument_list|(
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|ccnt
operator|-
literal|1
argument_list|,
name|you
operator|.
name|line
argument_list|)
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stretch
argument_list|(
operator|&
name|money
argument_list|)
condition|)
if|if
condition|(
operator|!
name|stretch
argument_list|(
operator|&
name|finish
argument_list|)
condition|)
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|you
operator|.
name|line
operator|<
literal|3
condition|)
block|{
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|you
operator|.
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you
operator|.
name|line
operator|>
name|lcnt
operator|-
literal|4
condition|)
block|{
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|you
operator|.
name|col
argument_list|,
name|lcnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you
operator|.
name|col
operator|<
literal|10
condition|)
block|{
name|point
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|,
name|you
operator|.
name|line
argument_list|)
expr_stmt|;
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you
operator|.
name|col
operator|>
name|ccnt
operator|-
literal|10
condition|)
block|{
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|ccnt
operator|-
literal|1
argument_list|,
name|you
operator|.
name|line
argument_list|)
expr_stmt|;
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stretch
argument_list|(
argument|ps
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|ps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|p
decl_stmt|;
name|point
argument_list|(
operator|&
name|p
argument_list|,
name|you
operator|.
name|col
argument_list|,
name|you
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|ps
operator|->
name|col
operator|-
name|you
operator|.
name|col
argument_list|)
operator|<
literal|6
condition|)
block|{
if|if
condition|(
name|you
operator|.
name|line
operator|<
name|ps
operator|->
name|line
condition|)
block|{
for|for
control|(
name|p
operator|.
name|line
operator|=
name|you
operator|.
name|line
operator|+
literal|1
init|;
name|p
operator|.
name|line
operator|<=
name|ps
operator|->
name|line
condition|;
name|p
operator|.
name|line
operator|++
control|)
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'v'
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|.
name|line
operator|>
name|you
operator|.
name|line
condition|;
name|p
operator|.
name|line
operator|--
control|)
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|.
name|line
operator|=
name|you
operator|.
name|line
operator|-
literal|1
init|;
name|p
operator|.
name|line
operator|>=
name|ps
operator|->
name|line
condition|;
name|p
operator|.
name|line
operator|--
control|)
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|.
name|line
operator|<
name|you
operator|.
name|line
condition|;
name|p
operator|.
name|line
operator|++
control|)
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|abs
argument_list|(
name|ps
operator|->
name|line
operator|-
name|you
operator|.
name|line
argument_list|)
operator|<
literal|3
condition|)
block|{
name|p
operator|.
name|line
operator|=
name|you
operator|.
name|line
expr_stmt|;
if|if
condition|(
name|you
operator|.
name|col
operator|<
name|ps
operator|->
name|col
condition|)
block|{
for|for
control|(
name|p
operator|.
name|col
operator|=
name|you
operator|.
name|col
operator|+
literal|1
init|;
name|p
operator|.
name|col
operator|<=
name|ps
operator|->
name|col
condition|;
name|p
operator|.
name|col
operator|++
control|)
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|.
name|col
operator|>
name|you
operator|.
name|col
condition|;
name|p
operator|.
name|col
operator|--
control|)
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|.
name|col
operator|=
name|you
operator|.
name|col
operator|-
literal|1
init|;
name|p
operator|.
name|col
operator|>=
name|ps
operator|->
name|col
condition|;
name|p
operator|.
name|col
operator|--
control|)
name|pchar
argument_list|(
operator|&
name|p
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|.
name|col
operator|<
name|you
operator|.
name|col
condition|;
name|p
operator|.
name|col
operator|++
control|)
name|chk
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|surround
argument_list|(
argument|ps
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|ps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|x
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|col
operator|==
literal|0
condition|)
name|ps
operator|->
name|col
operator|++
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|line
operator|==
literal|0
condition|)
name|ps
operator|->
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|line
operator|==
name|LINES
operator|-
literal|1
condition|)
name|ps
operator|->
name|line
operator|--
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|col
operator|==
name|COLUMNS
operator|-
literal|1
condition|)
name|ps
operator|->
name|col
operator|--
expr_stmt|;
name|apr
argument_list|(
name|point
argument_list|(
operator|&
name|x
argument_list|,
name|ps
operator|->
name|col
operator|-
literal|1
argument_list|,
name|ps
operator|->
name|line
operator|-
literal|1
argument_list|)
argument_list|,
literal|"/*\\\r* *\r\\*/"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|20
condition|;
name|j
operator|++
control|)
block|{
name|pchar
argument_list|(
name|ps
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pchar
argument_list|(
name|ps
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|post
argument_list|(
name|cashvalue
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|apr
argument_list|(
name|point
argument_list|(
operator|&
name|x
argument_list|,
name|ps
operator|->
name|col
operator|-
literal|1
argument_list|,
name|ps
operator|->
name|line
operator|-
literal|1
argument_list|)
argument_list|,
literal|"   \ro.o\r\\_/"
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|apr
argument_list|(
name|point
argument_list|(
operator|&
name|x
argument_list|,
name|ps
operator|->
name|col
operator|-
literal|1
argument_list|,
name|ps
operator|->
name|line
operator|-
literal|1
argument_list|)
argument_list|,
literal|"   \ro.-\r\\_/"
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
name|apr
argument_list|(
name|point
argument_list|(
operator|&
name|x
argument_list|,
name|ps
operator|->
name|col
operator|-
literal|1
argument_list|,
name|ps
operator|->
name|line
operator|-
literal|1
argument_list|)
argument_list|,
literal|"   \ro.o\r\\_/"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|win
argument_list|(
argument|ps
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|ps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|x
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|boxsize
decl_stmt|;
comment|/* actually diameter of box, not radius */
name|boxsize
operator|=
name|fast
condition|?
literal|10
else|:
literal|4
expr_stmt|;
name|point
argument_list|(
operator|&
name|x
argument_list|,
name|ps
operator|->
name|col
argument_list|,
name|ps
operator|->
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|boxsize
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|pchar
argument_list|(
operator|&
name|x
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|x
operator|.
name|line
operator|--
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|pchar
argument_list|(
operator|&
name|x
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|x
operator|.
name|col
operator|++
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|pchar
argument_list|(
operator|&
name|x
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|x
operator|.
name|line
operator|++
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|pchar
argument_list|(
operator|&
name|x
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|x
operator|.
name|col
operator|--
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pushsnake
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|bonus
decl_stmt|;
name|int
name|issame
init|=
literal|0
decl_stmt|;
comment|/* 	 * My manual says times doesn't return a value.  Furthermore, the 	 * snake should get his turn every time no matter if the user is 	 * on a fast terminal with typematic keys or not. 	 * So I have taken the call to times out. 	 */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|same
argument_list|(
operator|&
name|snake
index|[
name|i
index|]
argument_list|,
operator|&
name|snake
index|[
literal|5
index|]
argument_list|)
condition|)
name|issame
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|issame
condition|)
name|pchar
argument_list|(
operator|&
name|snake
index|[
literal|5
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|snake
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|snake
index|[
name|i
index|]
expr_stmt|;
name|chase
argument_list|(
operator|&
name|snake
index|[
literal|0
index|]
argument_list|,
operator|&
name|snake
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|snake
index|[
literal|1
index|]
argument_list|,
name|SNAKETAIL
argument_list|)
expr_stmt|;
name|pchar
argument_list|(
operator|&
name|snake
index|[
literal|0
index|]
argument_list|,
name|SNAKEHEAD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|same
argument_list|(
operator|&
name|snake
index|[
name|i
index|]
argument_list|,
operator|&
name|you
argument_list|)
condition|)
block|{
name|surround
argument_list|(
operator|&
name|you
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|cashvalue
operator|)
operator|%
literal|10
expr_stmt|;
name|bonus
operator|=
operator|(
operator|(
name|rand
argument_list|()
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|%
literal|10
expr_stmt|;
name|ll
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"%d\n"
argument_list|,
name|bonus
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|bonus
operator|==
name|i
condition|)
block|{
name|spacewarp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|logit
argument_list|(
literal|"bonus"
argument_list|)
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|loot
operator|>=
name|penalty
condition|)
block|{
name|pr
argument_list|(
literal|"You and your $%d have been eaten\n"
argument_list|,
name|cashvalue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr
argument_list|(
literal|"The snake ate you.  You owe $%d.\n"
argument_list|,
operator|-
name|cashvalue
argument_list|)
expr_stmt|;
block|}
name|logit
argument_list|(
literal|"eaten"
argument_list|)
expr_stmt|;
name|length
argument_list|(
name|moves
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|chk
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|same
argument_list|(
name|sp
argument_list|,
operator|&
name|money
argument_list|)
condition|)
block|{
name|pchar
argument_list|(
name|sp
argument_list|,
name|TREASURE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|same
argument_list|(
name|sp
argument_list|,
operator|&
name|finish
argument_list|)
condition|)
block|{
name|pchar
argument_list|(
name|sp
argument_list|,
name|GOAL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|same
argument_list|(
name|sp
argument_list|,
operator|&
name|snake
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|pchar
argument_list|(
name|sp
argument_list|,
name|SNAKEHEAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|same
argument_list|(
name|sp
argument_list|,
operator|&
name|snake
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|pchar
argument_list|(
name|sp
argument_list|,
name|SNAKETAIL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|col
operator|<
literal|4
operator|)
operator|&&
operator|(
name|sp
operator|->
name|line
operator|==
literal|0
operator|)
condition|)
block|{
name|winnings
argument_list|(
name|cashvalue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|you
operator|.
name|line
operator|==
literal|0
operator|)
operator|&&
operator|(
name|you
operator|.
name|col
operator|<
literal|4
operator|)
condition|)
name|pchar
argument_list|(
operator|&
name|you
argument_list|,
name|ME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|5
operator|)
return|;
block|}
if|if
condition|(
name|same
argument_list|(
name|sp
argument_list|,
operator|&
name|you
argument_list|)
condition|)
block|{
name|pchar
argument_list|(
name|sp
argument_list|,
name|ME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pchar
argument_list|(
name|sp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|winnings
argument_list|(
argument|won
argument_list|)
end_macro

begin_decl_stmt
name|int
name|won
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|p
decl_stmt|;
name|p
operator|.
name|line
operator|=
name|p
operator|.
name|col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|won
operator|>
literal|0
condition|)
block|{
name|move
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"$%d"
argument_list|,
name|won
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|stop
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ll
argument_list|()
expr_stmt|;
name|length
argument_list|(
name|moves
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|suspend
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|sh
decl_stmt|;
name|ll
argument_list|()
expr_stmt|;
name|cook
argument_list|()
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|winnings
argument_list|(
name|cashvalue
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|length
argument_list|(
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pr
argument_list|(
literal|"You made %d moves.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|logit
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|t
decl_stmt|;
if|if
condition|(
name|logfile
operator|!=
name|NULL
condition|)
block|{
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s $%d %dx%d %s %s"
argument_list|,
name|getlogin
argument_list|()
argument_list|,
name|cashvalue
argument_list|,
name|lcnt
argument_list|,
name|ccnt
argument_list|,
name|msg
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

