begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	create.c		Larn is copyrighted 1986 by Noah Morgan. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|spelknow
index|[]
decl_stmt|,
name|larnlevels
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|beenhere
index|[]
decl_stmt|,
name|wizard
decl_stmt|,
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|oldx
decl_stmt|,
name|oldy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	makeplayer()  	subroutine to create the player and the players attributes 	this is called at the beginning of a game and at no other time  */
end_comment

begin_macro
name|makeplayer
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|scbr
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|c
index|[
name|HPMAX
index|]
operator|=
name|c
index|[
name|HP
index|]
operator|=
literal|10
expr_stmt|;
comment|/*	start player off with 15 hit points	*/
name|c
index|[
name|LEVEL
index|]
operator|=
literal|1
expr_stmt|;
comment|/*	player starts at level one			*/
name|c
index|[
name|SPELLMAX
index|]
operator|=
name|c
index|[
name|SPELLS
index|]
operator|=
literal|1
expr_stmt|;
comment|/*	total # spells starts off as 3	*/
name|c
index|[
name|REGENCOUNTER
index|]
operator|=
literal|16
expr_stmt|;
name|c
index|[
name|ECOUNTER
index|]
operator|=
literal|96
expr_stmt|;
comment|/*start regeneration correctly*/
name|c
index|[
name|SHIELD
index|]
operator|=
name|c
index|[
name|WEAR
index|]
operator|=
name|c
index|[
name|WIELD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
name|iven
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|spelknow
index|[
literal|0
index|]
operator|=
name|spelknow
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/*he knows protection, magic missile*/
if|if
condition|(
name|c
index|[
name|HARDGAME
index|]
operator|<=
literal|0
condition|)
block|{
name|iven
index|[
literal|0
index|]
operator|=
name|OLEATHER
expr_stmt|;
name|iven
index|[
literal|1
index|]
operator|=
name|ODAGGER
expr_stmt|;
name|ivenarg
index|[
literal|1
index|]
operator|=
name|ivenarg
index|[
literal|0
index|]
operator|=
name|c
index|[
name|WEAR
index|]
operator|=
literal|0
expr_stmt|;
name|c
index|[
name|WIELD
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|playerx
operator|=
name|rnd
argument_list|(
name|MAXX
operator|-
literal|2
argument_list|)
expr_stmt|;
name|playery
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|2
argument_list|)
expr_stmt|;
name|oldx
operator|=
literal|0
expr_stmt|;
name|oldy
operator|=
literal|25
expr_stmt|;
name|gtime
operator|=
literal|0
expr_stmt|;
comment|/*	time clock starts at zero	*/
name|cbak
index|[
name|SPELLS
index|]
operator|=
operator|-
literal|50
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|c
index|[
name|i
index|]
operator|=
literal|12
expr_stmt|;
comment|/* make the attributes, ie str, int, etc.	*/
name|recalc
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* 	newcavelevel(level) 	int level;  	function to enter a new level.  This routine must be called anytime the 	player changes levels.  If that level is unknown it will be created. 	A new set of monsters will be created for a new level, and existing 	levels will get a few more monsters. 	Note that it is here we remove genocided monsters from the present level.  */
end_comment

begin_macro
name|newcavelevel
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|beenhere
index|[
name|level
index|]
condition|)
name|savelevel
argument_list|()
expr_stmt|;
comment|/* put the level back into storage	*/
name|level
operator|=
name|x
expr_stmt|;
comment|/* get the new level and put in working storage */
if|if
condition|(
name|beenhere
index|[
name|x
index|]
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXY
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXX
condition|;
name|j
operator|++
control|)
name|know
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|mitem
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|getlevel
argument_list|()
expr_stmt|;
name|sethp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|chgn
goto|;
block|}
name|makemaze
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|makeobject
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|beenhere
index|[
name|x
index|]
operator|=
literal|1
expr_stmt|;
name|sethp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|WIZID
if|if
condition|(
name|wizard
operator|||
name|x
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|x
operator|==
literal|0
condition|)
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXY
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXX
condition|;
name|i
operator|++
control|)
name|know
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|chgn
label|:
name|checkgen
argument_list|()
expr_stmt|;
comment|/* wipe out any genocided monsters */
block|}
end_block

begin_comment
comment|/* 	makemaze(level) 	int level;  	subroutine to make the caverns for a given level.  only walls are made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mx
decl_stmt|,
name|mxl
decl_stmt|,
name|mxh
decl_stmt|,
name|my
decl_stmt|,
name|myl
decl_stmt|,
name|myh
decl_stmt|,
name|tmp2
decl_stmt|;
end_decl_stmt

begin_macro
name|makemaze
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|z
decl_stmt|;
if|if
condition|(
name|k
operator|>
literal|1
operator|&&
operator|(
name|rnd
argument_list|(
literal|17
argument_list|)
operator|<=
literal|4
operator|||
name|k
operator|==
name|MAXLEVEL
operator|-
literal|1
operator|||
name|k
operator|==
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|cannedlevel
argument_list|(
name|k
argument_list|)
condition|)
empty_stmt|;
return|return;
comment|/* read maze from data file */
block|}
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
else|else
name|tmp
operator|=
name|OWALL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXY
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXX
condition|;
name|j
operator|++
control|)
name|item
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return;
name|eat
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
name|item
index|[
literal|33
index|]
index|[
name|MAXY
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* exit from dungeon */
comment|/*	now for open spaces -- not on level 10	*/
if|if
condition|(
name|k
operator|!=
name|MAXLEVEL
operator|-
literal|1
condition|)
block|{
name|tmp2
operator|=
name|rnd
argument_list|(
literal|3
argument_list|)
operator|+
literal|3
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|tmp2
condition|;
name|tmp
operator|++
control|)
block|{
name|my
operator|=
name|rnd
argument_list|(
literal|11
argument_list|)
operator|+
literal|2
expr_stmt|;
name|myl
operator|=
name|my
operator|-
name|rnd
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|myh
operator|=
name|my
operator|+
name|rnd
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|MAXLEVEL
condition|)
block|{
name|mx
operator|=
name|rnd
argument_list|(
literal|44
argument_list|)
operator|+
literal|5
expr_stmt|;
name|mxl
operator|=
name|mx
operator|-
name|rnd
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|mxh
operator|=
name|mx
operator|+
name|rnd
argument_list|(
literal|12
argument_list|)
operator|+
literal|3
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mx
operator|=
name|rnd
argument_list|(
literal|60
argument_list|)
operator|+
literal|3
expr_stmt|;
name|mxl
operator|=
name|mx
operator|-
name|rnd
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mxh
operator|=
name|mx
operator|+
name|rnd
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|z
operator|=
name|makemonst
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|mxl
init|;
name|i
operator|<
name|mxh
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|myl
init|;
name|j
operator|<
name|myh
condition|;
name|j
operator|++
control|)
block|{
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|z
operator|)
condition|)
name|hitp
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|monster
index|[
name|z
index|]
operator|.
name|hitpoints
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|k
operator|!=
name|MAXLEVEL
operator|-
literal|1
condition|)
block|{
name|my
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXX
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|item
index|[
name|i
index|]
index|[
name|my
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|1
condition|)
name|treasureroom
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	function to eat away a filled in maze  */
end_comment

begin_macro
name|eat
argument_list|(
argument|xx
argument_list|,
argument|yy
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xx
decl_stmt|,
name|yy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dir
decl_stmt|,
name|try
decl_stmt|;
name|dir
operator|=
name|rnd
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|try
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|try
condition|)
block|{
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|xx
operator|<=
literal|2
condition|)
break|break;
comment|/*	west	*/
if|if
condition|(
operator|(
name|item
index|[
name|xx
operator|-
literal|1
index|]
index|[
name|yy
index|]
operator|!=
name|OWALL
operator|)
operator|||
operator|(
name|item
index|[
name|xx
operator|-
literal|2
index|]
index|[
name|yy
index|]
operator|!=
name|OWALL
operator|)
condition|)
break|break;
name|item
index|[
name|xx
operator|-
literal|1
index|]
index|[
name|yy
index|]
operator|=
name|item
index|[
name|xx
operator|-
literal|2
index|]
index|[
name|yy
index|]
operator|=
literal|0
expr_stmt|;
name|eat
argument_list|(
name|xx
operator|-
literal|2
argument_list|,
name|yy
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|xx
operator|>=
name|MAXX
operator|-
literal|3
condition|)
break|break;
comment|/*	east	*/
if|if
condition|(
operator|(
name|item
index|[
name|xx
operator|+
literal|1
index|]
index|[
name|yy
index|]
operator|!=
name|OWALL
operator|)
operator|||
operator|(
name|item
index|[
name|xx
operator|+
literal|2
index|]
index|[
name|yy
index|]
operator|!=
name|OWALL
operator|)
condition|)
break|break;
name|item
index|[
name|xx
operator|+
literal|1
index|]
index|[
name|yy
index|]
operator|=
name|item
index|[
name|xx
operator|+
literal|2
index|]
index|[
name|yy
index|]
operator|=
literal|0
expr_stmt|;
name|eat
argument_list|(
name|xx
operator|+
literal|2
argument_list|,
name|yy
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|yy
operator|<=
literal|2
condition|)
break|break;
comment|/*	south	*/
if|if
condition|(
operator|(
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|-
literal|1
index|]
operator|!=
name|OWALL
operator|)
operator|||
operator|(
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|-
literal|2
index|]
operator|!=
name|OWALL
operator|)
condition|)
break|break;
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|-
literal|1
index|]
operator|=
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|eat
argument_list|(
name|xx
argument_list|,
name|yy
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|yy
operator|>=
name|MAXY
operator|-
literal|3
condition|)
break|break;
comment|/*	north	*/
if|if
condition|(
operator|(
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|+
literal|1
index|]
operator|!=
name|OWALL
operator|)
operator|||
operator|(
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|+
literal|2
index|]
operator|!=
name|OWALL
operator|)
condition|)
break|break;
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|+
literal|1
index|]
operator|=
name|item
index|[
name|xx
index|]
index|[
name|yy
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|eat
argument_list|(
name|xx
argument_list|,
name|yy
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
operator|++
name|dir
operator|>
literal|4
condition|)
block|{
name|dir
operator|=
literal|1
expr_stmt|;
operator|--
name|try
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	function to read in a maze from a data file  *  *	Format of maze data file:  1st character = # of mazes in file (ascii digit)  *				For each maze: 18 lines (1st 17 used) 67 characters per line  *  *	Special characters in maze data file:  *  *		#	wall			D	door			.	random monster  *		~	eye of larn		!	cure dianthroritis  *		-	random object  */
end_comment

begin_macro
name|cannedlevel
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|row
decl_stmt|,
modifier|*
name|lgetl
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|it
decl_stmt|,
name|arg
decl_stmt|,
name|mit
decl_stmt|,
name|marg
decl_stmt|;
if|if
condition|(
name|lopen
argument_list|(
name|larnlevels
argument_list|)
operator|<
literal|0
condition|)
block|{
name|write
argument_list|(
literal|1
argument_list|,
literal|"Can't open the maze data file\n"
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|died
argument_list|(
operator|-
literal|282
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|=
name|lgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|'0'
condition|)
block|{
name|died
argument_list|(
operator|-
literal|282
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|18
operator|*
name|rund
argument_list|(
name|i
operator|-
literal|'0'
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|lgetl
argument_list|()
expr_stmt|;
comment|/* advance to desired maze */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXY
condition|;
name|i
operator|++
control|)
block|{
name|row
operator|=
name|lgetl
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXX
condition|;
name|j
operator|++
control|)
block|{
name|it
operator|=
name|mit
operator|=
name|arg
operator|=
name|marg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|row
operator|++
condition|)
block|{
case|case
literal|'#'
case|:
name|it
operator|=
name|OWALL
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|it
operator|=
name|OCLOSEDDOOR
expr_stmt|;
name|arg
operator|=
name|rnd
argument_list|(
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|k
operator|!=
name|MAXLEVEL
operator|-
literal|1
condition|)
break|break;
name|it
operator|=
name|OLARNEYE
expr_stmt|;
name|mit
operator|=
name|rund
argument_list|(
literal|8
argument_list|)
operator|+
name|DEMONLORD
expr_stmt|;
name|marg
operator|=
name|monster
index|[
name|mit
index|]
operator|.
name|hitpoints
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|k
operator|!=
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
condition|)
break|break;
name|it
operator|=
name|OPOTION
expr_stmt|;
name|arg
operator|=
literal|21
expr_stmt|;
name|mit
operator|=
name|DEMONLORD
operator|+
literal|7
expr_stmt|;
name|marg
operator|=
name|monster
index|[
name|mit
index|]
operator|.
name|hitpoints
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|k
operator|<
name|MAXLEVEL
condition|)
break|break;
name|mit
operator|=
name|makemonst
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
name|marg
operator|=
name|monster
index|[
name|mit
index|]
operator|.
name|hitpoints
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|it
operator|=
name|newobject
argument_list|(
name|k
operator|+
literal|1
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|item
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|it
expr_stmt|;
name|iarg
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
name|mitem
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|mit
expr_stmt|;
name|hitp
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|marg
expr_stmt|;
if|#
directive|if
name|WIZID
name|know
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
operator|(
name|wizard
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|#
directive|else
name|know
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|lrclose
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	function to make a treasure room on a level 	level 10's treasure room has the eye in it and demon lords 	level V3 has potion of cure dianthroritis and demon prince  */
end_comment

begin_macro
name|treasureroom
argument_list|(
argument|lv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tx
decl_stmt|,
name|ty
decl_stmt|,
name|xsize
decl_stmt|,
name|ysize
decl_stmt|;
for|for
control|(
name|tx
operator|=
literal|1
operator|+
name|rnd
argument_list|(
literal|10
argument_list|)
init|;
name|tx
operator|<
name|MAXX
operator|-
literal|10
condition|;
name|tx
operator|+=
literal|10
control|)
if|if
condition|(
operator|(
name|lv
operator|==
name|MAXLEVEL
operator|-
literal|1
operator|)
operator|||
operator|(
name|lv
operator|==
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
operator|)
operator|||
name|rnd
argument_list|(
literal|13
argument_list|)
operator|==
literal|2
condition|)
block|{
name|xsize
operator|=
name|rnd
argument_list|(
literal|6
argument_list|)
operator|+
literal|3
expr_stmt|;
name|ysize
operator|=
name|rnd
argument_list|(
literal|3
argument_list|)
operator|+
literal|3
expr_stmt|;
name|ty
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|9
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* upper left corner of room */
if|if
condition|(
name|lv
operator|==
name|MAXLEVEL
operator|-
literal|1
operator|||
name|lv
operator|==
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
condition|)
name|troom
argument_list|(
name|lv
argument_list|,
name|xsize
argument_list|,
name|ysize
argument_list|,
name|tx
operator|=
name|tx
operator|+
name|rnd
argument_list|(
name|MAXX
operator|-
literal|24
argument_list|)
argument_list|,
name|ty
argument_list|,
name|rnd
argument_list|(
literal|3
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
else|else
name|troom
argument_list|(
name|lv
argument_list|,
name|xsize
argument_list|,
name|ysize
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|rnd
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	subroutine to create a treasure room of any size at a given location  *	room is filled with objects and monsters  *	the coordinate given is that of the upper left corner of the room  */
end_comment

begin_macro
name|troom
argument_list|(
argument|lv
argument_list|,
argument|xsize
argument_list|,
argument|ysize
argument_list|,
argument|tx
argument_list|,
argument|ty
argument_list|,
argument|glyph
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lv
decl_stmt|,
name|xsize
decl_stmt|,
name|ysize
decl_stmt|,
name|tx
decl_stmt|,
name|ty
decl_stmt|,
name|glyph
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|tp1
decl_stmt|,
name|tp2
decl_stmt|;
for|for
control|(
name|j
operator|=
name|ty
operator|-
literal|1
init|;
name|j
operator|<=
name|ty
operator|+
name|ysize
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
name|tx
operator|-
literal|1
init|;
name|i
operator|<=
name|tx
operator|+
name|xsize
condition|;
name|i
operator|++
control|)
comment|/* clear out space for room */
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|ty
init|;
name|j
operator|<
name|ty
operator|+
name|ysize
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
name|tx
init|;
name|i
operator|<
name|tx
operator|+
name|xsize
condition|;
name|i
operator|++
control|)
comment|/* now put in the walls */
block|{
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|OWALL
expr_stmt|;
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|ty
operator|+
literal|1
init|;
name|j
operator|<
name|ty
operator|+
name|ysize
operator|-
literal|1
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
name|tx
operator|+
literal|1
init|;
name|i
operator|<
name|tx
operator|+
name|xsize
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* now clear out interior */
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rnd
argument_list|(
literal|2
argument_list|)
condition|)
comment|/* locate the door on the treasure room */
block|{
case|case
literal|1
case|:
name|item
index|[
name|i
operator|=
name|tx
operator|+
name|rund
argument_list|(
name|xsize
argument_list|)
index|]
index|[
name|j
operator|=
name|ty
operator|+
operator|(
name|ysize
operator|-
literal|1
operator|)
operator|*
name|rund
argument_list|(
literal|2
argument_list|)
index|]
operator|=
name|OCLOSEDDOOR
expr_stmt|;
name|iarg
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|glyph
expr_stmt|;
comment|/* on horizontal walls */
break|break;
case|case
literal|2
case|:
name|item
index|[
name|i
operator|=
name|tx
operator|+
operator|(
name|xsize
operator|-
literal|1
operator|)
operator|*
name|rund
argument_list|(
literal|2
argument_list|)
index|]
index|[
name|j
operator|=
name|ty
operator|+
name|rund
argument_list|(
name|ysize
argument_list|)
index|]
operator|=
name|OCLOSEDDOOR
expr_stmt|;
name|iarg
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|glyph
expr_stmt|;
comment|/* on vertical walls */
break|break;
block|}
empty_stmt|;
name|tp1
operator|=
name|playerx
expr_stmt|;
name|tp2
operator|=
name|playery
expr_stmt|;
name|playery
operator|=
name|ty
operator|+
operator|(
name|ysize
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|c
index|[
name|HARDGAME
index|]
operator|<
literal|2
condition|)
for|for
control|(
name|playerx
operator|=
name|tx
operator|+
literal|1
init|;
name|playerx
operator|<=
name|tx
operator|+
name|xsize
operator|-
literal|2
condition|;
name|playerx
operator|+=
literal|2
control|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|rnd
argument_list|(
literal|6
argument_list|)
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|something
argument_list|(
name|lv
operator|+
literal|2
argument_list|)
expr_stmt|;
name|createmonster
argument_list|(
name|makemonst
argument_list|(
name|lv
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|playerx
operator|=
name|tx
operator|+
literal|1
init|;
name|playerx
operator|<=
name|tx
operator|+
name|xsize
operator|-
literal|2
condition|;
name|playerx
operator|+=
literal|2
control|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|rnd
argument_list|(
literal|4
argument_list|)
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|something
argument_list|(
name|lv
operator|+
literal|2
argument_list|)
expr_stmt|;
name|createmonster
argument_list|(
name|makemonst
argument_list|(
name|lv
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|playerx
operator|=
name|tp1
expr_stmt|;
name|playery
operator|=
name|tp2
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|fillroom
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* 	*********** 	MAKE_OBJECT 	*********** 	subroutine to create the objects in the maze for the given level  */
end_comment

begin_macro
name|makeobject
argument_list|(
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|int
name|j
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|fillroom
argument_list|(
name|OENTRANCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	entrance to dungeon			*/
name|fillroom
argument_list|(
name|ODNDSTORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	the DND STORE				*/
name|fillroom
argument_list|(
name|OSCHOOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	college of Larn				*/
name|fillroom
argument_list|(
name|OBANK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	1st national bank of larn 	*/
name|fillroom
argument_list|(
name|OVOLDOWN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	volcano shaft to temple 	*/
name|fillroom
argument_list|(
name|OHOME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	the players home& family 	*/
name|fillroom
argument_list|(
name|OTRADEPOST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  the trading post			*/
name|fillroom
argument_list|(
name|OLRS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  the larn revenue service 	*/
return|return;
block|}
if|if
condition|(
name|j
operator|==
name|MAXLEVEL
condition|)
name|fillroom
argument_list|(
name|OVOLUP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* volcano shaft up from the temple */
comment|/*	make the fixed objects in the maze STAIRS	*/
if|if
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|j
operator|!=
name|MAXLEVEL
operator|-
literal|1
operator|)
operator|&&
operator|(
name|j
operator|!=
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
operator|)
condition|)
name|fillroom
argument_list|(
name|OSTAIRSDOWN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|>
literal|1
operator|)
operator|&&
operator|(
name|j
operator|!=
name|MAXLEVEL
operator|)
condition|)
name|fillroom
argument_list|(
name|OSTAIRSUP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	make the random objects in the maze		*/
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|,
name|OBOOK
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|,
name|OALTAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|,
name|OSTATUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|,
name|OPIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|,
name|OFOUNTAIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rnd
argument_list|(
literal|3
argument_list|)
operator|-
literal|2
argument_list|,
name|OIVTELETRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OTHRONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OMIRROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OTRAPARROWIV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rnd
argument_list|(
literal|3
argument_list|)
operator|-
literal|2
argument_list|,
name|OIVDARTRAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|,
name|OCOOKIE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
name|fillmroom
argument_list|(
literal|1
argument_list|,
name|OCHEST
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OCHEST
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|!=
name|MAXLEVEL
operator|-
literal|1
operator|)
operator|&&
operator|(
name|j
operator|!=
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
operator|)
condition|)
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OIVTRAPDOOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<=
literal|10
condition|)
block|{
name|fillmroom
argument_list|(
operator|(
name|rund
argument_list|(
literal|2
argument_list|)
operator|)
argument_list|,
name|ODIAMOND
argument_list|,
name|rnd
argument_list|(
literal|10
operator|*
name|j
operator|+
literal|1
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|ORUBY
argument_list|,
name|rnd
argument_list|(
literal|6
operator|*
name|j
operator|+
literal|1
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OEMERALD
argument_list|,
name|rnd
argument_list|(
literal|4
operator|*
name|j
operator|+
literal|1
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fillmroom
argument_list|(
name|rund
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OSAPPHIRE
argument_list|,
name|rnd
argument_list|(
literal|3
operator|*
name|j
operator|+
literal|1
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rnd
argument_list|(
literal|4
argument_list|)
operator|+
literal|3
condition|;
name|i
operator|++
control|)
name|fillroom
argument_list|(
name|OPOTION
argument_list|,
name|newpotion
argument_list|()
argument_list|)
expr_stmt|;
comment|/*	make a POTION	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rnd
argument_list|(
literal|5
argument_list|)
operator|+
literal|3
condition|;
name|i
operator|++
control|)
name|fillroom
argument_list|(
name|OSCROLL
argument_list|,
name|newscroll
argument_list|()
argument_list|)
expr_stmt|;
comment|/*	make a SCROLL	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rnd
argument_list|(
literal|12
argument_list|)
operator|+
literal|11
condition|;
name|i
operator|++
control|)
name|fillroom
argument_list|(
name|OGOLDPILE
argument_list|,
literal|12
operator|*
name|rnd
argument_list|(
name|j
operator|+
literal|1
argument_list|)
operator|+
operator|(
name|j
operator|<<
literal|3
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* make GOLD	*/
if|if
condition|(
name|j
operator|==
literal|5
condition|)
name|fillroom
argument_list|(
name|OBANK2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*	branch office of the bank */
name|froom
argument_list|(
literal|2
argument_list|,
name|ORING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* a ring mail 			*/
name|froom
argument_list|(
literal|1
argument_list|,
name|OSTUDLEATHER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* a studded leather	*/
name|froom
argument_list|(
literal|3
argument_list|,
name|OSPLINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* a splint mail		*/
name|froom
argument_list|(
literal|5
argument_list|,
name|OSHIELD
argument_list|,
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a shield				*/
name|froom
argument_list|(
literal|2
argument_list|,
name|OBATTLEAXE
argument_list|,
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a battle axe			*/
name|froom
argument_list|(
literal|5
argument_list|,
name|OLONGSWORD
argument_list|,
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a long sword			*/
name|froom
argument_list|(
literal|5
argument_list|,
name|OFLAIL
argument_list|,
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a flail				*/
name|froom
argument_list|(
literal|4
argument_list|,
name|OREGENRING
argument_list|,
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ring of regeneration */
name|froom
argument_list|(
literal|1
argument_list|,
name|OPROTRING
argument_list|,
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ring of protection	*/
name|froom
argument_list|(
literal|2
argument_list|,
name|OSTRRING
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* ring of strength + 4 */
name|froom
argument_list|(
literal|7
argument_list|,
name|OSPEAR
argument_list|,
name|rnd
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a spear				*/
name|froom
argument_list|(
literal|3
argument_list|,
name|OORBOFDRAGON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* orb of dragon slaying*/
name|froom
argument_list|(
literal|4
argument_list|,
name|OSPIRITSCARAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*scarab of negate spirit*/
name|froom
argument_list|(
literal|4
argument_list|,
name|OCUBEofUNDEAD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cube of undead control	*/
name|froom
argument_list|(
literal|2
argument_list|,
name|ORINGOFEXTRA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ring of extra regen		*/
name|froom
argument_list|(
literal|3
argument_list|,
name|ONOTHEFT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* device of antitheft 		*/
name|froom
argument_list|(
literal|2
argument_list|,
name|OSWORDofSLASHING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* sword of slashing */
if|if
condition|(
name|c
index|[
name|BESSMANN
index|]
operator|==
literal|0
condition|)
block|{
name|froom
argument_list|(
literal|4
argument_list|,
name|OHAMMER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Bessman's flailing hammer*/
name|c
index|[
name|BESSMANN
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
index|[
name|HARDGAME
index|]
operator|<
literal|3
operator|||
operator|(
name|rnd
argument_list|(
literal|4
argument_list|)
operator|==
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|j
operator|>
literal|3
condition|)
block|{
name|froom
argument_list|(
literal|3
argument_list|,
name|OSWORD
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* sunsword + 3  		*/
name|froom
argument_list|(
literal|5
argument_list|,
name|O2SWORD
argument_list|,
name|rnd
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a two handed sword	*/
name|froom
argument_list|(
literal|3
argument_list|,
name|OBELT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* belt of striking		*/
name|froom
argument_list|(
literal|3
argument_list|,
name|OENERGYRING
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* energy ring			*/
name|froom
argument_list|(
literal|4
argument_list|,
name|OPLATE
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* platemail + 5 		*/
block|}
block|}
block|}
end_block

begin_comment
comment|/* 	subroutine to fill in a number of objects of the same kind  */
end_comment

begin_macro
name|fillmroom
argument_list|(
argument|n
argument_list|,
argument|what
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|fillroom
argument_list|(
name|what
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|froom
argument_list|(
argument|n
argument_list|,
argument|itm
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|itm
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|rnd
argument_list|(
literal|151
argument_list|)
operator|<
name|n
condition|)
name|fillroom
argument_list|(
name|itm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	subroutine to put an object into an empty room  *	uses a random walk  */
end_comment

begin_function
specifier|static
name|void
name|fillroom
parameter_list|(
name|what
parameter_list|,
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
name|char
name|what
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|FILLROOM
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|rnd
argument_list|(
name|MAXX
operator|-
literal|2
argument_list|)
expr_stmt|;
name|y
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|item
index|[
name|x
index|]
index|[
name|y
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|RANDOMWALK
index|]
operator|++
expr_stmt|;
comment|/* count up these random walks */
endif|#
directive|endif
name|x
operator|+=
name|rnd
argument_list|(
literal|3
argument_list|)
operator|-
literal|2
expr_stmt|;
name|y
operator|+=
name|rnd
argument_list|(
literal|3
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|MAXX
operator|-
literal|2
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|1
condition|)
name|x
operator|=
name|MAXX
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|MAXY
operator|-
literal|2
condition|)
name|y
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|1
condition|)
name|y
operator|=
name|MAXY
operator|-
literal|2
expr_stmt|;
block|}
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|what
expr_stmt|;
name|iarg
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 	subroutine to put monsters into an empty room without walls or other 	monsters  */
end_comment

begin_macro
name|fillmonst
argument_list|(
argument|what
argument_list|)
end_macro

begin_decl_stmt
name|char
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|trys
decl_stmt|;
for|for
control|(
name|trys
operator|=
literal|5
init|;
name|trys
operator|>
literal|0
condition|;
operator|--
name|trys
control|)
comment|/* max # of creation attempts */
block|{
name|x
operator|=
name|rnd
argument_list|(
name|MAXX
operator|-
literal|2
argument_list|)
expr_stmt|;
name|y
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|playerx
operator|!=
name|x
operator|)
operator|||
operator|(
name|playery
operator|!=
name|y
operator|)
operator|)
condition|)
block|{
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|what
expr_stmt|;
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|monster
index|[
name|what
index|]
operator|.
name|hitpoints
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* creation failure */
block|}
end_block

begin_comment
comment|/* 	creates an entire set of monsters for a level 	must be done when entering a new level 	if sethp(1) then wipe out old monsters else leave them there  */
end_comment

begin_macro
name|sethp
argument_list|(
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|flg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|flg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXY
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXX
condition|;
name|j
operator|++
control|)
name|stealth
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|c
index|[
name|TELEFLAG
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*	if teleported and found level 1 then know level we are on */
if|if
condition|(
name|flg
condition|)
name|j
operator|=
name|rnd
argument_list|(
literal|12
argument_list|)
operator|+
literal|2
operator|+
operator|(
name|level
operator|>>
literal|1
operator|)
expr_stmt|;
else|else
name|j
operator|=
operator|(
name|level
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|fillmonst
argument_list|(
name|makemonst
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|positionplayer
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Function to destroy all genocided monsters on the present level  */
end_comment

begin_macro
name|checkgen
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|MAXY
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAXX
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|monster
index|[
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
index|]
operator|.
name|genocided
condition|)
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no more monster */
block|}
end_block

end_unit

