begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	monster.c		Larn is copyrighted 1986 by Noah Morgan.  * $FreeBSD$  *  *	This file contains the following functions:  *	----------------------------------------------------------------------------  *  *	createmonster(monstno) 		Function to create a monster next to the player  *		int monstno;  *  *	int cgood(x,y,itm,monst)	Function to check location for emptiness  *		int x,y,itm,monst;  *  *	createitem(it,arg) 			Routine to place an item next to the player  *		int it,arg;  *  *	cast() 				Subroutine called by parse to cast a spell for the user  *  *	speldamage(x) 		Function to perform spell functions cast by the player  *		int x;  *  *	loseint()			Routine to decrement your int (intelligence) if> 3  *  *	isconfuse() 		Routine to check to see if player is confused  *  *	nospell(x,monst)	Routine to return 1 if a spell doesn't affect a monster  *		int x,monst;  *  *	fullhit(xx)			Function to return full damage against a monst (aka web)  *		int xx;  *  *	direct(spnum,dam,str,arg)	Routine to direct spell damage 1 square in 1 dir  *		int spnum,dam,arg;  *		char *str;  *  *	godirect(spnum,dam,str,delay,cshow)		Function to perform missile attacks  *		int spnum,dam,delay;  *		char *str,cshow;  *  *	ifblind(x,y)	Routine to put "monster" or the monster name into lastmosnt  *		int x,y;  *  *	tdirect(spnum)			Routine to teleport away a monster  *		int spnum;  *  *	omnidirect(sp,dam,str)  Routine to damage all monsters 1 square from player  *		int sp,dam;  *		char *str;  *  *	dirsub(x,y)			Routine to ask for direction, then modify x,y for it  *		int *x,*y;  *  *	vxy(x,y)		  	Routine to verify/fix (*x,*y) for being within bounds  *		int *x,*y;  *  *	dirpoly(spnum)		Routine to ask for a direction and polymorph a monst  *		int spnum;  *  *	hitmonster(x,y) 	Function to hit a monster at the designated coordinates  *		int x,y;  *  *	hitm(x,y,amt)		Function to just hit a monster at a given coordinates  *		int x,y,amt;  *  *	hitplayer(x,y) 		Function for the monster to hit the player from (x,y)  *		int x,y;  *  *	dropsomething(monst) 	Function to create an object when a monster dies  *		int monst;  *  *	dropgold(amount) 		Function to drop some gold around player  *		int amount;  *  *	something(level) 		Function to create a random item around player  *		int level;  *  *	newobject(lev,i) 		Routine to return a randomly selected new object  *		int lev,*i;  *  *  spattack(atckno,xx,yy) 	Function to process special attacks from monsters  *  	int atckno,xx,yy;  *  *	checkloss(x) 	Routine to subtract hp from user and flag bottomline display  *		int x;  *  *	annihilate()   Routine to annihilate monsters around player, playerx,playery  *  *	newsphere(x,y,dir,lifetime)  Function to create a new sphere of annihilation  *		int x,y,dir,lifetime;  *  *	rmsphere(x,y)		Function to delete a sphere of annihilation from list  *		int x,y;  *  *	sphboom(x,y)		Function to perform the effects of a sphere detonation  *		int x,y;  *  *	genmonst()			Function to ask for monster and genocide from game  *  */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_struct
struct|struct
name|isave
comment|/* used for altar reality */
block|{
name|char
name|type
decl_stmt|;
comment|/* 0=item,  1=monster */
name|char
name|id
decl_stmt|;
comment|/* item number or monster number */
name|short
name|arg
decl_stmt|;
comment|/* the type of item or hitpoints of monster */
block|}
struct|;
end_struct

begin_comment
comment|/*  *	createmonster(monstno) 		Function to create a monster next to the player  *		int monstno;  *  *	Enter with the monster number (1 to MAXMONST+8)  *	Returns no value.  */
end_comment

begin_macro
name|createmonster
argument_list|(
argument|mon
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mon
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|mon
operator|<
literal|1
operator|||
name|mon
operator|>
name|MAXMONST
operator|+
literal|8
condition|)
comment|/* check for monster number out of bounds */
block|{
name|beep
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\ncan't createmonst(%d)\n"
argument_list|,
operator|(
name|long
operator|)
name|mon
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|monster
index|[
name|mon
index|]
operator|.
name|genocided
operator|&&
name|mon
operator|<
name|MAXMONST
condition|)
name|mon
operator|++
expr_stmt|;
comment|/* genocided? */
for|for
control|(
name|k
operator|=
name|rnd
argument_list|(
literal|8
argument_list|)
operator|,
name|i
operator|=
operator|-
literal|8
init|;
name|i
operator|<
literal|0
condition|;
name|i
operator|++
operator|,
name|k
operator|++
control|)
comment|/* choose direction, then try all */
block|{
if|if
condition|(
name|k
operator|>
literal|8
condition|)
name|k
operator|=
literal|1
expr_stmt|;
comment|/* wraparound the diroff arrays */
name|x
operator|=
name|playerx
operator|+
name|diroffx
index|[
name|k
index|]
expr_stmt|;
name|y
operator|=
name|playery
operator|+
name|diroffy
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|cgood
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* if we can create here */
block|{
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|mon
expr_stmt|;
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|monster
index|[
name|mon
index|]
operator|.
name|hitpoints
expr_stmt|;
name|stealth
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mon
condition|)
block|{
case|case
name|ROTHE
case|:
case|case
name|POLTERGEIST
case|:
case|case
name|VAMPIRE
case|:
name|stealth
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	int cgood(x,y,itm,monst)	  Function to check location for emptiness  *		int x,y,itm,monst;  *  *	Routine to return TRUE if a location does not have itm or monst there  *	returns FALSE (0) otherwise  *	Enter with itm or monst TRUE or FALSE if checking it  *	Example:  if itm==TRUE check for no item at this location  *			  if monst==TRUE check for no monster at this location  *	This routine will return FALSE if at a wall or the dungeon exit on level 1  */
end_comment

begin_function
name|int
name|cgood
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|itm
parameter_list|,
name|monst
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|itm
decl_stmt|,
name|monst
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|y
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|y
operator|<=
name|MAXY
operator|-
literal|1
operator|)
operator|&&
operator|(
name|x
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|x
operator|<=
name|MAXX
operator|-
literal|1
operator|)
condition|)
comment|/* within bounds? */
if|if
condition|(
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|!=
name|OWALL
condition|)
comment|/* can't make anything on walls */
if|if
condition|(
name|itm
operator|==
literal|0
operator|||
operator|(
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|==
literal|0
operator|)
condition|)
comment|/* is it free of items? */
if|if
condition|(
name|monst
operator|==
literal|0
operator|||
operator|(
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|==
literal|0
operator|)
condition|)
comment|/* is it free of monsters? */
if|if
condition|(
operator|(
name|level
operator|!=
literal|1
operator|)
operator|||
operator|(
name|x
operator|!=
literal|33
operator|)
operator|||
operator|(
name|y
operator|!=
name|MAXY
operator|-
literal|1
operator|)
condition|)
comment|/* not exit to level 1 */
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	createitem(it,arg) 		Routine to place an item next to the player  *		int it,arg;  *  *	Enter with the item number and its argument (iven[], ivenarg[])  *	Returns no value, thus we don't know about createitem() failures.  */
end_comment

begin_macro
name|createitem
argument_list|(
argument|it
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|it
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|it
operator|>=
name|MAXOBJ
condition|)
return|return;
comment|/* no such object */
for|for
control|(
name|k
operator|=
name|rnd
argument_list|(
literal|8
argument_list|)
operator|,
name|i
operator|=
operator|-
literal|8
init|;
name|i
operator|<
literal|0
condition|;
name|i
operator|++
operator|,
name|k
operator|++
control|)
comment|/* choose direction, then try all */
block|{
if|if
condition|(
name|k
operator|>
literal|8
condition|)
name|k
operator|=
literal|1
expr_stmt|;
comment|/* wraparound the diroff arrays */
name|x
operator|=
name|playerx
operator|+
name|diroffx
index|[
name|k
index|]
expr_stmt|;
name|y
operator|=
name|playery
operator|+
name|diroffy
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|cgood
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* if we can create here */
block|{
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|it
expr_stmt|;
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
name|iarg
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|arg
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	cast() 		Subroutine called by parse to cast a spell for the user  *  *	No arguments and no return value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|eys
index|[]
init|=
literal|"\nEnter your spell: "
decl_stmt|;
end_decl_stmt

begin_macro
name|cast
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|d
decl_stmt|;
name|cursors
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
index|[
name|SPELLS
index|]
operator|<=
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nYou don't have any spells!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
name|eys
argument_list|)
expr_stmt|;
operator|--
name|c
index|[
name|SPELLS
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'D'
condition|)
block|{
name|seemagic
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
name|eys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
literal|'\33'
condition|)
goto|goto
name|over
goto|;
comment|/*	to escape casting a spell	*/
if|if
condition|(
operator|(
name|b
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\33'
condition|)
goto|goto
name|over
goto|;
comment|/*	to escape casting a spell	*/
if|if
condition|(
operator|(
name|d
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\33'
condition|)
block|{
name|over
label|:
name|lprcat
argument_list|(
name|aborted
argument_list|)
expr_stmt|;
name|c
index|[
name|SPELLS
index|]
operator|++
expr_stmt|;
return|return;
block|}
comment|/*	to escape casting a spell	*/
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|SPELLSCAST
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|lprc
argument_list|(
literal|'\n'
argument_list|)
operator|,
name|j
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPNUM
condition|;
name|i
operator|++
control|)
comment|/*seq search for his spell, hash?*/
if|if
condition|(
operator|(
name|spelcode
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|a
operator|)
operator|&&
operator|(
name|spelcode
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
name|b
operator|)
operator|&&
operator|(
name|spelcode
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
name|d
operator|)
condition|)
if|if
condition|(
name|spelknow
index|[
name|i
index|]
condition|)
block|{
name|speldamage
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|SPNUM
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
name|lprcat
argument_list|(
literal|"  Nothing Happened "
argument_list|)
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
block|}
end_block

begin_function_decl
specifier|static
name|int
name|dirsub
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *	speldamage(x) 		Function to perform spell functions cast by the player  *		int x;  *  *	Enter with the spell number, returns no value.  *	Please insure that there are 2 spaces before all messages here  */
end_comment

begin_macro
name|speldamage
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|clev
decl_stmt|;
name|int
name|xl
decl_stmt|,
name|xh
decl_stmt|,
name|yl
decl_stmt|,
name|yh
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|kn
decl_stmt|,
modifier|*
name|pm
decl_stmt|;
if|if
condition|(
name|x
operator|>=
name|SPNUM
condition|)
return|return;
comment|/* no such spell */
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
condition|)
block|{
name|lprcat
argument_list|(
literal|"  It didn't seem to work"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* not if time stopped */
name|clev
operator|=
name|c
index|[
name|LEVEL
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rnd
argument_list|(
literal|23
argument_list|)
operator|==
literal|7
operator|)
operator|||
operator|(
name|rnd
argument_list|(
literal|18
argument_list|)
operator|>
name|c
index|[
name|INTELLIGENCE
index|]
operator|)
condition|)
block|{
name|lprcat
argument_list|(
literal|"  It didn't work!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|clev
operator|*
literal|3
operator|+
literal|2
operator|<
name|x
condition|)
block|{
name|lprcat
argument_list|(
literal|"  Nothing happens.  You seem inexperienced at this"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|x
condition|)
block|{
comment|/* ----- LEVEL 1 SPELLS ----- */
case|case
literal|0
case|:
if|if
condition|(
name|c
index|[
name|PROTECTIONTIME
index|]
operator|==
literal|0
condition|)
name|c
index|[
name|MOREDEFENSES
index|]
operator|+=
literal|2
expr_stmt|;
comment|/* protection field +2 */
name|c
index|[
name|PROTECTIONTIME
index|]
operator|+=
literal|250
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|i
operator|=
name|rnd
argument_list|(
operator|(
operator|(
name|clev
operator|+
literal|1
operator|)
operator|<<
literal|1
operator|)
argument_list|)
operator|+
name|clev
operator|+
literal|3
expr_stmt|;
name|godirect
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
operator|(
name|clev
operator|>=
literal|2
operator|)
condition|?
literal|"  Your missiles hit the %s"
else|:
literal|"  Your missile hit the %s"
argument_list|,
literal|100
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
comment|/* magic missile */
return|return;
case|case
literal|2
case|:
if|if
condition|(
name|c
index|[
name|DEXCOUNT
index|]
operator|==
literal|0
condition|)
name|c
index|[
name|DEXTERITY
index|]
operator|+=
literal|3
expr_stmt|;
comment|/*	dexterity	*/
name|c
index|[
name|DEXCOUNT
index|]
operator|+=
literal|400
expr_stmt|;
return|return;
case|case
literal|3
case|:
name|i
operator|=
name|rnd
argument_list|(
literal|3
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
literal|"  While the %s slept, you smashed it %d times"
expr_stmt|;
name|ws
label|:
name|direct
argument_list|(
name|x
argument_list|,
name|fullhit
argument_list|(
name|i
argument_list|)
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*	sleep	*/
return|return;
case|case
literal|4
case|:
comment|/*	charm monster	*/
name|c
index|[
name|CHARMCOUNT
index|]
operator|+=
name|c
index|[
name|CHARISMA
index|]
operator|<<
literal|1
expr_stmt|;
return|return;
case|case
literal|5
case|:
name|godirect
argument_list|(
name|x
argument_list|,
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
literal|15
operator|+
name|clev
argument_list|,
literal|"  The sound damages the %s"
argument_list|,
literal|70
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
comment|/*	sonic spear */
return|return;
comment|/* ----- LEVEL 2 SPELLS ----- */
case|case
literal|6
case|:
name|i
operator|=
name|rnd
argument_list|(
literal|3
argument_list|)
operator|+
literal|2
expr_stmt|;
name|p
operator|=
literal|"  While the %s is entangled, you hit %d times"
expr_stmt|;
goto|goto
name|ws
goto|;
comment|/* web */
case|case
literal|7
case|:
if|if
condition|(
name|c
index|[
name|STRCOUNT
index|]
operator|==
literal|0
condition|)
name|c
index|[
name|STREXTRA
index|]
operator|+=
literal|3
expr_stmt|;
comment|/*	strength	*/
name|c
index|[
name|STRCOUNT
index|]
operator|+=
literal|150
operator|+
name|rnd
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
name|yl
operator|=
name|playery
operator|-
literal|5
expr_stmt|;
comment|/* enlightenment */
name|yh
operator|=
name|playery
operator|+
literal|6
expr_stmt|;
name|xl
operator|=
name|playerx
operator|-
literal|15
expr_stmt|;
name|xh
operator|=
name|playerx
operator|+
literal|16
expr_stmt|;
name|vxy
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|yl
argument_list|)
expr_stmt|;
name|vxy
argument_list|(
operator|&
name|xh
argument_list|,
operator|&
name|yh
argument_list|)
expr_stmt|;
comment|/* check bounds */
for|for
control|(
name|i
operator|=
name|yl
init|;
name|i
operator|<=
name|yh
condition|;
name|i
operator|++
control|)
comment|/* enlightenment	*/
for|for
control|(
name|j
operator|=
name|xl
init|;
name|j
operator|<=
name|xh
condition|;
name|j
operator|++
control|)
name|know
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|draws
argument_list|(
name|xl
argument_list|,
name|xh
operator|+
literal|1
argument_list|,
name|yl
argument_list|,
name|yh
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|9
case|:
name|raisehp
argument_list|(
literal|20
operator|+
operator|(
name|clev
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return;
comment|/* healing */
case|case
literal|10
case|:
name|c
index|[
name|BLINDCOUNT
index|]
operator|=
literal|0
expr_stmt|;
return|return;
comment|/* cure blindness	*/
case|case
literal|11
case|:
name|createmonster
argument_list|(
name|makemonst
argument_list|(
name|level
operator|+
literal|1
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return;
case|case
literal|12
case|:
if|if
condition|(
name|rnd
argument_list|(
literal|11
argument_list|)
operator|+
literal|7
operator|<=
name|c
index|[
name|WISDOM
index|]
condition|)
name|direct
argument_list|(
name|x
argument_list|,
name|rnd
argument_list|(
literal|20
argument_list|)
operator|+
literal|20
operator|+
name|clev
argument_list|,
literal|"  The %s believed!"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|lprcat
argument_list|(
literal|"  It didn't believe the illusions!"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|13
case|:
comment|/* if he has the amulet of invisibility then add more time */
for|for
control|(
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iven
index|[
name|i
index|]
operator|==
name|OAMULET
condition|)
name|j
operator|+=
literal|1
operator|+
name|ivenarg
index|[
name|i
index|]
expr_stmt|;
name|c
index|[
name|INVISIBILITY
index|]
operator|+=
operator|(
name|j
operator|<<
literal|7
operator|)
operator|+
literal|12
expr_stmt|;
return|return;
comment|/* ----- LEVEL 3 SPELLS ----- */
case|case
literal|14
case|:
name|godirect
argument_list|(
name|x
argument_list|,
name|rnd
argument_list|(
literal|25
operator|+
name|clev
argument_list|)
operator|+
literal|25
operator|+
name|clev
argument_list|,
literal|"  The fireball hits the %s"
argument_list|,
literal|40
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
return|return;
comment|/*	fireball */
case|case
literal|15
case|:
name|godirect
argument_list|(
name|x
argument_list|,
name|rnd
argument_list|(
literal|25
argument_list|)
operator|+
literal|20
operator|+
name|clev
argument_list|,
literal|"  Your cone of cold strikes the %s"
argument_list|,
literal|60
argument_list|,
literal|'O'
argument_list|)
expr_stmt|;
comment|/*	cold */
return|return;
case|case
literal|16
case|:
name|dirpoly
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
comment|/*	polymorph */
case|case
literal|17
case|:
name|c
index|[
name|CANCELLATION
index|]
operator|+=
literal|5
operator|+
name|clev
expr_stmt|;
return|return;
comment|/*	cancellation	*/
case|case
literal|18
case|:
name|c
index|[
name|HASTESELF
index|]
operator|+=
literal|7
operator|+
name|clev
expr_stmt|;
return|return;
comment|/*	haste self	*/
case|case
literal|19
case|:
name|omnidirect
argument_list|(
name|x
argument_list|,
literal|30
operator|+
name|rnd
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"  The %s gasps for air"
argument_list|)
expr_stmt|;
comment|/* cloud kill */
return|return;
case|case
literal|20
case|:
name|xh
operator|=
name|min
argument_list|(
name|playerx
operator|+
literal|1
argument_list|,
name|MAXX
operator|-
literal|2
argument_list|)
expr_stmt|;
name|yh
operator|=
name|min
argument_list|(
name|playery
operator|+
literal|1
argument_list|,
name|MAXY
operator|-
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|max
argument_list|(
name|playerx
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
init|;
name|i
operator|<=
name|xh
condition|;
name|i
operator|++
control|)
comment|/* vaporize rock */
for|for
control|(
name|j
operator|=
name|max
argument_list|(
name|playery
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
init|;
name|j
operator|<=
name|yh
condition|;
name|j
operator|++
control|)
block|{
name|kn
operator|=
operator|&
name|know
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|pm
operator|=
operator|&
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
operator|&
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
condition|)
block|{
case|case
name|OWALL
case|:
if|if
condition|(
name|level
operator|<
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
condition|)
operator|*
name|p
operator|=
operator|*
name|kn
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OSTATUE
case|:
if|if
condition|(
name|c
index|[
name|HARDGAME
index|]
operator|<
literal|3
condition|)
block|{
operator|*
name|p
operator|=
name|OBOOK
expr_stmt|;
name|iarg
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|level
expr_stmt|;
operator|*
name|kn
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|OTHRONE
case|:
operator|*
name|pm
operator|=
name|GNOMEKING
expr_stmt|;
operator|*
name|kn
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
name|OTHRONE2
expr_stmt|;
name|hitp
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|monster
index|[
name|GNOMEKING
index|]
operator|.
name|hitpoints
expr_stmt|;
break|break;
case|case
name|OALTAR
case|:
operator|*
name|pm
operator|=
name|DEMONPRINCE
expr_stmt|;
operator|*
name|kn
operator|=
literal|0
expr_stmt|;
name|hitp
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|monster
index|[
name|DEMONPRINCE
index|]
operator|.
name|hitpoints
expr_stmt|;
break|break;
block|}
empty_stmt|;
switch|switch
condition|(
operator|*
name|pm
condition|)
block|{
case|case
name|XORN
case|:
name|ifblind
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|hitm
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
literal|200
argument_list|)
expr_stmt|;
break|break;
comment|/* Xorn takes damage from vpr */
block|}
block|}
return|return;
comment|/* ----- LEVEL 4 SPELLS ----- */
case|case
literal|21
case|:
name|direct
argument_list|(
name|x
argument_list|,
literal|100
operator|+
name|clev
argument_list|,
literal|"  The %s shrivels up"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* dehydration */
return|return;
case|case
literal|22
case|:
name|godirect
argument_list|(
name|x
argument_list|,
name|rnd
argument_list|(
literal|25
argument_list|)
operator|+
literal|20
operator|+
operator|(
name|clev
operator|<<
literal|1
operator|)
argument_list|,
literal|"  A lightning bolt hits the %s"
argument_list|,
literal|1
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
comment|/*	lightning */
return|return;
case|case
literal|23
case|:
name|i
operator|=
name|min
argument_list|(
name|c
index|[
name|HP
index|]
operator|-
literal|1
argument_list|,
name|c
index|[
name|HPMAX
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* drain life */
name|direct
argument_list|(
name|x
argument_list|,
name|i
operator|+
name|i
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
index|[
name|HP
index|]
operator|-=
name|i
expr_stmt|;
return|return;
case|case
literal|24
case|:
if|if
condition|(
name|c
index|[
name|GLOBE
index|]
operator|==
literal|0
condition|)
name|c
index|[
name|MOREDEFENSES
index|]
operator|+=
literal|10
expr_stmt|;
name|c
index|[
name|GLOBE
index|]
operator|+=
literal|200
expr_stmt|;
name|loseint
argument_list|()
expr_stmt|;
comment|/* globe of invulnerability */
return|return;
case|case
literal|25
case|:
name|omnidirect
argument_list|(
name|x
argument_list|,
literal|32
operator|+
name|clev
argument_list|,
literal|"  The %s struggles for air in your flood!"
argument_list|)
expr_stmt|;
comment|/* flood */
return|return;
case|case
literal|26
case|:
if|if
condition|(
name|rnd
argument_list|(
literal|151
argument_list|)
operator|==
literal|63
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYour heart stopped!\n"
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|died
argument_list|(
literal|270
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
index|[
name|WISDOM
index|]
operator|>
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
literal|10
condition|)
name|direct
argument_list|(
name|x
argument_list|,
literal|2000
argument_list|,
literal|"  The %s's heart stopped"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* finger of death */
else|else
name|lprcat
argument_list|(
literal|"  It didn't work"
argument_list|)
expr_stmt|;
return|return;
comment|/* ----- LEVEL 5 SPELLS ----- */
case|case
literal|27
case|:
name|c
index|[
name|SCAREMONST
index|]
operator|+=
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
name|clev
expr_stmt|;
return|return;
comment|/* scare monster */
case|case
literal|28
case|:
name|c
index|[
name|HOLDMONST
index|]
operator|+=
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
name|clev
expr_stmt|;
return|return;
comment|/* hold monster */
case|case
literal|29
case|:
name|c
index|[
name|TIMESTOP
index|]
operator|+=
name|rnd
argument_list|(
literal|20
argument_list|)
operator|+
operator|(
name|clev
operator|<<
literal|1
operator|)
expr_stmt|;
return|return;
comment|/* time stop */
case|case
literal|30
case|:
name|tdirect
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
comment|/* teleport away */
case|case
literal|31
case|:
name|omnidirect
argument_list|(
name|x
argument_list|,
literal|35
operator|+
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
name|clev
argument_list|,
literal|"  The %s cringes from the flame"
argument_list|)
expr_stmt|;
comment|/* magic fire */
return|return;
comment|/* ----- LEVEL 6 SPELLS ----- */
case|case
literal|32
case|:
if|if
condition|(
operator|(
name|rnd
argument_list|(
literal|23
argument_list|)
operator|==
literal|5
operator|)
operator|&&
operator|(
name|wizard
operator|==
literal|0
operator|)
condition|)
comment|/* sphere of annihilation */
block|{
name|beep
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou have been enveloped by the zone of nothingness!\n"
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|died
argument_list|(
literal|258
argument_list|)
expr_stmt|;
return|return;
block|}
name|xl
operator|=
name|playerx
expr_stmt|;
name|yl
operator|=
name|playery
expr_stmt|;
name|loseint
argument_list|()
expr_stmt|;
name|i
operator|=
name|dirsub
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|yl
argument_list|)
expr_stmt|;
comment|/* get direction of sphere */
name|newsphere
argument_list|(
name|xl
argument_list|,
name|yl
argument_list|,
name|i
argument_list|,
name|rnd
argument_list|(
literal|20
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
comment|/* make a sphere */
return|return;
case|case
literal|33
case|:
name|genmonst
argument_list|()
expr_stmt|;
name|spelknow
index|[
literal|33
index|]
operator|=
literal|0
expr_stmt|;
comment|/* genocide */
name|loseint
argument_list|()
expr_stmt|;
return|return;
case|case
literal|34
case|:
comment|/* summon demon */
if|if
condition|(
name|rnd
argument_list|(
literal|100
argument_list|)
operator|>
literal|30
condition|)
block|{
name|direct
argument_list|(
name|x
argument_list|,
literal|150
argument_list|,
literal|"  The demon strikes at the %s"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rnd
argument_list|(
literal|100
argument_list|)
operator|>
literal|15
condition|)
block|{
name|lprcat
argument_list|(
literal|"  Nothing seems to have happened"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
literal|"  The demon turned on you and vanished!"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|i
operator|=
name|rnd
argument_list|(
literal|40
argument_list|)
operator|+
literal|30
expr_stmt|;
name|lastnum
operator|=
literal|277
expr_stmt|;
name|losehp
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* must say killed by a demon */
return|return;
case|case
literal|35
case|:
comment|/* walk through walls */
name|c
index|[
name|WTW
index|]
operator|+=
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
literal|5
expr_stmt|;
return|return;
case|case
literal|36
case|:
comment|/* alter reality */
block|{
name|struct
name|isave
modifier|*
name|save
decl_stmt|;
comment|/* pointer to item save structure */
name|int
name|sc
decl_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
comment|/* # items saved */
name|save
operator|=
operator|(
expr|struct
name|isave
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|isave
argument_list|)
operator|*
name|MAXX
operator|*
name|MAXY
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXY
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXX
condition|;
name|i
operator|++
control|)
comment|/* save all items and monsters */
block|{
name|xl
operator|=
name|item
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|xl
operator|&&
name|xl
operator|!=
name|OWALL
operator|&&
name|xl
operator|!=
name|OANNIHILATION
condition|)
block|{
name|save
index|[
name|sc
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|save
index|[
name|sc
index|]
operator|.
name|id
operator|=
name|item
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|save
index|[
name|sc
operator|++
index|]
operator|.
name|arg
operator|=
name|iarg
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
name|save
index|[
name|sc
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|save
index|[
name|sc
index|]
operator|.
name|id
operator|=
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|save
index|[
name|sc
operator|++
index|]
operator|.
name|arg
operator|=
name|hitp
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|OWALL
expr_stmt|;
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wizard
condition|)
name|know
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|know
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|eat
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|item
index|[
literal|33
index|]
index|[
name|MAXY
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|2
argument_list|)
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXX
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|>
literal|0
condition|)
comment|/* put objects back in level */
block|{
operator|--
name|sc
expr_stmt|;
if|if
condition|(
name|save
index|[
name|sc
index|]
operator|.
name|type
operator|==
literal|0
condition|)
block|{
name|int
name|trys
decl_stmt|;
for|for
control|(
name|trys
operator|=
literal|100
operator|,
name|i
operator|=
name|j
operator|=
literal|1
init|;
operator|--
name|trys
operator|>
literal|0
operator|&&
name|item
index|[
name|i
index|]
index|[
name|j
index|]
condition|;
name|i
operator|=
name|rnd
argument_list|(
name|MAXX
operator|-
literal|1
argument_list|)
operator|,
name|j
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|1
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|trys
condition|)
block|{
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|save
index|[
name|sc
index|]
operator|.
name|id
expr_stmt|;
name|iarg
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|save
index|[
name|sc
index|]
operator|.
name|arg
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* put monsters back in */
name|int
name|trys
decl_stmt|;
for|for
control|(
name|trys
operator|=
literal|100
operator|,
name|i
operator|=
name|j
operator|=
literal|1
init|;
operator|--
name|trys
operator|>
literal|0
operator|&&
operator|(
name|item
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|OWALL
operator|||
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
condition|;
name|i
operator|=
name|rnd
argument_list|(
name|MAXX
operator|-
literal|1
argument_list|)
operator|,
name|j
operator|=
name|rnd
argument_list|(
name|MAXY
operator|-
literal|1
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|trys
condition|)
block|{
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|save
index|[
name|sc
index|]
operator|.
name|id
expr_stmt|;
name|hitp
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|save
index|[
name|sc
index|]
operator|.
name|arg
expr_stmt|;
block|}
block|}
block|}
name|loseint
argument_list|()
expr_stmt|;
name|draws
argument_list|(
literal|0
argument_list|,
name|MAXX
argument_list|,
literal|0
argument_list|,
name|MAXY
argument_list|)
expr_stmt|;
if|if
condition|(
name|wizard
operator|==
literal|0
condition|)
name|spelknow
index|[
literal|36
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
argument_list|)
expr_stmt|;
name|positionplayer
argument_list|()
expr_stmt|;
return|return;
block|}
case|case
literal|37
case|:
comment|/* permanence */
name|adjtime
argument_list|(
operator|-
literal|99999L
argument_list|)
expr_stmt|;
name|spelknow
index|[
literal|37
index|]
operator|=
literal|0
expr_stmt|;
comment|/* forget */
name|loseint
argument_list|()
expr_stmt|;
return|return;
default|default:
name|lprintf
argument_list|(
literal|"  spell %d not available!"
argument_list|,
operator|(
name|long
operator|)
name|x
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
empty_stmt|;
block|}
end_block

begin_comment
comment|/*  *	loseint()		Routine to subtract 1 from your int (intelligence) if> 3  *  *	No arguments and no return value  */
end_comment

begin_macro
name|loseint
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|--
name|c
index|[
name|INTELLIGENCE
index|]
operator|<
literal|3
condition|)
name|c
index|[
name|INTELLIGENCE
index|]
operator|=
literal|3
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	isconfuse() 		Routine to check to see if player is confused  *  *	This routine prints out a message saying "You can't aim your magic!"  *	returns 0 if not confused, non-zero (time remaining confused) if confused  */
end_comment

begin_macro
name|isconfuse
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|c
index|[
name|CONFUSE
index|]
condition|)
block|{
name|lprcat
argument_list|(
literal|" You can't aim your magic!"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|c
index|[
name|CONFUSE
index|]
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	nospell(x,monst)	Routine to return 1 if a spell doesn't affect a monster  *		int x,monst;  *  *	Subroutine to return 1 if the spell can't affect the monster  *	  otherwise returns 0  *	Enter with the spell number in x, and the monster number in monst.  */
end_comment

begin_macro
name|nospell
argument_list|(
argument|x
argument_list|,
argument|monst
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|monst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|x
operator|>=
name|SPNUM
operator|||
name|monst
operator|>=
name|MAXMONST
operator|+
literal|8
operator|||
name|monst
operator|<
literal|0
operator|||
name|x
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* bad spell or monst */
if|if
condition|(
operator|(
name|tmp
operator|=
name|spelweird
index|[
name|monst
operator|-
literal|1
index|]
index|[
name|x
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|spelmes
index|[
name|tmp
index|]
argument_list|,
name|monster
index|[
name|monst
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	fullhit(xx)		Function to return full damage against a monster (aka web)  *		int xx;  *  *	Function to return hp damage to monster due to a number of full hits  *	Enter with the number of full hits being done  */
end_comment

begin_macro
name|fullhit
argument_list|(
argument|xx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|xx
operator|<
literal|0
operator|||
name|xx
operator|>
literal|20
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fullhits are out of range */
if|if
condition|(
name|c
index|[
name|LANCEDEATH
index|]
condition|)
return|return
operator|(
literal|10000
operator|)
return|;
comment|/* lance of death */
name|i
operator|=
name|xx
operator|*
operator|(
operator|(
name|c
index|[
name|WCLASS
index|]
operator|>>
literal|1
operator|)
operator|+
name|c
index|[
name|STRENGTH
index|]
operator|+
name|c
index|[
name|STREXTRA
index|]
operator|-
name|c
index|[
name|HARDGAME
index|]
operator|-
literal|12
operator|+
name|c
index|[
name|MOREDAM
index|]
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|i
operator|>=
literal|1
operator|)
condition|?
name|i
else|:
name|xx
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	direct(spnum,dam,str,arg)	Routine to direct spell damage 1 square in 1 dir  *		int spnum,dam,arg;  *		char *str;  *  *	Routine to ask for a direction to a spell and then hit the monster  *	Enter with the spell number in spnum, the damage to be done in dam,  *	  lprintf format string in str, and lprintf's argument in arg.  *	Returns no value.  */
end_comment

begin_macro
name|direct
argument_list|(
argument|spnum
argument_list|,
argument|dam
argument_list|,
argument|str
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|spnum
decl_stmt|,
name|dam
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|spnum
operator|<
literal|0
operator|||
name|spnum
operator|>=
name|SPNUM
operator|||
name|str
operator|==
literal|0
condition|)
return|return;
comment|/* bad arguments */
if|if
condition|(
name|isconfuse
argument_list|()
condition|)
return|return;
name|dirsub
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|m
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
expr_stmt|;
if|if
condition|(
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|==
name|OMIRROR
condition|)
block|{
if|if
condition|(
name|spnum
operator|==
literal|3
condition|)
comment|/* sleep */
block|{
name|lprcat
argument_list|(
literal|"You fall asleep! "
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|fool
label|:
name|arg
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|arg
operator|--
operator|>
literal|0
condition|)
block|{
name|parse2
argument_list|()
expr_stmt|;
name|nap
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|spnum
operator|==
literal|6
condition|)
comment|/* web */
block|{
name|lprcat
argument_list|(
literal|"You get stuck in your own web! "
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
goto|goto
name|fool
goto|;
block|}
else|else
block|{
name|lastnum
operator|=
literal|278
expr_stmt|;
name|lprintf
argument_list|(
name|str
argument_list|,
literal|"spell caster (thats you)"
argument_list|,
operator|(
name|long
operator|)
name|arg
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|losehp
argument_list|(
name|dam
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"  There wasn't anything there!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifblind
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|nospell
argument_list|(
name|spnum
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|lasthx
operator|=
name|x
expr_stmt|;
name|lasthy
operator|=
name|y
expr_stmt|;
return|return;
block|}
name|lprintf
argument_list|(
name|str
argument_list|,
name|lastmonst
argument_list|,
operator|(
name|long
operator|)
name|arg
argument_list|)
expr_stmt|;
name|hitm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|dam
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	godirect(spnum,dam,str,delay,cshow)		Function to perform missile attacks  *		int spnum,dam,delay;  *		char *str,cshow;  *  *	Function to hit in a direction from a missile weapon and have it keep  *	on going in that direction until its power is exhausted  *	Enter with the spell number in spnum, the power of the weapon in hp,  *	  lprintf format string in str, the # of milliseconds to delay between  *	  locations in delay, and the character to represent the weapon in cshow.  *	Returns no value.  */
end_comment

begin_macro
name|godirect
argument_list|(
argument|spnum
argument_list|,
argument|dam
argument_list|,
argument|str
argument_list|,
argument|delay
argument_list|,
argument|cshow
argument_list|)
end_macro

begin_decl_stmt
name|int
name|spnum
decl_stmt|,
name|dam
decl_stmt|,
name|delay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|,
name|cshow
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|m
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
if|if
condition|(
name|spnum
operator|<
literal|0
operator|||
name|spnum
operator|>=
name|SPNUM
operator|||
name|str
operator|==
literal|0
operator|||
name|delay
operator|<
literal|0
condition|)
return|return;
comment|/* bad args */
if|if
condition|(
name|isconfuse
argument_list|()
condition|)
return|return;
name|dirsub
argument_list|(
operator|&
name|dx
argument_list|,
operator|&
name|dy
argument_list|)
expr_stmt|;
name|x
operator|=
name|dx
expr_stmt|;
name|y
operator|=
name|dy
expr_stmt|;
name|dx
operator|=
name|x
operator|-
name|playerx
expr_stmt|;
name|dy
operator|=
name|y
operator|-
name|playery
expr_stmt|;
name|x
operator|=
name|playerx
expr_stmt|;
name|y
operator|=
name|playery
expr_stmt|;
while|while
condition|(
name|dam
operator|>
literal|0
condition|)
block|{
name|x
operator|+=
name|dx
expr_stmt|;
name|y
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|>
name|MAXX
operator|-
literal|1
operator|)
operator|||
operator|(
name|y
operator|>
name|MAXY
operator|-
literal|1
operator|)
operator|||
operator|(
name|x
operator|<
literal|0
operator|)
operator|||
operator|(
name|y
operator|<
literal|0
operator|)
condition|)
block|{
name|dam
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* out of bounds */
block|}
if|if
condition|(
operator|(
name|x
operator|==
name|playerx
operator|)
operator|&&
operator|(
name|y
operator|==
name|playery
operator|)
condition|)
comment|/* if energy hits player */
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou are hit my your own magic!"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|lastnum
operator|=
literal|278
expr_stmt|;
name|losehp
argument_list|(
name|dam
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
index|[
name|BLINDCOUNT
index|]
operator|==
literal|0
condition|)
comment|/* if not blind show effect */
block|{
name|cursor
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lprc
argument_list|(
name|cshow
argument_list|)
expr_stmt|;
name|nap
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
condition|)
comment|/* is there a monster there? */
block|{
name|ifblind
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|nospell
argument_list|(
name|spnum
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|lasthx
operator|=
name|x
expr_stmt|;
name|lasthy
operator|=
name|y
expr_stmt|;
return|return;
block|}
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|str
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|dam
operator|-=
name|hitm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|dam
argument_list|)
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|x
operator|-=
name|dx
expr_stmt|;
name|y
operator|-=
name|dy
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
operator|&
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
condition|)
block|{
case|case
name|OWALL
case|:
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|str
argument_list|,
literal|"wall"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dam
operator|>=
literal|50
operator|+
name|c
index|[
name|HARDGAME
index|]
condition|)
comment|/* enough damage? */
if|if
condition|(
name|level
operator|<
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|-
literal|1
condition|)
comment|/* not on V3 */
if|if
condition|(
operator|(
name|x
operator|<
name|MAXX
operator|-
literal|1
operator|)
operator|&&
operator|(
name|y
operator|<
name|MAXY
operator|-
literal|1
operator|)
operator|&&
operator|(
name|x
operator|)
operator|&&
operator|(
name|y
operator|)
condition|)
block|{
name|lprcat
argument_list|(
literal|"  The wall crumbles"
argument_list|)
expr_stmt|;
name|god3
label|:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|god
label|:
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|god2
label|:
name|dam
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OCLOSEDDOOR
case|:
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|str
argument_list|,
literal|"door"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dam
operator|>=
literal|40
condition|)
block|{
name|lprcat
argument_list|(
literal|"  The door is blasted apart"
argument_list|)
expr_stmt|;
goto|goto
name|god3
goto|;
block|}
goto|goto
name|god2
goto|;
case|case
name|OSTATUE
case|:
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|str
argument_list|,
literal|"statue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
index|[
name|HARDGAME
index|]
operator|<
literal|3
condition|)
if|if
condition|(
name|dam
operator|>
literal|44
condition|)
block|{
name|lprcat
argument_list|(
literal|"  The statue crumbles"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|OBOOK
expr_stmt|;
name|iarg
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|level
expr_stmt|;
goto|goto
name|god
goto|;
block|}
goto|goto
name|god2
goto|;
case|case
name|OTHRONE
case|:
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|str
argument_list|,
literal|"throne"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dam
operator|>
literal|39
condition|)
block|{
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|GNOMEKING
expr_stmt|;
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|monster
index|[
name|GNOMEKING
index|]
operator|.
name|hitpoints
expr_stmt|;
operator|*
name|p
operator|=
name|OTHRONE2
expr_stmt|;
goto|goto
name|god
goto|;
block|}
goto|goto
name|god2
goto|;
case|case
name|OMIRROR
case|:
name|dx
operator|*=
operator|-
literal|1
expr_stmt|;
name|dy
operator|*=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|dam
operator|-=
literal|3
operator|+
operator|(
name|c
index|[
name|HARDGAME
index|]
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	ifblind(x,y)	Routine to put "monster" or the monster name into lastmosnt  *		int x,y;  *  *	Subroutine to copy the word "monster" into lastmonst if the player is blind  *	Enter with the coordinates (x,y) of the monster  *	Returns no value.  */
end_comment

begin_macro
name|ifblind
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|vxy
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* verify correct x,y coordinates */
if|if
condition|(
name|c
index|[
name|BLINDCOUNT
index|]
condition|)
block|{
name|lastnum
operator|=
literal|279
expr_stmt|;
name|p
operator|=
literal|"monster"
expr_stmt|;
block|}
else|else
block|{
name|lastnum
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
expr_stmt|;
name|p
operator|=
name|monster
index|[
name|lastnum
index|]
operator|.
name|name
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|lastmonst
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	tdirect(spnum)		Routine to teleport away a monster  *		int spnum;  *  *	Routine to ask for a direction to a spell and then teleport away monster  *	Enter with the spell number that wants to teleport away  *	Returns no value.  */
end_comment

begin_macro
name|tdirect
argument_list|(
argument|spnum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|spnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|spnum
operator|<
literal|0
operator|||
name|spnum
operator|>=
name|SPNUM
condition|)
return|return;
comment|/* bad args */
if|if
condition|(
name|isconfuse
argument_list|()
condition|)
return|return;
name|dirsub
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"  There wasn't anything there!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifblind
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|nospell
argument_list|(
name|spnum
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|lasthx
operator|=
name|x
expr_stmt|;
name|lasthy
operator|=
name|y
expr_stmt|;
return|return;
block|}
name|fillmonst
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	omnidirect(sp,dam,str)   Routine to damage all monsters 1 square from player  *		int sp,dam;  *		char *str;  *  *	Routine to cast a spell and then hit the monster in all directions  *	Enter with the spell number in sp, the damage done to wach square in dam,  *	  and the lprintf string to identify the spell in str.  *	Returns no value.  */
end_comment

begin_macro
name|omnidirect
argument_list|(
argument|spnum
argument_list|,
argument|dam
argument_list|,
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|int
name|spnum
decl_stmt|,
name|dam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|spnum
operator|<
literal|0
operator|||
name|spnum
operator|>=
name|SPNUM
operator|||
name|str
operator|==
literal|0
condition|)
return|return;
comment|/* bad args */
for|for
control|(
name|x
operator|=
name|playerx
operator|-
literal|1
init|;
name|x
operator|<
name|playerx
operator|+
literal|2
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
name|playery
operator|-
literal|1
init|;
name|y
operator|<
name|playery
operator|+
literal|2
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
condition|)
block|{
if|if
condition|(
name|nospell
argument_list|(
name|spnum
argument_list|,
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ifblind
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
name|str
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|hitm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|dam
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|800
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lasthx
operator|=
name|x
expr_stmt|;
name|lasthy
operator|=
name|y
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	static dirsub(x,y)		Routine to ask for direction, then modify x,y for it  *		int *x,*y;  *  *	Function to ask for a direction and modify an x,y for that direction  *	Enter with the origination coordinates in (x,y).  *	Returns index into diroffx[] (0-8).  */
end_comment

begin_function
specifier|static
name|int
name|dirsub
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|int
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|lprcat
argument_list|(
literal|"\nIn What Direction? "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
switch|switch
condition|(
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'b'
case|:
name|i
operator|++
expr_stmt|;
case|case
literal|'n'
case|:
name|i
operator|++
expr_stmt|;
case|case
literal|'y'
case|:
name|i
operator|++
expr_stmt|;
case|case
literal|'u'
case|:
name|i
operator|++
expr_stmt|;
case|case
literal|'h'
case|:
name|i
operator|++
expr_stmt|;
case|case
literal|'k'
case|:
name|i
operator|++
expr_stmt|;
case|case
literal|'l'
case|:
name|i
operator|++
expr_stmt|;
case|case
literal|'j'
case|:
name|i
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
empty_stmt|;
name|out
label|:
operator|*
name|x
operator|=
name|playerx
operator|+
name|diroffx
index|[
name|i
index|]
expr_stmt|;
operator|*
name|y
operator|=
name|playery
operator|+
name|diroffy
index|[
name|i
index|]
expr_stmt|;
name|vxy
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	vxy(x,y)	   Routine to verify/fix coordinates for being within bounds  *		int *x,*y;  *  *	Function to verify x& y are within the bounds for a level  *	If *x or *y is not within the absolute bounds for a level, fix them so that  *	  they are on the level.  *	Returns TRUE if it was out of bounds, and the *x& *y in the calling  *	routine are affected.  */
end_comment

begin_macro
name|vxy
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|x
operator|<
literal|0
condition|)
block|{
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|flag
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|y
operator|<
literal|0
condition|)
block|{
operator|*
name|y
operator|=
literal|0
expr_stmt|;
name|flag
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|x
operator|>=
name|MAXX
condition|)
block|{
operator|*
name|x
operator|=
name|MAXX
operator|-
literal|1
expr_stmt|;
name|flag
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|y
operator|>=
name|MAXY
condition|)
block|{
operator|*
name|y
operator|=
name|MAXY
operator|-
literal|1
expr_stmt|;
name|flag
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|flag
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	dirpoly(spnum)		Routine to ask for a direction and polymorph a monst  *		int spnum;  *  *	Subroutine to polymorph a monster and ask for the direction its in  *	Enter with the spell number in spmun.  *	Returns no value.  */
end_comment

begin_macro
name|dirpoly
argument_list|(
argument|spnum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|spnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|spnum
operator|<
literal|0
operator|||
name|spnum
operator|>=
name|SPNUM
condition|)
return|return;
comment|/* bad args */
if|if
condition|(
name|isconfuse
argument_list|()
condition|)
return|return;
comment|/* if he is confused, he can't aim his magic */
name|dirsub
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|==
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"  There wasn't anything there!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifblind
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|nospell
argument_list|(
name|spnum
argument_list|,
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
argument_list|)
condition|)
block|{
name|lasthx
operator|=
name|x
expr_stmt|;
name|lasthy
operator|=
name|y
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|monster
index|[
name|m
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|rnd
argument_list|(
name|MAXMONST
operator|+
literal|7
argument_list|)
index|]
operator|.
name|genocided
condition|)
empty_stmt|;
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|monster
index|[
name|m
index|]
operator|.
name|hitpoints
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* show the new monster */
block|}
end_block

begin_comment
comment|/*  *	hitmonster(x,y) 	Function to hit a monster at the designated coordinates  *		int x,y;  *  *	This routine is used for a bash& slash type attack on a monster  *	Enter with the coordinates of the monster in (x,y).  *	Returns no value.  */
end_comment

begin_macro
name|hitmonster
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tmp
decl_stmt|,
name|monst
decl_stmt|,
name|damag
decl_stmt|,
name|flag
decl_stmt|;
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
condition|)
return|return;
comment|/* not if time stopped */
name|vxy
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* verify coordinates are within range */
if|if
condition|(
operator|(
name|monst
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
operator|==
literal|0
condition|)
return|return;
name|hit3flag
operator|=
literal|1
expr_stmt|;
name|ifblind
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|monster
index|[
name|monst
index|]
operator|.
name|armorclass
operator|+
name|c
index|[
name|LEVEL
index|]
operator|+
name|c
index|[
name|DEXTERITY
index|]
operator|+
name|c
index|[
name|WCLASS
index|]
operator|/
literal|4
operator|-
literal|12
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|rnd
argument_list|(
literal|20
argument_list|)
operator|<
name|tmp
operator|-
name|c
index|[
name|HARDGAME
index|]
operator|)
operator|||
operator|(
name|rnd
argument_list|(
literal|71
argument_list|)
operator|<
literal|5
operator|)
condition|)
comment|/* need at least random chance to hit */
block|{
name|lprcat
argument_list|(
literal|"\nYou hit"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|damag
operator|=
name|fullhit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|damag
operator|<
literal|9999
condition|)
name|damag
operator|=
name|rnd
argument_list|(
name|damag
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lprcat
argument_list|(
literal|"\nYou missed"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
name|lprcat
argument_list|(
literal|" the "
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
name|lastmonst
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
comment|/* if the monster was hit */
if|if
condition|(
operator|(
name|monst
operator|==
name|RUSTMONSTER
operator|)
operator|||
operator|(
name|monst
operator|==
name|DISENCHANTRESS
operator|)
operator|||
operator|(
name|monst
operator|==
name|CUBE
operator|)
condition|)
if|if
condition|(
name|c
index|[
name|WIELD
index|]
operator|>
literal|0
condition|)
if|if
condition|(
name|ivenarg
index|[
name|c
index|[
name|WIELD
index|]
index|]
operator|>
operator|-
literal|10
condition|)
block|{
name|lprintf
argument_list|(
literal|"\nYour weapon is dulled by the %s"
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
operator|--
name|ivenarg
index|[
name|c
index|[
name|WIELD
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
name|hitm
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|damag
argument_list|)
expr_stmt|;
if|if
condition|(
name|monst
operator|==
name|VAMPIRE
condition|)
if|if
condition|(
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|<
literal|25
condition|)
block|{
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|BAT
expr_stmt|;
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	hitm(x,y,amt)		Function to just hit a monster at a given coordinates  *		int x,y,amt;  *  *	Returns the number of hitpoints the monster absorbed  *	This routine is used to specifically damage a monster at a location (x,y)  *	Called by hitmonster(x,y)  */
end_comment

begin_macro
name|hitm
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|amt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|amt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|monst
decl_stmt|;
name|int
name|hpoints
decl_stmt|,
name|amt2
decl_stmt|;
name|vxy
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* verify coordinates are within range */
name|amt2
operator|=
name|amt
expr_stmt|;
comment|/* save initial damage so we can return it */
name|monst
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
expr_stmt|;
if|if
condition|(
name|c
index|[
name|HALFDAM
index|]
condition|)
name|amt
operator|>>=
literal|1
expr_stmt|;
comment|/* if half damage curse adjust damage points */
if|if
condition|(
name|amt
operator|<=
literal|0
condition|)
name|amt2
operator|=
name|amt
operator|=
literal|1
expr_stmt|;
name|lasthx
operator|=
name|x
expr_stmt|;
name|lasthy
operator|=
name|y
expr_stmt|;
name|stealth
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|1
expr_stmt|;
comment|/* make sure hitting monst breaks stealth condition */
name|c
index|[
name|HOLDMONST
index|]
operator|=
literal|0
expr_stmt|;
comment|/* hit a monster breaks hold monster spell	*/
switch|switch
condition|(
name|monst
condition|)
comment|/* if a dragon and orb(s) of dragon slaying	*/
block|{
case|case
name|WHITEDRAGON
case|:
case|case
name|REDDRAGON
case|:
case|case
name|GREENDRAGON
case|:
case|case
name|BRONZEDRAGON
case|:
case|case
name|PLATINUMDRAGON
case|:
case|case
name|SILVERDRAGON
case|:
name|amt
operator|*=
literal|1
operator|+
operator|(
name|c
index|[
name|SLAYING
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
break|break;
block|}
comment|/* invincible monster fix is here */
if|if
condition|(
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|>
name|monster
index|[
name|monst
index|]
operator|.
name|hitpoints
condition|)
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|monster
index|[
name|monst
index|]
operator|.
name|hitpoints
expr_stmt|;
if|if
condition|(
operator|(
name|hpoints
operator|=
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
operator|<=
name|amt
condition|)
block|{
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|MONSTKILLED
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|lprintf
argument_list|(
literal|"\nThe %s died!"
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|raiseexperience
argument_list|(
operator|(
name|long
operator|)
name|monster
index|[
name|monst
index|]
operator|.
name|experience
argument_list|)
expr_stmt|;
name|amt
operator|=
name|monster
index|[
name|monst
index|]
operator|.
name|gold
expr_stmt|;
if|if
condition|(
name|amt
operator|>
literal|0
condition|)
name|dropgold
argument_list|(
name|rnd
argument_list|(
name|amt
argument_list|)
operator|+
name|amt
argument_list|)
expr_stmt|;
name|dropsomething
argument_list|(
name|monst
argument_list|)
expr_stmt|;
name|disappear
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
return|return
operator|(
name|hpoints
operator|)
return|;
block|}
name|hitp
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|hpoints
operator|-
name|amt
expr_stmt|;
return|return
operator|(
name|amt2
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	hitplayer(x,y) 		Function for the monster to hit the player from (x,y)  *		int x,y;  *  *	Function for the monster to hit the player with monster at location x,y  *	Returns nothing of value.  */
end_comment

begin_macro
name|hitplayer
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dam
decl_stmt|,
name|tmp
decl_stmt|,
name|mster
decl_stmt|,
name|bias
decl_stmt|;
name|vxy
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* verify coordinates are within range */
name|lastnum
operator|=
name|mster
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
expr_stmt|;
comment|/*	spirit naga's and poltergeist's do nothing if scarab of negate spirit	*/
if|if
condition|(
name|c
index|[
name|NEGATESPIRIT
index|]
operator|||
name|c
index|[
name|SPIRITPRO
index|]
condition|)
if|if
condition|(
operator|(
name|mster
operator|==
name|POLTERGEIST
operator|)
operator|||
operator|(
name|mster
operator|==
name|SPIRITNAGA
operator|)
condition|)
return|return;
comment|/*	if undead and cube of undead control	*/
if|if
condition|(
name|c
index|[
name|CUBEofUNDEAD
index|]
operator|||
name|c
index|[
name|UNDEADPRO
index|]
condition|)
if|if
condition|(
operator|(
name|mster
operator|==
name|VAMPIRE
operator|)
operator|||
operator|(
name|mster
operator|==
name|WRAITH
operator|)
operator|||
operator|(
name|mster
operator|==
name|ZOMBIE
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|1
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|bias
operator|=
operator|(
name|c
index|[
name|HARDGAME
index|]
operator|)
operator|+
literal|1
expr_stmt|;
name|hitflag
operator|=
name|hit2flag
operator|=
name|hit3flag
operator|=
literal|1
expr_stmt|;
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|ifblind
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
index|[
name|INVISIBILITY
index|]
condition|)
if|if
condition|(
name|rnd
argument_list|(
literal|33
argument_list|)
operator|<
literal|20
condition|)
block|{
name|lprintf
argument_list|(
literal|"\nThe %s misses wildly"
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
index|[
name|CHARMCOUNT
index|]
condition|)
if|if
condition|(
name|rnd
argument_list|(
literal|30
argument_list|)
operator|+
literal|5
operator|*
name|monster
index|[
name|mster
index|]
operator|.
name|level
operator|-
name|c
index|[
name|CHARISMA
index|]
operator|<
literal|30
condition|)
block|{
name|lprintf
argument_list|(
literal|"\nThe %s is awestruck at your magnificence!"
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mster
operator|==
name|BAT
condition|)
name|dam
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|dam
operator|=
name|monster
index|[
name|mster
index|]
operator|.
name|damage
expr_stmt|;
name|dam
operator|+=
name|rnd
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|dam
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|dam
argument_list|)
argument_list|)
operator|+
name|monster
index|[
name|mster
index|]
operator|.
name|level
expr_stmt|;
block|}
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|monster
index|[
name|mster
index|]
operator|.
name|attack
operator|>
literal|0
condition|)
if|if
condition|(
operator|(
operator|(
name|dam
operator|+
name|bias
operator|+
literal|8
operator|)
operator|>
name|c
index|[
name|AC
index|]
operator|)
operator|||
operator|(
name|rnd
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|c
index|[
name|AC
index|]
operator|>
literal|0
operator|)
condition|?
name|c
index|[
name|AC
index|]
else|:
literal|1
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|spattack
argument_list|(
name|monster
index|[
name|mster
index|]
operator|.
name|attack
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|flushall
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
literal|1
expr_stmt|;
name|bias
operator|-=
literal|2
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|dam
operator|+
name|bias
operator|)
operator|>
name|c
index|[
name|AC
index|]
operator|)
operator|||
operator|(
name|rnd
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|c
index|[
name|AC
index|]
operator|>
literal|0
operator|)
condition|?
name|c
index|[
name|AC
index|]
else|:
literal|1
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
name|lprintf
argument_list|(
literal|"\n  The %s hit you "
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dam
operator|-=
name|c
index|[
name|AC
index|]
operator|)
operator|<
literal|0
condition|)
name|dam
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dam
operator|>
literal|0
condition|)
block|{
name|losehp
argument_list|(
name|dam
argument_list|)
expr_stmt|;
name|bottomhp
argument_list|()
expr_stmt|;
name|flushall
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|lprintf
argument_list|(
literal|"\n  The %s missed "
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	dropsomething(monst) 	Function to create an object when a monster dies  *		int monst;  *  *	Function to create an object near the player when certain monsters are killed  *	Enter with the monster number  *	Returns nothing of value.  */
end_comment

begin_macro
name|dropsomething
argument_list|(
argument|monst
argument_list|)
end_macro

begin_decl_stmt
name|int
name|monst
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|monst
condition|)
block|{
case|case
name|ORC
case|:
case|case
name|NYMPH
case|:
case|case
name|ELF
case|:
case|case
name|TROGLODYTE
case|:
case|case
name|TROLL
case|:
case|case
name|ROTHE
case|:
case|case
name|VIOLETFUNGI
case|:
case|case
name|PLATINUMDRAGON
case|:
case|case
name|GNOMEKING
case|:
case|case
name|REDDRAGON
case|:
name|something
argument_list|(
name|level
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEPRECHAUN
case|:
if|if
condition|(
name|rnd
argument_list|(
literal|101
argument_list|)
operator|>=
literal|75
condition|)
name|creategem
argument_list|()
expr_stmt|;
if|if
condition|(
name|rnd
argument_list|(
literal|5
argument_list|)
operator|==
literal|1
condition|)
name|dropsomething
argument_list|(
name|LEPRECHAUN
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  *	dropgold(amount) 	Function to drop some gold around player  *		int amount;  *  *	Enter with the number of gold pieces to drop  *	Returns nothing of value.  */
end_comment

begin_macro
name|dropgold
argument_list|(
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|amount
operator|>
literal|250
condition|)
name|createitem
argument_list|(
name|OMAXGOLD
argument_list|,
name|amount
operator|/
literal|100
argument_list|)
expr_stmt|;
else|else
name|createitem
argument_list|(
name|OGOLDPILE
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	something(level) 	Function to create a random item around player  *		int level;  *  *	Function to create an item from a designed probability around player  *	Enter with the cave level on which something is to be dropped  *	Returns nothing of value.  */
end_comment

begin_macro
name|something
argument_list|(
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|MAXLEVEL
operator|+
name|MAXVLEVEL
condition|)
return|return;
comment|/* correct level? */
if|if
condition|(
name|rnd
argument_list|(
literal|101
argument_list|)
operator|<
literal|8
condition|)
name|something
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|/* possibly more than one item */
name|j
operator|=
name|newobject
argument_list|(
name|level
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|createitem
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	newobject(lev,i) 	Routine to return a randomly selected new object  *		int lev,*i;  *  *	Routine to return a randomly selected object to be created  *	Returns the object number created, and sets *i for its argument  *	Enter with the cave level and a pointer to the items arg  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|nobjtab
index|[]
init|=
block|{
literal|0
block|,
name|OSCROLL
block|,
name|OSCROLL
block|,
name|OSCROLL
block|,
name|OSCROLL
block|,
name|OPOTION
block|,
name|OPOTION
block|,
name|OPOTION
block|,
name|OPOTION
block|,
name|OGOLDPILE
block|,
name|OGOLDPILE
block|,
name|OGOLDPILE
block|,
name|OGOLDPILE
block|,
name|OBOOK
block|,
name|OBOOK
block|,
name|OBOOK
block|,
name|OBOOK
block|,
name|ODAGGER
block|,
name|ODAGGER
block|,
name|ODAGGER
block|,
name|OLEATHER
block|,
name|OLEATHER
block|,
name|OLEATHER
block|,
name|OREGENRING
block|,
name|OPROTRING
block|,
name|OENERGYRING
block|,
name|ODEXRING
block|,
name|OSTRRING
block|,
name|OSPEAR
block|,
name|OBELT
block|,
name|ORING
block|,
name|OSTUDLEATHER
block|,
name|OSHIELD
block|,
name|OFLAIL
block|,
name|OCHAIN
block|,
name|O2SWORD
block|,
name|OPLATE
block|,
name|OLONGSWORD
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|newobject
argument_list|(
argument|lev
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lev
decl_stmt|,
modifier|*
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tmp
init|=
literal|32
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|MAXLEVEL
operator|+
name|MAXVLEVEL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* correct level? */
if|if
condition|(
name|lev
operator|>
literal|6
condition|)
name|tmp
operator|=
literal|37
expr_stmt|;
elseif|else
if|if
condition|(
name|lev
operator|>
literal|4
condition|)
name|tmp
operator|=
literal|35
expr_stmt|;
name|j
operator|=
name|nobjtab
index|[
name|tmp
operator|=
name|rnd
argument_list|(
name|tmp
argument_list|)
index|]
expr_stmt|;
comment|/* the object type */
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
operator|*
name|i
operator|=
name|newscroll
argument_list|()
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
operator|*
name|i
operator|=
name|newpotion
argument_list|()
expr_stmt|;
break|break;
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
operator|*
name|i
operator|=
name|rnd
argument_list|(
operator|(
name|lev
operator|+
literal|1
operator|)
operator|*
literal|10
argument_list|)
operator|+
name|lev
operator|*
literal|10
operator|+
literal|10
expr_stmt|;
break|break;
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
case|case
literal|16
case|:
operator|*
name|i
operator|=
name|lev
expr_stmt|;
break|break;
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
if|if
condition|(
operator|!
operator|(
operator|*
name|i
operator|=
name|newdagger
argument_list|()
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|20
case|:
case|case
literal|21
case|:
case|case
literal|22
case|:
if|if
condition|(
operator|!
operator|(
operator|*
name|i
operator|=
name|newleather
argument_list|()
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|23
case|:
case|case
literal|32
case|:
case|case
literal|35
case|:
operator|*
name|i
operator|=
name|rund
argument_list|(
name|lev
operator|/
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|26
case|:
operator|*
name|i
operator|=
name|rnd
argument_list|(
name|lev
operator|/
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|25
case|:
operator|*
name|i
operator|=
name|rund
argument_list|(
name|lev
operator|/
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|27
case|:
operator|*
name|i
operator|=
name|rnd
argument_list|(
name|lev
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
case|case
literal|33
case|:
operator|*
name|i
operator|=
name|rund
argument_list|(
name|lev
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|28
case|:
operator|*
name|i
operator|=
name|rund
argument_list|(
name|lev
operator|/
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|29
case|:
case|case
literal|31
case|:
operator|*
name|i
operator|=
name|rund
argument_list|(
name|lev
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|34
case|:
operator|*
name|i
operator|=
name|newchain
argument_list|()
expr_stmt|;
break|break;
case|case
literal|36
case|:
operator|*
name|i
operator|=
name|newplate
argument_list|()
expr_stmt|;
break|break;
case|case
literal|37
case|:
operator|*
name|i
operator|=
name|newsword
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  spattack(atckno,xx,yy) 	Function to process special attacks from monsters  *  	int atckno,xx,yy;  *  *	Enter with the special attack number, and the coordinates (xx,yy)  *		of the monster that is special attacking  *	Returns 1 if must do a show1cell(xx,yy) upon return, 0 otherwise  *  * atckno   monster     effect  * ---------------------------------------------------  *	0	none  *	1	rust monster	eat armor  *	2	hell hound		breathe light fire  *	3	dragon			breathe fire  *	4	giant centipede	weakening sing  *	5	white dragon	cold breath  *	6	wraith			drain level  *	7	waterlord		water gusher  *	8	leprechaun		steal gold  *	9	disenchantress	disenchant weapon or armor  *	10	ice lizard		hits with barbed tail  *	11	umber hulk		confusion  *	12	spirit naga		cast spells	taken from special attacks  *	13	platinum dragon	psionics  *	14	nymph			steal objects  *	15	bugbear			bite  *	16	osequip			bite  *  *	char rustarm[ARMORTYPES][2];  *	special array for maximum rust damage to armor from rustmonster  *	format is: { armor type , minimum attribute  */
end_comment

begin_define
define|#
directive|define
name|ARMORTYPES
value|6
end_define

begin_decl_stmt
specifier|static
name|char
name|rustarm
index|[
name|ARMORTYPES
index|]
index|[
literal|2
index|]
init|=
block|{
name|OSTUDLEATHER
block|,
operator|-
literal|2
block|,
name|ORING
block|,
operator|-
literal|4
block|,
name|OCHAIN
block|,
operator|-
literal|5
block|,
name|OSPLINT
block|,
operator|-
literal|6
block|,
name|OPLATE
block|,
operator|-
literal|8
block|,
name|OPLATEARMOR
block|,
operator|-
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|spsel
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|8
block|,
literal|9
block|,
literal|11
block|,
literal|13
block|,
literal|14
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|spattack
argument_list|(
argument|x
argument_list|,
argument|xx
argument_list|,
argument|yy
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|xx
decl_stmt|,
name|yy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
name|char
modifier|*
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
index|[
name|CANCELLATION
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vxy
argument_list|(
operator|&
name|xx
argument_list|,
operator|&
name|yy
argument_list|)
expr_stmt|;
comment|/* verify x& y coordinates */
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|1
case|:
comment|/* rust your armor, j=1 when rusting has occurred */
name|m
operator|=
name|k
operator|=
name|c
index|[
name|WEAR
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|c
index|[
name|SHIELD
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|--
name|ivenarg
index|[
name|i
index|]
operator|<
operator|-
literal|1
condition|)
name|ivenarg
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|j
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
name|k
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|m
operator|=
name|iven
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARMORTYPES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m
operator|==
name|rustarm
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
comment|/* find his armor in table */
block|{
if|if
condition|(
operator|--
name|ivenarg
index|[
name|k
index|]
operator|<
name|rustarm
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
name|ivenarg
index|[
name|k
index|]
operator|=
name|rustarm
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
else|else
name|j
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
comment|/* if rusting did not occur */
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|OLEATHER
case|:
name|p
operator|=
literal|"\nThe %s hit you -- Your lucky you have leather on"
expr_stmt|;
break|break;
case|case
name|OSSPLATE
case|:
name|p
operator|=
literal|"\nThe %s hit you -- Your fortunate to have stainless steel armor!"
expr_stmt|;
break|break;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
name|p
operator|=
literal|"\nThe %s hit you -- your armor feels weaker"
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|i
operator|=
name|rnd
argument_list|(
literal|15
argument_list|)
operator|+
literal|8
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
name|spout
label|:
name|p
operator|=
literal|"\nThe %s breathes fire at you!"
expr_stmt|;
if|if
condition|(
name|c
index|[
name|FIRERESISTANCE
index|]
condition|)
name|p
operator|=
literal|"\nThe %s's flame doesn't phase you!"
expr_stmt|;
else|else
name|spout2
label|:
if|if
condition|(
name|p
condition|)
block|{
name|lprintf
argument_list|(
name|p
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
name|checkloss
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|3
case|:
name|i
operator|=
name|rnd
argument_list|(
literal|20
argument_list|)
operator|+
literal|25
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
goto|goto
name|spout
goto|;
case|case
literal|4
case|:
if|if
condition|(
name|c
index|[
name|STRENGTH
index|]
operator|>
literal|3
condition|)
block|{
name|p
operator|=
literal|"\nThe %s stung you!  You feel weaker"
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
operator|--
name|c
index|[
name|STRENGTH
index|]
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|"\nThe %s stung you!"
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|p
operator|=
literal|"\nThe %s blasts you with his cold breath"
expr_stmt|;
name|i
operator|=
name|rnd
argument_list|(
literal|15
argument_list|)
operator|+
literal|18
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
goto|goto
name|spout2
goto|;
case|case
literal|6
case|:
name|lprintf
argument_list|(
literal|"\nThe %s drains you of your life energy!"
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|loselevel
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|7
case|:
name|p
operator|=
literal|"\nThe %s got you with a gusher!"
expr_stmt|;
name|i
operator|=
name|rnd
argument_list|(
literal|15
argument_list|)
operator|+
literal|25
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
goto|goto
name|spout2
goto|;
case|case
literal|8
case|:
if|if
condition|(
name|c
index|[
name|NOTHEFT
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* he has a device of no theft */
if|if
condition|(
name|c
index|[
name|GOLD
index|]
condition|)
block|{
name|p
operator|=
literal|"\nThe %s hit you -- Your purse feels lighter"
expr_stmt|;
if|if
condition|(
name|c
index|[
name|GOLD
index|]
operator|>
literal|32767
condition|)
name|c
index|[
name|GOLD
index|]
operator|>>=
literal|1
expr_stmt|;
else|else
name|c
index|[
name|GOLD
index|]
operator|-=
name|rnd
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|1
operator|+
operator|(
name|c
index|[
name|GOLD
index|]
operator|>>
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
index|[
name|GOLD
index|]
operator|<
literal|0
condition|)
name|c
index|[
name|GOLD
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|"\nThe %s couldn't find any gold to steal"
expr_stmt|;
name|lprintf
argument_list|(
name|p
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|disappear
argument_list|(
name|xx
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|bottomgold
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|9
case|:
for|for
control|(
name|j
operator|=
literal|50
init|;
condition|;
control|)
comment|/* disenchant */
block|{
name|i
operator|=
name|rund
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|m
operator|=
name|iven
index|[
name|i
index|]
expr_stmt|;
comment|/* randomly select item */
if|if
condition|(
name|m
operator|>
literal|0
operator|&&
name|ivenarg
index|[
name|i
index|]
operator|>
literal|0
operator|&&
name|m
operator|!=
name|OSCROLL
operator|&&
name|m
operator|!=
name|OPOTION
condition|)
block|{
if|if
condition|(
operator|(
name|ivenarg
index|[
name|i
index|]
operator|-=
literal|3
operator|)
operator|<
literal|0
condition|)
name|ivenarg
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nThe %s hits you -- you feel a sense of loss"
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|srcount
operator|=
literal|0
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|show3
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|--
name|j
operator|<=
literal|0
condition|)
block|{
name|p
operator|=
literal|"\nThe %s nearly misses"
expr_stmt|;
break|break;
block|}
break|break;
block|}
break|break;
case|case
literal|10
case|:
name|p
operator|=
literal|"\nThe %s hit you with his barbed tail"
expr_stmt|;
name|i
operator|=
name|rnd
argument_list|(
literal|25
argument_list|)
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
goto|goto
name|spout2
goto|;
case|case
literal|11
case|:
name|p
operator|=
literal|"\nThe %s has confused you"
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|c
index|[
name|CONFUSE
index|]
operator|+=
literal|10
operator|+
name|rnd
argument_list|(
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/*	performs any number of other special attacks	*/
return|return
operator|(
name|spattack
argument_list|(
name|spsel
index|[
name|rund
argument_list|(
literal|10
argument_list|)
index|]
argument_list|,
name|xx
argument_list|,
name|yy
argument_list|)
operator|)
return|;
case|case
literal|13
case|:
name|p
operator|=
literal|"\nThe %s flattens you with his psionics!"
expr_stmt|;
name|i
operator|=
name|rnd
argument_list|(
literal|15
argument_list|)
operator|+
literal|30
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
goto|goto
name|spout2
goto|;
case|case
literal|14
case|:
if|if
condition|(
name|c
index|[
name|NOTHEFT
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* he has device of no theft */
if|if
condition|(
name|emptyhanded
argument_list|()
operator|==
literal|1
condition|)
block|{
name|p
operator|=
literal|"\nThe %s couldn't find anything to steal"
expr_stmt|;
break|break;
block|}
name|lprintf
argument_list|(
literal|"\nThe %s picks your pocket and takes:"
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
if|if
condition|(
name|stealsomething
argument_list|()
operator|==
literal|0
condition|)
name|lprcat
argument_list|(
literal|"  nothing"
argument_list|)
expr_stmt|;
name|disappear
argument_list|(
name|xx
argument_list|,
name|yy
argument_list|)
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|15
case|:
name|i
operator|=
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
literal|5
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
name|spout3
label|:
name|p
operator|=
literal|"\nThe %s bit you!"
expr_stmt|;
goto|goto
name|spout2
goto|;
case|case
literal|16
case|:
name|i
operator|=
name|rnd
argument_list|(
literal|15
argument_list|)
operator|+
literal|10
operator|-
name|c
index|[
name|AC
index|]
expr_stmt|;
goto|goto
name|spout3
goto|;
block|}
empty_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|lprintf
argument_list|(
name|p
argument_list|,
name|lastmonst
argument_list|)
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	checkloss(x) 	Routine to subtract hp from user and flag bottomline display  *		int x;  *  *	Routine to subtract hitpoints from the user and flag the bottomline display  *	Enter with the number of hit points to lose  *	Note: if x> c[HP] this routine could kill the player!  */
end_comment

begin_macro
name|checkloss
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|losehp
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bottomhp
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	annihilate() 	Routine to annihilate all monsters around player (playerx,playery)  *  *	Gives player experience, but no dropped objects  *	Returns the experience gained from all monsters killed  */
end_comment

begin_macro
name|annihilate
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|k
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|i
operator|=
name|playerx
operator|-
literal|1
init|;
name|i
operator|<=
name|playerx
operator|+
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|playery
operator|-
literal|1
init|;
name|j
operator|<=
name|playery
operator|+
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|vxy
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
condition|)
comment|/* if not out of bounds */
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|=
operator|&
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
condition|)
comment|/* if a monster there */
if|if
condition|(
operator|*
name|p
operator|<
name|DEMONLORD
operator|+
literal|2
condition|)
block|{
name|k
operator|+=
name|monster
index|[
operator|*
name|p
index|]
operator|.
name|experience
expr_stmt|;
operator|*
name|p
operator|=
name|know
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lprintf
argument_list|(
literal|"\nThe %s barely escapes being annihilated!"
argument_list|,
name|monster
index|[
operator|*
name|p
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|hitp
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|hitp
index|[
name|i
index|]
index|[
name|j
index|]
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* lose half hit points*/
block|}
block|}
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nYou hear loud screams of agony!"
argument_list|)
expr_stmt|;
name|raiseexperience
argument_list|(
operator|(
name|long
operator|)
name|k
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	newsphere(x,y,dir,lifetime)  Function to create a new sphere of annihilation  *		int x,y,dir,lifetime;  *  *	Enter with the coordinates of the sphere in x,y  *	  the direction (0-8 diroffx format) in dir, and the lifespan of the  *	  sphere in lifetime (in turns)  *	Returns the number of spheres currently in existence  */
end_comment

begin_macro
name|newsphere
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|dir
argument_list|,
argument|life
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|dir
decl_stmt|,
name|life
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|m
decl_stmt|;
name|struct
name|sphere
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|sp
operator|=
operator|(
expr|struct
name|sphere
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sphere
argument_list|)
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|c
index|[
name|SPHCAST
index|]
operator|)
return|;
comment|/* can't malloc, therefore failure */
if|if
condition|(
name|dir
operator|>=
literal|9
condition|)
name|dir
operator|=
literal|0
expr_stmt|;
comment|/* no movement if direction not found */
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|vxy
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* don't go out of bounds */
else|else
block|{
if|if
condition|(
name|x
operator|<
literal|1
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|MAXX
operator|-
literal|1
condition|)
name|x
operator|=
name|MAXX
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|1
condition|)
name|y
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|MAXY
operator|-
literal|1
condition|)
name|y
operator|=
name|MAXY
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|)
operator|>=
name|DEMONLORD
operator|+
literal|4
condition|)
comment|/* demons dispel spheres */
block|{
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|1
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* show the demon (ha ha) */
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nThe %s dispels the sphere!"
argument_list|,
name|monster
index|[
name|m
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|rmsphere
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* remove any spheres that are here */
return|return
operator|(
name|c
index|[
name|SPHCAST
index|]
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|==
name|DISENCHANTRESS
condition|)
comment|/* disenchantress cancels spheres */
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nThe %s causes cancellation of the sphere!"
argument_list|,
name|monster
index|[
name|m
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|boom
label|:
name|sphboom
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* blow up stuff around sphere */
name|rmsphere
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* remove any spheres that are here */
return|return
operator|(
name|c
index|[
name|SPHCAST
index|]
operator|)
return|;
block|}
if|if
condition|(
name|c
index|[
name|CANCELLATION
index|]
condition|)
comment|/* cancellation cancels spheres */
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nAs the cancellation takes effect, you hear a great earth shaking blast!"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
goto|goto
name|boom
goto|;
block|}
if|if
condition|(
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|==
name|OANNIHILATION
condition|)
comment|/* collision of spheres detonates spheres */
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nTwo spheres of annihilation collide! You hear a great earth shaking blast!"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|rmsphere
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
goto|goto
name|boom
goto|;
block|}
if|if
condition|(
name|playerx
operator|==
name|x
operator|&&
name|playery
operator|==
name|y
condition|)
comment|/* collision of sphere and player! */
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou have been enveloped by the zone of nothingness!\n"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|rmsphere
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* remove any spheres that are here */
name|nap
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|died
argument_list|(
literal|258
argument_list|)
expr_stmt|;
block|}
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|OANNIHILATION
expr_stmt|;
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|1
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* show the new sphere */
name|sp
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|sp
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|sp
operator|->
name|lev
operator|=
name|level
expr_stmt|;
name|sp
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|sp
operator|->
name|lifetime
operator|=
name|life
expr_stmt|;
name|sp
operator|->
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spheres
operator|==
literal|0
condition|)
name|spheres
operator|=
name|sp
expr_stmt|;
comment|/* if first node in the sphere list */
else|else
comment|/* add sphere to beginning of linked list */
block|{
name|sp
operator|->
name|p
operator|=
name|spheres
expr_stmt|;
name|spheres
operator|=
name|sp
expr_stmt|;
block|}
return|return
operator|(
operator|++
name|c
index|[
name|SPHCAST
index|]
operator|)
return|;
comment|/* one more sphere in the world */
block|}
end_block

begin_comment
comment|/*  *	rmsphere(x,y)		Function to delete a sphere of annihilation from list  *		int x,y;  *  *	Enter with the coordinates of the sphere (on current level)  *	Returns the number of spheres currently in existence  */
end_comment

begin_macro
name|rmsphere
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sphere
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|spheres
init|;
name|sp
condition|;
name|sp2
operator|=
name|sp
operator|,
name|sp
operator|=
name|sp
operator|->
name|p
control|)
if|if
condition|(
name|level
operator|==
name|sp
operator|->
name|lev
condition|)
comment|/* is sphere on this level? */
if|if
condition|(
operator|(
name|x
operator|==
name|sp
operator|->
name|x
operator|)
operator|&&
operator|(
name|y
operator|==
name|sp
operator|->
name|y
operator|)
condition|)
comment|/* locate sphere at this location */
block|{
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
name|mitem
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|0
expr_stmt|;
name|know
index|[
name|x
index|]
index|[
name|y
index|]
operator|=
literal|1
expr_stmt|;
name|show1cell
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* show the now missing sphere */
operator|--
name|c
index|[
name|SPHCAST
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|spheres
condition|)
block|{
name|sp2
operator|=
name|sp
expr_stmt|;
name|spheres
operator|=
name|sp
operator|->
name|p
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp2
operator|->
name|p
operator|=
name|sp
operator|->
name|p
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|c
index|[
name|SPHCAST
index|]
operator|)
return|;
comment|/* return number of spheres in the world */
block|}
end_block

begin_comment
comment|/*  *	sphboom(x,y)	Function to perform the effects of a sphere detonation  *		int x,y;  *  *	Enter with the coordinates of the blast, Returns no value  */
end_comment

begin_macro
name|sphboom
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|c
index|[
name|HOLDMONST
index|]
condition|)
name|c
index|[
name|HOLDMONST
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
index|[
name|CANCELLATION
index|]
condition|)
name|c
index|[
name|CANCELLATION
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|x
operator|-
literal|2
argument_list|)
init|;
name|j
operator|<
name|min
argument_list|(
name|x
operator|+
literal|3
argument_list|,
name|MAXX
operator|-
literal|1
argument_list|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|y
operator|-
literal|2
argument_list|)
init|;
name|i
operator|<
name|min
argument_list|(
name|y
operator|+
literal|3
argument_list|,
name|MAXY
operator|-
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|item
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|mitem
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|show1cell
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|playerx
operator|==
name|j
operator|&&
name|playery
operator|==
name|i
condition|)
block|{
name|cursors
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou were too close to the sphere!"
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|died
argument_list|(
literal|283
argument_list|)
expr_stmt|;
comment|/* player killed in explosion */
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	genmonst()		Function to ask for monster and genocide from game  *  *	This is done by setting a flag in the monster[] structure  */
end_comment

begin_macro
name|genmonst
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nGenocide what monster? "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|!
name|isalpha
argument_list|(
name|i
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|' '
operator|)
condition|;
name|i
operator|=
name|getchar
argument_list|()
control|)
empty_stmt|;
name|lprc
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXMONST
condition|;
name|j
operator|++
control|)
comment|/* search for the monster type */
if|if
condition|(
name|monstnamelist
index|[
name|j
index|]
operator|==
name|i
condition|)
comment|/* have we found it? */
block|{
name|monster
index|[
name|j
index|]
operator|.
name|genocided
operator|=
literal|1
expr_stmt|;
comment|/* genocided from game */
name|lprintf
argument_list|(
literal|"  There will be no more %s's"
argument_list|,
name|monster
index|[
name|j
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* now wipe out monsters on this level */
name|newcavelevel
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|draws
argument_list|(
literal|0
argument_list|,
name|MAXX
argument_list|,
literal|0
argument_list|,
name|MAXY
argument_list|)
expr_stmt|;
name|bot_linex
argument_list|()
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
literal|"  You sense failure!"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

