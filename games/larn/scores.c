begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* scores.c			 Larn is copyrighted 1986 by Noah Morgan.  *  *	Functions in this file are:  *  *	readboard() 	Function to read in the scoreboard into a static buffer  *	writeboard()	Function to write the scoreboard from readboard()'s buffer  *	makeboard() 	Function to create a new scoreboard (wipe out old one)  *	hashewon()	 Function to return 1 if player has won a game before, else 0  *	long paytaxes(x)	 Function to pay taxes if any are due  *	winshou()		Subroutine to print out the winning scoreboard  *	shou(x)			Subroutine to print out the non-winners scoreboard  *	showscores()		Function to show the scoreboard on the terminal  *	showallscores()	Function to show scores and the iven lists that go with them  *	sortboard()		Function to sort the scoreboard  *	newscore(score, whoo, whyded, winner) 	Function to add entry to scoreboard  *	new1sub(score,i,whoo,taxes) 		  Subroutine to put player into a  *	new2sub(score,i,whoo,whyded)	 	  Subroutine to put player into a  *	died(x) 	Subroutine to record who played larn, and what the score was  *	diedsub(x) Subroutine to print out a line showing player when he is killed  *	diedlog() 	Subroutine to read a log file and print it out in ascii format  *	getplid(name)		Function to get players id # from id file  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_struct
struct|struct
name|scofmt
comment|/*	This is the structure for the scoreboard 		*/
block|{
name|long
name|score
decl_stmt|;
comment|/* the score of the player 							*/
name|long
name|suid
decl_stmt|;
comment|/* the user id number of the player 				*/
name|short
name|what
decl_stmt|;
comment|/* the number of the monster that killed player 	*/
name|short
name|level
decl_stmt|;
comment|/* the level player was on when he died 			*/
name|short
name|hardlev
decl_stmt|;
comment|/* the level of difficulty player played at 		*/
name|short
name|order
decl_stmt|;
comment|/* the relative ordering place of this entry 		*/
name|char
name|who
index|[
literal|40
index|]
decl_stmt|;
comment|/* the name of the character 						*/
name|char
name|sciv
index|[
literal|26
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|/* this is the inventory list of the character 		*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wscofmt
comment|/* This is the structure for the winning scoreboard */
block|{
name|long
name|score
decl_stmt|;
comment|/* the score of the player 							*/
name|long
name|timeused
decl_stmt|;
comment|/* the time used in mobuls to win the game 			*/
name|long
name|taxes
decl_stmt|;
comment|/* taxes he owes to LRS 							*/
name|long
name|suid
decl_stmt|;
comment|/* the user id number of the player 				*/
name|short
name|hardlev
decl_stmt|;
comment|/* the level of difficulty player played at 		*/
name|short
name|order
decl_stmt|;
comment|/* the relative ordering place of this entry 		*/
name|char
name|who
index|[
literal|40
index|]
decl_stmt|;
comment|/* the name of the character 						*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|log_fmt
comment|/* 102 bytes struct for the log file 				*/
block|{
name|long
name|score
decl_stmt|;
comment|/* the players score 								*/
name|long
name|diedtime
decl_stmt|;
comment|/* time when game was over 							*/
name|short
name|cavelev
decl_stmt|;
comment|/* level in caves 									*/
name|short
name|diff
decl_stmt|;
comment|/* difficulty player played at 						*/
ifdef|#
directive|ifdef
name|EXTRA
name|long
name|elapsedtime
decl_stmt|;
comment|/* real time of game in seconds 					*/
name|long
name|bytout
decl_stmt|;
comment|/* bytes input and output 							*/
name|long
name|bytin
decl_stmt|;
name|long
name|moves
decl_stmt|;
comment|/* number of moves made by player 					*/
name|short
name|ac
decl_stmt|;
comment|/* armor class of player 							*/
name|short
name|hp
decl_stmt|,
name|hpmax
decl_stmt|;
comment|/* players hitpoints 								*/
name|short
name|cputime
decl_stmt|;
comment|/* cpu time needed in seconds 						*/
name|short
name|killed
decl_stmt|,
name|spused
decl_stmt|;
comment|/* monsters killed and spells cast 					*/
name|short
name|usage
decl_stmt|;
comment|/* usage of the cpu in % 							*/
name|short
name|lev
decl_stmt|;
comment|/* player level 									*/
endif|#
directive|endif
name|char
name|who
index|[
literal|12
index|]
decl_stmt|;
comment|/* player name 										*/
name|char
name|what
index|[
literal|46
index|]
decl_stmt|;
comment|/* what happened to player 							*/
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|scofmt
name|sco
index|[
name|SCORESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the structure for the scoreboard  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|wscofmt
name|winr
index|[
name|SCORESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* struct for the winning scoreboard */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|log_fmt
name|logg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* structure for the log file 		 */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|whydead
index|[]
init|=
block|{
literal|"quit"
block|,
literal|"suspended"
block|,
literal|"self - annihilated"
block|,
literal|"shot by an arrow"
block|,
literal|"hit by a dart"
block|,
literal|"fell into a pit"
block|,
literal|"fell into a bottomless pit"
block|,
literal|"a winner"
block|,
literal|"trapped in solid rock"
block|,
literal|"killed by a missing save file"
block|,
literal|"killed by an old save file"
block|,
literal|"caught by the greedy cheater checker trap"
block|,
literal|"killed by a protected save file"
block|,
literal|"killed his family and committed suicide"
block|,
literal|"erased by a wayward finger"
block|,
literal|"fell through a bottomless trap door"
block|,
literal|"fell through a trap door"
block|,
literal|"drank some poisonous water"
block|,
literal|"fried by an electric shock"
block|,
literal|"slipped on a volcano shaft"
block|,
literal|"killed by a stupid act of frustration"
block|,
literal|"attacked by a revolting demon"
block|,
literal|"hit by his own magic"
block|,
literal|"demolished by an unseen attacker"
block|,
literal|"fell into the dreadful sleep"
block|,
literal|"killed by an exploding chest"
block|,
comment|/*26*/
literal|"killed by a missing maze data file"
block|,
literal|"annihilated in a sphere"
block|,
literal|"died a post mortem death"
block|,
literal|"wasted by a malloc() failure"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	readboard() 	Function to read in the scoreboard into a static buffer  *  *	returns -1 if unable to read in the scoreboard, returns 0 if all is OK  */
end_comment

begin_macro
name|readboard
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|lopen
argument_list|(
name|scorefile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"Can't read scoreboard\n"
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sco
argument_list|,
sizeof|sizeof
argument_list|(
name|sco
argument_list|)
argument_list|)
expr_stmt|;
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
name|winr
argument_list|,
sizeof|sizeof
argument_list|(
name|winr
argument_list|)
argument_list|)
expr_stmt|;
name|lrclose
argument_list|()
expr_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	writeboard()	Function to write the scoreboard from readboard()'s buffer  *  *	returns -1 if unable to write the scoreboard, returns 0 if all is OK  */
end_comment

begin_macro
name|writeboard
argument_list|()
end_macro

begin_block
block|{
name|set_score_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|lcreat
argument_list|(
name|scorefile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"Can't write scoreboard\n"
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sco
argument_list|,
sizeof|sizeof
argument_list|(
name|sco
argument_list|)
argument_list|)
expr_stmt|;
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|winr
argument_list|,
sizeof|sizeof
argument_list|(
name|winr
argument_list|)
argument_list|)
expr_stmt|;
name|lwclose
argument_list|()
expr_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	makeboard() 		Function to create a new scoreboard (wipe out old one)  *  *	returns -1 if unable to write the scoreboard, returns 0 if all is OK  */
end_comment

begin_macro
name|makeboard
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
block|{
name|winr
index|[
name|i
index|]
operator|.
name|taxes
operator|=
name|winr
index|[
name|i
index|]
operator|.
name|score
operator|=
name|sco
index|[
name|i
index|]
operator|.
name|score
operator|=
literal|0
expr_stmt|;
name|winr
index|[
name|i
index|]
operator|.
name|order
operator|=
name|sco
index|[
name|i
index|]
operator|.
name|order
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|writeboard
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|chmod
argument_list|(
name|scorefile
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	hashewon()	 Function to return 1 if player has won a game before, else 0  *  *	This function also sets c[HARDGAME] to appropriate value -- 0 if not a  *	winner, otherwise the next level of difficulty listed in the winners  *	scoreboard.  This function also sets outstanding_taxes to the value in  *	the winners scoreboard.  */
end_comment

begin_macro
name|hashewon
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|c
index|[
name|HARDGAME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|readboard
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* can't find scoreboard */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
comment|/* search through winners scoreboard */
if|if
condition|(
name|winr
index|[
name|i
index|]
operator|.
name|suid
operator|==
name|userid
condition|)
if|if
condition|(
name|winr
index|[
name|i
index|]
operator|.
name|score
operator|>
literal|0
condition|)
block|{
name|c
index|[
name|HARDGAME
index|]
operator|=
name|winr
index|[
name|i
index|]
operator|.
name|hardlev
operator|+
literal|1
expr_stmt|;
name|outstanding_taxes
operator|=
name|winr
index|[
name|i
index|]
operator|.
name|taxes
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	long paytaxes(x)		 Function to pay taxes if any are due  *  *	Enter with the amount (in gp) to pay on the taxes.  *	Returns amount actually paid.  */
end_comment

begin_function
name|long
name|paytaxes
parameter_list|(
name|x
parameter_list|)
name|long
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|amt
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
if|if
condition|(
name|readboard
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|winr
index|[
name|i
index|]
operator|.
name|suid
operator|==
name|userid
condition|)
comment|/* look for players winning entry */
if|if
condition|(
name|winr
index|[
name|i
index|]
operator|.
name|score
operator|>
literal|0
condition|)
comment|/* search for a winning entry for the player */
block|{
name|amt
operator|=
name|winr
index|[
name|i
index|]
operator|.
name|taxes
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|amt
condition|)
name|amt
operator|=
name|x
expr_stmt|;
comment|/* don't overpay taxes (Ughhhhh) */
name|winr
index|[
name|i
index|]
operator|.
name|taxes
operator|-=
name|amt
expr_stmt|;
name|outstanding_taxes
operator|-=
name|amt
expr_stmt|;
if|if
condition|(
name|writeboard
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|amt
operator|)
return|;
block|}
return|return
operator|(
literal|0L
operator|)
return|;
comment|/* couldn't find user on winning scoreboard */
block|}
end_function

begin_comment
comment|/*  *	winshou()		Subroutine to print out the winning scoreboard  *  *	Returns the number of players on scoreboard that were shown  */
end_comment

begin_macro
name|winshou
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|wscofmt
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
comment|/* is there anyone on the scoreboard? */
if|if
condition|(
name|winr
index|[
name|i
index|]
operator|.
name|score
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
condition|)
block|{
name|lprcat
argument_list|(
literal|"\n  Score    Difficulty   Time Needed   Larn Winners List\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
comment|/* this loop is needed to print out the */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SCORESIZE
condition|;
name|j
operator|++
control|)
comment|/* winners in order */
block|{
name|p
operator|=
operator|&
name|winr
index|[
name|j
index|]
expr_stmt|;
comment|/* pointer to the scoreboard entry */
if|if
condition|(
name|p
operator|->
name|order
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|score
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|lprintf
argument_list|(
literal|"%10d     %2d      %5d Mobuls   %s \n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|score
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|hardlev
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|timeused
argument_list|,
name|p
operator|->
name|who
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
comment|/* return number of people on scoreboard */
block|}
end_block

begin_comment
comment|/*  *	shou(x)			Subroutine to print out the non-winners scoreboard  *		int x;  *  *	Enter with 0 to list the scores, enter with 1 to list inventories too  *	Returns the number of players on scoreboard that were shown  */
end_comment

begin_macro
name|shou
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|k
decl_stmt|;
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
comment|/* is the scoreboard empty? */
if|if
condition|(
name|sco
index|[
name|i
index|]
operator|.
name|score
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
condition|)
block|{
name|lprcat
argument_list|(
literal|"\n   Score   Difficulty   Larn Visitor Log\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
comment|/* be sure to print them out in order */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SCORESIZE
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|sco
index|[
name|j
index|]
operator|.
name|order
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|sco
index|[
name|j
index|]
operator|.
name|score
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|lprintf
argument_list|(
literal|"%10d     %2d       %s "
argument_list|,
operator|(
name|long
operator|)
name|sco
index|[
name|j
index|]
operator|.
name|score
argument_list|,
operator|(
name|long
operator|)
name|sco
index|[
name|j
index|]
operator|.
name|hardlev
argument_list|,
name|sco
index|[
name|j
index|]
operator|.
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|sco
index|[
name|j
index|]
operator|.
name|what
operator|<
literal|256
condition|)
name|lprintf
argument_list|(
literal|"killed by a %s"
argument_list|,
name|monster
index|[
name|sco
index|[
name|j
index|]
operator|.
name|what
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|lprintf
argument_list|(
literal|"%s"
argument_list|,
name|whydead
index|[
name|sco
index|[
name|j
index|]
operator|.
name|what
operator|-
literal|256
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|263
condition|)
name|lprintf
argument_list|(
literal|" on %s"
argument_list|,
name|levelname
index|[
name|sco
index|[
name|j
index|]
operator|.
name|level
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|26
condition|;
name|n
operator|++
control|)
block|{
name|iven
index|[
name|n
index|]
operator|=
name|sco
index|[
name|j
index|]
operator|.
name|sciv
index|[
name|n
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ivenarg
index|[
name|n
index|]
operator|=
name|sco
index|[
name|j
index|]
operator|.
name|sciv
index|[
name|n
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|99
condition|;
name|k
operator|++
control|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|26
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|k
operator|==
name|iven
index|[
name|n
index|]
condition|)
block|{
name|srcount
operator|=
literal|0
expr_stmt|;
name|show3
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|lprcat
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|SCORESIZE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
comment|/* return the number of players just shown */
block|}
end_block

begin_comment
comment|/*  *	showscores()		Function to show the scoreboard on the terminal  *  *	Returns nothing of value  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|esb
index|[]
init|=
literal|"The scoreboard is empty.\n"
decl_stmt|;
end_decl_stmt

begin_macro
name|showscores
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readboard
argument_list|()
operator|<
literal|0
condition|)
return|return;
name|i
operator|=
name|winshou
argument_list|()
expr_stmt|;
name|j
operator|=
name|shou
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|==
literal|0
condition|)
name|lprcat
argument_list|(
name|esb
argument_list|)
expr_stmt|;
else|else
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	showallscores()	Function to show scores and the iven lists that go with them  *  *	Returns nothing of value  */
end_comment

begin_macro
name|showallscores
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readboard
argument_list|()
operator|<
literal|0
condition|)
return|return;
name|c
index|[
name|WEAR
index|]
operator|=
name|c
index|[
name|WIELD
index|]
operator|=
name|c
index|[
name|SHIELD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not wielding or wearing anything */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPOTION
condition|;
name|i
operator|++
control|)
name|potionname
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSCROLL
condition|;
name|i
operator|++
control|)
name|scrollname
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|i
operator|=
name|winshou
argument_list|()
expr_stmt|;
name|j
operator|=
name|shou
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|==
literal|0
condition|)
name|lprcat
argument_list|(
name|esb
argument_list|)
expr_stmt|;
else|else
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	sortboard()		Function to sort the scoreboard  *  *	Returns 0 if no sorting done, else returns 1  */
end_comment

begin_macro
name|sortboard
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pos
decl_stmt|;
name|long
name|jdat
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
name|sco
index|[
name|i
index|]
operator|.
name|order
operator|=
name|winr
index|[
name|i
index|]
operator|.
name|order
operator|=
operator|-
literal|1
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|SCORESIZE
condition|)
block|{
name|jdat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sco
index|[
name|i
index|]
operator|.
name|order
operator|<
literal|0
operator|)
operator|&&
operator|(
name|sco
index|[
name|i
index|]
operator|.
name|score
operator|>=
name|jdat
operator|)
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
name|jdat
operator|=
name|sco
index|[
name|i
index|]
operator|.
name|score
expr_stmt|;
block|}
name|sco
index|[
name|j
index|]
operator|.
name|order
operator|=
name|pos
operator|++
expr_stmt|;
block|}
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|SCORESIZE
condition|)
block|{
name|jdat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|winr
index|[
name|i
index|]
operator|.
name|order
operator|<
literal|0
operator|)
operator|&&
operator|(
name|winr
index|[
name|i
index|]
operator|.
name|score
operator|>=
name|jdat
operator|)
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
name|jdat
operator|=
name|winr
index|[
name|i
index|]
operator|.
name|score
expr_stmt|;
block|}
name|winr
index|[
name|j
index|]
operator|.
name|order
operator|=
name|pos
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	newscore(score, whoo, whyded, winner) 	Function to add entry to scoreboard  *		int score, winner, whyded;  *		char *whoo;  *  *	Enter with the total score in gp in score,  players name in whoo,  *		died() reason # in whyded, and TRUE/FALSE in winner if a winner  *	ex.		newscore(1000, "player 1", 32, 0);  */
end_comment

begin_macro
name|newscore
argument_list|(
argument|score
argument_list|,
argument|whoo
argument_list|,
argument|whyded
argument_list|,
argument|winner
argument_list|)
end_macro

begin_decl_stmt
name|long
name|score
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|winner
decl_stmt|,
name|whyded
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|whoo
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|taxes
decl_stmt|;
if|if
condition|(
name|readboard
argument_list|()
operator|<
literal|0
condition|)
return|return;
comment|/*	do the scoreboard	*/
comment|/* if a winner then delete all non-winning scores */
if|if
condition|(
name|cheat
condition|)
name|winner
operator|=
literal|0
expr_stmt|;
comment|/* if he cheated, don't let him win */
if|if
condition|(
name|winner
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sco
index|[
name|i
index|]
operator|.
name|suid
operator|==
name|userid
condition|)
name|sco
index|[
name|i
index|]
operator|.
name|score
operator|=
literal|0
expr_stmt|;
name|taxes
operator|=
name|score
operator|*
name|TAXRATE
expr_stmt|;
name|score
operator|+=
literal|100000
operator|*
name|c
index|[
name|HARDGAME
index|]
expr_stmt|;
comment|/* bonus for winning */
comment|/* if he has a slot on the winning scoreboard update it if greater score */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|winr
index|[
name|i
index|]
operator|.
name|suid
operator|==
name|userid
condition|)
block|{
name|new1sub
argument_list|(
name|score
argument_list|,
name|i
argument_list|,
name|whoo
argument_list|,
name|taxes
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* he had no entry. look for last entry and see if he has a greater score */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|winr
index|[
name|i
index|]
operator|.
name|order
operator|==
name|SCORESIZE
operator|-
literal|1
condition|)
block|{
name|new1sub
argument_list|(
name|score
argument_list|,
name|i
argument_list|,
name|whoo
argument_list|,
name|taxes
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|cheat
condition|)
comment|/* for not winning scoreboard */
block|{
comment|/* if he has a slot on the scoreboard update it if greater score */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sco
index|[
name|i
index|]
operator|.
name|suid
operator|==
name|userid
condition|)
block|{
name|new2sub
argument_list|(
name|score
argument_list|,
name|i
argument_list|,
name|whoo
argument_list|,
name|whyded
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* he had no entry. look for last entry and see if he has a greater score */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCORESIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sco
index|[
name|i
index|]
operator|.
name|order
operator|==
name|SCORESIZE
operator|-
literal|1
condition|)
block|{
name|new2sub
argument_list|(
name|score
argument_list|,
name|i
argument_list|,
name|whoo
argument_list|,
name|whyded
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	new1sub(score,i,whoo,taxes) 	  Subroutine to put player into a  *		int score,i,whyded,taxes;		  winning scoreboard entry if his score  *		char *whoo; 					  is high enough  *  *	Enter with the total score in gp in score,  players name in whoo,  *		died() reason # in whyded, and TRUE/FALSE in winner if a winner  *		slot in scoreboard in i, and the tax bill in taxes.  *	Returns nothing of value  */
end_comment

begin_macro
name|new1sub
argument_list|(
argument|score
argument_list|,
argument|i
argument_list|,
argument|whoo
argument_list|,
argument|taxes
argument_list|)
end_macro

begin_decl_stmt
name|long
name|score
decl_stmt|,
name|taxes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|whoo
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|wscofmt
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|winr
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|taxes
operator|+=
name|taxes
expr_stmt|;
if|if
condition|(
operator|(
name|score
operator|>=
name|p
operator|->
name|score
operator|)
operator|||
operator|(
name|c
index|[
name|HARDGAME
index|]
operator|>
name|p
operator|->
name|hardlev
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|p
operator|->
name|who
argument_list|,
name|whoo
argument_list|)
expr_stmt|;
name|p
operator|->
name|score
operator|=
name|score
expr_stmt|;
name|p
operator|->
name|hardlev
operator|=
name|c
index|[
name|HARDGAME
index|]
expr_stmt|;
name|p
operator|->
name|suid
operator|=
name|userid
expr_stmt|;
name|p
operator|->
name|timeused
operator|=
name|gtime
operator|/
literal|100
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	new2sub(score,i,whoo,whyded)	 	  Subroutine to put player into a  *		int score,i,whyded,taxes;		  non-winning scoreboard entry if his  *		char *whoo; 					  score is high enough  *  *	Enter with the total score in gp in score,  players name in whoo,  *		died() reason # in whyded, and slot in scoreboard in i.  *	Returns nothing of value  */
end_comment

begin_macro
name|new2sub
argument_list|(
argument|score
argument_list|,
argument|i
argument_list|,
argument|whoo
argument_list|,
argument|whyded
argument_list|)
end_macro

begin_decl_stmt
name|long
name|score
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|,
name|whyded
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|whoo
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|scofmt
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|sco
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|score
operator|>=
name|p
operator|->
name|score
operator|)
operator|||
operator|(
name|c
index|[
name|HARDGAME
index|]
operator|>
name|p
operator|->
name|hardlev
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|p
operator|->
name|who
argument_list|,
name|whoo
argument_list|)
expr_stmt|;
name|p
operator|->
name|score
operator|=
name|score
expr_stmt|;
name|p
operator|->
name|what
operator|=
name|whyded
expr_stmt|;
name|p
operator|->
name|hardlev
operator|=
name|c
index|[
name|HARDGAME
index|]
expr_stmt|;
name|p
operator|->
name|suid
operator|=
name|userid
expr_stmt|;
name|p
operator|->
name|level
operator|=
name|level
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|26
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|->
name|sciv
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|iven
index|[
name|j
index|]
expr_stmt|;
name|p
operator|->
name|sciv
index|[
name|j
index|]
index|[
literal|1
index|]
operator|=
name|ivenarg
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	died(x) 	Subroutine to record who played larn, and what the score was  *		int x;  *  *	if x< 0 then don't show scores  *	died() never returns! (unless c[LIFEPROT] and a reincarnatable death!)  *  *< 256	killed by the monster number  *		256		quit  *		257		suspended  *		258		self - annihilated  *		259		shot by an arrow  *		260		hit by a dart  *		261		fell into a pit  *		262		fell into a bottomless pit  *		263		a winner  *		264		trapped in solid rock  *		265		killed by a missing save file  *		266		killed by an old save file  *		267		caught by the greedy cheater checker trap  *		268		killed by a protected save file  *		269		killed his family and killed himself  *		270		erased by a wayward finger  *		271		fell through a bottomless trap door  *		272		fell through a trap door  *		273		drank some poisonous water  *		274		fried by an electric shock  *		275		slipped on a volcano shaft  *		276		killed by a stupid act of frustration  *		277		attacked by a revolting demon  *		278		hit by his own magic  *		279		demolished by an unseen attacker  *		280		fell into the dreadful sleep  *		281		killed by an exploding chest  *		282		killed by a missing maze data file  *		283		killed by a sphere of annihilation  *		284		died a post mortem death  *		285		malloc() failure  *		300		quick quit -- don't put on scoreboard  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|scorerror
decl_stmt|;
end_decl_stmt

begin_macro
name|died
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|f
decl_stmt|,
name|win
decl_stmt|;
name|char
name|ch
decl_stmt|,
modifier|*
name|mod
decl_stmt|;
name|long
name|zzz
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|tms
name|cputime
decl_stmt|;
if|if
condition|(
name|c
index|[
name|LIFEPROT
index|]
operator|>
literal|0
condition|)
comment|/* if life protection */
block|{
switch|switch
condition|(
operator|(
name|x
operator|>
literal|0
operator|)
condition|?
name|x
else|:
operator|-
name|x
condition|)
block|{
case|case
literal|256
case|:
case|case
literal|257
case|:
case|case
literal|262
case|:
case|case
literal|263
case|:
case|case
literal|265
case|:
case|case
literal|266
case|:
case|case
literal|267
case|:
case|case
literal|268
case|:
case|case
literal|269
case|:
case|case
literal|271
case|:
case|case
literal|282
case|:
case|case
literal|284
case|:
case|case
literal|285
case|:
case|case
literal|300
case|:
goto|goto
name|invalid
goto|;
comment|/* can't be saved */
block|}
empty_stmt|;
operator|--
name|c
index|[
name|LIFEPROT
index|]
expr_stmt|;
name|c
index|[
name|HP
index|]
operator|=
literal|1
expr_stmt|;
operator|--
name|c
index|[
name|CONSTITUTION
index|]
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou feel wiiieeeeerrrrrd all over! "
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return;
comment|/* only case where died() returns */
block|}
name|invalid
label|:
name|clearvt100
argument_list|()
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ckpflag
condition|)
name|unlink
argument_list|(
name|ckpfile
argument_list|)
expr_stmt|;
comment|/* remove checkpoint file if used */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|f
operator|++
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
comment|/* if we are not to display the scores */
if|if
condition|(
operator|(
name|x
operator|==
literal|300
operator|)
operator|||
operator|(
name|x
operator|==
literal|257
operator|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* for quick exit or saved game */
if|if
condition|(
name|x
operator|==
literal|263
condition|)
name|win
operator|=
literal|1
expr_stmt|;
else|else
name|win
operator|=
literal|0
expr_stmt|;
name|c
index|[
name|GOLD
index|]
operator|+=
name|c
index|[
name|BANKACCOUNT
index|]
expr_stmt|;
name|c
index|[
name|BANKACCOUNT
index|]
operator|=
literal|0
expr_stmt|;
comment|/*	now enter the player at the end of the scoreboard */
name|newscore
argument_list|(
name|c
index|[
name|GOLD
index|]
argument_list|,
name|logname
argument_list|,
name|x
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|diedsub
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* print out the score line */
name|lflush
argument_list|()
expr_stmt|;
name|set_score_output
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|wizard
operator|==
literal|0
operator|)
operator|&&
operator|(
name|c
index|[
name|GOLD
index|]
operator|>
literal|0
operator|)
condition|)
comment|/*	wizards can't score		*/
block|{
ifndef|#
directive|ifndef
name|NOLOG
if|if
condition|(
name|lappend
argument_list|(
name|logfile
argument_list|)
operator|<
literal|0
condition|)
comment|/* append to file */
block|{
if|if
condition|(
name|lcreat
argument_list|(
name|logfile
argument_list|)
operator|<
literal|0
condition|)
comment|/* and can't create new log file */
block|{
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nCan't open record file:  I can't post your score.\n"
argument_list|)
expr_stmt|;
name|sncbr
argument_list|()
expr_stmt|;
name|resetscroll
argument_list|()
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|chmod
argument_list|(
name|logfile
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|logg
operator|.
name|who
argument_list|,
name|loginname
argument_list|)
expr_stmt|;
name|logg
operator|.
name|score
operator|=
name|c
index|[
name|GOLD
index|]
expr_stmt|;
name|logg
operator|.
name|diff
operator|=
name|c
index|[
name|HARDGAME
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|256
condition|)
block|{
name|ch
operator|=
operator|*
name|monster
index|[
name|x
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'a'
operator|||
name|ch
operator|==
literal|'e'
operator|||
name|ch
operator|==
literal|'i'
operator|||
name|ch
operator|==
literal|'o'
operator|||
name|ch
operator|==
literal|'u'
condition|)
name|mod
operator|=
literal|"an"
expr_stmt|;
else|else
name|mod
operator|=
literal|"a"
expr_stmt|;
name|sprintf
argument_list|(
name|logg
operator|.
name|what
argument_list|,
literal|"killed by %s %s"
argument_list|,
name|mod
argument_list|,
name|monster
index|[
name|x
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|logg
operator|.
name|what
argument_list|,
literal|"%s"
argument_list|,
name|whydead
index|[
name|x
operator|-
literal|256
index|]
argument_list|)
expr_stmt|;
name|logg
operator|.
name|cavelev
operator|=
name|level
expr_stmt|;
name|time
argument_list|(
operator|&
name|zzz
argument_list|)
expr_stmt|;
comment|/* get cpu time -- write out score info */
name|logg
operator|.
name|diedtime
operator|=
name|zzz
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA
name|times
argument_list|(
operator|&
name|cputime
argument_list|)
expr_stmt|;
comment|/* get cpu time -- write out score info */
name|logg
operator|.
name|cputime
operator|=
name|i
operator|=
operator|(
name|cputime
operator|.
name|tms_utime
operator|+
name|cputime
operator|.
name|tms_stime
operator|)
operator|/
literal|60
operator|+
name|c
index|[
name|CPUTIME
index|]
expr_stmt|;
name|logg
operator|.
name|lev
operator|=
name|c
index|[
name|LEVEL
index|]
expr_stmt|;
name|logg
operator|.
name|ac
operator|=
name|c
index|[
name|AC
index|]
expr_stmt|;
name|logg
operator|.
name|hpmax
operator|=
name|c
index|[
name|HPMAX
index|]
expr_stmt|;
name|logg
operator|.
name|hp
operator|=
name|c
index|[
name|HP
index|]
expr_stmt|;
name|logg
operator|.
name|elapsedtime
operator|=
operator|(
name|zzz
operator|-
name|initialtime
operator|+
literal|59
operator|)
operator|/
literal|60
expr_stmt|;
name|logg
operator|.
name|usage
operator|=
operator|(
literal|10000
operator|*
name|i
operator|)
operator|/
operator|(
name|zzz
operator|-
name|initialtime
operator|)
expr_stmt|;
name|logg
operator|.
name|bytin
operator|=
name|c
index|[
name|BYTESIN
index|]
expr_stmt|;
name|logg
operator|.
name|bytout
operator|=
name|c
index|[
name|BYTESOUT
index|]
expr_stmt|;
name|logg
operator|.
name|moves
operator|=
name|c
index|[
name|MOVESMADE
index|]
expr_stmt|;
name|logg
operator|.
name|spused
operator|=
name|c
index|[
name|SPELLSCAST
index|]
expr_stmt|;
name|logg
operator|.
name|killed
operator|=
name|c
index|[
name|MONSTKILLED
index|]
expr_stmt|;
endif|#
directive|endif
name|lwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|logg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_fmt
argument_list|)
argument_list|)
expr_stmt|;
name|lwclose
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|NOLOG
comment|/*	now for the scoreboard maintenance -- not for a suspended game 	*/
if|if
condition|(
name|x
operator|!=
literal|257
condition|)
block|{
if|if
condition|(
name|sortboard
argument_list|()
condition|)
name|scorerror
operator|=
name|writeboard
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|x
operator|==
literal|256
operator|)
operator|||
operator|(
name|x
operator|==
literal|257
operator|)
operator|||
operator|(
name|f
operator|!=
literal|0
operator|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scorerror
operator|==
literal|0
condition|)
name|showscores
argument_list|()
expr_stmt|;
comment|/* if we updated the scoreboard */
if|if
condition|(
name|x
operator|==
literal|263
condition|)
name|mailbill
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	diedsub(x) Subroutine to print out the line showing the player when he is killed  *		int x;  */
end_comment

begin_macro
name|diedsub
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|ch
decl_stmt|,
modifier|*
name|mod
decl_stmt|;
name|lprintf
argument_list|(
literal|"Score: %d, Diff: %d,  %s "
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|GOLD
index|]
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|HARDGAME
index|]
argument_list|,
name|logname
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|256
condition|)
block|{
name|ch
operator|=
operator|*
name|monster
index|[
name|x
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'a'
operator|||
name|ch
operator|==
literal|'e'
operator|||
name|ch
operator|==
literal|'i'
operator|||
name|ch
operator|==
literal|'o'
operator|||
name|ch
operator|==
literal|'u'
condition|)
name|mod
operator|=
literal|"an"
expr_stmt|;
else|else
name|mod
operator|=
literal|"a"
expr_stmt|;
name|lprintf
argument_list|(
literal|"killed by %s %s"
argument_list|,
name|mod
argument_list|,
name|monster
index|[
name|x
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|lprintf
argument_list|(
literal|"%s"
argument_list|,
name|whydead
index|[
name|x
operator|-
literal|256
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|263
condition|)
name|lprintf
argument_list|(
literal|" on %s\n"
argument_list|,
name|levelname
index|[
name|level
index|]
argument_list|)
expr_stmt|;
else|else
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	diedlog() 	Subroutine to read a log file and print it out in ascii format  */
end_comment

begin_macro
name|diedlog
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lopen
argument_list|(
name|logfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"Can't locate log file<%s>\n"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"Can't  stat log file<%s>\n"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|n
operator|=
name|stbuf
operator|.
name|st_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|log_fmt
argument_list|)
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
name|lrfill
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|logg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_fmt
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|ctime
argument_list|(
operator|&
name|logg
operator|.
name|diedtime
argument_list|)
expr_stmt|;
name|p
index|[
literal|16
index|]
operator|=
literal|'\n'
expr_stmt|;
name|p
index|[
literal|17
index|]
operator|=
literal|0
expr_stmt|;
name|lprintf
argument_list|(
literal|"Score: %d, Diff: %d,  %s %s on %d at %s"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|score
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|diff
argument_list|)
argument_list|,
name|logg
operator|.
name|who
argument_list|,
name|logg
operator|.
name|what
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|cavelev
argument_list|)
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA
if|if
condition|(
name|logg
operator|.
name|moves
operator|<=
literal|0
condition|)
name|logg
operator|.
name|moves
operator|=
literal|1
expr_stmt|;
name|lprintf
argument_list|(
literal|"  Experience Level: %d,  AC: %d,  HP: %d/%d,  Elapsed Time: %d minutes\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|lev
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|ac
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|hp
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|hpmax
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|elapsedtime
argument_list|)
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"  CPU time used: %d seconds,  Machine usage: %d.%02d%%\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|cputime
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|usage
operator|/
literal|100
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|usage
operator|%
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"  BYTES in: %d, out: %d, moves: %d, deaths: %d, spells cast: %d\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|bytin
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|bytout
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|moves
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|killed
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|spused
argument_list|)
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"  out bytes per move: %d,  time per move: %d ms\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|logg
operator|.
name|bytout
operator|/
name|logg
operator|.
name|moves
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|logg
operator|.
name|cputime
operator|*
literal|1000
operator|)
operator|/
name|logg
operator|.
name|moves
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|lflush
argument_list|()
expr_stmt|;
name|lrclose
argument_list|()
expr_stmt|;
return|return;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|UIDSCORE
end_ifndef

begin_comment
comment|/*  *	getplid(name)		Function to get players id # from id file  *  *	Enter with the name of the players character in name.  *	Returns the id # of the players character, or -1 if failure.  *	This routine will try to find the name in the id file, if its not there,  *	it will try to make a new entry in the file.  Only returns -1 if can't  *	find him in the file, and can't make a new entry in the file.  *	Format of playerids file:  *			Id # in ascii     \n     character name     \n  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|havepid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* playerid # if previously done */
end_comment

begin_macro
name|getplid
argument_list|(
argument|nam
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd7
decl_stmt|,
name|high
init|=
literal|999
decl_stmt|,
name|no
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|havepid
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|havepid
operator|)
return|;
comment|/* already did it */
name|lflush
argument_list|()
expr_stmt|;
comment|/* flush any pending I/O */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s\n"
argument_list|,
name|nam
argument_list|)
expr_stmt|;
comment|/* append a \n to name */
if|if
condition|(
name|lopen
argument_list|(
name|playerids
argument_list|)
operator|<
literal|0
condition|)
comment|/* no file, make it */
block|{
if|if
condition|(
operator|(
name|fd7
operator|=
name|creat
argument_list|(
name|playerids
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* can't make it */
name|close
argument_list|(
name|fd7
argument_list|)
expr_stmt|;
goto|goto
name|addone
goto|;
comment|/* now append new playerid record to file */
block|}
for|for
control|(
init|;
condition|;
control|)
comment|/* now search for the name in the player id file */
block|{
name|p
operator|=
name|lgetl
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
comment|/* EOF? */
name|no
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* the id # */
name|p2
operator|=
name|lgetl
argument_list|()
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
break|break;
comment|/* EOF? */
if|if
condition|(
name|no
operator|>
name|high
condition|)
name|high
operator|=
name|no
expr_stmt|;
comment|/* accumulate highest id # */
if|if
condition|(
name|strcmp
argument_list|(
name|p2
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* we found him */
block|{
return|return
operator|(
name|no
operator|)
return|;
comment|/* his id number */
block|}
block|}
name|lrclose
argument_list|()
expr_stmt|;
comment|/* if we get here, we didn't find him in the file -- put him there */
name|addone
label|:
if|if
condition|(
name|lappend
argument_list|(
name|playerids
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* can't open file for append */
name|lprintf
argument_list|(
literal|"%d\n%s"
argument_list|,
operator|(
name|long
operator|)
operator|++
name|high
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* new id # and name */
name|lwclose
argument_list|()
expr_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* re-open terminal channel */
return|return
operator|(
name|high
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|UIDSCORE
end_endif

end_unit

