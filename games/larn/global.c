begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	global.c 		Larn is copyrighted 1986 by Noah Morgan.  * $FreeBSD$  *  *	raiselevel()		subroutine to raise the player one level  *	loselevel()		subroutine to lower the player by one level  *	raiseexperience(x)	subroutine to increase experience points  *	loseexperience(x)	subroutine to lose experience points  *	losehp(x)			subroutine to remove hit points from the player  *	losemhp(x)			subroutine to remove max # hit points from the player  *	raisehp(x)			subroutine to gain hit points  *	raisemhp(x)			subroutine to gain maximum hit points  *	losespells(x)		subroutine to lose spells  *	losemspells(x)		subroutine to lose maximum spells  *	raisespells(x)		subroutine to gain spells  *	raisemspells(x)		subroutine to gain maximum spells  *	recalc()			function to recalculate the armor class of the player  *	makemonst(lev)		function to return monster number for a randomly selected monster  *	positionplayer()	function to be sure player is not in a wall  *	quit()				subroutine to ask if the player really wants to quit  *  */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|score
index|[]
decl_stmt|,
name|srcount
decl_stmt|,
name|dropflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|playerx
decl_stmt|,
name|playery
decl_stmt|,
name|lastnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|cheat
decl_stmt|,
name|level
decl_stmt|,
name|monstnamelist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|lastmonst
index|[]
decl_stmt|,
modifier|*
name|what
index|[]
decl_stmt|,
modifier|*
name|who
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|winner
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|logname
index|[]
decl_stmt|,
name|monstlevel
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|sciv
index|[
name|SCORESIZE
operator|+
literal|1
index|]
index|[
literal|26
index|]
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|potionname
index|[]
decl_stmt|,
modifier|*
name|scrollname
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	*********** 	RAISE LEVEL 	*********** 	raiselevel()  	subroutine to raise the player one level 	uses the skill[] array to find level boundarys 	uses c[EXPERIENCE]  c[LEVEL]  */
end_comment

begin_macro
name|raiselevel
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|c
index|[
name|LEVEL
index|]
operator|<
name|MAXPLEVEL
condition|)
name|raiseexperience
argument_list|(
call|(
name|long
call|)
argument_list|(
name|skill
index|[
name|c
index|[
name|LEVEL
index|]
index|]
operator|-
name|c
index|[
name|EXPERIENCE
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	*********** 	LOOSE LEVEL 	***********     loselevel()  	subroutine to lower the players character level by one  */
end_comment

begin_macro
name|loselevel
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|c
index|[
name|LEVEL
index|]
operator|>
literal|1
condition|)
name|loseexperience
argument_list|(
call|(
name|long
call|)
argument_list|(
name|c
index|[
name|EXPERIENCE
index|]
operator|-
name|skill
index|[
name|c
index|[
name|LEVEL
index|]
operator|-
literal|1
index|]
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	**************** 	RAISE EXPERIENCE 	**************** 	raiseexperience(x)  	subroutine to increase experience points  */
end_comment

begin_macro
name|raiseexperience
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|long
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|tmp
decl_stmt|;
name|i
operator|=
name|c
index|[
name|LEVEL
index|]
expr_stmt|;
name|c
index|[
name|EXPERIENCE
index|]
operator|+=
name|x
expr_stmt|;
while|while
condition|(
name|c
index|[
name|EXPERIENCE
index|]
operator|>=
name|skill
index|[
name|c
index|[
name|LEVEL
index|]
index|]
operator|&&
operator|(
name|c
index|[
name|LEVEL
index|]
operator|<
name|MAXPLEVEL
operator|)
condition|)
block|{
name|tmp
operator|=
operator|(
name|c
index|[
name|CONSTITUTION
index|]
operator|-
name|c
index|[
name|HARDGAME
index|]
operator|)
operator|>>
literal|1
expr_stmt|;
name|c
index|[
name|LEVEL
index|]
operator|++
expr_stmt|;
name|raisemhp
argument_list|(
call|(
name|int
call|)
argument_list|(
name|rnd
argument_list|(
literal|3
argument_list|)
operator|+
name|rnd
argument_list|(
operator|(
name|tmp
operator|>
literal|0
operator|)
condition|?
name|tmp
else|:
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|raisemspells
argument_list|(
operator|(
name|int
operator|)
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
index|[
name|LEVEL
index|]
operator|<
literal|7
operator|-
name|c
index|[
name|HARDGAME
index|]
condition|)
name|raisemhp
argument_list|(
call|(
name|int
call|)
argument_list|(
name|c
index|[
name|CONSTITUTION
index|]
operator|>>
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
index|[
name|LEVEL
index|]
operator|!=
name|i
condition|)
block|{
name|cursors
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nWelcome to level %d"
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|LEVEL
index|]
argument_list|)
expr_stmt|;
comment|/* if we changed levels	*/
block|}
name|bottomline
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	**************** 	LOOSE EXPERIENCE 	**************** 	loseexperience(x)  	subroutine to lose experience points  */
end_comment

begin_macro
name|loseexperience
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|long
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|tmp
decl_stmt|;
name|i
operator|=
name|c
index|[
name|LEVEL
index|]
expr_stmt|;
name|c
index|[
name|EXPERIENCE
index|]
operator|-=
name|x
expr_stmt|;
if|if
condition|(
name|c
index|[
name|EXPERIENCE
index|]
operator|<
literal|0
condition|)
name|c
index|[
name|EXPERIENCE
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
index|[
name|EXPERIENCE
index|]
operator|<
name|skill
index|[
name|c
index|[
name|LEVEL
index|]
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|--
name|c
index|[
name|LEVEL
index|]
operator|<=
literal|1
condition|)
name|c
index|[
name|LEVEL
index|]
operator|=
literal|1
expr_stmt|;
comment|/*	down one level		*/
name|tmp
operator|=
operator|(
name|c
index|[
name|CONSTITUTION
index|]
operator|-
name|c
index|[
name|HARDGAME
index|]
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* lose hpoints */
name|losemhp
argument_list|(
operator|(
name|int
operator|)
name|rnd
argument_list|(
operator|(
name|tmp
operator|>
literal|0
operator|)
condition|?
name|tmp
else|:
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lose hpoints */
if|if
condition|(
name|c
index|[
name|LEVEL
index|]
operator|<
literal|7
operator|-
name|c
index|[
name|HARDGAME
index|]
condition|)
name|losemhp
argument_list|(
call|(
name|int
call|)
argument_list|(
name|c
index|[
name|CONSTITUTION
index|]
operator|>>
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|losemspells
argument_list|(
operator|(
name|int
operator|)
name|rund
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	lose spells		*/
block|}
if|if
condition|(
name|i
operator|!=
name|c
index|[
name|LEVEL
index|]
condition|)
block|{
name|cursors
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nYou went down to level %d!"
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|LEVEL
index|]
argument_list|)
expr_stmt|;
block|}
name|bottomline
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	******** 	LOOSE HP 	******** 	losehp(x) 	losemhp(x)  	subroutine to remove hit points from the player 	warning -- will kill player if hp goes to zero  */
end_comment

begin_macro
name|losehp
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|c
index|[
name|HP
index|]
operator|-=
name|x
operator|)
operator|<=
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nap
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|died
argument_list|(
name|lastnum
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|losemhp
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|c
index|[
name|HP
index|]
operator|-=
name|x
expr_stmt|;
if|if
condition|(
name|c
index|[
name|HP
index|]
operator|<
literal|1
condition|)
name|c
index|[
name|HP
index|]
operator|=
literal|1
expr_stmt|;
name|c
index|[
name|HPMAX
index|]
operator|-=
name|x
expr_stmt|;
if|if
condition|(
name|c
index|[
name|HPMAX
index|]
operator|<
literal|1
condition|)
name|c
index|[
name|HPMAX
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	******** 	RAISE HP 	******** 	raisehp(x) 	raisemhp(x)  	subroutine to gain maximum hit points  */
end_comment

begin_macro
name|raisehp
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|c
index|[
name|HP
index|]
operator|+=
name|x
operator|)
operator|>
name|c
index|[
name|HPMAX
index|]
condition|)
name|c
index|[
name|HP
index|]
operator|=
name|c
index|[
name|HPMAX
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|raisemhp
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|c
index|[
name|HPMAX
index|]
operator|+=
name|x
expr_stmt|;
name|c
index|[
name|HP
index|]
operator|+=
name|x
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	************ 	RAISE SPELLS 	************ 	raisespells(x) 	raisemspells(x)  	subroutine to gain maximum spells  */
end_comment

begin_macro
name|raisespells
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|c
index|[
name|SPELLS
index|]
operator|+=
name|x
operator|)
operator|>
name|c
index|[
name|SPELLMAX
index|]
condition|)
name|c
index|[
name|SPELLS
index|]
operator|=
name|c
index|[
name|SPELLMAX
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|raisemspells
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|c
index|[
name|SPELLMAX
index|]
operator|+=
name|x
expr_stmt|;
name|c
index|[
name|SPELLS
index|]
operator|+=
name|x
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	************ 	LOOSE SPELLS 	************ 	losespells(x) 	losemspells(x)  	subroutine to lose maximum spells  */
end_comment

begin_macro
name|losespells
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|c
index|[
name|SPELLS
index|]
operator|-=
name|x
operator|)
operator|<
literal|0
condition|)
name|c
index|[
name|SPELLS
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|losemspells
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|c
index|[
name|SPELLMAX
index|]
operator|-=
name|x
operator|)
operator|<
literal|0
condition|)
name|c
index|[
name|SPELLMAX
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
index|[
name|SPELLS
index|]
operator|-=
name|x
operator|)
operator|<
literal|0
condition|)
name|c
index|[
name|SPELLS
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	makemonst(lev) 		int lev;  	function to return monster number for a randomly selected monster 		for the given cave level  */
end_comment

begin_macro
name|makemonst
argument_list|(
argument|lev
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tmp
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|lev
operator|<
literal|1
condition|)
name|lev
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lev
operator|>
literal|12
condition|)
name|lev
operator|=
literal|12
expr_stmt|;
name|tmp
operator|=
name|WATERLORD
expr_stmt|;
if|if
condition|(
name|lev
operator|<
literal|5
condition|)
while|while
condition|(
name|tmp
operator|==
name|WATERLORD
condition|)
name|tmp
operator|=
name|rnd
argument_list|(
operator|(
name|x
operator|=
name|monstlevel
index|[
name|lev
operator|-
literal|1
index|]
operator|)
condition|?
name|x
else|:
literal|1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|tmp
operator|==
name|WATERLORD
condition|)
name|tmp
operator|=
name|rnd
argument_list|(
operator|(
name|x
operator|=
name|monstlevel
index|[
name|lev
operator|-
literal|1
index|]
operator|-
name|monstlevel
index|[
name|lev
operator|-
literal|4
index|]
operator|)
condition|?
name|x
else|:
literal|1
argument_list|)
operator|+
name|monstlevel
index|[
name|lev
operator|-
literal|4
index|]
expr_stmt|;
while|while
condition|(
name|monster
index|[
name|tmp
index|]
operator|.
name|genocided
operator|&&
name|tmp
operator|<
name|MAXMONST
condition|)
name|tmp
operator|++
expr_stmt|;
comment|/* genocided? */
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	positionplayer()  	function to be sure player is not in a wall  */
end_comment

begin_macro
name|positionplayer
argument_list|()
end_macro

begin_block
block|{
name|int
name|try
decl_stmt|;
name|try
operator|=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|item
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|||
name|mitem
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|)
operator|&&
operator|(
name|try
operator|)
condition|)
if|if
condition|(
operator|++
name|playerx
operator|>=
name|MAXX
operator|-
literal|1
condition|)
block|{
name|playerx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|playery
operator|>=
name|MAXY
operator|-
literal|1
condition|)
block|{
name|playery
operator|=
literal|1
expr_stmt|;
operator|--
name|try
expr_stmt|;
block|}
block|}
if|if
condition|(
name|try
operator|==
literal|0
condition|)
name|lprcat
argument_list|(
literal|"Failure in positionplayer\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	recalc()	function to recalculate the armor class of the player  */
end_comment

begin_macro
name|recalc
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|c
index|[
name|AC
index|]
operator|=
name|c
index|[
name|MOREDEFENSES
index|]
expr_stmt|;
if|if
condition|(
name|c
index|[
name|WEAR
index|]
operator|>=
literal|0
condition|)
switch|switch
condition|(
name|iven
index|[
name|c
index|[
name|WEAR
index|]
index|]
condition|)
block|{
case|case
name|OSHIELD
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|2
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|OLEATHER
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|2
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|OSTUDLEATHER
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|3
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|ORING
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|5
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|OCHAIN
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|6
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|OSPLINT
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|7
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|OPLATE
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|9
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|OPLATEARMOR
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|10
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
case|case
name|OSSPLATE
case|:
name|c
index|[
name|AC
index|]
operator|+=
literal|12
operator|+
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
index|[
name|SHIELD
index|]
operator|>=
literal|0
condition|)
if|if
condition|(
name|iven
index|[
name|c
index|[
name|SHIELD
index|]
index|]
operator|==
name|OSHIELD
condition|)
name|c
index|[
name|AC
index|]
operator|+=
literal|2
operator|+
name|ivenarg
index|[
name|c
index|[
name|SHIELD
index|]
index|]
expr_stmt|;
if|if
condition|(
name|c
index|[
name|WIELD
index|]
operator|<
literal|0
condition|)
name|c
index|[
name|WCLASS
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|i
operator|=
name|ivenarg
index|[
name|c
index|[
name|WIELD
index|]
index|]
expr_stmt|;
switch|switch
condition|(
name|iven
index|[
name|c
index|[
name|WIELD
index|]
index|]
condition|)
block|{
case|case
name|ODAGGER
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|3
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OBELT
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|7
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OSHIELD
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|8
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OSPEAR
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|10
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OFLAIL
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|14
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OBATTLEAXE
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|17
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OLANCE
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|19
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OLONGSWORD
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|22
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|O2SWORD
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|26
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OSWORD
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|32
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OSWORDofSLASHING
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|30
operator|+
name|i
expr_stmt|;
break|break;
case|case
name|OHAMMER
case|:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|35
operator|+
name|i
expr_stmt|;
break|break;
default|default:
name|c
index|[
name|WCLASS
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|c
index|[
name|WCLASS
index|]
operator|+=
name|c
index|[
name|MOREDAM
index|]
expr_stmt|;
comment|/*	now for regeneration abilities based on rings	*/
name|c
index|[
name|REGEN
index|]
operator|=
literal|1
expr_stmt|;
name|c
index|[
name|ENERGY
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|25
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
if|if
condition|(
name|iven
index|[
name|k
index|]
condition|)
block|{
name|j
operator|=
name|k
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|iven
index|[
name|i
index|]
condition|)
block|{
case|case
name|OPROTRING
case|:
name|c
index|[
name|AC
index|]
operator|+=
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|ODAMRING
case|:
name|c
index|[
name|WCLASS
index|]
operator|+=
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|OBELT
case|:
name|c
index|[
name|WCLASS
index|]
operator|+=
operator|(
operator|(
name|ivenarg
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator|)
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|OREGENRING
case|:
name|c
index|[
name|REGEN
index|]
operator|+=
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|ORINGOFEXTRA
case|:
name|c
index|[
name|REGEN
index|]
operator|+=
literal|5
operator|*
operator|(
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|OENERGYRING
case|:
name|c
index|[
name|ENERGY
index|]
operator|+=
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* 	quit()  	subroutine to ask if the player really wants to quit  */
end_comment

begin_macro
name|quit
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|lastmonst
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n\nDo you really want to quit?"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'y'
condition|)
block|{
name|died
argument_list|(
literal|300
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|'n'
operator|)
operator|||
operator|(
name|i
operator|==
literal|'\33'
operator|)
condition|)
block|{
name|lprcat
argument_list|(
literal|" no"
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|setbold
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"Yes"
argument_list|)
expr_stmt|;
name|resetbold
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|" or "
argument_list|)
expr_stmt|;
name|setbold
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"No"
argument_list|)
expr_stmt|;
name|resetbold
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|" please?   Do you want to quit? "
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	function to ask --more-- then the user must enter a space  */
end_comment

begin_macro
name|more
argument_list|()
end_macro

begin_block
block|{
name|lprcat
argument_list|(
literal|"\n  --- press "
argument_list|)
expr_stmt|;
name|standout
argument_list|(
literal|"space"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|" to continue --- "
argument_list|)
expr_stmt|;
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|' '
condition|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/* 	function to put something in the players inventory 	returns 0 if success, 1 if a failure  */
end_comment

begin_macro
name|take
argument_list|(
argument|itm
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|itm
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|limit
decl_stmt|;
comment|/*	cursors(); */
if|if
condition|(
operator|(
name|limit
operator|=
literal|15
operator|+
operator|(
name|c
index|[
name|LEVEL
index|]
operator|>>
literal|1
operator|)
operator|)
operator|>
literal|26
condition|)
name|limit
operator|=
literal|26
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iven
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|iven
index|[
name|i
index|]
operator|=
name|itm
expr_stmt|;
name|ivenarg
index|[
name|i
index|]
operator|=
name|arg
expr_stmt|;
name|limit
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|itm
condition|)
block|{
case|case
name|OPROTRING
case|:
case|case
name|ODAMRING
case|:
case|case
name|OBELT
case|:
name|limit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ODEXRING
case|:
name|c
index|[
name|DEXTERITY
index|]
operator|+=
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|limit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OSTRRING
case|:
name|c
index|[
name|STREXTRA
index|]
operator|+=
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|limit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OCLEVERRING
case|:
name|c
index|[
name|INTELLIGENCE
index|]
operator|+=
name|ivenarg
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|limit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OHAMMER
case|:
name|c
index|[
name|DEXTERITY
index|]
operator|+=
literal|10
expr_stmt|;
name|c
index|[
name|STREXTRA
index|]
operator|+=
literal|10
expr_stmt|;
name|c
index|[
name|INTELLIGENCE
index|]
operator|-=
literal|10
expr_stmt|;
name|limit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OORBOFDRAGON
case|:
name|c
index|[
name|SLAYING
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|OSPIRITSCARAB
case|:
name|c
index|[
name|NEGATESPIRIT
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|OCUBEofUNDEAD
case|:
name|c
index|[
name|CUBEofUNDEAD
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|ONOTHEFT
case|:
name|c
index|[
name|NOTHEFT
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|OSWORDofSLASHING
case|:
name|c
index|[
name|DEXTERITY
index|]
operator|+=
literal|5
expr_stmt|;
name|limit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|lprcat
argument_list|(
literal|"\nYou pick up:"
argument_list|)
expr_stmt|;
name|srcount
operator|=
literal|0
expr_stmt|;
name|show3
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
condition|)
name|bottomline
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lprcat
argument_list|(
literal|"\nYou can't carry anything else"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	subroutine to drop an object  returns 1 if something there already else 0  */
end_comment

begin_macro
name|drop_object
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|itm
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|<
literal|0
operator|)
operator|||
operator|(
name|k
operator|>
literal|25
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|itm
operator|=
name|iven
index|[
name|k
index|]
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
if|if
condition|(
name|itm
operator|==
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"\nYou don't have item %c! "
argument_list|,
name|k
operator|+
literal|'a'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|item
index|[
name|playerx
index|]
index|[
name|playery
index|]
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nThere's something here already"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|playery
operator|==
name|MAXY
operator|-
literal|1
operator|&&
name|playerx
operator|==
literal|33
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not in entrance */
name|item
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|=
name|itm
expr_stmt|;
name|iarg
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|=
name|ivenarg
index|[
name|k
index|]
expr_stmt|;
name|srcount
operator|=
literal|0
expr_stmt|;
name|lprcat
argument_list|(
literal|"\n  You drop:"
argument_list|)
expr_stmt|;
name|show3
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|/* show what item you dropped*/
name|know
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|=
literal|0
expr_stmt|;
name|iven
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
index|[
name|WIELD
index|]
operator|==
name|k
condition|)
name|c
index|[
name|WIELD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
index|[
name|WEAR
index|]
operator|==
name|k
condition|)
name|c
index|[
name|WEAR
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
index|[
name|SHIELD
index|]
operator|==
name|k
condition|)
name|c
index|[
name|SHIELD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|adjustcvalues
argument_list|(
name|itm
argument_list|,
name|ivenarg
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|dropflag
operator|=
literal|1
expr_stmt|;
comment|/* say dropped an item so wont ask to pick it up right away */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	function to enchant armor player is currently wearing  */
end_comment

begin_macro
name|enchantarmor
argument_list|()
end_macro

begin_block
block|{
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|c
index|[
name|WEAR
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
index|[
name|SHIELD
index|]
operator|<
literal|0
condition|)
block|{
name|cursors
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou feel a sense of loss"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|tmp
operator|=
name|iven
index|[
name|c
index|[
name|SHIELD
index|]
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|OSCROLL
condition|)
if|if
condition|(
name|tmp
operator|!=
name|OPOTION
condition|)
block|{
name|ivenarg
index|[
name|c
index|[
name|SHIELD
index|]
index|]
operator|++
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|tmp
operator|=
name|iven
index|[
name|c
index|[
name|WEAR
index|]
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|OSCROLL
condition|)
if|if
condition|(
name|tmp
operator|!=
name|OPOTION
condition|)
block|{
name|ivenarg
index|[
name|c
index|[
name|WEAR
index|]
index|]
operator|++
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	function to enchant a weapon presently being wielded  */
end_comment

begin_macro
name|enchweapon
argument_list|()
end_macro

begin_block
block|{
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|c
index|[
name|WIELD
index|]
operator|<
literal|0
condition|)
block|{
name|cursors
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou feel a sense of loss"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
name|iven
index|[
name|c
index|[
name|WIELD
index|]
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|OSCROLL
condition|)
if|if
condition|(
name|tmp
operator|!=
name|OPOTION
condition|)
block|{
name|ivenarg
index|[
name|c
index|[
name|WIELD
index|]
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|OCLEVERRING
condition|)
name|c
index|[
name|INTELLIGENCE
index|]
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
name|OSTRRING
condition|)
name|c
index|[
name|STREXTRA
index|]
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
name|ODEXRING
condition|)
name|c
index|[
name|DEXTERITY
index|]
operator|++
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	routine to tell if player can carry one more thing 	returns 1 if pockets are full, else 0  */
end_comment

begin_macro
name|pocketfull
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|limit
decl_stmt|;
if|if
condition|(
operator|(
name|limit
operator|=
literal|15
operator|+
operator|(
name|c
index|[
name|LEVEL
index|]
operator|>>
literal|1
operator|)
operator|)
operator|>
literal|26
condition|)
name|limit
operator|=
literal|26
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iven
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	function to return 1 if a monster is next to the player else returns 0  */
end_comment

begin_macro
name|nearbymonst
argument_list|()
end_macro

begin_block
block|{
name|int
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|playerx
operator|-
literal|1
init|;
name|tmp
operator|<
name|playerx
operator|+
literal|2
condition|;
name|tmp
operator|++
control|)
for|for
control|(
name|tmp2
operator|=
name|playery
operator|-
literal|1
init|;
name|tmp2
operator|<
name|playery
operator|+
literal|2
condition|;
name|tmp2
operator|++
control|)
if|if
condition|(
name|mitem
index|[
name|tmp
index|]
index|[
name|tmp2
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* if monster nearby */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	function to steal an item from the players pockets 	returns 1 if steals something else returns 0  */
end_comment

begin_macro
name|stealsomething
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|100
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|i
operator|=
name|rund
argument_list|(
literal|26
argument_list|)
expr_stmt|;
if|if
condition|(
name|iven
index|[
name|i
index|]
condition|)
if|if
condition|(
name|c
index|[
name|WEAR
index|]
operator|!=
name|i
condition|)
if|if
condition|(
name|c
index|[
name|WIELD
index|]
operator|!=
name|i
condition|)
if|if
condition|(
name|c
index|[
name|SHIELD
index|]
operator|!=
name|i
condition|)
block|{
name|srcount
operator|=
literal|0
expr_stmt|;
name|show3
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|adjustcvalues
argument_list|(
name|iven
index|[
name|i
index|]
argument_list|,
name|ivenarg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|iven
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|--
name|j
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* 	function to return 1 is player carrys nothing else return 0  */
end_comment

begin_macro
name|emptyhanded
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iven
index|[
name|i
index|]
condition|)
if|if
condition|(
name|i
operator|!=
name|c
index|[
name|WIELD
index|]
condition|)
if|if
condition|(
name|i
operator|!=
name|c
index|[
name|WEAR
index|]
condition|)
if|if
condition|(
name|i
operator|!=
name|c
index|[
name|SHIELD
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	function to create a gem on a square near the player  */
end_comment

begin_macro
name|creategem
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|rnd
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|i
operator|=
name|ODIAMOND
expr_stmt|;
name|j
operator|=
literal|50
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|=
name|ORUBY
expr_stmt|;
name|j
operator|=
literal|40
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|=
name|OEMERALD
expr_stmt|;
name|j
operator|=
literal|30
expr_stmt|;
break|break;
default|default:
name|i
operator|=
name|OSAPPHIRE
expr_stmt|;
name|j
operator|=
literal|20
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|createitem
argument_list|(
name|i
argument_list|,
name|rnd
argument_list|(
name|j
argument_list|)
operator|+
name|j
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	function to change character levels as needed when dropping an object 	that affects these characteristics  */
end_comment

begin_macro
name|adjustcvalues
argument_list|(
argument|itm
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|itm
decl_stmt|,
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flag
decl_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|itm
condition|)
block|{
case|case
name|ODEXRING
case|:
name|c
index|[
name|DEXTERITY
index|]
operator|-=
name|arg
operator|+
literal|1
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OSTRRING
case|:
name|c
index|[
name|STREXTRA
index|]
operator|-=
name|arg
operator|+
literal|1
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OCLEVERRING
case|:
name|c
index|[
name|INTELLIGENCE
index|]
operator|-=
name|arg
operator|+
literal|1
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OHAMMER
case|:
name|c
index|[
name|DEXTERITY
index|]
operator|-=
literal|10
expr_stmt|;
name|c
index|[
name|STREXTRA
index|]
operator|-=
literal|10
expr_stmt|;
name|c
index|[
name|INTELLIGENCE
index|]
operator|+=
literal|10
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OSWORDofSLASHING
case|:
name|c
index|[
name|DEXTERITY
index|]
operator|-=
literal|5
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OORBOFDRAGON
case|:
operator|--
name|c
index|[
name|SLAYING
index|]
expr_stmt|;
return|return;
case|case
name|OSPIRITSCARAB
case|:
operator|--
name|c
index|[
name|NEGATESPIRIT
index|]
expr_stmt|;
return|return;
case|case
name|OCUBEofUNDEAD
case|:
operator|--
name|c
index|[
name|CUBEofUNDEAD
index|]
expr_stmt|;
return|return;
case|case
name|ONOTHEFT
case|:
operator|--
name|c
index|[
name|NOTHEFT
index|]
expr_stmt|;
return|return;
case|case
name|OLANCE
case|:
name|c
index|[
name|LANCEDEATH
index|]
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|OPOTION
case|:
case|case
name|OSCROLL
case|:
return|return;
default|default:
name|flag
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|flag
condition|)
name|bottomline
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	function to read a string from token input "string" 	returns a pointer to the string  */
end_comment

begin_macro
name|gettokstr
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
literal|50
expr_stmt|;
while|while
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
operator|--
name|i
operator|>
literal|0
operator|)
condition|)
empty_stmt|;
name|i
operator|=
literal|36
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'"'
condition|)
operator|*
name|str
operator|++
operator|=
name|j
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|str
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|50
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|'"'
condition|)
while|while
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
operator|--
name|i
operator|>
literal|0
operator|)
condition|)
empty_stmt|;
comment|/* if end due to too long, then find closing quote */
block|}
end_block

begin_comment
comment|/* 	function to ask user for a password (no echo) 	returns 1 if entered correctly, 0 if not  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|gpwbuf
index|[
literal|33
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|getpassword
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|gpwp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|password
decl_stmt|;
name|scbr
argument_list|()
expr_stmt|;
comment|/*	system("stty -echo cbreak"); */
name|gpwp
operator|=
name|gpwbuf
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nEnter Password: "
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|password
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|read
argument_list|(
literal|0
argument_list|,
name|gpwp
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gpwbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sncbr
argument_list|()
expr_stmt|;
comment|/* system("stty echo -cbreak"); */
if|if
condition|(
name|strcmp
argument_list|(
name|gpwbuf
argument_list|,
name|password
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nSorry\n"
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	subroutine to get a yes or no response from the user 	returns y or n  */
end_comment

begin_macro
name|getyn
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|'y'
operator|&&
name|i
operator|!=
literal|'n'
operator|&&
name|i
operator|!=
literal|'\33'
condition|)
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	function to calculate the pack weight of the player 	returns the number of pounds the player is carrying  */
end_comment

begin_macro
name|packweight
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|k
operator|=
name|c
index|[
name|GOLD
index|]
operator|/
literal|1000
expr_stmt|;
name|j
operator|=
literal|25
expr_stmt|;
while|while
condition|(
operator|(
name|iven
index|[
name|j
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|j
operator|>
literal|0
operator|)
condition|)
operator|--
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|iven
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|OSSPLATE
case|:
case|case
name|OPLATEARMOR
case|:
name|k
operator|+=
literal|40
expr_stmt|;
break|break;
case|case
name|OPLATE
case|:
name|k
operator|+=
literal|35
expr_stmt|;
break|break;
case|case
name|OHAMMER
case|:
name|k
operator|+=
literal|30
expr_stmt|;
break|break;
case|case
name|OSPLINT
case|:
name|k
operator|+=
literal|26
expr_stmt|;
break|break;
case|case
name|OSWORDofSLASHING
case|:
case|case
name|OCHAIN
case|:
case|case
name|OBATTLEAXE
case|:
case|case
name|O2SWORD
case|:
name|k
operator|+=
literal|23
expr_stmt|;
break|break;
case|case
name|OLONGSWORD
case|:
case|case
name|OSWORD
case|:
case|case
name|ORING
case|:
case|case
name|OFLAIL
case|:
name|k
operator|+=
literal|20
expr_stmt|;
break|break;
case|case
name|OLANCE
case|:
case|case
name|OSTUDLEATHER
case|:
name|k
operator|+=
literal|15
expr_stmt|;
break|break;
case|case
name|OLEATHER
case|:
case|case
name|OSPEAR
case|:
name|k
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|OORBOFDRAGON
case|:
case|case
name|OBELT
case|:
name|k
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|OSHIELD
case|:
name|k
operator|+=
literal|7
expr_stmt|;
break|break;
case|case
name|OCHEST
case|:
name|k
operator|+=
literal|30
operator|+
name|ivenarg
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
name|k
operator|++
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|MACRORND
end_ifndef

begin_comment
comment|/* macros to generate random numbers   1<=rnd(N)<=N   0<=rund(N)<=N-1 */
end_comment

begin_macro
name|rnd
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|random
argument_list|()
operator|%
name|x
operator|)
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rund
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|random
argument_list|()
operator|%
name|x
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MACRORND
end_endif

end_unit

