begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* io.c			 Larn is copyrighted 1986 by Noah Morgan.  *  *	Below are the functions in this file:  *  *	setupvt100() 	Subroutine to set up terminal in correct mode for game  *	clearvt100()  	Subroutine to clean up terminal when the game is over  *	getchar() 		Routine to read in one character from the terminal  *	scbr()			Function to set cbreak -echo for the terminal  *	sncbr()			Function to set -cbreak echo for the terminal  *	newgame() 		Subroutine to save the initial time and seed rnd()  *  *	FILE OUTPUT ROUTINES  *  *	lprintf(format,args . . .)	printf to the output buffer  *	lprint(integer)				send binary integer to output buffer  *	lwrite(buf,len)				write a buffer to the output buffer  *	lprcat(str)					sent string to output buffer  *  *	FILE OUTPUT MACROS (in header.h)  *  *	lprc(character)				put the character into the output buffer  *  *	FILE INPUT ROUTINES  *  *	long lgetc()				read one character from input buffer  *	long lrint()				read one integer from input buffer  *	lrfill(address,number)		put input bytes into a buffer  *	char *lgetw()				get a whitespace ended word from input  *	char *lgetl()				get a \n or EOF ended line from input  *  *	FILE OPEN / CLOSE ROUTINES  *  *	lcreat(filename)			create a new file for write  *	lopen(filename)				open a file for read  *	lappend(filename)			open for append to an existing file  *	lrclose()					close the input file  *	lwclose()					close output file  *	lflush()					flush the output buffer  *  *	Other Routines  *  *	cursor(x,y)					position cursor at [x,y]  *	cursors()					position cursor at [1,24] (saves memory)  *  cl_line(x,y)         		Clear line at [1,y] and leave cursor at [x,y]  *  cl_up(x,y)    				Clear screen from [x,1] to current line.  *  cl_dn(x,y) 					Clear screen from [1,y] to end of display.  *  standout(str)	 			Print the string in standout mode.  *  set_score_output() 			Called when output should be literally printed.  ** putchar(ch)					Print one character in decoded output buffer.  ** flush_buf()					Flush buffer with decoded output.  ** init_term()					Terminal initialization -- setup termcap info  **	char *tmcapcnv(sd,ss)  		Routine to convert VT100 \33's to termcap format  *	beep()		Routine to emit a beep if enabled (see no-beep in .larnopts)  *  * Note: ** entries are available only in termcap mode.  */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_comment
comment|/* system III or system V */
end_comment

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_define
define|#
directive|define
name|sgttyb
value|termio
end_define

begin_define
define|#
directive|define
name|stty
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|)
value|ioctl(_a,TCSETA,_b)
end_define

begin_define
define|#
directive|define
name|gtty
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|)
value|ioctl(_a,TCGETA,_b)
end_define

begin_decl_stmt
specifier|static
name|int
name|rawflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|saveeof
decl_stmt|,
name|saveeol
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|doraw
parameter_list|(
name|_a
parameter_list|)
value|if(!rawflg){++rawflg;saveeof=_a.c_cc[VMIN];saveeol=_a.c_cc[VTIME];}\     _a.c_cc[VMIN]=1;_a.c_cc[VTIME]=1;_a.c_lflag&= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL)
end_define

begin_define
define|#
directive|define
name|unraw
parameter_list|(
name|_a
parameter_list|)
value|_a.c_cc[VMIN]=saveeof;_a.c_cc[VTIME]=saveeol;_a.c_lflag |= ICANON|ECHO|ECHOE|ECHOK|ECHONL
end_define

begin_else
else|#
directive|else
else|not SYSV
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_define
define|#
directive|define
name|CBREAK
value|RAW
end_define

begin_comment
comment|/* V7 has no CBREAK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|doraw
parameter_list|(
name|_a
parameter_list|)
value|(_a.sg_flags |= CBREAK,_a.sg_flags&= ~ECHO)
end_define

begin_define
define|#
directive|define
name|unraw
parameter_list|(
name|_a
parameter_list|)
value|(_a.sg_flags&= ~CBREAK,_a.sg_flags |= ECHO)
end_define

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
endif|not SYSV
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NOVARARGS
end_ifndef

begin_comment
comment|/* if we have varargs */
end_comment

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_else
else|#
directive|else
else|NOVARARGS
end_else

begin_comment
comment|/* if we don't have varargs */
end_comment

begin_typedef
typedef|typedef
name|char
modifier|*
name|va_list
typedef|;
end_typedef

begin_define
define|#
directive|define
name|va_dcl
value|int va_alist;
end_define

begin_define
define|#
directive|define
name|va_start
parameter_list|(
name|plist
parameter_list|)
value|plist = (char *)&va_alist
end_define

begin_define
define|#
directive|define
name|va_end
parameter_list|(
name|plist
parameter_list|)
end_define

begin_define
define|#
directive|define
name|va_arg
parameter_list|(
name|plist
parameter_list|,
name|mode
parameter_list|)
value|((mode *)(plist += sizeof(mode)))[-1]
end_define

begin_endif
endif|#
directive|endif
endif|NOVARARGS
end_endif

begin_define
define|#
directive|define
name|LINBUFSIZE
value|128
end_define

begin_comment
comment|/* size of the lgetw() and lgetl() buffer		*/
end_comment

begin_decl_stmt
name|int
name|lfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  output file numbers							*/
end_comment

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  input file numbers							*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|ttx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* storage for the tty modes					*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipoint
init|=
name|MAXIBUF
decl_stmt|,
name|iepoint
init|=
name|MAXIBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  input buffering pointers    */
end_comment

begin_decl_stmt
specifier|static
name|char
name|lgetwbuf
index|[
name|LINBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* get line (word) buffer				*/
end_comment

begin_comment
comment|/*  *	setupvt100() 		Subroutine to set up terminal in correct mode for game  *  *	Attributes off, clear screen, set scrolling region, set tty mode  */
end_comment

begin_macro
name|setupvt100
argument_list|()
end_macro

begin_block
block|{
name|clear
argument_list|()
expr_stmt|;
name|setscroll
argument_list|()
expr_stmt|;
name|scbr
argument_list|()
expr_stmt|;
comment|/* system("stty cbreak -echo"); */
block|}
end_block

begin_comment
comment|/*  *	clearvt100() 	 	Subroutine to clean up terminal when the game is over  *  *	Attributes off, clear screen, unset scrolling region, restore tty mode  */
end_comment

begin_macro
name|clearvt100
argument_list|()
end_macro

begin_block
block|{
name|resetscroll
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|sncbr
argument_list|()
expr_stmt|;
comment|/* system("stty -cbreak echo"); */
block|}
end_block

begin_comment
comment|/*  *	getchar() 		Routine to read in one character from the terminal  */
end_comment

begin_macro
name|getchar
argument_list|()
end_macro

begin_block
block|{
name|char
name|byt
decl_stmt|;
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|BYTESIN
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|lflush
argument_list|()
expr_stmt|;
comment|/* be sure output buffer is flushed */
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|byt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get byte from terminal */
return|return
operator|(
name|byt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	scbr()		Function to set cbreak -echo for the terminal  *  *	like: system("stty cbreak -echo")  */
end_comment

begin_macro
name|scbr
argument_list|()
end_macro

begin_block
block|{
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|doraw
argument_list|(
name|ttx
argument_list|)
expr_stmt|;
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	sncbr()		Function to set -cbreak echo for the terminal  *  *	like: system("stty -cbreak echo")  */
end_comment

begin_macro
name|sncbr
argument_list|()
end_macro

begin_block
block|{
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|unraw
argument_list|(
name|ttx
argument_list|)
expr_stmt|;
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	newgame() 		Subroutine to save the initial time and seed rnd()  */
end_comment

begin_macro
name|newgame
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|long
modifier|*
name|p
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
for|for
control|(
name|p
operator|=
name|c
operator|,
name|pe
operator|=
name|c
operator|+
literal|100
init|;
name|p
operator|<
name|pe
condition|;
operator|*
name|p
operator|++
operator|=
literal|0
control|)
empty_stmt|;
name|time
argument_list|(
operator|&
name|initialtime
argument_list|)
expr_stmt|;
name|srandomdev
argument_list|()
expr_stmt|;
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* open buffering for output to terminal */
block|}
end_block

begin_comment
comment|/*  *	lprintf(format,args . . .)		printf to the output buffer  *		char *format;  *		??? args . . .  *  *	Enter with the format string in "format", as per printf() usage  *		and any needed arguments following it  *	Note: lprintf() only supports %s, %c and %d, with width modifier and left  *		or right justification.  *	No correct checking for output buffer overflow is done, but flushes  *		are done beforehand if needed.  *	Returns nothing of value.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|lprintf
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|str2
decl_stmt|;
name|str2
operator|=
name|str
expr_stmt|;
name|str
operator|=
name|str2
expr_stmt|;
comment|/* to make lint happy */
block|}
end_block

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|sprintf
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|str2
decl_stmt|;
name|str2
operator|=
name|str
expr_stmt|;
name|str
operator|=
name|str2
expr_stmt|;
comment|/* to make lint happy */
block|}
end_block

begin_else
else|#
directive|else
else|lint
end_else

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|lprintf
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
comment|/* pointer for variable argument list */
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|char
modifier|*
name|outb
decl_stmt|,
modifier|*
name|tmpb
decl_stmt|;
specifier|register
name|long
name|wide
decl_stmt|,
name|left
decl_stmt|,
name|cont
decl_stmt|,
name|n
decl_stmt|;
comment|/* data for lprintf	*/
name|char
name|db
index|[
literal|12
index|]
decl_stmt|;
comment|/* %d buffer in lprintf	*/
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* initialize the var args pointer */
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* pointer to format string */
if|if
condition|(
name|lpnt
operator|>=
name|lpend
condition|)
name|lflush
argument_list|()
expr_stmt|;
name|outb
operator|=
name|lpnt
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
if|if
condition|(
operator|*
name|fmt
condition|)
operator|*
name|outb
operator|++
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
else|else
block|{
name|lpnt
operator|=
name|outb
expr_stmt|;
return|return;
block|}
name|wide
operator|=
literal|0
expr_stmt|;
name|left
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|cont
condition|)
switch|switch
condition|(
operator|*
operator|(
operator|++
name|fmt
operator|)
condition|)
block|{
case|case
literal|'d'
case|:
name|n
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
operator|*
name|outb
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|wide
condition|)
operator|--
name|wide
expr_stmt|;
block|}
name|tmpb
operator|=
name|db
operator|+
literal|11
expr_stmt|;
operator|*
name|tmpb
operator|=
call|(
name|char
call|)
argument_list|(
name|n
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|9
condition|)
operator|*
operator|(
operator|--
name|tmpb
operator|)
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|n
operator|/=
literal|10
operator|)
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide
operator|==
literal|0
condition|)
while|while
condition|(
name|tmpb
operator|<
name|db
operator|+
literal|12
condition|)
operator|*
name|outb
operator|++
operator|=
operator|*
name|tmpb
operator|++
expr_stmt|;
else|else
block|{
name|wide
operator|-=
name|db
operator|-
name|tmpb
operator|+
literal|12
expr_stmt|;
if|if
condition|(
name|left
condition|)
while|while
condition|(
name|wide
operator|--
operator|>
literal|0
condition|)
operator|*
name|outb
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|tmpb
operator|<
name|db
operator|+
literal|12
condition|)
operator|*
name|outb
operator|++
operator|=
operator|*
name|tmpb
operator|++
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
while|while
condition|(
name|wide
operator|--
operator|>
literal|0
condition|)
operator|*
name|outb
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|cont
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|tmpb
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|outb
operator|++
operator|=
operator|*
name|tmpb
operator|++
condition|)
empty_stmt|;
operator|--
name|outb
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|wide
operator|-
name|strlen
argument_list|(
name|tmpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
condition|)
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|outb
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|*
name|outb
operator|++
operator|=
operator|*
name|tmpb
operator|++
condition|)
empty_stmt|;
operator|--
name|outb
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|outb
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|cont
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|*
name|outb
operator|++
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|cont
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|wide
operator|=
literal|10
operator|*
name|wide
operator|+
operator|*
name|fmt
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|left
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
operator|*
name|outb
operator|++
operator|=
operator|*
name|fmt
expr_stmt|;
name|cont
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  *	lprint(long-integer)				send binary integer to output buffer  *		long integer;  *  *		+---------+---------+---------+---------+  *		|	high  |			|		  |	  low	|  *		|  order  |			|		  |  order	|  *		|   byte  |			|		  |	  byte	|  *		+---------+---------+---------+---------+  *	   31  ---  24 23 --- 16 15 ---  8 7  ---   0  *  *	The save order is low order first, to high order (4 bytes total)  *		and is written to be system independent.  *	No checking for output buffer overflow is done, but flushes if needed!  *	Returns nothing of value.  */
end_comment

begin_expr_stmt
name|lprint
argument_list|(
name|x
argument_list|)
specifier|register
name|long
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|lpnt
operator|>=
name|lpend
condition|)
name|lflush
argument_list|()
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
literal|255
operator|&
name|x
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
literal|255
operator|&
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
literal|255
operator|&
operator|(
name|x
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
literal|255
operator|&
operator|(
name|x
operator|>>
literal|24
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	lwrite(buf,len)					write a buffer to the output buffer  *		char *buf;  *		int len;  *  *	Enter with the address and number of bytes to write out  *	Returns nothing of value  */
end_comment

begin_expr_stmt
name|lwrite
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|num2
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|399
condition|)
comment|/* don't copy data if can just write it */
block|{
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|BYTESOUT
index|]
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|VT100
for|for
control|(
name|str
operator|=
name|buf
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
name|lprc
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
else|#
directive|else
else|VT100
name|lflush
argument_list|()
expr_stmt|;
name|write
argument_list|(
name|lfd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VT100
block|}
else|else
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|lpnt
operator|>=
name|lpend
condition|)
name|lflush
argument_list|()
expr_stmt|;
comment|/* if buffer is full flush it	*/
name|num2
operator|=
name|lpbuf
operator|+
name|BUFBIG
operator|-
name|lpnt
expr_stmt|;
comment|/*	# bytes left in output buffer	*/
if|if
condition|(
name|num2
operator|>
name|len
condition|)
name|num2
operator|=
name|len
expr_stmt|;
name|str
operator|=
name|lpnt
expr_stmt|;
name|len
operator|-=
name|num2
expr_stmt|;
while|while
condition|(
name|num2
operator|--
condition|)
operator|*
name|str
operator|++
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
comment|/* copy in the bytes */
name|lpnt
operator|=
name|str
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	long lgetc()				Read one character from input buffer  *  *  Returns 0 if EOF, otherwise the character  */
end_comment

begin_function
name|long
name|lgetc
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ipoint
operator|!=
name|iepoint
condition|)
return|return
operator|(
name|inbuffer
index|[
name|ipoint
operator|++
index|]
operator|)
return|;
if|if
condition|(
name|iepoint
operator|!=
name|MAXIBUF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|inbuffer
argument_list|,
name|MAXIBUF
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"error reading from input file\n"
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|iepoint
operator|=
name|ipoint
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ipoint
operator|=
literal|1
expr_stmt|;
name|iepoint
operator|=
name|i
expr_stmt|;
return|return
operator|(
operator|*
name|inbuffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	long lrint()			Read one integer from input buffer  *  *		+---------+---------+---------+---------+  *		|	high  |			|		  |	  low	|  *		|  order  |			|		  |  order	|  *		|   byte  |			|		  |	  byte	|  *		+---------+---------+---------+---------+  *	   31  ---  24 23 --- 16 15 ---  8 7  ---   0  *  *	The save order is low order first, to high order (4 bytes total)  *	Returns the int read  */
end_comment

begin_function
name|long
name|lrint
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|i
decl_stmt|;
name|i
operator|=
literal|255
operator|&
name|lgetc
argument_list|()
expr_stmt|;
name|i
operator||=
operator|(
literal|255
operator|&
name|lgetc
argument_list|()
operator|)
operator|<<
literal|8
expr_stmt|;
name|i
operator||=
operator|(
literal|255
operator|&
name|lgetc
argument_list|()
operator|)
operator|<<
literal|16
expr_stmt|;
name|i
operator||=
operator|(
literal|255
operator|&
name|lgetc
argument_list|()
operator|)
operator|<<
literal|24
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	lrfill(address,number)			put input bytes into a buffer  *		char *address;  *		int number;  *  *	Reads "number" bytes into the buffer pointed to by "address".  *	Returns nothing of value  */
end_comment

begin_expr_stmt
name|lrfill
argument_list|(
name|adr
argument_list|,
name|num
argument_list|)
specifier|register
name|char
operator|*
name|adr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pnt
decl_stmt|;
specifier|register
name|int
name|num2
decl_stmt|;
while|while
condition|(
name|num
condition|)
block|{
if|if
condition|(
name|iepoint
operator|==
name|ipoint
condition|)
block|{
if|if
condition|(
name|num
operator|>
literal|5
condition|)
comment|/* fast way */
block|{
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|adr
argument_list|,
name|num
argument_list|)
operator|!=
name|num
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"error reading from input file\n"
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|adr
operator|++
operator|=
name|lgetc
argument_list|()
expr_stmt|;
operator|--
name|num
expr_stmt|;
block|}
block|}
else|else
block|{
name|num2
operator|=
name|iepoint
operator|-
name|ipoint
expr_stmt|;
comment|/*	# of bytes left in the buffer	*/
if|if
condition|(
name|num2
operator|>
name|num
condition|)
name|num2
operator|=
name|num
expr_stmt|;
name|pnt
operator|=
name|inbuffer
operator|+
name|ipoint
expr_stmt|;
name|num
operator|-=
name|num2
expr_stmt|;
name|ipoint
operator|+=
name|num2
expr_stmt|;
while|while
condition|(
name|num2
operator|--
condition|)
operator|*
name|adr
operator|++
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	char *lgetw()			Get a whitespace ended word from input  *  *	Returns pointer to a buffer that contains word.  If EOF, returns a NULL  */
end_comment

begin_function
name|char
modifier|*
name|lgetw
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|lgp
decl_stmt|,
name|cc
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|LINBUFSIZE
decl_stmt|,
name|quote
init|=
literal|0
decl_stmt|;
name|lgp
operator|=
name|lgetwbuf
expr_stmt|;
do|do
name|cc
operator|=
name|lgetc
argument_list|()
expr_stmt|;
do|while
condition|(
operator|(
name|cc
operator|<=
literal|32
operator|)
operator|&&
operator|(
name|cc
operator|>
name|NULL
operator|)
condition|)
do|;
comment|/* eat whitespace */
for|for
control|(
init|;
condition|;
operator|--
name|n
operator|,
name|cc
operator|=
name|lgetc
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|cc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|lgp
operator|==
name|lgetwbuf
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* EOF */
if|if
condition|(
operator|(
name|n
operator|<=
literal|1
operator|)
operator|||
operator|(
operator|(
name|cc
operator|<=
literal|32
operator|)
operator|&&
operator|(
name|quote
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
operator|*
name|lgp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|lgetwbuf
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|!=
literal|'"'
condition|)
operator|*
name|lgp
operator|++
operator|=
name|cc
expr_stmt|;
else|else
name|quote
operator|^=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	char *lgetl()		Function to read in a line ended by newline or EOF  *  *	Returns pointer to a buffer that contains the line.  If EOF, returns NULL  */
end_comment

begin_function
name|char
modifier|*
name|lgetl
parameter_list|()
block|{
specifier|register
name|int
name|i
init|=
name|LINBUFSIZE
decl_stmt|,
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
init|=
name|lgetwbuf
decl_stmt|;
for|for
control|(
init|;
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|str
operator|++
operator|=
name|ch
operator|=
name|lgetc
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|str
operator|==
name|lgetwbuf
operator|+
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* EOF */
name|ot
label|:
operator|*
name|str
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|lgetwbuf
operator|)
return|;
comment|/* line ended by EOF */
block|}
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|i
operator|<=
literal|1
operator|)
condition|)
goto|goto
name|ot
goto|;
comment|/* line ended by \n */
block|}
block|}
end_function

begin_comment
comment|/*  *	lcreat(filename)			Create a new file for write  *		char *filename;  *  *	lcreat((char*)0); means to the terminal  *	Returns -1 if error, otherwise the file descriptor opened.  */
end_comment

begin_macro
name|lcreat
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lpnt
operator|=
name|lpbuf
expr_stmt|;
name|lpend
operator|=
name|lpbuf
operator|+
name|BUFBIG
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|lfd
operator|=
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|lfd
operator|=
name|creat
argument_list|(
name|str
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|lfd
operator|=
literal|1
expr_stmt|;
name|lprintf
argument_list|(
literal|"error creating file<%s>\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|lfd
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	lopen(filename)			Open a file for read  *		char *filename;  *  *	lopen(0) means from the terminal  *	Returns -1 if error, otherwise the file descriptor opened.  */
end_comment

begin_macro
name|lopen
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ipoint
operator|=
name|iepoint
operator|=
name|MAXIBUF
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|fd
operator|=
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|lwclose
argument_list|()
expr_stmt|;
name|lfd
operator|=
literal|1
expr_stmt|;
name|lpnt
operator|=
name|lpbuf
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	lappend(filename)		Open for append to an existing file  *		char *filename;  *  *	lappend(0) means to the terminal  *	Returns -1 if error, otherwise the file descriptor opened.  */
end_comment

begin_macro
name|lappend
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lpnt
operator|=
name|lpbuf
expr_stmt|;
name|lpend
operator|=
name|lpbuf
operator|+
name|BUFBIG
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|lfd
operator|=
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|lfd
operator|=
name|open
argument_list|(
name|str
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|lfd
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lseek
argument_list|(
name|lfd
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* seek to end of file */
return|return
operator|(
name|lfd
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	lrclose()						close the input file  *  *	Returns nothing of value.  */
end_comment

begin_macro
name|lrclose
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	lwclose()						close output file flushing if needed  *  *	Returns nothing of value.  */
end_comment

begin_macro
name|lwclose
argument_list|()
end_macro

begin_block
block|{
name|lflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|lfd
operator|>
literal|2
condition|)
name|close
argument_list|(
name|lfd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	lprcat(string)					append a string to the output buffer  *								    avoids calls to lprintf (time consuming)  */
end_comment

begin_expr_stmt
name|lprcat
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|str2
decl_stmt|;
if|if
condition|(
name|lpnt
operator|>=
name|lpend
condition|)
name|lflush
argument_list|()
expr_stmt|;
name|str2
operator|=
name|lpnt
expr_stmt|;
while|while
condition|(
operator|*
name|str2
operator|++
operator|=
operator|*
name|str
operator|++
condition|)
empty_stmt|;
name|lpnt
operator|=
name|str2
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VT100
end_ifdef

begin_comment
comment|/*  *	cursor(x,y) 		Subroutine to set the cursor position  *  *	x and y are the cursor coordinates, and lpbuff is the output buffer where  *	escape sequence will be placed.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|y_num
index|[]
init|=
block|{
literal|"\33["
block|,
literal|"\33["
block|,
literal|"\33[2"
block|,
literal|"\33[3"
block|,
literal|"\33[4"
block|,
literal|"\33[5"
block|,
literal|"\33[6"
block|,
literal|"\33[7"
block|,
literal|"\33[8"
block|,
literal|"\33[9"
block|,
literal|"\33[10"
block|,
literal|"\33[11"
block|,
literal|"\33[12"
block|,
literal|"\33[13"
block|,
literal|"\33[14"
block|,
literal|"\33[15"
block|,
literal|"\33[16"
block|,
literal|"\33[17"
block|,
literal|"\33[18"
block|,
literal|"\33[19"
block|,
literal|"\33[20"
block|,
literal|"\33[21"
block|,
literal|"\33[22"
block|,
literal|"\33[23"
block|,
literal|"\33[24"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|x_num
index|[]
init|=
block|{
literal|"H"
block|,
literal|"H"
block|,
literal|";2H"
block|,
literal|";3H"
block|,
literal|";4H"
block|,
literal|";5H"
block|,
literal|";6H"
block|,
literal|";7H"
block|,
literal|";8H"
block|,
literal|";9H"
block|,
literal|";10H"
block|,
literal|";11H"
block|,
literal|";12H"
block|,
literal|";13H"
block|,
literal|";14H"
block|,
literal|";15H"
block|,
literal|";16H"
block|,
literal|";17H"
block|,
literal|";18H"
block|,
literal|";19H"
block|,
literal|";20H"
block|,
literal|";21H"
block|,
literal|";22H"
block|,
literal|";23H"
block|,
literal|";24H"
block|,
literal|";25H"
block|,
literal|";26H"
block|,
literal|";27H"
block|,
literal|";28H"
block|,
literal|";29H"
block|,
literal|";30H"
block|,
literal|";31H"
block|,
literal|";32H"
block|,
literal|";33H"
block|,
literal|";34H"
block|,
literal|";35H"
block|,
literal|";36H"
block|,
literal|";37H"
block|,
literal|";38H"
block|,
literal|";39H"
block|,
literal|";40H"
block|,
literal|";41H"
block|,
literal|";42H"
block|,
literal|";43H"
block|,
literal|";44H"
block|,
literal|";45H"
block|,
literal|";46H"
block|,
literal|";47H"
block|,
literal|";48H"
block|,
literal|";49H"
block|,
literal|";50H"
block|,
literal|";51H"
block|,
literal|";52H"
block|,
literal|";53H"
block|,
literal|";54H"
block|,
literal|";55H"
block|,
literal|";56H"
block|,
literal|";57H"
block|,
literal|";58H"
block|,
literal|";59H"
block|,
literal|";60H"
block|,
literal|";61H"
block|,
literal|";62H"
block|,
literal|";63H"
block|,
literal|";64H"
block|,
literal|";65H"
block|,
literal|";66H"
block|,
literal|";67H"
block|,
literal|";68H"
block|,
literal|";69H"
block|,
literal|";70H"
block|,
literal|";71H"
block|,
literal|";72H"
block|,
literal|";73H"
block|,
literal|";74H"
block|,
literal|";75H"
block|,
literal|";76H"
block|,
literal|";77H"
block|,
literal|";78H"
block|,
literal|";79H"
block|,
literal|";80H"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|cursor
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|lpnt
operator|>=
name|lpend
condition|)
name|lflush
argument_list|()
expr_stmt|;
name|p
operator|=
name|y_num
index|[
name|y
index|]
expr_stmt|;
comment|/* get the string to print */
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|lpnt
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* print the string */
name|p
operator|=
name|x_num
index|[
name|x
index|]
expr_stmt|;
comment|/* get the string to print */
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|lpnt
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* print the string */
block|}
end_block

begin_else
else|#
directive|else
else|VT100
end_else

begin_comment
comment|/*  * cursor(x,y)	  Put cursor at specified coordinates staring at [1,1] (termcap)  */
end_comment

begin_macro
name|cursor
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lpnt
operator|>=
name|lpend
condition|)
name|lflush
argument_list|()
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
name|CURSOR
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
name|x
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
name|y
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VT100
end_endif

begin_comment
comment|/*  *	Routine to position cursor at beginning of 24th line  */
end_comment

begin_macro
name|cursors
argument_list|()
end_macro

begin_block
block|{
name|cursor
argument_list|(
literal|1
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|VT100
end_ifndef

begin_comment
comment|/*  * Warning: ringing the bell is control code 7. Don't use in defines.  * Don't change the order of these defines.  * Also used in helpfiles. Codes used in helpfiles should be \E[1 to \E[7 with  * obvious meanings.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CM
decl_stmt|,
modifier|*
name|CE
decl_stmt|,
modifier|*
name|CD
decl_stmt|,
modifier|*
name|CL
decl_stmt|,
modifier|*
name|SO
decl_stmt|,
modifier|*
name|SE
decl_stmt|,
modifier|*
name|AL
decl_stmt|,
modifier|*
name|DL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap capabilities */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translated output buffer */
end_comment

begin_function_decl
name|int
name|putchar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * init_term()		Terminal initialization -- setup termcap info  */
end_comment

begin_macro
name|init_term
argument_list|()
end_macro

begin_block
block|{
name|char
name|termbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|capptr
init|=
name|cap
operator|+
literal|10
decl_stmt|;
name|char
modifier|*
name|term
decl_stmt|;
name|struct
name|sgttyb
name|tt
decl_stmt|;
specifier|extern
name|short
name|ospeed
decl_stmt|;
switch|switch
condition|(
name|tgetent
argument_list|(
name|termbuf
argument_list|,
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"Cannot open termcap file.\n"
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"Cannot find entry of "
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|term
argument_list|,
name|strlen
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|" in termcap\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|tt
argument_list|)
operator|==
literal|0
condition|)
name|ospeed
operator|=
name|tt
operator|.
name|sg_ospeed
expr_stmt|;
name|CM
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* Cursor motion */
name|CE
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* Clear to eoln */
name|CL
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* Clear screen */
comment|/* OPTIONAL */
name|AL
operator|=
name|tgetstr
argument_list|(
literal|"al"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* Insert line */
name|DL
operator|=
name|tgetstr
argument_list|(
literal|"dl"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* Delete line */
name|SO
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* Begin standout mode */
name|SE
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* End standout mode */
name|CD
operator|=
name|tgetstr
argument_list|(
literal|"cd"
argument_list|,
operator|&
name|capptr
argument_list|)
expr_stmt|;
comment|/* Clear to end of display */
if|if
condition|(
operator|!
name|CM
condition|)
comment|/* can't find cursor motion entry */
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Sorry, for a "
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|term
argument_list|,
name|strlen
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|", I can't find the cursor motion entry in termcap\n"
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CE
condition|)
comment|/* can't find clear to end of line entry */
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Sorry, for a "
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|term
argument_list|,
name|strlen
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|", I can't find the clear to end of line entry in termcap\n"
argument_list|,
literal|57
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CL
condition|)
comment|/* can't find clear entire screen entry */
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Sorry, for a "
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|term
argument_list|,
name|strlen
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|", I can't find the clear entire screen entry in termcap\n"
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|outbuf
operator|=
name|malloc
argument_list|(
name|BUFBIG
operator|+
literal|16
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* get memory for decoded output buffer*/
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Error malloc'ing memory for decoded output buffer\n"
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|died
argument_list|(
operator|-
literal|285
argument_list|)
expr_stmt|;
comment|/* malloc() failure */
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VT100
end_endif

begin_comment
comment|/*  * cl_line(x,y)  Clear the whole line indicated by 'y' and leave cursor at [x,y]  */
end_comment

begin_macro
name|cl_line
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|VT100
name|cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\33[2K"
argument_list|)
expr_stmt|;
else|#
directive|else
else|VT100
name|cursor
argument_list|(
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
name|CL_LINE
expr_stmt|;
name|cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VT100
block|}
end_block

begin_comment
comment|/*  * cl_up(x,y) Clear screen from [x,1] to current position. Leave cursor at [x,y]  */
end_comment

begin_expr_stmt
name|cl_up
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|VT100
name|cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\33[1J\33[2K"
argument_list|)
expr_stmt|;
else|#
directive|else
else|VT100
specifier|register
name|int
name|i
decl_stmt|;
name|cursor
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|y
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|lpnt
operator|++
operator|=
name|CL_LINE
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
name|cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VT100
block|}
end_block

begin_comment
comment|/*  * cl_dn(x,y) 	Clear screen from [1,y] to end of display. Leave cursor at [x,y]  */
end_comment

begin_expr_stmt
name|cl_dn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|VT100
name|cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"\33[J\33[2K"
argument_list|)
expr_stmt|;
else|#
directive|else
else|VT100
specifier|register
name|int
name|i
decl_stmt|;
name|cursor
argument_list|(
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CD
condition|)
block|{
operator|*
name|lpnt
operator|++
operator|=
name|CL_LINE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|<=
literal|24
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|lpnt
operator|++
operator|=
name|CL_LINE
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|24
condition|)
operator|*
name|lpnt
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
name|cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|lpnt
operator|++
operator|=
name|CL_DOWN
expr_stmt|;
name|cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VT100
block|}
end_block

begin_comment
comment|/*  * standout(str)	Print the argument string in inverse video (standout mode).  */
end_comment

begin_expr_stmt
name|standout
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|VT100
name|setbold
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
operator|*
name|lpnt
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|resetbold
argument_list|()
expr_stmt|;
else|#
directive|else
else|VT100
operator|*
name|lpnt
operator|++
operator|=
name|ST_START
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
operator|*
name|lpnt
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
operator|*
name|lpnt
operator|++
operator|=
name|ST_END
expr_stmt|;
endif|#
directive|endif
endif|VT100
block|}
end_block

begin_comment
comment|/*  * set_score_output() 	Called when output should be literally printed.  */
end_comment

begin_macro
name|set_score_output
argument_list|()
end_macro

begin_block
block|{
name|enable_scroll
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	lflush()						Flush the output buffer  *  *	Returns nothing of value.  *	for termcap version: Flush output in output buffer according to output  *							status as indicated by `enable_scroll'  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VT100
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|scrline
init|=
literal|18
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line # for wraparound instead of scrolling if no DL */
end_comment

begin_macro
name|lflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|lpoint
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|static
name|int
name|curx
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|cury
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|lpoint
operator|=
name|lpnt
operator|-
name|lpbuf
operator|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|BYTESOUT
index|]
operator|+=
name|lpoint
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|enable_scroll
operator|<=
operator|-
literal|1
condition|)
block|{
name|flush_buf
argument_list|()
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|lfd
argument_list|,
name|lpbuf
argument_list|,
name|lpoint
argument_list|)
operator|!=
name|lpoint
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"error writing to output file\n"
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|lpnt
operator|=
name|lpbuf
expr_stmt|;
comment|/* point back to beginning of buffer */
return|return;
block|}
for|for
control|(
name|str
operator|=
name|lpbuf
init|;
name|str
operator|<
name|lpnt
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|>=
literal|32
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|curx
operator|++
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
name|CLEAR
case|:
name|tputs
argument_list|(
name|CL
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CL_LINE
case|:
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
break|break;
case|case
name|CL_DOWN
case|:
name|tputs
argument_list|(
name|CD
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_START
case|:
name|tputs
argument_list|(
name|SO
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_END
case|:
name|tputs
argument_list|(
name|SE
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
break|break;
case|case
name|CURSOR
case|:
name|curx
operator|=
operator|*
operator|++
name|str
operator|-
literal|1
expr_stmt|;
name|cury
operator|=
operator|*
operator|++
name|str
operator|-
literal|1
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
name|curx
argument_list|,
name|cury
argument_list|)
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
operator|(
name|cury
operator|==
literal|23
operator|)
operator|&&
name|enable_scroll
condition|)
block|{
if|if
condition|(
operator|!
name|DL
operator|||
operator|!
name|AL
condition|)
comment|/* wraparound or scroll? */
block|{
if|if
condition|(
operator|++
name|scrline
operator|>
literal|23
condition|)
name|scrline
operator|=
literal|19
expr_stmt|;
if|if
condition|(
operator|++
name|scrline
operator|>
literal|23
condition|)
name|scrline
operator|=
literal|19
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
name|scrline
argument_list|)
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|scrline
operator|<
literal|19
condition|)
name|scrline
operator|=
literal|23
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
name|scrline
argument_list|)
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
literal|19
argument_list|)
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|DL
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
comment|/*	tputs (AL, 0, putchar); */
block|}
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|cury
operator|++
expr_stmt|;
block|}
name|curx
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|curx
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
name|lpnt
operator|=
name|lpbuf
expr_stmt|;
name|flush_buf
argument_list|()
expr_stmt|;
comment|/* flush real output buffer now */
block|}
end_block

begin_else
else|#
directive|else
else|VT100
end_else

begin_comment
comment|/*  *	lflush()						flush the output buffer  *  *	Returns nothing of value.  */
end_comment

begin_macro
name|lflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|lpoint
decl_stmt|;
if|if
condition|(
operator|(
name|lpoint
operator|=
name|lpnt
operator|-
name|lpbuf
operator|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EXTRA
name|c
index|[
name|BYTESOUT
index|]
operator|+=
name|lpoint
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write
argument_list|(
name|lfd
argument_list|,
name|lpbuf
argument_list|,
name|lpoint
argument_list|)
operator|!=
name|lpoint
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"error writing to output file\n"
argument_list|,
literal|29
argument_list|)
expr_stmt|;
block|}
name|lpnt
operator|=
name|lpbuf
expr_stmt|;
comment|/* point back to beginning of buffer */
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VT100
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VT100
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|pindex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * putchar(ch)		Print one character in decoded output buffer.  */
end_comment

begin_function
name|int
name|putchar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|outbuf
index|[
name|pindex
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|pindex
operator|>=
name|BUFBIG
condition|)
name|flush_buf
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * flush_buf()			Flush buffer with decoded output.  */
end_comment

begin_macro
name|flush_buf
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|pindex
condition|)
name|write
argument_list|(
name|lfd
argument_list|,
name|outbuf
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
name|pindex
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	char *tmcapcnv(sd,ss)  Routine to convert VT100 escapes to termcap format  *  *	Processes only the \33[#m sequence (converts . files for termcap use  */
end_comment

begin_function
name|char
modifier|*
name|tmcapcnv
parameter_list|(
name|sd
parameter_list|,
name|ss
parameter_list|)
specifier|register
name|char
modifier|*
name|sd
decl_stmt|,
decl|*
name|ss
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|tmstate
init|=
literal|0
decl_stmt|;
comment|/* 0=normal, 1=\33 2=[ 3=# */
name|char
name|tmdigit
init|=
literal|0
decl_stmt|;
comment|/* the # in \33[#m */
while|while
condition|(
operator|*
name|ss
condition|)
block|{
switch|switch
condition|(
name|tmstate
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|*
name|ss
operator|==
literal|'\33'
condition|)
block|{
name|tmstate
operator|++
expr_stmt|;
break|break;
block|}
name|ign
label|:
operator|*
name|sd
operator|++
operator|=
operator|*
name|ss
expr_stmt|;
name|ign2
label|:
name|tmstate
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|*
name|ss
operator|!=
literal|'['
condition|)
goto|goto
name|ign
goto|;
name|tmstate
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|ss
argument_list|)
condition|)
block|{
name|tmdigit
operator|=
operator|*
name|ss
operator|-
literal|'0'
expr_stmt|;
name|tmstate
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|ss
operator|==
literal|'m'
condition|)
block|{
operator|*
name|sd
operator|++
operator|=
name|ST_END
expr_stmt|;
goto|goto
name|ign2
goto|;
block|}
goto|goto
name|ign
goto|;
case|case
literal|3
case|:
if|if
condition|(
operator|*
name|ss
operator|==
literal|'m'
condition|)
block|{
if|if
condition|(
name|tmdigit
condition|)
operator|*
name|sd
operator|++
operator|=
name|ST_START
expr_stmt|;
else|else
operator|*
name|sd
operator|++
operator|=
name|ST_END
expr_stmt|;
goto|goto
name|ign2
goto|;
block|}
default|default:
goto|goto
name|ign
goto|;
block|}
empty_stmt|;
name|ss
operator|++
expr_stmt|;
block|}
operator|*
name|sd
operator|=
literal|0
expr_stmt|;
comment|/* NULL terminator */
return|return
operator|(
name|sd
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VT100
end_endif

begin_comment
comment|/*  *	beep()		Routine to emit a beep if enabled (see no-beep in .larnopts)  */
end_comment

begin_macro
name|beep
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|nobeep
condition|)
operator|*
name|lpnt
operator|++
operator|=
literal|'\7'
expr_stmt|;
block|}
end_block

end_unit

